{"repository":"biojava","prod_path":"biojava3-core/src/main/java/org/biojava3/core/sequence/io/GenbankReader.java","test_path":"biojava3-core/src/test/java/org/biojava3/core/sequence/io/GenbankReaderTest.java","prod_time":"2013-08-05 04:28:38","test_time":"2013-08-05 04:28:38","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":16,"add_classname_line":1,"add_condition_line":4,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":1,"del_condition_line":0,"del_field_line":1,"del_import_line":6,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"POSITIVE","prod_commitID":"0bed2ad3ea40bc5f3dc955a517505ea1feab2b57","test_commitID":"0bed2ad3ea40bc5f3dc955a517505ea1feab2b57","isfound":"found test change","originPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on 01-21-2010\r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.TreeSet;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.biojava3.core.sequence.AccessionID;\r\nimport org.biojava3.core.sequence.DataSource;\r\nimport org.biojava3.core.sequence.ProteinSequence;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\r\nimport org.biojava3.core.sequence.io.template.GenbankHeaderParserInterface;\r\nimport org.biojava3.core.sequence.io.template.SequenceCreatorInterface;\r\nimport org.biojava3.core.sequence.template.AbstractSequence;\r\nimport org.biojava3.core.sequence.template.Compound;\r\nimport org.biojava3.core.sequence.template.Sequence;\r\nimport org.biojava3.core.sequence.template.AbstractSequence.AnnotationType;\r\nimport org.biojava3.core.exceptions.ParserException;\r\n\r\n/**\r\n * Use GenbankReaderHelper as an example of how to use this class where GenbankReaderHelper should be the\r\n * primary class used to read Genbank files\r\n * -- copied from original FastReader by Scooter Willis ;lt;willishf at gmail dot com&gt;\r\n * @author Karl Nicholas \r\n\r\n */\r\npublic class GenbankReader<S extends AbstractSequence<C>, C extends Compound> {\r\n\r\n    /**\r\n     * The name of this format\r\n     */\r\n    public static final String GENBANK_FORMAT = \"GENBANK\";\r\n    \r\n    protected static final String LOCUS_TAG =           \"LOCUS\";\r\n    protected static final String DEFINITION_TAG =      \"DEFINITION\";\r\n    protected static final String ACCESSION_TAG =       \"ACCESSION\";\r\n    protected static final String VERSION_TAG =         \"VERSION\";\r\n    protected static final String KEYWORDS_TAG =        \"KEYWORDS\";\r\n    //                                                  \"SEGMENT\"\r\n    protected static final String SOURCE_TAG =          \"SOURCE\";\r\n    protected static final String ORGANISM_TAG =        \"ORGANISM\";\r\n    protected static final String REFERENCE_TAG =       \"REFERENCE\";\r\n    protected static final String AUTHORS_TAG =         \"AUTHORS\";\r\n    protected static final String CONSORTIUM_TAG =      \"CONSRTM\";\r\n    protected static final String TITLE_TAG =           \"TITLE\";\r\n    protected static final String JOURNAL_TAG =         \"JOURNAL\";\r\n    protected static final String PUBMED_TAG =          \"PUBMED\";\r\n    protected static final String MEDLINE_TAG =         \"MEDLINE\"; //deprecated\r\n    protected static final String REMARK_TAG =          \"REMARK\";\r\n    protected static final String COMMENT_TAG =         \"COMMENT\";\r\n    protected static final String FEATURE_TAG =         \"FEATURES\";\r\n    protected static final String BASE_COUNT_TAG_FULL = \"BASE COUNT\"; //deprecated\r\n    protected static final String BASE_COUNT_TAG =      \"BASE\";\r\n    //                                                  \"CONTIG\"\r\n    protected static final String START_SEQUENCE_TAG =  \"ORIGIN\";\r\n    protected static final String END_SEQUENCE_TAG =    \"//\";\r\n    // locus line\r\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+)\\\\s+\\\\d+\\\\s+(bp|aa)\\\\s{1,4}([dms]s-)?(\\\\S+)?\\\\s+(circular|linear)?\\\\s*(\\\\S+)?\\\\s*(\\\\S+)?$\");\r\n    // version line\r\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S*?)(\\\\.(\\\\d+))?(\\\\s+GI:(\\\\S+))?$\");\r\n    // reference line\r\n    protected static final Pattern refRange = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+to\\\\s+(\\\\d+)$\");\r\n    protected static final Pattern refp = Pattern.compile(\"^(\\\\d+)\\\\s*(?:(\\\\((?:bases|residues)\\\\s+(\\\\d+\\\\s+to\\\\s+\\\\d+(\\\\s*;\\\\s*\\\\d+\\\\s+to\\\\s+\\\\d+)*)\\\\))|\\\\(sites\\\\))?\");\r\n    // dbxref line\r\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\r\n    //sections start at a line and continue till the first line afterwards with a\r\n    //non-whitespace first character\r\n    //we want to match any of the following as a new section within a section\r\n    //  \\s{0,8} word \\s{0,7} value\r\n    //  \\s{21} /word = value\r\n    //  \\s{21} /word\r\n    protected static final Pattern sectp = Pattern.compile(\"^(\\\\s{0,8}(\\\\S+)\\\\s{0,7}(.*)|\\\\s{21}(/\\\\S+?)=(.*)|\\\\s{21}(/\\\\S+))$\");\r\n    \r\n    protected static final Pattern readableFiles = Pattern.compile(\".*(g[bp]k*$|\\\\u002eg[bp].*)\");\r\n    protected static final Pattern headerLine = Pattern.compile(\"^LOCUS.*\");\r\n\r\n    SequenceCreatorInterface<C> sequenceCreator;\r\n    GenbankHeaderParserInterface<S,C> headerParser;\r\n    BufferedReaderBytesRead br;\r\n    InputStreamReader isr;\r\n    FileInputStream fi = null;\r\n    long fileIndex = 0;\r\n    long sequenceIndex = 0;\r\n    String line = \"\";\r\n    String header= \"\";\r\n    \r\n    /**\r\n     * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\r\n     * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\r\n     * an inputstream is forced to read all the data so you don't gain anything.\r\n     * @param br\r\n     * @param headerParser\r\n     * @param sequenceCreator\r\n     */\r\n    public GenbankReader(InputStream is, GenbankHeaderParserInterface<S,C> headerParser,\r\n    \t\tSequenceCreatorInterface<C> sequenceCreator) {\r\n        this.headerParser = headerParser;\r\n        isr = new InputStreamReader(is);\r\n        this.br = new BufferedReaderBytesRead(isr);\r\n        this.sequenceCreator = sequenceCreator;\r\n    }\r\n\r\n    /**\r\n     * If you are going to use the FileProxyProteinSequenceCreator then you\r\n     * need to use this constructor because we need details about\r\n     * the location of the file.\r\n     * @param file\r\n     * @param headerParser\r\n     * @param sequenceCreator\r\n     * @throws FileNotFoundException if the file does not exist, is a directory \r\n     * \trather than a regular file, or for some other reason cannot be opened\r\n     * \tfor reading.\r\n     * @throws SecurityException if a security manager exists and its checkRead\r\n     * \tmethod denies read access to the file.\r\n     */\r\n    public GenbankReader(File file, GenbankHeaderParserInterface<S,C> headerParser, \r\n    \t\tSequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\r\n        this.headerParser = headerParser;\r\n        fi = new FileInputStream(file);\r\n        isr = new InputStreamReader(fi);\r\n        this.br = new BufferedReaderBytesRead(isr);\r\n        this.sequenceCreator = sequenceCreator;\r\n    }\r\n\r\n    /**\r\n     * The parsing is done in this method.<br>\r\n     * This method tries to process all the available Genbank records \r\n     * in the File or InputStream, closes the underlying resource, \r\n     * and return the results in {@link LinkedHashMap}.<br>\r\n     * You don't need to call {@link #close()} after calling this method.\r\n     * @see #process(int)\r\n     * @return {@link HashMap} containing all the parsed Genbank records \r\n     * present, starting current fileIndex onwards.\r\n     * @throws IOException if an error occurs reading the input file\r\n     */\r\n    public LinkedHashMap<String,S> process() throws IOException {\r\n    \tLinkedHashMap<String,S> sequences = process(-1);\r\n    \tclose();\r\n    \treturn sequences;\r\n    }\r\n\r\n    private String sectionKey = null;\r\n//    private NCBITaxon tax = null;\r\n    private String accession = null;\r\n    private String identifier = null;\r\n    private String seqName = null;\r\n\r\n\r\n    /**\r\n     * This method tries to parse maximum <code>max</code> records from\r\n     * the open File or InputStream, and leaves the underlying resource open.<br>\r\n     * Subsequent calls to the same method continue parsing the rest of the file.<br>\r\n     * This is particularly useful when dealing with very big data files,\r\n     * (e.g. NCBI nr database), which can't fit into memory and will take long\r\n     * time before the first result is available.<br>\r\n     * <b>N.B.</b>\r\n     * <ul>\r\n     * <li>This method ca't be called after calling its NO-ARGUMENT twin.</li> \r\n     * <li>remember to close the underlying resource when you are done.</li> \r\n     * </ul>\r\n     * @see #process()\r\n     * @author Amr AL-Hossary\r\n     * @since 3.0.6\r\n     * @param max maximum number of records to return, <code>-1</code> for infinity.\r\n     * @return {@link HashMap} containing maximum <code>max</code> parsed Genbank records \r\n     * present, starting current fileIndex onwards.\r\n     * @throws IOException if an error occurs reading the input file\r\n     */\r\n    public LinkedHashMap<String,S> process(int max) throws IOException {\r\n        LinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\r\n\r\n        // Get an ordered list of key->value pairs in array-tuples\r\n        List section = null;\r\n        try{\r\n            do {\r\n                section = this.readSection();\r\n                sectionKey = ((String[])section.get(0))[0];\r\n                if(sectionKey == null){\r\n                    throw new ParserException(\"Section key was null\");\r\n                }\r\n                // process section-by-section\r\n                if (sectionKey.equals(LOCUS_TAG)) {\r\n                    String loc = ((String[])section.get(0))[1];\r\n                    header = loc;\r\n                    Matcher m = lp.matcher(loc);\r\n                    if (m.matches()) {\r\n                    \tseqName = m.group(1);\r\n                    }\r\n                } else if (sectionKey.equals(DEFINITION_TAG)) {\r\n                } else if (sectionKey.equals(ACCESSION_TAG)) {\r\n                    // if multiple accessions, store only first as accession,\r\n                    // and store rest in annotation\r\n                    String[] accs = ((String[])section.get(0))[1].split(\"\\\\s+\");\r\n                    accession = accs[0].trim();\r\n                } else if (sectionKey.equals(VERSION_TAG)) {\r\n                } else if (sectionKey.equals(KEYWORDS_TAG)) {\r\n                } else if (sectionKey.equals(SOURCE_TAG)) {\r\n                    // ignore - can get all this from the first feature\r\n                } else if (sectionKey.equals(REFERENCE_TAG) ) {\r\n                } else if (sectionKey.equals(COMMENT_TAG) ) {\r\n                } else if (sectionKey.equals(FEATURE_TAG) ) {\r\n                } else if (sectionKey.equals(BASE_COUNT_TAG)) {\r\n                    // ignore - can calculate from sequence content later if needed\r\n                } else if (sectionKey.equals(START_SEQUENCE_TAG) ) {\r\n\r\n                \t// our first line is ignorable as it is the ORIGIN tag\r\n                    // the second line onwards conveniently have the number as\r\n                    // the [0] tuple, and sequence string as [1] so all we have\r\n                    // to do is concat the [1] parts and then strip out spaces,\r\n                    // and replace '.' and '~' with '-' for our parser.\r\n                \tStringBuffer seq = new StringBuffer();\r\n                    for (int i = 1 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\r\n                \tString seqData = seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\").toUpperCase();\r\n\r\n                    S sequence = (S)sequenceCreator.getSequence(seqData, sequenceIndex);\r\n                    headerParser.parseHeader(header, sequence);\r\n                    sequence.setOriginalHeader(seqName);\r\n                    sequence.setAccession(new AccessionID(accession));\r\n                    \r\n                    sequences.put(sequence.getAccession().getID(),sequence);\r\n                }\r\n            } while (!sectionKey.equals(END_SEQUENCE_TAG));\r\n        } catch(RuntimeException e) {\r\n            throw new ParserException(\"Bad sequence section\");\r\n        }\r\n        return sequences;\r\n        \r\n        /*\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        int processedSequences=0;\r\n        boolean keepGoing = true;\r\n\r\n        do {\r\n            line = line.trim(); // nice to have but probably not needed\r\n            if (line.length() != 0) {\r\n                if (line.startsWith(\">\")) {\r\n                    if (sb.length() > 0) {//i.e. if there is already a sequence before\r\n                    //    System.out.println(\"Sequence index=\" + sequenceIndex);\r\n                    \t@SuppressWarnings(\"unchecked\")\r\n                        S sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\r\n                        headerParser.parseHeader(header, sequence);\r\n                        sequences.put(sequence.getAccession().getID(),sequence);\r\n                        processedSequences++;\r\n//                        if (maxSequenceLength < sb.length()) {\r\n//                            maxSequenceLength = sb.length();\r\n//                        }\r\n//                        sb = new StringBuilder(maxSequenceLength);\r\n                        sb.setLength(0); //this is faster, better memory utilization (same buffer)\r\n                    }\r\n                    header = line.substring(1);\r\n                } else if (line.startsWith(\";\")) {\r\n                } else {\r\n                    //mark the start of the sequence with the fileIndex before the line was read\r\n                    if(sb.length() == 0){\r\n                        sequenceIndex = fileIndex;\r\n                    }\r\n                    sb.append(line);\r\n                }\r\n            }\r\n            fileIndex = br.getBytesRead();\r\n            line = br.readLine();\r\n\t\t\tif (line == null) {//i.e. EOF\r\n\t\t\t\t@SuppressWarnings(\"unchecked\")\r\n\t\t\t\t//    System.out.println(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\r\n                S sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\r\n                headerParser.parseHeader(header, sequence);\r\n                sequences.put(sequence.getAccession().getID(),sequence);\r\n                processedSequences++;\r\n                keepGoing = false;\r\n            }\r\n\t\t\tif (max > -1 && processedSequences>=max) {\r\n\t\t\t\tkeepGoing=false;\r\n\t\t\t}\r\n        } while (keepGoing);\r\n        this.line  = line;\r\n        this.header= header;\r\n        return sequences;\r\n*/        \r\n    }\r\n\r\n\t// reads an indented section, combining split lines and creating a list of\r\n\t// key->value tuples\r\n\tprivate List<String[]> readSection() {\r\n\t\tList<String[]> section = new ArrayList<String[]>();\r\n\t\tString line = \"\";\r\n\t\tString currKey = null;\r\n\t\tStringBuffer currVal = new StringBuffer();\r\n\t\tboolean done = false;\r\n\t\tint linecount = 0;\r\n\r\n\t\ttry {\r\n\t\t\twhile (!done) {\r\n\t\t\t\tbr.mark(320);\r\n\t\t\t\tline = br.readLine();\r\n\t\t\t\tString firstSecKey = section.isEmpty() ? \"\"\r\n\t\t\t\t\t\t: ((String[]) section.get(0))[0];\r\n\t\t\t\tif (line != null && line.matches(\"\\\\p{Space}*\")) {\r\n\t\t\t\t\t// regular expression \\p{Space}* will match line\r\n\t\t\t\t\t// having only white space characters\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (line == null\r\n\t\t\t\t\t\t|| (!line.startsWith(\" \") && linecount++ > 0 && (!firstSecKey\r\n\t\t\t\t\t\t\t\t.equals(START_SEQUENCE_TAG) || line\r\n\t\t\t\t\t\t\t\t.startsWith(END_SEQUENCE_TAG)))) {\r\n\t\t\t\t\t// dump out last part of section\r\n\t\t\t\t\tsection.add(new String[] { currKey, currVal.toString() });\r\n\t\t\t\t\tbr.reset();\r\n\t\t\t\t\tdone = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMatcher m = sectp.matcher(line);\r\n\t\t\t\t\tif (m.matches()) {\r\n\t\t\t\t\t\t// new key\r\n\t\t\t\t\t\tif (currKey != null)\r\n\t\t\t\t\t\t\tsection.add(new String[] { currKey,\r\n\t\t\t\t\t\t\t\t\tcurrVal.toString() });\r\n\t\t\t\t\t\t// key = group(2) or group(4) or group(6) - whichever is\r\n\t\t\t\t\t\t// not null\r\n\t\t\t\t\t\tcurrKey = m.group(2) == null ? (m.group(4) == null ? m\r\n\t\t\t\t\t\t\t\t.group(6) : m.group(4)) : m.group(2);\r\n\t\t\t\t\t\tcurrVal = new StringBuffer();\r\n\t\t\t\t\t\t// val = group(3) if group(2) not null, group(5) if\r\n\t\t\t\t\t\t// group(4) not null, \"\" otherwise, trimmed\r\n\t\t\t\t\t\tcurrVal.append((m.group(2) == null ? (m.group(4) == null ? \"\"\r\n\t\t\t\t\t\t\t\t: m.group(5))\r\n\t\t\t\t\t\t\t\t: m.group(3)).trim());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// concatted line or SEQ START/END line?\r\n\t\t\t\t\t\tif (line.startsWith(START_SEQUENCE_TAG)\r\n\t\t\t\t\t\t\t\t|| line.startsWith(END_SEQUENCE_TAG))\r\n\t\t\t\t\t\t\tcurrKey = line;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tcurrVal.append(\"\\n\"); // newline in between lines -\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// can be removed later\r\n\t\t\t\t\t\t\tcurrVal.append(currKey.charAt(0) == '/' ? line\r\n\t\t\t\t\t\t\t\t\t.substring(21) : line.substring(12));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new ParserException(e.getMessage());\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tthrow new ParserException(e.getMessage());\r\n\t\t}\r\n\t\treturn section;\r\n\t}\r\n\r\n\tpublic void close() throws IOException {\r\n\t\tbr.close();\r\n        isr.close();\r\n        //If stream was created from File object then we need to close it\r\n        if (fi != null) {\r\n            fi.close();\r\n        }\r\n        this.line=this.header = null;\r\n\t}\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            String inputFile = \"src/test/resources/PF00104_small.Genbank\";\r\n            FileInputStream is = new FileInputStream(inputFile);\r\n\r\n            GenbankReader<ProteinSequence, AminoAcidCompound> GenbankReader = new GenbankReader<ProteinSequence, AminoAcidCompound>(is, new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n            LinkedHashMap<String,ProteinSequence> proteinSequences = GenbankReader.process();\r\n            is.close();\r\n\r\n\r\n            System.out.println(proteinSequences);\r\n\r\n            File file = new File(inputFile);\r\n            GenbankReader<ProteinSequence,AminoAcidCompound> GenbankProxyReader = new GenbankReader<ProteinSequence,AminoAcidCompound>(file, new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), new FileProxyProteinSequenceCreator(file, AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n            LinkedHashMap<String,ProteinSequence> proteinProxySequences = GenbankProxyReader.process();\r\n\r\n            for(String key : proteinProxySequences.keySet()){\r\n                ProteinSequence proteinSequence = proteinProxySequences.get(key);\r\n                System.out.println(key);\r\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\r\n//                    int dummy = 1;\r\n//                }\r\n                System.out.println(proteinSequence.toString());\r\n\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n","changedPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on 01-21-2010\r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.io.InputStreamReader;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.LinkedHashMap;\r\nimport java.util.List;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n\r\nimport org.biojava3.core.sequence.ProteinSequence;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\r\nimport org.biojava3.core.sequence.io.template.GenbankHeaderParserInterface;\r\nimport org.biojava3.core.sequence.io.template.SequenceCreatorInterface;\r\nimport org.biojava3.core.sequence.template.Compound;\r\nimport org.biojava3.core.sequence.template.Sequence;\r\nimport org.biojava3.core.exceptions.ParserException;\r\n\r\n/**\r\n * Use GenbankReaderHelper as an example of how to use this class where GenbankReaderHelper should be the\r\n * primary class used to read Genbank files\r\n * -- copied from original FastReader by Scooter Willis ;lt;willishf at gmail dot com&gt;\r\n * @author Karl Nicholas \r\n\r\n */\r\npublic class GenbankReader<S extends Sequence<?>, C extends Compound> {\r\n\r\n    /**\r\n     * The name of this format\r\n     */\r\n    public static final String GENBANK_FORMAT = \"GENBANK\";\r\n    \r\n    protected static final String LOCUS_TAG =           \"LOCUS\";\r\n    protected static final String DEFINITION_TAG =      \"DEFINITION\";\r\n    protected static final String ACCESSION_TAG =       \"ACCESSION\";\r\n    protected static final String VERSION_TAG =         \"VERSION\";\r\n    protected static final String KEYWORDS_TAG =        \"KEYWORDS\";\r\n    //                                                  \"SEGMENT\"\r\n    protected static final String SOURCE_TAG =          \"SOURCE\";\r\n    protected static final String ORGANISM_TAG =        \"ORGANISM\";\r\n    protected static final String REFERENCE_TAG =       \"REFERENCE\";\r\n    protected static final String AUTHORS_TAG =         \"AUTHORS\";\r\n    protected static final String CONSORTIUM_TAG =      \"CONSRTM\";\r\n    protected static final String TITLE_TAG =           \"TITLE\";\r\n    protected static final String JOURNAL_TAG =         \"JOURNAL\";\r\n    protected static final String PUBMED_TAG =          \"PUBMED\";\r\n    protected static final String MEDLINE_TAG =         \"MEDLINE\"; //deprecated\r\n    protected static final String REMARK_TAG =          \"REMARK\";\r\n    protected static final String COMMENT_TAG =         \"COMMENT\";\r\n    protected static final String FEATURE_TAG =         \"FEATURES\";\r\n    protected static final String BASE_COUNT_TAG_FULL = \"BASE COUNT\"; //deprecated\r\n    protected static final String BASE_COUNT_TAG =      \"BASE\";\r\n    //                                                  \"CONTIG\"\r\n    protected static final String START_SEQUENCE_TAG =  \"ORIGIN\";\r\n    protected static final String END_SEQUENCE_TAG =    \"//\";\r\n    // locus line\r\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+)\\\\s+\\\\d+\\\\s+(bp|aa)\\\\s{1,4}([dms]s-)?(\\\\S+)?\\\\s+(circular|linear)?\\\\s*(\\\\S+)?\\\\s*(\\\\S+)?$\");\r\n    // version line\r\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S*?)(\\\\.(\\\\d+))?(\\\\s+GI:(\\\\S+))?$\");\r\n    // reference line\r\n    protected static final Pattern refRange = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+to\\\\s+(\\\\d+)$\");\r\n    protected static final Pattern refp = Pattern.compile(\"^(\\\\d+)\\\\s*(?:(\\\\((?:bases|residues)\\\\s+(\\\\d+\\\\s+to\\\\s+\\\\d+(\\\\s*;\\\\s*\\\\d+\\\\s+to\\\\s+\\\\d+)*)\\\\))|\\\\(sites\\\\))?\");\r\n    // dbxref line\r\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\r\n    //sections start at a line and continue till the first line afterwards with a\r\n    //non-whitespace first character\r\n    //we want to match any of the following as a new section within a section\r\n    //  \\s{0,8} word \\s{0,7} value\r\n    //  \\s{21} /word = value\r\n    //  \\s{21} /word\r\n    protected static final Pattern sectp = Pattern.compile(\"^(\\\\s{0,8}(\\\\S+)\\\\s{0,7}(.*)|\\\\s{21}(/\\\\S+?)=(.*)|\\\\s{21}(/\\\\S+))$\");\r\n    \r\n    protected static final Pattern readableFiles = Pattern.compile(\".*(g[bp]k*$|\\\\u002eg[bp].*)\");\r\n    protected static final Pattern headerLine = Pattern.compile(\"^LOCUS.*\");\r\n\r\n    SequenceCreatorInterface<?> sequenceCreator;\r\n    GenbankHeaderParserInterface<S,C> headerParser;\r\n    BufferedReaderBytesRead br;\r\n    InputStreamReader isr;\r\n    FileInputStream fi = null;\r\n    long fileIndex = 0;\r\n    long sequenceIndex = 0;\r\n    String line = \"\";\r\n    String header= \"\";\r\n    \r\n    /**\r\n     * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\r\n     * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\r\n     * an inputstream is forced to read all the data so you don't gain anything.\r\n     * @param br\r\n     * @param headerParser\r\n     * @param sequenceCreator\r\n     */\r\n    public GenbankReader(InputStream is, GenbankHeaderParserInterface<S,C> headerParser,\r\n    \t\tSequenceCreatorInterface<?> sequenceCreator) {\r\n        this.headerParser = headerParser;\r\n        isr = new InputStreamReader(is);\r\n        this.br = new BufferedReaderBytesRead(isr);\r\n        this.sequenceCreator = sequenceCreator;\r\n    }\r\n\r\n    /**\r\n     * If you are going to use the FileProxyProteinSequenceCreator then you\r\n     * need to use this constructor because we need details about\r\n     * the location of the file.\r\n     * @param file\r\n     * @param headerParser\r\n     * @param sequenceCreator\r\n     * @throws FileNotFoundException if the file does not exist, is a directory \r\n     * \trather than a regular file, or for some other reason cannot be opened\r\n     * \tfor reading.\r\n     * @throws SecurityException if a security manager exists and its checkRead\r\n     * \tmethod denies read access to the file.\r\n     */\r\n    public GenbankReader(File file, GenbankHeaderParserInterface<S,C> headerParser, \r\n    \t\tSequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\r\n        this.headerParser = headerParser;\r\n        fi = new FileInputStream(file);\r\n        isr = new InputStreamReader(fi);\r\n        this.br = new BufferedReaderBytesRead(isr);\r\n        this.sequenceCreator = sequenceCreator;\r\n    }\r\n\r\n    /**\r\n     * The parsing is done in this method.<br>\r\n     * This method tries to process all the available Genbank records \r\n     * in the File or InputStream, closes the underlying resource, \r\n     * and return the results in {@link LinkedHashMap}.<br>\r\n     * You don't need to call {@link #close()} after calling this method.\r\n     * @see #process(int)\r\n     * @return {@link HashMap} containing all the parsed Genbank records \r\n     * present, starting current fileIndex onwards.\r\n     * @throws IOException if an error occurs reading the input file\r\n     */\r\n    public LinkedHashMap<String,S> process() throws IOException {\r\n    \tLinkedHashMap<String,S> sequences = process(-1);\r\n    \tclose();\r\n    \treturn sequences;\r\n    }\r\n\r\n    private String sectionKey = null;\r\n//    private NCBITaxon tax = null;\r\n    private String accession = null;\r\n    private String identifier = null;\r\n    private String seqName = null;\r\n\r\n\r\n    /**\r\n     * This method tries to parse maximum <code>max</code> records from\r\n     * the open File or InputStream, and leaves the underlying resource open.<br>\r\n     * Subsequent calls to the same method continue parsing the rest of the file.<br>\r\n     * This is particularly useful when dealing with very big data files,\r\n     * (e.g. NCBI nr database), which can't fit into memory and will take long\r\n     * time before the first result is available.<br>\r\n     * <b>N.B.</b>\r\n     * <ul>\r\n     * <li>This method ca't be called after calling its NO-ARGUMENT twin.</li> \r\n     * <li>remember to close the underlying resource when you are done.</li> \r\n     * </ul>\r\n     * @see #process()\r\n     * @author Amr AL-Hossary\r\n     * @since 3.0.6\r\n     * @param max maximum number of records to return, <code>-1</code> for infinity.\r\n     * @return {@link HashMap} containing maximum <code>max</code> parsed Genbank records \r\n     * present, starting current fileIndex onwards.\r\n     * @throws IOException if an error occurs reading the input file\r\n     */\r\n    public LinkedHashMap<String,S> process(int max) throws IOException {\r\n        LinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\r\n\r\n        // Get an ordered list of key->value pairs in array-tuples\r\n        List section = null;\r\n        try{\r\n            do {\r\n                section = this.readSection();\r\n                sectionKey = ((String[])section.get(0))[0];\r\n                if(sectionKey == null){\r\n                    throw new ParserException(\"Section key was null\");\r\n                }\r\n                // process section-by-section\r\n                if (sectionKey.equals(LOCUS_TAG)) {\r\n                    String loc = ((String[])section.get(0))[1];\r\n                    Matcher m = lp.matcher(loc);\r\n                    if (m.matches()) {\r\n                    \theaderParser.setName(m.group(1));\r\n                        accession = m.group(1); // default if no accession found\r\n                        headerParser.setAccession(accession);\r\n                    } else {\r\n                        throw new ParserException(\"Bad locus line\");\r\n                    }\r\n                } else if (sectionKey.equals(DEFINITION_TAG)) {\r\n                \theaderParser.setDescription(((String[])section.get(0))[1]);\r\n                } else if (sectionKey.equals(ACCESSION_TAG)) {\r\n                    // if multiple accessions, store only first as accession,\r\n                    // and store rest in annotation\r\n                    String[] accs = ((String[])section.get(0))[1].split(\"\\\\s+\");\r\n                    accession = accs[0].trim();\r\n                    headerParser.setAccession(accession);\r\n                } else if (sectionKey.equals(VERSION_TAG)) {\r\n                    String ver = ((String[])section.get(0))[1];\r\n                    Matcher m = vp.matcher(ver);\r\n                    if (m.matches()) {\r\n                        String verAcc = m.group(1);\r\n                        if (!accession.equals(verAcc)) {\r\n                            // the version refers to a different accession!\r\n                            // believe the version line, and store the original\r\n                            // accession away in the additional accession set\r\n                            accession = verAcc;\r\n                            headerParser.setAccession(accession);\r\n                        }\r\n                        if (m.group(3)!=null) headerParser.setVersion(Integer.parseInt(m.group(3)));\r\n                        if (m.group(5)!=null) {\r\n                            identifier = m.group(5);\r\n                            headerParser.setIdentifier(identifier);\r\n                        }\r\n                    } else {\r\n                        throw new ParserException(\"Bad version line\");\r\n                    }\r\n                } else if (sectionKey.equals(KEYWORDS_TAG)) {\r\n                } else if (sectionKey.equals(SOURCE_TAG)) {\r\n                    // ignore - can get all this from the first feature\r\n                } else if (sectionKey.equals(REFERENCE_TAG) ) {\r\n                } else if (sectionKey.equals(COMMENT_TAG) ) {\r\n                    // Set up some comments\r\n                    headerParser.setComment(((String[])section.get(0))[1]);\r\n                } else if (sectionKey.equals(FEATURE_TAG) ) {\r\n                } else if (sectionKey.equals(BASE_COUNT_TAG)) {\r\n                    // ignore - can calculate from sequence content later if needed\r\n                } else if (sectionKey.equals(START_SEQUENCE_TAG) ) {\r\n                \t// our first line is ignorable as it is the ORIGIN tag\r\n                    // the second line onwards conveniently have the number as\r\n                    // the [0] tuple, and sequence string as [1] so all we have\r\n                    // to do is concat the [1] parts and then strip out spaces,\r\n                    // and replace '.' and '~' with '-' for our parser.\r\n                \tStringBuffer seq = new StringBuffer();\r\n                    for (int i = 1 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\r\n                \tString seqData = seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\").toUpperCase();\r\n\r\n                    S sequence = (S)sequenceCreator.getSequence(seqData, sequenceIndex);\r\n                    headerParser.parseHeader(header, sequence);\r\n                    sequences.put(sequence.getAccession().getID(),sequence);\r\n                }\r\n            } while (!sectionKey.equals(END_SEQUENCE_TAG));\r\n        }catch(RuntimeException e){\r\n            throw new ParserException(\"Bad sequence section\", e);\r\n        }\r\n        return sequences;\r\n        \r\n    }\r\n\r\n\t// reads an indented section, combining split lines and creating a list of\r\n\t// key->value tuples\r\n\tprivate List<String[]> readSection() {\r\n\t\tList<String[]> section = new ArrayList<String[]>();\r\n\t\tString line = \"\";\r\n\t\tString currKey = null;\r\n\t\tStringBuffer currVal = new StringBuffer();\r\n\t\tboolean done = false;\r\n\t\tint linecount = 0;\r\n\r\n\t\ttry {\r\n\t\t\twhile (!done) {\r\n\t\t\t\tbr.mark(320);\r\n\t\t\t\tline = br.readLine();\r\n\t\t\t\tString firstSecKey = section.isEmpty() ? \"\"\r\n\t\t\t\t\t\t: ((String[]) section.get(0))[0];\r\n\t\t\t\tif (line != null && line.matches(\"\\\\p{Space}*\")) {\r\n\t\t\t\t\t// regular expression \\p{Space}* will match line\r\n\t\t\t\t\t// having only white space characters\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (line == null\r\n\t\t\t\t\t\t|| (!line.startsWith(\" \") && linecount++ > 0 && (!firstSecKey\r\n\t\t\t\t\t\t\t\t.equals(START_SEQUENCE_TAG) || line\r\n\t\t\t\t\t\t\t\t.startsWith(END_SEQUENCE_TAG)))) {\r\n\t\t\t\t\t// dump out last part of section\r\n\t\t\t\t\tsection.add(new String[] { currKey, currVal.toString() });\r\n\t\t\t\t\tbr.reset();\r\n\t\t\t\t\tdone = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tMatcher m = sectp.matcher(line);\r\n\t\t\t\t\tif (m.matches()) {\r\n\t\t\t\t\t\t// new key\r\n\t\t\t\t\t\tif (currKey != null)\r\n\t\t\t\t\t\t\tsection.add(new String[] { currKey,\r\n\t\t\t\t\t\t\t\t\tcurrVal.toString() });\r\n\t\t\t\t\t\t// key = group(2) or group(4) or group(6) - whichever is\r\n\t\t\t\t\t\t// not null\r\n\t\t\t\t\t\tcurrKey = m.group(2) == null ? (m.group(4) == null ? m\r\n\t\t\t\t\t\t\t\t.group(6) : m.group(4)) : m.group(2);\r\n\t\t\t\t\t\tcurrVal = new StringBuffer();\r\n\t\t\t\t\t\t// val = group(3) if group(2) not null, group(5) if\r\n\t\t\t\t\t\t// group(4) not null, \"\" otherwise, trimmed\r\n\t\t\t\t\t\tcurrVal.append((m.group(2) == null ? (m.group(4) == null ? \"\"\r\n\t\t\t\t\t\t\t\t: m.group(5))\r\n\t\t\t\t\t\t\t\t: m.group(3)).trim());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// concatted line or SEQ START/END line?\r\n\t\t\t\t\t\tif (line.startsWith(START_SEQUENCE_TAG)\r\n\t\t\t\t\t\t\t\t|| line.startsWith(END_SEQUENCE_TAG))\r\n\t\t\t\t\t\t\tcurrKey = line;\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tcurrVal.append(\"\\n\"); // newline in between lines -\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// can be removed later\r\n\t\t\t\t\t\t\tcurrVal.append(currKey.charAt(0) == '/' ? line\r\n\t\t\t\t\t\t\t\t\t.substring(21) : line.substring(12));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new ParserException(e.getMessage());\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tthrow new ParserException(e.getMessage());\r\n\t\t}\r\n\t\treturn section;\r\n\t}\r\n\r\n\tpublic void close() throws IOException {\r\n\t\tbr.close();\r\n        isr.close();\r\n        //If stream was created from File object then we need to close it\r\n        if (fi != null) {\r\n            fi.close();\r\n        }\r\n        this.line=this.header = null;\r\n\t}\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            String inputFile = \"src/test/resources/PF00104_small.Genbank\";\r\n            FileInputStream is = new FileInputStream(inputFile);\r\n\r\n            GenbankReader<ProteinSequence, AminoAcidCompound> GenbankReader = new GenbankReader<ProteinSequence, AminoAcidCompound>(is, new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n            LinkedHashMap<String,ProteinSequence> proteinSequences = GenbankReader.process();\r\n            is.close();\r\n\r\n\r\n            System.out.println(proteinSequences);\r\n\r\n            File file = new File(inputFile);\r\n            GenbankReader<ProteinSequence,AminoAcidCompound> GenbankProxyReader = new GenbankReader<ProteinSequence,AminoAcidCompound>(file, new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), new FileProxyProteinSequenceCreator(file, AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n            LinkedHashMap<String,ProteinSequence> proteinProxySequences = GenbankProxyReader.process();\r\n\r\n            for(String key : proteinProxySequences.keySet()){\r\n                ProteinSequence proteinSequence = proteinProxySequences.get(key);\r\n                System.out.println(key);\r\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\r\n//                    int dummy = 1;\r\n//                }\r\n                System.out.println(proteinSequence.toString());\r\n\r\n            }\r\n\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n\r\n","originTest":"/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\nimport static org.junit.Assert.assertNotNull;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.LinkedHashMap;\r\n\r\nimport org.biojava3.core.sequence.ProteinSequence;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\r\nimport org.junit.After;\r\nimport org.junit.AfterClass;\r\nimport org.junit.Before;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\n\r\n/**\r\n *\r\n * @author Scooter Willis <willishf at gmail dot com>\r\n */\r\npublic class GenbankReaderTest {\r\n\r\n\tpublic GenbankReaderTest() {\r\n\t}\r\n\r\n\t@BeforeClass\r\n\tpublic static void setUpClass() throws Exception {\r\n\t}\r\n\r\n\t@AfterClass\r\n\tpublic static void tearDownClass() throws Exception {\r\n\t}\r\n\r\n\t@Before\r\n\tpublic void setUp() {\r\n\t}\r\n\r\n\t@After\r\n\tpublic void tearDown() {\r\n\t}\r\n\r\n\t/**\r\n\t * Test of process method, of class GenbankReader.\r\n\t */\r\n\t@Test\r\n\tpublic void testProcess() throws Exception {\r\n\r\n\t\tSystem.out.println(\"process\");\r\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\");\r\n\t\tassertNotNull(inStream);\r\n\r\n\t\tGenbankReader<ProteinSequence,AminoAcidCompound> GenbankReader = new GenbankReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = GenbankReader.process();\r\n\t\tinStream.close();\r\n\r\n\t}\r\n\t\r\n}\r\n","changedTest":"/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport static org.junit.Assert.assertNotNull;\r\n\r\nimport java.io.InputStream;\r\nimport java.util.LinkedHashMap;\r\n\r\nimport org.biojava3.core.sequence.DNASequence;\r\nimport org.biojava3.core.sequence.ProteinSequence;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\r\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\r\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\r\nimport org.junit.After;\r\nimport org.junit.AfterClass;\r\nimport org.junit.Before;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\n\r\n/**\r\n *\r\n * @author Scooter Willis <willishf at gmail dot com>\r\n */\r\npublic class GenbankReaderTest {\r\n\r\n\tpublic GenbankReaderTest() {\r\n\t}\r\n\r\n\t@BeforeClass\r\n\tpublic static void setUpClass() throws Exception {\r\n\t}\r\n\r\n\t@AfterClass\r\n\tpublic static void tearDownClass() throws Exception {\r\n\t}\r\n\r\n\t@Before\r\n\tpublic void setUp() {\r\n\t}\r\n\r\n\t@After\r\n\tpublic void tearDown() {\r\n\t}\r\n\r\n\t/**\r\n\t * Test of process method, of class GenbankReader.\r\n\t */\r\n\t@Test\r\n\tpublic void testProcess() throws Exception {\r\n\r\n\t\tSystem.out.println(\"process protein\");\r\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\");\r\n\t\tassertNotNull(inStream);\r\n\t\t\r\n\t\tGenbankReader<ProteinSequence,AminoAcidCompound> GenbankProtein = \r\n\t\t\t\tnew GenbankReader<ProteinSequence,AminoAcidCompound>(\r\n\t\t\t\t\t\tinStream, \r\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<ProteinSequence,AminoAcidCompound>(), \r\n\t\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\r\n\t\t\t\t\t\t);\r\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = GenbankProtein.process();\r\n\t\tinStream.close();\r\n\r\n\t\tSystem.out.println(\"process DNA\");\r\n\t\tinStream = this.getClass().getResourceAsStream(\"/NM_000266.gb\");\r\n\t\tassertNotNull(inStream);\r\n\r\n\t\tGenbankReader<DNASequence,NucleotideCompound> GenbankDNA = \r\n\t\t\t\tnew GenbankReader<DNASequence,NucleotideCompound>(\r\n\t\t\t\t\t\tinStream,\r\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<DNASequence,NucleotideCompound>(), \r\n\t\t\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\r\n\t\t\t\t\t\t);\r\n\t\tLinkedHashMap<String,DNASequence> dnaSequences = GenbankDNA.process();\r\n\t\tinStream.close();\r\n\t}\r\n\t\r\n}\r\n","commitMessage":"Updated GenbankReader and files to properly handle AbstractSequence and\nCompound types. Added testcase for DNASequence/Nucleotide sequence.","test_commitMessage":"Updated GenbankReader and files to properly handle AbstractSequence and\nCompound types. Added testcase for DNASequence/Nucleotide sequence.","allZero":false}