{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleSequencePair.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleSequencePairTest.java","prod_time":"2010-07-29 07:05:27","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"d067ecabc788e661cedfcbd7f34df81f1ae56e2b","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a data structure for the results of pairwise sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleSequencePair<S extends Sequence<C>, C extends Compound> extends SimpleProfile<S, C>\n        implements SequencePair<S, C> {\n\n    private int identicals = -1, similars = -1;\n\n    /**\n     * Creates a pair profile for the given already aligned sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @throws IllegalArgumentException if sequences differ in size\n     */\n    public SimpleSequencePair(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n        super(query, target);\n    }\n\n    /**\n     * Creates a pair profile for the given sequences with a global alignment.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    public SimpleSequencePair(S query, S target, List<Step> sx, List<Step> sy) {\n        this(query, target, sx, 0, 0, sy, 0, 0);\n    }\n\n    /**\n     * Creates a pair profile for the given sequences with a local alignment.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n     * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n     * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    public SimpleSequencePair(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n        super(query, target, sx, xb, xa, sy, yb, ya);\n    }\n\n    @Override\n    public C getCompoundInQueryAt(int alignmentIndex) {\n        return getAlignedSequence(1).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public C getCompoundInTargetAt(int alignmentIndex) {\n        return getAlignedSequence(2).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInQueryAt(int alignmentIndex) {\n        return getAlignedSequence(1).getSequenceIndexAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInQueryForTargetAt(int targetIndex) {\n        return getAlignedSequence(1).getSequenceIndexAt(getAlignedSequence(2).getAlignmentIndexAt(targetIndex));\n    }\n\n    @Override\n    public int getIndexInTargetAt(int alignmentIndex) {\n        return getAlignedSequence(2).getSequenceIndexAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInTargetForQueryAt(int queryIndex) {\n        return getAlignedSequence(2).getSequenceIndexAt(getAlignedSequence(1).getAlignmentIndexAt(queryIndex));\n    }\n\n    @Override\n    public int getNumIdenticals() {\n        if (identicals == -1) {\n            identicals = 0;\n            for (int i = 1; i <= getLength(); i++) {\n                if (getCompoundInQueryAt(i).equalsIgnoreCase(getCompoundInTargetAt(i))) {\n                    identicals++;\n                }\n            }\n        }\n        getQuery().clearCache();\n        getTarget().clearCache();\n        return identicals;\n    }\n\n    @Override\n    public int getNumSimilars() {\n        if (similars == -1) {\n            similars = 0;\n            for (int i = 1; i <= getLength(); i++) {\n                if (getCompoundSet().compoundsEquivalent(getCompoundInQueryAt(i), getCompoundInTargetAt(i))) {\n                    similars++;\n                }\n            }\n        }\n        getQuery().clearCache();\n        getTarget().clearCache();\n        return similars;\n    }\n\n    @Override\n    public AlignedSequence<S, C> getQuery() {\n        return getAlignedSequence(1);\n    }\n\n    @Override\n    public AlignedSequence<S, C> getTarget() {\n        return getAlignedSequence(2);\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a data structure for the results of pairwise sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleSequencePair<S extends Sequence<C>, C extends Compound> extends SimpleProfile<S, C>\n        implements SequencePair<S, C> {\n\n    private int identicals = -1, similars = -1;\n\n    /**\n     * Creates a pair profile for the given already aligned sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @throws IllegalArgumentException if sequences differ in size\n     */\n    public SimpleSequencePair(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n        super(query, target);\n    }\n\n    /**\n     * Creates a pair profile for the given sequences with a global alignment.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    public SimpleSequencePair(S query, S target, List<Step> sx, List<Step> sy) {\n        this(query, target, sx, 0, 0, sy, 0, 0);\n    }\n\n    /**\n     * Creates a pair profile for the given sequences with a local alignment.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n     * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n     * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    public SimpleSequencePair(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n        super(query, target, sx, xb, xa, sy, yb, ya);\n    }\n\n    @Override\n    public C getCompoundInQueryAt(int alignmentIndex) {\n        return getAlignedSequence(1).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public C getCompoundInTargetAt(int alignmentIndex) {\n        return getAlignedSequence(2).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInQueryAt(int alignmentIndex) {\n        return getAlignedSequence(1).getSequenceIndexAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInQueryForTargetAt(int targetIndex) {\n        return getAlignedSequence(1).getSequenceIndexAt(getAlignedSequence(2).getAlignmentIndexAt(targetIndex));\n    }\n\n    @Override\n    public int getIndexInTargetAt(int alignmentIndex) {\n        return getAlignedSequence(2).getSequenceIndexAt(alignmentIndex);\n    }\n\n    @Override\n    public int getIndexInTargetForQueryAt(int queryIndex) {\n        return getAlignedSequence(2).getSequenceIndexAt(getAlignedSequence(1).getAlignmentIndexAt(queryIndex));\n    }\n\n    @Override\n    public int getNumIdenticals() {\n        if (identicals == -1) {\n            identicals = 0;\n            for (int i = 1; i <= getLength(); i++) {\n                if (getCompoundInQueryAt(i).equalsIgnoreCase(getCompoundInTargetAt(i))) {\n                    identicals++;\n                }\n            }\n            getQuery().clearCache();\n            getTarget().clearCache();\n        }\n        return identicals;\n    }\n\n    @Override\n    public int getNumSimilars() {\n        if (similars == -1) {\n            similars = 0;\n            for (int i = 1; i <= getLength(); i++) {\n                if (getCompoundSet().compoundsEquivalent(getCompoundInQueryAt(i), getCompoundInTargetAt(i))) {\n                    similars++;\n                }\n            }\n            getQuery().clearCache();\n            getTarget().clearCache();\n        }\n        return similars;\n    }\n\n    @Override\n    public AlignedSequence<S, C> getQuery() {\n        return getAlignedSequence(1);\n    }\n\n    @Override\n    public AlignedSequence<S, C> getTarget() {\n        return getAlignedSequence(2);\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\n\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class SimpleSequencePairTest {\n\n    private ProteinSequence query, target;\n    private SequencePair<ProteinSequence, AminoAcidCompound> global, local;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        global = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), Arrays.asList(new Step[] {\n                Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n        local = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n                Step.GAP, Step.COMPOUND}), 0, 1);\n    }\n\n    @Test\n    public void testGetCompoundInQueryAt() {\n        assertEquals(global.getCompoundInQueryAt(1).getShortName(), \"A\");\n        assertEquals(global.getCompoundInQueryAt(2).getShortName(), \"R\");\n        assertEquals(global.getCompoundInQueryAt(3).getShortName(), \"N\");\n        assertEquals(global.getCompoundInQueryAt(4).getShortName(), \"D\");\n        assertEquals(global.getCompoundInQueryAt(5).getShortName(), \"-\");\n        assertEquals(local.getCompoundInQueryAt(1).getShortName(), \"R\");\n        assertEquals(local.getCompoundInQueryAt(2).getShortName(), \"N\");\n        assertEquals(local.getCompoundInQueryAt(3).getShortName(), \"D\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInQueryAtOutOfBounds() {\n        global.getCompoundInQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInQueryAtOutOfBounds2() {\n        global.getCompoundInQueryAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInQueryAtOutOfBounds3() {\n        local.getCompoundInQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInQueryAtOutOfBounds4() {\n        local.getCompoundInQueryAt(4);\n    }\n\n    @Test\n    public void testGetCompoundInTargetAt() {\n        assertEquals(global.getCompoundInTargetAt(1).getShortName(), \"-\");\n        assertEquals(global.getCompoundInTargetAt(2).getShortName(), \"R\");\n        assertEquals(global.getCompoundInTargetAt(3).getShortName(), \"-\");\n        assertEquals(global.getCompoundInTargetAt(4).getShortName(), \"D\");\n        assertEquals(global.getCompoundInTargetAt(5).getShortName(), \"G\");\n        assertEquals(local.getCompoundInTargetAt(1).getShortName(), \"R\");\n        assertEquals(local.getCompoundInTargetAt(2).getShortName(), \"-\");\n        assertEquals(local.getCompoundInTargetAt(3).getShortName(), \"D\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInTargetAtOutOfBounds() {\n        global.getCompoundInTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInTargetAtOutOfBounds2() {\n        global.getCompoundInTargetAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInTargetAtOutOfBounds3() {\n        local.getCompoundInTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundInTargetAtOutOfBounds4() {\n        local.getCompoundInTargetAt(4);\n    }\n\n    @Test\n    public void testGetIndexInQueryAt() {\n        assertEquals(global.getIndexInQueryAt(1), 1);\n        assertEquals(global.getIndexInQueryAt(2), 2);\n        assertEquals(global.getIndexInQueryAt(3), 3);\n        assertEquals(global.getIndexInQueryAt(4), 4);\n        assertEquals(global.getIndexInQueryAt(5), 4);\n        assertEquals(local.getIndexInQueryAt(1), 2);\n        assertEquals(local.getIndexInQueryAt(2), 3);\n        assertEquals(local.getIndexInQueryAt(3), 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryAtOutOfBounds() {\n        global.getIndexInQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryAtOutOfBounds2() {\n        global.getIndexInQueryAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryAtOutOfBounds3() {\n        local.getIndexInQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryAtOutOfBounds4() {\n        local.getIndexInQueryAt(4);\n    }\n\n    @Test\n    public void testGetIndexInQueryForTargetAt() {\n        assertEquals(global.getIndexInQueryForTargetAt(1), 2);\n        assertEquals(global.getIndexInQueryForTargetAt(2), 4);\n        assertEquals(global.getIndexInQueryForTargetAt(3), 4);\n        assertEquals(local.getIndexInQueryForTargetAt(1), 2);\n        assertEquals(local.getIndexInQueryForTargetAt(2), 4);\n        assertEquals(local.getIndexInQueryForTargetAt(3), 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryForTargetAtOutOfBounds() {\n        global.getIndexInQueryForTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryForTargetAtOutOfBounds2() {\n        global.getIndexInQueryForTargetAt(4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryForTargetAtOutOfBounds3() {\n        local.getIndexInQueryForTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInQueryForTargetAtOutOfBounds4() {\n        local.getIndexInQueryForTargetAt(4);\n    }\n\n    @Test\n    public void testGetIndexInTargetAt() {\n        assertEquals(global.getIndexInTargetAt(1), 1);\n        assertEquals(global.getIndexInTargetAt(2), 1);\n        assertEquals(global.getIndexInTargetAt(3), 1);\n        assertEquals(global.getIndexInTargetAt(4), 2);\n        assertEquals(global.getIndexInTargetAt(5), 3);\n        assertEquals(local.getIndexInTargetAt(1), 1);\n        assertEquals(local.getIndexInTargetAt(2), 1);\n        assertEquals(local.getIndexInTargetAt(3), 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetAtOutOfBounds() {\n        global.getIndexInTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetAtOutOfBounds2() {\n        global.getIndexInTargetAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetAtOutOfBounds3() {\n        local.getIndexInTargetAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetAtOutOfBounds4() {\n        local.getIndexInTargetAt(4);\n    }\n\n    @Test\n    public void testGetIndexInTargetForQueryAt() {\n        assertEquals(global.getIndexInTargetForQueryAt(1), 1);\n        assertEquals(global.getIndexInTargetForQueryAt(2), 1);\n        assertEquals(global.getIndexInTargetForQueryAt(3), 1);\n        assertEquals(global.getIndexInTargetForQueryAt(4), 2);\n        assertEquals(local.getIndexInTargetForQueryAt(1), 1);\n        assertEquals(local.getIndexInTargetForQueryAt(2), 1);\n        assertEquals(local.getIndexInTargetForQueryAt(3), 1);\n        assertEquals(local.getIndexInTargetForQueryAt(4), 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetForQueryAtOutOfBounds() {\n        global.getIndexInTargetForQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetForQueryAtOutOfBounds2() {\n        global.getIndexInTargetForQueryAt(5);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetForQueryAtOutOfBounds3() {\n        local.getIndexInTargetForQueryAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndexInTargetForQueryAtOutOfBounds4() {\n        local.getIndexInTargetForQueryAt(5);\n    }\n\n    @Test\n    public void testGetNumIdenticals() {\n        assertEquals(global.getNumIdenticals(), 2);\n        assertEquals(local.getNumIdenticals(), 2);\n    }\n\n    @Test\n    public void testGetNumSimilars() {\n        assertEquals(global.getNumSimilars(), 2);\n        assertEquals(local.getNumSimilars(), 2);\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(global.getQuery().getOriginalSequence(), query);\n        assertEquals(local.getQuery().getOriginalSequence(), query);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(global.getTarget().getOriginalSequence(), target);\n        assertEquals(local.getTarget().getOriginalSequence(), target);\n    }\n\n}\n","changedTest":"","commitMessage":"improvements to memory usage during multiple sequence alignment\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8156 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":true}