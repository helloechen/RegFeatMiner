{"repository":"biojava","prod_path":"biojava-alignment/src/main/java/org/biojava/nbio/alignment/GuideTree.java","test_path":"biojava-alignment/src/test/java/org/biojava/nbio/alignment/GuideTreeTest.java","prod_time":"2016-06-17 01:48:24","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f3f73954d3cfa5dddcf8a860920237799151ac03","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.core.alignment.SimpleProfile;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceScorer;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfilePair;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.phylo.ForesterWrapper;\nimport org.biojava.nbio.phylo.TreeConstructor;\nimport org.biojava.nbio.phylo.TreeConstructorType;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\n\nimport javax.swing.tree.TreeNode;\n\nimport java.util.*;\nimport java.util.concurrent.Future;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n\tprivate List<S> sequences;\n\tprivate List<PairwiseSequenceScorer<S, C>> scorers;\n\tprivate BasicSymmetricalDistanceMatrix distances;\n\tprivate String newick;\n\tprivate Node root;\n\n\t/**\n\t * Creates a guide tree for use during progressive multiple sequence alignment.\n\t *\n\t * @param sequences the {@link List} of {@link Sequence}s to align\n\t * @param scorers list of sequence pair scorers, one for each pair of sequences given\n\t */\n\tpublic GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n\t\tthis.sequences = Collections.unmodifiableList(sequences);\n\t\tthis.scorers = Collections.unmodifiableList(scorers);\n\t\tdistances = new BasicSymmetricalDistanceMatrix(sequences.size());\n\t\tfor (int i = 0, n = 0; i < sequences.size(); i++) {\n\t\t\tAccessionID id = sequences.get(i).getAccession();\n\t\t\tString str = (id == null) ? Integer.toString(i + 1) : id.getID();\n\t\t\tdistances.setIdentifier(i, str);\n\t\t\tfor (int j = i+1; j < sequences.size(); j++) {\n\t\t\t\tdouble dist = scorers.get(n++).getDistance();\n\t\t\t\tdistances.setValue(i, j, dist);\n\t\t\t}\n\t\t}\n\t\tBasicSymmetricalDistanceMatrix distclone = ForesterWrapper.cloneDM(distances);\n\t\tPhylogeny phylogeny = TreeConstructor.distanceTree(distclone, TreeConstructorType.NJ);\n\t\tnewick = phylogeny.toString();\n\t\troot = new Node(phylogeny.getRoot(), null);\n\t}\n\n\t/**\n\t * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n\t *\n\t * @return list of sequence pair scores\n\t */\n\tpublic double[] getAllPairsScores() {\n\t\tdouble[] scores = new double[scorers.size()];\n\t\tint n = 0;\n\t\tfor (PairwiseSequenceScorer<S, C> scorer : scorers) {\n\t\t\tscores[n++] = scorer.getScore();\n\t\t}\n\t\treturn scores;\n\t}\n\n\t/**\n\t * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n\t *\n\t * @return the distance matrix used to construct this guide tree\n\t */\n\tpublic double[][] getDistanceMatrix() {\n\t\tdouble[][] matrix = new double[distances.getSize()][distances.getSize()];\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tfor (int j = i+1; j < matrix.length; j++) {\n\t\t\t\tmatrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n\t *\n\t * @return the root node\n\t */\n\tpublic Node getRoot() {\n\t\treturn root;\n\t}\n\n\t/**\n\t * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n\t *\n\t * @return the similarity matrix used to construct this guide tree\n\t */\n\tpublic double[][] getScoreMatrix() {\n\t\tdouble[][] matrix = new double[sequences.size()][sequences.size()];\n\t\tfor (int i = 0, n = 0; i < matrix.length; i++) {\n\t\t\tmatrix[i][i] = scorers.get(i).getMaxScore();\n\t\t\tfor (int j = i+1; j < matrix.length; j++) {\n\t\t\t\tmatrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * Returns the {@link Sequence}s which make up the leaves of this tree.\n\t *\n\t * @return the sequences which make up the leaves of this tree\n\t */\n\tpublic List<S> getSequences() {\n\t\treturn sequences;\n\t}\n\n\t// method for Iterable\n\n\t/**\n\t * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n\t */\n\t@Override\n\tpublic Iterator<GuideTreeNode<S, C>> iterator() {\n\t\treturn new PostOrderIterator();\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn newick;\n\t}\n\n\t/**\n\t * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n\t */\n\tpublic class Node implements GuideTreeNode<S, C> {\n\n\t\tprivate GuideTreeNode<S, C> parent, child1, child2;\n\t\tprivate double distance;\n\t\tprivate String name;\n\t\tprivate boolean isLeaf, isVisited;\n\t\tprivate Profile<S, C> profile;\n\t\tprivate Future<ProfilePair<S, C>> profileFuture;\n\n\t\tprivate Node(PhylogenyNode node, Node parent) {\n\t\t\tthis.parent = parent;\n\t\t\tdistance = node.getDistanceToParent();\n\t\t\tname = node.getName();\n\t\t\tif(isLeaf = node.isExternal()) {\n\t\t\t\tprofile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n\t\t\t} else {\n\t\t\t\tchild1 = new Node(node.getChildNode1(), this);\n\t\t\t\tchild2 = new Node(node.getChildNode2(), this);\n\t\t\t}\n\t\t}\n\n\t\t// methods for GuideTreeNode\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChild1() {\n\t\t\treturn child1;\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChild2() {\n\t\t\treturn child2;\n\t\t}\n\n\t\t@Override\n\t\tpublic double getDistanceToParent() {\n\t\t\treturn distance;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic Profile<S, C> getProfile() {\n\t\t\treturn profile;\n\t\t}\n\n\t\t@Override\n\t\tpublic Future<ProfilePair<S, C>> getProfileFuture() {\n\t\t\treturn profileFuture;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProfile(Profile<S, C> profile) {\n\t\t\tthis.profile = profile;\n\t\t\tprofileFuture = null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n\t\t\tthis.profileFuture = profileFuture;\n\t\t\tprofile = null;\n\t\t}\n\n\t\t// methods for TreeNode\n\n\t\t@Override\n\t\tpublic Enumeration<GuideTreeNode<S, C>> children() {\n\t\t\tVector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n\t\t\tchildren.add(getChild1());\n\t\t\tchildren.add(getChild2());\n\t\t\treturn children.elements();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean getAllowsChildren() {\n\t\t\treturn !isLeaf();\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChildAt(int childIndex) {\n\t\t\tif (childIndex == 1) {\n\t\t\t\treturn getChild1();\n\t\t\t} else if (childIndex == 2) {\n\t\t\t\treturn getChild2();\n\t\t\t}\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getChildCount() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getIndex(TreeNode child) {\n\t\t\treturn getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isLeaf() {\n\t\t\treturn isLeaf;\n\t\t}\n\n\t\t// helper methods for iterator\n\n\t\tprivate void clearVisited() {\n\t\t\tisVisited = false;\n\t\t\tif (!isLeaf()) {\n\t\t\t\t((Node) getChild1()).clearVisited();\n\t\t\t\t((Node) getChild2()).clearVisited();\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isVisited() {\n\t\t\treturn isVisited;\n\t\t}\n\n\t\tprivate void visit() {\n\t\t\tisVisited = true;\n\t\t}\n\n\t}\n\n\t// helper class that defines the default post-order (leaves to root) traversal\n\tprivate class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n\t\tprivate Stack<Node> nodes;\n\n\t\tprivate PostOrderIterator() {\n\t\t\tgetRoot().clearVisited();\n\t\t\tnodes = new Stack<Node>();\n\t\t\tnodes.push(getRoot());\n\t\t}\n\n\t\t// methods for Iterator\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn !nodes.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> next() {\n\t\t\twhile (hasNext()) {\n\t\t\t\tNode next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n\t\t\t\tif (child1 != null && !child1.isVisited()) {\n\t\t\t\t\tnodes.push(child1);\n\t\t\t\t} else if (child2 != null && !child2.isVisited()) {\n\t\t\t\t\tnodes.push(child2);\n\t\t\t\t} else {\n\t\t\t\t\tnext.visit();\n\t\t\t\t\treturn nodes.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.core.alignment.SimpleProfile;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceScorer;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfilePair;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.phylo.ForesterWrapper;\nimport org.biojava.nbio.phylo.TreeConstructor;\nimport org.biojava.nbio.phylo.TreeConstructorType;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\n\nimport javax.swing.tree.TreeNode;\n\nimport java.util.*;\nimport java.util.concurrent.Future;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n\tprivate List<S> sequences;\n\tprivate List<PairwiseSequenceScorer<S, C>> scorers;\n\tprivate BasicSymmetricalDistanceMatrix distances;\n\tprivate String newick;\n\tprivate Node root;\n\n\t/**\n\t * Creates a guide tree for use during progressive multiple sequence alignment.\n\t *\n\t * @param sequences the {@link List} of {@link Sequence}s to align\n\t * @param scorers list of sequence pair scorers, one for each pair of sequences given\n\t */\n\tpublic GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n\t\tthis.sequences = Collections.unmodifiableList(sequences);\n\t\tthis.scorers = Collections.unmodifiableList(scorers);\n\t\tdistances = new BasicSymmetricalDistanceMatrix(sequences.size());\n\t\tfor (int i = 0, n = 0; i < sequences.size(); i++) {\n\t\t\tAccessionID id = sequences.get(i).getAccession();\n\t\t\tString str = (id == null) ? Integer.toString(i + 1) : id.getID();\n\t\t\tdistances.setIdentifier(i, str);\n\t\t\tfor (int j = i+1; j < sequences.size(); j++) {\n\t\t\t\tdouble dist = scorers.get(n++).getDistance();\n\t\t\t\tdistances.setValue(i, j, dist);\n\t\t\t}\n\t\t}\n\t\tBasicSymmetricalDistanceMatrix distclone = ForesterWrapper.cloneDM(distances);\n\t\tPhylogeny phylogeny = TreeConstructor.distanceTree(distclone, TreeConstructorType.NJ);\n\t\tnewick = phylogeny.toString();\n\t\troot = new Node(phylogeny.getRoot(), null);\n\t}\n\n\t/**\n\t * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n\t *\n\t * @return list of sequence pair scores\n\t */\n\tpublic double[] getAllPairsScores() {\n\t\tdouble[] scores = new double[scorers.size()];\n\t\tint n = 0;\n\t\tfor (PairwiseSequenceScorer<S, C> scorer : scorers) {\n\t\t\tscores[n++] = scorer.getScore();\n\t\t}\n\t\treturn scores;\n\t}\n\n\t/**\n\t * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n\t *\n\t * @return the distance matrix used to construct this guide tree\n\t */\n\tpublic double[][] getDistanceMatrix() {\n\t\tdouble[][] matrix = new double[distances.getSize()][distances.getSize()];\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tfor (int j = i+1; j < matrix.length; j++) {\n\t\t\t\tmatrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n\t *\n\t * @return the root node\n\t */\n\tpublic Node getRoot() {\n\t\treturn root;\n\t}\n\n\t/**\n\t * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n\t *\n\t * @return the similarity matrix used to construct this guide tree\n\t */\n\tpublic double[][] getScoreMatrix() {\n\t\tdouble[][] matrix = new double[sequences.size()][sequences.size()];\n\t\tfor (int i = 0, n = 0; i < matrix.length; i++) {\n\t\t\tmatrix[i][i] = scorers.get(i).getMaxScore();\n\t\t\tfor (int j = i+1; j < matrix.length; j++) {\n\t\t\t\tmatrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n\t\t\t}\n\t\t}\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * Returns the {@link Sequence}s which make up the leaves of this tree.\n\t *\n\t * @return the sequences which make up the leaves of this tree\n\t */\n\tpublic List<S> getSequences() {\n\t\treturn sequences;\n\t}\n\n\t// method for Iterable\n\n\t/**\n\t * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n\t */\n\t@Override\n\tpublic Iterator<GuideTreeNode<S, C>> iterator() {\n\t\treturn new PostOrderIterator();\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn newick;\n\t}\n\n\t/**\n\t * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n\t */\n\tpublic class Node implements GuideTreeNode<S, C> {\n\n\t\tprivate GuideTreeNode<S, C> parent, child1, child2;\n\t\tprivate double distance;\n\t\tprivate String name;\n\t\tprivate boolean isLeaf, isVisited;\n\t\tprivate Profile<S, C> profile;\n\t\tprivate Future<ProfilePair<S, C>> profileFuture;\n\n\t\tprivate Node(PhylogenyNode node, Node parent) {\n\t\t\tthis.parent = parent;\n\t\t\tdistance = node.getDistanceToParent();\n\t\t\tname = node.getName();\n\t\t\tif(isLeaf = node.isExternal()) {\n\t\t\t\tprofile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n\t\t\t} else {\n\t\t\t\tchild1 = new Node(node.getChildNode1(), this);\n\t\t\t\tchild2 = new Node(node.getChildNode2(), this);\n\t\t\t}\n\t\t}\n\n\t\t// methods for GuideTreeNode\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChild1() {\n\t\t\treturn child1;\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChild2() {\n\t\t\treturn child2;\n\t\t}\n\n\t\t@Override\n\t\tpublic double getDistanceToParent() {\n\t\t\treturn distance;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\n\t\t@Override\n\t\tpublic Profile<S, C> getProfile() {\n\t\t\treturn profile;\n\t\t}\n\n\t\t@Override\n\t\tpublic Future<ProfilePair<S, C>> getProfileFuture() {\n\t\t\treturn profileFuture;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProfile(Profile<S, C> profile) {\n\t\t\tthis.profile = profile;\n\t\t\tprofileFuture = null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n\t\t\tthis.profileFuture = profileFuture;\n\t\t\tprofile = null;\n\t\t}\n\n\t\t// methods for TreeNode\n\n\t\t@Override\n\t\tpublic Enumeration<GuideTreeNode<S, C>> children() {\n\t\t\tVector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n\t\t\tchildren.add(getChild1());\n\t\t\tchildren.add(getChild2());\n\t\t\treturn children.elements();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean getAllowsChildren() {\n\t\t\treturn !isLeaf();\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getChildAt(int childIndex) {\n\t\t\tif (childIndex == 1) {\n\t\t\t\treturn getChild1();\n\t\t\t} else if (childIndex == 2) {\n\t\t\t\treturn getChild2();\n\t\t\t}\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getChildCount() {\n\t\t\treturn 2;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getIndex(TreeNode child) {\n\t\t\treturn getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> getParent() {\n\t\t\treturn parent;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isLeaf() {\n\t\t\treturn isLeaf;\n\t\t}\n\n\t\t// helper methods for iterator\n\n\t\tprivate void clearVisited() {\n\t\t\tisVisited = false;\n\t\t\tif (!isLeaf()) {\n\t\t\t\t((Node) getChild1()).clearVisited();\n\t\t\t\t((Node) getChild2()).clearVisited();\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isVisited() {\n\t\t\treturn isVisited;\n\t\t}\n\n\t\tprivate void visit() {\n\t\t\tisVisited = true;\n\t\t}\n\n\t}\n\n\t// helper class that defines the default post-order (leaves to root) traversal\n\tprivate class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n\t\tprivate Stack<Node> nodes;\n\n\t\tprivate PostOrderIterator() {\n\t\t\tgetRoot().clearVisited();\n\t\t\tnodes = new Stack<Node>();\n\t\t\tnodes.push(getRoot());\n\t\t}\n\n\t\t// methods for Iterator\n\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn !nodes.isEmpty();\n\t\t}\n\n\t\t@Override\n\t\tpublic GuideTreeNode<S, C> next() {\n            if(!hasNext()){\n                throw new NoSuchElementException();\n            }\n\n            while (hasNext()) {\n\t\t\t\tNode next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n\t\t\t\tif (child1 != null && !child1.isVisited()) {\n\t\t\t\t\tnodes.push(child1);\n\t\t\t\t} else if (child2 != null && !child2.isVisited()) {\n\t\t\t\t\tnodes.push(child2);\n\t\t\t\t} else {\n\t\t\t\t\tnext.visit();\n\t\t\t\t\treturn nodes.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceScorerType;\nimport org.biojava.nbio.alignment.Alignments.ProfileProfileAlignerType;\nimport org.biojava.nbio.alignment.template.GapPenalty;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class GuideTreeTest {\n\n\tprivate List<ProteinSequence> proteins;\n\tprivate GapPenalty gaps;\n\tprivate SubstitutionMatrix<AminoAcidCompound> blosum62;\n\tprivate GuideTree<ProteinSequence, AminoAcidCompound> tree;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tproteins = Arrays.asList(new ProteinSequence[] {new ProteinSequence(\"ARND\"), new ProteinSequence(\"ARND\"),\n\t\t\t\tnew ProteinSequence(\"HILK\"), new ProteinSequence(\"ANDR\")});\n\t\tgaps = new SimpleGapPenalty((short) 2, (short) 1);\n\t\tblosum62 = SubstitutionMatrixHelper.getBlosum62();\n\t\ttree = new GuideTree<ProteinSequence, AminoAcidCompound>(proteins, Alignments.getAllPairsScorers(proteins,\n\t\t\t\tPairwiseSequenceScorerType.GLOBAL_IDENTITIES, gaps, blosum62));\n\t}\n\n\t@Test\n\tpublic void testGuideTree() {\n\t\tassertNotNull(tree);\n\t}\n\n\t@Test\n\tpublic void testGetAllPairsScores() {\n\t\tassertArrayEquals(tree.getAllPairsScores(), new double[] {4, 0, 3, 0, 3, 0}, 0.00001);\n\t}\n\n\t@Test\n\tpublic void testGetDistanceMatrix() {\n\t\tassertArrayEquals(tree.getDistanceMatrix(), new double[][] {\n\t\t\t\t{0.0, 0.0, 1.0, 0.4},\n\t\t\t\t{0.0, 0.0, 1.0, 0.4},\n\t\t\t\t{1.0, 1.0, 0.0, 1.0},\n\t\t\t\t{0.4, 0.4, 1.0, 0.0}});\n\t}\n\n\t@Test\n\tpublic void testGetRoot() {\n\t\tassertEquals(Alignments.getProgressiveAlignment(tree, ProfileProfileAlignerType.GLOBAL, gaps,\n\t\t\t\tblosum62).toString(), String.format(\"%s%n%s%n%s%n%s%n\",\n\t\t\t\t\"--ARND-\",\n\t\t\t\t\"--ARND-\",\n\t\t\t\t\"HILK---\",\n\t\t\t\t\"--A-NDR\"));\n\t}\n\n\t@Test\n\tpublic void testGetScoreMatrix() {\n\t\tassertArrayEquals(tree.getScoreMatrix(), new double[][] {\n\t\t\t\t{4, 4, 0, 3},\n\t\t\t\t{4, 6, 0, 3},\n\t\t\t\t{0, 0, 5, 0},\n\t\t\t\t{3, 3, 0, 6}});\n\t}\n\n\t@Test\n\tpublic void testGetSequences() {\n\t\tList<ProteinSequence> list = tree.getSequences();\n\t\tassertEquals(list.size(), 4);\n\t\tassertEquals(list.get(0), proteins.get(0));\n\t\tassertEquals(list.get(1), proteins.get(1));\n\t\tassertEquals(list.get(2), proteins.get(2));\n\t\tassertEquals(list.get(3), proteins.get(3));\n\t}\n\n\t@Test\n\tpublic void testIterator() {\n\t\tint i = 0;\n\t\tfor (GuideTreeNode<ProteinSequence, AminoAcidCompound> n : tree) {\n\t\t\tswitch (i++) {\n\t\t\tcase 0: assertEquals(n.getName(), \"1\"); break;\n\t\t\tcase 1: assertEquals(n.getName(), \"2\"); break;\n\t\t\tcase 2: assertEquals(n.getName(), \"\"); break;\n\t\t\tcase 3: assertEquals(n.getName(), \"3\"); break;\n\t\t\tcase 4: assertEquals(n.getName(), \"\"); break;\n\t\t\tcase 5: assertEquals(n.getName(), \"4\"); break;\n\t\t\tcase 6: assertEquals(n.getName(), \"\"); break;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testToString() {\n\t\tassertEquals(\"(((1:0.0,2:0.0):0.19999999999999996,3:0.8):\"\n\t\t\t\t+ \"0.09999999999999998,4:0.09999999999999998)\",\n\t\t\t\ttree.toString());\n\t}\n\n}\n","changedTest":"","commitMessage":"squid:S2272 - \"Iterator.next()\" methods should throw \"NoSuchElementException\"\n","test_commitMessage":"","allZero":false}