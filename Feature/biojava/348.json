{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/AtomPositionMap.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/AtomPositionMapTest.java","prod_time":"2015-04-15 15:58:35","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":5,"add_classname_line":0,"add_condition_line":5,"add_field_line":18,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":4,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":2,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"a4bdcb7b5672a68e4225e360e43d74b3ef73a2f8","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.nbio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport org.biojava.nbio.structure.io.mmcif.chem.PolymerType;\nimport org.biojava.nbio.structure.io.mmcif.chem.ResidueType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A map from {@link ResidueNumber ResidueNumbers} to ATOM record positions in a PDB file.\n * \n * <p>To use:\n * \n * <pre>\n * Atom[] atoms = new AtomCache().getAtoms(\"1w0p\");\n * AtomPositionMap map = new AtomPositionMap(atoms);\n * ResidueNumber start = new ResidueNumber(\"A\", 100, null);\n * ResidueNumber end = map.getEnd(\"A\");\n * int pos = map.getPosition(start);\n * int length = map.calcLength(start, end);\n * </pre>\n * \n * <p>Note: The getLength() methods were introduced in BioJava 4.0.0 to replace\n * the calcLength methods. The new method returns the number of residues between\n * two residues, inclusive, whereas the previous method returned 1 less than that.\n * @author dmyerstu\n */\npublic class AtomPositionMap {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomPositionMap.class);\n\t\n\tprivate HashMap<ResidueNumber, Integer> hashMap;\n\tprivate TreeMap<ResidueNumber, Integer> treeMap;\n\n\n\t/**\n\t * Used as a Predicate to indicate whether a particular Atom should be mapped\n\t */\n\tpublic static interface GroupMatcher {\n\t\tboolean matches(Group group);\n\t}\n\n\t/**\n\t * Matches CA atoms of protein groups\n\t */\n\tpublic static final GroupMatcher AMINO_ACID_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\tResidueType type = group.getChemComp().getResidueType();\n\t\t\treturn PolymerType.PROTEIN_ONLY.contains(type.getPolymerType())\n\t\t\t\t\t&& group.hasAtom(StructureTools.CA_ATOM_NAME);\n\t\t}\n\t};\n\n\t/**\n\t * Matches all atoms\n\t */\n\tpublic static final GroupMatcher ANYTHING_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * A map that is sorted by its values. Used for the treemap\n\t * \n\t * @author dmyerstu\n\t * \n\t * @param <T>\n\t *            The key type\n\t * @param <V>\n\t *            The value type\n\t */\n\tprivate static class ValueComparator<T, V extends Comparable<V>> implements Comparator<T> {\n\n\t\tprivate Map<T, V> map;\n\n\t\tpublic ValueComparator(Map<T, V> map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(T o1, T o2) {\n\t\t\treturn map.get(o1).compareTo(map.get(o2));\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing peptide alpha-carbon atoms\n\t * \n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms) {\n\t\tthis(atoms, AMINO_ACID_MATCHER);\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only atoms matched by {@code matcher}.\n\t * \n\t * If multiple atoms are present from a group, the first atom encountered will\n\t * be used.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms, GroupMatcher matcher) {\n\t\thashMap = new HashMap<ResidueNumber, Integer>();\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tGroup group = atoms[i].getGroup();\n\t\t\tResidueNumber rn = group.getResidueNumber();\n\t\t\tif (matcher.matches(group)) {\n\t\t\t\tif (!hashMap.containsKey(rn)) {\n\t\t\t\t\thashMap.put(rn, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tComparator<ResidueNumber> vc = new ValueComparator<ResidueNumber, Integer>(hashMap);\n\t\ttreeMap = new TreeMap<ResidueNumber, Integer>(vc);\n\t\ttreeMap.putAll(hashMap);\n\t}\n\n\t/**\n\t * Calculates the number of residues of the specified chain in a given range, inclusive.\n\t * @param positionA index of the first atom to count\n\t * @param positionB index of the last atom to count\n\t * @param startingChain Case-sensitive chain\n\t * @return The number of atoms between A and B inclusive belonging to the given chain\n\t */\n\tpublic int getLength(int positionA, int positionB, String startingChain) {\n\t\t\n\t\tint positionStart, positionEnd;\n\t\tif (positionA <= positionB) {\n\t\t\tpositionStart = positionA;\n\t\t\tpositionEnd = positionB;\n\t\t} else {\n\t\t\tpositionStart = positionB;\n\t\t\tpositionEnd = positionA;\n\t\t}\n\n\t\tint count = 0;\n\t\t// Inefficient search\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : treeMap.entrySet()) {\n\t\t\tif (entry.getKey().getChainId().equals(startingChain)\n\t\t\t\t\t&& positionStart <= entry.getValue()\n\t\t\t\t\t&& entry.getValue() <= positionEnd)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Calculates the number of residues of the specified chain in a given range.\n\t * Will return a negative value if the start is past the end.\n\t * @param positionStart index of the first atom to count\n\t * @param positionEnd index of the last atom to count\n\t * @param startingChain Case-sensitive chain\n\t * @return The number of atoms from A to B inclusive belonging to the given chain\n\t */\n\tpublic int getLengthDirectional(int positionStart, int positionEnd, String startingChain) {\n\t\tint count = getLength(positionStart,positionEnd,startingChain);\n\t\tif(positionStart <= positionEnd) {\n\t\t\treturn count;\n\t\t} else {\n\t\t\treturn -count;\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n\t * must belong to the same chain.\n\t * @param start First residue\n\t * @param end Last residue\n\t * @return The number of atoms from A to B inclusive\n\t * @throws IllegalArgumentException if start and end are on different chains,\n\t *  or if either of the residues doesn't exist\n\t */\n\tpublic int getLength(ResidueNumber start, ResidueNumber end) {\n\t\tif( ! start.getChainId().equals(end.getChainId())) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Chains differ between %s and %s. Unable to calculate length.\",\n\t\t\t\t\tstart,end));\n\t\t}\n\t\tInteger startPos = getPosition(start);\n\t\tInteger endPos = getPosition(end);\n\t\tif(startPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\tif(endPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\treturn getLength(startPos, endPos, start.getChainId());\n\t}\n\n\t/**\n\t * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n\t * must belong to the same chain.\n\t * Will return a negative value if the start is past the end.\n\t * @param start First residue\n\t * @param end Last residue\n\t * @return The number of atoms from A to B inclusive\n\t * @throws IllegalArgumentException if start and end are on different chains,\n\t *  or if either of the residues doesn't exist\n\t */\n\tpublic int getLengthDirectional(ResidueNumber start, ResidueNumber end) {\n\t\tif( ! start.getChainId().equals(end.getChainId())) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Chains differ between %s and %s. Unable to calculate length.\",\n\t\t\t\t\tstart,end));\n\t\t}\n\t\tInteger startPos = getPosition(start);\n\t\tInteger endPos = getPosition(end);\n\t\tif(startPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\tif(endPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\treturn getLengthDirectional(startPos, endPos, start.getChainId());\n\t}\n\n\n\tpublic NavigableMap<ResidueNumber, Integer> getNavMap() {\n\t\treturn treeMap;\n\t}\n\n\t/**\n\t * Gets the 0-based index of residueNumber to the matched atoms\n\t * @param residueNumber\n\t * @return The position of the ATOM record in the PDB file corresponding to\n\t * the {@code residueNumber}, or null if the residueNumber was not found\n\t */\n\tpublic Integer getPosition(ResidueNumber residueNumber) {\n\t\treturn hashMap.get(residueNumber);\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The first {@link ResidueNumber} of the specified chain (the one highest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.firstEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.higherEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The last {@link ResidueNumber} of the specified chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.lastEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.lowerEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @return The first {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst() {\n\t\treturn treeMap.firstKey();\n\t}\n\n\t/**\n\t * @return The last {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast() {\n\t\treturn treeMap.lastKey();\n\t}\n\n\t/**\n\t * Returns a list of {@link ResidueRange ResidueRanges} corresponding to this entire AtomPositionMap.\n\t */\n\tpublic List<ResidueRangeAndLength> getRanges() {\n\t\tString currentChain = \"\";\n\t\tResidueNumber first = null;\n\t\tResidueNumber prev = null;\n\t\tList<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>();\n\t\tfor (ResidueNumber rn : treeMap.keySet()) {\n\t\t\tif (!rn.getChainId().equals(currentChain)) {\n\t\t\t\tif (first != null) {\n\t\t\t\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n\t\t\t\t\tranges.add(newRange);\n\t\t\t\t}\n\t\t\t\tfirst = rn;\n\t\t\t}\n\t\t\tprev = rn;\n\t\t\tcurrentChain = rn.getChainId();\n\t\t}\n\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n\t\tranges.add(newRange);\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Trims a residue range so that both endpoints are contained in this map.\n\t * @param rr\n\t * @param map\n\t * @return\n\t */\n\tpublic ResidueRangeAndLength trimToValidResidues(ResidueRange rr) {\n\t\tResidueNumber start = rr.getStart();\n\t\tResidueNumber end = rr.getEnd();\n\t\tString chain = rr.getChainId();\n\t\t// Add chainId\n\t\tif(start.getChainId() == null) {\n\t\t\tstart = new ResidueNumber(chain,start.getSeqNum(),start.getInsCode());\n\t\t}\n\t\tif(end.getChainId() == null) {\n\t\t\tend = new ResidueNumber(chain,end.getSeqNum(),end.getInsCode());\n\t\t}\n\t\t// Check that start and end are present in the map.\n\t\t// If not, try to find the next valid residue\n\t\t// (terminal residues sometimes lack CA atoms, so they don't appear)\n\t\tInteger startIndex = getPosition(start);\n\t\tif( startIndex == null) {\n\t\t\t// Assume that the residue numbers are sequential\n\t\t\t// Find startIndex such that the SeqNum is bigger than start's seqNum\n\t\t\tfor(ResidueNumber key :  treeMap.keySet()) {\n\t\t\t\tif( !key.getChainId().equals(chain) )\n\t\t\t\t\tcontinue;\n\t\t\t\tif( start.getSeqNum() <= key.getSeqNum() ) {\n\t\t\t\t\tstart = key;\n\t\t\t\t\tstartIndex = getPosition(key);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( startIndex == null ) {\n\t\t\t\tlogger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\",start);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Unable to find Residue {}, so substituting {}.\",rr.getStart(),start);\n\t\t\t}\n\t\t}\n\t\tInteger endIndex = getPosition(end);\n\t\tif( endIndex == null) {\n\t\t\t// Assume that the residue numbers are sequential\n\t\t\t// Find startIndex such that the SeqNum is bigger than start's seqNum\n\t\t\tfor(ResidueNumber key :  treeMap.descendingKeySet()) {\n\t\t\t\tif( !key.getChainId().equals(chain) )\n\t\t\t\t\tcontinue;\n\t\t\t\tInteger value = getPosition(key);\n\t\t\t\tif( value < startIndex ) {\n\t\t\t\t\t// start is before the end!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( end.getSeqNum() >= key.getSeqNum() ) {\n\t\t\t\t\tend = key;\n\t\t\t\t\tendIndex = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( endIndex == null ) {\n\t\t\t\tlogger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\",end);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Unable to find Residue {}, so substituting {}.\",rr.getEnd(),end);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now use those to calculate the length\n\t\t// if start or end is null, will throw NPE\n\t\tint length = getLength(startIndex, endIndex,chain);\n\n\t\treturn new ResidueRangeAndLength(chain, start, end, length);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.nbio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport org.biojava.nbio.structure.io.mmcif.chem.PolymerType;\nimport org.biojava.nbio.structure.io.mmcif.chem.ResidueType;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A map from {@link ResidueNumber ResidueNumbers} to ATOM record positions in a PDB file.\n * \n * <p>To use:\n * \n * <pre>\n * Atom[] atoms = new AtomCache().getAtoms(\"1w0p\");\n * AtomPositionMap map = new AtomPositionMap(atoms);\n * ResidueNumber start = new ResidueNumber(\"A\", 100, null);\n * ResidueNumber end = map.getEnd(\"A\");\n * int pos = map.getPosition(start);\n * int length = map.calcLength(start, end);\n * </pre>\n * \n * <p>Note: The getLength() methods were introduced in BioJava 4.0.0 to replace\n * the calcLength methods. The new method returns the number of residues between\n * two residues, inclusive, whereas the previous method returned 1 less than that.\n * @author dmyerstu\n */\npublic class AtomPositionMap {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomPositionMap.class);\n\t\n\tprivate HashMap<ResidueNumber, Integer> hashMap;\n\tprivate TreeMap<ResidueNumber, Integer> treeMap;\n\n\n\t/**\n\t * Used as a Predicate to indicate whether a particular Atom should be mapped\n\t */\n\tpublic static interface GroupMatcher {\n\t\tboolean matches(Group group);\n\t}\n\n\t/**\n\t * Matches CA atoms of protein groups\n\t */\n\tpublic static final GroupMatcher AMINO_ACID_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\tif( group == null )\n\t\t\t\treturn false;\n\t\t\tChemComp chem = group.getChemComp();\n\t\t\tif(chem == null)\n\t\t\t\treturn false;\n\t\t\t// Get polymer type\n\t\t\tPolymerType polyType = chem.getPolymerType();\n\t\t\tif( polyType == null) {\n\t\t\t\tResidueType type = chem.getResidueType();\n\t\t\t\tif(type != null ) {\n\t\t\t\t\tpolyType = type.getPolymerType();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( polyType == null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn PolymerType.PROTEIN_ONLY.contains(polyType)\n\t\t\t\t\t&& group.hasAtom(StructureTools.CA_ATOM_NAME);\n\t\t}\n\t};\n\n\t/**\n\t * Matches all atoms\n\t */\n\tpublic static final GroupMatcher ANYTHING_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * A map that is sorted by its values. Used for the treemap\n\t * \n\t * @author dmyerstu\n\t * \n\t * @param <T>\n\t *            The key type\n\t * @param <V>\n\t *            The value type\n\t */\n\tprivate static class ValueComparator<T, V extends Comparable<V>> implements Comparator<T> {\n\n\t\tprivate Map<T, V> map;\n\n\t\tpublic ValueComparator(Map<T, V> map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(T o1, T o2) {\n\t\t\treturn map.get(o1).compareTo(map.get(o2));\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing peptide alpha-carbon atoms\n\t * \n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms) {\n\t\tthis(atoms, AMINO_ACID_MATCHER);\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only atoms matched by {@code matcher}.\n\t * \n\t * If multiple atoms are present from a group, the first atom encountered will\n\t * be used.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms, GroupMatcher matcher) {\n\t\thashMap = new HashMap<ResidueNumber, Integer>();\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tGroup group = atoms[i].getGroup();\n\t\t\tResidueNumber rn = group.getResidueNumber();\n\t\t\tif (matcher.matches(group)) {\n\t\t\t\tif (!hashMap.containsKey(rn)) {\n\t\t\t\t\thashMap.put(rn, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tComparator<ResidueNumber> vc = new ValueComparator<ResidueNumber, Integer>(hashMap);\n\t\ttreeMap = new TreeMap<ResidueNumber, Integer>(vc);\n\t\ttreeMap.putAll(hashMap);\n\t}\n\n\t/**\n\t * Calculates the number of residues of the specified chain in a given range, inclusive.\n\t * @param positionA index of the first atom to count\n\t * @param positionB index of the last atom to count\n\t * @param startingChain Case-sensitive chain\n\t * @return The number of atoms between A and B inclusive belonging to the given chain\n\t */\n\tpublic int getLength(int positionA, int positionB, String startingChain) {\n\t\t\n\t\tint positionStart, positionEnd;\n\t\tif (positionA <= positionB) {\n\t\t\tpositionStart = positionA;\n\t\t\tpositionEnd = positionB;\n\t\t} else {\n\t\t\tpositionStart = positionB;\n\t\t\tpositionEnd = positionA;\n\t\t}\n\n\t\tint count = 0;\n\t\t// Inefficient search\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : treeMap.entrySet()) {\n\t\t\tif (entry.getKey().getChainId().equals(startingChain)\n\t\t\t\t\t&& positionStart <= entry.getValue()\n\t\t\t\t\t&& entry.getValue() <= positionEnd)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Calculates the number of residues of the specified chain in a given range.\n\t * Will return a negative value if the start is past the end.\n\t * @param positionStart index of the first atom to count\n\t * @param positionEnd index of the last atom to count\n\t * @param startingChain Case-sensitive chain\n\t * @return The number of atoms from A to B inclusive belonging to the given chain\n\t */\n\tpublic int getLengthDirectional(int positionStart, int positionEnd, String startingChain) {\n\t\tint count = getLength(positionStart,positionEnd,startingChain);\n\t\tif(positionStart <= positionEnd) {\n\t\t\treturn count;\n\t\t} else {\n\t\t\treturn -count;\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n\t * must belong to the same chain.\n\t * @param start First residue\n\t * @param end Last residue\n\t * @return The number of atoms from A to B inclusive\n\t * @throws IllegalArgumentException if start and end are on different chains,\n\t *  or if either of the residues doesn't exist\n\t */\n\tpublic int getLength(ResidueNumber start, ResidueNumber end) {\n\t\tif( ! start.getChainId().equals(end.getChainId())) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Chains differ between %s and %s. Unable to calculate length.\",\n\t\t\t\t\tstart,end));\n\t\t}\n\t\tInteger startPos = getPosition(start);\n\t\tInteger endPos = getPosition(end);\n\t\tif(startPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\tif(endPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\treturn getLength(startPos, endPos, start.getChainId());\n\t}\n\n\t/**\n\t * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n\t * must belong to the same chain.\n\t * Will return a negative value if the start is past the end.\n\t * @param start First residue\n\t * @param end Last residue\n\t * @return The number of atoms from A to B inclusive\n\t * @throws IllegalArgumentException if start and end are on different chains,\n\t *  or if either of the residues doesn't exist\n\t */\n\tpublic int getLengthDirectional(ResidueNumber start, ResidueNumber end) {\n\t\tif( ! start.getChainId().equals(end.getChainId())) {\n\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\"Chains differ between %s and %s. Unable to calculate length.\",\n\t\t\t\t\tstart,end));\n\t\t}\n\t\tInteger startPos = getPosition(start);\n\t\tInteger endPos = getPosition(end);\n\t\tif(startPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\tif(endPos == null) {\n\t\t\tthrow new IllegalArgumentException(\"Residue \"+start+\" was not found.\");\n\t\t}\n\t\treturn getLengthDirectional(startPos, endPos, start.getChainId());\n\t}\n\n\n\tpublic NavigableMap<ResidueNumber, Integer> getNavMap() {\n\t\treturn treeMap;\n\t}\n\n\t/**\n\t * Gets the 0-based index of residueNumber to the matched atoms\n\t * @param residueNumber\n\t * @return The position of the ATOM record in the PDB file corresponding to\n\t * the {@code residueNumber}, or null if the residueNumber was not found\n\t */\n\tpublic Integer getPosition(ResidueNumber residueNumber) {\n\t\treturn hashMap.get(residueNumber);\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The first {@link ResidueNumber} of the specified chain (the one highest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.firstEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.higherEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The last {@link ResidueNumber} of the specified chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.lastEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.lowerEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @return The first {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst() {\n\t\treturn treeMap.firstKey();\n\t}\n\n\t/**\n\t * @return The last {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast() {\n\t\treturn treeMap.lastKey();\n\t}\n\n\t/**\n\t * Returns a list of {@link ResidueRange ResidueRanges} corresponding to this entire AtomPositionMap.\n\t */\n\tpublic List<ResidueRangeAndLength> getRanges() {\n\t\tString currentChain = \"\";\n\t\tResidueNumber first = null;\n\t\tResidueNumber prev = null;\n\t\tList<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>();\n\t\tfor (ResidueNumber rn : treeMap.keySet()) {\n\t\t\tif (!rn.getChainId().equals(currentChain)) {\n\t\t\t\tif (first != null) {\n\t\t\t\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n\t\t\t\t\tranges.add(newRange);\n\t\t\t\t}\n\t\t\t\tfirst = rn;\n\t\t\t}\n\t\t\tprev = rn;\n\t\t\tcurrentChain = rn.getChainId();\n\t\t}\n\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n\t\tranges.add(newRange);\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Trims a residue range so that both endpoints are contained in this map.\n\t * @param rr\n\t * @param map\n\t * @return\n\t */\n\tpublic ResidueRangeAndLength trimToValidResidues(ResidueRange rr) {\n\t\tResidueNumber start = rr.getStart();\n\t\tResidueNumber end = rr.getEnd();\n\t\tString chain = rr.getChainId();\n\t\t// Add chainId\n\t\tif(start.getChainId() == null) {\n\t\t\tstart = new ResidueNumber(chain,start.getSeqNum(),start.getInsCode());\n\t\t}\n\t\tif(end.getChainId() == null) {\n\t\t\tend = new ResidueNumber(chain,end.getSeqNum(),end.getInsCode());\n\t\t}\n\t\t// Check that start and end are present in the map.\n\t\t// If not, try to find the next valid residue\n\t\t// (terminal residues sometimes lack CA atoms, so they don't appear)\n\t\tInteger startIndex = getPosition(start);\n\t\tif( startIndex == null) {\n\t\t\t// Assume that the residue numbers are sequential\n\t\t\t// Find startIndex such that the SeqNum is bigger than start's seqNum\n\t\t\tfor(ResidueNumber key :  treeMap.keySet()) {\n\t\t\t\tif( !key.getChainId().equals(chain) )\n\t\t\t\t\tcontinue;\n\t\t\t\tif( start.getSeqNum() <= key.getSeqNum() ) {\n\t\t\t\t\tstart = key;\n\t\t\t\t\tstartIndex = getPosition(key);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( startIndex == null ) {\n\t\t\t\tlogger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\",start);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Unable to find Residue {}, so substituting {}.\",rr.getStart(),start);\n\t\t\t}\n\t\t}\n\t\tInteger endIndex = getPosition(end);\n\t\tif( endIndex == null) {\n\t\t\t// Assume that the residue numbers are sequential\n\t\t\t// Find startIndex such that the SeqNum is bigger than start's seqNum\n\t\t\tfor(ResidueNumber key :  treeMap.descendingKeySet()) {\n\t\t\t\tif( !key.getChainId().equals(chain) )\n\t\t\t\t\tcontinue;\n\t\t\t\tInteger value = getPosition(key);\n\t\t\t\tif( value < startIndex ) {\n\t\t\t\t\t// start is before the end!\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( end.getSeqNum() >= key.getSeqNum() ) {\n\t\t\t\t\tend = key;\n\t\t\t\t\tendIndex = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( endIndex == null ) {\n\t\t\t\tlogger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\",end);\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Unable to find Residue {}, so substituting {}.\",rr.getEnd(),end);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now use those to calculate the length\n\t\t// if start or end is null, will throw NPE\n\t\tint length = getLength(startIndex, endIndex,chain);\n\n\t\treturn new ResidueRangeAndLength(chain, start, end, length);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.NavigableMap;\n\nimport static org.junit.Assert.*;\nimport static org.junit.Assume.*;\n\n/**\n * A unit test for {@link org.biojava.nbio.structure.AtomPositionMap}.\n * @author dmyerstu\n */\npublic class AtomPositionMapTest {\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache(); // TODO Should mock instead of depending on real data from AtomCache\n\t\tcache.setObsoleteBehavior(LocalPDBDirectory.ObsoleteBehavior.FETCH_OBSOLETE);\n\t}\n\n\tprivate AtomCache cache;\n\n\t/**\n\t * Tests with no insertion codes.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testEasy() throws IOException, StructureException { // no insertion codes\n\t\t// Straightforward case. Density for residues 25-777 (743 residues)\n\t\tString pdbId = \"1w0p\";\n\t\tint length = 93;\n\t\tResidueNumber start = new ResidueNumber(\"A\", 25, null);\n\t\tResidueNumber end = new ResidueNumber(\"A\", 117, null);\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tNavigableMap<ResidueNumber,Integer> navMap = map.getNavMap();\n\t\tfor (ResidueNumber n : navMap.keySet()) {\n\t\t\tassertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n\t\t}\n\t\tint realLength = map.getLength(start, end);\n\t\tassertEquals(\"Real atom length is wrong\", length, realLength);\n\t}\n\n\t@Test\n\tpublic void testLengths() throws IOException, StructureException {\n\t\t// Two identical chains, residues 1-68, no insertion codes or missing residues\n\t\tString pdbId = \"3w0e\";\n\n\t\tAtom[] atoms = cache.getAtoms(pdbId);\n\t\tAtomPositionMap map = new AtomPositionMap(atoms);\n\n\t\t// Double check that the chain length is correct\n\t\tint chainAlen = cache.getStructure(pdbId).getChainByPDB(\"A\").getAtomGroups(GroupType.AMINOACID).size();\n\t\tassumeTrue(68==chainAlen);\n\n\n\t\tint len;\n\t\tint start,end;// 0-based\n\n\t\t// Single residue\n\t\tstart = 0;\n\t\tend = 0;\n\t\tlen = map.getLength(new ResidueNumber(\"A\",start+1,null), new ResidueNumber(\"A\",end+1,null));\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLength(start, end,\"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\n\t\t// Short range\n\t\tstart = 2;\n\t\tend = 4;\n\t\tlen = map.getLength(new ResidueNumber(\"A\",start+1,null), new ResidueNumber(\"A\",end+1,null));\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",3, len);\n\t\tlen = map.getLength(start, end,\"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",3, len);\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",3, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-3, len);\n\n\t\t//Full chain\n\t\tstart = 0;\n\t\tend = chainAlen-1;\n\t\tlen = map.getLength(new ResidueNumber(\"A\",start+1,null), new ResidueNumber(\"A\",end+1,null));\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",chainAlen, len);\n\t\tlen = map.getLength(start, end,\"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",chainAlen, len);\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",chainAlen, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-chainAlen, len);\n\n\t\t// Chain spanning\n\t\tstart = chainAlen-1;\n\t\tend = chainAlen;\n\t\ttry {\n\t\t\tlen = map.getLength(new ResidueNumber(\"A\",chainAlen,null), new ResidueNumber(\"B\",1,null));\n\t\t\tfail(\"Not the same chain\");\n\t\t} catch( IllegalArgumentException e) {}\n\t\tlen = map.getLength(start, end,\"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-1, len);\n\t\tlen = map.getLengthDirectional(start,end, \"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\t\n\t\tstart = chainAlen-2; //2 residues of A\n\t\tend = chainAlen+2; // 3 residues of B\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",2, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-2, len);\n\t\tlen = map.getLengthDirectional(start, end, \"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",3, len);\n\t\tlen = map.getLengthDirectional(end, start, \"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-3, len);\n\n\t\tstart = 0;\n\t\tend = chainAlen;\n\t\ttry {\n\t\t\tlen = map.getLength(new ResidueNumber(\"A\",start+1,null), new ResidueNumber(\"A\",end+1,null));\n\t\t\tfail(\"Residue found from the wrong chain\");\n\t\t} catch( IllegalArgumentException e) {\n\t\t\t// end residue should be B1, not A142\n\t\t}\n\t\t// Chain Spanning\n\t\tlen = map.getLength(start, end,\"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(start, end, \"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",1, len);\n\t\tlen = map.getLengthDirectional(end, start, \"B\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-1, len);\n\t\tlen = map.getLength(start, end,\"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",chainAlen, len);\n\t\tlen = map.getLengthDirectional(start, end, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",chainAlen, len);\n\t\tlen = map.getLengthDirectional(end, start, \"A\");\n\t\tassertEquals(\"Bad length for (\"+start+\",\"+end+\")\",-chainAlen, len);\n\t}\n\n\t/**\n\t * Tests with insertion codes.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testInsertionCodes() throws IOException, StructureException {\n\t\tString pdbId = \"1qdm\";\n\t\t// has 2 insertion code regions, lettered P and S, as well as disordered regions:\n\t\t// 6P-26P,2-163,169-247,1S-37S,65S-104S,248-338\n\t\t// Len:21,  162,     79,    37,      40,     91 = 430\n\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tNavigableMap<ResidueNumber,Integer> navMap = map.getNavMap();\n\n\t\tfor (ResidueNumber n : navMap.keySet()) {\n\t\t\tassertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n\t\t}\n\n\t\tint length1 = 60; // 2+37+21\n\t\tint length2 = 132;// 2+37+40+53\n\t\tResidueNumber start = new ResidueNumber(\"A\", 246, null);\n\t\tResidueNumber mid = new ResidueNumber(\"A\", 85, 'S');\n\t\tResidueNumber end = new ResidueNumber(\"A\", 300, null);\n\t\tint realLength1 = map.getLength(start, mid);\n\t\tassertEquals(\"Real atom length is wrong\", length1, realLength1);\n\t\tint realLength2 = map.getLength(start, end);\n\t\tassertEquals(\"Real atom length is wrong\", length2, realLength2);\n\t\t\n\t\tint realLength = map.getLength(new ResidueNumber(\"A\",6,'P'),new ResidueNumber(\"A\",338,null));\n\t\tassertEquals(\"Full length wrong\",430,realLength);\n\t}\n\n\t@Test\n\tpublic void testTrim() throws IOException, StructureException {\n\t\t// Two identical chains, residues 1-68, no insertion codes or missing residues\n\t\tString pdbId = \"3w0e\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\t\n\t\tResidueRangeAndLength trimmed;\n\t\tResidueRange untrimmed;\n\t\t\n\t\tuntrimmed = new ResidueRange(\"A\", \"1\", \"68\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertEquals(\"Wrong start after trimming \"+untrimmed,new ResidueNumber(\"A\", 1, null), trimmed.getStart());\n\t\tassertEquals(\"Wrong end after trimming \"+untrimmed,new ResidueNumber(\"A\", 68, null), trimmed.getEnd());\n\t\tassertEquals(\"Wrong length after trimming \"+untrimmed,68, trimmed.getLength());\n\n\t\tuntrimmed = new ResidueRange(\"A\", \"1\", \"1\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertEquals(\"Wrong start after trimming \"+untrimmed,new ResidueNumber(\"A\", 1, null), trimmed.getStart());\n\t\tassertEquals(\"Wrong end after trimming \"+untrimmed,new ResidueNumber(\"A\", 1, null), trimmed.getEnd());\n\t\tassertEquals(\"Wrong length after trimming \"+untrimmed,1, trimmed.getLength());\n\n\t\tuntrimmed = new ResidueRange(\"A\", \"-1\", \"70\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertEquals(\"Wrong start after trimming \"+untrimmed,new ResidueNumber(\"A\", 1, null), trimmed.getStart());\n\t\tassertEquals(\"Wrong end after trimming \"+untrimmed,new ResidueNumber(\"A\", 68, null), trimmed.getEnd());\n\t\tassertEquals(\"Wrong length after trimming \"+untrimmed,68, trimmed.getLength());\n\n\t\t// Fully out of range\n\t\tuntrimmed = new ResidueRange(\"A\", \"-4\", \"-1\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertNull(\"Should be empty range \"+untrimmed,trimmed);\n\n\t\t// Start before end. Arguably should be invalid, but currently works\n\t\tuntrimmed = new ResidueRange(\"A\", \"4\", \"1\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertEquals(\"Wrong start after trimming \"+untrimmed,new ResidueNumber(\"A\", 4, null), trimmed.getStart());\n\t\tassertEquals(\"Wrong end after trimming \"+untrimmed,new ResidueNumber(\"A\", 1, null), trimmed.getEnd());\n\t\tassertEquals(\"Wrong length after trimming \"+untrimmed,4, trimmed.getLength());\n\n\t\t// However, doesn't work if the endpoints are invalid, since searches wrong direction\n\t\tuntrimmed = new ResidueRange(\"A\", \"4\", \"-1\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertNull(\"Should be empty range \"+untrimmed,trimmed);\n\n\t\tuntrimmed = new ResidueRange(\"A\", \"70\", \"50\");\n\t\ttrimmed = map.trimToValidResidues(untrimmed);\n\t\tassertNull(\"Should be empty range \"+untrimmed,trimmed);\n\n\t}\n\n\t@Test\n\tpublic void testChains() throws IOException, StructureException {\n\t\tString pdbId = \"1qdm\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\n\t\tResidueNumber start,end;\n\t\ttry {\n\t\t\tstart = new ResidueNumber(\"A\",6,'P');\n\t\t\tend = new ResidueNumber(\"B\",338,null);\n\t\t\tmap.getLength(start, end);\n\t\t\tfail(\"Chain missmatch\");\n\t\t} catch(IllegalArgumentException e) {\n\t\t\t// Expected\n\t\t}\n\t\ttry {\n\t\t\tstart = new ResidueNumber(\"A\",6,'P');\n\t\t\tend = new ResidueNumber(\"B\",338,null);\n\t\t\tmap.getLengthDirectional(start, end);\n\t\t\tfail(\"Chain missmatch\");\n\t\t} catch(IllegalArgumentException e) {\n\t\t\t// Expected\n\t\t}\n\n\t\t// With integers, only count matching chain atoms\n\t\tstart = new ResidueNumber(\"A\",338,null);\n\t\tend = new ResidueNumber(\"B\",6,'P');\n\t\tint len = map.getLength(map.getPosition(start),map.getPosition(end),\"A\");\n\t\tassertEquals(1, len);\n\t}\n}\n","changedTest":"","commitMessage":"Updated PolymerType and ResidueType for mmCIF 4.052\n\nAlso fix AtomPositionMap to avoid NullPointers upon encounters with\nunknown types.","test_commitMessage":"","allZero":false}