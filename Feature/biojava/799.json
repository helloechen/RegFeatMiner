{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/BasePairParameters.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestBasePairParameters.java","prod_time":"2017-07-21 13:21:30","test_time":"2017-07-21 13:21:30","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":5,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"4632f968428a7080237ce294ad23aff0a95fe981","test_commitID":"4632f968428a7080237ce294ad23aff0a95fe981","isfound":"found test change","originPro":"package org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.biojava.nbio.structure.io.PDBFileReader;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\n/**\n * Contributed to BioJava under its LGPL\n * This module calculates the el Hassan-Calladine Base Pairing and Base-pair Step Parameters\n * Citation: https://www.ncbi.nlm.nih.gov/pubmed/11601858\n *\n * Created by luke on 7/20/17.\n */\npublic class BasePairParameters {\n\n    private static String[] standardBases = new String[] {\n            \"SEQRES   1 A    1  A\\n\" +\n                    \"ATOM      2  N9    A A   1      -1.291   4.498   0.000\\n\" +\n                    \"ATOM      3  C8    A A   1       0.024   4.897   0.000\\n\" +\n                    \"ATOM      4  N7    A A   1       0.877   3.902   0.000\\n\" +\n                    \"ATOM      5  C5    A A   1       0.071   2.771   0.000\\n\" +\n                    \"ATOM      6  C6    A A   1       0.369   1.398   0.000\\n\" +\n                    \"ATOM      8  N1    A A   1      -0.668   0.532   0.000\\n\" +\n                    \"ATOM      9  C2    A A   1      -1.912   1.023   0.000\\n\" +\n                    \"ATOM     10  N3    A A   1      -2.320   2.290   0.000\\n\" +\n                    \"ATOM     11  C4    A A   1      -1.267   3.124   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  G\\n\" +\n                    \"ATOM      2  N9    G A   1      -1.289   4.551   0.000\\n\" +\n                    \"ATOM      3  C8    G A   1       0.023   4.962   0.000\\n\" +\n                    \"ATOM      4  N7    G A   1       0.870   3.969   0.000\\n\" +\n                    \"ATOM      5  C5    G A   1       0.071   2.833   0.000\\n\" +\n                    \"ATOM      6  C6    G A   1       0.424   1.460   0.000\\n\" +\n                    \"ATOM      8  N1    G A   1      -0.700   0.641   0.000\\n\" +\n                    \"ATOM      9  C2    G A   1      -1.999   1.087   0.000\\n\" +\n                    \"ATOM     11  N3    G A   1      -2.342   2.364   0.001\\n\" +\n                    \"ATOM     12  C4    G A   1      -1.265   3.177   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  T\\n\" +\n                    \"ATOM      2  N1    T A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    T A   1      -1.462   3.135   0.000\\n\" +\n                    \"ATOM      5  N3    T A   1      -0.298   2.407   0.000\\n\" +\n                    \"ATOM      6  C4    T A   1       0.994   2.897   0.000\\n\" +\n                    \"ATOM      8  C5    T A   1       1.106   4.338   0.000\\n\" +\n                    \"ATOM     10  C6    T A   1      -0.024   5.057   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  C\\n\" +\n                    \"ATOM      2  N1    C A   1      -1.285   4.542   0.000\\n\" +\n                    \"ATOM      3  C2    C A   1      -1.472   3.158   0.000\\n\" +\n                    \"ATOM      5  N3    C A   1      -0.391   2.344   0.000\\n\" +\n                    \"ATOM      6  C4    C A   1       0.837   2.868   0.000\\n\" +\n                    \"ATOM      8  C5    C A   1       1.056   4.275   0.000\\n\" +\n                    \"ATOM      9  C6    C A   1      -0.023   5.068   0.000\\n\" +\n                    \"END\"\n    };\n\n    private static String[] baseListDNA = {\"A\", \"G\", \"T\", \"C\"};\n    private static String[] baseListRNA = {\"A\", \"G\", \"U\", \"C\"};\n    private static Map<String, Integer> map;\n    private static Map<Integer, List<String>> ringMap;\n    static {\n        map = new HashMap<>();\n        map.put(\"DA\", 0); map.put(\"ADE\", 0); map.put(\"A\", 0);\n        map.put(\"DG\", 1); map.put(\"GUA\", 1); map.put(\"G\", 1);\n        map.put(\"DT\", 2); map.put(\"THY\", 2); map.put(\"T\", 2); //RNA lines: map.put(\"U\", 2); map.put(\"URA\", 2);\n        map.put(\"DC\", 3); map.put(\"CYT\", 3); map.put(\"C\", 3);\n        // chemically modified bases, leaving out right now.\n        //map.put(\"DZM\", 0);\n        //map.put(\"UCL\", 2);\n        //map.put(\"2DT\", 2);\n        //map.put(\"1CC\", 3); map.put(\"5CM\", 3);\n        ringMap = new HashMap<>();\n        ringMap.put(0, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        ringMap.put(1, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        ringMap.put(2, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n        ringMap.put(3, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n   }\n\n    private Structure structure;\n    private String pairSequence = \"\", pdbId = \"\";\n\n    private double[] pairParameters;\n    private double[][] pairingParameters;\n    private double[][] stepParameters;\n\n\n    // Either pass the name of a PDB file (ending in .pdb) or pass the pdbId\n    public BasePairParameters(String name) {\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        pdbFileReader.setPath(\".\");\n        try {\n            if (name.contains(\".pdb\")) structure = pdbFileReader.getStructure(name);\n            else structure = StructureIO.getStructure(name);\n            pdbId = name.replace(\".pdb\", \"\");\n            List<Chain> nucleics = this.getNucleicChains(false);\n            List<Group[]> pairs = this.findPairs(nucleics);\n            pairingParameters = new double[pairs.size()][6];\n            stepParameters = new double[pairs.size()][6];\n            Matrix4d lastStep = null;\n            Matrix4d currentStep = null;\n            for (int i = 0; i < pairs.size(); i++) {\n                lastStep = currentStep;\n                currentStep = this.basePairReferenceFrame(pairs.get(i));\n                for (int j = 0; j < 6; j++) pairingParameters[i][j] = pairParameters[j];\n                if (i != 0) {\n                    lastStep.invert();\n                    lastStep.mul(currentStep);\n                    double[] sparms = calculatetp(lastStep);\n                    for (int j = 0; j < 6; j++) stepParameters[i][j] = sparms[j];\n                }\n;            }\n        } catch (IOException|StructureException e) {\n            System.out.println(\"Error reading file from local drive or internet\");\n            structure = null;\n        }\n    }\n\n    public double[][] getPairingParameters() {\n        return pairingParameters;\n    }\n\n    public double[][] getStepParameters() {\n        return stepParameters;\n    }\n\n    public String getPairSequence() {\n        return pairSequence;\n    }\n\n    public List<Chain> getNucleicChains(boolean removeDups) {\n        if (structure == null) return new ArrayList<>();\n        List<Chain> chains = structure.getChains();\n        List<Chain> result = new ArrayList<>();\n        for (Chain c: chains) {\n            //EntityInfo ei = c.getEntityInfo();\n            if (c.isNucleicAcid()) {\n                result.add(c);\n            }\n            //result.add(c);\n        }\n        if (removeDups) for (int i = 0; i < result.size(); i++) {\n            for (int j = i+2; j < result.size(); j++) {\n                // remove double\n                if (result.get(i).getSeqResSequence().equals(result.get(j).getSeqResSequence())) {\n                    result.remove(j);\n                }\n            }\n        }\n        return result;\n    }\n\n\n    public List<Group[]> findPairs(List<Chain> chains) {\n        List<Group[]> result = new ArrayList<>();\n        for (int i = 0; i < chains.size(); i++) {\n            Chain c = chains.get(i);\n            for (int j = i+1; j < chains.size(); j++) {\n                String complement = complement(chains.get(j).getSeqResSequence(), false);\n                String match = longestCommonSubstring(c.getSeqResSequence(), complement);\n                //System.out.println(c.getSeqResSequence() + \" \" + chains.get(j).getSeqResSequence() + \" \" + match);\n                int index1 = c.getSeqResSequence().indexOf(match);\n                int index2 = complement.length() - complement.indexOf(match) - 1;\n                for (int k = 0; k < match.length(); k++) {\n                    Group g1 = c.getSeqResGroup(index1+k);\n                    Group g2 = chains.get(j).getSeqResGroup(index2-k);\n                    Integer type1 = map.get(g1.getPDBName());\n                    Integer type2 = map.get(g2.getPDBName());\n                    if (type1 == null || type2 == null) {\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    Atom a1 = g1.getAtom(ringMap.get(type1).get(0));\n                    Atom a2 = g2.getAtom(ringMap.get(type2).get(0));\n\n                    if (a1 == null) {\n                        System.out.println(\"Error processing \" + g1.getPDBName() + \" in \" + pdbId);\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    if (a2 == null) {\n                        System.out.println(\"Error processing \" + g2.getPDBName() + \" in \" + pdbId);\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n\n                    double dx = a1.getX()-a2.getX();\n                    double dy = a1.getY()-a2.getY();\n                    double dz = a1.getZ()-a2.getZ();\n                    double distance = Math.sqrt(dx*dx+dy*dy+dz*dz);\n                    //System.out.println(\"C8-C6 Distance (Å): \" + distance);\n                    // could be a base pair\n                    if (Math.abs(distance-10.0) < 2.0) {\n                        boolean valid = true;\n                        for (String atomname : ringMap.get(type1)) {\n                            Atom a = g1.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) for (String atomname: ringMap.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) {\n                            Group g3 = null;\n                            Group g4 = null;\n                            if (k + 1 < match.length()) g3 = c.getSeqResGroup(index1 + k + 1);\n                            if (k != 0) g4 = c.getSeqResGroup(index1 + k - 1);\n                            result.add(new Group[]{g1, g2, g3, g4});\n                            pairSequence += c.getSeqResSequence().charAt(index1 + k);\n                        } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                }\n                if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n            }\n            //System.out.println();\n        }\n        System.out.println(\"Matched: \" + pairSequence);\n        return result;\n    }\n\n\n\n    public Matrix4d basePairReferenceFrame(Group[] pair) {\n        Integer type1 = map.get(pair[0].getPDBName());\n        Integer type2 = map.get(pair[1].getPDBName());\n        SuperPosition sp = new SuperPositionQCP(true);\n        if (type1 == null || type2 == null) return null;\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        Structure s1, s2;\n        try {\n            s1 = pdbFileReader.getStructure(new ByteArrayInputStream(standardBases[type1].getBytes()));\n            s2 = pdbFileReader.getStructure(new ByteArrayInputStream(standardBases[type2].getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        Group std1 = s1.getChain(\"A\").getAtomGroup(0);\n        Group std2 = s2.getChain(\"A\").getAtomGroup(0);\n\n        Point3d[] pointref = new Point3d[std1.getAtoms().size()];\n        Point3d[] pointact = new Point3d[std1.getAtoms().size()];\n        int count = 0;\n\n        for (Atom a : std1.getAtoms()) {\n            if (pair[0].getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair[0].getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std1.getAtoms().size();\n        Matrix4d ref1 = (Matrix4d)sp.superposeAndTransform(pointact, pointref).clone();\n\n        pointref = new Point3d[std2.getAtoms().size()];\n        pointact = new Point3d[std2.getAtoms().size()];\n\n        count = 0;\n        for (Atom a : std2.getAtoms()) {\n            if (pair[1].getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair[1].getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std2.getAtoms().size();\n\n        //    System.out.println(ref1);\n        Matrix4d temp = (Matrix4d)ref1.clone();\n        Matrix4d temp2 = (Matrix4d)temp.clone();\n        Matrix4d ref2 = sp.superposeAndTransform(pointact, pointref);\n        //    System.out.println(ref2);\n        double[][] v = new double[3][4];\n        double[] y3 = new double[4];\n        double[] z3 = new double[4];\n        ref2.getColumn(1, y3);\n        ref2.getColumn(2, z3);\n        for (int i = 0; i < 3; i++) {\n            y3[i] *= -1.0;\n            z3[i] *= -1.0;\n        }\n        ref2.setColumn(1, y3);\n        ref2.setColumn(2, z3);\n        temp.add(ref2);\n        temp.mul(0.5);\n        for (int i = 0; i < 3; i++) {\n            temp.getColumn(i, v[i]);\n            double r = Math.sqrt(v[i][0] * v[i][0] + v[i][1] * v[i][1] + v[i][2] * v[i][2]);\n            for (int j = 0; j < 3; j++) {\n                v[i][j] /= r;\n            }\n            temp.setColumn(i, v[i]);\n        }\n\n        // calculate pairing parameters: buckle, propeller, opening, shear, stretch, stagger\n        temp2.invert();\n        temp2.mul(ref2);\n        pairParameters = calculatetp(temp2);\n        for (int i = 0; i < 6; i++) pairParameters[i] *= -1;\n\n        // return the central frame of the base pair\n        return temp;\n\n    }\n\n\n\n    /**\n     * This method calculates pairing and step parameters from 4x4 transformation matrices\n     * that come out as Matrix4d;\n     * @param input the 4x4 matrix representing the transformation from strand II -> strand I or pair i to pair i+1\n     * @return Six parameters as double[6]\n     */\n    public static double[] calculatetp(Matrix4d input) {\n\n        double[][] A = new double[4][4];\n        for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) {\n            A[i][j] = input.getElement(i, j);\n        }\n        double[] M = new double[6];\n\n        double cosgamma, gamma, phi, omega, sgcp, omega2_minus_phi,\n                sm, cm, sp, cp, sg, cg;\n\n        cosgamma = A[2][2];\n        if (cosgamma > 1.0) cosgamma = 1.0;\n        else if (cosgamma < -1.0) cosgamma = -1.0;\n\n        gamma = acos(cosgamma);\n\n        sgcp = A[1][1]*A[0][2]-A[0][1]*A[1][2];\n\n        if (gamma == 0.0) omega = -atan2(A[0][1],A[1][1]);\n        else omega = atan2(A[2][1]*A[0][2]+sgcp*A[1][2],sgcp*A[0][2]-A[2][1]*A[1][2]);\n\n        omega2_minus_phi = atan2(A[1][2],A[0][2]);\n\n        phi = omega/2.0 - omega2_minus_phi;\n\n        M[0] = gamma*sin(phi)*180.0/PI;\n        M[1] = gamma*cos(phi)*180.0/PI;\n        M[2] = omega*180.0/PI;\n\n        sm = sin(omega/2.0-phi);\n        cm = cos(omega/2.0-phi);\n        sp = sin(phi);\n        cp = cos(phi);\n        sg = sin(gamma/2.0);\n        cg = cos(gamma/2.0);\n\n        M[3] = (cm*cg*cp-sm*sp)*A[0][3]+(sm*cg*cp+cm*sp)*A[1][3]-sg*cp*A[2][3];\n        M[4] = (-cm*cg*sp-sm*cp)*A[0][3]+(-sm*cg*sp+cm*cp)*A[1][3]+sg*sp*A[2][3];\n        M[5] = (cm*sg)*A[0][3]+(sm*sg)*A[1][3]+cg*A[2][3];\n\n        return M;\n\n    }\n\n\n    public static char complementBase(char base, boolean RNA) {\n        if (base == 'A' && RNA) return 'U';\n        if (base == 'A') return 'T';\n        if (base == 'T') return 'A';\n        if (base == 'U') return 'A';\n        if (base == 'C') return 'G';\n        if (base == 'G') return 'C';\n        return ' ';\n    }\n\n    public static String complement(String sequence, boolean RNA) {\n        String result = \"\";\n        for (int i = sequence.length() - 1; i >= 0; i--) {\n            result += complementBase(sequence.charAt(i), RNA);\n        }\n        return result;\n    }\n\n\n    public static String longestCommonSubstring(String s1, String s2) {\n        int start = 0;\n        int max = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            for (int j = 0; j < s2.length(); j++) {\n                int x = 0;\n                while (s1.charAt(i + x) == s2.charAt(j + x)) {\n                    x++;\n                    if (((i + x) >= s1.length()) || ((j + x) >= s2.length())) break;\n                }\n                if (x > max) {\n                    max = x;\n                    start = i;\n                }\n            }\n        }\n        return s1.substring(start, (start + max));\n    }\n\n}\n","changedPro":"package org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.biojava.nbio.structure.io.PDBFileReader;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.*;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.lang.Math.*;\n\n/**\n * Contributed to BioJava under its LGPL\n * This module calculates the el Hassan-Calladine Base Pairing and Base-pair Step Parameters\n * Citation: https://www.ncbi.nlm.nih.gov/pubmed/11601858\n *\n * Created by luke on 7/20/17.\n */\npublic class BasePairParameters {\n\n    private static Logger log = LoggerFactory.getLogger(BasePairParameters.class);\n    \n    private static String[] standardBases = new String[] {\n            \"SEQRES   1 A    1  A\\n\" +\n                    \"ATOM      2  N9    A A   1      -1.291   4.498   0.000\\n\" +\n                    \"ATOM      3  C8    A A   1       0.024   4.897   0.000\\n\" +\n                    \"ATOM      4  N7    A A   1       0.877   3.902   0.000\\n\" +\n                    \"ATOM      5  C5    A A   1       0.071   2.771   0.000\\n\" +\n                    \"ATOM      6  C6    A A   1       0.369   1.398   0.000\\n\" +\n                    \"ATOM      8  N1    A A   1      -0.668   0.532   0.000\\n\" +\n                    \"ATOM      9  C2    A A   1      -1.912   1.023   0.000\\n\" +\n                    \"ATOM     10  N3    A A   1      -2.320   2.290   0.000\\n\" +\n                    \"ATOM     11  C4    A A   1      -1.267   3.124   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  G\\n\" +\n                    \"ATOM      2  N9    G A   1      -1.289   4.551   0.000\\n\" +\n                    \"ATOM      3  C8    G A   1       0.023   4.962   0.000\\n\" +\n                    \"ATOM      4  N7    G A   1       0.870   3.969   0.000\\n\" +\n                    \"ATOM      5  C5    G A   1       0.071   2.833   0.000\\n\" +\n                    \"ATOM      6  C6    G A   1       0.424   1.460   0.000\\n\" +\n                    \"ATOM      8  N1    G A   1      -0.700   0.641   0.000\\n\" +\n                    \"ATOM      9  C2    G A   1      -1.999   1.087   0.000\\n\" +\n                    \"ATOM     11  N3    G A   1      -2.342   2.364   0.001\\n\" +\n                    \"ATOM     12  C4    G A   1      -1.265   3.177   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  T\\n\" +\n                    \"ATOM      2  N1    T A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    T A   1      -1.462   3.135   0.000\\n\" +\n                    \"ATOM      5  N3    T A   1      -0.298   2.407   0.000\\n\" +\n                    \"ATOM      6  C4    T A   1       0.994   2.897   0.000\\n\" +\n                    \"ATOM      8  C5    T A   1       1.106   4.338   0.000\\n\" +\n                    \"ATOM     10  C6    T A   1      -0.024   5.057   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  C\\n\" +\n                    \"ATOM      2  N1    C A   1      -1.285   4.542   0.000\\n\" +\n                    \"ATOM      3  C2    C A   1      -1.472   3.158   0.000\\n\" +\n                    \"ATOM      5  N3    C A   1      -0.391   2.344   0.000\\n\" +\n                    \"ATOM      6  C4    C A   1       0.837   2.868   0.000\\n\" +\n                    \"ATOM      8  C5    C A   1       1.056   4.275   0.000\\n\" +\n                    \"ATOM      9  C6    C A   1      -0.023   5.068   0.000\\n\" +\n                    \"END\"\n    };\n\n    private static String[] baseListDNA = {\"A\", \"G\", \"T\", \"C\"};\n    private static String[] baseListRNA = {\"A\", \"G\", \"U\", \"C\"};\n    private static Map<String, Integer> map;\n    private static Map<Integer, List<String>> ringMap;\n    static {\n        map = new HashMap<>();\n        map.put(\"DA\", 0); map.put(\"ADE\", 0); map.put(\"A\", 0);\n        map.put(\"DG\", 1); map.put(\"GUA\", 1); map.put(\"G\", 1);\n        map.put(\"DT\", 2); map.put(\"THY\", 2); map.put(\"T\", 2); //RNA lines: map.put(\"U\", 2); map.put(\"URA\", 2);\n        map.put(\"DC\", 3); map.put(\"CYT\", 3); map.put(\"C\", 3);\n        // chemically modified bases, leaving out right now.\n        //map.put(\"DZM\", 0);\n        //map.put(\"UCL\", 2);\n        //map.put(\"2DT\", 2);\n        //map.put(\"1CC\", 3); map.put(\"5CM\", 3);\n        ringMap = new HashMap<>();\n        ringMap.put(0, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        ringMap.put(1, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        ringMap.put(2, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n        ringMap.put(3, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n   }\n\n    private Structure structure;\n    private String pairSequence = \"\", pdbId = \"\";\n\n    private double[] pairParameters;\n    private double[][] pairingParameters;\n    private double[][] stepParameters;\n\n\n    // Either pass the name of a PDB file (ending in .pdb) or pass the pdbId\n    public BasePairParameters(String name) {\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        pdbFileReader.setPath(\".\");\n        try {\n            if (name.contains(\".pdb\")) structure = pdbFileReader.getStructure(name);\n            else structure = StructureIO.getStructure(name);\n            pdbId = name.replace(\".pdb\", \"\");\n            List<Chain> nucleics = this.getNucleicChains(false);\n            List<Group[]> pairs = this.findPairs(nucleics);\n            pairingParameters = new double[pairs.size()][6];\n            stepParameters = new double[pairs.size()][6];\n            Matrix4d lastStep = null;\n            Matrix4d currentStep = null;\n            for (int i = 0; i < pairs.size(); i++) {\n                lastStep = currentStep;\n                currentStep = this.basePairReferenceFrame(pairs.get(i));\n                for (int j = 0; j < 6; j++) pairingParameters[i][j] = pairParameters[j];\n                if (i != 0) {\n                    lastStep.invert();\n                    lastStep.mul(currentStep);\n                    double[] sparms = calculatetp(lastStep);\n                    for (int j = 0; j < 6; j++) stepParameters[i][j] = sparms[j];\n                }\n;            }\n        } catch (IOException|StructureException e) {\n            log.info(\"Error reading file from local drive or internet\");\n            structure = null;\n        }\n    }\n\n    public double[][] getPairingParameters() {\n        return pairingParameters;\n    }\n\n    public double[][] getStepParameters() {\n        return stepParameters;\n    }\n\n    public String getPairSequence() {\n        return pairSequence;\n    }\n\n    public List<Chain> getNucleicChains(boolean removeDups) {\n        if (structure == null) return new ArrayList<>();\n        List<Chain> chains = structure.getChains();\n        List<Chain> result = new ArrayList<>();\n        for (Chain c: chains) {\n            //EntityInfo ei = c.getEntityInfo();\n            if (c.isNucleicAcid()) {\n                result.add(c);\n            }\n            //result.add(c);\n        }\n        if (removeDups) for (int i = 0; i < result.size(); i++) {\n            for (int j = i+2; j < result.size(); j++) {\n                // remove double\n                if (result.get(i).getSeqResSequence().equals(result.get(j).getSeqResSequence())) {\n                    result.remove(j);\n                }\n            }\n        }\n        return result;\n    }\n\n\n    public List<Group[]> findPairs(List<Chain> chains) {\n        List<Group[]> result = new ArrayList<>();\n        for (int i = 0; i < chains.size(); i++) {\n            Chain c = chains.get(i);\n            for (int j = i+1; j < chains.size(); j++) {\n                String complement = complement(chains.get(j).getSeqResSequence(), false);\n                String match = longestCommonSubstring(c.getSeqResSequence(), complement);\n                //log.info(c.getSeqResSequence() + \" \" + chains.get(j).getSeqResSequence() + \" \" + match);\n                int index1 = c.getSeqResSequence().indexOf(match);\n                int index2 = complement.length() - complement.indexOf(match) - 1;\n                for (int k = 0; k < match.length(); k++) {\n                    Group g1 = c.getSeqResGroup(index1+k);\n                    Group g2 = chains.get(j).getSeqResGroup(index2-k);\n                    Integer type1 = map.get(g1.getPDBName());\n                    Integer type2 = map.get(g2.getPDBName());\n                    if (type1 == null || type2 == null) {\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    Atom a1 = g1.getAtom(ringMap.get(type1).get(0));\n                    Atom a2 = g2.getAtom(ringMap.get(type2).get(0));\n\n                    if (a1 == null) {\n                        log.info(\"Error processing \" + g1.getPDBName() + \" in \" + pdbId);\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    if (a2 == null) {\n                        log.info(\"Error processing \" + g2.getPDBName() + \" in \" + pdbId);\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n\n                    double dx = a1.getX()-a2.getX();\n                    double dy = a1.getY()-a2.getY();\n                    double dz = a1.getZ()-a2.getZ();\n                    double distance = Math.sqrt(dx*dx+dy*dy+dz*dz);\n                    //log.info(\"C8-C6 Distance (Å): \" + distance);\n                    // could be a base pair\n                    if (Math.abs(distance-10.0) < 2.0) {\n                        boolean valid = true;\n                        for (String atomname : ringMap.get(type1)) {\n                            Atom a = g1.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) for (String atomname: ringMap.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) {\n                            Group g3 = null;\n                            Group g4 = null;\n                            if (k + 1 < match.length()) g3 = c.getSeqResGroup(index1 + k + 1);\n                            if (k != 0) g4 = c.getSeqResGroup(index1 + k - 1);\n                            result.add(new Group[]{g1, g2, g3, g4});\n                            pairSequence += c.getSeqResSequence().charAt(index1 + k);\n                        } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                }\n                if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n            }\n            //log.info();\n        }\n        log.info(\"Matched: \" + pairSequence);\n        return result;\n    }\n\n\n\n    public Matrix4d basePairReferenceFrame(Group[] pair) {\n        Integer type1 = map.get(pair[0].getPDBName());\n        Integer type2 = map.get(pair[1].getPDBName());\n        SuperPosition sp = new SuperPositionQCP(true);\n        if (type1 == null || type2 == null) return null;\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        Structure s1, s2;\n        try {\n            s1 = pdbFileReader.getStructure(new ByteArrayInputStream(standardBases[type1].getBytes()));\n            s2 = pdbFileReader.getStructure(new ByteArrayInputStream(standardBases[type2].getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        Group std1 = s1.getChain(\"A\").getAtomGroup(0);\n        Group std2 = s2.getChain(\"A\").getAtomGroup(0);\n\n        Point3d[] pointref = new Point3d[std1.getAtoms().size()];\n        Point3d[] pointact = new Point3d[std1.getAtoms().size()];\n        int count = 0;\n\n        for (Atom a : std1.getAtoms()) {\n            if (pair[0].getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair[0].getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std1.getAtoms().size();\n        Matrix4d ref1 = (Matrix4d)sp.superposeAndTransform(pointact, pointref).clone();\n\n        pointref = new Point3d[std2.getAtoms().size()];\n        pointact = new Point3d[std2.getAtoms().size()];\n\n        count = 0;\n        for (Atom a : std2.getAtoms()) {\n            if (pair[1].getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair[1].getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std2.getAtoms().size();\n\n        //    log.info(ref1);\n        Matrix4d temp = (Matrix4d)ref1.clone();\n        Matrix4d temp2 = (Matrix4d)temp.clone();\n        Matrix4d ref2 = sp.superposeAndTransform(pointact, pointref);\n        //    log.info(ref2);\n        double[][] v = new double[3][4];\n        double[] y3 = new double[4];\n        double[] z3 = new double[4];\n        ref2.getColumn(1, y3);\n        ref2.getColumn(2, z3);\n        for (int i = 0; i < 3; i++) {\n            y3[i] *= -1.0;\n            z3[i] *= -1.0;\n        }\n        ref2.setColumn(1, y3);\n        ref2.setColumn(2, z3);\n        temp.add(ref2);\n        temp.mul(0.5);\n        for (int i = 0; i < 3; i++) {\n            temp.getColumn(i, v[i]);\n            double r = Math.sqrt(v[i][0] * v[i][0] + v[i][1] * v[i][1] + v[i][2] * v[i][2]);\n            for (int j = 0; j < 3; j++) {\n                v[i][j] /= r;\n            }\n            temp.setColumn(i, v[i]);\n        }\n\n        // calculate pairing parameters: buckle, propeller, opening, shear, stretch, stagger\n        temp2.invert();\n        temp2.mul(ref2);\n        pairParameters = calculatetp(temp2);\n        for (int i = 0; i < 6; i++) pairParameters[i] *= -1;\n\n        // return the central frame of the base pair\n        return temp;\n\n    }\n\n\n\n    /**\n     * This method calculates pairing and step parameters from 4x4 transformation matrices\n     * that come out as Matrix4d;\n     * @param input the 4x4 matrix representing the transformation from strand II -> strand I or pair i to pair i+1\n     * @return Six parameters as double[6]\n     */\n    public static double[] calculatetp(Matrix4d input) {\n\n        double[][] A = new double[4][4];\n        for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) {\n            A[i][j] = input.getElement(i, j);\n        }\n        double[] M = new double[6];\n\n        double cosgamma, gamma, phi, omega, sgcp, omega2_minus_phi,\n                sm, cm, sp, cp, sg, cg;\n\n        cosgamma = A[2][2];\n        if (cosgamma > 1.0) cosgamma = 1.0;\n        else if (cosgamma < -1.0) cosgamma = -1.0;\n\n        gamma = acos(cosgamma);\n\n        sgcp = A[1][1]*A[0][2]-A[0][1]*A[1][2];\n\n        if (gamma == 0.0) omega = -atan2(A[0][1],A[1][1]);\n        else omega = atan2(A[2][1]*A[0][2]+sgcp*A[1][2],sgcp*A[0][2]-A[2][1]*A[1][2]);\n\n        omega2_minus_phi = atan2(A[1][2],A[0][2]);\n\n        phi = omega/2.0 - omega2_minus_phi;\n\n        M[0] = gamma*sin(phi)*180.0/PI;\n        M[1] = gamma*cos(phi)*180.0/PI;\n        M[2] = omega*180.0/PI;\n\n        sm = sin(omega/2.0-phi);\n        cm = cos(omega/2.0-phi);\n        sp = sin(phi);\n        cp = cos(phi);\n        sg = sin(gamma/2.0);\n        cg = cos(gamma/2.0);\n\n        M[3] = (cm*cg*cp-sm*sp)*A[0][3]+(sm*cg*cp+cm*sp)*A[1][3]-sg*cp*A[2][3];\n        M[4] = (-cm*cg*sp-sm*cp)*A[0][3]+(-sm*cg*sp+cm*cp)*A[1][3]+sg*sp*A[2][3];\n        M[5] = (cm*sg)*A[0][3]+(sm*sg)*A[1][3]+cg*A[2][3];\n\n        return M;\n\n    }\n\n\n    public static char complementBase(char base, boolean RNA) {\n        if (base == 'A' && RNA) return 'U';\n        if (base == 'A') return 'T';\n        if (base == 'T') return 'A';\n        if (base == 'U') return 'A';\n        if (base == 'C') return 'G';\n        if (base == 'G') return 'C';\n        return ' ';\n    }\n\n    public static String complement(String sequence, boolean RNA) {\n        String result = \"\";\n        for (int i = sequence.length() - 1; i >= 0; i--) {\n            result += complementBase(sequence.charAt(i), RNA);\n        }\n        return result;\n    }\n\n\n    public static String longestCommonSubstring(String s1, String s2) {\n        int start = 0;\n        int max = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            for (int j = 0; j < s2.length(); j++) {\n                int x = 0;\n                while (s1.charAt(i + x) == s2.charAt(j + x)) {\n                    x++;\n                    if (((i + x) >= s1.length()) || ((j + x) >= s2.length())) break;\n                }\n                if (x > max) {\n                    max = x;\n                    start = i;\n                }\n            }\n        }\n        return s1.substring(start, (start + max));\n    }\n\n}\n","originTest":"import org.biojava.nbio.structure.secstruc.BasePairParameters;\nimport org.junit.Test;\n\n/**\n * Created by luke on 7/21/17.\n */\npublic class TestBasePairParameters {\n    @Test\n    public void testBasePair() {\n        BasePairParameters bp = new BasePairParameters(\"1KX5\");\n        double[][] pairs = bp.getPairingParameters();\n        double[][] steps = bp.getStepParameters();\n        int pos = 0;\n        String sequence = bp.getPairSequence();\n        System.out.println(\"buckle propeller opening shear stretch stagger tilt roll twist shift slide rise\");\n        for (int i = 0; i < pairs.length; i++) {\n            while (sequence.charAt(pos) == ' ') pos++;\n            System.out.print(sequence.charAt(pos) + \": \");\n            for (int j = 0; j < 6; j++)\n                System.out.print(pairs[i][j] + \" \");\n            System.out.print(\"  \");\n            for (int j = 0; j < 6; j++)\n                System.out.print(steps[i][j] + \" \");\n            System.out.println();\n            pos++;\n        }\n\n    }\n\n}\n\n","changedTest":"import org.biojava.nbio.structure.secstruc.BasePairParameters;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Created by luke on 7/21/17.\n */\npublic class TestBasePairParameters {\n\n    @Test\n    public void testBasePair() {\n\n        BasePairParameters bp = new BasePairParameters(\"1KX5\");\n        double[][] pairs = bp.getPairingParameters();\n        double[][] steps = bp.getStepParameters();\n        String sequence = bp.getPairSequence();\n\n        assertEquals(sequence.trim().length(), 147);\n        // below: next 3 in degrees, all this data was from an external program, 3DNA\n        assertEquals(pairs[0][0], -3.796, 0.1);\n        assertEquals(pairs[0][1], 4.482, 0.1);\n        assertEquals(pairs[0][2], -0.730, 0.1);\n        // in Å\n        assertEquals(pairs[0][3], -0.324, 0.01);\n        assertEquals(pairs[0][4], -0.578, 0.01);\n        assertEquals(pairs[0][5], -0.336, 0.01);\n        // in degrees\n        assertEquals(steps[1][0], 2.354, 0.1);\n        assertEquals(steps[1][1], 0.785, 0.1);\n        assertEquals(steps[1][2], 32.522, 1.0);\n        // in Å\n        assertEquals(steps[1][3], -0.873, 0.01);\n        assertEquals(steps[1][4], -0.607, 0.01);\n        assertEquals(steps[1][5], 3.070, 0.01);\n\n    }\n\n}\n\n","commitMessage":"Made test use no println, and class use Logger\n","test_commitMessage":"Made test use no println, and class use Logger\n","allZero":false}