{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/io/StructureSequenceMatcher.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/io/StructureSequenceMatcherTest.java","prod_time":"2014-08-29 16:33:59","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"8e7c44f5e412b502092a49e2d59a17c34eaf5b44","test_commitID":"","isfound":"not found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created by Spencer Bliven\n *\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.ChainImpl;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava3.alignment.Alignments;\nimport org.biojava3.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava3.alignment.SimpleGapPenalty;\nimport org.biojava3.alignment.SimpleSubstitutionMatrix;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.template.CompoundSet;\n\n\n/**\n * A utility class with methods for matching ProteinSequences with\n * Structures.\n * @author Spencer Bliven\n *\n */\npublic class StructureSequenceMatcher {\n\n\t/**\n\t * Get a substructure of {@code wholeStructure} containing only the {@link Group Groups} that are included in\n\t * {@code sequence}. The resulting structure will contain only {@code ATOM} residues; the SEQ-RES will be empty.\n\t * The {@link Chain Chains} of the Structure will be new instances (cloned), but the {@link Group Groups} will not.\n\t * @param sequence The input protein sequence\n\t * @param wholeStructure The structure from which to take a substructure\n\t * @return The resulting structure\n\t * @throws StructureException\n\t * @see {@link #matchSequenceToStructure(ProteinSequence, Structure)}\n\t */\n\tpublic static Structure getSubstructureMatchingProteinSequence(ProteinSequence sequence, Structure wholeStructure) {\n\t\tResidueNumber[] rns = matchSequenceToStructure(sequence, wholeStructure);\n\t\tStructure structure = wholeStructure.clone();\n\t\tstructure.getChains().clear();\n//\t\tstructure.getHetGroups().clear();\n\t\tChain currentChain = null;\n\t\tfor (ResidueNumber rn : rns) {\n\t\t\tif (rn == null) continue;\n\t\t\tGroup group; // note that we don't clone\n\t\t\ttry {\n\t\t\t\tgroup = StructureTools.getGroupByPDBResidueNumber(wholeStructure, rn);\n\t\t\t} catch (StructureException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not find residue \" + rn + \" in structure\", e);\n\t\t\t}\n\t\t\tChain chain = new ChainImpl();\n\t\t\tchain.setChainID(group.getChainId());\n\t\t\tif (currentChain == null || !currentChain.getChainID().equals(chain.getChainID())) {\n\t\t\t\tstructure.addChain(chain);\n\t\t\t\tchain.setHeader(group.getChain().getHeader());\n\t\t\t\tchain.setParent(structure);\n\t\t\t\tchain.setSwissprotId(group.getChain().getSwissprotId());\n\t\t\t\tchain.setInternalChainID(group.getChain().getInternalChainID());\n\t\t\t\tchain.setId(group.getChain().getId());\n\t\t\t\tcurrentChain = chain;\n\t\t\t}\n\t\t\tcurrentChain.addGroup(group);\n\t\t}\n\t\treturn structure;\n\t}\n\t\n\t/**\n\t * Generates a ProteinSequence corresponding to the sequence of struct,\n\t * and maintains a mapping from the sequence back to the original groups.\n\t * \n\t * Chains are appended to one another. 'X' is used for heteroatoms.\n\t * \n\t * @param struct Input structure\n\t * @param groupIndexPosition An empty map, which will be populated with\n\t *  (residue index in returned ProteinSequence) -> (Group within struct)\n\t * @return A ProteinSequence with the full sequence of struct. Chains are\n\t *  concatenated in the same order as the input structures\n\t *  \n\t * @see {@link SeqRes2AtomAligner#getFullAtomSequence(List, Map)}, which\n\t * \tdoes the heavy lifting.\n\t * \n\t */\n\tpublic static ProteinSequence getProteinSequenceForStructure(Structure struct, Map<Integer,Group> groupIndexPosition ) {\n\n\t\tif( groupIndexPosition != null) {\n\t\t\tgroupIndexPosition.clear();\n\t\t}\n\n\t\tStringBuilder seqStr = new StringBuilder();\n\n\t\tfor(Chain chain : struct.getChains()) {\n\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\tMap<Integer,Integer> chainIndexPosition = new HashMap<Integer, Integer>();\n\t\t\tint prevLen = seqStr.length();\n\n\t\t\t// get the sequence for this chain\n\t\t\tString chainSeq = SeqRes2AtomAligner.getFullAtomSequence(groups, chainIndexPosition);\n\t\t\tseqStr.append(chainSeq);\n\n\n\t\t\t// fix up the position to include previous chains, and map the value back to a Group\n\t\t\tfor(Integer seqIndex : chainIndexPosition.keySet()) {\n\t\t\t\tInteger groupIndex = chainIndexPosition.get(seqIndex);\n\t\t\t\tgroupIndexPosition.put(prevLen + seqIndex, groups.get(groupIndex));\n\t\t\t}\n\t\t}\n\n\n\t\treturn new ProteinSequence(seqStr.toString());\t\n\t}\n\n\t/**\n\t * Given a sequence and the corresponding Structure, get the ResidueNumber\n\t * for each residue in the sequence.\n\t * \n\t * <p>Smith-Waterman alignment is used to match the sequences. Residues\n\t * in the sequence but not the structure or mismatched between sequence\n\t * and structure will have a null atom, while\n\t * residues in the structure but not the sequence are ignored with a warning.\n\t * @param seq The protein sequence. Should match the sequence of struct very\n\t * \tclosely.\n\t * @param struct The corresponding protein structure\n\t * @return A list of ResidueNumbers of the same length as seq, containing\n\t *  either the corresponding residue or null.\n\t */\n\tpublic static ResidueNumber[] matchSequenceToStructure(ProteinSequence seq, Structure struct) {\n\n\t\t//1. Create ProteinSequence for struct while remembering to which group each residue corresponds\n\t\tMap<Integer,Group> atomIndexPosition   = new HashMap<Integer, Group>();\n\n\t\tProteinSequence structSeq = getProteinSequenceForStructure(struct,atomIndexPosition);\n\n\t\t// TODO This should really be semi-global alignment, though global for either sequence OR structure (we don't know which)\n\t\t//2. Run Smith-Waterman to get the alignment\n\t\t// Identity substitution matrix with +1 for match, -1 for mismatch\n\t\t// TODO\n\t\tSubstitutionMatrix<AminoAcidCompound> matrix = \n\t\t\tnew SimpleSubstitutionMatrix<AminoAcidCompound>(\n\t\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\t\t(short)1, (short)-1 );\n\t\tmatrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\tnew InputStreamReader(\n\t\t\t\t\t\tSimpleSubstitutionMatrix.class.getResourceAsStream(\"/blosum100.txt\")),\n\t\t\"blosum100\");\n\t\tSequencePair<ProteinSequence, AminoAcidCompound> pair = \n\t\t\tAlignments.getPairwiseAlignment(seq, structSeq,\n\t\t\t\t\tPairwiseSequenceAlignerType.GLOBAL, new SimpleGapPenalty(), matrix);\n\n\t\t//System.out.print(pair.toString());\n\n\t\t//3. Convert the alignment back to Atoms\n\t\tAlignedSequence<ProteinSequence,AminoAcidCompound> alignedSeq = pair.getQuery();\n\t\tAlignedSequence<ProteinSequence,AminoAcidCompound> alignedStruct = pair.getTarget();\n\n\n\t\tassert(alignedSeq.getLength() == alignedStruct.getLength());\n\t\t\n//\t\tSystem.out.println(pair.toString(80));\n//\t\tSystem.out.format(\"%d/min{%d,%d}\\n\", pair.getNumIdenticals(),\n//\t\t\t\talignedSeq.getLength()-alignedSeq.getNumGaps(),\n//\t\t\t\talignedStruct.getLength()-alignedStruct.getNumGaps());\n\n\t\tResidueNumber[] ca = new ResidueNumber[seq.getLength()];\n\n\t\tfor( int pos = alignedSeq.getStart().getPosition(); pos <= alignedSeq.getEnd().getPosition(); pos++ ) { // 1-indexed\n\t\t\t//skip missing residues from sequence. These probably represent alignment errors\n\t\t\tif(alignedSeq.isGap(pos)) {\n\t\t\t\tint structIndex = alignedStruct.getSequenceIndexAt(pos)-1;\n\t\t\t\tassert(structIndex > 0);//should be defined since seq gap\n\n\t\t\t\tGroup g = atomIndexPosition.get(structIndex);\n\n\t\t\t\tSystem.err.format(\"Warning: chain %s residue %s in the Structure %s has no corresponding amino acid in the sequence.\\n\",\n\t\t\t\t\t\tg.getChainId(),\n\t\t\t\t\t\tg.getResidueNumber().toString(),\n\t\t\t\t\t\tg.getChain().getParent().getPDBCode());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(! alignedStruct.isGap(pos) ) {\n\t\t\t\tint seqIndex = alignedSeq.getSequenceIndexAt(pos)-1;//1-indexed\n\t\t\t\tint structIndex = alignedStruct.getSequenceIndexAt(pos)-1;//1-indexed\n\t\t\t\tGroup g = atomIndexPosition.get(structIndex);\n\t\t\t\t\n\t\t\t\tassert(0<=seqIndex && seqIndex < ca.length);\n\t\t\t\t\n\t\t\t\tca[seqIndex] = g.getResidueNumber(); //remains null for gaps\n\t\t\t}\n\t\t}\n\t\treturn ca;\n\t}\n\t\n\t\n\t/**\n\t * Removes all gaps ('-') from a protein sequence\n\t * @param gapped\n\t * @return\n\t */\n\tpublic static ProteinSequence removeGaps(ProteinSequence gapped) {\n\t\tfinal String[] gapStrings = {\"-\",\".\"};\n\t\t\n\t\tStringBuilder seq = new StringBuilder();\n\t\t\n\t\tCompoundSet<AminoAcidCompound> aaSet = gapped.getCompoundSet();\n\t\tAminoAcidCompound[] gaps = new AminoAcidCompound[gapStrings.length];\n\t\t\n\t\tfor(int i=0;i<gapStrings.length;i++) {\n\t\t\tgaps[i] = aaSet.getCompoundForString(gapStrings[i]);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=gapped.getLength();i++) { //1-indexed\n\t\t\tAminoAcidCompound aa = gapped.getCompoundAt(i);\n\t\t\tboolean isGap = false;\n\t\t\tfor(AminoAcidCompound gap : gaps) {\n\t\t\t\tif( aa.equals(gap)) {\n\t\t\t\t\tisGap = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isGap) {\n\t\t\t\tseq.append(aa.getShortName());\n\t\t\t}\n\t\t}\n\t\t\n\t\tProteinSequence ungapped = new ProteinSequence(seq.toString());\n\t\t\n\t\treturn ungapped;\n\t}\n\t\n\t/**\n\t * Creates a new list consisting of all columns of gapped where no row \n\t * contained a null value.\n\t * \n\t * Here, \"row\" refers to the first index and \"column\" to the second, eg\n\t * gapped.get(row).get(column)\n\t * @param gapped A rectangular matrix containing null to mark gaps\n\t * @return A new List without columns containing nulls\n\t */\n\tpublic static <T> T[][] removeGaps(final T[][] gapped) {\n\t\tif(gapped == null ) return null;\n\t\tif(gapped.length < 1) return Arrays.copyOf(gapped, gapped.length);\n\t\t\n\t\tfinal int nProts = gapped.length;\n\t\tfinal int protLen = gapped[0].length; // length of gapped proteins\n\t\t\n\t\t// Verify that input is rectangular\n\t\tfor(int i=0;i<nProts;i++) {\n\t\t\tif(gapped[i].length != protLen) {\n\t\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\t\"Expected a rectangular array, but row 0 has %d elements \" +\n\t\t\t\t\t\t\"while row %d has %d.\", protLen,i,gapped[i].length));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// determine where gaps exist in any structures\n\t\tboolean[] isGap = new boolean[protLen];\n\t\tint gaps = 0;\n\t\tfor(int j=0;j<protLen;j++) {\n\t\t\tfor(int i=0;i<nProts;i++) {\n\t\t\t\tif(gapped[i][j] == null ) {\n\t\t\t\t\tisGap[j] = true;\n\t\t\t\t\tgaps++;\n\t\t\t\t\tbreak; //go to next position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Create ungapped array\n\t\tT[][] ungapped = Arrays.copyOf(gapped,nProts);\n\t\tfinal int ungappedLen = protLen-gaps;\n\t\tfor(int i=0;i<nProts;i++) {\n\t\t\tungapped[i] = Arrays.copyOf(gapped[i],ungappedLen);\n\t\t\tint k = 0;\n\t\t\tfor(int j=0;j<protLen;j++) {\n\t\t\t\tif(!isGap[j]) { //skip gaps\n\t\t\t\t\tassert(gapped[i][j] != null);\n\t\t\t\t\tungapped[i][k] = gapped[i][j];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(k == ungappedLen);\n\t\t}\n\t\t\n\t\treturn ungapped;\n\t}\n}\n","changedPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created by Spencer Bliven\n *\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.ChainImpl;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava3.alignment.Alignments;\nimport org.biojava3.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava3.alignment.SimpleGapPenalty;\nimport org.biojava3.alignment.SimpleSubstitutionMatrix;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * A utility class with methods for matching ProteinSequences with\n * Structures.\n * @author Spencer Bliven\n *\n */\npublic class StructureSequenceMatcher {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureSequenceMatcher.class);\n\n\t/**\n\t * Get a substructure of {@code wholeStructure} containing only the {@link Group Groups} that are included in\n\t * {@code sequence}. The resulting structure will contain only {@code ATOM} residues; the SEQ-RES will be empty.\n\t * The {@link Chain Chains} of the Structure will be new instances (cloned), but the {@link Group Groups} will not.\n\t * @param sequence The input protein sequence\n\t * @param wholeStructure The structure from which to take a substructure\n\t * @return The resulting structure\n\t * @throws StructureException\n\t * @see {@link #matchSequenceToStructure(ProteinSequence, Structure)}\n\t */\n\tpublic static Structure getSubstructureMatchingProteinSequence(ProteinSequence sequence, Structure wholeStructure) {\n\t\tResidueNumber[] rns = matchSequenceToStructure(sequence, wholeStructure);\n\t\tStructure structure = wholeStructure.clone();\n\t\tstructure.getChains().clear();\n//\t\tstructure.getHetGroups().clear();\n\t\tChain currentChain = null;\n\t\tfor (ResidueNumber rn : rns) {\n\t\t\tif (rn == null) continue;\n\t\t\tGroup group; // note that we don't clone\n\t\t\ttry {\n\t\t\t\tgroup = StructureTools.getGroupByPDBResidueNumber(wholeStructure, rn);\n\t\t\t} catch (StructureException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Could not find residue \" + rn + \" in structure\", e);\n\t\t\t}\n\t\t\tChain chain = new ChainImpl();\n\t\t\tchain.setChainID(group.getChainId());\n\t\t\tif (currentChain == null || !currentChain.getChainID().equals(chain.getChainID())) {\n\t\t\t\tstructure.addChain(chain);\n\t\t\t\tchain.setHeader(group.getChain().getHeader());\n\t\t\t\tchain.setParent(structure);\n\t\t\t\tchain.setSwissprotId(group.getChain().getSwissprotId());\n\t\t\t\tchain.setInternalChainID(group.getChain().getInternalChainID());\n\t\t\t\tchain.setId(group.getChain().getId());\n\t\t\t\tcurrentChain = chain;\n\t\t\t}\n\t\t\tcurrentChain.addGroup(group);\n\t\t}\n\t\treturn structure;\n\t}\n\t\n\t/**\n\t * Generates a ProteinSequence corresponding to the sequence of struct,\n\t * and maintains a mapping from the sequence back to the original groups.\n\t * \n\t * Chains are appended to one another. 'X' is used for heteroatoms.\n\t * \n\t * @param struct Input structure\n\t * @param groupIndexPosition An empty map, which will be populated with\n\t *  (residue index in returned ProteinSequence) -> (Group within struct)\n\t * @return A ProteinSequence with the full sequence of struct. Chains are\n\t *  concatenated in the same order as the input structures\n\t *  \n\t * @see {@link SeqRes2AtomAligner#getFullAtomSequence(List, Map)}, which\n\t * \tdoes the heavy lifting.\n\t * \n\t */\n\tpublic static ProteinSequence getProteinSequenceForStructure(Structure struct, Map<Integer,Group> groupIndexPosition ) {\n\n\t\tif( groupIndexPosition != null) {\n\t\t\tgroupIndexPosition.clear();\n\t\t}\n\n\t\tStringBuilder seqStr = new StringBuilder();\n\n\t\tfor(Chain chain : struct.getChains()) {\n\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\tMap<Integer,Integer> chainIndexPosition = new HashMap<Integer, Integer>();\n\t\t\tint prevLen = seqStr.length();\n\n\t\t\t// get the sequence for this chain\n\t\t\tString chainSeq = SeqRes2AtomAligner.getFullAtomSequence(groups, chainIndexPosition);\n\t\t\tseqStr.append(chainSeq);\n\n\n\t\t\t// fix up the position to include previous chains, and map the value back to a Group\n\t\t\tfor(Integer seqIndex : chainIndexPosition.keySet()) {\n\t\t\t\tInteger groupIndex = chainIndexPosition.get(seqIndex);\n\t\t\t\tgroupIndexPosition.put(prevLen + seqIndex, groups.get(groupIndex));\n\t\t\t}\n\t\t}\n\n\n\t\treturn new ProteinSequence(seqStr.toString());\t\n\t}\n\n\t/**\n\t * Given a sequence and the corresponding Structure, get the ResidueNumber\n\t * for each residue in the sequence.\n\t * \n\t * <p>Smith-Waterman alignment is used to match the sequences. Residues\n\t * in the sequence but not the structure or mismatched between sequence\n\t * and structure will have a null atom, while\n\t * residues in the structure but not the sequence are ignored with a warning.\n\t * @param seq The protein sequence. Should match the sequence of struct very\n\t * \tclosely.\n\t * @param struct The corresponding protein structure\n\t * @return A list of ResidueNumbers of the same length as seq, containing\n\t *  either the corresponding residue or null.\n\t */\n\tpublic static ResidueNumber[] matchSequenceToStructure(ProteinSequence seq, Structure struct) {\n\n\t\t//1. Create ProteinSequence for struct while remembering to which group each residue corresponds\n\t\tMap<Integer,Group> atomIndexPosition   = new HashMap<Integer, Group>();\n\n\t\tProteinSequence structSeq = getProteinSequenceForStructure(struct,atomIndexPosition);\n\n\t\t// TODO This should really be semi-global alignment, though global for either sequence OR structure (we don't know which)\n\t\t//2. Run Smith-Waterman to get the alignment\n\t\t// Identity substitution matrix with +1 for match, -1 for mismatch\n\t\t// TODO\n\t\tSubstitutionMatrix<AminoAcidCompound> matrix = \n\t\t\tnew SimpleSubstitutionMatrix<AminoAcidCompound>(\n\t\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\t\t(short)1, (short)-1 );\n\t\tmatrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\tnew InputStreamReader(\n\t\t\t\t\t\tSimpleSubstitutionMatrix.class.getResourceAsStream(\"/blosum100.txt\")),\n\t\t\"blosum100\");\n\t\tSequencePair<ProteinSequence, AminoAcidCompound> pair = \n\t\t\tAlignments.getPairwiseAlignment(seq, structSeq,\n\t\t\t\t\tPairwiseSequenceAlignerType.GLOBAL, new SimpleGapPenalty(), matrix);\n\n\t\t//System.out.print(pair.toString());\n\n\t\t//3. Convert the alignment back to Atoms\n\t\tAlignedSequence<ProteinSequence,AminoAcidCompound> alignedSeq = pair.getQuery();\n\t\tAlignedSequence<ProteinSequence,AminoAcidCompound> alignedStruct = pair.getTarget();\n\n\n\t\tassert(alignedSeq.getLength() == alignedStruct.getLength());\n\t\t\n//\t\tSystem.out.println(pair.toString(80));\n//\t\tSystem.out.format(\"%d/min{%d,%d}\\n\", pair.getNumIdenticals(),\n//\t\t\t\talignedSeq.getLength()-alignedSeq.getNumGaps(),\n//\t\t\t\talignedStruct.getLength()-alignedStruct.getNumGaps());\n\n\t\tResidueNumber[] ca = new ResidueNumber[seq.getLength()];\n\n\t\tfor( int pos = alignedSeq.getStart().getPosition(); pos <= alignedSeq.getEnd().getPosition(); pos++ ) { // 1-indexed\n\t\t\t//skip missing residues from sequence. These probably represent alignment errors\n\t\t\tif(alignedSeq.isGap(pos)) {\n\t\t\t\tint structIndex = alignedStruct.getSequenceIndexAt(pos)-1;\n\t\t\t\tassert(structIndex > 0);//should be defined since seq gap\n\n\t\t\t\tGroup g = atomIndexPosition.get(structIndex);\n\n\t\t\t\tlogger.warn(String.format(\"Warning: chain %s residue %s in the Structure %s has no corresponding amino acid in the sequence.\",\n\t\t\t\t\t\tg.getChainId(),\n\t\t\t\t\t\tg.getResidueNumber().toString(),\n\t\t\t\t\t\tg.getChain().getParent().getPDBCode()) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(! alignedStruct.isGap(pos) ) {\n\t\t\t\tint seqIndex = alignedSeq.getSequenceIndexAt(pos)-1;//1-indexed\n\t\t\t\tint structIndex = alignedStruct.getSequenceIndexAt(pos)-1;//1-indexed\n\t\t\t\tGroup g = atomIndexPosition.get(structIndex);\n\t\t\t\t\n\t\t\t\tassert(0<=seqIndex && seqIndex < ca.length);\n\t\t\t\t\n\t\t\t\tca[seqIndex] = g.getResidueNumber(); //remains null for gaps\n\t\t\t}\n\t\t}\n\t\treturn ca;\n\t}\n\t\n\t\n\t/**\n\t * Removes all gaps ('-') from a protein sequence\n\t * @param gapped\n\t * @return\n\t */\n\tpublic static ProteinSequence removeGaps(ProteinSequence gapped) {\n\t\tfinal String[] gapStrings = {\"-\",\".\"};\n\t\t\n\t\tStringBuilder seq = new StringBuilder();\n\t\t\n\t\tCompoundSet<AminoAcidCompound> aaSet = gapped.getCompoundSet();\n\t\tAminoAcidCompound[] gaps = new AminoAcidCompound[gapStrings.length];\n\t\t\n\t\tfor(int i=0;i<gapStrings.length;i++) {\n\t\t\tgaps[i] = aaSet.getCompoundForString(gapStrings[i]);\n\t\t}\n\t\t\n\t\tfor(int i=1; i<=gapped.getLength();i++) { //1-indexed\n\t\t\tAminoAcidCompound aa = gapped.getCompoundAt(i);\n\t\t\tboolean isGap = false;\n\t\t\tfor(AminoAcidCompound gap : gaps) {\n\t\t\t\tif( aa.equals(gap)) {\n\t\t\t\t\tisGap = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isGap) {\n\t\t\t\tseq.append(aa.getShortName());\n\t\t\t}\n\t\t}\n\t\t\n\t\tProteinSequence ungapped = new ProteinSequence(seq.toString());\n\t\t\n\t\treturn ungapped;\n\t}\n\t\n\t/**\n\t * Creates a new list consisting of all columns of gapped where no row \n\t * contained a null value.\n\t * \n\t * Here, \"row\" refers to the first index and \"column\" to the second, eg\n\t * gapped.get(row).get(column)\n\t * @param gapped A rectangular matrix containing null to mark gaps\n\t * @return A new List without columns containing nulls\n\t */\n\tpublic static <T> T[][] removeGaps(final T[][] gapped) {\n\t\tif(gapped == null ) return null;\n\t\tif(gapped.length < 1) return Arrays.copyOf(gapped, gapped.length);\n\t\t\n\t\tfinal int nProts = gapped.length;\n\t\tfinal int protLen = gapped[0].length; // length of gapped proteins\n\t\t\n\t\t// Verify that input is rectangular\n\t\tfor(int i=0;i<nProts;i++) {\n\t\t\tif(gapped[i].length != protLen) {\n\t\t\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\t\t\"Expected a rectangular array, but row 0 has %d elements \" +\n\t\t\t\t\t\t\"while row %d has %d.\", protLen,i,gapped[i].length));\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// determine where gaps exist in any structures\n\t\tboolean[] isGap = new boolean[protLen];\n\t\tint gaps = 0;\n\t\tfor(int j=0;j<protLen;j++) {\n\t\t\tfor(int i=0;i<nProts;i++) {\n\t\t\t\tif(gapped[i][j] == null ) {\n\t\t\t\t\tisGap[j] = true;\n\t\t\t\t\tgaps++;\n\t\t\t\t\tbreak; //go to next position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Create ungapped array\n\t\tT[][] ungapped = Arrays.copyOf(gapped,nProts);\n\t\tfinal int ungappedLen = protLen-gaps;\n\t\tfor(int i=0;i<nProts;i++) {\n\t\t\tungapped[i] = Arrays.copyOf(gapped[i],ungappedLen);\n\t\t\tint k = 0;\n\t\t\tfor(int j=0;j<protLen;j++) {\n\t\t\t\tif(!isGap[j]) { //skip gaps\n\t\t\t\t\tassert(gapped[i][j] != null);\n\t\t\t\t\tungapped[i][k] = gapped[i][j];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(k == ungappedLen);\n\t\t}\n\t\t\n\t\treturn ungapped;\n\t}\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created by Spencer Bliven\n *\n */\npackage org.biojava.bio.structure.io;\n\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.AminoAcid;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.UnknownPdbAminoAcidException;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.junit.Test;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class StructureSequenceMatcherTest extends TestCase {\n\n\tprivate Structure struct1;\n\tprivate String[] pdbNum1;\n\tprivate String seq1;\n\t\n\tpublic void setUp() throws IOException, StructureException {\n\t\tString name1 = \"2PTC\";\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tstruct1 = cache.getStructure(name1);\n\t\tpdbNum1 = new String[] {\n\t\t\t\t\"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\",\n\t\t\t\t\"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"37\",\n\t\t\t\t\"38\", \"39\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\",\n\t\t\t\t\"48\", \"49\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\",\n\t\t\t\t\"58\", \"59\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\",\n\t\t\t\t\"69\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\",\n\t\t\t\t\"79\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\",\n\t\t\t\t\"89\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\",\n\t\t\t\t\"99\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\",\n\t\t\t\t\"108\", \"109\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\",\n\t\t\t\t\"117\", \"118\", \"119\", \"120\", \"121\", \"122\", \"123\", \"124\", \"125\",\n\t\t\t\t\"127\", \"128\", \"129\", \"130\", \"132\", \"133\", \"134\", \"135\", \"136\",\n\t\t\t\t\"137\", \"138\", \"139\", \"140\", \"141\", \"142\", \"143\", \"144\", \"145\",\n\t\t\t\t\"146\", \"147\", \"148\", \"149\", \"150\", \"151\", \"152\", \"153\", \"154\",\n\t\t\t\t\"155\", \"156\", \"157\", \"158\", \"159\", \"160\", \"161\", \"162\", \"163\",\n\t\t\t\t\"164\", \"165\", \"166\", \"167\", \"168\", \"169\", \"170\", \"171\", \"172\",\n\t\t\t\t\"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\", \"180\", \"181\",\n\t\t\t\t\"182\", \"183\", \"184A\", \"184\", \"185\", \"186\", \"187\", \"188A\", \"188\",\n\t\t\t\t\"189\", \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\",\n\t\t\t\t\"198\", \"199\", \"200\", \"201\", \"202\", \"203\", \"204\", \"209\", \"210\",\n\t\t\t\t\"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"219\", \"220\",\n\t\t\t\t\"221A\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\",\n\t\t\t\t\"229\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\",\n\t\t\t\t\"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"244\", \"245\",\n\t\t\t\t\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\",\n\t\t\t\t\"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\",\n\t\t\t\t\"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n\t\t\t\t\"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"40\", \"41\", \"42\",\n\t\t\t\t\"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"50\", \"51\", \"52\",\n\t\t\t\t\"53\", \"54\", \"55\", \"56\", \"57\", \"58\"\n\t\t};\n\t\tseq1 =\n\t\t\t\t//>2PTC:E|PDBID|CHAIN|SEQUENCE\n\t\t\t\t\"IVGGYTCGANTVPYQVSLNSGYHFCGGSLINSQWVVSAAHCYKSGIQVRLGEDNINVVEGNEQFISASKSIVHPSYNSNT\"+\n\t\t\t\t\"LNNDIMLIKLKSAASLNSRVASISLPTSCASAGTQCLISGWGNTKSSGTSYPDVLKCLKAPILSDSSCKSAYPGQITSNM\"+\n\t\t\t\t\"FCAGYLEGGKDSCQGDSGGPVVCSGKLQGIVSWGSGCAQKNKPGVYTKVCNYVSWIKQTIASN\"+\n\t\t\t\t//>2PTC:I|PDBID|CHAIN|SEQUENCE\n\t\t\t\t\"RPDFCLEPPYTGPCKARIIRYFYNAKAGLCQTFVYGGCRAKRNNFKSAEDCMRTCGGA\";\n\t\t\n\t\tassertTrue(seq1.length() == pdbNum1.length);\n\t\t\n\t\t/*// report some stats\n\t\tSystem.out.println(\"The SEQRES and ATOM information is available via the chains:\");\n\t\tint modelnr = 0 ; // also is 0 if structure is an XRAY structure.\n\t\tList<Chain> chains = struct1.getChains(modelnr);\n\t\tfor (Chain cha:chains){\n\t\t\tList<Group> agr = cha.getAtomGroups(\"amino\");\n\t\t\tList<Group> hgr = cha.getAtomGroups(\"hetatm\");\n\t\t\tList<Group> ngr = cha.getAtomGroups(\"nucleotide\");\n\n\t\t\tSystem.out.print(\"chain: >\"+cha.getChainID()+\"<\");\n\t\t\tSystem.out.print(\" length SEQRES: \" +cha.getSeqResLength());\n\t\t\tSystem.out.print(\" length ATOM: \" +cha.getAtomLength());\n\t\t\tSystem.out.print(\" aminos: \" +agr.size());\n\t\t\tSystem.out.print(\" hetatms: \"+hgr.size());\n\t\t\tSystem.out.println(\" nucleotides: \"+ngr.size());  \n\t\t}\n\t\tSystem.out.println(prot.toString());\n\t\t*/\n\t}\n\n\t@Test\n\tpublic void testSubstructureMatchingProteinSequence() throws UnknownPdbAminoAcidException {\n\t\tProteinSequence seq = new ProteinSequence(seq1.substring(30, 40));\n\t\tStructure result = StructureSequenceMatcher.getSubstructureMatchingProteinSequence(seq, struct1);\n\t\tassertEquals(\"Wrong number of groups\", 10, StructureTools.getNrGroups(result));\n\t\tassertEquals(\"Wrong number of chains\", 1, result.getChains().size());\n\t\tint i = 0;\n\t\tfor (Group group : result.getChain(0).getAtomGroups()) {\n\t\t\tassertTrue(\"Contains non-amino acid group\", group instanceof AminoAcid);\n\t\t\tAminoAcid aa = (AminoAcid) group;\n\t\t\tchar c = StructureTools.convert_3code_1code(aa.getPDBName());\n\t\t\tassertEquals(\"Wrong amino acid\", seq.getSequenceAsString().charAt(i), c);\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testGetProteinSequenceForStructure() throws UnknownPdbAminoAcidException {\n\t\tMap<Integer,Group> groupIndexPos = new HashMap<Integer,Group>();\n\t\tProteinSequence prot = StructureSequenceMatcher.getProteinSequenceForStructure(struct1, groupIndexPos);\n\n\t\t\n\t\t// Test returned sequence\n\t\tassertEquals(\"Unreported residues\", seq1.length(), prot.getLength() );\n\t\tassertEquals(\"Modified residues\",seq1, prot.toString());\n\n\t\t// Test mapping\n\t\tassertEquals(\"Missing residues in mapping\",seq1.length(),groupIndexPos.size());\n\t\t\n\t\tfor(int res=0;res<seq1.length();res++) {\n\t\t\tassertTrue(\"no mapping for group \"+res,groupIndexPos.containsKey(res));\n\t\t\tGroup g = groupIndexPos.get(res);\n\t\t\t\n\t\t\tResidueNumber resnum = g.getResidueNumber();\n\t\t\tCharacter aa = StructureTools.convert_3code_1code(g.getPDBName());\n\t\t\tassertEquals(\"Wrong PDB number at pos \"+res,pdbNum1[res],resnum.toString());\n\t\t\tassertEquals(\"Wrong Amino acid at pos \"+res,\n\t\t\t\t\tCharacter.valueOf(seq1.charAt(res)),aa);\n\t\t\t//System.out.format(\"%4d %.5s %s\\n\", res,resnum.toString(),aa.toString());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMatchSequenceToStructure() throws UnknownPdbAminoAcidException, StructureException {\n\t\t// create modified sequence by removing 10 residues and adding 3\n\t\tString sequenceStr = //>2PTC:E|PDBID|CHAIN|SEQUENCE\n\t\t\t\"IVGGYTCGAN\" +\n\t\t\t\"XXX\"+ //added\n\t\t\t\"TVPYQVSLNS\" +\n\t\t\t//\"GYHFCGGSLI\" +\n\t\t\t\"NSQWVVSAAH\" +\n\t\t\t\"-CYKSGIQVRLGEDNINVVEGNEQFISASKSIVHPSYNSNT\"+\n\t\t\t\"LNNDIMLIKLKSAASLNSRVASISLPTSCASAGTQCLISGWGNTKSSGTSYPDVLKCLKAPILSDSSCKSAYPGQITSNM\"+\n\t\t\t\"FCAGYLEGGKDSCQGDSGGPVVCSGKLQGIVSWGSGCAQKNKPGVYTKVCNYVSWIKQTIASN\";\n\t\tString[] correctResidues = new String[] {\n\t\t\t\t\"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\",\n\t\t\t\tnull, null, null,\n\t\t\t\t\"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\", \"33\", \"34\", \"37\",\n\t\t\t\t//\"38\", \"39\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\",\n\t\t\t\t\"48\", \"49\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\",\n\t\t\t\tnull,\"58\", \"59\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\",\n\t\t\t\t\"69\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\",\n\t\t\t\t\"79\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\",\n\t\t\t\t\"89\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\",\n\t\t\t\t\n\t\t\t\t\"99\", \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\",\n\t\t\t\t\"108\", \"109\", \"110\", \"111\", \"112\", \"113\", \"114\", \"115\", \"116\",\n\t\t\t\t\"117\", \"118\", \"119\", \"120\", \"121\", \"122\", \"123\", \"124\", \"125\",\n\t\t\t\t\"127\", \"128\", \"129\", \"130\", \"132\", \"133\", \"134\", \"135\", \"136\",\n\t\t\t\t\"137\", \"138\", \"139\", \"140\", \"141\", \"142\", \"143\", \"144\", \"145\",\n\t\t\t\t\"146\", \"147\", \"148\", \"149\", \"150\", \"151\", \"152\", \"153\", \"154\",\n\t\t\t\t\"155\", \"156\", \"157\", \"158\", \"159\", \"160\", \"161\", \"162\", \"163\",\n\t\t\t\t\"164\", \"165\", \"166\", \"167\", \"168\", \"169\", \"170\", \"171\", \"172\",\n\t\t\t\t\"173\", \"174\", \"175\", \"176\", \"177\", \"178\", \"179\", \"180\", \"181\",\n\t\t\t\t\"182\", \"183\", \"184A\", \"184\", \"185\", \"186\", \"187\", \"188A\", \"188\",\n\t\t\t\t\"189\", \"190\", \"191\", \"192\", \"193\", \"194\", \"195\", \"196\", \"197\",\n\t\t\t\t\"198\", \"199\", \"200\", \"201\", \"202\", \"203\", \"204\", \"209\", \"210\",\n\t\t\t\t\"211\", \"212\", \"213\", \"214\", \"215\", \"216\", \"217\", \"219\", \"220\",\n\t\t\t\t\"221A\", \"221\", \"222\", \"223\", \"224\", \"225\", \"226\", \"227\", \"228\",\n\t\t\t\t\"229\", \"230\", \"231\", \"232\", \"233\", \"234\", \"235\", \"236\", \"237\",\n\t\t\t\t\"238\", \"239\", \"240\", \"241\", \"242\", \"243\", \"244\", \"245\"\n\t\t};\n\t\t\n\t\tSystem.err.println(\"Note: the following 10 warnings about missing residues are expected.\");\n\t\tProteinSequence seq = new ProteinSequence(sequenceStr);\n\t\tResidueNumber[] match = StructureSequenceMatcher.matchSequenceToStructure(seq, struct1);\n\t\t\n\t\tassertEquals(\"Wrong length!\",sequenceStr.length(),match.length);\n\t\tfor(int i=0;i<sequenceStr.length();i++) {\n\t\t\tResidueNumber res = match[i];\n\t\t\tif( res == null) {\n\t\t\t\tif(!(sequenceStr.charAt(i) == '-' || sequenceStr.charAt(i) == 'X' )) {\n\t\t\t\t\tfail(\"Incorrectly marked as missing residue at pos \"+i+\" aa \"+sequenceStr.charAt(i));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tGroup g = struct1.findGroup(res.getChainId(), res.toString());\n\t\t\t\tassertNotNull(g);\n\t\t\t\tString aa3 = g.getPDBName();\n\t\t\t\tassertNotNull(aa3);\n\t\t\t\tCharacter aa = StructureTools.convert_3code_1code(aa3);\n\t\t\t\tassertEquals(\"Wrong PDB number at position \"+i,\n\t\t\t\t\t\tcorrectResidues[i] ,g.getResidueNumber().toString());\n\t\t\t\tassertEquals(\"Wrong amino acid at position \"+i,\n\t\t\t\t\t\tCharacter.valueOf(sequenceStr.charAt(i)),aa);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testRemoveGaps1() {\n\t\tString ungapped = \"ACDEFGHIKLMNPQRSTVWY\";\n\t\tString gapped = \"--ACDE-F-GHI..KLM-NPQRSTVWY--\";\n\t\t\n\t\tProteinSequence gappedProt = new ProteinSequence(gapped);\n\t\tProteinSequence ungappedProt = StructureSequenceMatcher.removeGaps(gappedProt);\n\t\t\n\t\tassertEquals(ungapped,ungappedProt.getSequenceAsString());\n\t}\n\n}\n","changedTest":"","commitMessage":"Important fix for #155, was not specifying runtime scope correctly","test_commitMessage":"","allZero":false}