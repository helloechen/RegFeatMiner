{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/FastaReader.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/FastaReaderTest.java","prod_time":"2015-06-18 06:26:33","test_time":"2015-06-18 06:26:33","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":5,"add_classname_line":0,"add_condition_line":5,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"90af46f19789af86d997eb3b89606c3379644323","test_commitID":"90af46f19789af86d997eb3b89606c3379644323","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\n\n/**\n * Use FastaReaderHelper as an example of how to use this class where FastaReaderHelper should be the\n * primary class used to read Fasta files\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n */\npublic class FastaReader<S extends Sequence<?>, C extends Compound> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReader.class);\n\n    SequenceCreatorInterface<C> sequenceCreator;\n    SequenceHeaderParserInterface<S,C> headerParser;\n    BufferedReaderBytesRead br;\n    InputStreamReader isr;\n    FileInputStream fi = null;\n    long fileIndex = 0;\n    long sequenceIndex = 0;\n    String line = \"\";\n    String header= \"\";\n    \n    /**\n     * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\n     * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\n     * an inputstream is forced to read all the data so you don't gain anything.\n     * @param br\n     * @param headerParser\n     * @param sequenceCreator\n     */\n    public FastaReader(InputStream is, SequenceHeaderParserInterface<S,C> headerParser,\n    \t\tSequenceCreatorInterface<C> sequenceCreator) {\n        this.headerParser = headerParser;\n        isr = new InputStreamReader(is);\n        this.br = new BufferedReaderBytesRead(isr);\n        this.sequenceCreator = sequenceCreator;\n    }\n\n    /**\n     * If you are going to use the FileProxyProteinSequenceCreator then you\n     * need to use this constructor because we need details about\n     * the location of the file.\n     * @param file\n     * @param headerParser\n     * @param sequenceCreator\n     * @throws FileNotFoundException if the file does not exist, is a directory \n     * \trather than a regular file, or for some other reason cannot be opened\n     * \tfor reading.\n     * @throws SecurityException if a security manager exists and its checkRead\n     * \tmethod denies read access to the file.\n     */\n    public FastaReader(File file, SequenceHeaderParserInterface<S,C> headerParser,\n    \t\tSequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\n        this.headerParser = headerParser;\n        fi = new FileInputStream(file);\n        isr = new InputStreamReader(fi);\n        this.br = new BufferedReaderBytesRead(isr);\n        this.sequenceCreator = sequenceCreator;\n    }\n\n    /**\n     * The parsing is done in this method.<br>\n     * This method tries to process all the available fasta records \n     * in the File or InputStream, closes the underlying resource, \n     * and return the results in {@link LinkedHashMap}.<br>\n     * You don't need to call {@link #close()} after calling this method.\n     * @see #process(int)\n     * @return {@link HashMap} containing all the parsed fasta records \n     * present, starting current fileIndex onwards.\n     * @throws IOException if an error occurs reading the input file\n     */\n    public LinkedHashMap<String,S> process() throws IOException {\n    \tLinkedHashMap<String,S> sequences = process(-1);\n    \tclose();\n    \treturn sequences;\n    }\n\n    /**\n     * This method tries to parse maximum <code>max</code> records from\n     * the open File or InputStream, and leaves the underlying resource open.<br>\n     * Subsequent calls to the same method continue parsing the rest of the file.<br>\n     * This is particularly useful when dealing with very big data files,\n     * (e.g. NCBI nr database), which can't fit into memory and will take long\n     * time before the first result is available.<br>\n     * <b>N.B.</b>\n     * <ul>\n     * <li>This method can't be called after calling its NO-ARGUMENT twin.</li> \n     * <li>remember to close the underlying resource when you are done.</li> \n     * </ul>\n     * @see #process()\n     * @author Amr AL-Hossary\n     * @since 3.0.6\n     * @param max maximum number of records to return, <code>-1</code> for infinity.\n     * @return {@link HashMap} containing maximum <code>max</code> parsed fasta records \n     * present, starting current fileIndex onwards.\n     * @throws IOException if an error occurs reading the input file\n     */\n\tpublic LinkedHashMap<String,S> process(int max) throws IOException {\n        LinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\n\n        String line = \"\";\n        if(this.line != null && this.line.length() > 0){\n        \tline=this.line;\n        }\n        String header = \"\";\n        if(this.header != null && this.header.length() > 0){\n        \theader=this.header;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        int processedSequences=0;\n        boolean keepGoing = true;\n\n        do {\n            line = line.trim(); // nice to have but probably not needed\n            if (line.length() != 0) {\n                if (line.startsWith(\">\")) {//start of new fasta record\n                    if (sb.length() > 0) {//i.e. if there is already a sequence before\n                    //    logger.debug(\"Sequence index=\" + sequenceIndex);\n                    \t\n                    \ttry {    \n                    \t    @SuppressWarnings(\"unchecked\")\n                    \t\tS sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                            headerParser.parseHeader(header, sequence);\n                            sequences.put(sequence.getAccession().getID(),sequence);\n                            processedSequences++;\n\n                    \t} catch (CompoundNotFoundException e) {\n                    \t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", \n                    \t\t\t\theader, e.getMessage());\n                    \t}\n//                        if (maxSequenceLength < sb.length()) {\n//                            maxSequenceLength = sb.length();\n//                        }\n//                        sb = new StringBuilder(maxSequenceLength);\n                        sb.setLength(0); //this is faster, better memory utilization (same buffer)\n                    }\n                    header = line.substring(1);\n                } else if (line.startsWith(\";\")) {\n                } else {\n                    //mark the start of the sequence with the fileIndex before the line was read\n                    if(sb.length() == 0){\n                        sequenceIndex = fileIndex;\n                    }\n                    sb.append(line);\n                }\n            }\n            fileIndex = br.getBytesRead();\n            line = br.readLine();\n\t\t\tif (line == null) {//i.e. EOF\n                String seq = sb.toString();\n                if ( seq.length() == 0) {\n                    logger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n                    logger.warn(\"header: {}\", header);\n                }\n                //    logger.debug(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n                try {\n                \t@SuppressWarnings(\"unchecked\")\n                \tS sequence = (S)sequenceCreator.getSequence(seq, sequenceIndex);\n                \theaderParser.parseHeader(header, sequence);\n                \tsequences.put(sequence.getAccession().getID(),sequence);\n                \tprocessedSequences++;                \t\n                } catch (CompoundNotFoundException e) {\n            \t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", \n            \t\t\t\theader, e.getMessage());\n            \t}\n                keepGoing = false;\n            }\n\t\t\tif (max > -1 && processedSequences>=max) {\n\t\t\t\tkeepGoing=false;\n\t\t\t}\n        } while (keepGoing);\n        this.line  = line;\n        this.header= header;\n        return sequences;\n    }\n\n\tpublic void close() throws IOException {\n\t\tbr.close();\n        isr.close();\n        //If stream was created from File object then we need to close it\n        if (fi != null) {\n            fi.close();\n        }\n        this.line=this.header = null;\n\t}\n\n    public static void main(String[] args) {\n        try {\n            String inputFile = \"src/test/resources/PF00104_small.fasta\";\n            FileInputStream is = new FileInputStream(inputFile);\n\n            FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(is, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n            LinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n            is.close();\n\n\n            logger.info(\"Protein Sequences: {}\", proteinSequences);\n\n            File file = new File(inputFile);\n            FastaReader<ProteinSequence,AminoAcidCompound> fastaProxyReader = \n            \t\tnew FastaReader<ProteinSequence,AminoAcidCompound>(\n            \t\t\t\tfile, \n            \t\t\t\tnew GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),\n            \t\t\t\tnew FileProxyProteinSequenceCreator(\n            \t\t\t\t\t\tfile, \n            \t\t\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(), \n            \t\t\t\t\t\tnew FastaSequenceParser()\n        \t\t\t\t\t\t) \n        \t\t\t\t);\n            LinkedHashMap<String,ProteinSequence> proteinProxySequences = fastaProxyReader.process();\n\n            for(String key : proteinProxySequences.keySet()){\n                ProteinSequence proteinSequence = proteinProxySequences.get(key);\n                logger.info(\"Protein Proxy Sequence Key: {}\", key);\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\n//                    int dummy = 1;\n//                }\n                logger.info(\"Protein Sequence: {}\", proteinSequence.toString());\n\n            }\n\n        } catch (Exception e) {\n            logger.warn(\"Exception: \", e);\n        }\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\n\n/**\n * Use FastaReaderHelper as an example of how to use this class where FastaReaderHelper should be the\n * primary class used to read Fasta files\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n */\npublic class FastaReader<S extends Sequence<?>, C extends Compound> {\n\n    private final static Logger logger = LoggerFactory.getLogger(FastaReader.class);\n\n    SequenceCreatorInterface<C> sequenceCreator;\n    SequenceHeaderParserInterface<S,C> headerParser;\n    BufferedReaderBytesRead br;\n    InputStreamReader isr;\n    FileInputStream fi = null;\n    long fileIndex = 0;\n    long sequenceIndex = 0;\n    String line = \"\";\n    String header= \"\";\n\n    /**\n     * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\n     * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\n     * an inputstream is forced to read all the data so you don't gain anything.\n     * @param is inputStream\n     * @param headerParser\n     * @param sequenceCreator\n     */\n    public FastaReader(InputStream is, SequenceHeaderParserInterface<S,C> headerParser,\n                       SequenceCreatorInterface<C> sequenceCreator) {\n        this.headerParser = headerParser;\n        isr = new InputStreamReader(is);\n        this.br = new BufferedReaderBytesRead(isr);\n        this.sequenceCreator = sequenceCreator;\n    }\n\n    /**\n     * If you are going to use the FileProxyProteinSequenceCreator then you\n     * need to use this constructor because we need details about\n     * the location of the file.\n     * @param file\n     * @param headerParser\n     * @param sequenceCreator\n     * @throws FileNotFoundException if the file does not exist, is a directory \n     * \trather than a regular file, or for some other reason cannot be opened\n     * \tfor reading.\n     * @throws SecurityException if a security manager exists and its checkRead\n     * \tmethod denies read access to the file.\n     */\n    public FastaReader(File file, SequenceHeaderParserInterface<S,C> headerParser,\n                       SequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\n        this.headerParser = headerParser;\n        fi = new FileInputStream(file);\n        isr = new InputStreamReader(fi);\n        this.br = new BufferedReaderBytesRead(isr);\n        this.sequenceCreator = sequenceCreator;\n    }\n\n    /**\n     * The parsing is done in this method.<br>\n     * This method tries to process all the available fasta records \n     * in the File or InputStream, closes the underlying resource, \n     * and return the results in {@link LinkedHashMap}.<br>\n     * You don't need to call {@link #close()} after calling this method.\n     * @see #process(int)\n     * @return {@link HashMap} containing all the parsed fasta records \n     * present, starting current fileIndex onwards.\n     * @throws IOException if an error occurs reading the input file\n     */\n    public LinkedHashMap<String,S> process() throws IOException {\n        LinkedHashMap<String,S> sequences = process(-1);\n        close();\n\n        return sequences;\n    }\n\n    /**\n     * This method tries to parse maximum <code>max</code> records from\n     * the open File or InputStream, and leaves the underlying resource open.<br>\n     * Subsequent calls to the same method continue parsing the rest of the file.<br>\n     * This is particularly useful when dealing with very big data files,\n     * (e.g. NCBI nr database), which can't fit into memory and will take long\n     * time before the first result is available.<br>\n     * <b>N.B.</b>\n     * <ul>\n     * <li>This method can't be called after calling its NO-ARGUMENT twin.</li> \n     * <li>remember to close the underlying resource when you are done.</li> \n     * </ul>\n     * @see #process()\n     * @author Amr AL-Hossary\n     * @since 3.0.6\n     * @param max maximum number of records to return, <code>-1</code> for infinity.\n     * @return {@link HashMap} containing maximum <code>max</code> parsed fasta records \n     * present, starting current fileIndex onwards.\n     * @throws IOException if an error occurs reading the input file\n     */\n    public LinkedHashMap<String,S> process(int max) throws IOException {\n\n\n        String line = \"\";\n        if(this.line != null && this.line.length() > 0){\n            line=this.line;\n        }\n        String header = \"\";\n        if(this.header != null && this.header.length() > 0){\n            header=this.header;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        int processedSequences=0;\n        boolean keepGoing = true;\n\n\n        LinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\n\n        do {\n            line = line.trim(); // nice to have but probably not needed\n            if (line.length() != 0) {\n                if (line.startsWith(\">\")) {//start of new fasta record\n\n                    if (sb.length() > 0) {\n                        //i.e. if there is already a sequence before\n                        //logger.info(\"Sequence index=\" + sequenceIndex);\n\n                        try {\n                            @SuppressWarnings(\"unchecked\")\n                            S sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                            headerParser.parseHeader(header, sequence);\n                            sequences.put(sequence.getAccession().getID(),sequence);\n                            processedSequences++;\n\n                        } catch (CompoundNotFoundException e) {\n                            logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n                                    header, e.getMessage());\n                        }\n\n                        sb.setLength(0); //this is faster than allocating new buffers, better memory utilization (same buffer)\n                    }\n                    header = line.substring(1);\n                } else if (line.startsWith(\";\")) {\n                } else {\n                    //mark the start of the sequence with the fileIndex before the line was read\n                    if(sb.length() == 0){\n                        sequenceIndex = fileIndex;\n                    }\n                    sb.append(line);\n                }\n            }\n            fileIndex = br.getBytesRead();\n\n            line = br.readLine();\n\n            if (line == null) {\n\n\n                // Fix for #282\n                if ( sequences.size() == 0 && max != -1) {\n                    return null;\n                }\n\n                //i.e. EOF\n                String seq = sb.toString();\n                if ( seq.length() == 0) {\n                    logger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n                    logger.warn(\"header: {}\", header);\n                }\n                //logger.info(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    S sequence = (S)sequenceCreator.getSequence(seq, sequenceIndex);\n                    headerParser.parseHeader(header, sequence);\n                    sequences.put(sequence.getAccession().getID(),sequence);\n                    processedSequences++;\n                } catch (CompoundNotFoundException e) {\n                    logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n                            header, e.getMessage());\n                }\n                keepGoing = false;\n            }\n            if (max > -1 && processedSequences>=max) {\n                keepGoing=false;\n            }\n            if ( this.line == null)\n                keepGoing = false;\n        } while (keepGoing);\n\n        this.line  = line;\n        this.header= header;\n\n        return sequences;\n    }\n\n    public void close() throws IOException {\n        br.close();\n        isr.close();\n        //If stream was created from File object then we need to close it\n        if (fi != null) {\n            fi.close();\n        }\n        this.line=this.header = null;\n    }\n\n    public static void main(String[] args) {\n        try {\n            String inputFile = \"/PF00104_small.fasta\";\n            InputStream is = FastaReader.class.getResourceAsStream(inputFile);\n\n\n            if ( is == null)\n                System.err.println(\"Could not get input file \" + inputFile);\n            FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(is, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n            LinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n            is.close();\n\n\n            //logger.info(\"Protein Sequences: {}\", proteinSequences);\n\n            File file = new File(inputFile);\n            FastaReader<ProteinSequence,AminoAcidCompound> fastaProxyReader =\n                    new FastaReader<ProteinSequence,AminoAcidCompound>(\n                            file,\n                            new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),\n                            new FileProxyProteinSequenceCreator(\n                                    file,\n                                    AminoAcidCompoundSet.getAminoAcidCompoundSet(),\n                                    new FastaSequenceParser()\n                            )\n                    );\n            LinkedHashMap<String,ProteinSequence> proteinProxySequences = fastaProxyReader.process();\n\n            for(String key : proteinProxySequences.keySet()){\n                ProteinSequence proteinSequence = proteinProxySequences.get(key);\n                logger.info(\"Protein Proxy Sequence Key: {}\", key);\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\n//                    int dummy = 1;\n//                }\n                logger.info(\"Protein Sequence: {}\", proteinSequence.toString());\n\n            }\n\n        } catch (Exception e) {\n            logger.warn(\"Exception: \", e);\n        }\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.util.LinkedHashMap;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class FastaReaderTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReaderTest.class);\n\n\tpublic FastaReaderTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws Exception {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() throws Exception {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of process method, of class FastaReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\t\tlogger.info(\"process\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\n\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\tinStream.close();\n\n\t\t//Should have 282 sequences\n\t\t//logger.debug(\"Expecting 283 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  283 );\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\tcase 0:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\tbreak;\n\t\t\tcase 281:\n\t\t\t\t//logger.debug(\"Get Accession: {}\", proteinSequence.getAccession());\n\t\t\t\t//logger.debug(\"Get Protein Sequence: {}\", proteinSequence.getSequenceAsString());\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\tbreak;\n\t\t\tcase 282:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,283);\n\t}\n\t\n\t@Test\n\tpublic void processIntTest() throws Exception {\n\t\tlogger.info(\"process(int)\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process(200);\n\n\t\t//Should have 200 sequences\n\t\t//logger.debug(\"Expecting 200 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  200 );\n\t\t\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\tcase 0:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\tbreak;\n\t\t\tcase 199:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q5F0P7_HUMAN/248-428\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"DRELVVIIGWAKHI-PGFS-S----LS-LGD----------------Q----MSL--LQS-----------AWM----------------------EI-LILG------IVYRSLP---YDDKLVYAEDYIMD-------------------------------------------------------------------------------------------------------------------------------------------------------------EEHSRLAGLLELYRAILQLV-RRY-KKL-K-VEKEEF--------------------VTLKA-LALA-NSDSMY-------------------------------------------IEDL--EAVQKLQDLLHEALQD-Y-----ELS---------QR---HE----------------------------EP------W--------RTG-KLLLTLPL-LRQTA-----------------AKA-VQHF--YSVKLQGKV--PMH--KLF-------LEM---\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,200);\n\t\t\n\t\t//Should have 83 sequences\n\t\tproteinSequences = fastaReader.process(200);\n\t\tassertEquals(proteinSequences.size() , 83 );\n\t\tseqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\tcase 0:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"RARA_CANFA/233-413\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(), \"TKCIIKTVEFAKQL-PGFT-T----LT-IAD----------------Q----ITL--LKA-----------ACL----------------------DI-LILR------ICTRYTP---EQDTMTFSEGLTLN-------------------------------------------------------------------------------------------------------------------------------------------------------------RTQMHKAGFGPLTDLVFAFA-NQL-LPL-E-MDDAET--------------------GLLSA-ICLI-CGDRQD-------------------------------------------LEQP--DRVDMLQEPLLEALKV-Y-----VRK---------RR---PS----------------------------RP------H--------MFP-KMLMKITD-LRSIS-----------------AKG-AERV--ITLKMEIPG--SMP--PLI-------QEM---\");\n\t\t\t\tbreak;\n\t\t\tcase 81:\n\t\t\t\t//logger.debug(proteinSequence.getAccession());\n\t\t\t\t//logger.debug(proteinSequence.getSequenceAsString());\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\tbreak;\n\t\t\tcase 82:\n\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,83);\n\t\tfastaReader.close();\n\t\tinStream.close();\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport junit.framework.TestCase;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.util.LinkedHashMap;\nimport java.util.logging.Level;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class FastaReaderTest extends TestCase{\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReaderTest.class);\n\n\tpublic FastaReaderTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws Exception {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() throws Exception {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of process method, of class FastaReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\t\tlogger.info(\"process\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\n\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\tinStream.close();\n\n\t\t//Should have 282 sequences\n\t\t//logger.debug(\"Expecting 283 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  283 );\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 281:\n\t\t\t\t\t//logger.debug(\"Get Accession: {}\", proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(\"Get Protein Sequence: {}\", proteinSequence.getSequenceAsString());\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 282:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,283);\n\t}\n\n\t@Test\n\tpublic void processIntTest() throws Exception {\n\t\tlogger.info(\"process(int)\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process(200);\n\n\t\t//Should have 200 sequences\n\t\t//logger.debug(\"Expecting 200 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  200 );\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 199:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q5F0P7_HUMAN/248-428\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"DRELVVIIGWAKHI-PGFS-S----LS-LGD----------------Q----MSL--LQS-----------AWM----------------------EI-LILG------IVYRSLP---YDDKLVYAEDYIMD-------------------------------------------------------------------------------------------------------------------------------------------------------------EEHSRLAGLLELYRAILQLV-RRY-KKL-K-VEKEEF--------------------VTLKA-LALA-NSDSMY-------------------------------------------IEDL--EAVQKLQDLLHEALQD-Y-----ELS---------QR---HE----------------------------EP------W--------RTG-KLLLTLPL-LRQTA-----------------AKA-VQHF--YSVKLQGKV--PMH--KLF-------LEM---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,200);\n\n\t\t//Should have 83 sequences\n\t\tproteinSequences = fastaReader.process(200);\n\t\tassertEquals(proteinSequences.size() , 83 );\n\t\tseqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"RARA_CANFA/233-413\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(), \"TKCIIKTVEFAKQL-PGFT-T----LT-IAD----------------Q----ITL--LKA-----------ACL----------------------DI-LILR------ICTRYTP---EQDTMTFSEGLTLN-------------------------------------------------------------------------------------------------------------------------------------------------------------RTQMHKAGFGPLTDLVFAFA-NQL-LPL-E-MDDAET--------------------GLLSA-ICLI-CGDRQD-------------------------------------------LEQP--DRVDMLQEPLLEALKV-Y-----VRK---------RR---PS----------------------------RP------H--------MFP-KMLMKITD-LRSIS-----------------AKG-AERV--ITLKMEIPG--SMP--PLI-------QEM---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 81:\n\t\t\t\t\t//logger.debug(proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(proteinSequence.getSequenceAsString());\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 82:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,83);\n\t\tfastaReader.close();\n\t\tinStream.close();\n\t}\n\n\t@Test\n\tpublic void testSmallFasta(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b;\n\n\t\t\tint nrSeq = 0;\n\n\t\t\twhile ((b = fastaReader.process(10)) != null) {\n\t\t\t\tfor (String key : b.keySet()) {\n\t\t\t\t\tnrSeq++;\n\n\t\t\t\t\t// #282 would result in an endless loop\n\t\t\t\t\t// this makes sure it has been fixed.\n\t\t\t\t\tassertTrue( \"Looks like there is a problem with termination of processing of the FASTA file!\",nrSeq < 15);\n\t\t\t\t}\n\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tfail(ex.getMessage());\n\t\t}\n\t}\n\n\n\t@Test\n\tpublic void testSmallFasta2(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\n\n\t\t\tint nrSeq = 0;\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b = fastaReader.process();\n\n\t\t\tassertNotNull(b);\n\n\t\t\t// #282 make sure that process() still works\n\n\t\t\tassertTrue(b.keySet().size() == 10);\n\n\n\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tfail(ex.getMessage());\n\t\t}\n\t}\n}\n","commitMessage":"fixing #282, adding junit test for verification\n","test_commitMessage":"fixing #282, adding junit test for verification\n","allZero":false}