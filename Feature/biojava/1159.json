{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/molbio/RestrictionEnzymeManager.java","test_path":"core/src/test/java/org/biojava/bio/molbio/RestrictionEnzymeManagerTest.java","prod_time":"2009-10-10 06:18:49","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"a4668eff3bdbbce5a2cbd7523167c867315b2087","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.Annotation;\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.SmallAnnotation;\nimport org.biojava.bio.program.tagvalue.ChangeTable;\nimport org.biojava.bio.program.tagvalue.LineSplitParser;\nimport org.biojava.bio.program.tagvalue.Parser;\nimport org.biojava.bio.program.tagvalue.RegexSplitter;\nimport org.biojava.bio.program.tagvalue.TagDropper;\nimport org.biojava.bio.program.tagvalue.TagValueContext;\nimport org.biojava.bio.program.tagvalue.TagValueListener;\nimport org.biojava.bio.program.tagvalue.TagValueParser;\nimport org.biojava.bio.program.tagvalue.ValueChanger;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeListener;\nimport org.biojava.utils.ChangeType;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.ParserException;\nimport org.biojava.utils.SmallSet;\n\n/**\n * <p><code>RestrictionEnzymeManager</code> manages collections of\n * static <code>RestrictionEnzyme</code> instances. A properties file\n * should be placed in the CLASSPATH containing a key\n * \"rebase.data.file\" and a corresponding value of a REBASE file\n * (standard REBASE format #31 conventionally named withrefm.### where\n * ### is the version number). This file will be loaded by the\n * <code>RestrictionEnzymeManager</code> <code>ClassLoader</code>. The\n * properties are loaded as a <code>ResourceBundle</code>, so the file\n * should be named \"RestrictionEnzymeManager.properties\".</p>\n * <p>Since 1.5, a format #31 REBASE file can be loaded at anytime\n * using the method <code>loadEnzymeFile</code> and optionally filtered\n * for commercially available enzymes.</p>\n *  \n * @author Keith James\n * @author George Waldon\n * @since 1.3\n\n */\npublic final class RestrictionEnzymeManager\n{\n     /**\n     * <code>REBASE_DATA_KEY</code> the ResourceBundle key which\n     * specifies the location of the REBASE flat file.\n     */\n    public static final String REBASE_DATA_KEY = \"rebase.data.file\";\n\n    /**\n     * <code>REBASE_TAG_NAME</code> the REBASE tag containing the\n     * enzyme name.\n     */\n    public static final String REBASE_TAG_NAME = \"<1>\";\n\n    /**\n     * <code>REBASE_TAG_ISZR</code> the REBASE tag containing the\n     * enzyme isoschizomers.\n     */\n    public static final String REBASE_TAG_ISZR = \"<2>\";\n\n    /**\n     * <code>REBASE_TAG_SITE</code> the REBASE tag containing the\n     * enzyme site.\n     */\n    public static final String REBASE_TAG_SITE = \"<3>\";\n\n    /**\n     * <code>REBASE_TAG_METH</code> the REBASE tag containing the\n     * methylation site.\n     */\n    public static final String REBASE_TAG_METH = \"<4>\";\n\n    /**\n     * <code>REBASE_TAG_ORGN</code> the REBASE tag containing the\n     * organism.\n     */\n    public static final String REBASE_TAG_ORGN = \"<5>\";\n\n    /**\n     * <code>REBASE_TAG_SRCE</code> the REBASE tag containing the\n     * source.\n     */\n    public static final String REBASE_TAG_SRCE = \"<6>\";\n\n    /**\n     * <code>REBASE_TAG_COMM</code> the REBASE tag containing the\n     * commercial suppliers.\n     */\n    public static final String REBASE_TAG_COMM = \"<7>\";\n\n    /**\n     * <code>REBASE_TAG_REFS</code> the REBASE tag containing the\n     * references.\n     */\n    public static final String REBASE_TAG_REFS = \"<8>\";\n    \n    \n    private static boolean loadCommercialOnly = false;\n\n    private static ResourceBundle bundle =\n        ResourceBundle.getBundle(RestrictionEnzymeManager.class.getName());\n\n    static\n    {\n        String rebaseDataFileName = bundle.getString(REBASE_DATA_KEY);\n        InputStream is = RestrictionEnzymeManager.class.getResourceAsStream(rebaseDataFileName);\n        loadData(is);\n    }\n\n    private static Map nameToSite;\n    private static Map nameToEnzyme;\n    private static Map nameToIsoschizomers;\n    private static Map sizeToCutters;\n    private static Map enzymeToPattern;\n    private static Map enzymeToAnnotation;\n    private static Map enzymeToSuppliers;\n\n    /**\n     * <code>RestrictionEnzymeManager</code> is a static utility\n     * method class and no instances should be created.\n     */\n    private RestrictionEnzymeManager() { }\n    \n    /**\n     * <code>loadEnzymeFile</code> loads a new REBASE file (or any file using\n     * REBASE format #31).\n     *\n     * @param is an InputStream over the file to load.\n     * @param commercialOnly indicates whether or not only commercially available \n     * enzymes are loaded.\n     *\n     * @since 1.5\n     */\n    public static synchronized void loadEnzymeFile(InputStream is, boolean commercialOnly) {\n        loadCommercialOnly = commercialOnly;\n        loadData(is);\n    }\n\n    /**\n     * <code>getAllEnzymes</code> returns an unmodifable set of all\n     * available enzymes.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getAllEnzymes()\n    {\n        return Collections.unmodifiableSet(enzymeToPattern.keySet());\n    }\n\n    /**\n     * <code>getEnzyme</code> returns an enzyme by name.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     *\n     * @return a <code>RestrictionEnzyme</code>.\n     */\n    public static RestrictionEnzyme getEnzyme(String name)\n    {\n        if (! nameToEnzyme.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n\n        return (RestrictionEnzyme) nameToEnzyme.get(name);\n    }\n\n    /**\n     * <code>getIsoschizomers</code> returns an unmodifable set of the\n     * isoschizomers of this enzyme.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getIsoschizomers(String name)\n    {\n        if (! nameToIsoschizomers.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n        Set result = (Set) nameToIsoschizomers.get(name);\n        if(result.contains(null))\n            return Collections.EMPTY_SET;\n        return Collections.unmodifiableSet(result);\n    }\n\n    /**\n     * <code>getRecognitionSequence</code> returns a string that describes\n     * the recognition site of this enzyme. It corresponds to the field <3>\n     * of the REBASE file.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     * @return a <code>String</code> describing the recognition sequence, \n     * e.g. \"G^AATTC\" for EcoRI.\n     * @since 1.5\n     */\n    public static String getRecognitionSequence(String name)\n    {\n        if (! nameToSite.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n        return (String) nameToSite.get(name);\n    }\n\n    /**\n     * <code>getNCutters</code> returns an unmodifable set of all\n     * enzymes with a cut site of size n.\n     *\n     * @param n an <code>int</code> cut site size.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getNCutters(int n)\n    {\n        Integer size = new Integer(n);\n        if (! sizeToCutters.containsKey(size))\n            return Collections.EMPTY_SET;\n\n        return Collections.unmodifiableSet((Set) sizeToCutters.get(size));\n    }\n\n    /**\n     * <code>getPatterns</code> returns two <code>Pattern</code>\n     * objects for an enzyme, one matches the forward strand and one\n     * the reverse. This enables searching of both strands of a\n     * sequence without reverse-complementing it. As\n     * <code>Pattern</code> objects are thread-safe these may be used\n     * for all searches.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return a <code>Pattern []</code> array with the forward strand\n     * <code>Pattern</code> at index 0 and the reverse at index 1.\n     */\n    public static Pattern [] getPatterns(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToPattern.containsKey(enzyme))\n            throw new IllegalArgumentException(\"RestrictionEnzyme '\"\n                                               + enzyme.getName()\n                                               + \"' is not registered. No precompiled Pattern is available\");\n\n        return (Pattern []) enzymeToPattern.get(enzyme);\n    }\n\n    /**\n     * <code>getAnnotation</code> returns an immutable, static\n     * annotation describing the enzyme. This is suitable for adding\n     * to <code>Feature</code>s which represent restriction sites. The\n     * annotation produced currently contains one key \"dbxref\" in line\n     * with the GenBank/EMBL qualifier for the \"misc_binding\" feature\n     * key. The key has a corresponding value \"REBASE:&lt;enzyme\n     * name&gt;\".\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return an <code>Annotation</code>.\n     */\n    public static Annotation getAnnotation(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToAnnotation.containsKey(enzyme))\n            throw new IllegalArgumentException(\"RestrictionEnzyme '\"\n                                               + enzyme.getName()\n                                               + \"' is not registered. No Annotation is available\");\n\n        return (Annotation) enzymeToAnnotation.get(enzyme);\n    }\n\n\n    /**\n     * <code>getSuppliers</code> returns a string describing the suppliers\n     * of this enzyme according to REBASE encoding for commercial sources \n     * or an empty String if the enzyme is not commecially available.\n     *\n     * <P>REBASE #31 version 604 code: </P>\n     * <P>A GE Healthcare (8/05) <BR>\n     * B Invitrogen Corporation(8/05)<BR>\n     * C Minotech Biotechnology (9/05)<BR>\n     * E Stratagene (9/05)<BR>\n     * F Fermentas International Inc. (2/06)<BR>\n     * G Qbiogene (9/05)<BR>\n     * H American Allied Biochemical, Inc. (9/05)<BR>\n     * I SibEnzyme Ltd. (2/06)<BR>\n     * J Nippon Gene Co., Ltd. (8/05)<BR>\n     * K Takara Bio Inc. (9/05)<BR>\n     * M Roche Applied Science (8/05)<BR>\n     * N New England Biolabs (2/06)<BR>\n     * O Toyobo Biochemicals (9/05)<BR>\n     * Q Molecular Biology Resources (8/05)<BR>\n     * R Promega Corporation (9/05)<BR>\n     * S Sigma Chemical Corporation (9/05)<BR>\n     * U Bangalore Genei (9/05)<BR>\n     * V Vivantis Technologies (1/06)<BR>\n     * X EURx Ltd. (9/05)<BR>\n     * Y CinnaGen Inc. (9/05)\n     * </P>\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return a <code>String</code>.\n     * @since 1.5\n     */\n    public static String getSuppliers(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToSuppliers.containsKey(enzyme))\n            return \"\";\n        return (String) enzymeToSuppliers.get(enzyme);\n    }\n\n    /**\n     * <code>register</code> regisiters a new\n     * <code>RestrictionEnzyme</code> with the manager. It does not\n     * check that the isoschizomers are known to the manager. If there\n     * are custom isoschizomers in the <code>Set</code>, they should\n     * be also be registered.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code> to register.\n     *\n     * @param isoschizomers a <code>Set</code> of\n     * <code>RestrictionEnzyme</code>s which are isoschizomers.\n     */\n    public synchronized static void register(RestrictionEnzyme enzyme,\n                                             Set               isoschizomers)\n    {\n        for (Iterator ii = isoschizomers.iterator(); ii.hasNext();)\n        {\n            Object o = ii.next();\n\n            if (! (o instanceof RestrictionEnzyme))\n            {\n                throw new IllegalArgumentException(\"Isoschizomers set may contain only RestrictionEnzymes. Found '\"\n                                                   + o\n                                                   + \"'\");\n            }\n        }\n\n        registerEnzyme(enzyme);\n\n        String name = enzyme.getName();\n        nameToIsoschizomers.put(name, isoschizomers);\n    }\n\n    /**\n     * <code>registerEnzyme</code> registers an enzyme, but does not\n     * populate its isoschizomers. This is because registering the\n     * contents of a REBASE file and registering a custom enzyme\n     * handle addition of isoschizomers differently, but both use this\n     * method for all other registration functions.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     */\n    private static void registerEnzyme(RestrictionEnzyme enzyme)\n    {\n        String name = enzyme.getName();\n        nameToEnzyme.put(name, enzyme);\n\n        Integer sizeKey = new Integer(enzyme.getRecognitionSite().length());\n        if (sizeToCutters.containsKey(sizeKey))\n        {\n            Set s = (Set) sizeToCutters.get(sizeKey);\n            s.add(enzyme);\n        }\n        else\n        {\n            Set s = new HashSet();\n            s.add(enzyme);\n            sizeToCutters.put(sizeKey, s);\n        }\n\n        Pattern forward = Pattern.compile(enzyme.getForwardRegex());\n        Pattern reverse = Pattern.compile(enzyme.getReverseRegex());\n        enzymeToPattern.put(enzyme, new Pattern [] { forward, reverse });\n\n        Annotation annotation = new SmallAnnotation();\n        try\n        {\n            annotation.setProperty(\"dbxref\", \"REBASE:\" + name);\n        }\n        catch (ChangeVetoException cve)\n        {\n            throw new BioError(\"Assertion Failure: failed to modify Annotation\", cve);\n        }\n\n        annotation.addChangeListener(ChangeListener.ALWAYS_VETO,ChangeType.UNKNOWN);\n        enzymeToAnnotation.put(enzyme, annotation);\n    }\n\n    private static void loadData(InputStream is) {\n        nameToSite          = new HashMap();\n        nameToEnzyme        = new HashMap();\n        nameToIsoschizomers = new HashMap();\n        sizeToCutters       = new HashMap();\n        enzymeToPattern     = new HashMap();\n        enzymeToAnnotation  = new HashMap();\n        enzymeToSuppliers   = new HashMap();\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n            // Basic linesplit parser\n            LineSplitParser lsParser = new LineSplitParser();\n            lsParser.setEndOfRecord(TagValueParser.EMPTY_LINE_EOR);\n            lsParser.setSplitOffset(3);\n            lsParser.setContinueOnEmptyTag(true);\n            lsParser.setMergeSameTag(true);\n\n            // The end of the chain\n            RebaseEnzymeBuilder builder = new RebaseEnzymeBuilder();\n\n            // Create isoschizomer value splitter\n            RegexSplitter iso =\n                new RegexSplitter(Pattern.compile(\"([^,]+)\"), 1);\n            // Create site value splitter\n            RegexSplitter site =\n                new RegexSplitter(Pattern.compile(\"(\\\\(-?\\\\d+/-?\\\\d+\\\\)|[A-Za-z^]+)\"), 1);\n\n            ChangeTable table = new ChangeTable();\n            table.setSplitter(REBASE_TAG_ISZR, iso);\n            table.setSplitter(REBASE_TAG_SITE, site);\n            ValueChanger changer = new ValueChanger(builder, table);\n\n            // Filter tags\n            TagDropper rebaseTags = new TagDropper(changer);\n            // Retain the enzyme name\n            rebaseTags.addTag(REBASE_TAG_NAME);\n            // Retain isoschizomers\n            rebaseTags.addTag(REBASE_TAG_ISZR);\n            // Retain recognition sequence\n            rebaseTags.addTag(REBASE_TAG_SITE);\n            // Retain commercial supplier\n            rebaseTags.addTag(REBASE_TAG_COMM);\n\n\n\n            Parser parser = new Parser();\n            while (parser.read(br, lsParser, rebaseTags))\n            {\n                continue;\n            }\n\n            // Replace isoschizomer names with RestrictionEnzymes\n            Map tempMap = new HashMap();\n            Set tempSet = null;\n            for (Iterator ni = nameToIsoschizomers.keySet().iterator(); ni.hasNext();)\n            {\n                Object name = ni.next();\n                Set isoschizomers = (Set) nameToIsoschizomers.get(name);\n\n                if (isoschizomers.size() == 0)\n                    tempSet = Collections.EMPTY_SET;\n                else\n                    tempSet = (Set) isoschizomers.getClass().newInstance();\n\n                tempMap.put(name, tempSet);\n\n                for (Iterator ii = isoschizomers.iterator(); ii.hasNext();) {\n                    String isoName = (String) ii.next();\n                    Object re = nameToEnzyme.get(isoName);\n                    //bug fix suggested by George Waldon\n                    if(re!=null)\n                        tempSet.add(re);\n                }\n            }\n\n            nameToIsoschizomers = tempMap;\n        }\n        catch (Exception e)\n        {\n            throw new BioError(\"Failed to read REBASE data file\",e);\n        }\n    }\n\n    /**\n     * <code>RebaseEnzymeBuilder</code> creates enzyme instances and\n     * populates the maps.\n     */\n    private static class RebaseEnzymeBuilder implements TagValueListener\n    {\n        private String recseq;\n        private String name;\n        private Set isoschizomers;\n        private List isoBuffer;\n        private SymbolList site;\n        private int [] usCutPositions;\n        private int [] dsCutPositions;\n        private boolean isCommerciallyAvailable;\n\n        private String tagState;\n        private String suppliers;\n        private boolean unknownSite;\n\n        RebaseEnzymeBuilder() { }\n\n        public void startRecord() throws ParserException\n        {\n            isoBuffer = new ArrayList(30);\n            recseq         = \"\";\n            site           = null;\n            dsCutPositions = null;\n            usCutPositions = null;\n            unknownSite = false;\n            isCommerciallyAvailable = false;\n        }\n\n        public void endRecord() throws ParserException\n        {\n            if (! getRecordState())\n                return;\n            if (unknownSite || site == null)\n                return;\n\n            int isoCount = isoBuffer.size();\n            if (isoCount < 30)\n            {\n                isoschizomers = new SmallSet(isoCount);\n                for (int i = 0; i < isoCount; i++)\n                    isoschizomers.add(isoBuffer.get(i));\n            }\n            else\n            {\n                isoschizomers = new HashSet(isoBuffer);\n            }\n\n            if(!loadCommercialOnly || isCommerciallyAvailable) {\n                RestrictionEnzyme re = createEnzyme();\n                registerEnzyme(re);\n                nameToIsoschizomers.put(name, isoschizomers);\n                enzymeToSuppliers.put(re,suppliers);\n                nameToSite.put(name,recseq);\n            }\n        }\n\n        public void startTag(Object tag) throws ParserException\n        {\n            tagState = (String) tag;\n        }\n\n        public void endTag() throws ParserException { }\n\n        public void value(TagValueContext context, Object value)\n            throws ParserException\n        {\n            if (tagState.equals(REBASE_TAG_NAME))\n                name = (String) value;\n            else if (tagState.equals(REBASE_TAG_ISZR))\n                isoBuffer.add(value);\n            else if (tagState.equals(REBASE_TAG_SITE)) {\n                recseq += (String) value;\n                processSite(value);\n            } else if (tagState.equals(REBASE_TAG_COMM))\n                processSuppliers(value);\n            else\n                throw new ParserException(\"Unable to handle value for tag '\"\n                                          + tagState\n                                          + \"'\");\n        }\n\n        boolean getRecordState()\n        {\n            return tagState != null;\n        }\n\n        RestrictionEnzyme createEnzyme()\n        {\n            RestrictionEnzyme enzyme = null;\n\n            try\n            {\n                if (usCutPositions != null)\n                {\n                    enzyme = new RestrictionEnzyme(name, site,\n                                                   usCutPositions[0],\n                                                   usCutPositions[1],\n                                                   dsCutPositions[0],\n                                                   dsCutPositions[1]);\n                }\n                else\n                {\n                    enzyme = new RestrictionEnzyme(name, site,\n                                                   dsCutPositions[0],\n                                                   dsCutPositions[1]);\n                }\n            }\n            catch (IllegalAlphabetException iae)\n            {\n                throw new BioError(\"New DNA SymbolList no longer consists on DNA Alphabet\",iae);\n            }\n\n            return enzyme;\n        }\n\n        private void processSuppliers(Object value) throws ParserException {\n            suppliers = (String) value;\n            if(suppliers.length()!=0)\n                isCommerciallyAvailable = true;\n        }\n\n        private void processSite(Object value) throws ParserException\n        {\n            StringBuffer sb = new StringBuffer((String) value);\n            int div, forIdx, revIdx;\n\n            // REBASE marks enzymes whose site is not known with '?'\n            if (sb.charAt(0) == '?')\n            {\n                unknownSite = true;\n                return;\n            }\n\n            if (sb.charAt(0) == '(')\n            {\n                // Index separator\n                div = sb.indexOf(\"/\");\n\n                try\n                {\n                    forIdx = Integer.parseInt(sb.substring(1, div));\n                    revIdx = Integer.parseInt(sb.substring(div + 1,\n                                                           sb.length() - 1));\n                }\n                catch (NumberFormatException nfe)\n                {\n                    throw new ParserException(\"Failed to parse cut site index\",nfe);\n                }\n\n                // Indices before the site indicate a double cutter\n                if (site == null)\n                {\n                    usCutPositions = new int [2];\n                    usCutPositions[0] = forIdx;\n                    usCutPositions[1] = revIdx;\n                }\n                else\n                {\n                    dsCutPositions = new int [2];\n                    dsCutPositions[0] = forIdx + site.length();\n                    dsCutPositions[1] = revIdx + site.length();\n                }\n            }\n            else\n            {\n                // Explicit cut site marker\n                int cut = sb.indexOf(\"^\");\n                dsCutPositions = new int [2];\n\n                try\n                {\n                    if (cut == -1)\n                    {\n                        site = DNATools.createDNA(sb.substring(0));\n                        dsCutPositions[0] = 1;\n                        dsCutPositions[1] = 1;\n                    }\n                    else\n                    {\n                        sb.deleteCharAt(cut);\n                        site = DNATools.createDNA(sb.substring(0));\n                        dsCutPositions[0] = cut;\n                        dsCutPositions[1] = site.length() - cut;\n                    }\n                }\n                catch (IllegalSymbolException iae)\n                {\n                    throw new ParserException(\"Illegal DNA symbol in recognition site\",iae);\n                }\n            }\n        }\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ResourceBundle;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.Annotation;\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.SmallAnnotation;\nimport org.biojava.bio.program.tagvalue.ChangeTable;\nimport org.biojava.bio.program.tagvalue.LineSplitParser;\nimport org.biojava.bio.program.tagvalue.Parser;\nimport org.biojava.bio.program.tagvalue.RegexSplitter;\nimport org.biojava.bio.program.tagvalue.TagDropper;\nimport org.biojava.bio.program.tagvalue.TagValueContext;\nimport org.biojava.bio.program.tagvalue.TagValueListener;\nimport org.biojava.bio.program.tagvalue.TagValueParser;\nimport org.biojava.bio.program.tagvalue.ValueChanger;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeListener;\nimport org.biojava.utils.ChangeType;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.ParserException;\nimport org.biojava.utils.SmallSet;\n\n/**\n * <p><code>RestrictionEnzymeManager</code> manages collections of\n * static <code>RestrictionEnzyme</code> instances. A properties file\n * should be placed in the CLASSPATH containing a key\n * \"rebase.data.file\" and a corresponding value of a REBASE file\n * (standard REBASE format #31 conventionally named withrefm.### where\n * ### is the version number). This file will be loaded by the\n * <code>RestrictionEnzymeManager</code> <code>ClassLoader</code>. The\n * properties are loaded as a <code>ResourceBundle</code>, so the file\n * should be named \"RestrictionEnzymeManager.properties\".</p>\n * <p>Since 1.5, a format #31 REBASE file can be loaded at anytime\n * using the method <code>loadEnzymeFile</code> and optionally filtered\n * for commercially available enzymes.</p>\n *  \n * @author Keith James\n * @author George Waldon\n * @since 1.3\n\n */\npublic final class RestrictionEnzymeManager\n{\n     /**\n     * <code>REBASE_DATA_KEY</code> the ResourceBundle key which\n     * specifies the location of the REBASE flat file.\n     */\n    public static final String REBASE_DATA_KEY = \"rebase.data.file\";\n\n    /**\n     * <code>REBASE_TAG_NAME</code> the REBASE tag containing the\n     * enzyme name.\n     */\n    public static final String REBASE_TAG_NAME = \"<1>\";\n\n    /**\n     * <code>REBASE_TAG_ISZR</code> the REBASE tag containing the\n     * enzyme isoschizomers.\n     */\n    public static final String REBASE_TAG_ISZR = \"<2>\";\n\n    /**\n     * <code>REBASE_TAG_SITE</code> the REBASE tag containing the\n     * enzyme site.\n     */\n    public static final String REBASE_TAG_SITE = \"<3>\";\n\n    /**\n     * <code>REBASE_TAG_METH</code> the REBASE tag containing the\n     * methylation site.\n     */\n    public static final String REBASE_TAG_METH = \"<4>\";\n\n    /**\n     * <code>REBASE_TAG_ORGN</code> the REBASE tag containing the\n     * organism.\n     */\n    public static final String REBASE_TAG_ORGN = \"<5>\";\n\n    /**\n     * <code>REBASE_TAG_SRCE</code> the REBASE tag containing the\n     * source.\n     */\n    public static final String REBASE_TAG_SRCE = \"<6>\";\n\n    /**\n     * <code>REBASE_TAG_COMM</code> the REBASE tag containing the\n     * commercial suppliers.\n     */\n    public static final String REBASE_TAG_COMM = \"<7>\";\n\n    /**\n     * <code>REBASE_TAG_REFS</code> the REBASE tag containing the\n     * references.\n     */\n    public static final String REBASE_TAG_REFS = \"<8>\";\n    \n    \n    private static boolean loadCommercialOnly = false;\n\n    private static ResourceBundle bundle =\n        ResourceBundle.getBundle(RestrictionEnzymeManager.class.getName());\n\n    static\n    {\n        String rebaseDataFileName = bundle.getString(REBASE_DATA_KEY);\n        InputStream is = RestrictionEnzymeManager.class.getResourceAsStream(rebaseDataFileName);\n        loadData(is);\n    }\n\n    private static Map nameToSite;\n    private static Map nameToEnzyme;\n    private static Map nameToIsoschizomers;\n    private static Map sizeToCutters;\n    private static Map enzymeToPattern;\n    private static Map enzymeToAnnotation;\n    private static Map enzymeToSuppliers;\n\n    /**\n     * <code>RestrictionEnzymeManager</code> is a static utility\n     * method class and no instances should be created.\n     */\n    private RestrictionEnzymeManager() { }\n    \n    /**\n     * <code>loadEnzymeFile</code> loads a new REBASE file (or any file using\n     * REBASE format #31).\n     *\n     * @param is an InputStream over the file to load.\n     * @param commercialOnly indicates whether or not only commercially available \n     * enzymes are loaded.\n     *\n     * @since 1.5\n     */\n    public static synchronized void loadEnzymeFile(InputStream is, boolean commercialOnly) {\n        loadCommercialOnly = commercialOnly;\n        loadData(is);\n    }\n\n    /**\n     * <code>getAllEnzymes</code> returns an unmodifable set of all\n     * available enzymes.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getAllEnzymes()\n    {\n        return Collections.unmodifiableSet(enzymeToPattern.keySet());\n    }\n\n    /**\n     * <code>getEnzyme</code> returns an enzyme by name.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     *\n     * @return a <code>RestrictionEnzyme</code>.\n     */\n    public static RestrictionEnzyme getEnzyme(String name)\n    {\n        if (! nameToEnzyme.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n\n        return (RestrictionEnzyme) nameToEnzyme.get(name);\n    }\n\n    /**\n     * <code>getIsoschizomers</code> returns an unmodifable set of the\n     * isoschizomers of this enzyme.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getIsoschizomers(String name)\n    {\n        if (! nameToIsoschizomers.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n        Set result = (Set) nameToIsoschizomers.get(name);\n        if(result.contains(null))\n            return Collections.EMPTY_SET;\n        return Collections.unmodifiableSet(result);\n    }\n\n    /**\n     * <code>getRecognitionSequence</code> returns a string that describes\n     * the recognition site of this enzyme. It corresponds to the field <3>\n     * of the REBASE file.\n     *\n     * @param name a <code>String</code> such as EcoRI, case\n     * sensitive.\n     * @return a <code>String</code> describing the recognition sequence, \n     * e.g. \"G^AATTC\" for EcoRI.\n     * @since 1.5\n     */\n    public static String getRecognitionSequence(String name)\n    {\n        if (! nameToSite.containsKey(name))\n            throw new IllegalArgumentException(\"Unknown RestrictionEnzyme name '\"\n                                               + name\n                                               + \"'\");\n        return (String) nameToSite.get(name);\n    }\n\n    /**\n     * <code>getNCutters</code> returns an unmodifable set of all\n     * enzymes with a cut site of size n.\n     *\n     * @param n an <code>int</code> cut site size.\n     *\n     * @return a <code>Set</code> of <code>RestrictionEnzyme</code>s.\n     */\n    public static Set getNCutters(int n)\n    {\n        Integer size = new Integer(n);\n        if (! sizeToCutters.containsKey(size))\n            return Collections.EMPTY_SET;\n\n        return Collections.unmodifiableSet((Set) sizeToCutters.get(size));\n    }\n\n    /**\n     * <code>getPatterns</code> returns two <code>Pattern</code>\n     * objects for an enzyme, one matches the forward strand and one\n     * the reverse. This enables searching of both strands of a\n     * sequence without reverse-complementing it. As\n     * <code>Pattern</code> objects are thread-safe these may be used\n     * for all searches.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return a <code>Pattern []</code> array with the forward strand\n     * <code>Pattern</code> at index 0 and the reverse at index 1.\n     */\n    public static Pattern [] getPatterns(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToPattern.containsKey(enzyme))\n            throw new IllegalArgumentException(\"RestrictionEnzyme '\"\n                                               + enzyme.getName()\n                                               + \"' is not registered. No precompiled Pattern is available\");\n\n        return (Pattern []) enzymeToPattern.get(enzyme);\n    }\n\n    /**\n     * <code>getAnnotation</code> returns an immutable, static\n     * annotation describing the enzyme. This is suitable for adding\n     * to <code>Feature</code>s which represent restriction sites. The\n     * annotation produced currently contains one key \"dbxref\" in line\n     * with the GenBank/EMBL qualifier for the \"misc_binding\" feature\n     * key. The key has a corresponding value \"REBASE:&lt;enzyme\n     * name&gt;\".\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return an <code>Annotation</code>.\n     */\n    public static Annotation getAnnotation(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToAnnotation.containsKey(enzyme))\n            throw new IllegalArgumentException(\"RestrictionEnzyme '\"\n                                               + enzyme.getName()\n                                               + \"' is not registered. No Annotation is available\");\n\n        return (Annotation) enzymeToAnnotation.get(enzyme);\n    }\n\n\n    /**\n     * <code>getSuppliers</code> returns a string describing the suppliers\n     * of this enzyme according to REBASE encoding for commercial sources \n     * or an empty String if the enzyme is not commecially available.\n     *\n     * <P>REBASE #31 version 604 code: </P>\n     * <P>A GE Healthcare (8/05) <BR>\n     * B Invitrogen Corporation(8/05)<BR>\n     * C Minotech Biotechnology (9/05)<BR>\n     * E Stratagene (9/05)<BR>\n     * F Fermentas International Inc. (2/06)<BR>\n     * G Qbiogene (9/05)<BR>\n     * H American Allied Biochemical, Inc. (9/05)<BR>\n     * I SibEnzyme Ltd. (2/06)<BR>\n     * J Nippon Gene Co., Ltd. (8/05)<BR>\n     * K Takara Bio Inc. (9/05)<BR>\n     * M Roche Applied Science (8/05)<BR>\n     * N New England Biolabs (2/06)<BR>\n     * O Toyobo Biochemicals (9/05)<BR>\n     * Q Molecular Biology Resources (8/05)<BR>\n     * R Promega Corporation (9/05)<BR>\n     * S Sigma Chemical Corporation (9/05)<BR>\n     * U Bangalore Genei (9/05)<BR>\n     * V Vivantis Technologies (1/06)<BR>\n     * X EURx Ltd. (9/05)<BR>\n     * Y CinnaGen Inc. (9/05)\n     * </P>\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     *\n     * @return a <code>String</code>.\n     * @since 1.5\n     */\n    public static String getSuppliers(RestrictionEnzyme enzyme)\n    {\n        if (! enzymeToSuppliers.containsKey(enzyme))\n            return \"\";\n        return (String) enzymeToSuppliers.get(enzyme);\n    }\n\n    /**\n     * <code>register</code> regisiters a new\n     * <code>RestrictionEnzyme</code> with the manager. It does not\n     * check that the isoschizomers are known to the manager. If there\n     * are custom isoschizomers in the <code>Set</code>, they should\n     * be also be registered.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code> to register.\n     *\n     * @param isoschizomers a <code>Set</code> of\n     * <code>RestrictionEnzyme</code>s which are isoschizomers.\n     */\n    public synchronized static void register(RestrictionEnzyme enzyme,\n                                             Set               isoschizomers)\n    {\n        for (Iterator ii = isoschizomers.iterator(); ii.hasNext();)\n        {\n            Object o = ii.next();\n\n            if (! (o instanceof RestrictionEnzyme))\n            {\n                throw new IllegalArgumentException(\"Isoschizomers set may contain only RestrictionEnzymes. Found '\"\n                                                   + o\n                                                   + \"'\");\n            }\n        }\n\n        registerEnzyme(enzyme);\n\n        String name = enzyme.getName();\n        nameToIsoschizomers.put(name, isoschizomers);\n    }\n\n    /**\n     * <code>registerEnzyme</code> registers an enzyme, but does not\n     * populate its isoschizomers. This is because registering the\n     * contents of a REBASE file and registering a custom enzyme\n     * handle addition of isoschizomers differently, but both use this\n     * method for all other registration functions.\n     *\n     * @param enzyme a <code>RestrictionEnzyme</code>.\n     */\n    private static void registerEnzyme(RestrictionEnzyme enzyme)\n    {\n        String name = enzyme.getName();\n        nameToEnzyme.put(name, enzyme);\n\n        Integer sizeKey = new Integer(enzyme.getRecognitionSite().length());\n        if (sizeToCutters.containsKey(sizeKey))\n        {\n            Set s = (Set) sizeToCutters.get(sizeKey);\n            s.add(enzyme);\n        }\n        else\n        {\n            Set s = new HashSet();\n            s.add(enzyme);\n            sizeToCutters.put(sizeKey, s);\n        }\n\n        Pattern forward = Pattern.compile(enzyme.getForwardRegex());\n        Pattern reverse = Pattern.compile(enzyme.getReverseRegex());\n        enzymeToPattern.put(enzyme, new Pattern [] { forward, reverse });\n\n        Annotation annotation = new SmallAnnotation();\n        try\n        {\n            annotation.setProperty(\"dbxref\", \"REBASE:\" + name);\n        }\n        catch (ChangeVetoException cve)\n        {\n            throw new BioError(\"Assertion Failure: failed to modify Annotation\", cve);\n        }\n\n        annotation.addChangeListener(ChangeListener.ALWAYS_VETO,ChangeType.UNKNOWN);\n        enzymeToAnnotation.put(enzyme, annotation);\n    }\n\n    private static void loadData(InputStream is) {\n        nameToSite          = new HashMap();\n        nameToEnzyme        = new HashMap();\n        nameToIsoschizomers = new HashMap();\n        sizeToCutters       = new HashMap();\n        enzymeToPattern     = new HashMap();\n        enzymeToAnnotation  = new HashMap();\n        enzymeToSuppliers   = new HashMap();\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(is));\n\n            // Basic linesplit parser\n            LineSplitParser lsParser = new LineSplitParser();\n            lsParser.setEndOfRecord(TagValueParser.EMPTY_LINE_EOR);\n            lsParser.setSplitOffset(3);\n            lsParser.setContinueOnEmptyTag(true);\n            lsParser.setMergeSameTag(true);\n\n            // The end of the chain\n            RebaseEnzymeBuilder builder = new RebaseEnzymeBuilder();\n\n            // Create isoschizomer value splitter\n            RegexSplitter iso =\n                new RegexSplitter(Pattern.compile(\"([^,]+)\"), 1);\n            // Create site value splitter\n            RegexSplitter site =\n                new RegexSplitter(Pattern.compile(\"(\\\\(-?\\\\d+/-?\\\\d+\\\\)|[A-Za-z^]+)\"), 1);\n\n            ChangeTable table = new ChangeTable();\n            table.setSplitter(REBASE_TAG_ISZR, iso);\n            table.setSplitter(REBASE_TAG_SITE, site);\n            ValueChanger changer = new ValueChanger(builder, table);\n\n            // Filter tags\n            TagDropper rebaseTags = new TagDropper(changer);\n            // Retain the enzyme name\n            rebaseTags.addTag(REBASE_TAG_NAME);\n            // Retain isoschizomers\n            rebaseTags.addTag(REBASE_TAG_ISZR);\n            // Retain recognition sequence\n            rebaseTags.addTag(REBASE_TAG_SITE);\n            // Retain commercial supplier\n            rebaseTags.addTag(REBASE_TAG_COMM);\n\n\n\n            Parser parser = new Parser();\n            while (parser.read(br, lsParser, rebaseTags))\n            {\n                continue;\n            }\n\n            // Replace isoschizomer names with RestrictionEnzymes\n            Map tempMap = new HashMap();\n            Set tempSet = null;\n            for (Iterator ni = nameToIsoschizomers.keySet().iterator(); ni.hasNext();)\n            {\n                Object name = ni.next();\n                Set isoschizomers = (Set) nameToIsoschizomers.get(name);\n\n                if (isoschizomers.size() == 0)\n                    tempSet = Collections.EMPTY_SET;\n                else\n                    tempSet = (Set) isoschizomers.getClass().newInstance();\n\n                tempMap.put(name, tempSet);\n\n                for (Iterator ii = isoschizomers.iterator(); ii.hasNext();) {\n                    String isoName = (String) ii.next();\n                    Object re = nameToEnzyme.get(isoName);\n                    //bug fix suggested by George Waldon\n                    if(re!=null)\n                        tempSet.add(re);\n                }\n            }\n\n            nameToIsoschizomers = tempMap;\n        }\n        catch (Exception e)\n        {\n            throw new BioError(\"Failed to read REBASE data file\",e);\n        }\n    }\n\n    /**\n     * <code>RebaseEnzymeBuilder</code> creates enzyme instances and\n     * populates the maps.\n     */\n    private static class RebaseEnzymeBuilder implements TagValueListener\n    {\n        private String recseq;\n        private String name;\n        private Set isoschizomers;\n        private List isoBuffer;\n        private SymbolList site;\n        private int [] usCutPositions;\n        private int [] dsCutPositions;\n        private boolean isCommerciallyAvailable;\n\n        private String tagState;\n        private String suppliers;\n        private boolean unknownSite;\n\n        RebaseEnzymeBuilder() { }\n\n        public void startRecord() throws ParserException\n        {\n            isoBuffer = new ArrayList(30);\n            recseq         = \"\";\n            site           = null;\n            dsCutPositions = null;\n            usCutPositions = null;\n            unknownSite = false;\n            isCommerciallyAvailable = false;\n        }\n\n        public void endRecord() throws ParserException\n        {\n            if (! getRecordState())\n                return;\n            if (unknownSite || site == null)\n                return;\n\n            int isoCount = isoBuffer.size();\n            if (isoCount < 30)\n            {\n                isoschizomers = new SmallSet(isoCount);\n                for (int i = 0; i < isoCount; i++)\n                    isoschizomers.add(isoBuffer.get(i));\n            }\n            else\n            {\n                isoschizomers = new HashSet(isoBuffer);\n            }\n\n            if(!loadCommercialOnly || isCommerciallyAvailable) {\n                RestrictionEnzyme re = createEnzyme();\n                registerEnzyme(re);\n                nameToIsoschizomers.put(name, isoschizomers);\n                enzymeToSuppliers.put(re,suppliers);\n                nameToSite.put(name,recseq);\n            }\n        }\n\n        public void startTag(Object tag) throws ParserException\n        {\n            tagState = (String) tag;\n        }\n\n        public void endTag() throws ParserException { }\n\n        public void value(TagValueContext context, Object value)\n            throws ParserException\n        {\n            if (tagState.equals(REBASE_TAG_NAME))\n                name = (String) value;\n            else if (tagState.equals(REBASE_TAG_ISZR))\n                isoBuffer.add(value);\n            else if (tagState.equals(REBASE_TAG_SITE)) {\n                recseq += (String) value;\n                processSite(value);\n            } else if (tagState.equals(REBASE_TAG_COMM))\n                processSuppliers(value);\n            else\n                throw new ParserException(\"Unable to handle value for tag '\"\n                                          + tagState\n                                          + \"'\");\n        }\n\n        boolean getRecordState()\n        {\n            return tagState != null;\n        }\n\n        RestrictionEnzyme createEnzyme()\n        {\n            RestrictionEnzyme enzyme = null;\n\n            try\n            {\n                if (usCutPositions != null)\n                {\n                    enzyme = new RestrictionEnzyme(name, site,\n                                                   usCutPositions[0],\n                                                   usCutPositions[1],\n                                                   dsCutPositions[0],\n                                                   dsCutPositions[1]);\n                }\n                else\n                {\n                    enzyme = new RestrictionEnzyme(name, site,\n                                                   dsCutPositions[0],\n                                                   dsCutPositions[1]);\n                }\n            }\n            catch (IllegalAlphabetException iae)\n            {\n                throw new BioError(\"New DNA SymbolList no longer consists on DNA Alphabet\",iae);\n            }\n\n            return enzyme;\n        }\n\n        private void processSuppliers(Object value) throws ParserException {\n            suppliers = (String) value;\n            if(suppliers.length()!=0)\n                isCommerciallyAvailable = true;\n        }\n\n        private void processSite(Object value) throws ParserException\n        {\n            StringBuffer sb = new StringBuffer((String) value);\n            int div, forIdx, revIdx;\n\n            // REBASE marks enzymes whose site is not known with '?'\n            if (sb.charAt(0) == '?')\n            {\n                unknownSite = true;\n                return;\n            }\n\n            if (sb.charAt(0) == '(')\n            {\n                // Index separator\n                div = sb.indexOf(\"/\");\n\n                try\n                {\n                    forIdx = Integer.parseInt(sb.substring(1, div));\n                    revIdx = Integer.parseInt(sb.substring(div + 1,\n                                                           sb.length() - 1));\n                }\n                catch (NumberFormatException nfe)\n                {\n                    throw new ParserException(\"Failed to parse cut site index\",nfe);\n                }\n\n                // Indices before the site indicate a double cutter\n                if (site == null)\n                {\n                    usCutPositions = new int [2];\n                    usCutPositions[0] = -forIdx;\n                    usCutPositions[1] = -revIdx;\n                }\n                else\n                {\n                    dsCutPositions = new int [2];\n                    dsCutPositions[0] = forIdx + site.length();\n                    dsCutPositions[1] = revIdx + site.length();\n                }\n            }\n            else\n            {\n                // Explicit cut site marker\n                int cut = sb.indexOf(\"^\");\n                dsCutPositions = new int [2];\n\n                try\n                {\n                    if (cut == -1)\n                    {\n                        site = DNATools.createDNA(sb.substring(0));\n                        dsCutPositions[0] = 1;\n                        dsCutPositions[1] = 1;\n                    }\n                    else\n                    {\n                        sb.deleteCharAt(cut);\n                        site = DNATools.createDNA(sb.substring(0));\n                        dsCutPositions[0] = cut;\n                        dsCutPositions[1] = site.length() - cut;\n                    }\n                }\n                catch (IllegalSymbolException iae)\n                {\n                    throw new ParserException(\"Illegal DNA symbol in recognition site\",iae);\n                }\n            }\n        }\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport java.io.InputStream;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * <code>RestrictionEnzymeManagerTest</code> tests manager\n * functionality.\n *\n * @author Keith James\n * @author G. Waldon\n */\npublic class RestrictionEnzymeManagerTest extends TestCase\n{\n    public RestrictionEnzymeManagerTest(String name)\n    {\n        super(name);\n    }\n\n    public void testGetAllEnzymes()\n    {\n        Set allEnz = RestrictionEnzymeManager.getAllEnzymes();\n        assertEquals(40, allEnz.size());\n    }\n\n    public void testGetEnzyme()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(\"EcoRI\", ecoRI.getName());\n\n        try\n        {\n            RestrictionEnzyme invalid = RestrictionEnzymeManager.getEnzyme(\"xxxx\");\n            invalid=invalid==null?null:invalid;//trick\n        }\n        catch (IllegalArgumentException iae)\n        {\n            return;\n        }\n\n        fail(\"Expected IllegalArgumentException\");\n    }\n\n    public void testGetIsoschizomers()\n    {\n        Set isoAvaI = RestrictionEnzymeManager.getIsoschizomers(\"AvaI\");\n        assertEquals(1, isoAvaI.size());\n\n        Set isoAvrI = RestrictionEnzymeManager.getIsoschizomers(\"AvrI\");\n        assertEquals(1, isoAvrI.size());\n\n        RestrictionEnzyme avaI = RestrictionEnzymeManager.getEnzyme(\"AvaI\");\n        RestrictionEnzyme avrI = RestrictionEnzymeManager.getEnzyme(\"AvrI\");\n\n        assertTrue(isoAvaI.contains(avrI));\n        assertTrue(isoAvrI.contains(avaI));\n\n        try\n        {\n            Set invalid = RestrictionEnzymeManager.getIsoschizomers(\"xxxx\");\n            invalid=invalid==null?null:invalid;//trick\n        }\n        catch (IllegalArgumentException iae)\n        {\n            return;\n        }\n\n        fail(\"Expected IllegalArgumentException\");\n    }\n\n    public void testGetNCutters()\n    {\n        Set all6Cutters = RestrictionEnzymeManager.getNCutters(6);\n        assertEquals(29, all6Cutters.size());\n\n        for (Iterator ei = all6Cutters.iterator(); ei.hasNext();)\n        {\n            RestrictionEnzyme e = (RestrictionEnzyme) ei.next();\n            assertEquals(6, e.getRecognitionSite().length());\n        }\n    }\n\n    public void testGetPatterns()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        Pattern [] pat = RestrictionEnzymeManager.getPatterns(ecoRI);\n\n        assertEquals(\"ga{2}t{2}c\", pat[0].pattern());\n        assertEquals(\"ga{2}t{2}c\", pat[1].pattern());\n\n        SymbolList site = null;\n        try\n        {\n            site = DNATools.createDNA(\"a\");\n        }\n        catch (IllegalSymbolException ise)\n        {\n            throw new BioError(ise, \"Internal error in test\");\n        }\n\n        RestrictionEnzyme custom = null;\n        try\n        {\n            custom = new RestrictionEnzyme(\"custom\", site, 1, 1);\n        }\n        catch (IllegalAlphabetException iae)\n        {\n            throw new BioError(iae, \"Internal error in test\");\n        }\n\n        try\n        {\n            pat = RestrictionEnzymeManager.getPatterns(custom);\n        }\n        catch (IllegalArgumentException iae)\n        {\n            return;\n        }\n\n        fail(\"Expected IllegalArgumentException\");\n    }\n    \n    /**\n     * @author G. Waldon\n     * @since 1.5\n     */\n    public void testGetRecognitionSequence() {\n        String recognition = RestrictionEnzymeManager.getRecognitionSequence(\"EcoRI\");\n        assertEquals(\"G^AATTC\",recognition);\n    }\n    \n    /** Note: suppliers vary between REBASE releases.\n     *\n     * @author G. Waldon\n     * @since 1.5\n     */\n    public void testgetSuppliers() {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        String suppliers = RestrictionEnzymeManager.getSuppliers(ecoRI);\n        assertEquals(\"ABCEFGHIJKLMNOQRSTUVX\",suppliers);\n    }\n    \n    /**\n     * @author G. Waldon\n     * @since 1.5\n     */\n    public void testloadEnzymeFile() {\n        String rebaseDataFileName = \"org/biojava/bio/molbio/rebase.dat\";\n        InputStream is = getClass().getClassLoader().getResourceAsStream(rebaseDataFileName);\n        RestrictionEnzymeManager.loadEnzymeFile(is,true);\n        Set re = RestrictionEnzymeManager.getAllEnzymes();\n        assertEquals(re.size(),1);\n        try\n        {\n            RestrictionEnzyme hind3 = RestrictionEnzymeManager.getEnzyme(\"HindIII\");\n            assertEquals(\"HindIII\", hind3.getName());\n        }\n        catch (IllegalArgumentException iae)\n        {\n            fail(\"IllegalArgumentException not expected\");\n        }\n        is = getClass().getClassLoader().getResourceAsStream(rebaseDataFileName);\n        RestrictionEnzymeManager.loadEnzymeFile(is,false);\n        re = RestrictionEnzymeManager.getAllEnzymes();\n        assertEquals(re.size(),2);\n        try\n        {\n            RestrictionEnzyme hind3 = RestrictionEnzymeManager.getEnzyme(\"HindIII\");\n            assertEquals(\"HindIII\", hind3.getName());\n            RestrictionEnzyme ecor1 = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n            assertEquals(\"EcoRI\", ecor1.getName());\n        }\n        catch (IllegalArgumentException iae)\n        {\n            fail(\"IllegalArgumentException not expected\");\n        }\n        rebaseDataFileName = \"/org/biojava/bio/molbio/rebase_common.dat\";\n        is = RestrictionEnzymeManager.class.getResourceAsStream(rebaseDataFileName);\n        RestrictionEnzymeManager.loadEnzymeFile(is,false);\n    }\n}\n","changedTest":"","commitMessage":"Fix restriction enzyme overhangs and upstream cutsites.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7240 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":true}