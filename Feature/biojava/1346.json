{"repository":"biojava","prod_path":"biojava3-protein-disorder/src/main/java/org/biojava3/ronn/Jronn.java","test_path":"biojava3-protein-disorder/src/test/java/org/biojava3/ronn/JronnTest.java","prod_time":"2011-08-02 00:17:56","test_time":"2011-08-17 00:38:22","type":"RENAME","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"0cd393ff8dca21d2df2fdac23719e349a70dc1a6","test_commitID":"d78f78af799384b0603403b4265e56a62ad9864e","isfound":"found test change","originPro":"package org.biojava3.ronn;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n\r\n\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.data.sequence.SequenceUtil;\r\nimport org.biojava3.ronn.ORonn.ResultLayout;\r\n\r\n/**\r\n * This class gives public API to RONN functions. \r\n * It is build on top of the command line client. Due to this fact a few things \r\n * could be improved and extended pending the command line client refactoring.  \r\n *\r\n * The input sequence limitations - the input sequence must not contain any ambiguous characters, \r\n * and have a minimum length of 19 amino acids. \r\n * \r\n * @author Peter Troshin\r\n *\r\n *\r\n */\r\npublic class Jronn {\r\n\t\r\n\t// Load models\r\n\tprivate static final ModelLoader loader = new ModelLoader();  \r\n\tstatic {\r\n\t\ttry {\r\n\t\t\tloader.loadModels();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e); \r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Holder for the ranges, contain pointers to starting and ending position \r\n\t * on the sequence which comprises a disordered region. Immutable. \r\n\t * @author pvtroshin\r\n\t */\r\n\tpublic static class Range {\r\n\t\t/**\r\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\r\n\t\t */\r\n\t\tfinal int from; \r\n\t\t/**\r\n\t\t * The range ending position includes the last residue. \r\n\t\t */\r\n\t\tfinal int to; \r\n\t\r\n\t\tpublic Range(int from, int to) {\r\n\t\t\tassert from>=0; \r\n\t\t\tassert from<to; \r\n\t\t\tthis.from = from; \r\n\t\t\tthis.to = to; \r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() { \r\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tfinal int prime = 31;\r\n\t\t\tint result = 1;\r\n\t\t\tresult = prime * result + from;\r\n\t\t\tresult = prime * result + to;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (this == obj)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj == null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (getClass() != obj.getClass())\r\n\t\t\t\treturn false;\r\n\t\t\tRange other = (Range) obj;\r\n\t\t\tif (from != other.from)\r\n\t\t\t\treturn false;\r\n\t\t\tif (to != other.to)\r\n\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\r\n\t\t    return predictSerial(sequence);\r\n\t}\r\n\r\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\r\n\t\tORonn.validateSequenceForRonn(fsequence);\r\n\t\tORonn ronn;\r\n\t\tfloat[] disorder = null; \r\n\t\ttry {\r\n\t\t\tronn = new ORonn(fsequence, loader);\r\n\t\t\tdisorder = ronn.call().getMeanScores();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t}\r\n\t\treturn disorder;  \r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the \r\n\t * probability of disorder is greater then 0.50.  \r\n\t *  \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then 0.5, null otherwise. \r\n\t *\r\n\t */\r\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\r\n\t\tfloat[] scores = getDisorderScores(sequence);\r\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\r\n\t}\r\n\r\n\t/**\r\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value \r\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.  \r\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then {@code probability}, null otherwise.\r\n\t */\r\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\r\n\t\tassert scores!=null && scores.length>0;\r\n\t\tassert probability>0 && probability<1;\r\n\t\t\r\n\t\tint count=0;\r\n\t\tint regionLen=0;\r\n\t\tList<Range> ranges = new ArrayList<Range>();\r\n\t\tfor(float score: scores) { \r\n\t\t\tcount++;\r\n\t\t\t// Round to 2 decimal points before comparison \r\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\r\n\t\t\tif(score>probability) {\r\n\t\t\t\tregionLen++;\r\n\t\t\t} else {\r\n\t\t\t\tif(regionLen>0) {\r\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1));\r\n\t\t\t\t}\r\n\t\t\t\tregionLen=0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// In case of the range to boundary runs to the very end of the sequence \r\n\t\tif(regionLen>1) {\r\n\t\t\tranges.add(new Range(count-regionLen+1, count));\r\n\t\t}\r\n\t\treturn ranges.toArray(new Range[ranges.size()]); \t\t\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability of disorder scores for each residue in the sequence for \r\n\t * many sequences in the input.\r\n\t * \r\n\t * @param sequences the list of the FastaSequence objects \r\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\r\n\t\tfor(FastaSequence fsequence : sequences) {\r\n\t\t\tresults.put(fsequence, predictSerial(fsequence));\r\n\t\t}\r\n\t\treturn results; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\r\n\t * \r\n\t * @param sequences sequences the list of the FastaSequence objects\r\n\t * @return\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\r\n\t\tfor(FastaSequence fs: sequences) {\r\n\t\t\tdisorderRanges.put(fs, getDisorder(fs));\r\n\t\t}\r\n\t\treturn disorderRanges; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the protein sequence.\r\n\t * @param fastaFile input file name containing the sequence in FASTA\r\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\r\n\t * @throws FileNotFoundException if the input file cannot be found\r\n\t * @throws IOException of the system cannot access or read from the input file \r\n\t * @see #getDisorder(FastaSequence)\r\n\t * @see #Jronn.Range\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\treturn getDisorder(sequences);\r\n\t}\r\n\t\r\n\t/**\r\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\r\n\t *  \r\n\t * @param fastaFile  fully qualified path to the input FASTA file  \r\n\t * @param outputFile file name of the file for the results \r\n\t * @param threadNumber the number of threads to use, default\r\n\t * @param controls the format of the result file \r\n\t * @throws FileNotFoundException if input file in not found \r\n\t * @throws IOException if the input or the output files cannot be accessed  \r\n\t * @see ORonn.ResultLayout\r\n\t */\r\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\tInputParameters in = new InputParameters(); \r\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\r\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\r\n\t\tin.setThreadNum(Integer.toString(threadNumber)); \r\n\t\tORonn.predictParallel(sequences, in, loader); \r\n\t} \r\n}\r\n","changedPro":"package org.biojava3.ronn;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n\r\n\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.data.sequence.SequenceUtil;\r\nimport org.biojava3.ronn.ORonn.ResultLayout;\r\n\r\n/**\r\n * This class gives public API to RONN functions. \r\n * It is build on top of the command line client. Due to this fact a few things \r\n * could be improved and extended pending the command line client refactoring.  \r\n *\r\n * The input sequence limitations - the input sequence must not contain any ambiguous characters, \r\n * and have a minimum length of 19 amino acids. \r\n * \r\n * @author Peter Troshin\r\n *\r\n *\r\n */\r\npublic class Jronn {\r\n\t\r\n\t// Load models\r\n\tprivate static final ModelLoader loader = new ModelLoader();  \r\n\tstatic {\r\n\t\ttry {\r\n\t\t\tloader.loadModels();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e); \r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Holder for the ranges, contain pointers to starting and ending position \r\n\t * on the sequence which comprises a disordered region. Immutable. \r\n\t * @author pvtroshin\r\n\t */\r\n\tpublic static class Range {\r\n\t\t/**\r\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\r\n\t\t */\r\n\t\tfinal int from; \r\n\t\t/**\r\n\t\t * The range ending position includes the last residue. \r\n\t\t */\r\n\t\tfinal int to; \r\n\t\r\n\t\tpublic Range(int from, int to) {\r\n\t\t\tassert from>=0; \r\n\t\t\tassert from<to; \r\n\t\t\tthis.from = from; \r\n\t\t\tthis.to = to; \r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() { \r\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tfinal int prime = 31;\r\n\t\t\tint result = 1;\r\n\t\t\tresult = prime * result + from;\r\n\t\t\tresult = prime * result + to;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (this == obj)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj == null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (getClass() != obj.getClass())\r\n\t\t\t\treturn false;\r\n\t\t\tRange other = (Range) obj;\r\n\t\t\tif (from != other.from)\r\n\t\t\t\treturn false;\r\n\t\t\tif (to != other.to)\r\n\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\r\n\t\t    return predictSerial(sequence);\r\n\t}\r\n\r\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\r\n\t\tORonn.validateSequenceForRonn(fsequence);\r\n\t\tORonn ronn;\r\n\t\tfloat[] disorder = null; \r\n\t\ttry {\r\n\t\t\tronn = new ORonn(fsequence, loader);\r\n\t\t\tdisorder = ronn.call().getMeanScores();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t}\r\n\t\treturn disorder;  \r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the \r\n\t * probability of disorder is greater then 0.50.  \r\n\t *  \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then 0.5, null otherwise. \r\n\t *\r\n\t */\r\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\r\n\t\tfloat[] scores = getDisorderScores(sequence);\r\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\r\n\t}\r\n\r\n\t/**\r\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value \r\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.  \r\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then {@code probability}, null otherwise.\r\n\t */\r\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\r\n\t\tassert scores!=null && scores.length>0;\r\n\t\tassert probability>0 && probability<1;\r\n\t\t\r\n\t\tint count=0;\r\n\t\tint regionLen=0;\r\n\t\tList<Range> ranges = new ArrayList<Range>();\r\n\t\tfor(float score: scores) { \r\n\t\t\tcount++;\r\n\t\t\t// Round to 2 decimal points before comparison \r\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\r\n\t\t\tif(score>probability) {\r\n\t\t\t\tregionLen++;\r\n\t\t\t} else {\r\n\t\t\t\tif(regionLen>0) {\r\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1));\r\n\t\t\t\t}\r\n\t\t\t\tregionLen=0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// In case of the range to boundary runs to the very end of the sequence \r\n\t\tif(regionLen>1) {\r\n\t\t\tranges.add(new Range(count-regionLen+1, count));\r\n\t\t}\r\n\t\treturn ranges.toArray(new Range[ranges.size()]); \t\t\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability of disorder scores for each residue in the sequence for \r\n\t * many sequences in the input.\r\n\t * \r\n\t * @param sequences the list of the FastaSequence objects \r\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\r\n\t\tfor(FastaSequence fsequence : sequences) {\r\n\t\t\tresults.put(fsequence, predictSerial(fsequence));\r\n\t\t}\r\n\t\treturn results; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\r\n\t * \r\n\t * @param sequences sequences the list of the FastaSequence objects\r\n\t * @return\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\r\n\t\tfor(FastaSequence fs: sequences) {\r\n\t\t\tdisorderRanges.put(fs, getDisorder(fs));\r\n\t\t}\r\n\t\treturn disorderRanges; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the protein sequence.\r\n\t * @param fastaFile input file name containing the sequence in FASTA\r\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\r\n\t * @throws FileNotFoundException if the input file cannot be found\r\n\t * @throws IOException of the system cannot access or read from the input file \r\n\t * @see #getDisorder(FastaSequence)\r\n\t * @see #Jronn.Range\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\treturn getDisorder(sequences);\r\n\t}\r\n\t\r\n\t/**\r\n\t * TODO \r\n\t * \r\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\r\n\t *  \r\n\t * @param fastaFile  fully qualified path to the input FASTA file  \r\n\t * @param outputFile file name of the file for the results \r\n\t * @param threadNumber the number of threads to use, default\r\n\t * @param controls the format of the result file \r\n\t * @throws FileNotFoundException if input file in not found \r\n\t * @throws IOException if the input or the output files cannot be accessed  \r\n\t * @see ORonn.ResultLayout\r\n\t \r\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\tInputParameters in = new InputParameters(); \r\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\r\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\r\n\t\t//in.setThreadNum(Integer.toString(threadNumber)); \r\n\t\tORonn.predictParallel(sequences, in, loader); \r\n\t}\r\n\t*/ \r\n}\r\n","originTest":"package org.biojava3.ronn;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.ronn.Jronn.Range;\r\nimport org.junit.Test;\r\n\r\npublic class JronnTester {\r\n\r\n\t@Test\r\n\tpublic void verifyRanges() { \r\n  \r\n\tRange[]\tranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" +\r\n\t\t\t\t\"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" +\r\n\t\t\t\t\"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" +\r\n\t\t\t\t\"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" +\r\n\t\t\t\t\"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\r\n\tassertEquals(4, ranges.length);\r\n\tassertEquals(53, ranges[0].from);\r\n\tassertEquals(59, ranges[0].to); \r\n\t\r\n\tassertEquals(190, ranges[1].from);\r\n\tassertEquals(196, ranges[1].to);\r\n\t\r\n\tassertEquals(210, ranges[2].from);\r\n\tassertEquals(226, ranges[2].to);\r\n\t\r\n\tassertEquals(305, ranges[3].from);\r\n\tassertEquals(313, ranges[3].to);\r\n\t//System.out.println(Arrays.toString(ranges));\r\n\t}\r\n}\r\n","changedTest":"package org.biojava3.ronn;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.ronn.Jronn.Range;\r\nimport org.junit.Test;\r\n\r\n\r\npublic class JronnTest {\r\n\r\n\t@Test\r\n\tpublic void verifyRanges() { \r\n  \r\n\tRange[]\tranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" +\r\n\t\t\t\t\"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" +\r\n\t\t\t\t\"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" +\r\n\t\t\t\t\"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" +\r\n\t\t\t\t\"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\r\n\tassertEquals(4, ranges.length);\r\n\tassertEquals(53, ranges[0].from);\r\n\tassertEquals(59, ranges[0].to); \r\n\t\r\n\tassertEquals(190, ranges[1].from);\r\n\tassertEquals(196, ranges[1].to);\r\n\t\r\n\tassertEquals(210, ranges[2].from);\r\n\tassertEquals(226, ranges[2].to);\r\n\t\r\n\tassertEquals(305, ranges[3].from);\r\n\tassertEquals(313, ranges[3].to);\r\n\t//System.out.println(Arrays.toString(ranges));\r\n\t}\r\n}\r\n","commitMessage":"Test cases/examples\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9047 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Rearrange resources to fit into maven model. Use standard maven jar plugin in favour of assembly plugin. \n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9065 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}