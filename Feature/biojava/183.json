{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SmithWaterman.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SmithWatermanTest.java","prod_time":"2015-01-26 18:26:26","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"de2015e2d47dcba45950e9495614bae1ffe8c0df","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 24, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport org.biojava3.alignment.template.AbstractPairwiseSequenceAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\nimport java.util.List;\n\n/**\n * Smith and Waterman defined an algorithm for pairwise local sequence alignments (best match of sections from each\n * {@link Sequence}).  This class performs such local sequence comparisons efficiently by dynamic programming.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} of the alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SmithWaterman<S extends Sequence<C>, C extends Compound> extends AbstractPairwiseSequenceAligner<S, C> {\n\n    /**\n     * Before running a pairwise local sequence alignment, data must be sent in via calls to\n     * {@link #setQuery(Sequence)}, {@link #setTarget(Sequence)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public SmithWaterman() {\n        super(null, null, null, null, AlignmentMode.LOCAL);\n    }\n\n    /**\n     * Prepares for a pairwise local sequence alignment.\n     *\n     * @param query the first {@link Sequence} of the pair to align\n     * @param target the second {@link Sequence} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SmithWaterman(S query, S target, GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix, AlignmentMode.LOCAL);\n    }\n\n    // method for AbstractMatrixAligner\n\n    @Override\n    protected void setProfile(List<Step> sx, List<Step> sy) {\n        profile = pair = new SimpleSequencePair<S, C>(getQuery(), getTarget(), sx, xyStart[0],\n                getQuery().getLength() - xyMax[0], sy, xyStart[1], getTarget().getLength() - xyMax[1]);\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 24, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AbstractPairwiseSequenceAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Smith and Waterman defined an algorithm for pairwise local sequence alignments (best match of sections from each\n * {@link Sequence}).  This class performs such local sequence comparisons efficiently by dynamic programming.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} of the alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SmithWaterman<S extends Sequence<C>, C extends Compound> extends AbstractPairwiseSequenceAligner<S, C> {\n\n    /**\n     * Before running a pairwise local sequence alignment, data must be sent in via calls to\n     * {@link #setQuery(Sequence)}, {@link #setTarget(Sequence)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public SmithWaterman() {\n        super(null, null, null, null, true);\n    }\n\n    /**\n     * Prepares for a pairwise local sequence alignment.\n     *\n     * @param query the first {@link Sequence} of the pair to align\n     * @param target the second {@link Sequence} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SmithWaterman(S query, S target, GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix, true);\n    }\n\n    // method for AbstractMatrixAligner\n\n    @Override\n    protected void setProfile(List<Step> sx, List<Step> sy) {\n        profile = pair = new SimpleSequencePair<S, C>(getQuery(), getTarget(), sx, xyStart[0],\n                getQuery().getLength() - xyMax[0], sy, xyStart[1], getTarget().getLength() - xyMax[1]);\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 29, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class SmithWatermanTest {\n\n\tprivate static final double PRECISION = 0.00000001;\n\t\n    private ProteinSequence query, target;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private SmithWaterman<ProteinSequence, AminoAcidCompound> alignment, self;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        query = new ProteinSequence(\"AERNDKK\");\n        target = new ProteinSequence(\"ERDNKGFPS\");\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        alignment = new SmithWaterman<ProteinSequence, AminoAcidCompound>(query, target, gaps, blosum62);\n        self = new SmithWaterman<ProteinSequence, AminoAcidCompound>(query, query, gaps, blosum62);\n    }\n\n    @Test\n    public void testSmithWaterman() {\n        SmithWaterman<ProteinSequence, AminoAcidCompound> alig =\n                new SmithWaterman<ProteinSequence, AminoAcidCompound>();\n        alig.setQuery(query);\n        alig.setTarget(target);\n        alig.setGapPenalty(gaps);\n        alig.setSubstitutionMatrix(blosum62);\n        assertEquals(alig.getPair().toString(), String.format(\"ERNDKK%nER-DNK%n\"));\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(alignment.getQuery(), query);\n        assertEquals(self.getQuery(), query);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(alignment.getTarget(), target);\n        assertEquals(self.getTarget(), query);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(alignment.getGapPenalty(), gaps);\n        assertEquals(self.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(alignment.getSubstitutionMatrix(), blosum62);\n        assertEquals(self.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(alignment.isStoringScoreMatrix());\n        assertFalse(self.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testSetStoringScoreMatrix() {\n        assertFalse(alignment.isStoringScoreMatrix());\n        alignment.setStoringScoreMatrix(true);\n        assertTrue(alignment.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        int[][][] scores = alignment.getScoreMatrix();\n        assertEquals(scores[2][2][2], 2);\n        assertEquals(scores[4][3][0], 11);\n        scores = self.getScoreMatrix();\n        assertEquals(scores[2][2][0], 9);\n        assertEquals(scores[4][3][1], 11);\n    }\n\n    @Test\n    public void testGetScoreMatrixAsString() {\n        assertEquals(alignment.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"      E  R  D  N  K  G  F  P  S%n\" +\n                \"   0  0  0  0  0  0  0  0  0  0%n\" +\n                \"A  0  0  0  0  0  0  0  0  0  1%n\" +\n                \"E  0  5  0  2  0  1  0  0  0  0%n\" +\n                \"R  0  0 10  0  2  2  0  0  0  0%n\" +\n                \"N  0  0  2 11 13  6  5  1  1  3%n\" +\n                \"D  0  2  0 13 12 12  9  6  7  7%n\" +\n                \"K  0  1  4  5 13 17 10  6  7  7%n\" +\n                \"K  0  1  3  4 10 18 15 11 12 12%n\" +\n                \"%nDeletion%n\" +\n                \"      E  R  D  N  K  G  F  P  S%n\" +\n                \"   0  0  0  0  0  0  0  0  0  0%n\" +\n                \"A  0  0  0  0  0  0  0  0  0  0%n\" +\n                \"E  0  0  0  0  0  0  0  0  0  0%n\" +\n                \"R  0  2  0  0  0  0  0  0  0  0%n\" +\n                \"N  0  1  7  0  0  0  0  0  0  0%n\" +\n                \"D  0  0  6  8 10  3  2  0  0  0%n\" +\n                \"K  0  0  5 10  9  9  6  3  4  4%n\" +\n                \"K  0  0  4  9 10 14  7  3  4  4%n\" +\n                \"%nInsertion%n\" +\n                \"      E  R  D  N  K  G  F  P  S%n\" +\n                \"   0  0  0  0  0  0  0  0  0  0%n\" +\n                \"A  0  0  0  0  0  0  0  0  0  0%n\" +\n                \"E  0  0  2  1  0  0  0  0  0  0%n\" +\n                \"R  0  0  0  7  6  5  4  3  2  1%n\" +\n                \"N  0  0  0  0  8 10  9  8  7  6%n\" +\n                \"D  0  0  0  0 10  9  9  8  7  6%n\" +\n                \"K  0  0  0  1  2 10 14 13 12 11%n\" +\n                \"K  0  0  0  0  1  7 15 14 13 12%n\"));\n        assertEquals(self.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"      A  E  R  N  D  K  K%n\" +\n                \"   0  0  0  0  0  0  0  0%n\" +\n                \"A  0  4  0  0  0  0  0  0%n\" +\n                \"E  0  0  9  1  0  2  1  1%n\" +\n                \"R  0  0  1 14  6  3  6  5%n\" +\n                \"N  0  0  0  6 20 12 10  9%n\" +\n                \"D  0  0  2  3 12 26 16 15%n\" +\n                \"K  0  0  1  6 10 16 31 28%n\" +\n                \"K  0  0  1  5  9 15 28 36%n\" +\n                \"%nDeletion%n\" +\n                \"      A  E  R  N  D  K  K%n\" +\n                \"   0  0  0  0  0  0  0  0%n\" +\n                \"A  0  0  0  0  0  0  0  0%n\" +\n                \"E  0  1  0  0  0  0  0  0%n\" +\n                \"R  0  0  6  0  0  0  0  0%n\" +\n                \"N  0  0  5 11  3  0  3  2%n\" +\n                \"D  0  0  4 10 17  9  7  6%n\" +\n                \"K  0  0  3  9 16 23 13 12%n\" +\n                \"K  0  0  2  8 15 22 28 25%n\" +\n                \"%nInsertion%n\" +\n                \"      A  E  R  N  D  K  K%n\" +\n                \"   0  0  0  0  0  0  0  0%n\" +\n                \"A  0  0  1  0  0  0  0  0%n\" +\n                \"E  0  0  0  6  5  4  3  2%n\" +\n                \"R  0  0  0  0 11 10  9  8%n\" +\n                \"N  0  0  0  0  3 17 16 15%n\" +\n                \"D  0  0  0  0  0  9 23 22%n\" +\n                \"K  0  0  0  0  3  7 13 28%n\" +\n                \"K  0  0  0  0  2  6 12 25%n\"));\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(alignment.getComputationTime() > 0);\n        assertTrue(self.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(alignment.getProfile().toString(), String.format(\"ERNDKK%nER-DNK%n\"));\n        assertEquals(self.getProfile().toString(), String.format(\"AERNDKK%nAERNDKK%n\"));\n    }\n\n    @Test\n    public void testGetMaxScore() {\n        assertEquals(alignment.getMaxScore(), 50, PRECISION);\n        assertEquals(self.getMaxScore(), 36, PRECISION);\n    }\n\n    @Test\n    public void testGetMinScore() {\n        assertEquals(alignment.getMinScore(), 0, PRECISION);\n        assertEquals(self.getMinScore(), 0, PRECISION);\n    }\n\n    @Test\n    public void testGetScore() {\n        assertEquals(alignment.getScore(), 18, PRECISION);\n        assertEquals(self.getScore(), 36, PRECISION);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(alignment.getPair().toString(), String.format(\"ERNDKK%nER-DNK%n\"));\n        assertEquals(self.getPair().toString(), String.format(\"AERNDKK%nAERNDKK%n\"));\n    }\n\n}\n","changedTest":"","commitMessage":"Revert \"Start of implementation to semiglobal alignment. (Any complaints/suggestions so far?)\"\n\nThis reverts commit 91fbc0189287e023841555e787e08d2552116262.\n\nIt broke the build and there is an unresolved discussion on github.\nPlease resubmit as a pull request.\n","test_commitMessage":"","allZero":false}