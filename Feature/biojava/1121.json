{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/ProteinSequence.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/ProteinSequenceTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.*;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.io.DNASequenceCreator;\nimport org.biojava.nbio.core.sequence.io.FastaReader;\nimport org.biojava.nbio.core.sequence.io.PlainFastaHeaderParser;\nimport org.biojava.nbio.core.sequence.location.InsdcParser;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.ProxySequenceReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\n\n/**\n * The representation of a ProteinSequence\n *\n * @author Scooter Willis\n * @author Paolo Pavan\n */\npublic class ProteinSequence extends AbstractSequence<AminoAcidCompound> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(ProteinSequence.class);\n\n\t/*\n\t private ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>> features\n\t = new ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>();\n\t private LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>> groupedFeatures\n\t = new LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>>();\n\t */\n\t/**\n\t * Create a protein from a string\n\t *\n\t * @param seqString\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ProteinSequence(String seqString) throws CompoundNotFoundException {\n\t\tthis(seqString, AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t}\n\n\t/**\n\t * Create a protein from a string with a user defined set of amino acids\n\t *\n\t * @param seqString\n\t * @param compoundSet\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ProteinSequence(String seqString, CompoundSet<AminoAcidCompound> compoundSet) throws CompoundNotFoundException {\n\t\tsuper(seqString, compoundSet);\n\t}\n\n\t/**\n\t * A protein sequence where the storage of the sequence is somewhere else.\n\t * Could be loaded from a large Fasta file or via a Uniprot Proxy reader via\n\t * Uniprot ID\n\t *\n\t * @param proxyLoader\n\t */\n\tpublic ProteinSequence(ProxySequenceReader<AminoAcidCompound> proxyLoader) {\n\t\tthis(proxyLoader, AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t}\n\n\t/**\n\t * A protein sequence where the storage of the sequence is somewhere else\n\t * with user defined set of amino acids. Could be loaded from a large Fasta\n\t * file or via a Uniprot Proxy reader via Uniprot ID\n\t *\n\t * @param proxyLoader\n\t * @param compoundSet\n\t */\n\tpublic ProteinSequence(ProxySequenceReader<AminoAcidCompound> proxyLoader, CompoundSet<AminoAcidCompound> compoundSet) {\n\t\tsuper(proxyLoader, compoundSet);\n\n\t\t// do protein-specific tasks\n\t\t// add source if found\n\t\tList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>> CDSFeatures = getFeaturesByType(\"CDS\");\n\n\t\t// cases if a protein has more than 1 parent are not supported yet\n\t\tif (CDSFeatures.size() == 1) {\n\t\t\tQualifier codedBy = CDSFeatures.get(0).getQualifiers().get(\"coded_by\").get(0);\n\n\t\t\tif (codedBy != null) {\n\t\t\t\tString codedBySeq = codedBy.getValue();\n\n\t\t\t\tInsdcParser parser = new InsdcParser(DataSource.GENBANK);\n\t\t\t\tLocation location = parser.parse(codedBySeq);\n\n\t\t\t\ttry {\n\t\t\t\t\tDNASequence dnaSeq = new DNASequence(getSequence(location), DNACompoundSet.getDNACompoundSet());\n\t\t\t\t\tsetParentDNASequence(dnaSeq, location.getStart().getPosition(), location.getEnd().getPosition());\n\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t// TODO is there another solution to handle this exception?\n\t\t\t\t\tlogger.error(\"Could not add 'coded_by' parent DNA location feature, unrecognised compounds found in DNA sequence: {}\", e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * A Protein sequence can be stand alone or loaded from a transcript\n\t * sequence. The design goal is to allow the creation of a Protein sequence\n\t * from a Uniprot ID or some other Protein ID that based on cross reference\n\t * you should be able to get the GeneSequence that codes for the protein if\n\t * the CDS/Gene region is known. From the GeneSequence you should then be\n\t * able to get the ChromosomeSequence which then allows you explore flaning\n\t * regions of the gene sequences. The framework is in place to do this but\n\t * currently hasn't been implement in the reverse direction starting from\n\t * the Protein sequence.\n\t *\n\t * @param parentDNASequence\n\t * @param begin\n\t * @param end\n\t */\n\t//TODO - Someone needs to check if this is a bug.  Shouldn't a parentDNASequence be something other then AminoAcid?\n\t//However, due to the derivation of this class, this is the only possible type argument for this parameter...\n\tpublic void setParentDNASequence(AbstractSequence<NucleotideCompound> parentDNASequence, Integer begin, Integer end) {\n\t\tthis.setParentSequence(parentDNASequence);\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t}\n\n\tprivate DNASequence getRawParentSequence(String accessId) throws IOException {\n\t\tString seqUrlTemplate = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=%s&rettype=fasta&retmode=text\";\n\t\tURL url = new URL(String.format(seqUrlTemplate, accessId));\n\n\t\tlogger.trace(\"Getting parent DNA sequence from URL: {}\", url.toString());\n\n\t\tInputStream is = url.openConnection().getInputStream();\n\n\t\tFastaReader<DNASequence, NucleotideCompound> parentReader\n\t\t\t\t= new FastaReader<DNASequence, NucleotideCompound>(is,\n\t\t\t\t\t\tnew PlainFastaHeaderParser<DNASequence, NucleotideCompound>(),\n\t\t\t\t\t\tnew DNASequenceCreator(AmbiguityDNACompoundSet.getDNACompoundSet()));\n\t\tLinkedHashMap<String, DNASequence> seq = parentReader.process();\n\n\t\tDNASequence parentSeq = null;\n\t\tif (seq.size() == 1) {\n\t\t\tparentSeq = seq.values().iterator().next();\n\t\t}\n\t\tis.close();\n\n\t\treturn parentSeq;\n\t}\n\n\tprivate String getSequence(Location cdna) {\n\t\tDNASequence rawParent;\n\t\tif (!cdna.isComplex()) {\n\t\t\ttry {\n\t\t\t\trawParent = getRawParentSequence(cdna.getAccession().getID());\n\t\t\t\treturn cdna.getSubSequence(rawParent).getSequenceAsString();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// return null\n\t\t\t\tlogger.error(\"Caught IOException when getting DNA sequence for id {}. Error: {}\", cdna.getAccession().getID(), e.getMessage());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\t// in case of complex\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tfor (Location sub : cdna.getSubLocations()) {\n\t\t\t\tString sebStr = getSequence(sub);\n\t\t\t\tsb.append((sebStr == null ? \"\" : sebStr));\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.*;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.io.DNASequenceCreator;\nimport org.biojava.nbio.core.sequence.io.FastaReader;\nimport org.biojava.nbio.core.sequence.io.PlainFastaHeaderParser;\nimport org.biojava.nbio.core.sequence.location.InsdcParser;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.ProxySequenceReader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\n\n/**\n * The representation of a ProteinSequence\n *\n * @author Scooter Willis\n * @author Paolo Pavan\n */\npublic class ProteinSequence extends AbstractSequence<AminoAcidCompound> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(ProteinSequence.class);\n\n\t/*\n\t private ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>> features\n\t = new ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>();\n\t private LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>> groupedFeatures\n\t = new LinkedHashMap<String, ArrayList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>>>();\n\t */\n\t/**\n\t * Create a protein from a string\n\t *\n\t * @param seqString\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ProteinSequence(String seqString) throws CompoundNotFoundException {\n\t\tthis(seqString, AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t}\n\n\t/**\n\t * Create a protein from a string with a user defined set of amino acids\n\t *\n\t * @param seqString\n\t * @param compoundSet\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ProteinSequence(String seqString, CompoundSet<AminoAcidCompound> compoundSet) throws CompoundNotFoundException {\n\t\tsuper(seqString, compoundSet);\n\t}\n\n\t/**\n\t * A protein sequence where the storage of the sequence is somewhere else.\n\t * Could be loaded from a large Fasta file or via a Uniprot Proxy reader via\n\t * Uniprot ID\n\t *\n\t * @param proxyLoader\n\t */\n\tpublic ProteinSequence(ProxySequenceReader<AminoAcidCompound> proxyLoader) {\n\t\tthis(proxyLoader, AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t}\n\n\t/**\n\t * A protein sequence where the storage of the sequence is somewhere else\n\t * with user defined set of amino acids. Could be loaded from a large Fasta\n\t * file or via a Uniprot Proxy reader via Uniprot ID\n\t *\n\t * @param proxyLoader\n\t * @param compoundSet\n\t */\n\tpublic ProteinSequence(ProxySequenceReader<AminoAcidCompound> proxyLoader, CompoundSet<AminoAcidCompound> compoundSet) {\n\t\tsuper(proxyLoader, compoundSet);\n\n\t\t// do protein-specific tasks\n\t\t// add source if found\n\t\tList<FeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound>> CDSFeatures = getFeaturesByType(\"CDS\");\n\n\t\t// cases if a protein has more than 1 parent are not supported yet\n\t\tif (CDSFeatures.size() == 1) {\n\t\t\tQualifier codedBy = CDSFeatures.get(0).getQualifiers().get(\"coded_by\").get(0);\n\n\t\t\tif (codedBy != null) {\n\t\t\t\tString codedBySeq = codedBy.getValue();\n\n\t\t\t\tInsdcParser parser = new InsdcParser(DataSource.GENBANK);\n\t\t\t\tLocation location = parser.parse(codedBySeq);\n\n\t\t\t\ttry {\n\t\t\t\t\tDNASequence dnaSeq = new DNASequence(getSequence(location), DNACompoundSet.getDNACompoundSet());\n\t\t\t\t\tsetParentDNASequence(dnaSeq, location.getStart().getPosition(), location.getEnd().getPosition());\n\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t// TODO is there another solution to handle this exception?\n\t\t\t\t\tlogger.error(\"Could not add 'coded_by' parent DNA location feature, unrecognised compounds found in DNA sequence: {}\", e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * A Protein sequence can be stand alone or loaded from a transcript\n\t * sequence. The design goal is to allow the creation of a Protein sequence\n\t * from a Uniprot ID or some other Protein ID that based on cross reference\n\t * you should be able to get the GeneSequence that codes for the protein if\n\t * the CDS/Gene region is known. From the GeneSequence you should then be\n\t * able to get the ChromosomeSequence which then allows you explore flaning\n\t * regions of the gene sequences. The framework is in place to do this but\n\t * currently hasn't been implement in the reverse direction starting from\n\t * the Protein sequence.\n\t *\n\t * @param parentDNASequence\n\t * @param begin\n\t * @param end\n\t */\n\t//TODO - Someone needs to check if this is a bug.  Shouldn't a parentDNASequence be something other then AminoAcid?\n\t//However, due to the derivation of this class, this is the only possible type argument for this parameter...\n\tpublic void setParentDNASequence(AbstractSequence<NucleotideCompound> parentDNASequence, Integer begin, Integer end) {\n\t\tthis.setParentSequence(parentDNASequence);\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t}\n\n\tprivate DNASequence getRawParentSequence(String accessId) throws IOException {\n\t\tString seqUrlTemplate = \"https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&id=%s&rettype=fasta&retmode=text\";\n\t\tURL url = new URL(String.format(seqUrlTemplate, accessId));\n\n\t\tlogger.trace(\"Getting parent DNA sequence from URL: {}\", url.toString());\n\n\t\tInputStream is = url.openConnection().getInputStream();\n\n\t\tFastaReader<DNASequence, NucleotideCompound> parentReader\n\t\t\t\t= new FastaReader<>(is,\n\t\t\t\t\t\tnew PlainFastaHeaderParser<DNASequence, NucleotideCompound>(),\n\t\t\t\t\t\tnew DNASequenceCreator(AmbiguityDNACompoundSet.getDNACompoundSet()));\n\t\tLinkedHashMap<String, DNASequence> seq = parentReader.process();\n\n\t\tDNASequence parentSeq = null;\n\t\tif (seq.size() == 1) {\n\t\t\tparentSeq = seq.values().iterator().next();\n\t\t}\n\t\tis.close();\n\n\t\treturn parentSeq;\n\t}\n\n\tprivate String getSequence(Location cdna) {\n\t\tDNASequence rawParent;\n\t\tif (!cdna.isComplex()) {\n\t\t\ttry {\n\t\t\t\trawParent = getRawParentSequence(cdna.getAccession().getID());\n\t\t\t\treturn cdna.getSubSequence(rawParent).getSequenceAsString();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// return null\n\t\t\t\tlogger.error(\"Caught IOException when getting DNA sequence for id {}. Error: {}\", cdna.getAccession().getID(), e.getMessage());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} else {\n\t\t\t// in case of complex\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tfor (Location sub : cdna.getSubLocations()) {\n\t\t\t\tString sebStr = getSequence(sub);\n\t\t\t\tsb.append((sebStr == null ? \"\" : sebStr));\n\t\t\t}\n\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.loader.StringProxySequenceReader;\nimport org.junit.jupiter.api.Test;\n\npublic class ProteinSequenceTest {\n\n    @Test\n    void basicTest() throws Exception {\n        ProteinSequence proteinSequence = new ProteinSequence(\"ARNDCEQGHILKMFPSTWYVBZJX\");\n        assertNotNull(proteinSequence.toString());\n        assertEquals(24, proteinSequence.getLength());\n\n        StringProxySequenceReader<AminoAcidCompound> sequenceStringProxyLoader = new StringProxySequenceReader<AminoAcidCompound>(\n                \"XRNDCEQGHILKMFPSTWYVBZJA\", AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        ProteinSequence proteinSequenceFromProxy = new ProteinSequence(sequenceStringProxyLoader);\n        assertNotNull(proteinSequenceFromProxy.toString());\n        assertEquals(24, proteinSequence.getLength());\n    }\n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":true}