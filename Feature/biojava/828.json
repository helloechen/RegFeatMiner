{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/Calc.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestCalc.java","prod_time":"2017-12-08 09:16:09","test_time":"2017-12-08 09:16:09","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":8,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":10,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"3a1ad26c6d0df71508e58a52a114978b940b9022","test_commitID":"3a1ad26c6d0df71508e58a52a114978b940b9022","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 08.05.2004\n *\n */\npackage org.biojava.nbio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.geometry.CalcPoint;\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.geometry.SuperPositionSVD;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility operations on Atoms, AminoAcids, Matrices, Point3d, etc.\n * <p>\n * Currently the coordinates of an Atom are stored as an array of size 3\n * (double[3]). It would be more powerful to use Point3d from javax.vecmath.\n * Overloaded methods for Point3d operations exist in the {@link CalcPoint}\n * Class.\n *\n * @author Andreas Prlic\n * @author Aleix Lafita\n * @since 1.4\n * @version %I% %G%\n */\n\npublic class Calc {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(Calc.class);\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static final double getDistance(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s = x * x + y * y + z * z;\n\n\t\treturn Math.sqrt(s);\n\t}\n\n\t/**\n\t * Will calculate the square of distances between two atoms. This will be\n\t * faster as it will not perform the final square root to get the actual\n\t * distance. Use this if doing large numbers of distance comparisons - it is\n\t * marginally faster than getDistance().\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static double getDistanceFast(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\treturn x * x + y * y + z * z;\n\t}\n\n\tpublic static final Atom invert(Atom a) {\n\t\tdouble[] coords = new double[] { 0.0, 0.0, 0.0 };\n\t\tAtom zero = new AtomImpl();\n\t\tzero.setCoords(coords);\n\t\treturn subtract(zero, a);\n\t}\n\n\t/**\n\t * add two atoms ( a + b).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom add(Atom a, Atom b) {\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getX() + b.getX());\n\t\tc.setY(a.getY() + b.getY());\n\t\tc.setZ(a.getZ() + b.getZ());\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * subtract two atoms ( a - b).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return n new Atom object representing the difference\n\t */\n\tpublic static final Atom subtract(Atom a, Atom b) {\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getX() - b.getX());\n\t\tc.setY(a.getY() - b.getY());\n\t\tc.setZ(a.getZ() - b.getZ());\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Vector product (cross product).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom vectorProduct(Atom a, Atom b) {\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getY() * b.getZ() - a.getZ() * b.getY());\n\t\tc.setY(a.getZ() * b.getX() - a.getX() * b.getZ());\n\t\tc.setZ(a.getX() * b.getY() - a.getY() * b.getX());\n\t\treturn c;\n\n\t}\n\n\t/**\n\t * Scalar product (dot product).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static final double scalarProduct(Atom a, Atom b) {\n\t\treturn a.getX() * b.getX() + a.getY() * b.getY() + a.getZ() * b.getZ();\n\t}\n\n\t/**\n\t * Gets the length of the vector (2-norm)\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @return Square root of the sum of the squared elements\n\t */\n\tpublic static final double amount(Atom a) {\n\t\treturn Math.sqrt(scalarProduct(a, a));\n\t}\n\n\t/**\n\t * Gets the angle between two vectors\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return Angle between a and b in degrees, in range [0,180]. If either\n\t *         vector has length 0 then angle is not defined and NaN is returned\n\t */\n\tpublic static final double angle(Atom a, Atom b) {\n\n\t\tVector3d va = new Vector3d(a.getCoordsAsPoint3d());\n\t\tVector3d vb = new Vector3d(b.getCoordsAsPoint3d());\n\n\t\treturn Math.toDegrees(va.angle(vb));\n\n\t}\n\n\t/**\n\t * Returns the unit vector of vector a .\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom unitVector(Atom a) {\n\t\tdouble amount = amount(a);\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = a.getX() / amount;\n\t\tcoords[1] = a.getY() / amount;\n\t\tcoords[2] = a.getZ() / amount;\n\n\t\ta.setCoords(coords);\n\t\treturn a;\n\n\t}\n\n\t/**\n\t * Calculate the torsion angle, i.e. the angle between the normal vectors of\n\t * the two plains a-b-c and b-c-d. See\n\t * http://en.wikipedia.org/wiki/Dihedral_angle\n\t * \n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @param c\n\t *            an Atom object\n\t * @param d\n\t *            an Atom object\n\t * @return the torsion angle in degrees, in range +-[0,180]. If either first\n\t *         3 or last 3 atoms are colinear then torsion angle is not defined\n\t *         and NaN is returned\n\t */\n\tpublic static final double torsionAngle(Atom a, Atom b, Atom c, Atom d) {\n\n\t\tAtom ab = subtract(a, b);\n\t\tAtom cb = subtract(c, b);\n\t\tAtom bc = subtract(b, c);\n\t\tAtom dc = subtract(d, c);\n\n\t\tAtom abc = vectorProduct(ab, cb);\n\t\tAtom bcd = vectorProduct(bc, dc);\n\n\t\tdouble angl = angle(abc, bcd);\n\n\t\t/* calc the sign: */\n\t\tAtom vecprod = vectorProduct(abc, bcd);\n\t\tdouble val = scalarProduct(cb, vecprod);\n\t\tif (val < 0.0)\n\t\t\tangl = -angl;\n\n\t\treturn angl;\n\t}\n\n\t/**\n\t * Calculate the phi angle.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return a double\n\t * @throws StructureException\n\t *             if aminoacids not connected or if any of the 4 needed atoms\n\t *             missing\n\t */\n\tpublic static final double getPhi(AminoAcid a, AminoAcid b)\n\t\t\tthrows StructureException {\n\n\t\tif (!isConnected(a, b)) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"can not calc Phi - AminoAcids are not connected!\");\n\t\t}\n\n\t\tAtom a_C = a.getC();\n\t\tAtom b_N = b.getN();\n\t\tAtom b_CA = b.getCA();\n\t\tAtom b_C = b.getC();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (b_CA == null)\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"Can not calculate Phi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_C, b_N, b_CA, b_C);\n\t}\n\n\t/**\n\t * Calculate the psi angle.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return a double\n\t * @throws StructureException\n\t *             if aminoacids not connected or if any of the 4 needed atoms\n\t *             missing\n\t */\n\tpublic static final double getPsi(AminoAcid a, AminoAcid b)\n\t\t\tthrows StructureException {\n\t\tif (!isConnected(a, b)) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"can not calc Psi - AminoAcids are not connected!\");\n\t\t}\n\n\t\tAtom a_N = a.getN();\n\t\tAtom a_CA = a.getCA();\n\t\tAtom a_C = a.getC();\n\t\tAtom b_N = b.getN();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (a_CA == null)\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"Can not calculate Psi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_N, a_CA, a_C, b_N);\n\n\t}\n\n\t/**\n\t * Test if two amino acids are connected, i.e. if the distance from C to N <\n\t * 2.5 Angstrom.\n\t *\n\t * If one of the AminoAcids has an atom missing, returns false.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return true if ...\n\t */\n\tpublic static final boolean isConnected(AminoAcid a, AminoAcid b) {\n\t\tAtom C = null;\n\t\tAtom N = null;\n\n\t\tC = a.getC();\n\t\tN = b.getN();\n\n\t\tif (C == null || N == null)\n\t\t\treturn false;\n\n\t\t// one could also check if the CA atoms are < 4 A...\n\t\tdouble distance = getDistance(C, N);\n\t\treturn distance < 2.5;\n\t}\n\n\t/**\n\t * Rotate a single Atom aroud a rotation matrix. The rotation Matrix must be\n\t * a pre-multiplication 3x3 Matrix.\n\t *\n\t * If the matrix is indexed m[row][col], then the matrix will be\n\t * pre-multiplied (y=atom*M)\n\t * \n\t * @param atom\n\t *            atom to be rotated\n\t * @param m\n\t *            a rotation matrix represented as a double[3][3] array\n\t */\n\tpublic static final void rotate(Atom atom, double[][] m) {\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY();\n\t\tdouble z = atom.getZ();\n\n\t\tdouble nx = m[0][0] * x + m[0][1] * y + m[0][2] * z;\n\t\tdouble ny = m[1][0] * x + m[1][1] * y + m[1][2] * z;\n\t\tdouble nz = m[2][0] * x + m[2][1] * y + m[2][2] * z;\n\n\t\tatom.setX(nx);\n\t\tatom.setY(ny);\n\t\tatom.setZ(nz);\n\t}\n\n\t/**\n\t * Rotate a structure. The rotation Matrix must be a pre-multiplication\n\t * Matrix.\n\t *\n\t * @param structure\n\t *            a Structure object\n\t * @param rotationmatrix\n\t *            an array (3x3) of double representing the rotation matrix.\n\t * @throws StructureException\n\t *             ...\n\t */\n\tpublic static final void rotate(Structure structure,\n\t\t\tdouble[][] rotationmatrix) throws StructureException {\n\n\t\tif (rotationmatrix.length != 3) {\n\t\t\tthrow new StructureException(\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(structure);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\tCalc.rotate(atom, rotationmatrix);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate a Group. The rotation Matrix must be a pre-multiplication Matrix.\n\t *\n\t * @param group\n\t *            a group object\n\t * @param rotationmatrix\n\t *            an array (3x3) of double representing the rotation matrix.\n\t * @throws StructureException\n\t *             ...\n\t */\n\tpublic static final void rotate(Group group, double[][] rotationmatrix)\n\t\t\tthrows StructureException {\n\n\t\tif (rotationmatrix.length != 3) {\n\t\t\tthrow new StructureException(\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(group);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\t\t\trotate(atom, rotationmatrix);\n\n\t\t}\n\t}\n\n\t/**\n\t * Rotate an Atom around a Matrix object. The rotation Matrix must be a\n\t * pre-multiplication Matrix.\n\t *\n\t * @param atom\n\t *            atom to be rotated\n\t * @param m\n\t *            rotation matrix to be applied to the atom\n\t */\n\tpublic static final void rotate(Atom atom, Matrix m) {\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY();\n\t\tdouble z = atom.getZ();\n\t\tdouble[][] ad = new double[][] { { x, y, z } };\n\n\t\tMatrix am = new Matrix(ad);\n\t\tMatrix na = am.times(m);\n\n\t\tatom.setX(na.get(0, 0));\n\t\tatom.setY(na.get(0, 1));\n\t\tatom.setZ(na.get(0, 2));\n\n\t}\n\n\t/**\n\t * Rotate a group object. The rotation Matrix must be a pre-multiplication\n\t * Matrix.\n\t *\n\t * @param group\n\t *            a group to be rotated\n\t * @param m\n\t *            a Matrix object representing the rotation matrix\n\t */\n\tpublic static final void rotate(Group group, Matrix m) {\n\n\t\tAtomIterator iter = new AtomIterator(group);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\trotate(atom, m);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotate a structure object. The rotation Matrix must be a\n\t * pre-multiplication Matrix.\n\t *\n\t * @param structure\n\t *            the structure to be rotated\n\t * @param m\n\t *            rotation matrix to be applied\n\t */\n\tpublic static final void rotate(Structure structure, Matrix m) {\n\n\t\tAtomIterator iter = new AtomIterator(structure);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\trotate(atom, m);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Transform an array of atoms at once. The transformation Matrix must be a\n\t * post-multiplication Matrix.\n\t *\n\t * @param ca\n\t *            array of Atoms to shift\n\t * @param t\n\t *            transformation Matrix4d\n\t */\n\tpublic static void transform(Atom[] ca, Matrix4d t) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.transform(atom, t);\n\t}\n\n\t/**\n\t * Transforms an atom object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param atom\n\t * @param m\n\t */\n\tpublic static final void transform(Atom atom, Matrix4d m) {\n\n\t\tPoint3d p = new Point3d(atom.getX(), atom.getY(), atom.getZ());\n\t\tm.transform(p);\n\n\t\tatom.setX(p.x);\n\t\tatom.setY(p.y);\n\t\tatom.setZ(p.z);\n\t}\n\n\t/**\n\t * Transforms a group object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param group\n\t * @param m\n\t */\n\tpublic static final void transform(Group group, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(group);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttransform(atom, m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a structure object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param structure\n\t * @param m\n\t */\n\tpublic static final void transform(Structure structure, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(structure);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttransform(atom, m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a chain object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param chain\n\t * @param m\n\t */\n\tpublic static final void transform(Chain chain, Matrix4d m) {\n\n\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\tfor (Atom atom : g.getAtoms()) {\n\t\t\t\ttransform(atom, m);\n\t\t\t}\n\t\t\tfor (Group altG : g.getAltLocs()) {\n\t\t\t\tfor (Atom atom : altG.getAtoms()) {\n\t\t\t\t\ttransform(atom, m);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates an atom object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param atom\n\t * @param v\n\t */\n\tpublic static final void translate(Atom atom, Vector3d v) {\n\n\t\tatom.setX(atom.getX() + v.x);\n\t\tatom.setY(atom.getY() + v.y);\n\t\tatom.setZ(atom.getZ() + v.z);\n\t}\n\n\t/**\n\t * Translates a group object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param group\n\t * @param v\n\t */\n\tpublic static final void translate(Group group, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(group);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttranslate(atom, v);\n\n\t\t}\n\t}\n\n\t/**\n\t * Translates a chain object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param chain\n\t * @param v\n\t */\n\tpublic static final void translate(Chain chain, Vector3d v) {\n\n\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\tfor (Atom atom : g.getAtoms()) {\n\t\t\t\ttranslate(atom, v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates a Structure object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param structure\n\t * @param v\n\t */\n\tpublic static final void translate(Structure structure, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(structure);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttranslate(atom, v);\n\n\t\t}\n\t}\n\n\t/**\n\t * calculate structure + Matrix coodinates ...\n\t *\n\t * @param s\n\t *            the structure to operate on\n\t * @param matrix\n\t *            a Matrix object\n\t */\n\tpublic static final void plus(Structure s, Matrix matrix) {\n\t\tAtomIterator iter = new AtomIterator(s);\n\t\tAtom oldAtom = null;\n\t\tAtom rotOldAtom = null;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\t\t\ttry {\n\t\t\t\tif (oldAtom != null) {\n\t\t\t\t\tlogger.debug(\"before {}\", getDistance(oldAtom, atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\toldAtom = (Atom) atom.clone();\n\n\t\t\tdouble x = atom.getX();\n\t\t\tdouble y = atom.getY();\n\t\t\tdouble z = atom.getZ();\n\t\t\tdouble[][] ad = new double[][] { { x, y, z } };\n\n\t\t\tMatrix am = new Matrix(ad);\n\t\t\tMatrix na = am.plus(matrix);\n\n\t\t\tdouble[] coords = new double[3];\n\t\t\tcoords[0] = na.get(0, 0);\n\t\t\tcoords[1] = na.get(0, 1);\n\t\t\tcoords[2] = na.get(0, 2);\n\t\t\tatom.setCoords(coords);\n\t\t\ttry {\n\t\t\t\tif (rotOldAtom != null) {\n\t\t\t\t\tlogger.debug(\"after {}\", getDistance(rotOldAtom, atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\trotOldAtom = (Atom) atom.clone();\n\t\t}\n\n\t}\n\n\t/**\n\t * shift a structure with a vector.\n\t *\n\t * @param structure\n\t *            a Structure object\n\t * @param a\n\t *            an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Structure structure, Atom a) {\n\n\t\tAtomIterator iter = new AtomIterator(structure);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\n\t\t\tAtom natom = add(atom, a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY();\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/**\n\t * Shift a vector.\n\t *\n\t * @param a\n\t *            vector a\n\t * @param b\n\t *            vector b\n\t */\n\tpublic static final void shift(Atom a, Atom b) {\n\n\t\tAtom natom = add(a, b);\n\t\tdouble x = natom.getX();\n\t\tdouble y = natom.getY();\n\t\tdouble z = natom.getZ();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t}\n\n\t/**\n\t * Shift a Group with a vector.\n\t *\n\t * @param group\n\t *            a group object\n\t * @param a\n\t *            an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Group group, Atom a) {\n\n\t\tAtomIterator iter = new AtomIterator(group);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\n\t\t\tAtom natom = add(atom, a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY();\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/**\n\t * Returns the centroid of the set of atoms.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t */\n\tpublic static final Atom getCentroid(Atom[] atomSet) {\n\t\t\n\t\t// if we don't catch this case, the centroid returned is (NaN,NaN,NaN), which can cause lots of problems down the line\n\t\tif (atomSet.length==0) \n\t\t\tthrow new IllegalArgumentException(\"Atom array has length 0, can't calculate centroid!\");\n\n\t\t// if we don't catch this case, the centroid returned is (NaN,NaN,NaN), which can cause lots of problems down the line\n\t\tif (atomSet.length==0) \n\t\t\tthrow new IllegalArgumentException(\"Atom array has length 0, can't calculate centroid!\");\n\t\t\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = 0;\n\t\tcoords[1] = 0;\n\t\tcoords[2] = 0;\n\n\t\tfor (Atom a : atomSet) {\n\t\t\tcoords[0] += a.getX();\n\t\t\tcoords[1] += a.getY();\n\t\t\tcoords[2] += a.getZ();\n\t\t}\n\n\t\tint n = atomSet.length;\n\t\tcoords[0] = coords[0] / n;\n\t\tcoords[1] = coords[1] / n;\n\t\tcoords[2] = coords[2] / n;\n\n\t\tAtom vec = new AtomImpl();\n\t\tvec.setCoords(coords);\n\t\treturn vec;\n\n\t}\n\n\t/**\n\t * Returns the center of mass of the set of atoms. Atomic masses of the\n\t * Atoms are used.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the center of mass\n\t */\n\tpublic static Atom centerOfMass(Atom[] points) {\n\t\tAtom center = new AtomImpl();\n\n\t\tfloat totalMass = 0.0f;\n\t\tfor (Atom a : points) {\n\t\t\tfloat mass = a.getElement().getAtomicMass();\n\t\t\ttotalMass += mass;\n\t\t\tcenter = scaleAdd(mass, a, center);\n\t\t}\n\n\t\tcenter = scaleEquals(center, 1.0f / totalMass);\n\t\treturn center;\n\t}\n\n\t/**\n\t * Multiply elements of a by s (in place)\n\t * \n\t * @param a\n\t * @param s\n\t * @return the modified a\n\t */\n\tpublic static Atom scaleEquals(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tx *= s;\n\t\ty *= s;\n\t\tz *= s;\n\n\t\t// Atom b = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Multiply elements of a by s\n\t * \n\t * @param a\n\t * @param s\n\t * @return A new Atom with s*a\n\t */\n\tpublic static Atom scale(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(x * s);\n\t\tb.setY(y * s);\n\t\tb.setZ(z * s);\n\n\t\treturn b;\n\t}\n\n\t/**\n\t * Perform linear transformation s*X+B, and store the result in b\n\t * \n\t * @param s\n\t *            Amount to scale x\n\t * @param x\n\t *            Input coordinate\n\t * @param b\n\t *            Vector to translate (will be modified)\n\t * @return b, after modification\n\t */\n\tpublic static Atom scaleAdd(double s, Atom x, Atom b) {\n\n\t\tdouble xc = s * x.getX() + b.getX();\n\t\tdouble yc = s * x.getY() + b.getY();\n\t\tdouble zc = s * x.getZ() + b.getZ();\n\n\t\t// Atom a = new AtomImpl();\n\t\tb.setX(xc);\n\t\tb.setY(yc);\n\t\tb.setZ(zc);\n\n\t\treturn b;\n\t}\n\n\t/**\n\t * Returns the Vector that needs to be applied to shift a set of atoms to\n\t * the Centroid.\n\t * \n\t * @param atomSet\n\t *            array of Atoms\n\t * @return the vector needed to shift the set of atoms to its geometric\n\t *         center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet) {\n\t\tAtom centroid = getCentroid(atomSet);\n\n\t\treturn getCenterVector(atomSet, centroid);\n\n\t}\n\n\t/**\n\t * Returns the Vector that needs to be applied to shift a set of atoms to\n\t * the Centroid, if the centroid is already known\n\t * \n\t * @param atomSet\n\t *            array of Atoms\n\t * @return the vector needed to shift the set of atoms to its geometric\n\t *         center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet, Atom centroid) {\n\n\t\tdouble[] coords = new double[3];\n\t\tcoords[0] = 0 - centroid.getX();\n\t\tcoords[1] = 0 - centroid.getY();\n\t\tcoords[2] = 0 - centroid.getZ();\n\n\t\tAtom shiftVec = new AtomImpl();\n\t\tshiftVec.setCoords(coords);\n\t\treturn shiftVec;\n\n\t}\n\n\t/**\n\t * Center the atoms at the Centroid.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet)\n\t\t\tthrows StructureException {\n\n\t\tAtom centroid = getCentroid(atomSet);\n\t\treturn centerAtoms(atomSet, centroid);\n\t}\n\n\t/**\n\t * Center the atoms at the Centroid, if the centroid is already know.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet, Atom centroid)\n\t\t\tthrows StructureException {\n\n\t\tAtom shiftVector = getCenterVector(atomSet, centroid);\n\n\t\tAtom[] newAtoms = new AtomImpl[atomSet.length];\n\n\t\tfor (int i = 0; i < atomSet.length; i++) {\n\t\t\tAtom a = atomSet[i];\n\t\t\tAtom n = add(a, shiftVector);\n\t\t\tnewAtoms[i] = n;\n\t\t}\n\t\treturn newAtoms;\n\t}\n\n\t/**\n\t * creates a virtual C-beta atom. this might be needed when working with GLY\n\t *\n\t * thanks to Peter Lackner for a python template of this method.\n\t * \n\t * @param amino\n\t *            the amino acid for which a \"virtual\" CB atom should be\n\t *            calculated\n\t * @return a \"virtual\" CB atom\n\t * @throws StructureException\n\t */\n\tpublic static final Atom createVirtualCBAtom(AminoAcid amino)\n\t\t\tthrows StructureException {\n\n\t\tAminoAcid ala = StandardAminoAcid.getAminoAcid(\"ALA\");\n\t\tAtom aN = ala.getN();\n\t\tAtom aCA = ala.getCA();\n\t\tAtom aC = ala.getC();\n\t\tAtom aCB = ala.getCB();\n\n\t\tAtom[] arr1 = new Atom[3];\n\t\tarr1[0] = aN;\n\t\tarr1[1] = aCA;\n\t\tarr1[2] = aC;\n\n\t\tAtom[] arr2 = new Atom[3];\n\t\tarr2[0] = amino.getN();\n\t\tarr2[1] = amino.getCA();\n\t\tarr2[2] = amino.getC();\n\n\t\t// ok now we got the two arrays, do a Superposition:\n\n\t\tSuperPositionSVD svd = new SuperPositionSVD(false);\n\n\t\tMatrix4d transform = svd.superpose(Calc.atomsToPoints(arr1), Calc.atomsToPoints(arr2));\n\t\tMatrix rotMatrix = Matrices.getRotationJAMA(transform);\n\t\tAtom tranMatrix = getTranslationVector(transform);\n\t\t\n\t\tCalc.rotate(aCB, rotMatrix);\n\n\t\tAtom virtualCB = Calc.add(aCB, tranMatrix);\n\t\tvirtualCB.setName(\"CB\");\n\n\t\treturn virtualCB;\n\t}\n\n\t/**\n\t * Gets euler angles for a matrix given in ZYZ convention. (as e.g. used by\n\t * Jmol)\n\t *\n\t * @param m\n\t *            the rotation matrix\n\t * @return the euler values for a rotation around Z, Y, Z in degrees...\n\t */\n\tpublic static final double[] getZYZEuler(Matrix m) {\n\t\tdouble m22 = m.get(2, 2);\n\t\tdouble rY = Math.toDegrees(Math.acos(m22));\n\t\tdouble rZ1, rZ2;\n\t\tif (m22 > .999d || m22 < -.999d) {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(1, 0), m.get(1, 1)));\n\t\t\trZ2 = 0;\n\t\t} else {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(2, 1), -m.get(2, 0)));\n\t\t\trZ2 = Math.toDegrees(Math.atan2(m.get(1, 2), m.get(0, 2)));\n\t\t}\n\t\treturn new double[] { rZ1, rY, rZ2 };\n\t}\n\n\t/**\n\t * Convert a rotation Matrix to Euler angles. This conversion uses\n\t * conventions as described on page:\n\t * http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t * Coordinate System: right hand Positive angle: right hand Order of euler\n\t * angles: heading first, then attitude, then bank\n\t *\n\t * @param m\n\t *            the rotation matrix\n\t * @return a array of three doubles containing the three euler angles in\n\t *         radians\n\t */\n\tpublic static final double[] getXYZEuler(Matrix m) {\n\t\tdouble heading, attitude, bank;\n\n\t\t// Assuming the angles are in radians.\n\t\tif (m.get(1, 0) > 0.998) { // singularity at north pole\n\t\t\theading = Math.atan2(m.get(0, 2), m.get(2, 2));\n\t\t\tattitude = Math.PI / 2;\n\t\t\tbank = 0;\n\n\t\t} else if (m.get(1, 0) < -0.998) { // singularity at south pole\n\t\t\theading = Math.atan2(m.get(0, 2), m.get(2, 2));\n\t\t\tattitude = -Math.PI / 2;\n\t\t\tbank = 0;\n\n\t\t} else {\n\t\t\theading = Math.atan2(-m.get(2, 0), m.get(0, 0));\n\t\t\tbank = Math.atan2(-m.get(1, 2), m.get(1, 1));\n\t\t\tattitude = Math.asin(m.get(1, 0));\n\t\t}\n\t\treturn new double[] { heading, attitude, bank };\n\t}\n\n\t/**\n\t * This conversion uses NASA standard aeroplane conventions as described on\n\t * page:\n\t * http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t * Coordinate System: right hand Positive angle: right hand Order of euler\n\t * angles: heading first, then attitude, then bank. matrix row column\n\t * ordering: [m00 m01 m02] [m10 m11 m12] [m20 m21 m22]\n\t * \n\t * @param heading\n\t *            in radians\n\t * @param attitude\n\t *            in radians\n\t * @param bank\n\t *            in radians\n\t * @return the rotation matrix\n\t */\n\tpublic static final Matrix matrixFromEuler(double heading, double attitude,\n\t\t\tdouble bank) {\n\t\t// Assuming the angles are in radians.\n\t\tdouble ch = Math.cos(heading);\n\t\tdouble sh = Math.sin(heading);\n\t\tdouble ca = Math.cos(attitude);\n\t\tdouble sa = Math.sin(attitude);\n\t\tdouble cb = Math.cos(bank);\n\t\tdouble sb = Math.sin(bank);\n\n\t\tMatrix m = new Matrix(3, 3);\n\t\tm.set(0, 0, ch * ca);\n\t\tm.set(0, 1, sh * sb - ch * sa * cb);\n\t\tm.set(0, 2, ch * sa * sb + sh * cb);\n\t\tm.set(1, 0, sa);\n\t\tm.set(1, 1, ca * cb);\n\t\tm.set(1, 2, -ca * sb);\n\t\tm.set(2, 0, -sh * ca);\n\t\tm.set(2, 1, sh * sa * cb + ch * sb);\n\t\tm.set(2, 2, -sh * sa * sb + ch * cb);\n\n\t\treturn m;\n\t}\n\n\t/**\n\t * Calculates the angle from centerPt to targetPt in degrees. The return\n\t * should range from [0,360), rotating CLOCKWISE, 0 and 360 degrees\n\t * represents NORTH, 90 degrees represents EAST, etc...\n\t *\n\t * Assumes all points are in the same coordinate space. If they are not, you\n\t * will need to call SwingUtilities.convertPointToScreen or equivalent on\n\t * all arguments before passing them to this function.\n\t *\n\t * @param centerPt\n\t *            Point we are rotating around.\n\t * @param targetPt\n\t *            Point we want to calculate the angle to.\n\t * @return angle in degrees. This is the angle from centerPt to targetPt.\n\t */\n\tpublic static double calcRotationAngleInDegrees(Atom centerPt, Atom targetPt) {\n\t\t// calculate the angle theta from the deltaY and deltaX values\n\t\t// (atan2 returns radians values from [-PI,PI])\n\t\t// 0 currently points EAST.\n\t\t// NOTE: By preserving Y and X param order to atan2, we are expecting\n\t\t// a CLOCKWISE angle direction.\n\t\tdouble theta = Math.atan2(targetPt.getY() - centerPt.getY(),\n\t\t\t\ttargetPt.getX() - centerPt.getX());\n\n\t\t// rotate the theta angle clockwise by 90 degrees\n\t\t// (this makes 0 point NORTH)\n\t\t// NOTE: adding to an angle rotates it clockwise.\n\t\t// subtracting would rotate it counter-clockwise\n\t\ttheta += Math.PI / 2.0;\n\n\t\t// convert from radians to degrees\n\t\t// this will give you an angle from [0->270],[-180,0]\n\t\tdouble angle = Math.toDegrees(theta);\n\n\t\t// convert to positive range [0-360)\n\t\t// since we want to prevent negative angles, adjust them now.\n\t\t// we can assume that atan2 will not return a negative value\n\t\t// greater than one partial rotation\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tAtom a = new AtomImpl();\n\t\ta.setX(0);\n\t\ta.setY(0);\n\t\ta.setZ(0);\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(1);\n\t\tb.setY(1);\n\t\tb.setZ(0);\n\n\t\tlogger.info(\"Angle between atoms: \", calcRotationAngleInDegrees(a, b));\n\t}\n\n\tpublic static void rotate(Atom[] ca, Matrix matrix) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.rotate(atom, matrix);\n\t}\n\n\t/**\n\t * Shift an array of atoms at once.\n\t * \n\t * @param ca\n\t *            array of Atoms to shift\n\t * @param b\n\t *            reference Atom vector\n\t */\n\tpublic static void shift(Atom[] ca, Atom b) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.shift(atom, b);\n\t}\n\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix.\n\t * Because the JAMA matrix is a pre-multiplication matrix and the Vecmath\n\t * matrix is a post-multiplication one, the rotation matrix is transposed to\n\t * ensure that the transformation they produce is the same.\n\t *\n\t * @param rot\n\t *            3x3 Rotation matrix\n\t * @param trans\n\t *            3x1 translation vector in Atom coordinates\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Atom trans) {\n\t\treturn new Matrix4d(new Matrix3d(rot.getColumnPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getCoordsAsPoint3d()), 1.0);\n\t}\n\t\n\t/**\n\t * Extract the translational vector as an Atom of a transformation matrix.\n\t *\n\t * @param transform\n\t *            Matrix4d\n\t * @return Atom shift vector\n\t */\n\tpublic static Atom getTranslationVector(Matrix4d transform) {\n\n\t\tAtom transl = new AtomImpl();\n\t\tdouble[] coords = { transform.m03, transform.m13, transform.m23 };\n\t\ttransl.setCoords(coords);\n\t\treturn transl;\n\t}\n\n\t/**\n\t * Convert an array of atoms into an array of vecmath points\n\t * \n\t * @param atoms\n\t *            list of atoms\n\t * @return list of Point3ds storing the x,y,z coordinates of each atom\n\t */\n\tpublic static Point3d[] atomsToPoints(Atom[] atoms) {\n\t\tPoint3d[] points = new Point3d[atoms.length];\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tpoints[i] = atoms[i].getCoordsAsPoint3d();\n\t\t}\n\t\treturn points;\n\t}\n\t/**\n\t * Convert an array of atoms into an array of vecmath points\n\t * \n\t * @param atoms\n\t *            list of atoms\n\t * @return list of Point3ds storing the x,y,z coordinates of each atom\n\t */\n\tpublic static List<Point3d> atomsToPoints(Collection<Atom> atoms) {\n\t\tArrayList<Point3d> points = new ArrayList<>(atoms.size());\n\t\tfor (Atom atom : atoms) {\n\t\t\tpoints.add(atom.getCoordsAsPoint3d());\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Calculate the RMSD of two Atom arrays, already superposed.\n\t * \n\t * @param x\n\t *            array of Atoms superposed to y\n\t * @param y\n\t *            array of Atoms superposed to x\n\t * @return RMSD\n\t */\n\tpublic static double rmsd(Atom[] x, Atom[] y) {\n\t\treturn CalcPoint.rmsd(atomsToPoints(x), atomsToPoints(y));\n\t}\n\n\t/**\n\t * Calculate the TM-Score for the superposition.\n\t *\n\t * <em>Normalizes by the <strong>maximum</strong>-length structure (that is, {@code max\\{len1,len2\\}}) rather than the minimum.</em>\n\t *\n\t * Atom sets must be superposed.\n\t *\n\t * <p>\n\t * Citation:<br/>\n\t * <i>Zhang Y and Skolnick J (2004). \"Scoring function for automated\n\t * assessment of protein structure template quality\". Proteins 57: 702 -\n\t * 710.</i>\n\t *\n\t * @param atomSet1\n\t *            atom array 1\n\t * @param atomSet2\n\t *            atom array 2\n\t * @param len1\n\t *            The full length of the protein supplying atomSet1\n\t * @param len2\n\t *            The full length of the protein supplying atomSet2\n\t * @return The TM-Score\n\t * @throws StructureException\n\t * @see {@link #getTMScore(Atom[], Atom[], int, int)}, which normalizes by\n\t *      the minimum length\n\t */\n\tpublic static double getTMScoreAlternate(Atom[] atomSet1, Atom[] atomSet2,\n\t\t\tint len1, int len2) throws StructureException {\n\t\tif (atomSet1.length != atomSet2.length) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"The two atom sets are not of same length!\");\n\t\t}\n\t\tif (atomSet1.length > len1) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len1 must be greater or equal to the alignment length!\");\n\t\t}\n\t\tif (atomSet2.length > len2) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len2 must be greater or equal to the alignment length!\");\n\t\t}\n\n\t\tint Lmax = Math.max(len1, len2);\n\t\tint Laln = atomSet1.length;\n\n\t\tdouble d0 = 1.24 * Math.cbrt(Lmax - 15.) - 1.8;\n\t\tdouble d0sq = d0 * d0;\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < Laln; i++) {\n\t\t\tdouble d = Calc.getDistance(atomSet1[i], atomSet2[i]);\n\t\t\tsum += 1. / (1 + d * d / d0sq);\n\t\t}\n\n\t\treturn sum / Lmax;\n\t}\n\n\t/**\n\t * Calculate the TM-Score for the superposition.\n\t *\n\t * <em>Normalizes by the <strong>minimum</strong>-length structure (that is, {@code min\\{len1,len2\\}}).</em>\n\t *\n\t * Atom sets must be pre-rotated.\n\t *\n\t * <p>\n\t * Citation:<br/>\n\t * <i>Zhang Y and Skolnick J (2004). \"Scoring function for automated\n\t * assessment of protein structure template quality\". Proteins 57: 702 -\n\t * 710.</i>\n\t *\n\t * @param atomSet1\n\t *            atom array 1\n\t * @param atomSet2\n\t *            atom array 2\n\t * @param len1\n\t *            The full length of the protein supplying atomSet1\n\t * @param len2\n\t *            The full length of the protein supplying atomSet2\n\t * @return The TM-Score\n\t * @throws StructureException\n\t */\n\tpublic static double getTMScore(Atom[] atomSet1, Atom[] atomSet2, int len1,\n\t\t\tint len2) throws StructureException {\n\t\tif (atomSet1.length != atomSet2.length) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"The two atom sets are not of same length!\");\n\t\t}\n\t\tif (atomSet1.length > len1) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len1 must be greater or equal to the alignment length!\");\n\t\t}\n\t\tif (atomSet2.length > len2) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len2 must be greater or equal to the alignment length!\");\n\t\t}\n\n\t\tint Lmin = Math.min(len1, len2);\n\t\tint Laln = atomSet1.length;\n\n\t\tdouble d0 = 1.24 * Math.cbrt(Lmin - 15.) - 1.8;\n\t\tdouble d0sq = d0 * d0;\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < Laln; i++) {\n\t\t\tdouble d = Calc.getDistance(atomSet1[i], atomSet2[i]);\n\t\t\tsum += 1. / (1 + d * d / d0sq);\n\t\t}\n\n\t\treturn sum / Lmin;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 08.05.2004\n *\n */\npackage org.biojava.nbio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.geometry.CalcPoint;\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.geometry.SuperPositionSVD;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility operations on Atoms, AminoAcids, Matrices, Point3d, etc.\n * <p>\n * Currently the coordinates of an Atom are stored as an array of size 3\n * (double[3]). It would be more powerful to use Point3d from javax.vecmath.\n * Overloaded methods for Point3d operations exist in the {@link CalcPoint}\n * Class.\n *\n * @author Andreas Prlic\n * @author Aleix Lafita\n * @since 1.4\n * @version %I% %G%\n */\n\npublic class Calc {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(Calc.class);\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static final double getDistance(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s = x * x + y * y + z * z;\n\n\t\treturn Math.sqrt(s);\n\t}\n\n\t/**\n\t * Will calculate the square of distances between two atoms. This will be\n\t * faster as it will not perform the final square root to get the actual\n\t * distance. Use this if doing large numbers of distance comparisons - it is\n\t * marginally faster than getDistance().\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static double getDistanceFast(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\treturn x * x + y * y + z * z;\n\t}\n\n\tpublic static final Atom invert(Atom a) {\n\t\tdouble[] coords = new double[] { 0.0, 0.0, 0.0 };\n\t\tAtom zero = new AtomImpl();\n\t\tzero.setCoords(coords);\n\t\treturn subtract(zero, a);\n\t}\n\n\t/**\n\t * add two atoms ( a + b).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom add(Atom a, Atom b) {\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getX() + b.getX());\n\t\tc.setY(a.getY() + b.getY());\n\t\tc.setZ(a.getZ() + b.getZ());\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * subtract two atoms ( a - b).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return n new Atom object representing the difference\n\t */\n\tpublic static final Atom subtract(Atom a, Atom b) {\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getX() - b.getX());\n\t\tc.setY(a.getY() - b.getY());\n\t\tc.setZ(a.getZ() - b.getZ());\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Vector product (cross product).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom vectorProduct(Atom a, Atom b) {\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX(a.getY() * b.getZ() - a.getZ() * b.getY());\n\t\tc.setY(a.getZ() * b.getX() - a.getX() * b.getZ());\n\t\tc.setZ(a.getX() * b.getY() - a.getY() * b.getX());\n\t\treturn c;\n\n\t}\n\n\t/**\n\t * Scalar product (dot product).\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return a double\n\t */\n\tpublic static final double scalarProduct(Atom a, Atom b) {\n\t\treturn a.getX() * b.getX() + a.getY() * b.getY() + a.getZ() * b.getZ();\n\t}\n\n\t/**\n\t * Gets the length of the vector (2-norm)\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @return Square root of the sum of the squared elements\n\t */\n\tpublic static final double amount(Atom a) {\n\t\treturn Math.sqrt(scalarProduct(a, a));\n\t}\n\n\t/**\n\t * Gets the angle between two vectors\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @return Angle between a and b in degrees, in range [0,180]. If either\n\t *         vector has length 0 then angle is not defined and NaN is returned\n\t */\n\tpublic static final double angle(Atom a, Atom b) {\n\n\t\tVector3d va = new Vector3d(a.getCoordsAsPoint3d());\n\t\tVector3d vb = new Vector3d(b.getCoordsAsPoint3d());\n\n\t\treturn Math.toDegrees(va.angle(vb));\n\n\t}\n\n\t/**\n\t * Returns the unit vector of vector a .\n\t *\n\t * @param a\n\t *            an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom unitVector(Atom a) {\n\t\tdouble amount = amount(a);\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = a.getX() / amount;\n\t\tcoords[1] = a.getY() / amount;\n\t\tcoords[2] = a.getZ() / amount;\n\n\t\ta.setCoords(coords);\n\t\treturn a;\n\n\t}\n\n\t/**\n\t * Calculate the torsion angle, i.e. the angle between the normal vectors of\n\t * the two plains a-b-c and b-c-d. See\n\t * http://en.wikipedia.org/wiki/Dihedral_angle\n\t * \n\t * @param a\n\t *            an Atom object\n\t * @param b\n\t *            an Atom object\n\t * @param c\n\t *            an Atom object\n\t * @param d\n\t *            an Atom object\n\t * @return the torsion angle in degrees, in range +-[0,180]. If either first\n\t *         3 or last 3 atoms are colinear then torsion angle is not defined\n\t *         and NaN is returned\n\t */\n\tpublic static final double torsionAngle(Atom a, Atom b, Atom c, Atom d) {\n\n\t\tAtom ab = subtract(a, b);\n\t\tAtom cb = subtract(c, b);\n\t\tAtom bc = subtract(b, c);\n\t\tAtom dc = subtract(d, c);\n\n\t\tAtom abc = vectorProduct(ab, cb);\n\t\tAtom bcd = vectorProduct(bc, dc);\n\n\t\tdouble angl = angle(abc, bcd);\n\n\t\t/* calc the sign: */\n\t\tAtom vecprod = vectorProduct(abc, bcd);\n\t\tdouble val = scalarProduct(cb, vecprod);\n\t\tif (val < 0.0)\n\t\t\tangl = -angl;\n\n\t\treturn angl;\n\t}\n\n\t/**\n\t * Calculate the phi angle.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return a double\n\t * @throws StructureException\n\t *             if aminoacids not connected or if any of the 4 needed atoms\n\t *             missing\n\t */\n\tpublic static final double getPhi(AminoAcid a, AminoAcid b)\n\t\t\tthrows StructureException {\n\n\t\tif (!isConnected(a, b)) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"can not calc Phi - AminoAcids are not connected!\");\n\t\t}\n\n\t\tAtom a_C = a.getC();\n\t\tAtom b_N = b.getN();\n\t\tAtom b_CA = b.getCA();\n\t\tAtom b_C = b.getC();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (b_CA == null)\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"Can not calculate Phi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_C, b_N, b_CA, b_C);\n\t}\n\n\t/**\n\t * Calculate the psi angle.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return a double\n\t * @throws StructureException\n\t *             if aminoacids not connected or if any of the 4 needed atoms\n\t *             missing\n\t */\n\tpublic static final double getPsi(AminoAcid a, AminoAcid b)\n\t\t\tthrows StructureException {\n\t\tif (!isConnected(a, b)) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"can not calc Psi - AminoAcids are not connected!\");\n\t\t}\n\n\t\tAtom a_N = a.getN();\n\t\tAtom a_CA = a.getCA();\n\t\tAtom a_C = a.getC();\n\t\tAtom b_N = b.getN();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (a_CA == null)\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"Can not calculate Psi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_N, a_CA, a_C, b_N);\n\n\t}\n\n\t/**\n\t * Test if two amino acids are connected, i.e. if the distance from C to N <\n\t * 2.5 Angstrom.\n\t *\n\t * If one of the AminoAcids has an atom missing, returns false.\n\t *\n\t * @param a\n\t *            an AminoAcid object\n\t * @param b\n\t *            an AminoAcid object\n\t * @return true if ...\n\t */\n\tpublic static final boolean isConnected(AminoAcid a, AminoAcid b) {\n\t\tAtom C = null;\n\t\tAtom N = null;\n\n\t\tC = a.getC();\n\t\tN = b.getN();\n\n\t\tif (C == null || N == null)\n\t\t\treturn false;\n\n\t\t// one could also check if the CA atoms are < 4 A...\n\t\tdouble distance = getDistance(C, N);\n\t\treturn distance < 2.5;\n\t}\n\n\t/**\n\t * Rotate a single Atom aroud a rotation matrix. The rotation Matrix must be\n\t * a pre-multiplication 3x3 Matrix.\n\t *\n\t * If the matrix is indexed m[row][col], then the matrix will be\n\t * pre-multiplied (y=atom*M)\n\t * \n\t * @param atom\n\t *            atom to be rotated\n\t * @param m\n\t *            a rotation matrix represented as a double[3][3] array\n\t */\n\tpublic static final void rotate(Atom atom, double[][] m) {\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY();\n\t\tdouble z = atom.getZ();\n\n\t\tdouble nx = m[0][0] * x + m[0][1] * y + m[0][2] * z;\n\t\tdouble ny = m[1][0] * x + m[1][1] * y + m[1][2] * z;\n\t\tdouble nz = m[2][0] * x + m[2][1] * y + m[2][2] * z;\n\n\t\tatom.setX(nx);\n\t\tatom.setY(ny);\n\t\tatom.setZ(nz);\n\t}\n\n\t/**\n\t * Rotate a structure. The rotation Matrix must be a pre-multiplication\n\t * Matrix.\n\t *\n\t * @param structure\n\t *            a Structure object\n\t * @param rotationmatrix\n\t *            an array (3x3) of double representing the rotation matrix.\n\t * @throws StructureException\n\t *             ...\n\t */\n\tpublic static final void rotate(Structure structure,\n\t\t\tdouble[][] rotationmatrix) throws StructureException {\n\n\t\tif (rotationmatrix.length != 3) {\n\t\t\tthrow new StructureException(\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(structure);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\tCalc.rotate(atom, rotationmatrix);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate a Group. The rotation Matrix must be a pre-multiplication Matrix.\n\t *\n\t * @param group\n\t *            a group object\n\t * @param rotationmatrix\n\t *            an array (3x3) of double representing the rotation matrix.\n\t * @throws StructureException\n\t *             ...\n\t */\n\tpublic static final void rotate(Group group, double[][] rotationmatrix)\n\t\t\tthrows StructureException {\n\n\t\tif (rotationmatrix.length != 3) {\n\t\t\tthrow new StructureException(\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(group);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\t\t\trotate(atom, rotationmatrix);\n\n\t\t}\n\t}\n\n\t/**\n\t * Rotate an Atom around a Matrix object. The rotation Matrix must be a\n\t * pre-multiplication Matrix.\n\t *\n\t * @param atom\n\t *            atom to be rotated\n\t * @param m\n\t *            rotation matrix to be applied to the atom\n\t */\n\tpublic static final void rotate(Atom atom, Matrix m) {\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY();\n\t\tdouble z = atom.getZ();\n\t\tdouble[][] ad = new double[][] { { x, y, z } };\n\n\t\tMatrix am = new Matrix(ad);\n\t\tMatrix na = am.times(m);\n\n\t\tatom.setX(na.get(0, 0));\n\t\tatom.setY(na.get(0, 1));\n\t\tatom.setZ(na.get(0, 2));\n\n\t}\n\n\t/**\n\t * Rotate a group object. The rotation Matrix must be a pre-multiplication\n\t * Matrix.\n\t *\n\t * @param group\n\t *            a group to be rotated\n\t * @param m\n\t *            a Matrix object representing the rotation matrix\n\t */\n\tpublic static final void rotate(Group group, Matrix m) {\n\n\t\tAtomIterator iter = new AtomIterator(group);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\trotate(atom, m);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Rotate a structure object. The rotation Matrix must be a\n\t * pre-multiplication Matrix.\n\t *\n\t * @param structure\n\t *            the structure to be rotated\n\t * @param m\n\t *            rotation matrix to be applied\n\t */\n\tpublic static final void rotate(Structure structure, Matrix m) {\n\n\t\tAtomIterator iter = new AtomIterator(structure);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\trotate(atom, m);\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Transform an array of atoms at once. The transformation Matrix must be a\n\t * post-multiplication Matrix.\n\t *\n\t * @param ca\n\t *            array of Atoms to shift\n\t * @param t\n\t *            transformation Matrix4d\n\t */\n\tpublic static void transform(Atom[] ca, Matrix4d t) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.transform(atom, t);\n\t}\n\n\t/**\n\t * Transforms an atom object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param atom\n\t * @param m\n\t */\n\tpublic static final void transform(Atom atom, Matrix4d m) {\n\n\t\tPoint3d p = new Point3d(atom.getX(), atom.getY(), atom.getZ());\n\t\tm.transform(p);\n\n\t\tatom.setX(p.x);\n\t\tatom.setY(p.y);\n\t\tatom.setZ(p.z);\n\t}\n\n\t/**\n\t * Transforms a group object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param group\n\t * @param m\n\t */\n\tpublic static final void transform(Group group, Matrix4d m) {\n\t\tfor (Atom atom : group.getAtoms()) {\n\t\t\ttransform(atom, m);\n\t\t}\n\t\tfor (Group altG : group.getAltLocs()) {\n\t\t\tfor (Atom atom : altG.getAtoms()) {\n\t\t\t\ttransform(atom, m);\n\t\t\t}\t\t\t\t\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a structure object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param structure\n\t * @param m\n\t */\n\tpublic static final void transform(Structure structure, Matrix4d m) {\n\t\tfor (int n=0; n<structure.nrModels();n++) {\n\t\t\tfor (Chain c : structure.getChains(n)) {\n\t\t\t\ttransform(c, m);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a chain object, given a Matrix4d (i.e. the vecmath library\n\t * double-precision 4x4 rotation+translation matrix). The transformation\n\t * Matrix must be a post-multiplication Matrix.\n\t *\n\t * @param chain\n\t * @param m\n\t */\n\tpublic static final void transform(Chain chain, Matrix4d m) {\n\n\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\ttransform(g, m);\n\t\t}\n\t}\n\n\t/**\n\t * Translates an atom object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param atom\n\t * @param v\n\t */\n\tpublic static final void translate(Atom atom, Vector3d v) {\n\n\t\tatom.setX(atom.getX() + v.x);\n\t\tatom.setY(atom.getY() + v.y);\n\t\tatom.setZ(atom.getZ() + v.z);\n\t}\n\n\t/**\n\t * Translates a group object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param group\n\t * @param v\n\t */\n\tpublic static final void translate(Group group, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(group);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttranslate(atom, v);\n\n\t\t}\n\t}\n\n\t/**\n\t * Translates a chain object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param chain\n\t * @param v\n\t */\n\tpublic static final void translate(Chain chain, Vector3d v) {\n\n\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\tfor (Atom atom : g.getAtoms()) {\n\t\t\t\ttranslate(atom, v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates a Structure object, given a Vector3d (i.e. the vecmath library\n\t * double-precision 3-d vector)\n\t * \n\t * @param structure\n\t * @param v\n\t */\n\tpublic static final void translate(Structure structure, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(structure);\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next();\n\t\t\ttranslate(atom, v);\n\n\t\t}\n\t}\n\n\t/**\n\t * calculate structure + Matrix coodinates ...\n\t *\n\t * @param s\n\t *            the structure to operate on\n\t * @param matrix\n\t *            a Matrix object\n\t */\n\tpublic static final void plus(Structure s, Matrix matrix) {\n\t\tAtomIterator iter = new AtomIterator(s);\n\t\tAtom oldAtom = null;\n\t\tAtom rotOldAtom = null;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\t\t\ttry {\n\t\t\t\tif (oldAtom != null) {\n\t\t\t\t\tlogger.debug(\"before {}\", getDistance(oldAtom, atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\toldAtom = (Atom) atom.clone();\n\n\t\t\tdouble x = atom.getX();\n\t\t\tdouble y = atom.getY();\n\t\t\tdouble z = atom.getZ();\n\t\t\tdouble[][] ad = new double[][] { { x, y, z } };\n\n\t\t\tMatrix am = new Matrix(ad);\n\t\t\tMatrix na = am.plus(matrix);\n\n\t\t\tdouble[] coords = new double[3];\n\t\t\tcoords[0] = na.get(0, 0);\n\t\t\tcoords[1] = na.get(0, 1);\n\t\t\tcoords[2] = na.get(0, 2);\n\t\t\tatom.setCoords(coords);\n\t\t\ttry {\n\t\t\t\tif (rotOldAtom != null) {\n\t\t\t\t\tlogger.debug(\"after {}\", getDistance(rotOldAtom, atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\trotOldAtom = (Atom) atom.clone();\n\t\t}\n\n\t}\n\n\t/**\n\t * shift a structure with a vector.\n\t *\n\t * @param structure\n\t *            a Structure object\n\t * @param a\n\t *            an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Structure structure, Atom a) {\n\n\t\tAtomIterator iter = new AtomIterator(structure);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\n\t\t\tAtom natom = add(atom, a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY();\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/**\n\t * Shift a vector.\n\t *\n\t * @param a\n\t *            vector a\n\t * @param b\n\t *            vector b\n\t */\n\tpublic static final void shift(Atom a, Atom b) {\n\n\t\tAtom natom = add(a, b);\n\t\tdouble x = natom.getX();\n\t\tdouble y = natom.getY();\n\t\tdouble z = natom.getZ();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t}\n\n\t/**\n\t * Shift a Group with a vector.\n\t *\n\t * @param group\n\t *            a group object\n\t * @param a\n\t *            an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Group group, Atom a) {\n\n\t\tAtomIterator iter = new AtomIterator(group);\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null;\n\n\t\t\tatom = iter.next();\n\n\t\t\tAtom natom = add(atom, a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY();\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/**\n\t * Returns the centroid of the set of atoms.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t */\n\tpublic static final Atom getCentroid(Atom[] atomSet) {\n\t\t\n\t\t// if we don't catch this case, the centroid returned is (NaN,NaN,NaN), which can cause lots of problems down the line\n\t\tif (atomSet.length==0) \n\t\t\tthrow new IllegalArgumentException(\"Atom array has length 0, can't calculate centroid!\");\n\n\t\t// if we don't catch this case, the centroid returned is (NaN,NaN,NaN), which can cause lots of problems down the line\n\t\tif (atomSet.length==0) \n\t\t\tthrow new IllegalArgumentException(\"Atom array has length 0, can't calculate centroid!\");\n\t\t\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = 0;\n\t\tcoords[1] = 0;\n\t\tcoords[2] = 0;\n\n\t\tfor (Atom a : atomSet) {\n\t\t\tcoords[0] += a.getX();\n\t\t\tcoords[1] += a.getY();\n\t\t\tcoords[2] += a.getZ();\n\t\t}\n\n\t\tint n = atomSet.length;\n\t\tcoords[0] = coords[0] / n;\n\t\tcoords[1] = coords[1] / n;\n\t\tcoords[2] = coords[2] / n;\n\n\t\tAtom vec = new AtomImpl();\n\t\tvec.setCoords(coords);\n\t\treturn vec;\n\n\t}\n\n\t/**\n\t * Returns the center of mass of the set of atoms. Atomic masses of the\n\t * Atoms are used.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the center of mass\n\t */\n\tpublic static Atom centerOfMass(Atom[] points) {\n\t\tAtom center = new AtomImpl();\n\n\t\tfloat totalMass = 0.0f;\n\t\tfor (Atom a : points) {\n\t\t\tfloat mass = a.getElement().getAtomicMass();\n\t\t\ttotalMass += mass;\n\t\t\tcenter = scaleAdd(mass, a, center);\n\t\t}\n\n\t\tcenter = scaleEquals(center, 1.0f / totalMass);\n\t\treturn center;\n\t}\n\n\t/**\n\t * Multiply elements of a by s (in place)\n\t * \n\t * @param a\n\t * @param s\n\t * @return the modified a\n\t */\n\tpublic static Atom scaleEquals(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tx *= s;\n\t\ty *= s;\n\t\tz *= s;\n\n\t\t// Atom b = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Multiply elements of a by s\n\t * \n\t * @param a\n\t * @param s\n\t * @return A new Atom with s*a\n\t */\n\tpublic static Atom scale(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(x * s);\n\t\tb.setY(y * s);\n\t\tb.setZ(z * s);\n\n\t\treturn b;\n\t}\n\n\t/**\n\t * Perform linear transformation s*X+B, and store the result in b\n\t * \n\t * @param s\n\t *            Amount to scale x\n\t * @param x\n\t *            Input coordinate\n\t * @param b\n\t *            Vector to translate (will be modified)\n\t * @return b, after modification\n\t */\n\tpublic static Atom scaleAdd(double s, Atom x, Atom b) {\n\n\t\tdouble xc = s * x.getX() + b.getX();\n\t\tdouble yc = s * x.getY() + b.getY();\n\t\tdouble zc = s * x.getZ() + b.getZ();\n\n\t\t// Atom a = new AtomImpl();\n\t\tb.setX(xc);\n\t\tb.setY(yc);\n\t\tb.setZ(zc);\n\n\t\treturn b;\n\t}\n\n\t/**\n\t * Returns the Vector that needs to be applied to shift a set of atoms to\n\t * the Centroid.\n\t * \n\t * @param atomSet\n\t *            array of Atoms\n\t * @return the vector needed to shift the set of atoms to its geometric\n\t *         center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet) {\n\t\tAtom centroid = getCentroid(atomSet);\n\n\t\treturn getCenterVector(atomSet, centroid);\n\n\t}\n\n\t/**\n\t * Returns the Vector that needs to be applied to shift a set of atoms to\n\t * the Centroid, if the centroid is already known\n\t * \n\t * @param atomSet\n\t *            array of Atoms\n\t * @return the vector needed to shift the set of atoms to its geometric\n\t *         center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet, Atom centroid) {\n\n\t\tdouble[] coords = new double[3];\n\t\tcoords[0] = 0 - centroid.getX();\n\t\tcoords[1] = 0 - centroid.getY();\n\t\tcoords[2] = 0 - centroid.getZ();\n\n\t\tAtom shiftVec = new AtomImpl();\n\t\tshiftVec.setCoords(coords);\n\t\treturn shiftVec;\n\n\t}\n\n\t/**\n\t * Center the atoms at the Centroid.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet)\n\t\t\tthrows StructureException {\n\n\t\tAtom centroid = getCentroid(atomSet);\n\t\treturn centerAtoms(atomSet, centroid);\n\t}\n\n\t/**\n\t * Center the atoms at the Centroid, if the centroid is already know.\n\t * \n\t * @param atomSet\n\t *            a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet, Atom centroid)\n\t\t\tthrows StructureException {\n\n\t\tAtom shiftVector = getCenterVector(atomSet, centroid);\n\n\t\tAtom[] newAtoms = new AtomImpl[atomSet.length];\n\n\t\tfor (int i = 0; i < atomSet.length; i++) {\n\t\t\tAtom a = atomSet[i];\n\t\t\tAtom n = add(a, shiftVector);\n\t\t\tnewAtoms[i] = n;\n\t\t}\n\t\treturn newAtoms;\n\t}\n\n\t/**\n\t * creates a virtual C-beta atom. this might be needed when working with GLY\n\t *\n\t * thanks to Peter Lackner for a python template of this method.\n\t * \n\t * @param amino\n\t *            the amino acid for which a \"virtual\" CB atom should be\n\t *            calculated\n\t * @return a \"virtual\" CB atom\n\t * @throws StructureException\n\t */\n\tpublic static final Atom createVirtualCBAtom(AminoAcid amino)\n\t\t\tthrows StructureException {\n\n\t\tAminoAcid ala = StandardAminoAcid.getAminoAcid(\"ALA\");\n\t\tAtom aN = ala.getN();\n\t\tAtom aCA = ala.getCA();\n\t\tAtom aC = ala.getC();\n\t\tAtom aCB = ala.getCB();\n\n\t\tAtom[] arr1 = new Atom[3];\n\t\tarr1[0] = aN;\n\t\tarr1[1] = aCA;\n\t\tarr1[2] = aC;\n\n\t\tAtom[] arr2 = new Atom[3];\n\t\tarr2[0] = amino.getN();\n\t\tarr2[1] = amino.getCA();\n\t\tarr2[2] = amino.getC();\n\n\t\t// ok now we got the two arrays, do a Superposition:\n\n\t\tSuperPositionSVD svd = new SuperPositionSVD(false);\n\n\t\tMatrix4d transform = svd.superpose(Calc.atomsToPoints(arr1), Calc.atomsToPoints(arr2));\n\t\tMatrix rotMatrix = Matrices.getRotationJAMA(transform);\n\t\tAtom tranMatrix = getTranslationVector(transform);\n\t\t\n\t\tCalc.rotate(aCB, rotMatrix);\n\n\t\tAtom virtualCB = Calc.add(aCB, tranMatrix);\n\t\tvirtualCB.setName(\"CB\");\n\n\t\treturn virtualCB;\n\t}\n\n\t/**\n\t * Gets euler angles for a matrix given in ZYZ convention. (as e.g. used by\n\t * Jmol)\n\t *\n\t * @param m\n\t *            the rotation matrix\n\t * @return the euler values for a rotation around Z, Y, Z in degrees...\n\t */\n\tpublic static final double[] getZYZEuler(Matrix m) {\n\t\tdouble m22 = m.get(2, 2);\n\t\tdouble rY = Math.toDegrees(Math.acos(m22));\n\t\tdouble rZ1, rZ2;\n\t\tif (m22 > .999d || m22 < -.999d) {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(1, 0), m.get(1, 1)));\n\t\t\trZ2 = 0;\n\t\t} else {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(2, 1), -m.get(2, 0)));\n\t\t\trZ2 = Math.toDegrees(Math.atan2(m.get(1, 2), m.get(0, 2)));\n\t\t}\n\t\treturn new double[] { rZ1, rY, rZ2 };\n\t}\n\n\t/**\n\t * Convert a rotation Matrix to Euler angles. This conversion uses\n\t * conventions as described on page:\n\t * http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t * Coordinate System: right hand Positive angle: right hand Order of euler\n\t * angles: heading first, then attitude, then bank\n\t *\n\t * @param m\n\t *            the rotation matrix\n\t * @return a array of three doubles containing the three euler angles in\n\t *         radians\n\t */\n\tpublic static final double[] getXYZEuler(Matrix m) {\n\t\tdouble heading, attitude, bank;\n\n\t\t// Assuming the angles are in radians.\n\t\tif (m.get(1, 0) > 0.998) { // singularity at north pole\n\t\t\theading = Math.atan2(m.get(0, 2), m.get(2, 2));\n\t\t\tattitude = Math.PI / 2;\n\t\t\tbank = 0;\n\n\t\t} else if (m.get(1, 0) < -0.998) { // singularity at south pole\n\t\t\theading = Math.atan2(m.get(0, 2), m.get(2, 2));\n\t\t\tattitude = -Math.PI / 2;\n\t\t\tbank = 0;\n\n\t\t} else {\n\t\t\theading = Math.atan2(-m.get(2, 0), m.get(0, 0));\n\t\t\tbank = Math.atan2(-m.get(1, 2), m.get(1, 1));\n\t\t\tattitude = Math.asin(m.get(1, 0));\n\t\t}\n\t\treturn new double[] { heading, attitude, bank };\n\t}\n\n\t/**\n\t * This conversion uses NASA standard aeroplane conventions as described on\n\t * page:\n\t * http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t * Coordinate System: right hand Positive angle: right hand Order of euler\n\t * angles: heading first, then attitude, then bank. matrix row column\n\t * ordering: [m00 m01 m02] [m10 m11 m12] [m20 m21 m22]\n\t * \n\t * @param heading\n\t *            in radians\n\t * @param attitude\n\t *            in radians\n\t * @param bank\n\t *            in radians\n\t * @return the rotation matrix\n\t */\n\tpublic static final Matrix matrixFromEuler(double heading, double attitude,\n\t\t\tdouble bank) {\n\t\t// Assuming the angles are in radians.\n\t\tdouble ch = Math.cos(heading);\n\t\tdouble sh = Math.sin(heading);\n\t\tdouble ca = Math.cos(attitude);\n\t\tdouble sa = Math.sin(attitude);\n\t\tdouble cb = Math.cos(bank);\n\t\tdouble sb = Math.sin(bank);\n\n\t\tMatrix m = new Matrix(3, 3);\n\t\tm.set(0, 0, ch * ca);\n\t\tm.set(0, 1, sh * sb - ch * sa * cb);\n\t\tm.set(0, 2, ch * sa * sb + sh * cb);\n\t\tm.set(1, 0, sa);\n\t\tm.set(1, 1, ca * cb);\n\t\tm.set(1, 2, -ca * sb);\n\t\tm.set(2, 0, -sh * ca);\n\t\tm.set(2, 1, sh * sa * cb + ch * sb);\n\t\tm.set(2, 2, -sh * sa * sb + ch * cb);\n\n\t\treturn m;\n\t}\n\n\t/**\n\t * Calculates the angle from centerPt to targetPt in degrees. The return\n\t * should range from [0,360), rotating CLOCKWISE, 0 and 360 degrees\n\t * represents NORTH, 90 degrees represents EAST, etc...\n\t *\n\t * Assumes all points are in the same coordinate space. If they are not, you\n\t * will need to call SwingUtilities.convertPointToScreen or equivalent on\n\t * all arguments before passing them to this function.\n\t *\n\t * @param centerPt\n\t *            Point we are rotating around.\n\t * @param targetPt\n\t *            Point we want to calculate the angle to.\n\t * @return angle in degrees. This is the angle from centerPt to targetPt.\n\t */\n\tpublic static double calcRotationAngleInDegrees(Atom centerPt, Atom targetPt) {\n\t\t// calculate the angle theta from the deltaY and deltaX values\n\t\t// (atan2 returns radians values from [-PI,PI])\n\t\t// 0 currently points EAST.\n\t\t// NOTE: By preserving Y and X param order to atan2, we are expecting\n\t\t// a CLOCKWISE angle direction.\n\t\tdouble theta = Math.atan2(targetPt.getY() - centerPt.getY(),\n\t\t\t\ttargetPt.getX() - centerPt.getX());\n\n\t\t// rotate the theta angle clockwise by 90 degrees\n\t\t// (this makes 0 point NORTH)\n\t\t// NOTE: adding to an angle rotates it clockwise.\n\t\t// subtracting would rotate it counter-clockwise\n\t\ttheta += Math.PI / 2.0;\n\n\t\t// convert from radians to degrees\n\t\t// this will give you an angle from [0->270],[-180,0]\n\t\tdouble angle = Math.toDegrees(theta);\n\n\t\t// convert to positive range [0-360)\n\t\t// since we want to prevent negative angles, adjust them now.\n\t\t// we can assume that atan2 will not return a negative value\n\t\t// greater than one partial rotation\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tAtom a = new AtomImpl();\n\t\ta.setX(0);\n\t\ta.setY(0);\n\t\ta.setZ(0);\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(1);\n\t\tb.setY(1);\n\t\tb.setZ(0);\n\n\t\tlogger.info(\"Angle between atoms: \", calcRotationAngleInDegrees(a, b));\n\t}\n\n\tpublic static void rotate(Atom[] ca, Matrix matrix) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.rotate(atom, matrix);\n\t}\n\n\t/**\n\t * Shift an array of atoms at once.\n\t * \n\t * @param ca\n\t *            array of Atoms to shift\n\t * @param b\n\t *            reference Atom vector\n\t */\n\tpublic static void shift(Atom[] ca, Atom b) {\n\t\tfor (Atom atom : ca)\n\t\t\tCalc.shift(atom, b);\n\t}\n\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix.\n\t * Because the JAMA matrix is a pre-multiplication matrix and the Vecmath\n\t * matrix is a post-multiplication one, the rotation matrix is transposed to\n\t * ensure that the transformation they produce is the same.\n\t *\n\t * @param rot\n\t *            3x3 Rotation matrix\n\t * @param trans\n\t *            3x1 translation vector in Atom coordinates\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Atom trans) {\n\t\treturn new Matrix4d(new Matrix3d(rot.getColumnPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getCoordsAsPoint3d()), 1.0);\n\t}\n\t\n\t/**\n\t * Extract the translational vector as an Atom of a transformation matrix.\n\t *\n\t * @param transform\n\t *            Matrix4d\n\t * @return Atom shift vector\n\t */\n\tpublic static Atom getTranslationVector(Matrix4d transform) {\n\n\t\tAtom transl = new AtomImpl();\n\t\tdouble[] coords = { transform.m03, transform.m13, transform.m23 };\n\t\ttransl.setCoords(coords);\n\t\treturn transl;\n\t}\n\n\t/**\n\t * Convert an array of atoms into an array of vecmath points\n\t * \n\t * @param atoms\n\t *            list of atoms\n\t * @return list of Point3ds storing the x,y,z coordinates of each atom\n\t */\n\tpublic static Point3d[] atomsToPoints(Atom[] atoms) {\n\t\tPoint3d[] points = new Point3d[atoms.length];\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tpoints[i] = atoms[i].getCoordsAsPoint3d();\n\t\t}\n\t\treturn points;\n\t}\n\t/**\n\t * Convert an array of atoms into an array of vecmath points\n\t * \n\t * @param atoms\n\t *            list of atoms\n\t * @return list of Point3ds storing the x,y,z coordinates of each atom\n\t */\n\tpublic static List<Point3d> atomsToPoints(Collection<Atom> atoms) {\n\t\tArrayList<Point3d> points = new ArrayList<>(atoms.size());\n\t\tfor (Atom atom : atoms) {\n\t\t\tpoints.add(atom.getCoordsAsPoint3d());\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Calculate the RMSD of two Atom arrays, already superposed.\n\t * \n\t * @param x\n\t *            array of Atoms superposed to y\n\t * @param y\n\t *            array of Atoms superposed to x\n\t * @return RMSD\n\t */\n\tpublic static double rmsd(Atom[] x, Atom[] y) {\n\t\treturn CalcPoint.rmsd(atomsToPoints(x), atomsToPoints(y));\n\t}\n\n\t/**\n\t * Calculate the TM-Score for the superposition.\n\t *\n\t * <em>Normalizes by the <strong>maximum</strong>-length structure (that is, {@code max\\{len1,len2\\}}) rather than the minimum.</em>\n\t *\n\t * Atom sets must be superposed.\n\t *\n\t * <p>\n\t * Citation:<br/>\n\t * <i>Zhang Y and Skolnick J (2004). \"Scoring function for automated\n\t * assessment of protein structure template quality\". Proteins 57: 702 -\n\t * 710.</i>\n\t *\n\t * @param atomSet1\n\t *            atom array 1\n\t * @param atomSet2\n\t *            atom array 2\n\t * @param len1\n\t *            The full length of the protein supplying atomSet1\n\t * @param len2\n\t *            The full length of the protein supplying atomSet2\n\t * @return The TM-Score\n\t * @throws StructureException\n\t * @see {@link #getTMScore(Atom[], Atom[], int, int)}, which normalizes by\n\t *      the minimum length\n\t */\n\tpublic static double getTMScoreAlternate(Atom[] atomSet1, Atom[] atomSet2,\n\t\t\tint len1, int len2) throws StructureException {\n\t\tif (atomSet1.length != atomSet2.length) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"The two atom sets are not of same length!\");\n\t\t}\n\t\tif (atomSet1.length > len1) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len1 must be greater or equal to the alignment length!\");\n\t\t}\n\t\tif (atomSet2.length > len2) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len2 must be greater or equal to the alignment length!\");\n\t\t}\n\n\t\tint Lmax = Math.max(len1, len2);\n\t\tint Laln = atomSet1.length;\n\n\t\tdouble d0 = 1.24 * Math.cbrt(Lmax - 15.) - 1.8;\n\t\tdouble d0sq = d0 * d0;\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < Laln; i++) {\n\t\t\tdouble d = Calc.getDistance(atomSet1[i], atomSet2[i]);\n\t\t\tsum += 1. / (1 + d * d / d0sq);\n\t\t}\n\n\t\treturn sum / Lmax;\n\t}\n\n\t/**\n\t * Calculate the TM-Score for the superposition.\n\t *\n\t * <em>Normalizes by the <strong>minimum</strong>-length structure (that is, {@code min\\{len1,len2\\}}).</em>\n\t *\n\t * Atom sets must be pre-rotated.\n\t *\n\t * <p>\n\t * Citation:<br/>\n\t * <i>Zhang Y and Skolnick J (2004). \"Scoring function for automated\n\t * assessment of protein structure template quality\". Proteins 57: 702 -\n\t * 710.</i>\n\t *\n\t * @param atomSet1\n\t *            atom array 1\n\t * @param atomSet2\n\t *            atom array 2\n\t * @param len1\n\t *            The full length of the protein supplying atomSet1\n\t * @param len2\n\t *            The full length of the protein supplying atomSet2\n\t * @return The TM-Score\n\t * @throws StructureException\n\t */\n\tpublic static double getTMScore(Atom[] atomSet1, Atom[] atomSet2, int len1,\n\t\t\tint len2) throws StructureException {\n\t\tif (atomSet1.length != atomSet2.length) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"The two atom sets are not of same length!\");\n\t\t}\n\t\tif (atomSet1.length > len1) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len1 must be greater or equal to the alignment length!\");\n\t\t}\n\t\tif (atomSet2.length > len2) {\n\t\t\tthrow new StructureException(\n\t\t\t\t\t\"len2 must be greater or equal to the alignment length!\");\n\t\t}\n\n\t\tint Lmin = Math.min(len1, len2);\n\t\tint Laln = atomSet1.length;\n\n\t\tdouble d0 = 1.24 * Math.cbrt(Lmin - 15.) - 1.8;\n\t\tdouble d0sq = d0 * d0;\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < Laln; i++) {\n\t\t\tdouble d = Calc.getDistance(atomSet1[i], atomSet2[i]);\n\t\t\tsum += 1. / (1 + d * d / d0sq);\n\t\t}\n\n\t\treturn sum / Lmin;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\n\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.junit.Test;\n\npublic class TestCalc {\n\n\t@Test\n\tpublic void testAngle() {\n\t\tAtom a = getAtom(1,1,1);\n\n\t\tAtom b = getAtom(2,2,2);\n\n\t\t// 2 parallel vectors should return 0\n\t\tassertEquals(0.0, Calc.angle(a, b),0.00001);\n\n\t\t// range should be [0,180]\n\t\tAtom ref = getAtom(1,0,0);\n\t\tAtom a1 = getAtom(1,1,0);\n\t\tAtom a2 = getAtom(0,1,0);\n\t\tAtom a3 = getAtom(-1,1,0);\n\t\tAtom a4 = getAtom(-1,0,0);\n\t\tAtom a5 = getAtom(-1,-1,0);\n\t\tAtom a6 = getAtom(0,-1,0);\n\t\tAtom a7 = getAtom(1,-1,0);\n\n\t\tassertEquals(180.0,Calc.angle(ref, a4),0.00001);\n\n\t\tassertTrue(Calc.angle(ref, a1)>=0 && Calc.angle(ref,a1)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a2)>=0 && Calc.angle(ref,a2)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a3)>=0 && Calc.angle(ref,a3)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a4)>=0 && Calc.angle(ref,a4)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a5)>=0 && Calc.angle(ref,a5)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a6)>=0 && Calc.angle(ref,a6)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a7)>=0 && Calc.angle(ref,a7)<=180.0);\n\n\t\tAtom c = getAtom(0,0,0);\n\t\tAtom d = getAtom(0,0,0);\n\n\t\tassertEquals(Double.NaN, Calc.angle(a,c),0.00001);\n\t\tassertEquals(Double.NaN, Calc.angle(c,d),0.00001);\n\t}\n\n\t@Test\n\tpublic void testTorsionAngle() {\n\t\tAtom a = getAtom(0,0,0);\n\n\t\tAtom b = getAtom(1,0,0);\n\n\t\tAtom c = getAtom(2,0,0);\n\n\t\tAtom d = getAtom(3,0,0);\n\n\t\t// all 4 points colinear\n\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// first 3 colinear\n\t\td = getAtom(3,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// second 3 colinear\n\t\td = getAtom(3,0,0);\n\t\ta = getAtom(1,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// coplanar vectors\n\t\ta = getAtom(0,0,0);\n\t\tb = getAtom(1,0,0);\n\t\tc = getAtom(1, 1, 0);\n\t\td = getAtom(2, 1, 0);\n\n\t\tassertEquals(180, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\tc = getAtom(-1,-1, 0);\n\t\td = getAtom(-2,-1, 0);\n\n\t\tassertEquals(0, Calc.torsionAngle(a, b, c, d),0.00001);\n\t}\n\n\t@Test\n\tpublic void testJamaTransformation() {\n\n\t\tAtom atom = getAtom(1.0, 1.0, 1.0);\n\n\t\t//Identity transform\n\t\tMatrix identR = Matrix.identity(3, 3);\n\t\tAtom identT = getAtom(0, 0, 0);\n\t\tCalc.rotate(atom, identR);\n\t\tCalc.shift(atom, identT);\n\n\t\tPoint3d expected = new Point3d(1.0, 1.0, 1.0);\n\t\tPoint3d actual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\n\t\t//Sample transform: calc transposes automatically the matrix\n\t\t//because it is a pre-multiplication rotation matrix\n\t\tMatrix sampleR = Matrices.getRotationJAMA(getSampleTransform());\n\t\tAtom sampleT = Calc.getTranslationVector(getSampleTransform());\n\t\tCalc.rotate(atom, sampleR);\n\t\tCalc.shift(atom, sampleT);\n\n\t\texpected = new Point3d(2.0, 7.0, -1.3);\n\t\tactual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\t}\n\n\t@Test\n\tpublic void testVecmathTransformation() {\n\n\t\tAtom atom = getAtom(1.0, 1.0, 1.0);\n\n\t\t//Identity transform\n\t\tMatrix4d ident = new Matrix4d();\n\t\tident.setIdentity();\n\t\tCalc.transform(atom, ident);\n\n\t\tPoint3d expected = new Point3d(1.0, 1.0, 1.0);\n\t\tPoint3d actual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\n\t\t//Sample transform\n\t\tMatrix4d sample = getSampleTransform();\n\t\tCalc.transform(atom, sample);\n\n\t\texpected = new Point3d(2.0, 7.0, -1.3);\n\t\tactual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t * Issue https://github.com/biojava/biojava/issues/715\n\t */\n\t@Test\n\tpublic void testChainTransform() {\n\t\tGroup g = new AminoAcidImpl();\n\t\tAtom a = new AtomImpl();\n\t\ta.setName(\"CA\");\n\t\ta.setX(1);\n\t\ta.setY(1);\n\t\ta.setZ(1);\n\t\tg.addAtom(a);\n\t\tGroup altLocG = new AminoAcidImpl();\n\t\tAtom a2 = new AtomImpl();\n\t\ta2.setName(\"CA\");\n\t\ta2.setX(2);\n\t\ta2.setY(2);\n\t\ta2.setZ(2);\n\t\taltLocG.addAtom(a2);\n\t\t\n\t\tg.addAltLoc(altLocG);\n\t\t\n\t\tChain c = new ChainImpl();\n\t\tc.addGroup(g);\n\t\t\n\t\tMatrix4d m = new Matrix4d(1,0,0,1, 0,1,0,0, 0,0,1,0, 0,0,0,1); // shift of 1 in x axis\n \t\tCalc.transform(c, m);\n \t\t\n \t\tGroup thegroup = c.getAtomGroup(0);\n \t\tGroup thealtlocgroup = thegroup.getAltLocs().get(0);\n \t\t\n \t\tAtom atom1 = thegroup.getAtom(\"CA\");\n \t\tAtom atom2 = thealtlocgroup.getAtom(\"CA\");\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(2, atom1.getX(), 0.00001);\n \t\tassertEquals(1, atom1.getY(), 0.00001);\n \t\tassertEquals(1, atom1.getZ(), 0.00001);\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(3, atom2.getX(), 0.00001);\n \t\tassertEquals(2, atom2.getY(), 0.00001);\n \t\tassertEquals(2, atom2.getZ(), 0.00001);\n\n \t\t\n\t}\n\n\tprivate static Atom getAtom(double x, double y, double z) {\n\t\tAtom a = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t\treturn a;\n\t}\n\n\tprivate static Matrix4d getSampleTransform(){\n\n\t\tMatrix4d sample = new Matrix4d(new double[] {1.0,1.5,0.5,-1.0,\n\t\t                                0.5,0.5,1.0,5.0,\n\t\t                                0.3,0.4,0.5,-2.5,\n\t\t                                0.0,0.0,0.0,1.0});\n\t\treturn sample;\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\n\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.junit.Test;\n\npublic class TestCalc {\n\n\t@Test\n\tpublic void testAngle() {\n\t\tAtom a = getAtom(1,1,1);\n\n\t\tAtom b = getAtom(2,2,2);\n\n\t\t// 2 parallel vectors should return 0\n\t\tassertEquals(0.0, Calc.angle(a, b),0.00001);\n\n\t\t// range should be [0,180]\n\t\tAtom ref = getAtom(1,0,0);\n\t\tAtom a1 = getAtom(1,1,0);\n\t\tAtom a2 = getAtom(0,1,0);\n\t\tAtom a3 = getAtom(-1,1,0);\n\t\tAtom a4 = getAtom(-1,0,0);\n\t\tAtom a5 = getAtom(-1,-1,0);\n\t\tAtom a6 = getAtom(0,-1,0);\n\t\tAtom a7 = getAtom(1,-1,0);\n\n\t\tassertEquals(180.0,Calc.angle(ref, a4),0.00001);\n\n\t\tassertTrue(Calc.angle(ref, a1)>=0 && Calc.angle(ref,a1)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a2)>=0 && Calc.angle(ref,a2)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a3)>=0 && Calc.angle(ref,a3)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a4)>=0 && Calc.angle(ref,a4)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a5)>=0 && Calc.angle(ref,a5)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a6)>=0 && Calc.angle(ref,a6)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a7)>=0 && Calc.angle(ref,a7)<=180.0);\n\n\t\tAtom c = getAtom(0,0,0);\n\t\tAtom d = getAtom(0,0,0);\n\n\t\tassertEquals(Double.NaN, Calc.angle(a,c),0.00001);\n\t\tassertEquals(Double.NaN, Calc.angle(c,d),0.00001);\n\t}\n\n\t@Test\n\tpublic void testTorsionAngle() {\n\t\tAtom a = getAtom(0,0,0);\n\n\t\tAtom b = getAtom(1,0,0);\n\n\t\tAtom c = getAtom(2,0,0);\n\n\t\tAtom d = getAtom(3,0,0);\n\n\t\t// all 4 points colinear\n\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// first 3 colinear\n\t\td = getAtom(3,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// second 3 colinear\n\t\td = getAtom(3,0,0);\n\t\ta = getAtom(1,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\t// coplanar vectors\n\t\ta = getAtom(0,0,0);\n\t\tb = getAtom(1,0,0);\n\t\tc = getAtom(1, 1, 0);\n\t\td = getAtom(2, 1, 0);\n\n\t\tassertEquals(180, Calc.torsionAngle(a, b, c, d),0.00001);\n\n\t\tc = getAtom(-1,-1, 0);\n\t\td = getAtom(-2,-1, 0);\n\n\t\tassertEquals(0, Calc.torsionAngle(a, b, c, d),0.00001);\n\t}\n\n\t@Test\n\tpublic void testJamaTransformation() {\n\n\t\tAtom atom = getAtom(1.0, 1.0, 1.0);\n\n\t\t//Identity transform\n\t\tMatrix identR = Matrix.identity(3, 3);\n\t\tAtom identT = getAtom(0, 0, 0);\n\t\tCalc.rotate(atom, identR);\n\t\tCalc.shift(atom, identT);\n\n\t\tPoint3d expected = new Point3d(1.0, 1.0, 1.0);\n\t\tPoint3d actual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\n\t\t//Sample transform: calc transposes automatically the matrix\n\t\t//because it is a pre-multiplication rotation matrix\n\t\tMatrix sampleR = Matrices.getRotationJAMA(getSampleTransform());\n\t\tAtom sampleT = Calc.getTranslationVector(getSampleTransform());\n\t\tCalc.rotate(atom, sampleR);\n\t\tCalc.shift(atom, sampleT);\n\n\t\texpected = new Point3d(2.0, 7.0, -1.3);\n\t\tactual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\t}\n\n\t@Test\n\tpublic void testVecmathTransformation() {\n\n\t\tAtom atom = getAtom(1.0, 1.0, 1.0);\n\n\t\t//Identity transform\n\t\tMatrix4d ident = new Matrix4d();\n\t\tident.setIdentity();\n\t\tCalc.transform(atom, ident);\n\n\t\tPoint3d expected = new Point3d(1.0, 1.0, 1.0);\n\t\tPoint3d actual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\n\t\t//Sample transform\n\t\tMatrix4d sample = getSampleTransform();\n\t\tCalc.transform(atom, sample);\n\n\t\texpected = new Point3d(2.0, 7.0, -1.3);\n\t\tactual = atom.getCoordsAsPoint3d();\n\n\t\tassertEquals(expected, actual);\n\t}\n\t\n\t/**\n\t * Issue https://github.com/biojava/biojava/issues/715\n\t */\n\t@Test\n\tpublic void testChainTransform() {\n\t\tGroup g = new AminoAcidImpl();\n\t\tAtom a = getAtom(\"CA\", 1, 1, 1);\n\t\tg.addAtom(a);\n\t\tGroup altLocG = new AminoAcidImpl();\n\t\tAtom a2 = getAtom(\"CA\", 2, 2, 2);\n\t\taltLocG.addAtom(a2);\n\t\t\n\t\tg.addAltLoc(altLocG);\n\t\t\n\t\tChain c = new ChainImpl();\n\t\tc.addGroup(g);\n\t\t\n\t\tMatrix4d m = new Matrix4d(1,0,0,1, 0,1,0,0, 0,0,1,0, 0,0,0,1); // shift of 1 in x axis\n \t\tCalc.transform(c, m);\n \t\t\n \t\tGroup thegroup = c.getAtomGroup(0);\n \t\tGroup thealtlocgroup = thegroup.getAltLocs().get(0);\n \t\t\n \t\tAtom atom1 = thegroup.getAtom(\"CA\");\n \t\tAtom atom2 = thealtlocgroup.getAtom(\"CA\");\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(2, atom1.getX(), 0.00001);\n \t\tassertEquals(1, atom1.getY(), 0.00001);\n \t\tassertEquals(1, atom1.getZ(), 0.00001);\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(3, atom2.getX(), 0.00001);\n \t\tassertEquals(2, atom2.getY(), 0.00001);\n \t\tassertEquals(2, atom2.getZ(), 0.00001);\n\n \t\t\n\t}\n\n\t/**\n\t * Issue https://github.com/biojava/biojava/issues/715\n\t */\n\t@Test\n\tpublic void testStructureTransform() {\n\t\tGroup g = new AminoAcidImpl();\n\t\tAtom a = getAtom(\"CA\", 1, 1, 1);\n\t\tg.addAtom(a);\n\t\tGroup altLocG = new AminoAcidImpl();\n\t\tAtom a2 = getAtom(\"CA\", 2, 2, 2);\n\t\taltLocG.addAtom(a2);\n\t\t\n\t\tg.addAltLoc(altLocG);\n\t\t\n\t\tChain c1 = new ChainImpl();\n\t\tc1.addGroup(g);\n\t\tc1.setId(\"A\");\n\t\t\n\t\tGroup gc2 = new AminoAcidImpl();\n\t\tAtom ac2 = getAtom(\"CA\", 3, 3, 3);\n\t\tgc2.addAtom(ac2);\n\t\tGroup altLocGc2 = new AminoAcidImpl();\n\t\tAtom ac22 = getAtom(\"CA\", 4, 4, 4);\n\t\taltLocGc2.addAtom(ac22);\n\t\t\n\t\tgc2.addAltLoc(altLocGc2);\n\t\t\n\t\tChain c2 = new ChainImpl();\n\t\tc2.addGroup(gc2);\n\t\tc2.setId(\"B\");\n\t\t\n\t\tStructure s = new StructureImpl();\n\t\ts.addChain(c1);\n\t\ts.addChain(c2);\n\t\t\n\t\t\n\t\tMatrix4d m = new Matrix4d(1,0,0,1, 0,1,0,0, 0,0,1,0, 0,0,0,1); // shift of 1 in x axis\n \t\tCalc.transform(s, m);\n \t\t\n \t\t// testing 1st chain\n \t\tGroup thegroup = s.getChain(\"A\").getAtomGroup(0);\n \t\tGroup thealtlocgroup = thegroup.getAltLocs().get(0);\n \t\t\n \t\tAtom atom1 = thegroup.getAtom(\"CA\");\n \t\tAtom atom2 = thealtlocgroup.getAtom(\"CA\");\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(2, atom1.getX(), 0.00001);\n \t\tassertEquals(1, atom1.getY(), 0.00001);\n \t\tassertEquals(1, atom1.getZ(), 0.00001);\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(3, atom2.getX(), 0.00001);\n \t\tassertEquals(2, atom2.getY(), 0.00001);\n \t\tassertEquals(2, atom2.getZ(), 0.00001);\n\n \t\t// testing 2nd chain\n \t\tthegroup = s.getChain(\"B\").getAtomGroup(0);\n \t\tthealtlocgroup = thegroup.getAltLocs().get(0);\n \t\t\n \t\tatom1 = thegroup.getAtom(\"CA\");\n \t\tatom2 = thealtlocgroup.getAtom(\"CA\");\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(4, atom1.getX(), 0.00001);\n \t\tassertEquals(3, atom1.getY(), 0.00001);\n \t\tassertEquals(3, atom1.getZ(), 0.00001);\n \t\t\n \t\t// x should be shitfted by 1\n \t\tassertEquals(5, atom2.getX(), 0.00001);\n \t\tassertEquals(4, atom2.getY(), 0.00001);\n \t\tassertEquals(4, atom2.getZ(), 0.00001);\n\n \t\t\n\t}\n\n\tprivate static Atom getAtom(String name, double x, double y, double z) {\n\t\tAtom a = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t\ta.setName(name);\n\t\treturn a;\n\t}\n\t\n\tprivate static Atom getAtom(double x, double y, double z) {\n\t\treturn getAtom(null, x, y, z);\n\t}\n\n\tprivate static Matrix4d getSampleTransform(){\n\n\t\tMatrix4d sample = new Matrix4d(new double[] {1.0,1.5,0.5,-1.0,\n\t\t                                0.5,0.5,1.0,5.0,\n\t\t                                0.3,0.4,0.5,-2.5,\n\t\t                                0.0,0.0,0.0,1.0});\n\t\treturn sample;\n\t}\n\n}\n","commitMessage":"Fixing also Calc.transform(Structure,Matrix4d)","test_commitMessage":"Fixing also Calc.transform(Structure,Matrix4d)","allZero":false}