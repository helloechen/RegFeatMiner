{"repository":"biojava","prod_path":"biojava-protein-disorder/src/main/java/org/biojava3/ronn/Jronn.java","test_path":"biojava-protein-disorder/src/test/java/org/biojava3/ronn/JronnTest.java","prod_time":"2015-01-30 06:34:57","test_time":"2015-01-30 06:34:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":4,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":4,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","test_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","isfound":"found test change","originPro":" /*        BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\npackage org.biojava3.ronn;\r\n\r\nimport java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.IOException;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n\r\n\r\n\r\nimport org.biojava3.core.sequence.ProteinSequence;\r\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.data.sequence.SequenceUtil;\r\n\r\n\r\n/**\r\n * This class gives public API to RONN functions. \r\n * It is build on top of the command line client. Due to this fact a few things \r\n * could be improved and extended pending the refactoring of the command line client.  \r\n *\r\n * The input sequence limitations - the input sequence must not contain any ambiguous characters, \r\n * and have a minimum length of 19 amino acids. \r\n * \r\n * @author Peter Troshin\r\n * @version 1.0\r\n * @since 3.0.2\r\n * \r\n */\r\npublic class Jronn {\r\n\t\r\n\t// Load models\r\n\tprivate static final ModelLoader loader = new ModelLoader();  \r\n\tstatic {\r\n\t\ttry {\r\n\t\t\tloader.loadModels();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e); \r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Holder for the ranges, contain pointers to starting and ending position \r\n\t * on the sequence which comprises a disordered region. Immutable. \r\n\t * @author pvtroshin\r\n\t */\r\n\tpublic static class Range {\r\n\t\t/**\r\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\r\n\t\t */\r\n\t\tpublic final int from; \r\n\t\t/**\r\n\t\t * The range ending position includes the last residue. \r\n\t\t */\r\n\t\tpublic final int to; \r\n\t\r\n\t\tpublic final float score;\r\n\t\tpublic Range(int from, int to, float score) {\r\n\t\t\tassert from>=0; \r\n\t\t\tassert from<to; \r\n\t\t\tthis.from = from; \r\n\t\t\tthis.to = to; \r\n\t\t\tthis.score = score;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() { \r\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tfinal int prime = 31;\r\n\t\t\tint result = 1;\r\n\t\t\tresult = prime * result + from;\r\n\t\t\tresult = prime * result + to;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (this == obj)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj == null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (getClass() != obj.getClass())\r\n\t\t\t\treturn false;\r\n\t\t\tRange other = (Range) obj;\r\n\t\t\tif (from != other.from)\r\n\t\t\t\treturn false;\r\n\t\t\tif (to != other.to)\r\n\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\r\n\t\t    return predictSerial(sequence);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(ProteinSequence sequence) {\r\n\t\t\r\n\t\tFastaSequence seq = convertProteinSequencetoFasta(sequence);\r\n\t\t\r\n\t\treturn predictSerial(seq);\r\n\t}\r\n\t\r\n\t/** Utility method to convert a BioJava ProteinSequence object to the FastaSequence \r\n\t *  object used internally in JRonn.\r\n\t * \r\n\t * @param sequence\r\n\t * @return\r\n\t */\r\n\tpublic static FastaSequence convertProteinSequencetoFasta(ProteinSequence sequence){\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tfor (AminoAcidCompound compound : sequence) {\r\n\t\t\t\r\n\t\t\tString c = compound.getShortName();\r\n\t\t\t\r\n\t\t\tif (! SequenceUtil.NON_AA.matcher(c).find()) {\r\n\t\t\t\tbuf.append(c);\r\n\t\t\t} else {\t\t\t\t\r\n\t\t\t\tbuf.append(\"X\");\r\n\t\t\t}\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn new FastaSequence(sequence.getAccession().getID(),buf.toString());\r\n\t}\r\n\r\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\r\n\t\tORonn.validateSequenceForRonn(fsequence);\r\n\t\tORonn ronn;\r\n\t\tfloat[] disorder = null; \r\n\t\ttry {\r\n\t\t\tronn = new ORonn(fsequence, loader);\r\n\t\t\tdisorder = ronn.call().getMeanScores();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t}\r\n\t\treturn disorder;  \r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the \r\n\t * probability of disorder is greater then 0.50.  \r\n\t *  \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then 0.5, null otherwise. \r\n\t *\r\n\t */\r\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\r\n\t\tfloat[] scores = getDisorderScores(sequence);\r\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\r\n\t}\r\n\r\n\t/**\r\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value \r\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.  \r\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then {@code probability}, null otherwise.\r\n\t */\r\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\r\n\t\tassert scores!=null && scores.length>0;\r\n\t\tassert probability>0 && probability<1;\r\n\t\t\r\n\t\tint count=0;\r\n\t\tint regionLen=0;\r\n\t\tList<Range> ranges = new ArrayList<Range>();\r\n\t\tfor(float score: scores) { \r\n\t\t\tcount++;\r\n\t\t\t// Round to 2 decimal points before comparison \r\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\r\n\t\t\tif(score>probability) {\r\n\t\t\t\tregionLen++;\r\n\t\t\t} else {\r\n\t\t\t\tif(regionLen>0) {\r\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1,score));\r\n\t\t\t\t}\r\n\t\t\t\tregionLen=0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// In case of the range to boundary runs to the very end of the sequence \r\n\t\tif(regionLen>1) {\r\n\t\t\tranges.add(new Range(count-regionLen+1, count,scores[scores.length-1]));\r\n\t\t}\r\n\t\treturn ranges.toArray(new Range[ranges.size()]); \t\t\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability of disorder scores for each residue in the sequence for \r\n\t * many sequences in the input.\r\n\t * \r\n\t * @param sequences the list of the FastaSequence objects \r\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\r\n\t\tfor(FastaSequence fsequence : sequences) {\r\n\t\t\tresults.put(fsequence, predictSerial(fsequence));\r\n\t\t}\r\n\t\treturn results; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\r\n\t * \r\n\t * @param sequences sequences the list of the FastaSequence objects\r\n\t * @return\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\r\n\t\tfor(FastaSequence fs: sequences) {\r\n\t\t\tdisorderRanges.put(fs, getDisorder(fs));\r\n\t\t}\r\n\t\treturn disorderRanges; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the protein sequence.\r\n\t * @param fastaFile input file name containing the sequence in FASTA\r\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\r\n\t * @throws FileNotFoundException if the input file cannot be found\r\n\t * @throws IOException of the system cannot access or read from the input file \r\n\t * @see #getDisorder(FastaSequence)\r\n\t * @see #Jronn.Range\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\treturn getDisorder(sequences);\r\n\t}\r\n\t\r\n\t/**\r\n\t * TODO \r\n\t * \r\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\r\n\t *  \r\n\t * @param fastaFile  fully qualified path to the input FASTA file  \r\n\t * @param outputFile file name of the file for the results \r\n\t * @param threadNumber the number of threads to use, default\r\n\t * @param controls the format of the result file \r\n\t * @throws FileNotFoundException if input file in not found \r\n\t * @throws IOException if the input or the output files cannot be accessed  \r\n\t * @see ORonn.ResultLayout\r\n\t \r\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\tInputParameters in = new InputParameters(); \r\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\r\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\r\n\t\t//in.setThreadNum(Integer.toString(threadNumber)); \r\n\t\tORonn.predictParallel(sequences, in, loader); \r\n\t}\r\n\t*/ \r\n}\r\n","changedPro":" /*        BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\npackage org.biojava3.ronn;\r\n\r\n import org.biojava3.core.sequence.ProteinSequence;\r\n import org.biojava3.core.sequence.compound.AminoAcidCompound;\r\n import org.biojava3.data.sequence.FastaSequence;\r\n import org.biojava3.data.sequence.SequenceUtil;\r\n\r\n import java.io.FileInputStream;\r\n import java.io.FileNotFoundException;\r\n import java.io.IOException;\r\n import java.util.ArrayList;\r\n import java.util.List;\r\n import java.util.Map;\r\n import java.util.TreeMap;\r\n\r\n\r\n/**\r\n * This class gives public API to RONN functions. \r\n * It is build on top of the command line client. Due to this fact a few things \r\n * could be improved and extended pending the refactoring of the command line client.  \r\n *\r\n * The input sequence limitations - the input sequence must not contain any ambiguous characters, \r\n * and have a minimum length of 19 amino acids. \r\n * \r\n * @author Peter Troshin\r\n * @version 1.0\r\n * @since 3.0.2\r\n * \r\n */\r\npublic class Jronn {\r\n\t\r\n\t// Load models\r\n\tprivate static final ModelLoader loader = new ModelLoader();  \r\n\tstatic {\r\n\t\ttry {\r\n\t\t\tloader.loadModels();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e); \r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Holder for the ranges, contain pointers to starting and ending position \r\n\t * on the sequence which comprises a disordered region. Immutable. \r\n\t * @author pvtroshin\r\n\t */\r\n\tpublic static class Range {\r\n\t\t/**\r\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\r\n\t\t */\r\n\t\tpublic final int from; \r\n\t\t/**\r\n\t\t * The range ending position includes the last residue. \r\n\t\t */\r\n\t\tpublic final int to; \r\n\t\r\n\t\tpublic final float score;\r\n\t\tpublic Range(int from, int to, float score) {\r\n\t\t\tassert from>=0; \r\n\t\t\tassert from<to; \r\n\t\t\tthis.from = from; \r\n\t\t\tthis.to = to; \r\n\t\t\tthis.score = score;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic String toString() { \r\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int hashCode() {\r\n\t\t\tfinal int prime = 31;\r\n\t\t\tint result = 1;\r\n\t\t\tresult = prime * result + from;\r\n\t\t\tresult = prime * result + to;\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean equals(Object obj) {\r\n\t\t\tif (this == obj)\r\n\t\t\t\treturn true;\r\n\t\t\tif (obj == null)\r\n\t\t\t\treturn false;\r\n\t\t\tif (getClass() != obj.getClass())\r\n\t\t\t\treturn false;\r\n\t\t\tRange other = (Range) obj;\r\n\t\t\tif (from != other.from)\r\n\t\t\t\treturn false;\r\n\t\t\tif (to != other.to)\r\n\t\t\t\treturn false;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\r\n\t\t    return predictSerial(sequence);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability value for each residue in the protein sequence, \r\n\t * telling the probability that the residue belongs to disordered region. \r\n\t * In general, values greater than 0.5 considered to be in the disordered regions. \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence. \r\n\t * @return the probability scores for each residue in the sequence\r\n\t */\r\n\tpublic static float[] getDisorderScores(ProteinSequence sequence) {\r\n\t\t\r\n\t\tFastaSequence seq = convertProteinSequencetoFasta(sequence);\r\n\t\t\r\n\t\treturn predictSerial(seq);\r\n\t}\r\n\t\r\n\t/** Utility method to convert a BioJava ProteinSequence object to the FastaSequence \r\n\t *  object used internally in JRonn.\r\n\t * \r\n\t * @param sequence\r\n\t * @return\r\n\t */\r\n\tpublic static FastaSequence convertProteinSequencetoFasta(ProteinSequence sequence){\r\n\t\tStringBuffer buf = new StringBuffer();\r\n\t\tfor (AminoAcidCompound compound : sequence) {\r\n\t\t\t\r\n\t\t\tString c = compound.getShortName();\r\n\t\t\t\r\n\t\t\tif (! SequenceUtil.NON_AA.matcher(c).find()) {\r\n\t\t\t\tbuf.append(c);\r\n\t\t\t} else {\t\t\t\t\r\n\t\t\t\tbuf.append(\"X\");\r\n\t\t\t}\t\t\t\t\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn new FastaSequence(sequence.getAccession().getID(),buf.toString());\r\n\t}\r\n\r\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\r\n\t\tORonn.validateSequenceForRonn(fsequence);\r\n\t\tORonn ronn;\r\n\t\tfloat[] disorder = null; \r\n\t\ttry {\r\n\t\t\tronn = new ORonn(fsequence, loader);\r\n\t\t\tdisorder = ronn.call().getMeanScores();\r\n\t\t} catch (NumberFormatException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\r\n\t\t}\r\n\t\treturn disorder;  \r\n\t}\r\n\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the \r\n\t * probability of disorder is greater then 0.50.  \r\n\t *  \r\n\t *   \r\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then 0.5, null otherwise. \r\n\t *\r\n\t */\r\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\r\n\t\tfloat[] scores = getDisorderScores(sequence);\r\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\r\n\t}\r\n\r\n\t/**\r\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value \r\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.  \r\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\r\n\t * @return the array of ranges if there are any residues predicted to have the \r\n\t * probability of disorder greater then {@code probability}, null otherwise.\r\n\t */\r\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\r\n\t\tassert scores!=null && scores.length>0;\r\n\t\tassert probability>0 && probability<1;\r\n\t\t\r\n\t\tint count=0;\r\n\t\tint regionLen=0;\r\n\t\tList<Range> ranges = new ArrayList<Range>();\r\n\t\tfor(float score: scores) { \r\n\t\t\tcount++;\r\n\t\t\t// Round to 2 decimal points before comparison \r\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\r\n\t\t\tif(score>probability) {\r\n\t\t\t\tregionLen++;\r\n\t\t\t} else {\r\n\t\t\t\tif(regionLen>0) {\r\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1,score));\r\n\t\t\t\t}\r\n\t\t\t\tregionLen=0;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// In case of the range to boundary runs to the very end of the sequence \r\n\t\tif(regionLen>1) {\r\n\t\t\tranges.add(new Range(count-regionLen+1, count,scores[scores.length-1]));\r\n\t\t}\r\n\t\treturn ranges.toArray(new Range[ranges.size()]); \t\t\r\n\r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the probability of disorder scores for each residue in the sequence for \r\n\t * many sequences in the input.\r\n\t * \r\n\t * @param sequences the list of the FastaSequence objects \r\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\r\n\t\tfor(FastaSequence fsequence : sequences) {\r\n\t\t\tresults.put(fsequence, predictSerial(fsequence));\r\n\t\t}\r\n\t\treturn results; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\r\n\t * \r\n\t * @param sequences sequences the list of the FastaSequence objects\r\n\t * @return\r\n\t * @see #getDisorder(FastaSequence)\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\r\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\r\n\t\tfor(FastaSequence fs: sequences) {\r\n\t\t\tdisorderRanges.put(fs, getDisorder(fs));\r\n\t\t}\r\n\t\treturn disorderRanges; \r\n\t}\r\n\t\r\n\t/**\r\n\t * Calculates the disordered regions of the protein sequence.\r\n\t * @param fastaFile input file name containing the sequence in FASTA\r\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\r\n\t * @throws FileNotFoundException if the input file cannot be found\r\n\t * @throws IOException of the system cannot access or read from the input file \r\n\t * @see #getDisorder(FastaSequence)\r\n\t * @see #Jronn.Range\r\n\t */\r\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\treturn getDisorder(sequences);\r\n\t}\r\n\t\r\n\t/**\r\n\t * TODO \r\n\t * \r\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\r\n\t *  \r\n\t * @param fastaFile  fully qualified path to the input FASTA file  \r\n\t * @param outputFile file name of the file for the results \r\n\t * @param threadNumber the number of threads to use, default\r\n\t * @param controls the format of the result file \r\n\t * @throws FileNotFoundException if input file in not found \r\n\t * @throws IOException if the input or the output files cannot be accessed  \r\n\t * @see ORonn.ResultLayout\r\n\t \r\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\r\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\r\n\t\tInputParameters in = new InputParameters(); \r\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\r\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\r\n\t\t//in.setThreadNum(Integer.toString(threadNumber)); \r\n\t\tORonn.predictParallel(sequences, in, loader); \r\n\t}\r\n\t*/ \r\n}\r\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.ronn;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.ronn.Jronn.Range;\r\nimport org.junit.Test;\r\n\r\n\r\npublic class JronnTest {\r\n\r\n\t@Test\r\n\tpublic void verifyRanges() { \r\n  \r\n\tRange[]\tranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" +\r\n\t\t\t\t\"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" +\r\n\t\t\t\t\"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" +\r\n\t\t\t\t\"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" +\r\n\t\t\t\t\"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\r\n\tassertEquals(4, ranges.length);\r\n\tassertEquals(53, ranges[0].from);\r\n\tassertEquals(59, ranges[0].to); \r\n\t\r\n\tassertEquals(190, ranges[1].from);\r\n\tassertEquals(196, ranges[1].to);\r\n\t\r\n\tassertEquals(210, ranges[2].from);\r\n\tassertEquals(226, ranges[2].to);\r\n\t\r\n\tassertEquals(305, ranges[3].from);\r\n\tassertEquals(313, ranges[3].to);\r\n\t//System.out.println(Arrays.toString(ranges));\r\n\t}\r\n}\r\n","changedTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\npackage org.biojava3.ronn;\r\n\r\nimport org.biojava3.data.sequence.FastaSequence;\r\nimport org.biojava3.ronn.Jronn.Range;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.assertEquals;\r\n\r\n\r\npublic class JronnTest {\r\n\r\n\t@Test\r\n\tpublic void verifyRanges() { \r\n  \r\n\tRange[]\tranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" +\r\n\t\t\t\t\"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" +\r\n\t\t\t\t\"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" +\r\n\t\t\t\t\"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" +\r\n\t\t\t\t\"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\r\n\tassertEquals(4, ranges.length);\r\n\tassertEquals(53, ranges[0].from);\r\n\tassertEquals(59, ranges[0].to); \r\n\t\r\n\tassertEquals(190, ranges[1].from);\r\n\tassertEquals(196, ranges[1].to);\r\n\t\r\n\tassertEquals(210, ranges[2].from);\r\n\tassertEquals(226, ranges[2].to);\r\n\t\r\n\tassertEquals(305, ranges[3].from);\r\n\tassertEquals(313, ranges[3].to);\r\n\t//System.out.println(Arrays.toString(ranges));\r\n\t}\r\n}\r\n","commitMessage":"Ran Optimize Imports across the whole project.\n","test_commitMessage":"Ran Optimize Imports across the whole project.\n","allZero":false}