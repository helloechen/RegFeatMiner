{"repository":"biojava","prod_path":"biojava-sequencing/src/main/java/org/biojava/nbio/sequencing/io/fastq/FastqVariant.java","test_path":"biojava-sequencing/src/test/java/org/biojava/nbio/sequencing/io/fastq/FastqVariantTest.java","prod_time":"2016-03-10 05:51:10","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":5,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":5,"label":"NEGATIVE","prod_commitID":"38934acadf7f82c58dbe223930d87d87ee63f0c0","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.sequencing.io.fastq;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * FASTQ sequence format variant.\n *\n * @since 3.0.3\n */\npublic enum FastqVariant\n{\n\t/** Sanger FASTQ sequence format variant. */\n\tFASTQ_SANGER(\"Original or Sanger format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 93;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn ((int) c) - 33;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tint phredQ = constrain(-10.0d * Math.log10(errorProbability));\n\t\t\treturn phredQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 33);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\treturn Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n\t\t}\n\t},\n\n\t/** Solexa FASTQ sequence format variant. */\n\tFASTQ_SOLEXA(\"Solexa and early Illumina format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn -5;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 62;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn ((int) c) - 64;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tdouble phredQ = -10.0d * Math.log10(errorProbability);\n\t\t\t// eq. 4\n\t\t\tint solexaQ = constrain(10.0d * Math.log10(Math.pow(10.0d, (phredQ/10.0d)) - 1.0d));\n\n\t\t\treturn solexaQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 64);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\tdouble q = Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n\t\t\treturn q / (1.0d + q);\n\t\t}\n\t},\n\n\t/** Illumina FASTQ sequence format variant. */\n\tFASTQ_ILLUMINA(\"Illumina 1.3+ format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 62;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn ((int) c) - 64;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tint phredQ = constrain(-10.0d * Math.log10(errorProbability));\n\t\t\treturn phredQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 64);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\treturn Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n\t\t}\n\t};\n\n\n\t/** Map of FASTQ sequence format variants keyed by name and lowercase-with-dashes name. */\n\tprivate static final Map<String, FastqVariant> FASTQ_VARIANTS = new HashMap<String, FastqVariant>(6);\n\n\tstatic\n\t{\n\t\tfor (FastqVariant fastqVariant : values())\n\t\t{\n\t\t\tFASTQ_VARIANTS.put(fastqVariant.name(), fastqVariant);\n\t\t\tFASTQ_VARIANTS.put(fastqVariant.lowercaseName(), fastqVariant);\n\t\t}\n\t}\n\n\t/** Description of this FASTQ sequence format variant. */\n\tprivate final String description;\n\n\n\t/**\n\t * Create a new FASTQ sequence format variant with the specified description.\n\t *\n\t * @param description description of this FASTQ sequence format variant, must not be null\n\t */\n\tprivate FastqVariant(final String description)\n\t{\n\t\tif (description == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"description must not be null\");\n\t\t}\n\t\tthis.description = description;\n\t}\n\n\n\t/**\n\t * Return the description of this FASTQ sequence format variant.\n\t * The description will not be null.\n\t *\n\t * @return the description of this FASTQ sequence format variant\n\t */\n\tpublic String getDescription()\n\t{\n\t\treturn description;\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}\n\t */\n\tpublic boolean isSanger()\n\t{\n\t\treturn (this == FASTQ_SANGER);\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}\n\t */\n\tpublic boolean isSolexa()\n\t{\n\t\treturn (this == FASTQ_SOLEXA);\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}\n\t */\n\tpublic boolean isIllumina()\n\t{\n\t\treturn (this == FASTQ_ILLUMINA);\n\t}\n\n\t/**\n\t * Return the minimum quality score for this FASTQ sequence format variant.\n\t *\n\t * @return the minimum quality score for this FASTQ sequence format variant.\n\t */\n\tpublic abstract int minimumQualityScore();\n\n\t/**\n\t * Return the maximum quality score for this FASTQ sequence format variant.\n\t *\n\t * @return the maximum quality score for this FASTQ sequence format variant.\n\t */\n\tpublic abstract int maximumQualityScore();\n\n\t/**\n\t * Convert the specified quality in ASCII format to a quality score.\n\t *\n\t * @param c quality in ASCII format\n\t * @return the specified quality in ASCII format converted to a quality score\n\t */\n\tpublic abstract int qualityScore(char c);\n\n\t/**\n\t * Convert the specified error probability to a quality score.\n\t *\n\t * @since 4.2\n\t * @param errorProbability error probability\n\t * @return the specified error probability converted to a quality score\n\t */\n\tpublic abstract int qualityScore(double errorProbability);\n\n\t/**\n\t * Convert the specified quality score to a quality in ASCII format.\n\t *\n\t * @since 3.0.6\n\t * @param qualityScore quality score, must be <code>&gt;= minimumQualityScore()</code>\n\t *    and <code>&lt;= maximumQualityScore()</code>\n\t * @return the quality in ASCII format converted from the specified quality score\n\t */\n\tpublic abstract char quality(int qualityScore);\n\n\t/**\n\t * Convert the specified quality in ASCII format to an error probability.\n\t *\n\t * @param c quality in ASCII format\n\t * @return the specified quality in ASCII format converted to an error probability\n\t */\n\tpublic double errorProbability(char c)\n\t{\n\t\treturn errorProbability(qualityScore(c));\n\t}\n\n\t/**\n\t * Calculate the error probability given the specified quality score.\n\t *\n\t * @param qualityScore quality score\n\t * @return the error probability given the specified quality score\n\t */\n\tpublic abstract double errorProbability(int qualityScore);\n\n\t/**\n\t * Return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style.\n\t *\n\t * @return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style\n\t */\n\tpublic String lowercaseName()\n\t{\n\t\treturn name().toLowerCase().replace('_', '-');\n\t}\n\n\t/**\n\t * Constrain the specified quality score in double precision to the minimum and maximum quality\n\t * scores in int precision.\n\t *\n\t * @since 4.2\n\t * @param qualityScore quality score in double precision\n\t * @return the specified quality score in double precision constrained to the minimum and maximum quality\n\t *    scores in int precision\n\t */\n\tprotected int constrain(final double qualityScore)\n\t{\n\t\t// ick.\n\t\treturn Math.min(maximumQualityScore(), Math.max(minimumQualityScore(), Math.round((float) qualityScore)));\n\t}\n\n\t/**\n\t * Return the FASTQ sequence format variant with the specified name, if any.  The name may\n\t * be specified in either <code>UPPERCASE_WITH_UNDERSCORES</code>\n\t * or <code>lowercase-with-dashes</code> style.\n\t *\n\t * @param name name\n\t * @return the FASTQ sequence format variant with the specified name, or <code>null</code>\n\t *    if no such FASTQ sequence format variant exists\n\t */\n\tpublic static FastqVariant parseFastqVariant(final String name)\n\t{\n\t\treturn FASTQ_VARIANTS.get(name);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.sequencing.io.fastq;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * FASTQ sequence format variant.\n *\n * @since 3.0.3\n */\npublic enum FastqVariant\n{\n\t/** Sanger FASTQ sequence format variant. */\n\tFASTQ_SANGER(\"Original or Sanger format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 93;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn (c) - 33;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tint phredQ = constrain(-10.0d * Math.log10(errorProbability));\n\t\t\treturn phredQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 33);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\treturn Math.pow(10.0d, (qualityScore) / -10.0d);\n\t\t}\n\t},\n\n\t/** Solexa FASTQ sequence format variant. */\n\tFASTQ_SOLEXA(\"Solexa and early Illumina format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn -5;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 62;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn (c) - 64;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tdouble phredQ = -10.0d * Math.log10(errorProbability);\n\t\t\t// eq. 4\n\t\t\tint solexaQ = constrain(10.0d * Math.log10(Math.pow(10.0d, (phredQ/10.0d)) - 1.0d));\n\n\t\t\treturn solexaQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 64);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\tdouble q = Math.pow(10.0d, (qualityScore) / -10.0d);\n\t\t\treturn q / (1.0d + q);\n\t\t}\n\t},\n\n\t/** Illumina FASTQ sequence format variant. */\n\tFASTQ_ILLUMINA(\"Illumina 1.3+ format\")\n\t{\n\t\t@Override\n\t\tpublic int minimumQualityScore()\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic int maximumQualityScore()\n\t\t{\n\t\t\treturn 62;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final char c)\n\t\t{\n\t\t\treturn (c) - 64;\n\t\t}\n\n\t\t@Override\n\t\tpublic int qualityScore(final double errorProbability)\n\t\t{\n\t\t\t// eq. 2\n\t\t\tint phredQ = constrain(-10.0d * Math.log10(errorProbability));\n\t\t\treturn phredQ;\n\t\t}\n\n\t\t@Override\n\t\tpublic char quality(final int qualityScore)\n\t\t{\n\t\t\tif (qualityScore < minimumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n\t\t\t}\n\t\t\tif (qualityScore > maximumQualityScore())\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n\t\t\t}\n\t\t\treturn (char) (qualityScore + 64);\n\t\t}\n\n\t\t@Override\n\t\tpublic double errorProbability(final int qualityScore)\n\t\t{\n\t\t\treturn Math.pow(10.0d, (qualityScore) / -10.0d);\n\t\t}\n\t};\n\n\n\t/** Map of FASTQ sequence format variants keyed by name and lowercase-with-dashes name. */\n\tprivate static final Map<String, FastqVariant> FASTQ_VARIANTS = new HashMap<String, FastqVariant>(6);\n\n\tstatic\n\t{\n\t\tfor (FastqVariant fastqVariant : values())\n\t\t{\n\t\t\tFASTQ_VARIANTS.put(fastqVariant.name(), fastqVariant);\n\t\t\tFASTQ_VARIANTS.put(fastqVariant.lowercaseName(), fastqVariant);\n\t\t}\n\t}\n\n\t/** Description of this FASTQ sequence format variant. */\n\tprivate final String description;\n\n\n\t/**\n\t * Create a new FASTQ sequence format variant with the specified description.\n\t *\n\t * @param description description of this FASTQ sequence format variant, must not be null\n\t */\n\tprivate FastqVariant(final String description)\n\t{\n\t\tif (description == null)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"description must not be null\");\n\t\t}\n\t\tthis.description = description;\n\t}\n\n\n\t/**\n\t * Return the description of this FASTQ sequence format variant.\n\t * The description will not be null.\n\t *\n\t * @return the description of this FASTQ sequence format variant\n\t */\n\tpublic String getDescription()\n\t{\n\t\treturn description;\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}\n\t */\n\tpublic boolean isSanger()\n\t{\n\t\treturn (this == FASTQ_SANGER);\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}\n\t */\n\tpublic boolean isSolexa()\n\t{\n\t\treturn (this == FASTQ_SOLEXA);\n\t}\n\n\t/**\n\t * Return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}.\n\t *\n\t * @return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}\n\t */\n\tpublic boolean isIllumina()\n\t{\n\t\treturn (this == FASTQ_ILLUMINA);\n\t}\n\n\t/**\n\t * Return the minimum quality score for this FASTQ sequence format variant.\n\t *\n\t * @return the minimum quality score for this FASTQ sequence format variant.\n\t */\n\tpublic abstract int minimumQualityScore();\n\n\t/**\n\t * Return the maximum quality score for this FASTQ sequence format variant.\n\t *\n\t * @return the maximum quality score for this FASTQ sequence format variant.\n\t */\n\tpublic abstract int maximumQualityScore();\n\n\t/**\n\t * Convert the specified quality in ASCII format to a quality score.\n\t *\n\t * @param c quality in ASCII format\n\t * @return the specified quality in ASCII format converted to a quality score\n\t */\n\tpublic abstract int qualityScore(char c);\n\n\t/**\n\t * Convert the specified error probability to a quality score.\n\t *\n\t * @since 4.2\n\t * @param errorProbability error probability\n\t * @return the specified error probability converted to a quality score\n\t */\n\tpublic abstract int qualityScore(double errorProbability);\n\n\t/**\n\t * Convert the specified quality score to a quality in ASCII format.\n\t *\n\t * @since 3.0.6\n\t * @param qualityScore quality score, must be <code>&gt;= minimumQualityScore()</code>\n\t *    and <code>&lt;= maximumQualityScore()</code>\n\t * @return the quality in ASCII format converted from the specified quality score\n\t */\n\tpublic abstract char quality(int qualityScore);\n\n\t/**\n\t * Convert the specified quality in ASCII format to an error probability.\n\t *\n\t * @param c quality in ASCII format\n\t * @return the specified quality in ASCII format converted to an error probability\n\t */\n\tpublic double errorProbability(char c)\n\t{\n\t\treturn errorProbability(qualityScore(c));\n\t}\n\n\t/**\n\t * Calculate the error probability given the specified quality score.\n\t *\n\t * @param qualityScore quality score\n\t * @return the error probability given the specified quality score\n\t */\n\tpublic abstract double errorProbability(int qualityScore);\n\n\t/**\n\t * Return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style.\n\t *\n\t * @return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style\n\t */\n\tpublic String lowercaseName()\n\t{\n\t\treturn name().toLowerCase().replace('_', '-');\n\t}\n\n\t/**\n\t * Constrain the specified quality score in double precision to the minimum and maximum quality\n\t * scores in int precision.\n\t *\n\t * @since 4.2\n\t * @param qualityScore quality score in double precision\n\t * @return the specified quality score in double precision constrained to the minimum and maximum quality\n\t *    scores in int precision\n\t */\n\tprotected int constrain(final double qualityScore)\n\t{\n\t\t// ick.\n\t\treturn Math.min(maximumQualityScore(), Math.max(minimumQualityScore(), Math.round((float) qualityScore)));\n\t}\n\n\t/**\n\t * Return the FASTQ sequence format variant with the specified name, if any.  The name may\n\t * be specified in either <code>UPPERCASE_WITH_UNDERSCORES</code>\n\t * or <code>lowercase-with-dashes</code> style.\n\t *\n\t * @param name name\n\t * @return the FASTQ sequence format variant with the specified name, or <code>null</code>\n\t *    if no such FASTQ sequence format variant exists\n\t */\n\tpublic static FastqVariant parseFastqVariant(final String name)\n\t{\n\t\treturn FASTQ_VARIANTS.get(name);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.sequencing.io.fastq;\n\nimport junit.framework.TestCase;\n\nimport static org.biojava.nbio.sequencing.io.fastq.FastqVariant.*;\n\n/**\n * Unit test for FastqVariant.\n */\npublic final class FastqVariantTest\n\textends TestCase\n{\n\n\tpublic void testDescription()\n\t{\n\t\tfor (FastqVariant variant : values())\n\t\t{\n\t\t\tassertNotNull(variant.getDescription());\n\t\t}\n\t}\n\n\tpublic void testIsSanger()\n\t{\n\t\tassertTrue(FASTQ_SANGER.isSanger());\n\t\tassertFalse(FASTQ_SOLEXA.isSanger());\n\t\tassertFalse(FASTQ_ILLUMINA.isSanger());\n\t}\n\n\tpublic void testIsSolexa()\n\t{\n\t\tassertFalse(FASTQ_SANGER.isSolexa());\n\t\tassertTrue(FASTQ_SOLEXA.isSolexa());\n\t\tassertFalse(FASTQ_ILLUMINA.isSolexa());\n\t}\n\n\tpublic void testIsIllumina()\n\t{\n\t\tassertFalse(FASTQ_SANGER.isIllumina());\n\t\tassertFalse(FASTQ_SOLEXA.isIllumina());\n\t\tassertTrue(FASTQ_ILLUMINA.isIllumina());\n\t}\n\n\tpublic void testParseFastqVariant()\n\t{\n\t\tassertEquals(null, parseFastqVariant(null));\n\t\tassertEquals(null, parseFastqVariant(\"\"));\n\t\tassertEquals(null, parseFastqVariant(\"not a valid FASTQ variant\"));\n\t\tassertEquals(FASTQ_SANGER, parseFastqVariant(\"FASTQ_SANGER\"));\n\t\tassertEquals(FASTQ_SANGER, parseFastqVariant(\"fastq-sanger\"));\n\t}\n\n\tpublic void testQualityLessThanMinimumQualityScore()\n\t{\n\t\tfor (FastqVariant variant : values())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvariant.quality(variant.minimumQualityScore() - 1);\n\t\t\t\tfail(\"expected IllegalArgumentException\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException e)\n\t\t\t{\n\t\t\t\t// expected\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testQualityMoreThanMaximumQualityScore()\n\t{\n\t\tfor (FastqVariant variant : values())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvariant.quality(variant.maximumQualityScore() + 1);\n\t\t\t\tfail(\"expected IllegalArgumentException\");\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException e)\n\t\t\t{\n\t\t\t\t// expected\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testQualityQualityScoreRoundTrip()\n\t{\n\t\tfor (FastqVariant variant : values())\n\t\t{\n\t\t\tfor (int i = variant.minimumQualityScore(); i < (variant.maximumQualityScore() + 1); i++)\n\t\t\t{\n\t\t\t\tassertEquals(i, variant.qualityScore(variant.quality(i)));\n\t\t\t}\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Removing unnecessary casts","test_commitMessage":"","allZero":false}