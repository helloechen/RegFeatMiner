{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitExtractor.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitExtractor.java","prod_time":"2018-09-25 02:00:32","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"5377a9872ced428d3b2483c832088d4d7fa8680e","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.structure.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * The SubunitExtractor extracts the information of each protein {@link Chain}\n * in a {@link Structure} and converts them into a List of {@link Subunit}.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitExtractor {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitExtractor.class);\n\n\t/** Prevent instantiation **/\n\tprivate SubunitExtractor() {\n\t}\n\n\t/**\n\t * Extract the information of each protein Chain in a Structure and converts\n\t * them into a List of Subunit. The name of the Subunits is set to the\n\t * {@link Chain#getName()}.\n\t * \n\t * \n\t * @param structure\n\t *            Structure object with protein Chains\n\t * @param absMinLen\n\t *            {@link SubunitClustererParameters#getAbsoluteMinimumSequenceLength()}\n\t * @param fraction\n\t *            {@link SubunitClustererParameters#getMinimumSequenceLengthFraction()}\n\t * @param minLen\n\t *            {@link SubunitClustererParameters#getMinimumSequenceLength()}\n\t * @return List of Subunits\n\t */\n\tpublic static List<Subunit> extractSubunits(Structure structure,\n\t\t\tint absMinLen, double fraction, int minLen) {\n\n\t\t// The extracted subunit container\n\t\tList<Subunit> subunits = new ArrayList<Subunit>();\n\n\t\tfor (Chain c : structure.getPolyChains()) {\n\t\t\t// Only take protein chains\n\t\t\tif (c.isProtein()) {\n\t\t\t\tAtom[] ca = StructureTools.getRepresentativeAtomArray(c);\n\t\t\t\tlogger.debug(\"Chain \" + c.getId() + \"; CA Atoms: \" + ca.length + \"; SEQRES: \" + c.getSeqResSequence());\n\t\t\t\tif (ca.length==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tsubunits.add(new Subunit(ca, c.getId(), null, structure));\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the minimum length of a Subunit\n\t\tint adjustedMinLen = calcAdjustedMinimumSequenceLength(subunits,\n\t\t\t\tabsMinLen, fraction, minLen);\n\t\tlogger.debug(\"Adjusted minimum sequence length: \" + adjustedMinLen);\n\n\t\t// Filter out short Subunits\n\t\tfor (int s = subunits.size() - 1; s >= 0; s--) {\n\t\t\tif (subunits.get(s).size() < adjustedMinLen)\n\t\t\t\tsubunits.remove(s);\n\t\t}\n\n\t\treturn subunits;\n\t}\n\n\t/**\n\t * Returns an adapted minimum sequence length. This method ensure that\n\t * structure that only have short chains are not excluded by the\n\t * minimumSequenceLength cutoff value.\n\t * \n\t * @return adjustedMinimumSequenceLength\n\t */\n\tprivate static int calcAdjustedMinimumSequenceLength(\n\t\t\tList<Subunit> subunits, int absMinLen, double fraction, int minLen) {\n\n\t\tint maxLength = Integer.MIN_VALUE;\n\t\tint minLength = Integer.MAX_VALUE;\n\n\t\t// Extract the length List, the min and the max\n\t\tList<Integer> lengths = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < subunits.size(); i++) {\n\t\t\tif (subunits.get(i).size() >= absMinLen) {\n\t\t\t\tmaxLength = Math.max(subunits.get(i).size(), maxLength);\n\t\t\t\tminLength = Math.min(subunits.get(i).size(), minLength);\n\t\t\t\tlengths.add(subunits.get(i).size());\n\n\t\t\t}\n\t\t}\n\n\t\tint adjustedMinimumSequenceLength = minLen;\n\n\t\tif (lengths.size() < 2)\n\t\t\treturn adjustedMinimumSequenceLength;\n\n\t\t// Calculate the median of the lengths\n\t\tdouble median = 0;\n\t\tCollections.sort(lengths);\n\t\tif (lengths.size() % 2 == 1) {\n\t\t\tint middle = (lengths.size() - 1) / 2;\n\t\t\tmedian = lengths.get(middle);\n\t\t} else {\n\t\t\tint middle2 = lengths.size() / 2;\n\t\t\tint middle1 = middle2 - 1;\n\t\t\tmedian = 0.5 * (lengths.get(middle1) + lengths.get(middle2));\n\t\t}\n\n\t\t// If the median * fraction is lower than the minLength\n\t\tif (minLength >= median * fraction) {\n\t\t\tadjustedMinimumSequenceLength = Math.min(minLength, minLen);\n\t\t}\n\n\t\treturn adjustedMinimumSequenceLength;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.structure.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * The SubunitExtractor extracts the information of each protein {@link Chain}\n * in a {@link Structure} and converts them into a List of {@link Subunit}.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitExtractor {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitExtractor.class);\n\n\t/** Prevent instantiation **/\n\tprivate SubunitExtractor() {\n\t}\n\n\t/**\n\t * Extract the information of each protein Chain in a Structure and converts\n\t * them into a List of Subunit. The name of the Subunits is set to\n\t * {@link Chain#getId()}.\n\t * \n\t * \n\t * @param structure\n\t *            Structure object with protein Chains\n\t * @param absMinLen\n\t *            {@link SubunitClustererParameters#getAbsoluteMinimumSequenceLength()}\n\t * @param fraction\n\t *            {@link SubunitClustererParameters#getMinimumSequenceLengthFraction()}\n\t * @param minLen\n\t *            {@link SubunitClustererParameters#getMinimumSequenceLength()}\n\t * @return List of Subunits\n\t */\n\tpublic static List<Subunit> extractSubunits(Structure structure,\n\t\t\tint absMinLen, double fraction, int minLen) {\n\n\t\t// The extracted subunit container\n\t\tList<Subunit> subunits = new ArrayList<Subunit>();\n\n\t\tfor (Chain c : structure.getPolyChains()) {\n\t\t\t// Only take protein chains\n\t\t\tif (c.isProtein()) {\n\t\t\t\tAtom[] ca = StructureTools.getRepresentativeAtomArray(c);\n\t\t\t\tlogger.debug(\"Chain \" + c.getId() + \"; CA Atoms: \" + ca.length + \"; SEQRES: \" + c.getSeqResSequence());\n\t\t\t\tif (ca.length==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tsubunits.add(new Subunit(ca, c.getId(), null, structure));\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the minimum length of a Subunit\n\t\tint adjustedMinLen = calcAdjustedMinimumSequenceLength(subunits,\n\t\t\t\tabsMinLen, fraction, minLen);\n\t\tlogger.debug(\"Adjusted minimum sequence length: \" + adjustedMinLen);\n\n\t\t// Filter out short Subunits\n\t\tfor (int s = subunits.size() - 1; s >= 0; s--) {\n\t\t\tif (subunits.get(s).size() < adjustedMinLen)\n\t\t\t\tsubunits.remove(s);\n\t\t}\n\n\t\treturn subunits;\n\t}\n\n\t/**\n\t * Returns an adapted minimum sequence length. This method ensure that\n\t * structure that only have short chains are not excluded by the\n\t * minimumSequenceLength cutoff value.\n\t * \n\t * @return adjustedMinimumSequenceLength\n\t */\n\tprivate static int calcAdjustedMinimumSequenceLength(\n\t\t\tList<Subunit> subunits, int absMinLen, double fraction, int minLen) {\n\n\t\tint maxLength = Integer.MIN_VALUE;\n\t\tint minLength = Integer.MAX_VALUE;\n\n\t\t// Extract the length List, the min and the max\n\t\tList<Integer> lengths = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < subunits.size(); i++) {\n\t\t\tif (subunits.get(i).size() >= absMinLen) {\n\t\t\t\tmaxLength = Math.max(subunits.get(i).size(), maxLength);\n\t\t\t\tminLength = Math.min(subunits.get(i).size(), minLength);\n\t\t\t\tlengths.add(subunits.get(i).size());\n\n\t\t\t}\n\t\t}\n\n\t\tint adjustedMinimumSequenceLength = minLen;\n\n\t\tif (lengths.size() < 2)\n\t\t\treturn adjustedMinimumSequenceLength;\n\n\t\t// Calculate the median of the lengths\n\t\tdouble median = 0;\n\t\tCollections.sort(lengths);\n\t\tif (lengths.size() % 2 == 1) {\n\t\t\tint middle = (lengths.size() - 1) / 2;\n\t\t\tmedian = lengths.get(middle);\n\t\t} else {\n\t\t\tint middle2 = lengths.size() / 2;\n\t\t\tint middle1 = middle2 - 1;\n\t\t\tmedian = 0.5 * (lengths.get(middle1) + lengths.get(middle2));\n\t\t}\n\n\t\t// If the median * fraction is lower than the minLength\n\t\tif (minLength >= median * fraction) {\n\t\t\tadjustedMinimumSequenceLength = Math.min(minLength, minLen);\n\t\t}\n\n\t\treturn adjustedMinimumSequenceLength;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.junit.Test;\n\n/**\n * Test the {@link SubunitExtractor} correctness on different real structures\n * with different types of difficulties.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSubunitExtractor {\n\n\t/**\n\t * Some collagen structures have very short Chains, so the minimum sequence\n\t * length is adjusted: 1A3I.\n\t * \n\t * @see SubunitClustererParameters#getMinimumSequenceLengthFraction()\n\t */\n\t@Test\n\tpublic void testCollagen() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"1A3I\");\n\n\t\tList<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n\n\t\t// We expect all 3 subunits to be returned\n\t\tassertEquals(subunits.size(), 3);\n\n\t\tsubunits = SubunitExtractor.extractSubunits(s, 8, 0.75, 9);\n\n\t\t// Now we expect only the long Subunit to be returned\n\t\tassertEquals(subunits.size(), 1);\n\t\tassertEquals(subunits.get(0).size(), 9);\n\t}\n\n\t/**\n\t * Make sure that only aminoacid chains are extracted: 5B2I.\n\t */\n\t@Test\n\tpublic void testHistone() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"5B2I\");\n\n\t\tList<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n\n\t\t// We expect all 8 histone subunits to be returned\n\t\tassertEquals(subunits.size(), 8);\n\t\tassertEquals(subunits.get(0).size(), 99);\n\t\tassertEquals(subunits.get(1).size(), 82);\n\t\tassertEquals(subunits.get(2).size(), 106);\n\t}\n\n\t/**\n\t * Test that all chains from biological assemblies are extracted.\n\t */\n\t@Test\n\tpublic void testBioAssembly() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"BIO:4E3E:1\");\n\n\t\tList<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n\n\t\t// We expect all 3 equal double hot-dog subunits to be returned\n\t\tassertEquals(subunits.size(), 3);\n\t\tassertEquals(subunits.get(0).size(), subunits.get(1).size());\n\t\tassertEquals(subunits.get(0).size(), subunits.get(2).size());\n\t}\n}\n","changedTest":"","commitMessage":"Docs\n","test_commitMessage":"","allZero":true}