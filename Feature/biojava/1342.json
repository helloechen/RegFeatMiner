{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/Structure.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/StructureTest.java","prod_time":"2011-05-25 08:19:48","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"7dd7523d21de96b6a2cfa95ac422c358ac22127e","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.io.FileConvert;\nimport org.biojava.bio.structure.io.PDBFileReader;\n\n\n/**\n *\n * Interface for a structure object. Provides access to the data of a PDB file.\n *\n * A structure object allows to access the PDB header information as well\n * as to the data from the ATOM records. The header information is\n * currently available through the following objects:\n * <ul>\n * <li>{@link PDBHeader}</li>\n * <li>{@link DBRef}</li>\n * <li>{@link Compound}</li>\n * </ul>\n *\n * The structure object provides access to the data from the ATOM records through\n * a hierarchy of sub-object:\n * <pre>\n * Structure\n *         |\n *         {@link Chain}\n *             |\n *             {@link Group}\n *                 |\n *                 {@link Atom}\n * </pre>\n *\n * For more documentation on how to work with the Structure API please\n * see <a href=\"http://biojava.org/wiki/BioJava:CookBook#Protein_Structure\" target=\"_top\">\n * http://biojava.org/wiki/BioJava:CookBook#Protein_Structure</a>\n *\n *\n *\n *\n<hr/>\n</hr>\n * <p>\n * Q: How can I get a Structure object from a PDB file?\n * </p>\n * <p>\n * A:\n </p>\n * <pre>\npublic {@link Structure} loadStructure(String pathToPDBFile){\n\t\t{@link PDBFileReader} pdbreader = new {@link PDBFileReader}();\n\n\t\t{@link Structure} structure = null;\n\t\ttry{\n\t\t\tstructure = pdbreader.getStructure(pathToPDBFile);\n\t\t\tSystem.out.println(structure);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn structure;\n\t}\n </pre>\n\n<hr>\n</hr>\n<p>\nQ: How can I calculate Phi and Psi angles of AminoAcids?\n</p>\n<p>\nA:\n</p>\n<pre>\npublic void calcPhiPsi({@link Structure} structure){\n\n\n\t\t// get the first chain from the structure\n\n\t\t{@link Chain} chain  = structure.getChain(0);\n\n\t\t// A protein chain consists of a number of groups. These can be either\n\t\t// {@link AminoAcid}, {@link HetatomImpl Hetatom} or {@link NucleotideImpl Nucleotide} groups.\n\t\t//\n\t\t// Note: BioJava provides access to both the ATOM and SEQRES data in a PDB file.\n\t\t// since we are interested in doing calculations here, we only request the groups\n\t\t// from the ATOM records\n\n\t\t//  get the Groups of the chain that are AminoAcids.\n\t\tList<Group> groups = chain.getAtomGroups(\"amino\");\n\n\t\t{@link AminoAcid} a;\n\t\t{@link AminoAcid} b;\n\t\t{@link AminoAcid} c ;\n\n\t\tfor ( int i=0; i < groups.size(); i++){\n\n\t\t\t// since we requested only groups of type \"amino\" they will always be amino acids\n\t\t\t// Nucleotide and Hetatom groups will not be present in the groups list.\n\n\t\t\tb = ({@link AminoAcid})groups.get(i);\n\n\t\t\tdouble phi =360.0;\n\t\t\tdouble psi =360.0;\n\n\t\t\tif ( i > 0) {\n\t\t\t\ta = ({@link AminoAcid})groups.get(i-1) ;\n\t\t\t\ttry {\n\n\t\t\t\t\t// the Calc class provides utility methods for various calculations on\n\t\t\t\t\t// structures, groups and atoms\n\n\t\t\t\t\tphi = {@link Calc}.getPhi(a,b);\n\t\t\t\t} catch ({@link StructureException} e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tphi = 360.0 ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( i < groups.size()-1) {\n\t\t\t\tc = ({@link AminoAcid})groups.get(i+1) ;\n\t\t\t\ttry {\n\t\t\t\t\tpsi = {@link Calc}.getPsi(b,c);\n\t\t\t\t}catch ({@link StructureException} e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tpsi = 360.0 ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.print(b.getPDBCode() + \" \" + b.getPDBName() + \":\"  );\n\n\t\t\tSystem.out.println(String.format(\"\\tphi: %+7.2f psi: %+7.2f\", phi, psi));\n\n\t\t}\n</pre>\n<hr>\n</hr>\n\n *\n *\n *\n * @author Andreas Prlic\n * @since 1.4\n * @version %I% %G%\n */\npublic interface Structure extends Cloneable{\n\n\n\t/** returns an identical copy of this Structure object\n\t *\n\t * @return identical copy of this Structure object\n\t */\n\tpublic Structure clone();\n\n    /**\n     * String representation of object.\n     */\n    public String toString();\n\n    /**\n     *\n     * set PDB code of structure .\n     *\n     * @param pdb_id  a String specifying the PDBCode\n     * @see #getPDBCode\n     *\n     */\n    public void setPDBCode (String pdb_id) ;\n\n    /**\n     *\n     * get PDB code of structure.\n     *\n     * @return a String representing the PDBCode value\n     * @see #setPDBCode\n     */\n    public String  getPDBCode () ;\n\n    /** set biological name of Structure .\n     *\n     * @param name  a String specifying the biological name of the Structure\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /** get biological name of Structure.\n     *\n     * @return a String representing the biological name of the Structure\n     * @see #setName\n     */\n    public String getName();\n\n    /** set the Header data .\n     *\n     * @param h  a Map object specifying the header\n     * @see #getHeader\n     */\n    public void setHeader(Map<String,Object> h) ;\n\n    /** get Header data .\n     *\n     * @return a Map object representing the header value\n     * @see #setHeader\n     * @deprecated use getPDBHeader instead\n     * @see #getPDBHeader\n     */\n    public Map<String,Object> getHeader() ;\n\n    /**\n       sets/gets an List of  Maps which corresponds to the CONECT lines in the PDB file:\n\n       <pre>\n       COLUMNS         DATA TYPE        FIELD           DEFINITION\n       ---------------------------------------------------------------------------------\n        1 -  6         Record name      \"CONECT\"\n        7 - 11         Integer          serial          Atom serial number\n       12 - 16         Integer          serial          Serial number of bonded atom\n       17 - 21         Integer          serial          Serial number of bonded atom\n       22 - 26         Integer          serial          Serial number of bonded atom\n       27 - 31         Integer          serial          Serial number of bonded atom\n       32 - 36         Integer          serial          Serial number of hydrogen bonded\n       atom\n       37 - 41         Integer          serial          Serial number of hydrogen bonded\n       atom\n       42 - 46         Integer          serial          Serial number of salt bridged\n       atom\n       47 - 51         Integer          serial          Serial number of hydrogen bonded\n       atom\n       52 - 56         Integer          serial          Serial number of hydrogen bonded\n       atom\n       57 - 61         Integer          serial          Serial number of salt bridged\n       atom\n       </pre>\n\n       the HashMap for a single CONECT line contains the following fields:\n\n       <li> atomserial (mandatory) : Atom serial number</li>\n       <li> bond1 .. bond4 (optional): Serial number of bonded atom</li>\n       <li> hydrogen1 .. hydrogen4 (optional):Serial number of hydrogen bonded atom</li>\n       <li> salt1 .. salt2 (optional): Serial number of salt bridged atom</li>\n\n       *\n       * @param connections  a List object specifying the connections\n       * @see #getConnections\n    */\n    public void setConnections(List<Map<String,Integer>> connections);\n\n    /**\n     * Returns the connections value.\n     * @return a List object representing the connections value\n     * @see #setConnections\n     */\n    public List<Map<String,Integer>> getConnections();\n\n    /** return number of Chains in this Structure.\n     * @return an int representing the number of Chains in this Structure\n     */\n    public int size() ;\n\n    /** return number of chains of model.\n    *\n    * @param modelnr  an int specifying the number of the Model that should be used\n    * @return an int representing the number of Chains in this Model\n    */\n    public int size(int modelnr);\n\n    /** return number of models .\n     * in this implementation also XRAY structures have \"1 model\", since\n     * model is the container for the chains.\n     * to test if a Structure is an NMR structure use @see isNMR ,\n     * since this is based on the info in the PDB file header.\n     *\n     * @return an int representing the number of models in this Structure\n     */\n    public int nrModels() ;\n\n    /** test if this structure is an nmr structure.\n     *\n     * @return true if this Structure has been resolved by NMR\n     */\n    public boolean isNmr() ;\n\n    /** set NMR flag.\n     *\n     * @param nmr  true to declare that this Structure has been solved by NMR.\n     */\n    public void setNmr(boolean nmr);\n\n\n    /** add a new model.\n     *\n     * @param model  a List object containing the Chains of the new Model\n     */\n    public void addModel(List<Chain> model);\n\n\n    /** a convenience function if one wants to edit and replace the\n     * models in a structure. allows to set (replace) the model at position\n     * with the new List of Chains.\n     * @param position starting at 0\n     * @param model\n     */\n    public void setModel(int position, List<Chain> model);\n\n    /** retrieve all Chains belonging to a model .\n     * @see #getChains(int modelnr)\n     *\n     * @param modelnr  an int\n     * @return a List object containing the Chains of Model nr. modelnr\n\n     */\n    public List<Chain> getModel(int modelnr);\n\n    /** retrieve all chains - if it is a NMR structure will return the chains of the first model.\n     * This is the same as getChains(0);\n     * @see #getModel(int modelnr)\n     * @see #getChains(int modelnr)\n     *\n     * @return a List object containing the Chains of Model nr. modelnr\n     */\n    public List<Chain> getChains();\n\n\n    /** set the chains of a structure, if this is a NMR structure,\n     * this will only set model 0.\n     *\n     * @see #setChains(int, List)\n     *\n     * @param chains the list of chains for this structure.\n     */\n    public void setChains(List<Chain> chains);\n\n    /** retrieve all chains of a model.\n     * @see #getModel\n     *\n     * @param modelnr  an int\n     * @return a List object containing the Chains of Model nr. modelnr\n     */\n    public List<Chain> getChains(int modelnr);\n\n    /** set the chains for a model\n     * @param chains\n     * @param modelnr\n     */\n    public void setChains( int modelnr, List<Chain> chains);\n\n    /** add a new chain.\n     *\n     * @param chain  a Chain object\n     */\n    public void addChain(Chain chain);\n\n    /** add a new chain, if several models are available.\n     *\n     * @param chain    a Chain object\n     * @param modelnr  an int specifying to which model the Chain should be added\n     */\n    public void addChain(Chain chain, int modelnr);\n\n    /** retrieve a chain by it's position within the Structure .\n     *\n     * @param pos  an int for the position in the List of Chains.\n     * @return a Chain object\n    */\n    public Chain getChain(int pos);\n\n    /** retrieve a chain by it's position within the Structure and model number.\n     *\n     * @param pos      an int\n     * @param modelnr  an int\n     * @return a Chain object\n    */\n    public Chain getChain( int modelnr, int pos);\n\n\n\n    /** request a particular chain from a structure.\n     * by default considers only the first model.\n     * @param chainId the ID of a chain that should be returned\n     * @return Chain the requested chain\n     * @throws StructureException\n     */\n    public Chain findChain(String chainId)\n    throws StructureException;\n\n\n    /** check if a chain with the id chainId is contained in this structure.\n     *\n     * @param chainId the name of the chain\n     * @return true if a chain with the id (name) chainId is found\n     */\n    public boolean hasChain(String chainId);\n\n    /** request a particular chain from a particular model\n     * @param modelnr the number of the model to use\n     * @param chainId the ID of a chain that should be returned\n     * @return Chain the requested chain\n     * @throws StructureException\n     */\n    public Chain findChain(String chainId, int modelnr)\n    throws StructureException;\n\n    /** request a particular group from a structure.\n    * by default considers only the first model in the structure.\n    * @param chainId the ID of the chain to use\n    * @param pdbResnum the PDB residue number of the requested group\n    * @return Group the requested Group\n    * @throws StructureException\n    *\n    */\n    public  Group findGroup(String chainId, String pdbResnum)\n    throws StructureException;\n\n    /** request a particular group from a structure.\n     * considers only model nr X. count starts with 0.\n     * @param chainId the ID of the chain to use\n     * @param pdbResnum the PDB residue number of the requested group\n     * @param modelnr the number of the model to use\n     * @return Group the requested Group\n     * @throws StructureException\n     */\n     public  Group findGroup(String chainId, String pdbResnum, int modelnr)\n     throws StructureException;\n\n\n     /** request a chain by it's PDB code\n      * by default takes only the first model\n      *\n      * @param chainId the chain identifier\n      * @return the Chain that matches the chainID\n      * @throws StructureException\n      */\n     public Chain getChainByPDB(String chainId)\n         throws StructureException;\n\n     /** request a chain by it's PDB code\n      * by default takes only the first model\n      *\n      * @param chainId the chain identifier\n      * @param modelnr request a particular model;\n      * @return the Chain that matches the chainID in the model\n      * @throws StructureException\n      */\n     public Chain getChainByPDB(String chainId, int modelnr)\n         throws StructureException;\n\n\n    /** create a String that contains the contents of a PDB file .\n     *\n     * @return a String that looks like a PDB file\n     * @see FileConvert\n     */\n    public String toPDB();\n\n    /** set the compounts\n     *\n     * @param molList\n     */\n    public void setCompounds(List<Compound>molList);\n\n    /** get all the Compounds that are defined in the PDB Header\n     *\n     * @return a list of compound\n     */\n    public List<Compound> getCompounds();\n\n    /** set the list of database references for this structure\n     * @param dbrefs list of DBRef objects\n     *\n     *\n     */\n    public void setDBRefs(List<DBRef> dbrefs);\n\n    /** get the list of database references\n     *\n     * @return list of DBRef objects\n     */\n    public List<DBRef> getDBRefs();\n\n    /** request a particular compound by its id\n     *\n     * @param molId\n     * @return a compound\n     */\n    public Compound getCompoundById(String molId);\n\n\n    /** return the header information for this PDB file\n     *\n     * @return the PDBHeader object\n     */\n    public PDBHeader getPDBHeader();\n\n    /**\n     * return whether or not the entry has an associated journal article\n     * or publication. The JRNL section is not mandatory and thus may not be\n     * present.\n     * @return flag if a JournalArticle has been found.\n     */\n    public boolean hasJournalArticle();\n\n    /**\n     * get the associated publication as defined by the JRNL records in a PDB\n     * file.\n     * @return a JournalArticle\n     */\n    public JournalArticle getJournalArticle();\n\n    /**\n     * set the associated publication as defined by the JRNL records in a PDB\n     * file.\n     * @param journalArticle\n     */\n    public void setJournalArticle(JournalArticle journalArticle);\n\n    /** get the list of SSBonds as they have been defined in the PDB files\n     *\n     * @return a list of SSBonds\n     */\n    public List<SSBond> getSSBonds();\n\n    /** set the list of SSBonds for this structure\n     *\n     * @param ssbonds\n     */\n    public void setSSBonds(List<SSBond> ssbonds);\n\n    /** add a single SSBond to this structure\n     *\n     * @param ssbond\n     */\n    public void addSSBond(SSBond ssbond);\n\n    /** the the header information for this PDB file\n     *\n     * @param header the PDBHeader object\n     */\n    public void setPDBHeader(PDBHeader header);\n\n    /** get the ID used by Hibernate\n     *\n     * @return the ID used by Hibernate\n     */\n    public Long getId() ;\n\n    /** set the ID used by Hibernate\n     *\n     * @param id\n     */\n    public void setId(Long id) ;\n\n    /**\n     * @param sites the sites to set in the structure\n     */\n    public void setSites(List<Site> sites);\n\n    /**\n     * @return the sites contained in this structure\n     */\n    public List<Site> getSites();\n\n    public List<Group> getHetGroups();\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.io.FileConvert;\nimport org.biojava.bio.structure.io.PDBFileReader;\n\n\n/**\n *\n * Interface for a structure object. Provides access to the data of a PDB file.\n *\n * A structure object allows to access the PDB header information as well\n * as to the data from the ATOM records. The header information is\n * currently available through the following objects:\n * <ul>\n * <li>{@link PDBHeader}</li>\n * <li>{@link DBRef}</li>\n * <li>{@link Compound}</li>\n * </ul>\n *\n * The structure object provides access to the data from the ATOM records through\n * a hierarchy of sub-object:\n * <pre>\n * Structure\n *         |\n *         {@link Chain}\n *             |\n *             {@link Group}\n *                 |\n *                 {@link Atom}\n * </pre>\n *\n * For more documentation on how to work with the Structure API please\n * see <a href=\"http://biojava.org/wiki/BioJava:CookBook#Protein_Structure\" target=\"_top\">\n * http://biojava.org/wiki/BioJava:CookBook#Protein_Structure</a>\n *\n *\n *\n *\n<hr/>\n</hr>\n * <p>\n * Q: How can I get a Structure object from a PDB file?\n * </p>\n * <p>\n * A:\n </p>\n * <pre>\npublic {@link Structure} loadStructure(String pathToPDBFile){\n\t\t{@link PDBFileReader} pdbreader = new {@link PDBFileReader}();\n\n\t\t{@link Structure} structure = null;\n\t\ttry{\n\t\t\tstructure = pdbreader.getStructure(pathToPDBFile);\n\t\t\tSystem.out.println(structure);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn structure;\n\t}\n </pre>\n\n<hr>\n</hr>\n<p>\nQ: How can I calculate Phi and Psi angles of AminoAcids?\n</p>\n<p>\nA:\n</p>\n<pre>\npublic void calcPhiPsi({@link Structure} structure){\n\n\n\t\t// get the first chain from the structure\n\n\t\t{@link Chain} chain  = structure.getChain(0);\n\n\t\t// A protein chain consists of a number of groups. These can be either\n\t\t// {@link AminoAcid}, {@link HetatomImpl Hetatom} or {@link NucleotideImpl Nucleotide} groups.\n\t\t//\n\t\t// Note: BioJava provides access to both the ATOM and SEQRES data in a PDB file.\n\t\t// since we are interested in doing calculations here, we only request the groups\n\t\t// from the ATOM records\n\n\t\t//  get the Groups of the chain that are AminoAcids.\n\t\tList<Group> groups = chain.getAtomGroups(\"amino\");\n\n\t\t{@link AminoAcid} a;\n\t\t{@link AminoAcid} b;\n\t\t{@link AminoAcid} c ;\n\n\t\tfor ( int i=0; i < groups.size(); i++){\n\n\t\t\t// since we requested only groups of type \"amino\" they will always be amino acids\n\t\t\t// Nucleotide and Hetatom groups will not be present in the groups list.\n\n\t\t\tb = ({@link AminoAcid})groups.get(i);\n\n\t\t\tdouble phi =360.0;\n\t\t\tdouble psi =360.0;\n\n\t\t\tif ( i > 0) {\n\t\t\t\ta = ({@link AminoAcid})groups.get(i-1) ;\n\t\t\t\ttry {\n\n\t\t\t\t\t// the Calc class provides utility methods for various calculations on\n\t\t\t\t\t// structures, groups and atoms\n\n\t\t\t\t\tphi = {@link Calc}.getPhi(a,b);\n\t\t\t\t} catch ({@link StructureException} e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tphi = 360.0 ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( i < groups.size()-1) {\n\t\t\t\tc = ({@link AminoAcid})groups.get(i+1) ;\n\t\t\t\ttry {\n\t\t\t\t\tpsi = {@link Calc}.getPsi(b,c);\n\t\t\t\t}catch ({@link StructureException} e){\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tpsi = 360.0 ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.print(b.getPDBCode() + \" \" + b.getPDBName() + \":\"  );\n\n\t\t\tSystem.out.println(String.format(\"\\tphi: %+7.2f psi: %+7.2f\", phi, psi));\n\n\t\t}\n</pre>\n<hr>\n</hr>\n\n *\n *\n *\n * @author Andreas Prlic\n * @since 1.4\n * @version %I% %G%\n */\npublic interface Structure extends Cloneable{\n\n\n\t/** returns an identical copy of this Structure object\n\t *\n\t * @return identical copy of this Structure object\n\t */\n\tpublic Structure clone();\n\n    /**\n     * String representation of object.\n     */\n    public String toString();\n\n    /**\n     *\n     * set PDB code of structure .\n     *\n     * @param pdb_id  a String specifying the PDBCode\n     * @see #getPDBCode\n     *\n     */\n    public void setPDBCode (String pdb_id) ;\n\n    /**\n     *\n     * get PDB code of structure.\n     *\n     * @return a String representing the PDBCode value\n     * @see #setPDBCode\n     */\n    public String  getPDBCode () ;\n\n    /** set biological name of Structure .\n     *\n     * @param name  a String specifying the biological name of the Structure\n     * @see #getName\n     */\n    public void setName(String name);\n\n    /** get biological name of Structure.\n     *\n     * @return a String representing the biological name of the Structure\n     * @see #setName\n     */\n    public String getName();\n\n    /** set the Header data .\n     *\n     * @param h  a Map object specifying the header\n     * @see #getHeader\n     */\n    public void setHeader(Map<String,Object> h) ;\n\n    /** get Header data .\n     *\n     * @return a Map object representing the header value\n     * @see #setHeader\n     * @deprecated use getPDBHeader instead\n     * @see #getPDBHeader\n     */\n    public Map<String,Object> getHeader() ;\n\n    /**\n       sets/gets an List of  Maps which corresponds to the CONECT lines in the PDB file:\n\n       <pre>\n       COLUMNS         DATA TYPE        FIELD           DEFINITION\n       ---------------------------------------------------------------------------------\n        1 -  6         Record name      \"CONECT\"\n        7 - 11         Integer          serial          Atom serial number\n       12 - 16         Integer          serial          Serial number of bonded atom\n       17 - 21         Integer          serial          Serial number of bonded atom\n       22 - 26         Integer          serial          Serial number of bonded atom\n       27 - 31         Integer          serial          Serial number of bonded atom\n       32 - 36         Integer          serial          Serial number of hydrogen bonded\n       atom\n       37 - 41         Integer          serial          Serial number of hydrogen bonded\n       atom\n       42 - 46         Integer          serial          Serial number of salt bridged\n       atom\n       47 - 51         Integer          serial          Serial number of hydrogen bonded\n       atom\n       52 - 56         Integer          serial          Serial number of hydrogen bonded\n       atom\n       57 - 61         Integer          serial          Serial number of salt bridged\n       atom\n       </pre>\n\n       the HashMap for a single CONECT line contains the following fields:\n\n       <li> atomserial (mandatory) : Atom serial number</li>\n       <li> bond1 .. bond4 (optional): Serial number of bonded atom</li>\n       <li> hydrogen1 .. hydrogen4 (optional):Serial number of hydrogen bonded atom</li>\n       <li> salt1 .. salt2 (optional): Serial number of salt bridged atom</li>\n\n       *\n       * @param connections  a List object specifying the connections\n       * @see #getConnections\n    */\n    public void setConnections(List<Map<String,Integer>> connections);\n\n    /**\n     * Returns the connections value.\n     * @return a List object representing the connections value\n     * @see #setConnections\n     */\n    public List<Map<String,Integer>> getConnections();\n\n    /** return number of Chains in this Structure.\n     * @return an int representing the number of Chains in this Structure\n     */\n    public int size() ;\n\n    /** return number of chains of model.\n    *\n    * @param modelnr  an int specifying the number of the Model that should be used\n    * @return an int representing the number of Chains in this Model\n    */\n    public int size(int modelnr);\n\n    /** return number of models .\n     * in this implementation also XRAY structures have \"1 model\", since\n     * model is the container for the chains.\n     * to test if a Structure is an NMR structure use @see isNMR ,\n     * since this is based on the info in the PDB file header.\n     *\n     * @return an int representing the number of models in this Structure\n     */\n    public int nrModels() ;\n\n    /** test if this structure is an nmr structure.\n     *\n     * @return true if this Structure has been resolved by NMR\n     */\n    public boolean isNmr() ;\n\n    /** set NMR flag.\n     *\n     * @param nmr  true to declare that this Structure has been solved by NMR.\n     */\n    public void setNmr(boolean nmr);\n\n\n    /** add a new model.\n     *\n     * @param model  a List object containing the Chains of the new Model\n     */\n    public void addModel(List<Chain> model);\n\n\n    /** a convenience function if one wants to edit and replace the\n     * models in a structure. allows to set (replace) the model at position\n     * with the new List of Chains.\n     * @param position starting at 0\n     * @param model\n     */\n    public void setModel(int position, List<Chain> model);\n\n    /** retrieve all Chains belonging to a model .\n     * @see #getChains(int modelnr)\n     *\n     * @param modelnr  an int\n     * @return a List object containing the Chains of Model nr. modelnr\n\n     */\n    public List<Chain> getModel(int modelnr);\n\n    /** retrieve all chains - if it is a NMR structure will return the chains of the first model.\n     * This is the same as getChains(0);\n     * @see #getModel(int modelnr)\n     * @see #getChains(int modelnr)\n     *\n     * @return a List object containing the Chains of Model nr. modelnr\n     */\n    public List<Chain> getChains();\n\n\n    /** set the chains of a structure, if this is a NMR structure,\n     * this will only set model 0.\n     *\n     * @see #setChains(int, List)\n     *\n     * @param chains the list of chains for this structure.\n     */\n    public void setChains(List<Chain> chains);\n\n    /** retrieve all chains of a model.\n     * @see #getModel\n     *\n     * @param modelnr  an int\n     * @return a List object containing the Chains of Model nr. modelnr\n     */\n    public List<Chain> getChains(int modelnr);\n\n    /** set the chains for a model\n     * @param chains\n     * @param modelnr\n     */\n    public void setChains( int modelnr, List<Chain> chains);\n\n    /** add a new chain.\n     *\n     * @param chain  a Chain object\n     */\n    public void addChain(Chain chain);\n\n    /** add a new chain, if several models are available.\n     *\n     * @param chain    a Chain object\n     * @param modelnr  an int specifying to which model the Chain should be added\n     */\n    public void addChain(Chain chain, int modelnr);\n\n    /** retrieve a chain by it's position within the Structure .\n     *\n     * @param pos  an int for the position in the List of Chains.\n     * @return a Chain object\n    */\n    public Chain getChain(int pos);\n\n    /** retrieve a chain by it's position within the Structure and model number.\n     *\n     * @param pos      an int\n     * @param modelnr  an int\n     * @return a Chain object\n    */\n    public Chain getChain( int modelnr, int pos);\n\n\n\n    /** request a particular chain from a structure.\n     * by default considers only the first model.\n     * @param chainId the ID of a chain that should be returned\n     * @return Chain the requested chain\n     * @throws StructureException\n     */\n    public Chain findChain(String chainId)\n    throws StructureException;\n\n\n    /** check if a chain with the id chainId is contained in this structure.\n     *\n     * @param chainId the name of the chain\n     * @return true if a chain with the id (name) chainId is found\n     */\n    public boolean hasChain(String chainId);\n\n    /** request a particular chain from a particular model\n     * @param modelnr the number of the model to use\n     * @param chainId the ID of a chain that should be returned\n     * @return Chain the requested chain\n     * @throws StructureException\n     */\n    public Chain findChain(String chainId, int modelnr)\n    throws StructureException;\n\n    /** request a particular group from a structure.\n    * by default considers only the first model in the structure.\n    * @param chainId the ID of the chain to use\n    * @param pdbResnum the PDB residue number of the requested group\n    * @return Group the requested Group\n    * @throws StructureException\n    *\n    */\n    public  Group findGroup(String chainId, String pdbResnum)\n    throws StructureException;\n\n    /** request a particular group from a structure.\n     * considers only model nr X. count starts with 0.\n     * @param chainId the ID of the chain to use\n     * @param pdbResnum the PDB residue number of the requested group\n     * @param modelnr the number of the model to use\n     * @return Group the requested Group\n     * @throws StructureException\n     */\n     public  Group findGroup(String chainId, String pdbResnum, int modelnr)\n     throws StructureException;\n\n\n     /** request a chain by it's PDB code\n      * by default takes only the first model\n      *\n      * @param chainId the chain identifier\n      * @return the Chain that matches the chainID\n      * @throws StructureException\n      */\n     public Chain getChainByPDB(String chainId)\n         throws StructureException;\n\n     /** request a chain by it's PDB code\n      * by default takes only the first model\n      *\n      * @param chainId the chain identifier\n      * @param modelnr request a particular model;\n      * @return the Chain that matches the chainID in the model\n      * @throws StructureException\n      */\n     public Chain getChainByPDB(String chainId, int modelnr)\n         throws StructureException;\n\n\n    /** create a String that contains the contents of a PDB file .\n     *\n     * @return a String that looks like a PDB file\n     * @see FileConvert\n     */\n    public String toPDB();\n\n    /** set the compounts\n     *\n     * @param molList\n     */\n    public void setCompounds(List<Compound>molList);\n\n    /** get all the Compounds that are defined in the PDB Header\n     *\n     * @return a list of compound\n     */\n    public List<Compound> getCompounds();\n\n    /** set the list of database references for this structure\n     * @param dbrefs list of DBRef objects\n     *\n     *\n     */\n    public void setDBRefs(List<DBRef> dbrefs);\n\n    /** get the list of database references\n     *\n     * @return list of DBRef objects\n     */\n    public List<DBRef> getDBRefs();\n\n    /** request a particular compound by its id\n     *\n     * @param molId\n     * @return a compound\n     */\n    public Compound getCompoundById(String molId);\n\n\n    /** return the header information for this PDB file\n     *\n     * @return the PDBHeader object\n     */\n    public PDBHeader getPDBHeader();\n\n    /**\n     * return whether or not the entry has an associated journal article\n     * or publication. The JRNL section is not mandatory and thus may not be\n     * present.\n     * @return flag if a JournalArticle has been found.\n     */\n    public boolean hasJournalArticle();\n\n    /**\n     * get the associated publication as defined by the JRNL records in a PDB\n     * file.\n     * @return a JournalArticle\n     */\n    public JournalArticle getJournalArticle();\n\n    /**\n     * set the associated publication as defined by the JRNL records in a PDB\n     * file.\n     * @param journalArticle\n     */\n    public void setJournalArticle(JournalArticle journalArticle);\n\n    /** get the list of SSBonds as they have been defined in the PDB files\n     *\n     * @return a list of SSBonds\n     */\n    public List<SSBond> getSSBonds();\n\n    /** set the list of SSBonds for this structure\n     *\n     * @param ssbonds\n     */\n    public void setSSBonds(List<SSBond> ssbonds);\n\n    /** add a single SSBond to this structure\n     *\n     * @param ssbond\n     */\n    public void addSSBond(SSBond ssbond);\n\n    /** the the header information for this PDB file\n     *\n     * @param header the PDBHeader object\n     */\n    public void setPDBHeader(PDBHeader header);\n\n    /** get the ID used by Hibernate\n     *\n     * @return the ID used by Hibernate\n     */\n    public Long getId() ;\n\n    /** set the ID used by Hibernate\n     *\n     * @param id\n     */\n    public void setId(Long id) ;\n\n    /**\n     * @param sites the sites to set in the structure\n     */\n    public void setSites(List<Site> sites);\n\n    /**\n     * @return the sites contained in this structure\n     */\n    public List<Site> getSites();\n\n    public List<Group> getHetGroups();\n    \n    /**\n     * Sets a flag to indicate if this structure is a biological assembly\n     * @param biologicalAssembly true if biological assembly, otherwise false\n     * @since 3.2\n     */\n    public void setBiologicalAssembly(boolean biologicalAssembly);\n\n    /**\n     * Gets flag that indicates if this structure is a biological assembly\n     * @return the sites contained in this structure\n     * @since 3.2\n     */\n    public boolean isBiologicalAssembly();\n\n}\n","originTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava.bio.structure.io.PDBFileParser;\nimport org.biojava.bio.structure.jama.Matrix;\n\n\n/**\n *\n * @author Andreas Prlic\n * @since 1.5\n */\n\n\npublic class StructureTest extends TestCase {\n\n\tStructure structure;\n\n\tprotected void setUp()\n\t{\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/5pti_old.pdb\");\n\t\tassertNotNull(inStream);\n\n\t\tPDBFileParser pdbpars = new PDBFileParser();\n\t\tFileParsingParameters params = new FileParsingParameters();\n\t\tparams.setAlignSeqRes(true);\n\t\tpdbpars.setFileParsingParameters(params);\n\t\t\n\t\ttry {\n\t\t\tstructure = pdbpars.parsePDBFile(inStream) ;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tassertNotNull(structure);\n\n\t\tassertEquals(\"structure does not contain one chain \", 2 ,structure.size());\n\t}\n\n\tpublic void testSeqResParsing() {\n\n\t\t// System.out.println(structure);\n\t\tList<Chain> chains = structure.getChains(0);\n\t\tassertEquals(\" nr of found chains not correct!\",2,chains.size());\n\t\tChain c = chains.get(0);\n\t\t//System.out.println(c);\n\t\tList<Group> seqResGroups = c.getSeqResGroups();\n\t\tassertEquals(\"nr of SEQRES groups not correct!\",58,seqResGroups.size());\n\n\t\tList<Group> atomGroups = c.getAtomGroups();\n\n\t\tGroup g3 = seqResGroups.get(2);\n\t\tint indexAtom = atomGroups.indexOf(g3);\n\t\t//System.out.println(\" index in atomlist: \" + indexAtom);\n\t\tassertEquals(\"the SEQRES group can not be found in the ATOM list\",2,indexAtom);\n\n\n\t\tGroup g5 = atomGroups.get(5);\n\t\tassertEquals(\"The ATOM group can not be fond in the SEQRES list\", 5,seqResGroups.indexOf(g5));\n\n\t\tChain c2 = chains.get(1);\n\t\tList<Group>atomGroups2 = c2.getAtomGroups();\n\t\tGroup g58 = atomGroups2.get(0);\n\t\tassertEquals(\"The group is not PO4\",\"PO4\", g58.getPDBName());\n\t\tassertEquals(\"The group P04 should not be in the SEQRES list\", -1 , seqResGroups.indexOf(g58));\n\n\t}\n\n\n\t/** test if a PDB file can be parsed\n\t * @throws Exception */\n\tpublic void testReadPDBFile() throws Exception {\n\n\t\tassertEquals(\"pdb code not set!\",\"5PTI\",structure.getPDBCode());\n\n\t\tChain c = structure.getChain(0);\n\t\tassertEquals(\"did not find the expected 58 amino acids!\",58,c.getAtomGroups(\"amino\").size());\n\n\t\tassertTrue(c.getAtomGroups(\"hetatm\").size()     == 0);\n\n\t\tChain c2 = structure.getChain(1);\n\t\tassertTrue(c2.getAtomGroups(\"hetatm\").size()     == 65);\n\t\tassertTrue(c2.getAtomGroups(\"nucleotide\").size() == 0 );\n\n\t\tList<Compound> compounds= structure.getCompounds();\n\t\tassertTrue(compounds.size() == 1);\n\t\tCompound mol = compounds.get(0);\n\t\tassertTrue(mol.getMolName().startsWith(\"TRYPSIN INHIBITOR\"));\n\t}\n\n\n\tpublic void testSSBondParsing() throws Exception {\n\t\tassertNotNull(structure);\n\n\t\tList<SSBond> ssbonds = structure.getSSBonds();\n\t\tassertEquals(\"did not find the correct nr of SSBonds \",3,ssbonds.size());\n\n\t\tString pdb1 = \"SSBOND   1 CYS A    5    CYS A   55\";\n\t\tString pdb2 = \"SSBOND   2 CYS A   14    CYS A   38\";\n\n\t\tSSBond bond1 = ssbonds.get(0);\n\n\t\tString b1 = bond1.toPDB();\n\n\t\tassertTrue(\"PDB representation incorrect\",pdb1.equals(b1.trim()));\n\t\tassertTrue(\"not right resnum1 \" , bond1.getResnum1().equals(\"5\"));\n\t\tassertTrue(\"not right resnum2 \" , bond1.getResnum2().equals(\"55\"));\n\n\t\tSSBond bond2 = ssbonds.get(1);\n\t\tString b2 = bond2.toPDB();\n\t\tassertTrue(\"not right resnum1 \" , bond2.getResnum1().equals(\"14\"));\n\t\tassertTrue(\"not right resnum2 \" , bond2.getResnum2().equals(\"38\"));\n\t\tassertTrue(\"PDB representation incorrect\",pdb2.equals(b2.trim()));\n\n\t}\n\n\t/** Tests that standard amino acids are working properly\n\t * @throws Exception */\n\tpublic void testStandardAmino() throws Exception {\n\n\t\tAminoAcid arg = StandardAminoAcid.getAminoAcid(\"ARG\");\n\t\tassertTrue(arg.size() == 11 );\n\n\t\tAminoAcid gly = StandardAminoAcid.getAminoAcid(\"G\");\n\t\tassertTrue(gly.size() == 4);\n\n\t}\n\n\n\tpublic void testHeader() {\n\t\tMap<String, Object> m = structure.getHeader();\n\n\t\tassertNotNull(m);\n\n\t\tString classification = (String)m.get(\"classification\");\n\t\tassertTrue(classification.equals(\"PROTEINASE INHIBITOR (TRYPSIN)\"));\n\n\t\tString idCode = (String)m.get(\"idCode\");\n\t\tassertEquals(\"the idCode in the Header is \" + idCode + \" and not 5PTI, as expected\",\"5PTI\",idCode);\n\n\t\tFloat resolution = (Float) m.get(\"resolution\");\n\t\tassertEquals(\"the resolution in the Header is \" + resolution + \" and not 1.0, as expected\",new Float(1.0),resolution);\n\n\t\tString technique = (String) m.get(\"technique\");\n\t\tString techShould = \"X-RAY DIFFRACTION \";\n\t\tassertEquals(\"the technique in the Header is \" + technique, techShould,technique);\n\n\t\tList <Compound> compounds = structure.getCompounds();\n\t\tassertEquals(\"did not find the right number of compounds! \", 1, compounds.size());\n\n\t\tCompound comp = compounds.get(0);\n\t\tassertEquals(\"did not get the right compounds info\",true,comp.getMolName().startsWith(\"TRYPSIN INHIBITOR\"));\n\n\t\tList<String> chainIds = comp.getChainId();\n\t\tList<Chain> chains    = comp.getChains();\n\n\t\tassertEquals(\"the number of chain ids and chains did not match!\",chainIds.size(),chains.size());\n\t\tassertEquals(\"the chain ID did not match\", chainIds.get(0),chains.get(0).getName());\n\n\n\t}\n\n\n\tpublic void testPDBHeader(){\n\t\tMap<String, Object> m = structure.getHeader();\n\t\tPDBHeader header = structure.getPDBHeader();\n\t\tString classification = (String)m.get(\"classification\");\n\t\tassertTrue(classification.equals(header.getClassification()));\n\n\t\tString idCode = (String)m.get(\"idCode\");\n\t\tassertTrue(idCode.equals(header.getIdCode()));\n\n\t\tFloat resolution = (Float) m.get(\"resolution\");\n\t\tassertTrue(resolution.floatValue() == header.getResolution());\n\n\t\tString technique = (String) m.get(\"technique\");\n\t\tassertTrue(technique.equals(header.getTechnique()));\n\n\t}\n\n\tpublic void testCreateVirtualCBAtom(){\n\n\t\tGroup g1 = structure.getChain(0).getAtomGroup(11);\n\n\t\tif ( g1.getPDBName().equals(\"GLY\")){\n\t\t\tif ( g1 instanceof AminoAcid){\n\t\t\t\ttry {\n\t\t\t\t\tAtom cb = Calc.createVirtualCBAtom((AminoAcid)g1);\n\t\t\t\t\tg1.addAtom(cb);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\tfail (\"createVirtualCBAtom failed with \" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfail(\"the group at position 11 is not a GLY!\");\n\t\t}\n\t}\n\n\tpublic void testMutation() throws Exception {\n\n\t\tGroup g1 = (Group)structure.getChain(0).getAtomGroup(21).clone();\n\t\tassertTrue(g1 != null);\n\n\n\t\tGroup g2 = (Group)structure.getChain(0).getAtomGroup(53).clone();\n\t\tassertTrue(g2 != null);\n\n\n\t\tassertEquals(\"The group at position 22 is not a PHE\",\"PHE\", g1.getPDBName());\n\t\tassertEquals(\"The group position is  not number 22\",\"22\", g1.getPDBCode());\n\n\t\tassertEquals(\"The group at position 54 is not a THR\",\"THR\", g2.getPDBName());\n\t\tassertEquals(\"The group position is not number 54\",\"54\", g2.getPDBCode());\n\n\t\tAtom[] atoms1 = new Atom[3];\n\t\tAtom[] atoms2 = new Atom[3];\n\n\t\tatoms1[0] = g1.getAtom(\"N\");\n\t\tatoms1[1] = g1.getAtom(\"CA\");\n\t\tatoms1[2] = g1.getAtom(\"CB\");\n\n\n\t\tatoms2[0] = g2.getAtom(\"N\");\n\t\tatoms2[1] = g2.getAtom(\"CA\");\n\t\tatoms2[2] = g2.getAtom(\"CB\");\n\n\n\t\tSVDSuperimposer svds = new SVDSuperimposer(atoms1,atoms2);\n\n\n\t\tMatrix rotMatrix = svds.getRotation();\n\t\tAtom   tran      = svds.getTranslation();\n\n\t\tGroup newGroup = (Group)g2.clone();\n\n\t\tCalc.rotate(newGroup,rotMatrix);\n\n\t\tCalc.shift(newGroup,tran);\n\n\t\tAtom ca1    =       g1.getAtom(\"CA\");\n\t\tAtom oldca2 =       g2.getAtom(\"CA\");\n\t\tAtom newca2 = newGroup.getAtom(\"CA\");\n\t\tElement e1 = ca1.getElement();\n\t\t\n\t\tassertEquals(Element.C, e1);\n\n\t\t// this also tests the cloning ...\n\t\tdouble olddistance = Calc.getDistance(ca1,oldca2);\n\t\tassertTrue( olddistance > 10 );\n\n\t\t// final test check that the distance between the CA atoms is small ;\n\n\t\tdouble newdistance = Calc.getDistance(ca1,newca2);\n\t\tassertTrue( newdistance < 0.1);\n\n\n\t}\n\n\tpublic void testElement() throws Exception {\n\t\t// there should be no wild card elements\n\t\t// in a structure (!= Element.R)\n\t\tfor (Chain c: structure.getChains()) {\n\t\t\tfor (Group g: c.getAtomGroups()) {\n\t\t\t\tfor (Atom a: g.getAtoms()) {\n\t\t\t\t\tassertFalse(a.getElement().equals(Element.R));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n}\n","changedTest":"","commitMessage":"Added biologicalAssembly flag that indicates if this structure was loaded from a biological assembly file (i.e. *.pdb.gz).\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8968 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}