{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitCluster.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitCluster.java","prod_time":"2020-01-22 08:01:52","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":17,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":12,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"8b76e96a7af6b0118025b8a906b64de11b0d9693","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.alignment.Alignments;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava.nbio.alignment.SimpleGapPenalty;\nimport org.biojava.nbio.alignment.template.GapPenalty;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceAligner;\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.StructureAlignment;\nimport org.biojava.nbio.structure.align.StructureAlignmentFactory;\nimport org.biojava.nbio.structure.align.ce.ConfigStrucAligParams;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetrySubunits;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * A SubunitCluster contains a set of equivalent {@link QuatSymmetrySubunits},\n * the set of equivalent residues (EQR) between {@link Subunit} and a\n * {@link Subunit} representative. It also stores the method used for\n * clustering.\n * <p>\n * This class allows the comparison and merging of SubunitClusters.\n *\n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class SubunitCluster {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SubunitCluster.class);\n\n\tprivate List<Subunit> subunits = new ArrayList<>();\n\tprivate List<List<Integer>> subunitEQR = new ArrayList<>();\n\tprivate int representative = -1;\n\n\tprivate SubunitClustererMethod method = SubunitClustererMethod.SEQUENCE;\n\tprivate boolean pseudoStoichiometric = false;\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t*/\n\tprivate String alpha = \"\";\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t *\n\t * @return alpha\n\t *          String\n\t */\n\n\tpublic String getAlpha() {\n\t\treturn alpha;\n\t}\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t *\n\t * @param  alpha\n\t *          String\n\t */\n\tpublic void setAlpha(String alpha) {\n\t\tthis.alpha = alpha;\n\t}\n\n\t/**\n\t * A constructor from a single Subunit. To obtain a\n\t * SubunitCluster with multiple Subunits, initialize different\n\t * SubunitClusters and merge them.\n\t *\n\t * @param subunit\n\t *            initial Subunit\n\t */\n\tpublic SubunitCluster(Subunit subunit) {\n\n\t\tsubunits.add(subunit);\n\n\t\tList<Integer> identity = new ArrayList<>();\n\t\tfor (int i = 0; i < subunit.size(); i++)\n\t\t\tidentity.add(i);\n\t\tsubunitEQR.add(identity);\n\n\t\trepresentative = 0;\n\t}\n\n\t/**\n\t * A copy constructor with the possibility of removing subunits.\n\t * No re-clustering is done.\n\t *\n\t * @param other\n\t *            reference SubunitCluster\n\t * @param subunitsToRetain\n\t *            which subunits to copy to this cluster\n\t */\n\tpublic SubunitCluster(SubunitCluster other, List<Integer> subunitsToRetain) {\n\t\tmethod = other.method;\n\t\tpseudoStoichiometric = other.pseudoStoichiometric;\n\t\tfor (int i = 0; i < other.subunits.size(); i++) {\n\t\t\tif(subunitsToRetain.contains(i)) {\n\t\t\t\tsubunits.add(other.subunits.get(i));\n\t\t\t\tsubunitEQR.add(other.subunitEQR.get(i));\n\t\t\t}\n\t\t}\n\t\trepresentative = 0;\n\t\tfor (int i=1; i<subunits.size(); i++) {\n\t\t\tif (subunits.get(i).size() > subunits.get(representative).size()) {\n\t\t\t\trepresentative = i;\n\t\t\t}\n\t\t}\n\t\tsetAlpha(other.getAlpha());\n\t}\n\n\t/**\n\t * Subunits contained in the SubunitCluster.\n\t *\n\t * @return an unmodifiable view of the original List\n\t */\n\tpublic List<Subunit> getSubunits() {\n\t\treturn Collections.unmodifiableList(subunits);\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by String equality of their residue one-letter sequences.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalTo(SubunitCluster other) {\n\t\tString thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\tString otherSequence = other.subunits.get(other.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\treturn thisSequence.equals(otherSequence);\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by equality of their entity identifiers if they are present.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalByEntityIdTo(SubunitCluster other) {\n\t\tStructure thisStruct = this.subunits.get(this.representative).getStructure();\n\t\tStructure otherStruct = other.subunits.get(other.representative).getStructure();\n\t\tString thisName = this.subunits.get(this.representative).getName();\n\t\tString otherName = other.subunits.get(this.representative).getName();\n\t\tChain thisChain = thisStruct.getChain(thisName);\n\t\tChain otherChain = otherStruct.getChain(otherName);\n\t\tif (thisChain == null || otherChain == null) {\n\t\t\tlogger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\",\n\t\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\t\tother.subunits.get(other.representative).getName());\n\t\t\treturn false;\n\t\t}\n\t\tif (thisChain.getEntityInfo() == null || otherChain.getEntityInfo() == null) {\n\t\t\tlogger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\",\n\t\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\t\tother.subunits.get(other.representative).getName());\n\t\t\treturn false;\n\t\t}\n\t\tint thisEntityId = thisChain.getEntityInfo().getMolId();\n\t\tint otherEntityId = otherChain.getEntityInfo().getMolId();\n\t\treturn thisEntityId == otherEntityId;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by {@link #isIdenticalTo(SubunitCluster)}.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdentical(SubunitCluster other) {\n\n\t\tif (!isIdenticalTo(other))\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters {}-{} are identical in sequence\",\n\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\tother.subunits.get(other.representative).getName());\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by comparing the entity identifiers of the subunits\n\t * if one can be found.\n\t * Thus this only makes sense when the subunits are complete chains of a\n\t * deposited PDB entry.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdenticalByEntityId(SubunitCluster other) {\n\n\t\tif (!isIdenticalByEntityIdTo(other))\n\t\t\treturn false;\n\n\t\tSubunit thisSub = this.subunits.get(this.representative);\n\t\tSubunit otherSub = other.subunits.get(other.representative);\n\t\tlogger.info(\"SubunitClusters {}-{} belong to same entity. Assuming they are identical\",\n\t\t\t\tthisSub.getName(),\n\t\t\t\totherSub.getName());\n\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// we've merged by entity id, we can assume structure, chain and entity are available\n\t\tStructure thisStruct = thisSub.getStructure();\n\t\tStructure otherStruct = otherSub.getStructure();\n\t\tString thisName = thisSub.getName();\n\t\tString otherName = otherSub.getName();\n\t\tChain thisChain = thisStruct.getChain(thisName);\n\t\tChain otherChain = otherStruct.getChain(otherName);\n\t\tEntityInfo entityInfo = thisChain.getEntityInfo();\n\n\t\t// Extract the aligned residues of both Subunits\n\t\tfor (int thisIndex=0; thisIndex < thisSub.size(); thisIndex++) {\n\n\t\t\tGroup g = thisSub.getRepresentativeAtoms()[thisIndex].getGroup();\n\n\t\t\tint seqresIndex = entityInfo.getAlignedResIndex(g, thisChain);\n\n\t\t\tGroup otherG = otherChain.getSeqResGroups().get(seqresIndex - 1);\n\n\t\t\tif (!otherChain.getAtomGroups().contains(otherG)) {\n\t\t\t\t// skip residues that are unobserved in other sequence (\"gaps\" in the entity alignment)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint otherIndex = otherChain.getAtomGroups().indexOf(otherG);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(otherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (according to the criteria in params).\n\t * <p>\n\t * The sequence alignment is performed using linear {@link SimpleGapPenalty} and\n\t * BLOSUM62 as scoring matrix.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            SubunitClustererParameters, with information whether to use local\n\t *            or global alignment, sequence identity and coverage thresholds.\n\t *            Threshold values lower than 0.7 are not recommended.\n\t *            Use {@link #mergeStructure} for lower values.\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\n\tpublic boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params) throws CompoundNotFoundException {\n\t\tPairwiseSequenceAlignerType alignerType = PairwiseSequenceAlignerType.LOCAL;\n\t\tif (params.isUseGlobalMetrics()) {\n\t\t\talignerType = PairwiseSequenceAlignerType.GLOBAL;\n\t\t}\n\t\treturn mergeSequence(other, params,alignerType\n\t\t\t\t, new SimpleGapPenalty(),\n\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (according to the criteria in params).\n\t * <p>\n\t * The sequence alignment is performed using linear {@link SimpleGapPenalty} and\n\t * BLOSUM62 as scoring matrix.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            {@link SubunitClustererParameters}, with information whether to use local\n\t *            or global alignment, sequence identity and coverage thresholds.\n\t *            Threshold values lower than 0.7 are not recommended.\n\t *            Use {@link #mergeStructure} for lower values.\n\t * @param alignerType\n\t *            parameter for the sequence alignment algorithm\n\t * @param gapPenalty\n\t *            parameter for the sequence alignment algorithm\n\t * @param subsMatrix\n\t *            parameter for the sequence alignment algorithm\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\n\tpublic boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params,\n\t\t\t\t\t\t\t\t PairwiseSequenceAlignerType alignerType,\n\t\t\t\t\t\t\t\t GapPenalty gapPenalty,\n\t\t\t\t\t\t\t\t SubstitutionMatrix<AminoAcidCompound> subsMatrix)\n\t\t\tthrows CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform the alignment with provided parameters\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence, alignerType,\n\t\t\t\t\t\tgapPenalty, subsMatrix);\n\n\t\tdouble sequenceIdentity;\n\t\tif(params.isUseGlobalMetrics()) {\n\t\t\tsequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n\t\t} else {\n\t\t\tsequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n\t\t}\n\n\t\tif (sequenceIdentity < params.getSequenceIdentityThreshold())\n\t\t\treturn false;\n\n\t\tdouble sequenceCoverage = 0;\n\t\tif(params.isUseSequenceCoverage()) {\n\t\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t\t.getNumGapPositions();\n\t\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t\t.getNumGapPositions();\n\t\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\t\tsequenceCoverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\t\tif (sequenceCoverage < params.getSequenceCoverageThreshold())\n\t\t\t\treturn false;\n\t\t}\n\n\t\tlogger.info(String.format(\"SubunitClusters %s-%s are similar in sequence \"\n\t\t\t\t\t\t+ \"with %.2f sequence identity and %.2f coverage\",\n\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\tother.subunits.get(other.representative).getName(),\n\t\t\t\tsequenceIdentity, sequenceCoverage));\n\n\t\t// If coverage and sequence identity sufficient, merge other and this\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 1; p < aligner.getPair().getLength() + 1; p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (aligner.getPair().getAlignedSequence(1).isGap(p))\n\t\t\t\tcontinue;\n\t\t\tif (aligner.getPair().getAlignedSequence(2).isGap(p))\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = aligner.getPair().getIndexInQueryAt(p) - 1;\n\t\t\tint otherIndex = aligner.getPair().getIndexInTargetAt(p) - 1;\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(otherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\tthis.method = SubunitClustererMethod.SEQUENCE;\n\t\tpseudoStoichiometric = !params.isHighConfidenceScores(sequenceIdentity,sequenceCoverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representative\n\t * Atoms are structurally similar (according to the criteria in params).\n\t * <p>\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            {@link SubunitClustererParameters}, with information on what alignment\n\t *            algorithm to use, RMSD/TMScore and structure coverage thresholds.\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\n\tpublic boolean mergeStructure(SubunitCluster other, SubunitClustererParameters params) throws StructureException {\n\n\t\tStructureAlignment aligner = StructureAlignmentFactory.getAlgorithm(params.getSuperpositionAlgorithm());\n\t\tConfigStrucAligParams aligner_params = aligner.getParameters();\n\n\t\tMethod setOptimizeAlignment = null;\n\t\ttry {\n\t\t\tsetOptimizeAlignment = aligner_params.getClass().getMethod(\"setOptimizeAlignment\", boolean.class);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\t//alignment algorithm does not have an optimization switch, moving on\n\t\t}\n\t\tif (setOptimizeAlignment != null) {\n\t\t\ttry {\n\t\t\t\tsetOptimizeAlignment.invoke(aligner_params, params.isOptimizeAlignment());\n\t\t\t} catch (IllegalAccessException|InvocationTargetException e) {\n\t\t\t\tlogger.warn(\"Could not set alignment optimisation switch\");\n\t\t\t}\n\t\t}\n\n\t\tAFPChain afp = aligner.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convenience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble structureCoverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\n\t\tif(params.isUseStructureCoverage() && structureCoverage < params.getStructureCoverageThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (params.isUseRMSD() && rmsd > params.getRMSDThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble tmScore = afp.getTMScore();\n\t\tif (params.isUseTMScore() && tmScore < params.getTMThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlogger.info(String.format(\"SubunitClusters are structurally similar with \"\n\t\t\t\t+ \"%.2f RMSD %.2f coverage\", rmsd, structureCoverage));\n\n\t\t// Merge clusters\n\t\tList<List<Integer>> alignedRes = msa.getBlock(0).getAlignRes();\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 0; p < msa.length(); p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (alignedRes.get(0).get(p) == null)\n\t\t\t\tcontinue;\n\t\t\tif (alignedRes.get(1).get(p) == null)\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = alignedRes.get(0).get(p);\n\t\t\tint otherIndex = alignedRes.get(1).get(p);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\tthis.method = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\n\t\treturn true;\n\t}\n\n\tprivate void updateEquivResidues(SubunitCluster other, List<Integer> thisAligned, List<Integer> otherAligned) {\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<>();\n\t\tList<Integer> otherRemove = new ArrayList<>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative).get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(other.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(other.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t}\n\n\t/**\n\t * Analyze the internal symmetry of the SubunitCluster and divide its\n\t * {@link Subunit} into the internal repeats (domains) if they are\n\t * internally symmetric.\n\t *\n\t * @param clusterParams {@link SubunitClustererParameters} with fields used as follows:\n\t * structureCoverageThreshold\n\t *            the minimum coverage of all repeats in the Subunit\n\t * rmsdThreshold\n\t *            the maximum allowed RMSD between the repeats\n\t * minimumSequenceLength\n\t *            the minimum length of the repeating units\n\t * @return true if the cluster was internally symmetric, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean divideInternally(SubunitClustererParameters clusterParams)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters cesym_params = new CESymmParameters();\n\t\tcesym_params.setMinCoreLength(clusterParams.getMinimumSequenceLength());\n\t\tcesym_params.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), cesym_params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > clusterParams.getRMSDThreshold())\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < clusterParams.getStructureCoverageThreshold())\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitCluster is internally symmetric with {} repeats, \"\n\t\t\t\t+ \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms, subunits.get(s)\n\t\t\t\t\t\t.getName(), subunits.get(s).getIdentifier(), subunits\n\t\t\t\t\t\t.get(s).getStructure()));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return the number of Subunits in the cluster\n\t */\n\tpublic int size() {\n\t\treturn subunits.size();\n\t}\n\n\t/**\n\t * @return the number of aligned residues between Subunits of the cluster\n\t */\n\tpublic int length() {\n\t\treturn subunitEQR.get(representative).size();\n\t}\n\n\t/**\n\t * @return the {@link SubunitClustererMethod} used for clustering the\n\t *         Subunits\n\t */\n\tpublic SubunitClustererMethod getClustererMethod() {\n\t\treturn method;\n\t}\n\n\t/**\n\t * @return A List of size {@link #size()} of Atom arrays of length\n\t *         {@link #length()} with the aligned Atoms for each Subunit in the\n\t *         cluster\n\t */\n\tpublic List<Atom[]> getAlignedAtomsSubunits() {\n\n\t\tList<Atom[]> alignedAtoms = Collections.emptyList();\n\n\t\t// Loop through all subunits and add the aligned positions\n\t\tfor (int s = 0; s < subunits.size(); s++)\n\t\t\talignedAtoms.add(getAlignedAtomsSubunit(s));\n\n\t\treturn alignedAtoms;\n\t}\n\n\t/**\n\t * @param index\n\t *            Subunit index in the Cluster\n\t * @return An Atom array of length {@link #length()} with the aligned Atoms\n\t *         from the selected Subunit in the Cluster\n\t */\n\tpublic Atom[] getAlignedAtomsSubunit(int index) {\n\n\t\tAtom[] aligned = new Atom[subunitEQR.get(index).size()];\n\n\t\t// Add only the aligned positions of the Subunit in the Cluster\n\t\tfor (int p = 0; p < subunitEQR.get(index).size(); p++) {\n\t\t\taligned[p] = subunits.get(index).getRepresentativeAtoms()[subunitEQR\n\t\t\t\t\t.get(index).get(p)];\n\t\t}\n\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * The multiple alignment is calculated from the equivalent residues in the\n\t * SubunitCluster. The alignment is recalculated every time the method is\n\t * called (no caching).\n\t *\n\t * @return MultipleAlignment representation of the aligned residues in this\n\t *         Subunit Cluster\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment getMultipleAlignment() throws StructureException {\n\n\t\t// Create a multiple alignment with the atom arrays of the Subunits\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\tsubunits.stream().map(s -> s.getRepresentativeAtoms())\n\t\t\t\t\t\t.collect(Collectors.toList()));\n\n\t\t// Fill in the alignment information\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(subunitEQR);\n\n\t\t// Fill in the transformation matrices\n\t\tnew ReferenceSuperimposer(representative).superimpose(msa);\n\n\t\t// Calculate some scores\n\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\treturn msa;\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubunitCluster [Size=\" + size() + \", Length=\" + length()\n\t\t\t\t+ \", Representative=\" + representative + \", Method=\" + method\n\t\t\t\t+ \"]\";\n\t}\n\n\t/**\n\t * @return true if this cluster is considered pseudo-stoichiometric (i.e.,\n\t * \t\t   was either clustered by structure, or by sequence with low scores),\n\t *         false otherwise.\n\t */\n\tpublic boolean isPseudoStoichiometric() {\n\t\treturn pseudoStoichiometric;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.alignment.Alignments;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava.nbio.alignment.SimpleGapPenalty;\nimport org.biojava.nbio.alignment.template.GapPenalty;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceAligner;\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.StructureAlignment;\nimport org.biojava.nbio.structure.align.StructureAlignmentFactory;\nimport org.biojava.nbio.structure.align.ce.ConfigStrucAligParams;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetrySubunits;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * A SubunitCluster contains a set of equivalent {@link QuatSymmetrySubunits},\n * the set of equivalent residues (EQR) between {@link Subunit} and a\n * {@link Subunit} representative. It also stores the method used for\n * clustering.\n * <p>\n * This class allows the comparison and merging of SubunitClusters.\n *\n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class SubunitCluster {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SubunitCluster.class);\n\n\tprivate List<Subunit> subunits = new ArrayList<>();\n\tprivate List<List<Integer>> subunitEQR = new ArrayList<>();\n\tprivate int representative = -1;\n\n\tprivate SubunitClustererMethod method = SubunitClustererMethod.SEQUENCE;\n\tprivate boolean pseudoStoichiometric = false;\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t*/\n\tprivate String alpha = \"\";\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t *\n\t * @return alpha\n\t *          String\n\t */\n\n\tpublic String getAlpha() {\n\t\treturn alpha;\n\t}\n\n\t/**\n\t * A letter that is assigned to this cluster in stoichiometry.\n\t *\n\t * @param  alpha\n\t *          String\n\t */\n\tpublic void setAlpha(String alpha) {\n\t\tthis.alpha = alpha;\n\t}\n\n\t/**\n\t * A constructor from a single Subunit. To obtain a\n\t * SubunitCluster with multiple Subunits, initialize different\n\t * SubunitClusters and merge them.\n\t *\n\t * @param subunit\n\t *            initial Subunit\n\t */\n\tpublic SubunitCluster(Subunit subunit) {\n\n\t\tsubunits.add(subunit);\n\n\t\tList<Integer> identity = new ArrayList<>();\n\t\tfor (int i = 0; i < subunit.size(); i++)\n\t\t\tidentity.add(i);\n\t\tsubunitEQR.add(identity);\n\n\t\trepresentative = 0;\n\t}\n\n\t/**\n\t * A copy constructor with the possibility of removing subunits.\n\t * No re-clustering is done.\n\t *\n\t * @param other\n\t *            reference SubunitCluster\n\t * @param subunitsToRetain\n\t *            which subunits to copy to this cluster\n\t */\n\tpublic SubunitCluster(SubunitCluster other, List<Integer> subunitsToRetain) {\n\t\tmethod = other.method;\n\t\tpseudoStoichiometric = other.pseudoStoichiometric;\n\t\tfor (int i = 0; i < other.subunits.size(); i++) {\n\t\t\tif(subunitsToRetain.contains(i)) {\n\t\t\t\tsubunits.add(other.subunits.get(i));\n\t\t\t\tsubunitEQR.add(other.subunitEQR.get(i));\n\t\t\t}\n\t\t}\n\t\trepresentative = 0;\n\t\tfor (int i=1; i<subunits.size(); i++) {\n\t\t\tif (subunits.get(i).size() > subunits.get(representative).size()) {\n\t\t\t\trepresentative = i;\n\t\t\t}\n\t\t}\n\t\tsetAlpha(other.getAlpha());\n\t}\n\n\t/**\n\t * Subunits contained in the SubunitCluster.\n\t *\n\t * @return an unmodifiable view of the original List\n\t */\n\tpublic List<Subunit> getSubunits() {\n\t\treturn Collections.unmodifiableList(subunits);\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by String equality of their residue one-letter sequences.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalTo(SubunitCluster other) {\n\t\tString thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\tString otherSequence = other.subunits.get(other.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\treturn thisSequence.equals(otherSequence);\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by equality of their entity identifiers if they are present.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalByEntityIdTo(SubunitCluster other) {\n\t\tSubunit thisSub = this.subunits.get(this.representative);\n\t\tSubunit otherSub = other.subunits.get(other.representative);\n\t\tString thisName = thisSub.getName();\n\t\tString otherName = otherSub.getName();\n\n\t\tStructure thisStruct = thisSub.getStructure();\n\t\tStructure otherStruct = otherSub.getStructure();\n\t\tif (thisStruct == null || otherStruct == null) {\n\t\t\tlogger.info(\"SubunitClusters {}-{} have no referenced structures. Ignoring identity check by entity id\",\n\t\t\t\t\tthisName,\n\t\t\t\t\totherName);\n\t\t\treturn false;\n\t\t}\n\t\tif (thisStruct != otherStruct) {\n\t\t\t// different object references: will not cluster even if entity id is same\n\t\t\treturn false;\n\t\t}\n\t\tChain thisChain = thisStruct.getChain(thisName);\n\t\tChain otherChain = otherStruct.getChain(otherName);\n\t\tif (thisChain == null || otherChain == null) {\n\t\t\tlogger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\",\n\t\t\t\t\tthisName,\n\t\t\t\t\totherName);\n\t\t\treturn false;\n\t\t}\n\t\tif (thisChain.getEntityInfo() == null || otherChain.getEntityInfo() == null) {\n\t\t\tlogger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\",\n\t\t\t\t\tthisName,\n\t\t\t\t\totherName);\n\t\t\treturn false;\n\t\t}\n\t\tint thisEntityId = thisChain.getEntityInfo().getMolId();\n\t\tint otherEntityId = otherChain.getEntityInfo().getMolId();\n\t\treturn thisEntityId == otherEntityId;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by {@link #isIdenticalTo(SubunitCluster)}.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdentical(SubunitCluster other) {\n\n\t\tif (!isIdenticalTo(other))\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters {}-{} are identical in sequence\",\n\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\tother.subunits.get(other.representative).getName());\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by comparing the entity identifiers of the subunits\n\t * if one can be found.\n\t * Thus this only makes sense when the subunits are complete chains of a\n\t * deposited PDB entry.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdenticalByEntityId(SubunitCluster other) {\n\n\t\tif (!isIdenticalByEntityIdTo(other))\n\t\t\treturn false;\n\n\t\tSubunit thisSub = this.subunits.get(this.representative);\n\t\tSubunit otherSub = other.subunits.get(other.representative);\n\t\tString thisName = thisSub.getName();\n\t\tString otherName = otherSub.getName();\n\n\t\tlogger.info(\"SubunitClusters {}-{} belong to same entity. Assuming they are identical\",\n\t\t\t\tthisName,\n\t\t\t\totherName);\n\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// we've merged by entity id, we can assume structure, chain and entity are available (checked in isIdenticalByEntityIdTo())\n\t\tStructure thisStruct = thisSub.getStructure();\n\t\tStructure otherStruct = otherSub.getStructure();\n\t\tChain thisChain = thisStruct.getChain(thisName);\n\t\tChain otherChain = otherStruct.getChain(otherName);\n\t\tEntityInfo entityInfo = thisChain.getEntityInfo();\n\n\t\t// Extract the aligned residues of both Subunits\n\t\tfor (int thisIndex=0; thisIndex < thisSub.size(); thisIndex++) {\n\n\t\t\tGroup g = thisSub.getRepresentativeAtoms()[thisIndex].getGroup();\n\n\t\t\tint seqresIndex = entityInfo.getAlignedResIndex(g, thisChain);\n\n\t\t\tGroup otherG = otherChain.getSeqResGroups().get(seqresIndex - 1);\n\n\t\t\tif (!otherChain.getAtomGroups().contains(otherG)) {\n\t\t\t\t// skip residues that are unobserved in other sequence (\"gaps\" in the entity alignment)\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint otherIndex = otherChain.getAtomGroups().indexOf(otherG);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(otherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (according to the criteria in params).\n\t * <p>\n\t * The sequence alignment is performed using linear {@link SimpleGapPenalty} and\n\t * BLOSUM62 as scoring matrix.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            SubunitClustererParameters, with information whether to use local\n\t *            or global alignment, sequence identity and coverage thresholds.\n\t *            Threshold values lower than 0.7 are not recommended.\n\t *            Use {@link #mergeStructure} for lower values.\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\n\tpublic boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params) throws CompoundNotFoundException {\n\t\tPairwiseSequenceAlignerType alignerType = PairwiseSequenceAlignerType.LOCAL;\n\t\tif (params.isUseGlobalMetrics()) {\n\t\t\talignerType = PairwiseSequenceAlignerType.GLOBAL;\n\t\t}\n\t\treturn mergeSequence(other, params,alignerType\n\t\t\t\t, new SimpleGapPenalty(),\n\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (according to the criteria in params).\n\t * <p>\n\t * The sequence alignment is performed using linear {@link SimpleGapPenalty} and\n\t * BLOSUM62 as scoring matrix.\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            {@link SubunitClustererParameters}, with information whether to use local\n\t *            or global alignment, sequence identity and coverage thresholds.\n\t *            Threshold values lower than 0.7 are not recommended.\n\t *            Use {@link #mergeStructure} for lower values.\n\t * @param alignerType\n\t *            parameter for the sequence alignment algorithm\n\t * @param gapPenalty\n\t *            parameter for the sequence alignment algorithm\n\t * @param subsMatrix\n\t *            parameter for the sequence alignment algorithm\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\n\tpublic boolean mergeSequence(SubunitCluster other, SubunitClustererParameters params,\n\t\t\t\t\t\t\t\t PairwiseSequenceAlignerType alignerType,\n\t\t\t\t\t\t\t\t GapPenalty gapPenalty,\n\t\t\t\t\t\t\t\t SubstitutionMatrix<AminoAcidCompound> subsMatrix)\n\t\t\tthrows CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform the alignment with provided parameters\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence, alignerType,\n\t\t\t\t\t\tgapPenalty, subsMatrix);\n\n\t\tdouble sequenceIdentity;\n\t\tif(params.isUseGlobalMetrics()) {\n\t\t\tsequenceIdentity = aligner.getPair().getPercentageOfIdentity(true);\n\t\t} else {\n\t\t\tsequenceIdentity = aligner.getPair().getPercentageOfIdentity(false);\n\t\t}\n\n\t\tif (sequenceIdentity < params.getSequenceIdentityThreshold())\n\t\t\treturn false;\n\n\t\tdouble sequenceCoverage = 0;\n\t\tif(params.isUseSequenceCoverage()) {\n\t\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t\t.getNumGapPositions();\n\t\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t\t.getNumGapPositions();\n\t\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\t\tsequenceCoverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\t\tif (sequenceCoverage < params.getSequenceCoverageThreshold())\n\t\t\t\treturn false;\n\t\t}\n\n\t\tlogger.info(String.format(\"SubunitClusters %s-%s are similar in sequence \"\n\t\t\t\t\t\t+ \"with %.2f sequence identity and %.2f coverage\",\n\t\t\t\tthis.subunits.get(this.representative).getName(),\n\t\t\t\tother.subunits.get(other.representative).getName(),\n\t\t\t\tsequenceIdentity, sequenceCoverage));\n\n\t\t// If coverage and sequence identity sufficient, merge other and this\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 1; p < aligner.getPair().getLength() + 1; p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (aligner.getPair().getAlignedSequence(1).isGap(p))\n\t\t\t\tcontinue;\n\t\t\tif (aligner.getPair().getAlignedSequence(2).isGap(p))\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = aligner.getPair().getIndexInQueryAt(p) - 1;\n\t\t\tint otherIndex = aligner.getPair().getIndexInTargetAt(p) - 1;\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(otherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\tthis.method = SubunitClustererMethod.SEQUENCE;\n\t\tpseudoStoichiometric = !params.isHighConfidenceScores(sequenceIdentity,sequenceCoverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representative\n\t * Atoms are structurally similar (according to the criteria in params).\n\t * <p>\n\t *\n\t * @param other\n\t *            SubunitCluster\n\t * @param params\n\t *            {@link SubunitClustererParameters}, with information on what alignment\n\t *            algorithm to use, RMSD/TMScore and structure coverage thresholds.\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\n\tpublic boolean mergeStructure(SubunitCluster other, SubunitClustererParameters params) throws StructureException {\n\n\t\tStructureAlignment aligner = StructureAlignmentFactory.getAlgorithm(params.getSuperpositionAlgorithm());\n\t\tConfigStrucAligParams aligner_params = aligner.getParameters();\n\n\t\tMethod setOptimizeAlignment = null;\n\t\ttry {\n\t\t\tsetOptimizeAlignment = aligner_params.getClass().getMethod(\"setOptimizeAlignment\", boolean.class);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\t//alignment algorithm does not have an optimization switch, moving on\n\t\t}\n\t\tif (setOptimizeAlignment != null) {\n\t\t\ttry {\n\t\t\t\tsetOptimizeAlignment.invoke(aligner_params, params.isOptimizeAlignment());\n\t\t\t} catch (IllegalAccessException|InvocationTargetException e) {\n\t\t\t\tlogger.warn(\"Could not set alignment optimisation switch\");\n\t\t\t}\n\t\t}\n\n\t\tAFPChain afp = aligner.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convenience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble structureCoverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\n\t\tif(params.isUseStructureCoverage() && structureCoverage < params.getStructureCoverageThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (params.isUseRMSD() && rmsd > params.getRMSDThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tdouble tmScore = afp.getTMScore();\n\t\tif (params.isUseTMScore() && tmScore < params.getTMThreshold()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlogger.info(String.format(\"SubunitClusters are structurally similar with \"\n\t\t\t\t+ \"%.2f RMSD %.2f coverage\", rmsd, structureCoverage));\n\n\t\t// Merge clusters\n\t\tList<List<Integer>> alignedRes = msa.getBlock(0).getAlignRes();\n\t\tList<Integer> thisAligned = new ArrayList<>();\n\t\tList<Integer> otherAligned = new ArrayList<>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 0; p < msa.length(); p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (alignedRes.get(0).get(p) == null)\n\t\t\t\tcontinue;\n\t\t\tif (alignedRes.get(1).get(p) == null)\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = alignedRes.get(0).get(p);\n\t\t\tint otherIndex = alignedRes.get(1).get(p);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\tupdateEquivResidues(other, thisAligned, otherAligned);\n\n\t\tthis.method = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\n\t\treturn true;\n\t}\n\n\tprivate void updateEquivResidues(SubunitCluster other, List<Integer> thisAligned, List<Integer> otherAligned) {\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<>();\n\t\tList<Integer> otherRemove = new ArrayList<>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative).get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(other.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(other.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t}\n\n\t/**\n\t * Analyze the internal symmetry of the SubunitCluster and divide its\n\t * {@link Subunit} into the internal repeats (domains) if they are\n\t * internally symmetric.\n\t *\n\t * @param clusterParams {@link SubunitClustererParameters} with fields used as follows:\n\t * structureCoverageThreshold\n\t *            the minimum coverage of all repeats in the Subunit\n\t * rmsdThreshold\n\t *            the maximum allowed RMSD between the repeats\n\t * minimumSequenceLength\n\t *            the minimum length of the repeating units\n\t * @return true if the cluster was internally symmetric, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean divideInternally(SubunitClustererParameters clusterParams)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters cesym_params = new CESymmParameters();\n\t\tcesym_params.setMinCoreLength(clusterParams.getMinimumSequenceLength());\n\t\tcesym_params.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), cesym_params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > clusterParams.getRMSDThreshold())\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < clusterParams.getStructureCoverageThreshold())\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitCluster is internally symmetric with {} repeats, \"\n\t\t\t\t+ \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms, subunits.get(s)\n\t\t\t\t\t\t.getName(), subunits.get(s).getIdentifier(), subunits\n\t\t\t\t\t\t.get(s).getStructure()));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.STRUCTURE;\n\t\tpseudoStoichiometric = true;\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return the number of Subunits in the cluster\n\t */\n\tpublic int size() {\n\t\treturn subunits.size();\n\t}\n\n\t/**\n\t * @return the number of aligned residues between Subunits of the cluster\n\t */\n\tpublic int length() {\n\t\treturn subunitEQR.get(representative).size();\n\t}\n\n\t/**\n\t * @return the {@link SubunitClustererMethod} used for clustering the\n\t *         Subunits\n\t */\n\tpublic SubunitClustererMethod getClustererMethod() {\n\t\treturn method;\n\t}\n\n\t/**\n\t * @return A List of size {@link #size()} of Atom arrays of length\n\t *         {@link #length()} with the aligned Atoms for each Subunit in the\n\t *         cluster\n\t */\n\tpublic List<Atom[]> getAlignedAtomsSubunits() {\n\n\t\tList<Atom[]> alignedAtoms = Collections.emptyList();\n\n\t\t// Loop through all subunits and add the aligned positions\n\t\tfor (int s = 0; s < subunits.size(); s++)\n\t\t\talignedAtoms.add(getAlignedAtomsSubunit(s));\n\n\t\treturn alignedAtoms;\n\t}\n\n\t/**\n\t * @param index\n\t *            Subunit index in the Cluster\n\t * @return An Atom array of length {@link #length()} with the aligned Atoms\n\t *         from the selected Subunit in the Cluster\n\t */\n\tpublic Atom[] getAlignedAtomsSubunit(int index) {\n\n\t\tAtom[] aligned = new Atom[subunitEQR.get(index).size()];\n\n\t\t// Add only the aligned positions of the Subunit in the Cluster\n\t\tfor (int p = 0; p < subunitEQR.get(index).size(); p++) {\n\t\t\taligned[p] = subunits.get(index).getRepresentativeAtoms()[subunitEQR\n\t\t\t\t\t.get(index).get(p)];\n\t\t}\n\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * The multiple alignment is calculated from the equivalent residues in the\n\t * SubunitCluster. The alignment is recalculated every time the method is\n\t * called (no caching).\n\t *\n\t * @return MultipleAlignment representation of the aligned residues in this\n\t *         Subunit Cluster\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment getMultipleAlignment() throws StructureException {\n\n\t\t// Create a multiple alignment with the atom arrays of the Subunits\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\tsubunits.stream().map(s -> s.getRepresentativeAtoms())\n\t\t\t\t\t\t.collect(Collectors.toList()));\n\n\t\t// Fill in the alignment information\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(subunitEQR);\n\n\t\t// Fill in the transformation matrices\n\t\tnew ReferenceSuperimposer(representative).superimpose(msa);\n\n\t\t// Calculate some scores\n\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\treturn msa;\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubunitCluster [Size=\" + size() + \", Length=\" + length()\n\t\t\t\t+ \", Representative=\" + representative + \", Method=\" + method\n\t\t\t\t+ \"]\";\n\t}\n\n\t/**\n\t * @return true if this cluster is considered pseudo-stoichiometric (i.e.,\n\t * \t\t   was either clustered by structure, or by sequence with low scores),\n\t *         false otherwise.\n\t */\n\tpublic boolean isPseudoStoichiometric() {\n\t\treturn pseudoStoichiometric;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.junit.Test;\n\n/**\n * Test the {@link SubunitCluster} merge and divide methods, one test specific\n * for each method.\n *\n * @author Aleix Lafita\n *\n */\npublic class TestSubunitCluster {\n\n\t/**\n\t * Test {@link SubunitCluster#mergeIdentical(SubunitCluster)}.\n\t */\n\t@Test\n\tpublic void testMergeIdentical() {\n\n\t\t// Create an Atom Array of poly-alanine\n\t\tAtom[] reprAtoms = mockAtomArray(10, \"ALA\", -1, null);\n\n\t\t// Create two identical SubunitCluster\n\t\tSubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms,\n\t\t\t\t\"subunit 1\", null, null));\n\t\tSubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms,\n\t\t\t\t\"subunit 2\", null, null));\n\n\t\tboolean merged = sc1.mergeIdentical(sc2);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(10, sc1.length());\n\n\t\t// Create an Atom Array of poly-glycine\n\t\tAtom[] reprAtoms2 = mockAtomArray(10, \"GLY\", -1, null);\n\n\t\tSubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2,\n\t\t\t\t\"subunit 1\", null, null));\n\n\t\tmerged = sc1.mergeIdentical(sc3);\n\n\t\t// Merged have to be false, and Clusters result inmodified\n\t\tassertFalse(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(10, sc1.length());\n\n\t}\n\n\t@Test\n\tpublic void testMergeIdenticalByEntityId() {\n\n\t\t// Create 2 Atom Arrays, with same entity id\n\t\tStructure structure = mockStructure();\n\t\tAtom[] reprAtoms1 = getAtomArray(structure.getChain(\"A\"));\n\t\tAtom[] reprAtoms2 = getAtomArray(structure.getChain(\"B\"));\n\n\t\t// Create two SubunitCluster with same entity id\n\t\tSubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms1,\n\t\t\t\t\"A\", null, structure));\n\t\tSubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms2,\n\t\t\t\t\"B\", null, structure));\n\n\t\tboolean merged = sc1.mergeIdenticalByEntityId(sc2);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(9, sc1.length());\n\n\t\t// Create an Atom Array of poly-glycine with a different entity id\n\t\tAtom[] reprAtoms3 = getAtomArray(structure.getChain(\"C\"));\n\n\t\tSubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms3,\n\t\t\t\t\"C\", null, structure));\n\n\t\tmerged = sc1.mergeIdenticalByEntityId(sc3);\n\n\t\t// Merged have to be false, and Clusters result unmodified\n\t\tassertFalse(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(9, sc1.length());\n\n\t}\n\n\t/**\n\t * Test {@link SubunitCluster#mergeSequence(SubunitCluster, SubunitClustererParameters)}\n\t *\n\t * @throws CompoundNotFoundException\n\t */\n\t@Test\n\tpublic void testMergeSequence() throws CompoundNotFoundException {\n\n\t\t// Create an Atom Array of poly-alanine\n\t\tAtom[] reprAtoms = mockAtomArray(100, \"ALA\", -1, null);\n\n\t\t// Create two identical SubunitCluster\n\t\tSubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms,\n\t\t\t\t\"subunit 1\", null, null));\n\t\tSubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms,\n\t\t\t\t\"subunit 2\", null, null));\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setSequenceIdentityThreshold(0.9);\n\t\tclustererParameters.setSequenceCoverageThreshold(0.9);\n\t\tboolean merged = sc1.mergeSequence(sc2, clustererParameters);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(100, sc1.length());\n\n\t\t// Create an Atom Array of poly-glycine\n\t\tAtom[] reprAtoms2 = mockAtomArray(100, \"GLY\", -1, null);\n\n\t\tSubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2,\n\t\t\t\t\"subunit 3\", null, null));\n\n\t\tmerged = sc1.mergeSequence(sc3,clustererParameters);\n\n\t\t// Merged have to be false, and Clusters result inmodified\n\t\tassertFalse(merged);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(100, sc1.length());\n\n\t\t// Create an Atom Array of 9 glycine and 91 alanine\n\t\tAtom[] reprAtoms3 = mockAtomArray(9, \"GLY\", 91, \"ALA\");\n\n\t\tSubunitCluster sc4 = new SubunitCluster(new Subunit(reprAtoms3,\n\t\t\t\t\"subunit 4\", null, null));\n\n\t\tmerged = sc1.mergeSequence(sc4, clustererParameters);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(3, sc1.size());\n\t\tassertEquals(1, sc2.size());\n\t\tassertEquals(91, sc1.length());\n\n\t}\n\n\t/**\n\t * Test\n\t * {@link SubunitCluster#mergeStructure(SubunitCluster, SubunitClustererParameters)}\n\t *\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testMergeStructure() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4hhb\");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(1)), \"chain 1\", null, s));\n\t\tSubunitCluster sc3 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(2)), \"chain 2\", null, s));\n\t\tSubunitCluster sc4 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(3)), \"chain 3\", null, s));\n\n\t\t// Clusters 1 and 3 and 2 and 4 are identical\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setStructureCoverageThreshold(0.9);\n\n\t\tboolean merged13 = sc1.mergeStructure(sc3,clustererParameters);\n\t\tboolean merged24 = sc2.mergeStructure(sc4,clustererParameters);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged13);\n\t\tassertTrue(merged24);\n\t\tassertEquals(2, sc1.size());\n\t\tassertEquals(2, sc2.size());\n\t\tassertEquals(141, sc1.length());\n\t\tassertEquals(146, sc2.length());\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t\tassertEquals(sc2.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc2.getAlignedAtomsSubunit(1).length);\n\n\t\t// Now test for pseudosymmetry\n\t\tboolean merged = sc1.mergeStructure(sc2, clustererParameters);\n\n\t\tassertTrue(merged);\n\t\tassertEquals(4, sc1.size());\n\t\tassertEquals(140, sc1.length(), 2);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(2).length);\n\n\t}\n\n\t/**\n\t * Test {@link SubunitCluster#divideInternally(SubunitClustererParameters)}\n\t *\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testDivideInternally() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4e3e\");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0)), \"chain 0\", null, s));\n\n\t\tSubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n\t\tclustererParameters.setStructureCoverageThreshold(0.8);\n\t\tclustererParameters.setRMSDThreshold(3.0);\n\t\tclustererParameters.setMinimumSequenceLength(20);\n\n\t\t// Clusters should be merged by identity\n\t\tboolean divided = sc1.divideInternally(clustererParameters);\n\n\t\t// Divided has to be true, and Subunit length shorter than half\n\t\tassertTrue(divided);\n\t\tassertEquals(2, sc1.size());\n\t\tassertTrue(sc1.length() < 178);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t}\n\n\t/**\n\t * Create a mock atom array, with size1 residues of type1, followed by size2 residues of type2.\n\t *\n\t * @param size1 the number of residues of type1 to add\n\t * @param type1 the 3 letter code of residue\n\t * @param size2 the number of residues of type2 to add, if -1 none are added\n\t * @param type2 the 3 letter code of residue, if null none are added\n\t * @return the mock atom array\n\t */\n\tprivate Atom[] mockAtomArray(int size1, String type1, int size2, String type2) {\n\n\t\tList<Atom> atoms = new ArrayList<>(size1 + size2);\n\t\tfor (int i = 0; i < size1; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(type1);\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms.add(a);\n\t\t}\n\n\t\tif (size2 >= 0 && type2 !=null) {\n\t\t\tfor (int i = 0; i < size2; i++) {\n\t\t\t\tGroup g = new AminoAcidImpl();\n\t\t\t\tg.setPDBName(type2);\n\t\t\t\tAtom a = new AtomImpl();\n\t\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\t\tg.addAtom(a);\n\t\t\t\tatoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn atoms.toArray(new Atom[0]);\n\t}\n\n\t/**\n\t * Create a mock structure with 2 entities 1 (chains A, B) and 2 (chain C).\n\t * @return a structure\n\t */\n\tprivate Structure mockStructure() {\n\t\tStructure structure = new StructureImpl();\n\t\tEntityInfo entity1 = new EntityInfo();\n\t\tentity1.setMolId(1);\n\t\tEntityInfo entity2 = new EntityInfo();\n\t\tentity2.setMolId(2);\n\t\tstructure.addEntityInfo(entity1);\n\t\tstructure.addEntityInfo(entity2);\n\n\t\tChain chainA = new ChainImpl();\n\t\tchainA.setId(\"A\");\n\t\tChain chainB = new ChainImpl();\n\t\tchainB.setId(\"B\");\n\t\tentity1.addChain(chainA);\n\t\tentity1.addChain(chainB);\n\t\tChain chainC = new ChainImpl();\n\t\tchainC.setId(\"C\");\n\t\tentity2.addChain(chainC);\n\n\t\tstructure.addChain(chainA);\n\t\tstructure.addChain(chainB);\n\t\tstructure.addChain(chainC);\n\n\t\t// entity 1: chain A 10 observed residues, chain B 9 observed residues (first unobserved)\n\t\tList<Group> aGroups = getGroupList(10, \"ALA\", chainA);\n\t\tchainA.setAtomGroups(new ArrayList<>(aGroups));\n\t\tchainA.setSeqResGroups(aGroups);\n\t\tchainA.setEntityInfo(entity1);\n\n\t\tList<Group> bGroups = getGroupList(10, \"ALA\", chainB);\n\t\tchainB.setAtomGroups(new ArrayList<>(bGroups.subList(1,10)));\n\t\tchainB.setSeqResGroups(bGroups);\n\t\tchainB.setEntityInfo(entity1);\n\n\t\tList<Group> cGroups = getGroupList(20, \"GLY\", chainC);\n\t\tchainC.setAtomGroups(new ArrayList<>(cGroups));\n\t\tchainC.setSeqResGroups(cGroups);\n\t\tchainC.setEntityInfo(entity2);\n\n\t\treturn structure;\n\t}\n\n\tprivate List<Group> getGroupList(int size, String type, Chain chain) {\n\t\tList<Group> list = new ArrayList<>();\n\t\tfor (int i=0;i<size;i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(type);\n\t\t\tg.setResidueNumber(new ResidueNumber(chain.getId(), i+1, null));\n\t\t\tchain.addGroup(g);\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tlist.add(g);\n\t\t}\n\t\treturn list;\n\t}\n\n\tprivate Atom[] getAtomArray(Chain chain) {\n\t\tAtom[] atoms = new Atom[chain.getAtomGroups().size()];\n\t\tfor (int i = 0; i<chain.getAtomGroups().size(); i++) {\n\t\t\tatoms[i] = chain.getAtomGroups().get(i).getAtom(StructureTools.CA_ATOM_NAME);\n\t\t}\n\t\treturn atoms;\n\t}\n}\n","changedTest":"","commitMessage":"Some improvements\n","test_commitMessage":"","allZero":false}