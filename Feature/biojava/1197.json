{"repository":"biojava","prod_path":"biojava3-protmod/src/main/java/org/biojava3/protmod/parser/AttachmentParser.java","test_path":"biojava3-protmod/src/test/java/org/biojava3/protmod/parser/AttachmentParserTest.java","prod_time":"2010-06-10 11:16:06","test_time":"2010-06-10 11:16:06","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"f5d9fe909f073d72904262646c822cc30d1e2afb","test_commitID":"f5d9fe909f073d72904262646c822cc30d1e2afb","isfound":"found test change","originPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 6, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Calc;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.GroupType;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\n\r\nimport org.biojava3.protmod.AtomBond;\r\nimport org.biojava3.protmod.Component;\r\nimport org.biojava3.protmod.ComponentType;\r\nimport org.biojava3.protmod.ModificationCategory;\r\nimport org.biojava3.protmod.ModificationCondition;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ModifiedCompoundFactory;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * Identify attachment modification in a 3-D structure.\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class AttachmentParser implements ProteinModificationParser {\r\n\tfinal double bondLengthTolerance;\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bondLengthTolerance tolerance of error (in Angstroms) of the\r\n\t *  covalent bond length, when calculating the atom distance threshold.\r\n\t */\r\n\tpublic AttachmentParser(final double bondLengthTolerance) {\r\n\t\tif (bondLengthTolerance<0) {\r\n\t\t\tthrow new IllegalArgumentException(\"bondLengthTolerance \" +\r\n\t\t\t\t\t\"must be positive.\");\r\n\t\t}\r\n\t\tthis.bondLengthTolerance = bondLengthTolerance;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parse attachement modification in a structure.\r\n\t * @param structure query {@link Structure}.\r\n\t * @param potentialModifications query {@link ProteinModification}s.\r\n\t * @param modelnr model number.\r\n\t * @return an list of {@link ModifiedCompound}s, or null if the\r\n\t *  nodelnr is larger than the number of models in the structure.\r\n\t * @throws IllegalArgumentException if null structure, or null or \r\n\t *  empty potentialModifications, or potentialModifications contain \r\n\t *  modifications other than ATTACHMENT.\r\n\t */\r\n\t@Override\r\n\tpublic List<ModifiedCompound> parse(final Structure structure, \r\n\t\t\tfinal Set<ProteinModification> potentialModifications,\r\n\t\t\tfinal int modelnr) {\r\n\t\tif (structure==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null structure.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications==null || potentialModifications.isEmpty()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null or empty potentialModifications.\");\r\n\t\t}\r\n\t\t\r\n\t\tfor (ProteinModification mod:potentialModifications) {\r\n\t\t\tif (mod.getCategory()!=ModificationCategory.ATTACHMENT) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Only ATTACHMENT is allowed.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (modelnr >= structure.nrModels())\r\n\t\t\treturn null;\r\n\t\t\r\n\t\tList<ModifiedCompound> ret = new ArrayList<ModifiedCompound>();\r\n\t\t\r\n\t\t// TODO: how to deal with multi-model structure?\r\n\t\tList<Chain> chains = structure.getChains(modelnr);\r\n\t\tfor (Chain chain : chains) {\r\n\t\t\tMap<Component, List<Group>> mapCompRes = \r\n\t\t\t\t\tmodifiableResidues(chain, potentialModifications);\r\n\t\t\t\r\n\t\t\tList<Group> groups = chain.getAtomGroups(GroupType.HETATM);\r\n\t\t\t\r\n\t\t\t// for all heta\r\n\t\t\tfor (Group group : groups) {\r\n\t\t\t\tString pdbccId = group.getPDBName();\r\n\t\t\t\tComponent comp = Component.of(pdbccId);\r\n\t\t\t\tif (comp==null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tSet<ProteinModification> mods = ProteinModification.getByComponent(comp);\r\n\t\t\t\tif (mods==null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tmods = new HashSet<ProteinModification>(mods);\r\n\t\t\t\tmods.retainAll(potentialModifications);\r\n\t\t\t\t\r\n\t\t\t\tif (mods.isEmpty()) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (ProteinModification mod : mods) {\r\n\t\t\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\t\t\tcomp = condition.getComponents().get(0);\r\n\t\t\t\t\tif (comp.getType() != ComponentType.AMINOACID) {\r\n\t\t\t\t\t\tthrow new IllegalStateException(\"No residue involved in modification\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tList<Group> residues = mapCompRes.get(comp);\r\n\t\t\t\t\tif (residues == null || residues.isEmpty()) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tAtom atomOnAttachedGroup = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\t//* use atom specified by condition\r\n\t\t\t\t\tAtomBond bond = condition.getBonds().get(0);\r\n\t\t\t\t\tString nameOfAtomOnResidue = bond.getAtom1();\r\n\t\t\t\t\tString nameOfAtomOnAttachedGroup = bond.getAtom2();\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tatomOnAttachedGroup = group.getAtom(nameOfAtomOnAttachedGroup);\r\n\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (atomOnAttachedGroup==null) {\r\n\t\t\t\t\t\tSystem.err.println(\"Atom does not exist.\");\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}//*/\r\n\t\t\t\t\t\r\n\t\t\t\t\tdouble clostestDistance = Double.POSITIVE_INFINITY;\r\n\t\t\t\t\tGroup clostestResidue = null;\r\n\t\t\t\t\tAtom closestAtomOnResidue = null;\r\n\t\t\t\t\tfor (Group residue : residues) {\r\n\t\t\t\t\t\t//* use atom specified in condition\r\n\t\t\t\t\t\tAtom atomOnResidue = null;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tatomOnResidue = residue.getAtom(nameOfAtomOnResidue);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\t//e.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (atomOnResidue==null) {\r\n\t\t\t\t\t\t\t//System.err.println(\"Atom does not exist.\");\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdouble distance;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tdistance = Calc.getDistance(atomOnAttachedGroup, atomOnResidue);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (distance < clostestDistance) {\r\n\t\t\t\t\t\t\tclostestDistance = distance;\r\n\t\t\t\t\t\t\tclostestResidue = residue;\r\n\t\t\t\t\t\t\tclosestAtomOnResidue = atomOnResidue;\r\n\t\t\t\t\t\t}//*/\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t/* find the atom\r\n\t\t\t\t\t\tAtom[] atoms;\r\n\t\t\t\t\t\tdouble distance;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tatoms = findNearestAtoms(residue, group);\r\n\t\t\t\t\t\t\tif (atoms==null) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdistance = Calc.getDistance(atoms[0], atoms[1]);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (distance < clostestDistance) {\r\n\t\t\t\t\t\t\tclostestDistance = distance;\r\n\t\t\t\t\t\t\tclostestResidue = residue;\r\n\t\t\t\t\t\t\tclosestAtomOnResidue = atoms[0];\r\n\t\t\t\t\t\t\tatomOnAttachedGroup = atoms[1];\r\n\t\t\t\t\t\t}//*/\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (Double.isInfinite(clostestDistance)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat radiusOfAtomOnResidue = \r\n\t\t\t\t\t\tclosestAtomOnResidue.getElement().getCovalentRadius();\t\t\t\t\t\r\n\t\t\t\t\tfloat radiusOfAtomOnAttachedGroup = \r\n\t\t\t\t\t\tatomOnAttachedGroup.getElement().getCovalentRadius();\r\n\t\t\t\t\tif (Math.abs(clostestDistance-radiusOfAtomOnResidue\r\n\t\t\t\t\t\t\t-radiusOfAtomOnAttachedGroup) < bondLengthTolerance) {\r\n\t\t\t\t\t\tModifiedCompound attachment = ModifiedCompoundFactory\r\n\t\t\t\t\t\t\t\t.createAttachmentModification(mod, clostestResidue, \r\n\t\t\t\t\t\t\t\t\t\tclosestAtomOnResidue, group, atomOnAttachedGroup);\r\n\t\t\t\t\t\tret.add(attachment);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Find the nearest Atoms between a pair of {@link Group}s.\r\n\t * @param group1\r\n\t * @param group2\r\n\t * @return a pair of Atoms.\r\n\t * @throws StructureException ...\r\n\t */\r\n\tprivate Atom[] findNearestAtoms(Group group1, Group group2)\r\n\t\t\tthrows StructureException {\t\t\r\n\t\tdouble nearestDistance = Double.MAX_VALUE;\r\n\t\tAtom[] ret = new Atom[2];\r\n\t\t\r\n\t\tIterator<Atom> it1 = group1.iterator();\r\n\t\twhile (it1.hasNext()) {\r\n\t\t\tAtom atom1 = it1.next();\r\n\t\t\tIterator<Atom> it2 = group2.iterator();\r\n\t\t\twhile (it2.hasNext()) {\r\n\t\t\t\tAtom atom2 = it2.next();\r\n\t\t\t\tdouble dis = Calc.getDistance(atom1, atom2);\r\n\t\t\t\tif (dis < nearestDistance) {\r\n\t\t\t\t\tnearestDistance = dis;\r\n\t\t\t\t\tret[0] = atom1;\r\n\t\t\t\t\tret[1] = atom2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (ret[0]==null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param chain {@link Chain}.\r\n\t * @param modifications a set of {@link ProteinModification}s.\r\n\t * @return map from component to list of corresponding residues\r\n\t *  in the chain.\r\n\t */\r\n\tprivate Map<Component, List<Group>> modifiableResidues(\r\n\t\t\tfinal Chain chain, \r\n\t\t\tfinal Set<ProteinModification> modifications) {\r\n\t\tList<Group> residues = chain.getSeqResGroups();\r\n\t\tMap<Component, List<Group>> mapCompRes = new HashMap<Component, List<Group>>();\r\n\t\t\r\n\t\t// for all residue\r\n\t\tfor (Group res : residues) {\r\n\t\t\tString pdbccId = res.getPDBName();\r\n\t\t\tComponent comp = Component.of(pdbccId);\r\n\t\t\tif (comp==null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tList<Group> groups = mapCompRes.get(comp);\r\n\t\t\tif (groups==null) {\r\n\t\t\t\tgroups = new ArrayList<Group>();\r\n\t\t\t\tmapCompRes.put(comp, groups);\r\n\t\t\t}\r\n\t\t\tgroups.add(res);\r\n\t\t}\r\n\t\t\r\n\t\t// for N-terminal\r\n\t\tGroup res = residues.get(0);\r\n\t\tComponent comp = Component.of(res.getPDBName(), true, false);\r\n\t\tif (comp!=null) {\r\n\t\t\tList<Group> groups = new ArrayList<Group>(1);\r\n\t\t\tgroups.add(res);\r\n\t\t\tmapCompRes.put(comp, groups);\r\n\t\t}\r\n\t\t\r\n\t\t// for C-terminal\r\n\t\tres = residues.get(residues.size()-1);\r\n\t\tcomp = Component.of(res.getPDBName(), false, true);\r\n\t\tif (comp!=null) {\r\n\t\t\tList<Group> groups = new ArrayList<Group>(1);\r\n\t\t\tgroups.add(res);\r\n\t\t\tmapCompRes.put(comp, groups);\r\n\t\t}\r\n\r\n\t\treturn mapCompRes;\r\n\t}\r\n}\r\n","changedPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 6, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.Iterator;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Calc;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.GroupType;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\n\r\nimport org.biojava3.protmod.AtomBond;\r\nimport org.biojava3.protmod.Component;\r\nimport org.biojava3.protmod.ComponentType;\r\nimport org.biojava3.protmod.ModificationCategory;\r\nimport org.biojava3.protmod.ModificationCondition;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ModifiedCompoundFactory;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * Identify attachment modification in a 3-D structure.\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class AttachmentParser implements ProteinModificationParser {\r\n\tfinal double bondLengthTolerance;\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bondLengthTolerance tolerance of error (in Angstroms) of the\r\n\t *  covalent bond length, when calculating the atom distance threshold.\r\n\t */\r\n\tpublic AttachmentParser(final double bondLengthTolerance) {\r\n\t\tif (bondLengthTolerance<0) {\r\n\t\t\tthrow new IllegalArgumentException(\"bondLengthTolerance \" +\r\n\t\t\t\t\t\"must be positive.\");\r\n\t\t}\r\n\t\tthis.bondLengthTolerance = bondLengthTolerance;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parse attachement modification in a structure.\r\n\t * @param structure query {@link Structure}.\r\n\t * @param potentialModifications query {@link ProteinModification}s.\r\n\t * @param modelnr model number.\r\n\t * @return an list of {@link ModifiedCompound}s, or null if the\r\n\t *  nodelnr is larger than the number of models in the structure.\r\n\t * @throws IllegalArgumentException if null structure, or null or \r\n\t *  empty potentialModifications, or potentialModifications contain \r\n\t *  modifications other than ATTACHMENT.\r\n\t */\r\n\t@Override\r\n\tpublic List<ModifiedCompound> parse(final Structure structure, \r\n\t\t\tfinal Set<ProteinModification> potentialModifications,\r\n\t\t\tfinal int modelnr) {\r\n\t\tif (structure==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null structure.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications==null || potentialModifications.isEmpty()) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null or empty potentialModifications.\");\r\n\t\t}\r\n\t\t\r\n\t\tfor (ProteinModification mod:potentialModifications) {\r\n\t\t\tif (mod.getCategory()!=ModificationCategory.ATTACHMENT) {\r\n\t\t\t\tthrow new IllegalArgumentException(\"Only ATTACHMENT is allowed.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (modelnr >= structure.nrModels())\r\n\t\t\treturn null;\r\n\t\t\r\n\t\tList<ModifiedCompound> ret = new ArrayList<ModifiedCompound>();\r\n\t\t\r\n\t\t// TODO: how to deal with multi-model structure?\r\n\t\tList<Chain> chains = structure.getChains(modelnr);\r\n\t\tfor (Chain chain : chains) {\r\n\t\t\tMap<Component, List<Group>> mapCompRes = \r\n\t\t\t\t\tmodifiableResidues(chain, potentialModifications);\r\n\t\t\t\r\n\t\t\tList<Group> groups = chain.getAtomGroups(GroupType.HETATM);\r\n\t\t\t\r\n\t\t\t// for all heta\r\n\t\t\tfor (Group group : groups) {\r\n\t\t\t\tString pdbccId = group.getPDBName();\r\n\t\t\t\tComponent comp = Component.of(pdbccId);\r\n\t\t\t\tif (comp==null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tSet<ProteinModification> mods = ProteinModification.getByComponent(comp);\r\n\t\t\t\tif (mods==null) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tmods = new HashSet<ProteinModification>(mods);\r\n\t\t\t\tmods.retainAll(potentialModifications);\r\n\t\t\t\t\r\n\t\t\t\tif (mods.isEmpty()) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tfor (ProteinModification mod : mods) {\r\n\t\t\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\t\t\tcomp = condition.getComponents().get(0);\r\n\t\t\t\t\tif (comp.getType() != ComponentType.AMINOACID) {\r\n\t\t\t\t\t\tthrow new IllegalStateException(\"No residue involved in modification\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tList<Group> residues = mapCompRes.get(comp);\r\n\t\t\t\t\tif (residues == null || residues.isEmpty()) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tAtom atomOnAttachedGroup = null;\r\n\t\t\t\t\t\r\n\t\t\t\t\t//* use atom specified by condition\r\n\t\t\t\t\tAtomBond bond = condition.getBonds().get(0);\r\n\t\t\t\t\tString nameOfAtomOnResidue = bond.getAtom1();\r\n\t\t\t\t\tString nameOfAtomOnAttachedGroup = bond.getAtom2();\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tatomOnAttachedGroup = group.getAtom(nameOfAtomOnAttachedGroup);\r\n\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (atomOnAttachedGroup==null) {\r\n\t\t\t\t\t\tSystem.err.println(\"Atom does not exist.\");\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}//*/\r\n\t\t\t\t\t\r\n\t\t\t\t\tdouble clostestDistance = Double.POSITIVE_INFINITY;\r\n\t\t\t\t\tGroup clostestResidue = null;\r\n\t\t\t\t\tAtom closestAtomOnResidue = null;\r\n\t\t\t\t\tfor (Group residue : residues) {\r\n\t\t\t\t\t\t//* use atom specified in condition\r\n\t\t\t\t\t\tAtom atomOnResidue = null;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tatomOnResidue = residue.getAtom(nameOfAtomOnResidue);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\t//e.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (atomOnResidue==null) {\r\n\t\t\t\t\t\t\t//System.err.println(\"Atom does not exist.\");\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tdouble distance;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tdistance = Calc.getDistance(atomOnAttachedGroup, atomOnResidue);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (distance < clostestDistance) {\r\n\t\t\t\t\t\t\tclostestDistance = distance;\r\n\t\t\t\t\t\t\tclostestResidue = residue;\r\n\t\t\t\t\t\t\tclosestAtomOnResidue = atomOnResidue;\r\n\t\t\t\t\t\t}//*/\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t/* find the atom\r\n\t\t\t\t\t\tAtom[] atoms;\r\n\t\t\t\t\t\tdouble distance;\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tatoms = findNearestAtoms(residue, group);\r\n\t\t\t\t\t\t\tif (atoms==null) {\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdistance = Calc.getDistance(atoms[0], atoms[1]);\r\n\t\t\t\t\t\t} catch (StructureException e) {\r\n\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (distance < clostestDistance) {\r\n\t\t\t\t\t\t\tclostestDistance = distance;\r\n\t\t\t\t\t\t\tclostestResidue = residue;\r\n\t\t\t\t\t\t\tclosestAtomOnResidue = atoms[0];\r\n\t\t\t\t\t\t\tatomOnAttachedGroup = atoms[1];\r\n\t\t\t\t\t\t}//*/\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (Double.isInfinite(clostestDistance)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tfloat radiusOfAtomOnResidue = \r\n\t\t\t\t\t\tclosestAtomOnResidue.getElement().getCovalentRadius();\t\t\t\t\t\r\n\t\t\t\t\tfloat radiusOfAtomOnAttachedGroup = \r\n\t\t\t\t\t\tatomOnAttachedGroup.getElement().getCovalentRadius();\r\n\t\t\t\t\tif (Math.abs(clostestDistance-radiusOfAtomOnResidue\r\n\t\t\t\t\t\t\t-radiusOfAtomOnAttachedGroup) < bondLengthTolerance) {\r\n\t\t\t\t\t\tModifiedCompound attachment = ModifiedCompoundFactory\r\n\t\t\t\t\t\t\t\t.createAttachmentModification(mod, clostestResidue, \r\n\t\t\t\t\t\t\t\t\t\tclosestAtomOnResidue, group, atomOnAttachedGroup);\r\n\t\t\t\t\t\tret.add(attachment);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// TODO: identify additional attached groups that are not \r\n\t\t\t// directly attached to protein residues.\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Find the nearest Atoms between a pair of {@link Group}s.\r\n\t * @param group1\r\n\t * @param group2\r\n\t * @return a pair of Atoms.\r\n\t * @throws StructureException ...\r\n\t */\r\n\tprivate Atom[] findNearestAtoms(Group group1, Group group2)\r\n\t\t\tthrows StructureException {\t\t\r\n\t\tdouble nearestDistance = Double.MAX_VALUE;\r\n\t\tAtom[] ret = new Atom[2];\r\n\t\t\r\n\t\tIterator<Atom> it1 = group1.iterator();\r\n\t\twhile (it1.hasNext()) {\r\n\t\t\tAtom atom1 = it1.next();\r\n\t\t\tIterator<Atom> it2 = group2.iterator();\r\n\t\t\twhile (it2.hasNext()) {\r\n\t\t\t\tAtom atom2 = it2.next();\r\n\t\t\t\tdouble dis = Calc.getDistance(atom1, atom2);\r\n\t\t\t\tif (dis < nearestDistance) {\r\n\t\t\t\t\tnearestDistance = dis;\r\n\t\t\t\t\tret[0] = atom1;\r\n\t\t\t\t\tret[1] = atom2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (ret[0]==null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param chain {@link Chain}.\r\n\t * @param modifications a set of {@link ProteinModification}s.\r\n\t * @return map from component to list of corresponding residues\r\n\t *  in the chain.\r\n\t */\r\n\tprivate Map<Component, List<Group>> modifiableResidues(\r\n\t\t\tfinal Chain chain, \r\n\t\t\tfinal Set<ProteinModification> modifications) {\r\n\t\tList<Group> residues = chain.getSeqResGroups();\r\n\t\tMap<Component, List<Group>> mapCompRes = new HashMap<Component, List<Group>>();\r\n\t\t\r\n\t\t// for all residue\r\n\t\tfor (Group res : residues) {\r\n\t\t\tString pdbccId = res.getPDBName();\r\n\t\t\tComponent comp = Component.of(pdbccId);\r\n\t\t\tif (comp==null) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tList<Group> groups = mapCompRes.get(comp);\r\n\t\t\tif (groups==null) {\r\n\t\t\t\tgroups = new ArrayList<Group>();\r\n\t\t\t\tmapCompRes.put(comp, groups);\r\n\t\t\t}\r\n\t\t\tgroups.add(res);\r\n\t\t}\r\n\t\t\r\n\t\t// for N-terminal\r\n\t\tGroup res = residues.get(0);\r\n\t\tComponent comp = Component.of(res.getPDBName(), true, false);\r\n\t\tif (comp!=null) {\r\n\t\t\tList<Group> groups = new ArrayList<Group>(1);\r\n\t\t\tgroups.add(res);\r\n\t\t\tmapCompRes.put(comp, groups);\r\n\t\t}\r\n\t\t\r\n\t\t// for C-terminal\r\n\t\tres = residues.get(residues.size()-1);\r\n\t\tcomp = Component.of(res.getPDBName(), false, true);\r\n\t\tif (comp!=null) {\r\n\t\t\tList<Group> groups = new ArrayList<Group>(1);\r\n\t\t\tgroups.add(res);\r\n\t\t\tmapCompRes.put(comp, groups);\r\n\t\t}\r\n\r\n\t\treturn mapCompRes;\r\n\t}\r\n}\r\n","originTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 8, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.io.IOException;\r\n\r\nimport java.net.URL;\r\n\r\nimport java.util.List;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Calc;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\nimport org.biojava.bio.structure.io.PDBFileReader;\r\n\r\nimport org.biojava3.protmod.ModificationCategory;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class AttachmentParserTest extends TestCase {\r\n\r\n\tpublic void testParser() throws IOException, StructureException {\r\n\t\tSystem.out.println(\"===Begin testing on ModifiedResidueParser\");\r\n\t\t\r\n\t\tString server = \"http://www.pdb.org/pdb/files/\";\r\n\t\tURL url;\r\n\t\tString name;\r\n\t\t\r\n//\t\tname = \"3HN3\"; // NAG\r\n//\t\tSystem.out.println(name);\r\n//\t\turl = new URL(server+name+\".pdb\");\r\n//\t\tassertNotNull(url);\r\n//\t\tparserTest(url);\r\n//\t\t\r\n//\t\tname = \"1CPO\"; // XYS\r\n//\t\tSystem.out.println(name);\r\n//\t\turl = new URL(server+name+\".pdb\");\r\n//\t\tassertNotNull(url);\r\n//\t\tparserTest(url);\r\n\t\t\r\n\t\tname = \"1AL2\"; // MYR\r\n\t\tSystem.out.println(name);\r\n\t\turl = new URL(server+name+\".pdb\");\r\n\t\tassertNotNull(url);\r\n\t\tparserTest(url);\r\n\t\t\r\n\t\tSystem.out.println(\"===End testing on ModifiedResidueParser\");\r\n\t}\r\n\t\r\n\tprivate void parserTest(URL pdbUrl) throws IOException, StructureException {\r\n\t\tPDBFileReader pdbReader = new PDBFileReader();\r\n\t\tStructure struc = pdbReader.getStructure(pdbUrl);\r\n\t\t\r\n\t\tAttachmentParser parser = new AttachmentParser(0.4);\r\n\t\t\r\n\t\tint nrmodel = struc.nrModels();\r\n\t\tfor (int modelnr=0; modelnr<nrmodel; modelnr++) {\r\n\t\t\tSystem.out.println(\"Model \"+(modelnr+1));\r\n\t\t\t\r\n\t\t\tList<ModifiedCompound> mcs = parser.parse(struc, \r\n\t\t\t\t\tProteinModification.getByCategory(ModificationCategory.ATTACHMENT),\r\n\t\t\t\t\tmodelnr);\r\n\t\t\t\r\n\t\t\tint i=0;\r\n\t\t\tfor (ModifiedCompound mc : mcs) {\r\n\t\t\t\tSystem.out.println(\"Attachment #\"+(++i)+\":\");\r\n\t\t\t\t\r\n\t\t\t\tAtom[] atoms = mc.getAtomBonds().get(0);\r\n\t\t\t\t\r\n\t\t\t\tGroup residue = mc.getProteinResidues().get(0);\r\n\t\t\t\tChain chain = residue.getParent();\r\n\t\t\t\tSystem.out.println(\"\\t\"+residue.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t\t\t+residue.getPDBCode()+\"\\t\"+atoms[0].getName());\r\n\t\t\t\t\r\n\t\t\t\tGroup group = mc.getOtherGroups().get(0);\r\n\t\t\t\tassertEquals(chain, group.getParent());\r\n\t\t\t\tSystem.out.println(\"\\t\"+group.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t\t\t+group.getPDBCode()+\"\\t\"+atoms[1].getName());\r\n\t\t\t\t\r\n\t\t\t\tSystem.out.println(\"\\t\"+Calc.getDistance(atoms[0], atoms[1]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","changedTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 8, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.io.IOException;\r\n\r\nimport java.net.URL;\r\n\r\nimport java.util.List;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Calc;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\nimport org.biojava.bio.structure.io.PDBFileReader;\r\n\r\nimport org.biojava3.protmod.ModificationCategory;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class AttachmentParserTest extends TestCase {\r\n\r\n\tpublic void testParser() throws IOException, StructureException {\r\n\t\tSystem.out.println(\"===Begin testing on AttachmentParser\");\r\n\t\t\r\n\t\tString server = \"http://www.pdb.org/pdb/files/\";\r\n\t\tString[] names = new String[] {\r\n//\t\t\t\"3HN3\", // NAG\r\n//\t\t\t\"1CPO\", // XYS\r\n\t\t\t\"1AL2\" // MYR\r\n\t\t};\r\n\t\t\t\r\n\t\tfor (String name : names) {\r\n\t\t\tSystem.out.println(name);\r\n\t\t\tURL url = new URL(server+name+\".pdb\");\r\n\t\t\tassertNotNull(url);\r\n\t\t\tparserTest(url);\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"===End testing on AttachmentParser\");\r\n\t}\r\n\t\r\n\tprivate void parserTest(URL pdbUrl) throws IOException, StructureException {\r\n\t\tPDBFileReader pdbReader = new PDBFileReader();\r\n\t\tStructure struc = pdbReader.getStructure(pdbUrl);\r\n\t\t\r\n\t\tAttachmentParser parser = new AttachmentParser(0.4);\r\n\t\t\r\n\t\tint nrmodel = struc.nrModels();\r\n\t\tfor (int modelnr=0; modelnr<nrmodel; modelnr++) {\r\n\t\t\tSystem.out.println(\"Model \"+(modelnr+1));\r\n\t\t\t\r\n\t\t\tList<ModifiedCompound> mcs = parser.parse(struc, \r\n\t\t\t\t\tProteinModification.getByCategory(ModificationCategory.ATTACHMENT),\r\n\t\t\t\t\tmodelnr);\r\n\t\t\t\r\n\t\t\tint i=0;\r\n\t\t\tfor (ModifiedCompound mc : mcs) {\r\n\t\t\t\tSystem.out.println(\"Attachment #\"+(++i)+\":\");\r\n\t\t\t\t\r\n\t\t\t\tAtom[] atoms = mc.getAtomBonds().get(0);\r\n\t\t\t\t\r\n\t\t\t\tGroup residue = mc.getProteinResidues().get(0);\r\n\t\t\t\tChain chain = residue.getParent();\r\n\t\t\t\tSystem.out.println(\"\\t\"+residue.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t\t\t+residue.getPDBCode()+\"\\t\"+atoms[0].getName());\r\n\t\t\t\t\r\n\t\t\t\tGroup group = mc.getOtherGroups().get(0);\r\n\t\t\t\tassertEquals(chain, group.getParent());\r\n\t\t\t\tSystem.out.println(\"\\t\"+group.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t\t\t+group.getPDBCode()+\"\\t\"+atoms[1].getName());\r\n\t\t\t\t\r\n\t\t\t\tSystem.out.println(\"\\t\"+Calc.getDistance(atoms[0], atoms[1]));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","commitMessage":"biojava3-protmod: more modifications were added.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7940 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"biojava3-protmod: more modifications were added.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7940 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":true}