{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/dist/DistributionTools.java","test_path":"core/src/test/java/org/biojava/bio/dist/DistributionToolsTest.java","prod_time":"2010-03-25 14:10:57","test_time":"2010-03-27 00:09:40","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":4,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"fcfff41a3d56d284b2531db7a9b1251ca88b53f8","test_commitID":"00539e9dec3257a0388518a064ea70105fde360c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.dist;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\nimport org.biojava.bio.Annotation;\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.SequenceFactory;\nimport org.biojava.bio.seq.impl.SimpleSequenceFactory;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetIndex;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.AtomicSymbol;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.LocationTools;\nimport org.biojava.bio.symbol.PackedSymbolListFactory;\nimport org.biojava.bio.symbol.PointLocation;\nimport org.biojava.bio.symbol.SimpleSymbolListFactory;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.bio.symbol.SymbolListFactory;\nimport org.biojava.bio.symbol.SymbolListViews;\nimport org.biojava.utils.AssertionFailure;\nimport org.biojava.utils.ChangeVetoException;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A class to hold static methods for calculations and manipulations using\n * Distributions.\n *\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @since 1.2\n */\n\npublic final class DistributionTools {\n\n  /**\n   * Overide the constructer to prevent subclassing.\n   */\n  private DistributionTools(){}\n\n  /**\n   * Writes a Distribution to XML that can be read with the readFromXML method.\n   *\n   * @param d the Distribution to write.\n   * @param os where to write it to.\n   * @throws IOException if writing fails\n   */\n  public static void writeToXML(Distribution d, OutputStream os) throws IOException{\n    new XMLDistributionWriter().writeDistribution(d, os);\n  }\n\n  /**\n   * Read a distribution from XML.\n   *\n   * @param is  an InputStream to read from\n   * @return  a Distribution parameterised by the xml in is\n   * @throws IOException  if is failed\n   * @throws SAXException if is could not be processed as XML\n   */\n  public static Distribution readFromXML(InputStream is)throws IOException, SAXException{\n    XMLDistributionReader writer = new XMLDistributionReader();\n    return writer.parseXML(is);\n  }\n\n  /**\n   * Randomizes the weights of a <code>Distribution</code>.\n   *\n   * @param d the <code>Distribution</code> to randomize\n   * @throws ChangeVetoException if the Distribution is locked\n   */\n  public static void randomizeDistribution(Distribution d)\n    throws ChangeVetoException{\n    Random rand = new Random();\n    FiniteAlphabet a = (FiniteAlphabet)d.getAlphabet();\n    AlphabetIndex ind = AlphabetManager.getAlphabetIndex(a);\n    DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n    dtc.registerDistribution(d);\n\n    for(int i = 0; i < a.size(); i++){\n      try {\n        dtc.addCount(d,ind.symbolForIndex(i),rand.nextDouble());\n      }\n      catch (IllegalSymbolException ex) {\n        throw new BioError(\"Alphabet has Illegal Symbols!!\", ex);\n      }\n    }\n\n    dtc.train();\n  }\n\n  /**\n   * Make a distribution from a count.\n   *\n   * @param c the count\n   * @return a Distrubution over the same <code>FiniteAlphabet</code> as <code>c</code>\n   * and trained with the counts of <code>c</code>\n   */\n  public static Distribution countToDistribution(Count c){\n    FiniteAlphabet a  = (FiniteAlphabet)c.getAlphabet();\n    Distribution d = null;\n    try{\n      d = DistributionFactory.DEFAULT.createDistribution(a);\n      AlphabetIndex index =\n          AlphabetManager.getAlphabetIndex(a);\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n      dtc.registerDistribution(d);\n\n      for(int i = 0; i < a.size(); i++){\n        dtc.addCount(d, index.symbolForIndex(i),\n         c.getCount((AtomicSymbol)index.symbolForIndex(i)));\n      }\n      dtc.train();\n    } catch (IllegalAlphabetException iae) {\n      throw new AssertionFailure(\"Assertion failure: Alphabets don't match\");\n    }catch(IllegalSymbolException ise){\n      throw new AssertionFailure(\"Assertion Error: Cannot convert Count to Distribution\", ise);\n    } catch (ChangeVetoException cve) {\n      throw new AssertionFailure(\"Assertion failure: distributions or counts got locked.\", cve);\n    }\n    return d;\n  }\n\n  /**\n   * Compares the emission spectra of two distributions.\n   *\n   * @return true if alphabets and symbol weights are equal for the two distributions.\n   * @throws BioException if one or both of the Distributions are over infinite alphabets.\n   * @since 1.2\n   * @param a A <code>Distribution</code> with the same <code>Alphabet</code> as\n   * <code>b</code>\n   * @param b A <code>Distribution</code> with the same <code>Alphabet</code> as\n   * <code>a</code>\n   */\n  public static final boolean areEmissionSpectraEqual(Distribution a, Distribution b)\n    throws BioException{\n      //are either of the Dists infinite\n      if(a.getAlphabet() instanceof FiniteAlphabet == false\n          || b.getAlphabet() instanceof FiniteAlphabet == false){\n        throw new IllegalAlphabetException(\"Cannot compare emission spectra over infinite alphabet\");\n      }\n      //are alphabets equal?\n      if(!(a.getAlphabet().equals(b.getAlphabet()))){\n        return false;\n      }\n      //are emissions equal?\n      for(Iterator i = ((FiniteAlphabet)a.getAlphabet()).iterator();i.hasNext();){\n        Symbol s = (Symbol)i.next();\n        if(a.getWeight(s) != b.getWeight(s)) return false;\n      }\n      return true;\n  }\n\n  /**\n   * Compares the emission spectra of two distribution arrays.\n   *\n   * @return true if alphabets and symbol weights are equal for each pair\n   * of distributions. Will return false if the arrays are of unequal length.\n   * @throws BioException if one of the Distributions is over an infinite\n   * alphabet.\n   * @since 1.3\n   * @param a A <code>Distribution[]</code> consisting of <code>Distributions</code>\n   * over a <code>FiniteAlphabet </code>\n   * @param b A <code>Distribution[]</code> consisting of <code>Distributions</code>\n   * over a <code>FiniteAlphabet </code>\n   */\n  public static final boolean areEmissionSpectraEqual(Distribution[] a,\n                                                      Distribution[] b)\n    throws BioException{\n      if(a.length != b.length) return false;\n      for (int i = 0; i < a.length; i++) {\n        if(areEmissionSpectraEqual(a[i], b[i]) == false){\n          return false;\n        }\n      }\n      return true;\n    }\n\n  /**\n   * A method to calculate the Kullback-Liebler Distance (relative entropy).\n   *\n   * @param logBase  - the log base for the entropy calculation. 2 is standard.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @param expected - the excpected or background frequency.\n   * @return  - A HashMap mapping Symbol to <code>(Double)</code> relative entropy.\n   * @since 1.2\n   */\n  public static final HashMap KLDistance(Distribution observed,\n                                   Distribution expected,\n                                   double logBase){\n    Iterator alpha = ((FiniteAlphabet)observed.getAlphabet()).iterator();\n    HashMap kldist = new HashMap(((FiniteAlphabet)observed.getAlphabet()).size());\n\n    while(alpha.hasNext()){\n      Symbol s = (Symbol)alpha.next();\n      try{\n        double obs = observed.getWeight(s);\n        double exp = expected.getWeight(s);\n        if(obs == 0.0){\n          kldist.put(s,new Double(0.0));\n        }else{\n          double entropy = obs * (Math.log(obs/exp))/Math.log(logBase);\n          kldist.put(s,new Double(entropy));\n        }\n      }catch(IllegalSymbolException ise){\n        ise.printStackTrace(System.err);\n      }\n    }\n    return kldist;\n  }\n\n  /**\n   * A method to calculate the Shannon Entropy for a Distribution.\n   *\n   * @param logBase  - the log base for the entropy calculation. 2 is standard.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @return  - A HashMap mapping Symbol to <code>(Double)</code> entropy.\n   * @since 1.2\n   */\n  public static final HashMap shannonEntropy(Distribution observed, double logBase){\n    Iterator alpha = ((FiniteAlphabet)observed.getAlphabet()).iterator();\n    HashMap entropy = new HashMap(((FiniteAlphabet)observed.getAlphabet()).size());\n\n    while(alpha.hasNext()){\n      Symbol s = (Symbol)alpha.next();\n      try{\n        double obs = observed.getWeight(s);\n        if(obs == 0.0){\n         // entropy.put(s,new Double(0.0));\n        }else{\n          double e = -(Math.log(obs))/Math.log(logBase);\n          entropy.put(s,new Double(e));\n        }\n      }catch(IllegalSymbolException ise){\n        ise.printStackTrace(System.err);\n      }\n    }\n    return entropy;\n  }\n\n  /**\n   * Calculates the total Entropy for a Distribution. Entropies for individual\n   * <code>Symbols</code> are weighted by their probability of occurence.\n   * @param observed the observed frequence of <code>Symbols </code>.\n   * @return the total entropy of the <code>Distribution </code>.\n   */\n  public static double totalEntropy(Distribution observed){\n    HashMap ent = shannonEntropy(observed, 2.0);\n    double totalEntropy = 0.0;\n    try{\n    for(Iterator i = ent.keySet().iterator(); i.hasNext();){\n      Symbol sym = (Symbol) i.next();\n      totalEntropy += observed.getWeight(sym)*((Double)ent.get(sym)).doubleValue();\n    }\n    }\n    catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n\n    return totalEntropy;\n  }\n\n  /**\n   * Calculates the total bits of information for a distribution.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @return the total information content of the <code>Distribution </code>.\n   * @since 1.2\n   */\n  public static final double bitsOfInformation(Distribution observed){\n    double totalEntropy = totalEntropy(observed);\n    int size = ((FiniteAlphabet)observed.getAlphabet()).size();\n\n    return Math.log((double)size)/Math.log(2.0) - totalEntropy;\n  }\n\n  /**\n   * Equivalent to distOverAlignment(a, false, 0.0).\n   *\n   * @param a  the Alignment\n   * @return   an array of Distribution instances representing columns of the\n   *     alignment\n   * @throws IllegalAlphabetException  if the alignment alphabet is not\n   *    compattible\n   */\n  public static Distribution[] distOverAlignment(Alignment a)\n      throws IllegalAlphabetException{\n    return distOverAlignment(a,false,0.0);\n  }\n\n  /**\n   * Creates a joint distribution.\n   *\n   * @throws IllegalAlphabetException if all sequences don't use the same alphabet\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @param countGaps if true gaps will be included in the distributions\n   * (NOT YET IMPLEMENTED!!, CURRENTLY EITHER OPTION WILL PRODUCE THE SAME RESULT)\n   * @param nullWeight the number of pseudo counts to add to each distribution\n   * @param cols a list of positions in the alignment to include in the joint distribution\n   * @return a <code>Distribution</code>\n   * @since 1.2\n   */\n  public static final Distribution jointDistOverAlignment(Alignment a,\n                                                 boolean countGaps,\n                                                 double nullWeight,\n                                                 int[] cols)\n  throws IllegalAlphabetException {\n        List seqs = a.getLabels();\n        FiniteAlphabet alpha =\n          (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(0))).getAlphabet();\n        for(int i = 1; i < seqs.size();i++){\n                FiniteAlphabet test = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(i))).getAlphabet();\n                if(test != alpha){\n                        throw new IllegalAlphabetException(\"Cannot Calculate jointDistOverAlignment() for alignments with\"+\n                        \"mixed alphabets\");\n                }\n        }\n        List a_list = new ArrayList();\n        for(int i=0; i<cols.length; i++){\n                a_list.add(alpha);\n        }\n        Distribution dist;\n        DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n        dist =\n          DistributionFactory.DEFAULT.\n          createDistribution(AlphabetManager.getCrossProductAlphabet(a_list));\n        dtc.setNullModelWeight(nullWeight);\n    try{\n\n        dtc.registerDistribution(dist);\n        Location loc= new PointLocation(cols[0]);\n        for (int j = 0; j < cols.length; j++)\n            {\n                Location lj = new PointLocation(cols[j]);\n                loc = LocationTools.union(loc, lj);\n            }\n            Alignment subalign = a.subAlignment(new HashSet(seqs), loc);\n            Iterator s_it = subalign.symbolListIterator();\n        while(s_it.hasNext()){\n            SymbolList syml = (SymbolList) s_it.next();\n            Symbol s= SymbolListViews.orderNSymbolList(syml,syml.length()).symbolAt(1);\n            if(countGaps == false && syml.toList().contains(a.getAlphabet().getGapSymbol())){\n                    //do nothing, not counting gaps\n            }else{\n            dtc.addCount(dist,s,1.0);// count the symbol\n            }\n        }\n        dtc.train();\n    }catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n    return dist;\n}\n  /**\n   * Creates an array of distributions, one for each column of the alignment.\n   *\n   * @throws IllegalAlphabetException if all sequences don't use the same alphabet\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @param countGaps if true gaps will be included in the distributions\n   * @param nullWeight the number of pseudo counts to add to each distribution,\n   * pseudo counts will not affect gaps, no gaps, no gap counts.\n   * @return a <code>Distribution[]</code> where each member of the array is a\n   * <code>Distribution </code>of the <code>Symbols </code>found at that position\n   * of the <code>Alignment </code>.\n   * @since 1.2\n   */\n  public static final Distribution[] distOverAlignment(Alignment a,\n                                                 boolean countGaps,\n                                                 double nullWeight)\n  throws IllegalAlphabetException {\n\n    List seqs = a.getLabels();\n\n    FiniteAlphabet alpha = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(0))).getAlphabet();\n    for(int i = 1; i < seqs.size();i++){\n        FiniteAlphabet test = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(i))).getAlphabet();\n        if(test != alpha){\n          throw new IllegalAlphabetException(\"Cannot Calculate distOverAlignment() for alignments with\"+\n          \"mixed alphabets\");\n        }\n    }\n\n    Distribution[] pos = new Distribution[a.length()];\n    DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n    dtc.setNullModelWeight(nullWeight);\n\n    double[] adjRatios = null;\n    if(countGaps){\n      adjRatios = new double[a.length()];\n    }\n\n    try{\n      for(int i = 0; i < a.length(); i++){// For each position\n        double gapCount = 0.0;\n        double totalCount = 0.0;\n\n        pos[i] = DistributionFactory.DEFAULT.createDistribution(alpha);\n        dtc.registerDistribution(pos[i]);\n\n        for(Iterator j = seqs.iterator(); j.hasNext();){// of each sequence\n          Object seqLabel = j.next();\n          Symbol s = a.symbolAt(seqLabel,i + 1);\n\n          /*If this is working over a flexible alignment there is a possibility\n          that s could be null if this Sequence is not really preset in this\n          region of the Alignment. In this case it will be skipped*/\n          if(s == null)\n            continue;\n\n          Symbol gap = alpha.getGapSymbol();\n          if(countGaps &&\n             s.equals(gap)){\n             gapCount++; totalCount++;\n          }else{\n            dtc.addCount(pos[i],s,1.0);// count the symbol\n            totalCount++;\n          }\n        }\n\n        if(countGaps){\n          adjRatios[i] = 1.0 - (gapCount / totalCount);\n        }\n      }\n\n      dtc.train();\n\n      if(countGaps){//need to adjust counts for gaps\n        for (int i = 0; i < adjRatios.length; i++) {\n          Distribution d = pos[i];\n          for (Iterator iter = ((FiniteAlphabet)d.getAlphabet()).iterator();\n                            iter.hasNext(); ) {\n            Symbol sym = (Symbol)iter.next();\n            d.setWeight(sym, (d.getWeight(sym) * adjRatios[i]));\n          }\n        }\n      }\n\n    }catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n    return pos;\n  }\n\n\n  /**\n   * Creates an array of distributions, one for each column of the alignment.\n   * No pseudo counts are used.\n   * @param countGaps if true gaps will be included in the distributions\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @throws IllegalAlphabetException if the alignment is not composed from sequences all\n   *         with the same alphabet\n   * @return a <code>Distribution[]</code> where each member of the array is a\n   * <code>Distribution </code>of the <code>Symbols </code>found at that position\n   * of the <code>Alignment </code>.\n   * @since 1.2\n   */\n  public static final Distribution[] distOverAlignment(Alignment a,\n                                                 boolean countGaps)\n  throws IllegalAlphabetException {\n    return distOverAlignment(a,countGaps,0.0);\n  }\n\n  /**\n   * Averages two or more distributions. NOTE the current implementation ignore the null model.\n   * @since 1.2\n   * @param dists the <code>Distributions </code>to average\n   * @return a <code>Distribution </code>were the weight of each <code>Symbol </code>\n   * is the average of the weights of that <code>Symbol </code>in each <code>Distribution </code>.\n   */\n  public static final Distribution average (Distribution [] dists){\n\n    Alphabet alpha = dists[0].getAlphabet();\n    //check if all alphabets are the same\n    for (int i = 1; i < dists.length; i++) {\n      if(!(dists[i].getAlphabet().equals(alpha))){\n        throw new IllegalArgumentException(\"All alphabets must be the same\");\n      }\n    }\n\n    try{\n      Distribution average = DistributionFactory.DEFAULT.createDistribution(alpha);\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n      dtc.registerDistribution(average);\n\n      for (int i = 0; i < dists.length; i++) {// for each distribution\n        for(Iterator iter = ((FiniteAlphabet)dists[i].getAlphabet()).iterator(); iter.hasNext(); ){//for each symbol\n          Symbol sym = (Symbol)iter.next();\n          dtc.addCount(average,sym,dists[i].getWeight(sym));\n        }\n      }\n\n\n      dtc.train();\n      return average;\n    } catch(IllegalAlphabetException iae){//The following throw unchecked exceptions as they shouldn't happen\n       throw new AssertionFailure(\"Distribution contains an illegal alphabet\", iae);\n    } catch(IllegalSymbolException ise){\n       throw new AssertionFailure(\"Distribution contains an illegal symbol\", ise);\n    } catch(ChangeVetoException cve){\n       throw new AssertionFailure(\"The Distribution has become locked\", cve);\n    }\n  }\n\n  /**\n   * Produces a sequence by randomly sampling the Distribution.\n   *\n   * @param name the name for the sequence\n   * @param d the distribution to sample. If this distribution is of order N a\n   * seed sequence is generated allowed to 'burn in' for 1000 iterations and used\n   * to produce a sequence over the conditioned alphabet.\n   * @param length the number of symbols in the sequence.\n   * @return a Sequence with name and urn = to name and an Empty Annotation.\n   */\n  public static final Sequence generateSequence(String name, Distribution d, int length){\n    SymbolList sl = generateSymbolList(d, length);\n    SequenceFactory fact = new SimpleSequenceFactory();\n    return fact.createSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n    //return new SimpleSequence(sl,name,name,Annotation.EMPTY_ANNOTATION);\n  }\n\n/**\n * Produces a <code>SymbolList</code> by randomly sampling a Distribution.\n *\n * @param d the distribution to sample. If this distribution is of order N a\n * seed sequence is generated allowed to 'burn in' for 1000 iterations and used\n * to produce a sequence over the conditioned alphabet.\n * @param length the number of symbols in the sequence.\n * @return a SymbolList or length <code>length</code>\n */\n  public static final SymbolList generateSymbolList(Distribution d, int length){\n    if(d instanceof OrderNDistribution)\n      return generateOrderNSymbolList((OrderNDistribution)d, length);\n\n    SymbolList sl = null;\n\n    List l = new ArrayList(length);\n    for (int i = 0; i < length; i++) {\n      l.add(d.sampleSymbol());\n    }\n\n    try {\n      SymbolListFactory fact;\n      if(length < 10000){\n        fact = new SimpleSymbolListFactory();\n      }else{\n        fact = new PackedSymbolListFactory();\n      }\n\n      Symbol[] syms = new Symbol[length];\n      l.toArray(syms);\n\n      sl = fact.makeSymbolList(syms, length, d.getAlphabet());\n      //sl = new SimpleSymbolList(d.getAlphabet(),l);\n    }\n    catch (IllegalAlphabetException ex) {\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\");\n    }\n\n    return sl;\n  }\n\n  private static final SymbolList generateOrderNSymbolList(OrderNDistribution d, int length){\n    SymbolList sl = null;\n    List l = new ArrayList(length);\n\n    /*\n     * When emitting an orderN sequence a seed sequence is required that is of the\n     * length of the conditioning alphabet. The emissions will also be allowed\n     * to 'burn in' for 1000 emissions so that the 'end effect' of the seed\n     * is negated.\n     */\n     FiniteAlphabet cond = (FiniteAlphabet)d.getConditioningAlphabet();\n     UniformDistribution uni = new UniformDistribution(cond);\n     BasisSymbol seed = (BasisSymbol)uni.sampleSymbol();\n     //using the linked list the seed becomes like a history buffer.\n     LinkedList ll = new LinkedList(seed.getSymbols());\n\n    try {\n\n      for(int i = 0; i < 1000+ length; i++){\n         //get a symbol using the seed\n         Symbol sym = d.getDistribution(seed).sampleSymbol();\n         if(i >= 1000){\n           l.add(sym);\n         }\n         //add the symbol to the end of the seed\n         ll.addLast(sym);\n         //remove the first basis symbol of the seed\n         ll.removeFirst();\n         //regenerate the seed\n         seed = (BasisSymbol)cond.getSymbol(ll);\n       }\n\n       SymbolListFactory fact;\n       if(length < 10000){\n         fact = new SimpleSymbolListFactory();\n       }else{\n         fact = new PackedSymbolListFactory();\n       }\n\n       Symbol[] syms = new Symbol[l.size()];\n       l.toArray(syms);\n       sl = fact.makeSymbolList(syms, length, d.getConditionedAlphabet());\n       //sl = new SimpleSymbolList(d.getConditionedAlphabet(),l);\n    }\n    catch (IllegalSymbolException ex) {\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\",ex);\n    }catch(IllegalAlphabetException ex){\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\",ex);\n    }\n\n    return sl;\n  }\n\n  /**\n   * Generate a sequence by sampling a distribution.\n   *\n   * @deprecated use generateSequence() or generateSymbolList() instead.\n   * @param name    the name of the sequence\n   * @param d       the distribution to sample\n   * @param length  the length of the sequence\n   * @return        a new sequence with the required composition\n   */\n  protected static final Sequence generateOrderNSequence(String name, OrderNDistribution d, int length){\n\n    SymbolList sl = generateOrderNSymbolList(d, length);\n    SequenceFactory fact = new SimpleSequenceFactory();\n\n    return fact.createSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n    //return new SimpleSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n  }\n\n}//End of class\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.dist;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\nimport org.biojava.bio.Annotation;\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.SequenceFactory;\nimport org.biojava.bio.seq.impl.SimpleSequenceFactory;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetIndex;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.AtomicSymbol;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.LocationTools;\nimport org.biojava.bio.symbol.PackedSymbolListFactory;\nimport org.biojava.bio.symbol.PointLocation;\nimport org.biojava.bio.symbol.SimpleSymbolListFactory;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.bio.symbol.SymbolListFactory;\nimport org.biojava.bio.symbol.SymbolListViews;\nimport org.biojava.utils.AssertionFailure;\nimport org.biojava.utils.ChangeVetoException;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A class to hold static methods for calculations and manipulations using\n * Distributions.\n *\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @since 1.2\n */\n\npublic final class DistributionTools {\n\n  /**\n   * Overide the constructer to prevent subclassing.\n   */\n  private DistributionTools(){}\n\n  /**\n   * Writes a Distribution to XML that can be read with the readFromXML method.\n   *\n   * @param d the Distribution to write.\n   * @param os where to write it to.\n   * @throws IOException if writing fails\n   */\n  public static void writeToXML(Distribution d, OutputStream os) throws IOException{\n    new XMLDistributionWriter().writeDistribution(d, os);\n  }\n\n  /**\n   * Read a distribution from XML.\n   *\n   * @param is  an InputStream to read from\n   * @return  a Distribution parameterised by the xml in is\n   * @throws IOException  if is failed\n   * @throws SAXException if is could not be processed as XML\n   */\n  public static Distribution readFromXML(InputStream is)throws IOException, SAXException{\n    XMLDistributionReader writer = new XMLDistributionReader();\n    return writer.parseXML(is);\n  }\n\n  /**\n   * Randomizes the weights of a <code>Distribution</code>.\n   *\n   * @param d the <code>Distribution</code> to randomize\n   * @throws ChangeVetoException if the Distribution is locked\n   */\n  public static void randomizeDistribution(Distribution d)\n    throws ChangeVetoException{\n    Random rand = new Random();\n    FiniteAlphabet a = (FiniteAlphabet)d.getAlphabet();\n    AlphabetIndex ind = AlphabetManager.getAlphabetIndex(a);\n    DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n    dtc.registerDistribution(d);\n\n    for(int i = 0; i < a.size(); i++){\n      try {\n        dtc.addCount(d,ind.symbolForIndex(i),rand.nextDouble());\n      }\n      catch (IllegalSymbolException ex) {\n        throw new BioError(\"Alphabet has Illegal Symbols!!\", ex);\n      }\n    }\n\n    dtc.train();\n  }\n\n  /**\n   * Make a distribution from a count.\n   *\n   * @param c the count\n   * @return a Distrubution over the same <code>FiniteAlphabet</code> as <code>c</code>\n   * and trained with the counts of <code>c</code>\n   */\n  public static Distribution countToDistribution(Count c){\n    FiniteAlphabet a  = (FiniteAlphabet)c.getAlphabet();\n    Distribution d = null;\n    try{\n      d = DistributionFactory.DEFAULT.createDistribution(a);\n      AlphabetIndex index =\n          AlphabetManager.getAlphabetIndex(a);\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n      dtc.registerDistribution(d);\n\n      for(int i = 0; i < a.size(); i++){\n        dtc.addCount(d, index.symbolForIndex(i),\n         c.getCount((AtomicSymbol)index.symbolForIndex(i)));\n      }\n      dtc.train();\n    } catch (IllegalAlphabetException iae) {\n      throw new AssertionFailure(\"Assertion failure: Alphabets don't match\");\n    }catch(IllegalSymbolException ise){\n      throw new AssertionFailure(\"Assertion Error: Cannot convert Count to Distribution\", ise);\n    } catch (ChangeVetoException cve) {\n      throw new AssertionFailure(\"Assertion failure: distributions or counts got locked.\", cve);\n    }\n    return d;\n  }\n\n  /**\n   * Compares the emission spectra of two distributions.\n   *\n   * @return true if alphabets and symbol weights are equal for the two distributions.\n   * @throws BioException if one or both of the Distributions are over infinite alphabets.\n   * @since 1.2\n   * @param a A <code>Distribution</code> with the same <code>Alphabet</code> as\n   * <code>b</code>\n   * @param b A <code>Distribution</code> with the same <code>Alphabet</code> as\n   * <code>a</code>\n   */\n  public static final boolean areEmissionSpectraEqual(Distribution a, Distribution b)\n    throws BioException{\n      //are either of the Dists infinite\n      if(a.getAlphabet() instanceof FiniteAlphabet == false\n          || b.getAlphabet() instanceof FiniteAlphabet == false){\n        throw new IllegalAlphabetException(\"Cannot compare emission spectra over infinite alphabet\");\n      }\n      //are alphabets equal?\n      if(!(a.getAlphabet().equals(b.getAlphabet()))){\n        return false;\n      }\n      //are emissions equal?\n      for(Iterator i = ((FiniteAlphabet)a.getAlphabet()).iterator();i.hasNext();){\n        Symbol s = (Symbol)i.next();\n        if(a.getWeight(s) != b.getWeight(s)) return false;\n      }\n      return true;\n  }\n\n  /**\n   * Compares the emission spectra of two distribution arrays.\n   *\n   * @return true if alphabets and symbol weights are equal for each pair\n   * of distributions. Will return false if the arrays are of unequal length.\n   * @throws BioException if one of the Distributions is over an infinite\n   * alphabet.\n   * @since 1.3\n   * @param a A <code>Distribution[]</code> consisting of <code>Distributions</code>\n   * over a <code>FiniteAlphabet </code>\n   * @param b A <code>Distribution[]</code> consisting of <code>Distributions</code>\n   * over a <code>FiniteAlphabet </code>\n   */\n  public static final boolean areEmissionSpectraEqual(Distribution[] a,\n                                                      Distribution[] b)\n    throws BioException{\n      if(a.length != b.length) return false;\n      for (int i = 0; i < a.length; i++) {\n        if(areEmissionSpectraEqual(a[i], b[i]) == false){\n          return false;\n        }\n      }\n      return true;\n    }\n\n  /**\n   * A method to calculate the Kullback-Liebler Distance (relative entropy).\n   *\n   * @param logBase  - the log base for the entropy calculation. 2 is standard.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @param expected - the excpected or background frequency.\n   * @return  - A HashMap mapping Symbol to <code>(Double)</code> relative entropy.\n   * @since 1.2\n   */\n  public static final HashMap KLDistance(Distribution observed,\n                                   Distribution expected,\n                                   double logBase){\n    Iterator alpha = ((FiniteAlphabet)observed.getAlphabet()).iterator();\n    HashMap kldist = new HashMap(((FiniteAlphabet)observed.getAlphabet()).size());\n\n    while(alpha.hasNext()){\n      Symbol s = (Symbol)alpha.next();\n      try{\n        double obs = observed.getWeight(s);\n        double exp = expected.getWeight(s);\n        if(obs == 0.0){\n          kldist.put(s,new Double(0.0));\n        }else{\n          double entropy = obs * (Math.log(obs/exp))/Math.log(logBase);\n          kldist.put(s,new Double(entropy));\n        }\n      }catch(IllegalSymbolException ise){\n        ise.printStackTrace(System.err);\n      }\n    }\n    return kldist;\n  }\n\n  /**\n   * A method to calculate the Shannon Entropy for a Distribution.\n   *\n   * @param logBase  - the log base for the entropy calculation. 2 is standard.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @return  - A HashMap mapping Symbol to <code>(Double)</code> entropy.\n   * @since 1.2\n   */\n  public static final HashMap shannonEntropy(Distribution observed, double logBase){\n    Iterator alpha = ((FiniteAlphabet)observed.getAlphabet()).iterator();\n    HashMap entropy = new HashMap(((FiniteAlphabet)observed.getAlphabet()).size());\n\n    while(alpha.hasNext()){\n      Symbol s = (Symbol)alpha.next();\n      try{\n        double obs = observed.getWeight(s);\n        if(obs == 0.0){\n         // entropy.put(s,new Double(0.0));\n        }else{\n          double e = -(Math.log(obs))/Math.log(logBase);\n          entropy.put(s,new Double(e));\n        }\n      }catch(IllegalSymbolException ise){\n        ise.printStackTrace(System.err);\n      }\n    }\n    return entropy;\n  }\n\n  /**\n   * Calculates the total Entropy for a Distribution. Entropies for individual\n   * <code>Symbols</code> are weighted by their probability of occurence.\n   * @param observed the observed frequence of <code>Symbols </code>.\n   * @return the total entropy of the <code>Distribution </code>.\n   */\n  public static double totalEntropy(Distribution observed){\n    HashMap ent = shannonEntropy(observed, 2.0);\n    double totalEntropy = 0.0;\n    try{\n    for(Iterator i = ent.keySet().iterator(); i.hasNext();){\n      Symbol sym = (Symbol) i.next();\n      totalEntropy += observed.getWeight(sym)*((Double)ent.get(sym)).doubleValue();\n    }\n    }\n    catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n\n    return totalEntropy;\n  }\n\n  /**\n   * Calculates the total bits of information for a distribution.\n   * @param observed - the observed frequence of <code>Symbols </code>.\n   * @return the total information content of the <code>Distribution </code>.\n   * @since 1.2\n   */\n  public static final double bitsOfInformation(Distribution observed){\n    double totalEntropy = totalEntropy(observed);\n    int size = ((FiniteAlphabet)observed.getAlphabet()).size();\n\n    return Math.log((double)size)/Math.log(2.0) - totalEntropy;\n  }\n\n  /**\n   * Equivalent to distOverAlignment(a, false, 0.0).\n   *\n   * @param a  the Alignment\n   * @return   an array of Distribution instances representing columns of the\n   *     alignment\n   * @throws IllegalAlphabetException  if the alignment alphabet is not\n   *    compattible\n   */\n  public static Distribution[] distOverAlignment(Alignment a)\n      throws IllegalAlphabetException{\n    return distOverAlignment(a,false,0.0);\n  }\n\n  /**\n   * Creates a joint distribution.\n   *\n   * @throws IllegalAlphabetException if all sequences don't use the same alphabet\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @param countGaps if true gaps will be included in the distributions\n   * (NOT YET IMPLEMENTED!!, CURRENTLY EITHER OPTION WILL PRODUCE THE SAME RESULT)\n   * @param nullWeight the number of pseudo counts to add to each distribution\n   * @param cols a list of positions in the alignment to include in the joint distribution\n   * @return a <code>Distribution</code>\n   * @since 1.2\n   */\n  public static final Distribution jointDistOverAlignment(Alignment a,\n                                                 boolean countGaps,\n                                                 double nullWeight,\n                                                 int[] cols)\n  throws IllegalAlphabetException {\n        List<String> seqs = a.getLabels();\n        FiniteAlphabet alpha =\n          (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(0))).getAlphabet();\n        for(int i = 1; i < seqs.size();i++){\n                FiniteAlphabet test = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(i))).getAlphabet();\n                if(test != alpha){\n                        throw new IllegalAlphabetException(\"Cannot Calculate jointDistOverAlignment() for alignments with\"+\n                        \"mixed alphabets\");\n                }\n        }\n        List<Alphabet> a_list = new ArrayList();\n        for(int i=0; i<cols.length; i++){\n                a_list.add(alpha);\n        }\n        Distribution dist;\n        DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n        dist =\n          DistributionFactory.DEFAULT.\n          createDistribution(AlphabetManager.getCrossProductAlphabet(a_list));\n        dtc.setNullModelWeight(nullWeight);\n    try{\n\n        dtc.registerDistribution(dist);\n        Location loc= new PointLocation(cols[0]);\n        for (int j = 0; j < cols.length; j++)\n            {\n                Location lj = new PointLocation(cols[j]);\n                loc = LocationTools.union(loc, lj);\n            }\n            Alignment subalign = a.subAlignment(new HashSet(seqs), loc);\n            Iterator s_it = subalign.symbolListIterator();\n        while(s_it.hasNext()){\n            SymbolList syml = (SymbolList) s_it.next();\n            Symbol s= SymbolListViews.orderNSymbolList(syml,syml.length()).symbolAt(1);\n            if(countGaps == false && syml.toList().contains(a.getAlphabet().getGapSymbol())){\n                    //do nothing, not counting gaps\n            }else{\n            dtc.addCount(dist,s,1.0);// count the symbol\n            }\n        }\n        dtc.train();\n    }catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n    return dist;\n}\n  /**\n   * Creates an array of distributions, one for each column of the alignment.\n   *\n   * @throws IllegalAlphabetException if all sequences don't use the same alphabet\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @param countGaps if true gaps will be included in the distributions\n   * @param nullWeight the number of pseudo counts to add to each distribution,\n   * pseudo counts will not affect gaps, no gaps, no gap counts.\n   * @return a <code>Distribution[]</code> where each member of the array is a\n   * <code>Distribution </code>of the <code>Symbols </code>found at that position\n   * of the <code>Alignment </code>.\n   * @since 1.2\n   */\n  public static final Distribution[] distOverAlignment(Alignment a,\n                                                 boolean countGaps,\n                                                 double nullWeight)\n  throws IllegalAlphabetException {\n\n    List<String> seqs = a.getLabels();\n\n    FiniteAlphabet alpha = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(0))).getAlphabet();\n    for(int i = 1; i < seqs.size();i++){\n        FiniteAlphabet test = (FiniteAlphabet)((SymbolList)a.symbolListForLabel(seqs.get(i))).getAlphabet();\n        if(test != alpha){\n          throw new IllegalAlphabetException(\"Cannot Calculate distOverAlignment() for alignments with\"+\n          \"mixed alphabets\");\n        }\n    }\n\n    Distribution[] pos = new Distribution[a.length()];\n    DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n    dtc.setNullModelWeight(nullWeight);\n\n    double[] adjRatios = null;\n    if(countGaps){\n      adjRatios = new double[a.length()];\n    }\n\n    try{\n      for(int i = 0; i < a.length(); i++){// For each position\n        double gapCount = 0.0;\n        double totalCount = 0.0;\n\n        pos[i] = DistributionFactory.DEFAULT.createDistribution(alpha);\n        dtc.registerDistribution(pos[i]);\n\n        for(Iterator<String> j = seqs.iterator(); j.hasNext();){// of each sequence\n          String seqLabel = j.next();\n          Symbol s = a.symbolAt(seqLabel,i + 1);\n\n          /*If this is working over a flexible alignment there is a possibility\n          that s could be null if this Sequence is not really preset in this\n          region of the Alignment. In this case it will be skipped*/\n          if(s == null)\n            continue;\n\n          Symbol gap = alpha.getGapSymbol();\n          if(countGaps &&\n             s.equals(gap)){\n             gapCount++; totalCount++;\n          }else{\n            dtc.addCount(pos[i],s,1.0);// count the symbol\n            totalCount++;\n          }\n        }\n\n        if(countGaps){\n          adjRatios[i] = 1.0 - (gapCount / totalCount);\n        }\n      }\n\n      dtc.train();\n\n      if(countGaps){//need to adjust counts for gaps\n        for (int i = 0; i < adjRatios.length; i++) {\n          Distribution d = pos[i];\n          for (Iterator iter = ((FiniteAlphabet)d.getAlphabet()).iterator();\n                            iter.hasNext(); ) {\n            Symbol sym = (Symbol)iter.next();\n            d.setWeight(sym, (d.getWeight(sym) * adjRatios[i]));\n          }\n        }\n      }\n\n    }catch(Exception e){\n      e.printStackTrace(System.err);\n    }\n    return pos;\n  }\n\n\n  /**\n   * Creates an array of distributions, one for each column of the alignment.\n   * No pseudo counts are used.\n   * @param countGaps if true gaps will be included in the distributions\n   * @param a the <code>Alignment </code>to build the <code>Distribution[]</code> over.\n   * @throws IllegalAlphabetException if the alignment is not composed from sequences all\n   *         with the same alphabet\n   * @return a <code>Distribution[]</code> where each member of the array is a\n   * <code>Distribution </code>of the <code>Symbols </code>found at that position\n   * of the <code>Alignment </code>.\n   * @since 1.2\n   */\n  public static final Distribution[] distOverAlignment(Alignment a,\n                                                 boolean countGaps)\n  throws IllegalAlphabetException {\n    return distOverAlignment(a,countGaps,0.0);\n  }\n\n  /**\n   * Averages two or more distributions. NOTE the current implementation ignore the null model.\n   * @since 1.2\n   * @param dists the <code>Distributions </code>to average\n   * @return a <code>Distribution </code>were the weight of each <code>Symbol </code>\n   * is the average of the weights of that <code>Symbol </code>in each <code>Distribution </code>.\n   */\n  public static final Distribution average (Distribution [] dists){\n\n    Alphabet alpha = dists[0].getAlphabet();\n    //check if all alphabets are the same\n    for (int i = 1; i < dists.length; i++) {\n      if(!(dists[i].getAlphabet().equals(alpha))){\n        throw new IllegalArgumentException(\"All alphabets must be the same\");\n      }\n    }\n\n    try{\n      Distribution average = DistributionFactory.DEFAULT.createDistribution(alpha);\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n      dtc.registerDistribution(average);\n\n      for (int i = 0; i < dists.length; i++) {// for each distribution\n        for(Iterator iter = ((FiniteAlphabet)dists[i].getAlphabet()).iterator(); iter.hasNext(); ){//for each symbol\n          Symbol sym = (Symbol)iter.next();\n          dtc.addCount(average,sym,dists[i].getWeight(sym));\n        }\n      }\n\n\n      dtc.train();\n      return average;\n    } catch(IllegalAlphabetException iae){//The following throw unchecked exceptions as they shouldn't happen\n       throw new AssertionFailure(\"Distribution contains an illegal alphabet\", iae);\n    } catch(IllegalSymbolException ise){\n       throw new AssertionFailure(\"Distribution contains an illegal symbol\", ise);\n    } catch(ChangeVetoException cve){\n       throw new AssertionFailure(\"The Distribution has become locked\", cve);\n    }\n  }\n\n  /**\n   * Produces a sequence by randomly sampling the Distribution.\n   *\n   * @param name the name for the sequence\n   * @param d the distribution to sample. If this distribution is of order N a\n   * seed sequence is generated allowed to 'burn in' for 1000 iterations and used\n   * to produce a sequence over the conditioned alphabet.\n   * @param length the number of symbols in the sequence.\n   * @return a Sequence with name and urn = to name and an Empty Annotation.\n   */\n  public static final Sequence generateSequence(String name, Distribution d, int length){\n    SymbolList sl = generateSymbolList(d, length);\n    SequenceFactory fact = new SimpleSequenceFactory();\n    return fact.createSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n    //return new SimpleSequence(sl,name,name,Annotation.EMPTY_ANNOTATION);\n  }\n\n/**\n * Produces a <code>SymbolList</code> by randomly sampling a Distribution.\n *\n * @param d the distribution to sample. If this distribution is of order N a\n * seed sequence is generated allowed to 'burn in' for 1000 iterations and used\n * to produce a sequence over the conditioned alphabet.\n * @param length the number of symbols in the sequence.\n * @return a SymbolList or length <code>length</code>\n */\n  public static final SymbolList generateSymbolList(Distribution d, int length){\n    if(d instanceof OrderNDistribution)\n      return generateOrderNSymbolList((OrderNDistribution)d, length);\n\n    SymbolList sl = null;\n\n    List l = new ArrayList(length);\n    for (int i = 0; i < length; i++) {\n      l.add(d.sampleSymbol());\n    }\n\n    try {\n      SymbolListFactory fact;\n      if(length < 10000){\n        fact = new SimpleSymbolListFactory();\n      }else{\n        fact = new PackedSymbolListFactory();\n      }\n\n      Symbol[] syms = new Symbol[length];\n      l.toArray(syms);\n\n      sl = fact.makeSymbolList(syms, length, d.getAlphabet());\n      //sl = new SimpleSymbolList(d.getAlphabet(),l);\n    }\n    catch (IllegalAlphabetException ex) {\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\");\n    }\n\n    return sl;\n  }\n\n  private static final SymbolList generateOrderNSymbolList(OrderNDistribution d, int length){\n    SymbolList sl = null;\n    List l = new ArrayList(length);\n\n    /*\n     * When emitting an orderN sequence a seed sequence is required that is of the\n     * length of the conditioning alphabet. The emissions will also be allowed\n     * to 'burn in' for 1000 emissions so that the 'end effect' of the seed\n     * is negated.\n     */\n     FiniteAlphabet cond = (FiniteAlphabet)d.getConditioningAlphabet();\n     UniformDistribution uni = new UniformDistribution(cond);\n     BasisSymbol seed = (BasisSymbol)uni.sampleSymbol();\n     //using the linked list the seed becomes like a history buffer.\n     LinkedList ll = new LinkedList(seed.getSymbols());\n\n    try {\n\n      for(int i = 0; i < 1000+ length; i++){\n         //get a symbol using the seed\n         Symbol sym = d.getDistribution(seed).sampleSymbol();\n         if(i >= 1000){\n           l.add(sym);\n         }\n         //add the symbol to the end of the seed\n         ll.addLast(sym);\n         //remove the first basis symbol of the seed\n         ll.removeFirst();\n         //regenerate the seed\n         seed = (BasisSymbol)cond.getSymbol(ll);\n       }\n\n       SymbolListFactory fact;\n       if(length < 10000){\n         fact = new SimpleSymbolListFactory();\n       }else{\n         fact = new PackedSymbolListFactory();\n       }\n\n       Symbol[] syms = new Symbol[l.size()];\n       l.toArray(syms);\n       sl = fact.makeSymbolList(syms, length, d.getConditionedAlphabet());\n       //sl = new SimpleSymbolList(d.getConditionedAlphabet(),l);\n    }\n    catch (IllegalSymbolException ex) {\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\",ex);\n    }catch(IllegalAlphabetException ex){\n      //shouldn't happen but...\n      throw new BioError(\"Distribution emitting Symbols not from its Alphabet?\",ex);\n    }\n\n    return sl;\n  }\n\n  /**\n   * Generate a sequence by sampling a distribution.\n   *\n   * @deprecated use generateSequence() or generateSymbolList() instead.\n   * @param name    the name of the sequence\n   * @param d       the distribution to sample\n   * @param length  the length of the sequence\n   * @return        a new sequence with the required composition\n   */\n  protected static final Sequence generateOrderNSequence(String name, OrderNDistribution d, int length){\n\n    SymbolList sl = generateOrderNSymbolList(d, length);\n    SequenceFactory fact = new SimpleSequenceFactory();\n\n    return fact.createSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n    //return new SimpleSequence(sl, name, name, Annotation.EMPTY_ANNOTATION);\n  }\n\n}//End of class\n","originTest":"package org.biojava.bio.dist;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.alignment.SimpleAlignment;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Symbol;\n\n/**\n * Tests that methods from DistributionTools work as advertised.\n *\n * @author Mark Schreiber\n * @since 1.3\n */\npublic class DistributionToolsTest extends TestCase {\n\n  private Alignment a;\n  private Distribution random;\n  private String[] sa;\n  private Map map;\n\n  public DistributionToolsTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() {\n    try{\n      sa = new String[]{\"CA-TGGG\",\"AATTGGC\",\"AATTGGG\",\n                        \"AATTGGC\",\"AA-TGGG\",\"AATTGGC\",\n                        \"AATTGGG\",\"AATTGGC\",\"AATTGGG\",\n                        \"AATTGGC\"};\n\n      map = new HashMap(sa.length);\n      for (int i = 0; i < sa.length; i++) {\n         map.put(new Integer(i), DNATools.createDNA(sa[i]));\n      }\n\n      a = new SimpleAlignment(map);\n\n      random = new SimpleDistribution(DNATools.getDNA());\n      DistributionTools.randomizeDistribution(random);\n\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n\n  protected void tearDown(){\n    sa = null;\n    map = null;\n    a = null;\n    random = null;\n  }\n\n\n  public void testDistOverAlignment() {\n    try{\n      Distribution[] d = DistributionTools.distOverAlignment(a,false);\n      Distribution[] d2 = DistributionTools.distOverAlignment(a,false,10.0);\n      Distribution[] d3 = DistributionTools.distOverAlignment(a,true);\n\n      assertTrue(d[0].getWeight(DNATools.a()) == 0.9);\n      assertTrue(d[0].getWeight(DNATools.c()) == 0.1);\n      assertTrue(d[0].getWeight(DNATools.g()) == 0.0);\n      assertTrue(d[0].getWeight(DNATools.t()) == 0.0);\n      assertTrue(d[0].getWeight(AlphabetManager.getGapSymbol()) == 0.0);\n\n      assertTrue(d2[1].getWeight(DNATools.a()) == 0.625);\n      assertTrue(d2[1].getWeight(DNATools.c()) == 0.125);\n      assertTrue(d2[1].getWeight(DNATools.g()) == 0.125);\n      assertTrue(d2[1].getWeight(DNATools.t()) == 0.125);\n      assertTrue(d2[1].getWeight(AlphabetManager.getGapSymbol()) == 0.0);\n\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.a()) ,0.000001);\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.c()) ,0.000001);\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.g()) ,0.000001);\n      assertEquals( 0.8 , d3[2].getWeight(DNATools.t()), 0.000001);\n      assertEquals( 0.2 , d3[2].getWeight(AlphabetManager.getGapSymbol()),\n                    0.000001);\n\n\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n\n  /**\n   * This method tests DistributionTools.shannonEntropy(), DistributionTools.totalEntropy()\n   * and DistributionTools.bitsOfInformation().\n   */\n  public void testInformationContent(){\n    Distribution d = new UniformDistribution(DNATools.getDNA());\n    assertTrue(DistributionTools.bitsOfInformation(d) == 0.0);\n    assertTrue(DistributionTools.totalEntropy(d) == 2.0);\n\n    Map map = DistributionTools.shannonEntropy(d,2.0);\n    for(Iterator i = DNATools.getDNA().iterator(); i.hasNext();){\n      Symbol s = (Symbol)i.next();\n      double ent = ((Double)map.get(s)).doubleValue();\n      assertTrue(ent == 2.0);\n    }\n  }\n\n  public void testGenerateSequence(){\n    Sequence seq = DistributionTools.generateSequence(\"seq\",random,1000);\n    assertTrue(seq.length() == 1000);\n    //this will kick in the PackedSymbolListFactory\n    Sequence seq2 = DistributionTools.generateSequence(\"seq\", random, 30000);\n    assertTrue(seq2.length() == 30000);\n  }\n\n}\n","changedTest":"package org.biojava.bio.dist;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.alignment.SimpleAlignment;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * Tests that methods from DistributionTools work as advertised.\n *\n * @author Mark Schreiber\n * @since 1.3\n */\npublic class DistributionToolsTest extends TestCase {\n\n  private Alignment a;\n  private Distribution random;\n  private String[] sa;\n  private Map<String,SymbolList> map;\n\n  public DistributionToolsTest(String name) {\n    super(name);\n  }\n\n  protected void setUp() {\n    try{\n      sa = new String[]{\"CA-TGGG\",\"AATTGGC\",\"AATTGGG\",\n                        \"AATTGGC\",\"AA-TGGG\",\"AATTGGC\",\n                        \"AATTGGG\",\"AATTGGC\",\"AATTGGG\",\n                        \"AATTGGC\"};\n\n      map = new HashMap<String, SymbolList>(sa.length);\n      for (int i = 0; i < sa.length; i++) {\n         map.put(i+\"\", DNATools.createDNA(sa[i]));\n      }\n\n      a = new SimpleAlignment(map);\n\n      random = new SimpleDistribution(DNATools.getDNA());\n      DistributionTools.randomizeDistribution(random);\n\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n\n  protected void tearDown(){\n    sa = null;\n    map = null;\n    a = null;\n    random = null;\n  }\n\n\n  public void testDistOverAlignment() {\n    try{\n      Distribution[] d = DistributionTools.distOverAlignment(a,false);\n      Distribution[] d2 = DistributionTools.distOverAlignment(a,false,10.0);\n      Distribution[] d3 = DistributionTools.distOverAlignment(a,true);\n\n      assertTrue(d[0].getWeight(DNATools.a()) == 0.9);\n      assertTrue(d[0].getWeight(DNATools.c()) == 0.1);\n      assertTrue(d[0].getWeight(DNATools.g()) == 0.0);\n      assertTrue(d[0].getWeight(DNATools.t()) == 0.0);\n      assertTrue(d[0].getWeight(AlphabetManager.getGapSymbol()) == 0.0);\n\n      assertTrue(d2[1].getWeight(DNATools.a()) == 0.625);\n      assertTrue(d2[1].getWeight(DNATools.c()) == 0.125);\n      assertTrue(d2[1].getWeight(DNATools.g()) == 0.125);\n      assertTrue(d2[1].getWeight(DNATools.t()) == 0.125);\n      assertTrue(d2[1].getWeight(AlphabetManager.getGapSymbol()) == 0.0);\n\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.a()) ,0.000001);\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.c()) ,0.000001);\n      assertEquals( 0.0 , d3[2].getWeight(DNATools.g()) ,0.000001);\n      assertEquals( 0.8 , d3[2].getWeight(DNATools.t()), 0.000001);\n      assertEquals( 0.2 , d3[2].getWeight(AlphabetManager.getGapSymbol()),\n                    0.000001);\n\n\n    }catch(Exception e){\n      e.printStackTrace();\n    }\n  }\n\n  /**\n   * This method tests DistributionTools.shannonEntropy(), DistributionTools.totalEntropy()\n   * and DistributionTools.bitsOfInformation().\n   */\n  public void testInformationContent(){\n    Distribution d = new UniformDistribution(DNATools.getDNA());\n    assertTrue(DistributionTools.bitsOfInformation(d) == 0.0);\n    assertTrue(DistributionTools.totalEntropy(d) == 2.0);\n\n    Map map = DistributionTools.shannonEntropy(d,2.0);\n    for(Iterator i = DNATools.getDNA().iterator(); i.hasNext();){\n      Symbol s = (Symbol)i.next();\n      double ent = ((Double)map.get(s)).doubleValue();\n      assertTrue(ent == 2.0);\n    }\n  }\n\n  public void testGenerateSequence(){\n    Sequence seq = DistributionTools.generateSequence(\"seq\",random,1000);\n    assertTrue(seq.length() == 1000);\n    //this will kick in the PackedSymbolListFactory\n    Sequence seq2 = DistributionTools.generateSequence(\"seq\", random, 30000);\n    assertTrue(seq2.length() == 30000);\n  }\n\n}\n","commitMessage":"The alignment algorithms NeedlemanWunsch and SmithWaterman have been revised and are now based on a Alignment data structure that strongly eases using the result.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7598 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"fixing compile error with new Alignment code\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7602 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}