{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/ChainClusterer.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestChainClusterer.java","prod_time":"2016-06-20 22:26:16","test_time":"2016-06-20 22:26:16","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"9142ce2dc33c8902b4d7573d58e98a7096f74514","test_commitID":"9142ce2dc33c8902b4d7573d58e98a7096f74514","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.structure.Atom;\n\nimport javax.vecmath.Point3d;\n\nimport java.util.*;\n\n/**\n * Wraps a sequence clustering with structural information\n */\npublic class ChainClusterer {\n\tprivate List<SequenceAlignmentCluster> seqClusters = new ArrayList<SequenceAlignmentCluster>();\n\tprivate boolean modified = true;\n\n\tprivate List<Atom[]> caAligned = new ArrayList<Atom[]>();\n\tprivate List<Point3d[]> caCoords = new ArrayList<Point3d[]>();\n\n\tpublic ChainClusterer(List<SequenceAlignmentCluster> seqClusters) {\n\t\tthis.seqClusters = seqClusters;\n\t\tthis.modified = true;\n\t}\n\n\tpublic List<Point3d[]> getCalphaCoordinates() {\n\t\trun();\n\t\treturn caCoords;\n\t}\n\n\tpublic List<Atom[]> getCalphaTraces() {\n\t\trun();\n\t\treturn caAligned;\n\t}\n\n\tpublic List<String> getChainIds() {\n\t\trun();\n\t\tList<String> chainIdList = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tSequenceAlignmentCluster cluster = seqClusters.get(i);\n\t\t\tfor (String chainId : cluster.getChainIds()) {\n\t\t\t\tchainIdList.add(chainId);\n\t\t\t}\n\t\t}\n\t\treturn chainIdList;\n\t}\n\n\tpublic List<Integer> getModelNumbers() {\n\t\trun();\n\t\tList<Integer> modNumbers = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tSequenceAlignmentCluster cluster = seqClusters.get(i);\n\t\t\tfor (Integer number : cluster.getModelNumbers()) {\n\t\t\t\tmodNumbers.add(number);\n\t\t\t}\n\t\t}\n\t\treturn modNumbers;\n\t}\n\n\tpublic String getStoichiometry() {\n\t\trun();\n\t\tStringBuilder formula = new StringBuilder();\n\t\tString alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tString c = \"?\";\n\t\t\tif (i < alpha.length()) {\n\t\t\t\tc = alpha.substring(i, i + 1);\n\t\t\t}\n\t\t\tformula.append(c);\n\t\t\tint multiplier = seqClusters.get(i).getSequenceCount();\n\t\t\tif (multiplier > 1) {\n\t\t\t\tformula.append(multiplier);\n\t\t\t}\n\t\t}\n\t\treturn formula.toString();\n\t}\n\n\t/**\n\t * Get valid symmetry order for this stoichiometry.\n\t * \n\t * @return\n\t */\n\tpublic List<Integer> getFolds() {\n\t\trun();\n\t\tList<Integer> stoichiometry = new ArrayList<Integer>(seqClusters.size());\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tstoichiometry.add(seqCount);\n\t\t}\n\t\treturn getValidFolds(stoichiometry);\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each chain cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n\n\tpublic List<Integer> getSequenceClusterIds() {\n\t\trun();\n\t\tList<Integer> list = new ArrayList<Integer>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(id);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic int getSequenceClusterCount() {\n\t\trun();\n\t\treturn seqClusters.size();\n\t}\n\n\tpublic List<SequenceAlignmentCluster> getSequenceAlignmentClusters() {\n\t\treturn seqClusters;\n\t}\n\n\tpublic List<Boolean> getPseudoStoichiometry() {\n\t\trun();\n\t\tList<Boolean> list = new ArrayList<Boolean>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tBoolean pseudo = seqClusters.get(id).isPseudoStoichiometric();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(pseudo);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic List<Double> getMinSequenceIdentity() {\n\t\trun();\n\t\tList<Double> list = new ArrayList<Double>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tdouble minSequenceIdentity = seqClusters.get(id)\n\t\t\t\t\t.getMinSequenceIdentity();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(minSequenceIdentity);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic List<Double> getMaxSequenceIdentity() {\n\t\trun();\n\t\tList<Double> list = new ArrayList<Double>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tdouble maxSequenceIdentity = seqClusters.get(id)\n\t\t\t\t\t.getMaxSequenceIdentity();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(maxSequenceIdentity);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\trun();\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"Sequence alignment clusters: \" + seqClusters.size());\n\t\tbuilder.append(\"\\n\");\n\t\tfor (SequenceAlignmentCluster s : seqClusters) {\n\t\t\tbuilder.append(\"# seq: \");\n\t\t\tbuilder.append(s.getSequenceCount());\n\t\t\tbuilder.append(\" alignment length: \");\n\t\t\tbuilder.append(s.getSequenceAlignmentLength());\n\t\t\tbuilder.append(\"\\n\");\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\tprivate void run() {\n\t\tif (modified) {\n\t\t\tmodified = false;\n\t\t\tcalcAlignedSequences();\n\t\t\tcreateCalphaTraces();\n\t\t}\n\t}\n\n\tprivate void calcAlignedSequences() {\n\t\tcaAligned = new ArrayList<Atom[]>();\n\t\tfor (SequenceAlignmentCluster cluster : seqClusters) {\n\t\t\tcaAligned.addAll(cluster.getAlignedCalphaAtoms());\n\t\t}\n\t}\n\n\tprivate void createCalphaTraces() {\n\t\tfor (Atom[] atoms : caAligned) {\n\t\t\tPoint3d[] trace = new Point3d[atoms.length];\n\t\t\tfor (int j = 0; j < atoms.length; j++) {\n\t\t\t\ttrace[j] = new Point3d(atoms[j].getCoords());\n\t\t\t}\n\t\t\tcaCoords.add(trace);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.structure.Atom;\n\nimport javax.vecmath.Point3d;\n\nimport java.util.*;\n\n/**\n * Wraps a sequence clustering with structural information\n */\npublic class ChainClusterer {\n\t\n\tprivate List<SequenceAlignmentCluster> seqClusters = new ArrayList<SequenceAlignmentCluster>();\n\tprivate boolean modified = true;\n\n\tprivate List<Atom[]> caAligned = new ArrayList<Atom[]>();\n\tprivate List<Point3d[]> caCoords = new ArrayList<Point3d[]>();\n\n\tpublic ChainClusterer(List<SequenceAlignmentCluster> seqClusters) {\n\t\tthis.seqClusters = seqClusters;\n\t\tthis.modified = true;\n\t}\n\n\tpublic List<Point3d[]> getCalphaCoordinates() {\n\t\trun();\n\t\treturn caCoords;\n\t}\n\n\tpublic List<Atom[]> getCalphaTraces() {\n\t\trun();\n\t\treturn caAligned;\n\t}\n\n\tpublic List<String> getChainIds() {\n\t\trun();\n\t\tList<String> chainIdList = new ArrayList<String>();\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tSequenceAlignmentCluster cluster = seqClusters.get(i);\n\t\t\tfor (String chainId : cluster.getChainIds()) {\n\t\t\t\tchainIdList.add(chainId);\n\t\t\t}\n\t\t}\n\t\treturn chainIdList;\n\t}\n\n\tpublic List<Integer> getModelNumbers() {\n\t\trun();\n\t\tList<Integer> modNumbers = new ArrayList<Integer>();\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tSequenceAlignmentCluster cluster = seqClusters.get(i);\n\t\t\tfor (Integer number : cluster.getModelNumbers()) {\n\t\t\t\tmodNumbers.add(number);\n\t\t\t}\n\t\t}\n\t\treturn modNumbers;\n\t}\n\n\tpublic String getStoichiometry() {\n\t\trun();\n\t\tStringBuilder formula = new StringBuilder();\n\t\tString alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n\t\tfor (int i = 0; i < seqClusters.size(); i++) {\n\t\t\tString c = \"?\";\n\t\t\tif (i < alpha.length()) {\n\t\t\t\tc = alpha.substring(i, i + 1);\n\t\t\t}\n\t\t\tformula.append(c);\n\t\t\tint multiplier = seqClusters.get(i).getSequenceCount();\n\t\t\tif (multiplier > 1) {\n\t\t\t\tformula.append(multiplier);\n\t\t\t}\n\t\t}\n\t\treturn formula.toString();\n\t}\n\n\t/**\n\t * Get valid symmetry order for this stoichiometry.\n\t * \n\t * @return\n\t */\n\tpublic List<Integer> getFolds() {\n\t\trun();\n\t\tList<Integer> stoichiometry = new ArrayList<Integer>(seqClusters.size());\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tstoichiometry.add(seqCount);\n\t\t}\n\t\treturn getValidFolds(stoichiometry);\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each chain cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n\n\tpublic List<Integer> getSequenceClusterIds() {\n\t\trun();\n\t\tList<Integer> list = new ArrayList<Integer>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(id);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic int getSequenceClusterCount() {\n\t\trun();\n\t\treturn seqClusters.size();\n\t}\n\n\tpublic List<SequenceAlignmentCluster> getSequenceAlignmentClusters() {\n\t\treturn seqClusters;\n\t}\n\n\tpublic List<Boolean> getPseudoStoichiometry() {\n\t\trun();\n\t\tList<Boolean> list = new ArrayList<Boolean>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tBoolean pseudo = seqClusters.get(id).isPseudoStoichiometric();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(pseudo);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic List<Double> getMinSequenceIdentity() {\n\t\trun();\n\t\tList<Double> list = new ArrayList<Double>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tdouble minSequenceIdentity = seqClusters.get(id)\n\t\t\t\t\t.getMinSequenceIdentity();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(minSequenceIdentity);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic List<Double> getMaxSequenceIdentity() {\n\t\trun();\n\t\tList<Double> list = new ArrayList<Double>();\n\n\t\tfor (int id = 0; id < seqClusters.size(); id++) {\n\t\t\tint seqCount = seqClusters.get(id).getSequenceCount();\n\t\t\tdouble maxSequenceIdentity = seqClusters.get(id)\n\t\t\t\t\t.getMaxSequenceIdentity();\n\t\t\tfor (int i = 0; i < seqCount; i++) {\n\t\t\t\tlist.add(maxSequenceIdentity);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\trun();\n\t\tStringBuilder builder = new StringBuilder();\n\t\tbuilder.append(\"Sequence alignment clusters: \" + seqClusters.size());\n\t\tbuilder.append(\"\\n\");\n\t\tfor (SequenceAlignmentCluster s : seqClusters) {\n\t\t\tbuilder.append(\"# seq: \");\n\t\t\tbuilder.append(s.getSequenceCount());\n\t\t\tbuilder.append(\" alignment length: \");\n\t\t\tbuilder.append(s.getSequenceAlignmentLength());\n\t\t\tbuilder.append(\"\\n\");\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\tprivate void run() {\n\t\tif (modified) {\n\t\t\tmodified = false;\n\t\t\tcalcAlignedSequences();\n\t\t\tcreateCalphaTraces();\n\t\t}\n\t}\n\n\tprivate void calcAlignedSequences() {\n\t\tcaAligned = new ArrayList<Atom[]>();\n\t\tfor (SequenceAlignmentCluster cluster : seqClusters) {\n\t\t\tcaAligned.addAll(cluster.getAlignedCalphaAtoms());\n\t\t}\n\t}\n\n\tprivate void createCalphaTraces() {\n\t\tfor (Atom[] atoms : caAligned) {\n\t\t\tPoint3d[] trace = new Point3d[atoms.length];\n\t\t\tfor (int j = 0; j < atoms.length; j++) {\n\t\t\t\ttrace[j] = new Point3d(atoms[j].getCoords());\n\t\t\t}\n\t\t\tcaCoords.add(trace);\n\t\t}\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.cluster.ChainClusterer;\nimport org.junit.Test;\n\npublic class TestChainClusterer {\n\n\t/**\n\t * Test ChainClusterer.getValidFolds\n\t */\n\t@Test\n\tpublic void testValidFolds() {\n\t\tList<Integer> stoich;\n\t\tList<Integer> folds;\n\t\tList<Integer> expected;\n\n\t\tstoich = Arrays.asList(6,4);\n\t\texpected = Arrays.asList(1,2);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,6);\n\t\texpected = Arrays.asList(1,2,3,6);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,3);\n\t\texpected = Arrays.asList(1,3);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,5);\n\t\texpected = Arrays.asList(1);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.cluster.ChainClusterer;\nimport org.junit.Test;\n\npublic class TestChainClusterer {\n\n\t/**\n\t * Test ChainClusterer.getValidFolds\n\t */\n\t@Test\n\tpublic void testValidFolds() {\n\t\t\n\t\tList<Integer> stoich;\n\t\tList<Integer> folds;\n\t\tList<Integer> expected;\n\n\t\tstoich = Arrays.asList(6,4);\n\t\texpected = Arrays.asList(1,2);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,6);\n\t\texpected = Arrays.asList(1,2,3,6);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,3);\n\t\texpected = Arrays.asList(1,3);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t\tstoich = Arrays.asList(6,5);\n\t\texpected = Arrays.asList(1);\n\t\tfolds = ChainClusterer.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \"+stoich,expected,folds);\n\n\t}\n}\n","commitMessage":"Replace verbose by logger.info and unify methods with StructureTools","test_commitMessage":"Replace verbose by logger.info and unify methods with StructureTools","allZero":true}