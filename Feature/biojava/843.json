{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/xtal/CrystalBuilder.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/xtal/TestCrystalBuilder.java","prod_time":"2018-03-02 07:24:55","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"8c679332bd876f440951db79305a773a03dc2d62","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.xtal;\n\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.AtomContactSet;\nimport org.biojava.nbio.structure.contact.StructureInterface;\nimport org.biojava.nbio.structure.contact.StructureInterfaceList;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Vector3d;\nimport java.util.*;\n\n\n/**\n * A class containing methods to find interfaces in a given crystallographic Structure by\n * reconstructing the crystal lattice through application of symmetry operators\n *\n * @author Jose Duarte\n *\n */\n\npublic class CrystalBuilder {\n\n\t// Default number of cell neighbors to try in interface search (in 3 directions of space).\n\t// In the search, only bounding box overlaps are tried, thus there's not so much overhead in adding\n\t// more cells. We actually tested it and using numCells from 1 to 10 didn't change runtimes at all.\n\t// Examples with interfaces in distant neighbor cells:\n\t//   2nd neighbors: 3hz3, 1wqj, 2de3, 1jcd\n\t//   3rd neighbors: 3bd3, 1men, 2gkp, 1wui\n\t//   5th neighbors: 2ahf, 2h2z\n\t//   6th neighbors: 1was (in fact interfaces appear only at 5th neighbors for it)\n\t// Maybe this could be avoided by previously translating the given molecule to the first cell,\n\t// BUT! some bona fide cases exist, e.g. 2d3e: it is properly placed at the origin but the molecule\n\t// is enormously long in comparison with the dimensions of the unit cell, some interfaces come at the 7th neighbor.\n\t// After a scan of the whole PDB (Oct 2013) using numCells=50, the highest one was 4jgc with\n\t// interfaces up to the 11th neighbor. Other high ones (9th neighbors) are 4jbm and 4k3t.\n\t// We set the default value to 12 based on that (having not seen any difference in runtime)\n\tpublic static final int DEF_NUM_CELLS = 12;\n\n\t/**\n\t * Default maximum distance between two chains to be considered an interface.\n\t * @see #getUniqueInterfaces(double)\n\t */\n\tpublic static final double DEFAULT_INTERFACE_DISTANCE_CUTOFF = 5.5;\n\n\tpublic static final Matrix4d IDENTITY = new Matrix4d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\n\n\t/**\n\t * Whether to consider HETATOMs in contact calculations\n\t */\n\tprivate static final boolean INCLUDE_HETATOMS = true;\n\n\tprivate Structure structure;\n\tprivate PDBCrystallographicInfo crystallographicInfo;\n\tprivate int numPolyChainsAu;\n\tprivate int numOperatorsSg;\n\tprivate Map<String,Matrix4d> chainNcsOps = null;\n\tprivate Map<String,String> chainOrigNames = null;\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(CrystalBuilder.class);\n\n\tprivate int numCells;\n\n\tprivate ArrayList<CrystalTransform> visitedCrystalTransforms;\n\tprivate Map<String,Map<Matrix4d,StructureInterface>> visitedNcsChainPairs = null;\n\n\tprivate boolean searchBeyondAU;\n\tprivate Matrix4d[] ops;\n\n\t/**\n\t * Special constructor for NCS-aware CrystalBuilder.\n\t * The output list of interfaces will be pre-clustered by NCS-equivalence.\n\t * Run {@link CrystalBuilder#expandNcsOps(Structure, Map, Map)} first to extend the AU\n\t * and get the equivalence information.\n\t * @param structure\n\t *          NCS-extended structure\n\t * @param chainOrigNames\n\t *          chain names mapped to the original chain names (pre-NCS extension)\n\t * @param chainNcsOps\n\t *          chain names mapped to the ncs operators that was used to generate them\n\t */\n\tpublic CrystalBuilder(Structure structure, Map<String,String> chainOrigNames, Map<String,Matrix4d> chainNcsOps) {\n\t\tthis(structure);\n\t\tthis.chainOrigNames = chainOrigNames;\n\t\tthis.chainNcsOps = chainNcsOps;\n\t}\n\n\tpublic CrystalBuilder(Structure structure) {\n\t\tthis.structure = structure;\n\t\tthis.crystallographicInfo = structure.getCrystallographicInfo();\n\t\tthis.numPolyChainsAu = structure.getPolyChains().size();\n\n\t\tthis.searchBeyondAU = false;\n\t\tif (structure.isCrystallographic()) {\n\n\t\t\tthis.searchBeyondAU = true;\n\n\t\t\t// we need to check space group not null for the cases where the entry is crystallographic but\n\t\t\t// the space group is not a standard one recognized by biojava, e.g. 1mnk (SG: 'I 21')\n\t\t\tif (this.crystallographicInfo.isNonStandardSg()) {\n\t\t\t\tlogger.warn(\"Space group is non-standard, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// just in case we still check for space group null (a user pdb file could potentially be crystallographic and have no space group)\n\t\t\tif (this.crystallographicInfo.getSpaceGroup() == null) {\n\t\t\t\tlogger.warn(\"Space group is null, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// we need to check crystal cell not null for the rare cases where the entry is crystallographic but\n\t\t\t// the crystal cell is not given, e.g. 2i68, 2xkm, 4bpq\n\t\t\tif (this.crystallographicInfo.getCrystalCell() == null) {\n\t\t\t\tlogger.warn(\"Could not find a crystal cell definition, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// check for cases like 4hhb that are in a non-standard coordinate frame convention, see https://github.com/eppic-team/owl/issues/4\n\t\t\tif (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {\n\t\t\t\tlogger.warn(\"Non-standard coordinate frame convention, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.searchBeyondAU) {\n\t\t\t// explore the crystal\n\t\t\tthis.numOperatorsSg = this.crystallographicInfo.getSpaceGroup().getMultiplicity();\n\t\t\tthis.ops = this.crystallographicInfo.getTransformationsOrthonormal();\n\t\t} else {\n\t\t\t// look for contacts within structure as given\n\t\t\tthis.numOperatorsSg = 1;\n\t\t\tthis.ops = new Matrix4d[1];\n\t\t\tthis.ops[0] = new Matrix4d(IDENTITY);\n\t\t}\n\n\t\tthis.numCells = DEF_NUM_CELLS;\n\n\t}\n\n\n\t/**\n\t * @return true if this CrystalBuilder is NCS-aware.\n\t */\n\tpublic boolean hasNcsOps() {\n\t\treturn chainNcsOps != null;\n\t}\n\n\t/**\n\t * Set the number of neighboring crystal cells that will be used in the search for contacts\n\t * @param numCells\n\t */\n\tpublic void setNumCells(int numCells) {\n\t\tthis.numCells = numCells;\n\t}\n\n\tprivate void initialiseVisited() {\n\t\tvisitedCrystalTransforms = new ArrayList<>();\n\t\tif(this.hasNcsOps()) {\n\t\t\tvisitedNcsChainPairs = new HashMap<>();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon\n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains\n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within\n\t * the default cutoff distance.\n\t * @return\n\t * @see #DEFAULT_INTERFACE_DISTANCE_CUTOFF\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces() {\n\t\treturn getUniqueInterfaces(DEFAULT_INTERFACE_DISTANCE_CUTOFF);\n\t}\n\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon\n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains\n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within\n\t * the given cutoff distance.\n\t * @param cutoff the distance cutoff for 2 chains to be considered in contact\n\t * @return\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces(double cutoff) {\n\n\n\t\tStructureInterfaceList set = new StructureInterfaceList();\n\n\t\t// certain structures in the PDB are not macromolecules (contain no polymeric chains at all), e.g. 1ao2\n\t\t// with the current mmCIF parsing, those will be empty since purely non-polymeric chains are removed\n\t\t// see commit e9562781f23da0ebf3547146a307d7edd5741090\n\t\tif (numPolyChainsAu==0) {\n\t\t\tlogger.warn(\"No chains present in the structure! No interfaces will be calculated\");\n\t\t\treturn set;\n\t\t}\n\n\n\n\t\t// initialising the visited ArrayList for keeping track of symmetry redundancy\n\t\tinitialiseVisited();\n\n\n\n\t\t// the isCrystallographic() condition covers 3 cases:\n\t\t// a) entries with expMethod X-RAY/other diffraction and defined crystalCell (most usual case)\n\t\t// b) entries with expMethod null but defined crystalCell (e.g. PDB file with CRYST1 record but no expMethod annotation)\n\t\t// c) entries with expMethod not X-RAY (e.g. NMR) and defined crystalCell (NMR entries do have a dummy CRYST1 record \"1 1 1 90 90 90 P1\")\n\t\t// d) isCrystallographic will be false if the structure is crystallographic but the space group was not recognized\n\n\n\t\tcalcInterfacesCrystal(set, cutoff);\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * Calculate interfaces between original asymmetric unit and neighboring\n\t * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0\n\t * @param set\n\t * @param cutoff\n\t */\n\tprivate void calcInterfacesCrystal(StructureInterfaceList set, double cutoff) {\n\n\n\t\t// initialising debugging vars\n\t\tlong start = -1;\n\t\tlong end = -1;\n\t\tint trialCount = 0;\n\t\tint skippedRedundant = 0;\n\t\tint skippedAUsNoOverlap = 0;\n\t\tint skippedChainsNoOverlap = 0;\n\t\tint skippedSelfEquivalent = 0;\n\n\t\t// The bounding boxes of all AUs of the unit cell\n\t\tUnitCellBoundingBox bbGrid = new UnitCellBoundingBox(numOperatorsSg, numPolyChainsAu);;\n\t\t// we calculate all the bounds of each of the asym units, those will then be reused and translated\n\t\tbbGrid.setBbs(structure, ops, INCLUDE_HETATOMS);\n\n\n\t\t// if not crystallographic there's no search to do in other cells, only chains within \"AU\" will be checked\n\t\tif (!searchBeyondAU) numCells = 0;\n\n\t\tboolean verbose = logger.isDebugEnabled();\n\n\t\tif (verbose) {\n\t\t\ttrialCount = 0;\n\t\t\tstart= System.currentTimeMillis();\n\t\t\tint neighbors = (2*numCells+1)*(2*numCells+1)*(2*numCells+1)-1;\n\t\t\tint auTrials = (numPolyChainsAu*(numPolyChainsAu-1))/2;\n\t\t\tint trials = numPolyChainsAu*numOperatorsSg*numPolyChainsAu*neighbors;\n\t\t\tlogger.debug(\"Chain clash trials within original AU: \"+auTrials);\n\t\t\tlogger.debug(\n\t\t\t\t\t\"Chain clash trials between the original AU and the neighbouring \"+neighbors+\n\t\t\t\t\t\" whole unit cells (\"+numCells+\" neighbours)\" +\n\t\t\t\t\t\"(2x\"+numPolyChainsAu+\"chains x \"+numOperatorsSg+\"AUs x \"+neighbors+\"cells) : \"+trials);\n\t\t\tlogger.debug(\"Total trials: \"+(auTrials+trials));\n\t\t}\n\n\t\tList<Chain> polyChains = structure.getPolyChains();\n\n\t\tfor (int a=-numCells;a<=numCells;a++) {\n\t\t\tfor (int b=-numCells;b<=numCells;b++) {\n\t\t\t\tfor (int c=-numCells;c<=numCells;c++) {\n\n\t\t\t\t\tPoint3i trans = new Point3i(a,b,c);\n\t\t\t\t\tVector3d transOrth = new Vector3d(a,b,c);\n\t\t\t\t\tif (a!=0 || b!=0 || c!=0) {\n\t\t\t\t\t\t// we avoid doing the transformation for 0,0,0 (in case it's not crystallographic)\n\t\t\t\t\t\tthis.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);\n\t\t\t\t\t}\n\n\t\t\t\t\tUnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n\n\t\t\t\t\tfor (int n=0;n<numOperatorsSg;n++) {\n\n\t\t\t\t\t\t// short-cut strategies\n\t\t\t\t\t\t// 1) we skip first of all if the bounding boxes of the AUs don't overlap\n\t\t\t\t\t\tif (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n), cutoff)) {\n\t\t\t\t\t\t\tskippedAUsNoOverlap++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2) we check if we didn't already see its equivalent symmetry operator partner\n\t\t\t\t\t\tCrystalTransform tt = new CrystalTransform(this.crystallographicInfo.getSpaceGroup(), n);\n\t\t\t\t\t\ttt.translate(trans);\n\t\t\t\t\t\tif (isRedundantTransform(tt)) {\n\t\t\t\t\t\t\tskippedRedundant++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddVisitedTransform(tt);\n\n\n\t\t\t\t\t\tboolean selfEquivalent = false;\n\n\t\t\t\t\t\t// 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\n\t\t\t\t\t\tif (tt.isEquivalent(tt)) {\n\t\t\t\t\t\t\tlogger.debug(\"Transform \"+tt+\" is equivalent to itself, will skip half of i-chains to j-chains comparisons\");\n\t\t\t\t\t\t\t// in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n\t\t\t\t\t\t\t// we set a flag and do that within the loop below\n\t\t\t\t\t\t\tselfEquivalent = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tStringBuilder builder = null;\n\t\t\t\t\t\tif (verbose) builder = new StringBuilder(String.valueOf(tt)).append(\" \");\n\n\t\t\t\t\t\t// Now that we know that boxes overlap and operator is not redundant, we have to go to the details\n\t\t\t\t\t\tint contactsFound = 0;\n\n\t\t\t\t\t\tfor (int j=0;j<numPolyChainsAu;j++) {\n\n\t\t\t\t\t\t\tfor (int i=0;i<numPolyChainsAu;i++) { // we only have to compare the original asymmetric unit to every full cell around\n\n\t\t\t\t\t\t\t\tif(selfEquivalent && (j>i)) {\n\t\t\t\t\t\t\t\t\t// in case of self equivalency of the operator we can safely skip half of the matrix\n\t\t\t\t\t\t\t\t\tskippedSelfEquivalent++;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// special case of original AU, we don't compare a chain to itself\n\t\t\t\t\t\t\t\tif (n==0 && a==0 && b==0 && c==0 && i==j) continue;\n\n\t\t\t\t\t\t\t\t// before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n\t\t\t\t\t\t\t\tif (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {\n\t\t\t\t\t\t\t\t\tskippedChainsNoOverlap++;\n\t\t\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\t\t\tbuilder.append(\".\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttrialCount++;\n\n\t\t\t\t\t\t\t\t// finally we've gone through all short-cuts and the 2 chains seem to be close enough:\n\t\t\t\t\t\t\t\t// we do the calculation of contacts\n\t\t\t\t\t\t\t\tChain chaini = polyChains.get(i);\n\t\t\t\t\t\t\t\tChain chainj = polyChains.get(j);\n\n\t\t\t\t\t\t\t\tif (n!=0 || a!=0 || b!=0 || c!=0) {\n\t\t\t\t\t\t\t\t\tMatrix4d mJCryst = new Matrix4d(ops[n]);\n\t\t\t\t\t\t\t\t\ttranslate(mJCryst, transOrth);\n\t\t\t\t\t\t\t\t\tchainj = (Chain)chainj.clone();\n\t\t\t\t\t\t\t\t\tCalc.transform(chainj,mJCryst);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tStructureInterface interf = calcContacts(chaini, chainj, cutoff, tt, builder);\n\t\t\t\t\t\t\t\tif (interf == null) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontactsFound++;\n\t\t\t\t\t\t\t\tif(this.hasNcsOps()) {\n\t\t\t\t\t\t\t\t\tStructureInterface interfNcsRef = findNcsRef(interf);\n\t\t\t\t\t\t\t\t\tset.addNcsEquivalent(interf,interfNcsRef);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tset.add(interf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( verbose ) {\n\t\t\t\t\t\t\tif (a==0 && b==0 && c==0 && n==0)\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+(numPolyChainsAu*(numPolyChainsAu-1))/2+\")\");\n\t\t\t\t\t\t\telse if (selfEquivalent)\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+(numPolyChainsAu*(numPolyChainsAu+1))/2+\")\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+numPolyChainsAu*numPolyChainsAu+\")\");\n\n\t\t\t\t\t\t\tlogger.debug(builder.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tend = System.currentTimeMillis();\n\t\tlogger.debug(\"\\n\"+trialCount+\" chain-chain clash trials done. Time \"+(end-start)/1000+\"s\");\n\t\tlogger.debug(\"  skipped (not overlapping AUs)       : \"+skippedAUsNoOverlap);\n\t\tlogger.debug(\"  skipped (not overlapping chains)    : \"+skippedChainsNoOverlap);\n\t\tlogger.debug(\"  skipped (sym redundant op pairs)    : \"+skippedRedundant);\n\t\tlogger.debug(\"  skipped (sym redundant self op)     : \"+skippedSelfEquivalent);\n\t\tlogger.debug(\"Found \"+set.size()+\" interfaces.\");\n\t}\n\n\n\t/**\n\t * Checks whether given interface is NCS-redundant, i.e., an identical interface between NCS copies of\n\t * these molecules has already been seen, and returns this (reference) interface.\n\t *\n\t * @param interf\n\t *          StructureInterface\n\t * @return  already seen interface that is NCS-equivalent to interf,\n\t *          null if such interface is not found.\n\t */\n\tprivate StructureInterface findNcsRef(StructureInterface interf) {\n\t\tif (!this.hasNcsOps()) {\n\t\t\treturn null;\n\t\t}\n\t\tString chainIName = interf.getMoleculeIds().getFirst();\n\t\tString iOrigName = chainOrigNames.get(chainIName);\n\n\t\tString chainJName = interf.getMoleculeIds().getSecond();\n\t\tString jOrigName = chainOrigNames.get(chainJName);\n\n\t\tMatrix4d mJCryst;\n\t\tif(this.searchBeyondAU) {\n\t\t\tmJCryst = interf.getTransforms().getSecond().getMatTransform();\n\t\t\tmJCryst = crystallographicInfo.getCrystalCell().transfToOrthonormal(mJCryst);\n\t\t} else {\n\t\t\tmJCryst = IDENTITY;\n\t\t}\n\n\t\t// Let X1,...Xn be the original coords, before NCS transforms (M1...Mk)\n\t\t// current chain i: M_i * X_i\n\t\t// current chain j: Cn * M_j * X_j\n\n\t\t// transformation to bring chain j near X_i: M_i^(-1) * Cn * M_j\n\t\t// transformation to bring chain i near X_j: (Cn * M_j)^(-1) * M_i = (M_i^(-1) * Cn * M_j)^(-1)\n\n\t\tif(chainNcsOps.get(chainIName) == null)\n\t\t\treturn null;\n\t\tMatrix4d mChainIInv = new Matrix4d(chainNcsOps.get(chainIName));\n\t\tmChainIInv.invert();\n\n\t\tMatrix4d mJNcs = new Matrix4d(chainNcsOps.get(chainJName));\n\n\t\tMatrix4d j2iNcsOrigin = new Matrix4d(mChainIInv);\n\t\tj2iNcsOrigin.mul(mJCryst);\n\t\t//overall transformation to bring current chainj from its NCS origin to i's\n\t\tj2iNcsOrigin.mul(mJNcs);\n\n\t\t//overall transformation to bring current chaini from its NCS origin to j's\n\t\tMatrix4d i2jNcsOrigin = new Matrix4d(j2iNcsOrigin);\n\t\ti2jNcsOrigin.invert();\n\n\t\tString matchChainIdsIJ = iOrigName + jOrigName;\n\t\tString matchChainIdsJI = jOrigName + iOrigName;\n\n\t\t// same original chain names\n\t\tOptional<Matrix4d> matchDirect =\n\t\t\t\tvisitedNcsChainPairs.computeIfAbsent(matchChainIdsIJ, k-> new HashMap<>()).entrySet().stream().\n\t\t\t\t\tmap(r->r.getKey()).\n\t\t\t\t\tfilter(r->r.epsilonEquals(j2iNcsOrigin,0.01)).\n\t\t\t\t\tfindFirst();\n\n\t\tMatrix4d matchMatrix = matchDirect.orElse(null);\n\t\tString matchChainIds = matchChainIdsIJ;\n\n\t\tif(matchMatrix == null) {\n\t\t\t// reversed original chain names with inverted transform\n\t\t\tOptional<Matrix4d> matchInverse =\n\t\t\t\t\tvisitedNcsChainPairs.computeIfAbsent(matchChainIdsJI, k-> new HashMap<>()).entrySet().stream().\n\t\t\t\t\tmap(r->r.getKey()).\n\t\t\t\t\tfilter(r->r.epsilonEquals(i2jNcsOrigin,0.01)).\n\t\t\t\t\tfindFirst();\n\t\t\tmatchMatrix = matchInverse.orElse(null);\n\t\t\tmatchChainIds = matchChainIdsJI;\n\t\t}\n\n\t\tStructureInterface matchInterface = null;\n\n\t\tif (matchMatrix == null) {\n\t\t\tvisitedNcsChainPairs.get(matchChainIdsIJ).put(j2iNcsOrigin,interf);\n\t\t} else {\n\t\t\tmatchInterface = visitedNcsChainPairs.get(matchChainIds).get(matchMatrix);\n\t\t}\n\n\t\treturn matchInterface;\n\t}\n\n\tprivate StructureInterface calcContacts(Chain chaini, Chain chainj, double cutoff, CrystalTransform tt, StringBuilder builder) {\n\t\t// note that we don't consider hydrogens when calculating contacts\n\t\tAtomContactSet graph = StructureTools.getAtomsInContact(chaini, chainj, cutoff, INCLUDE_HETATOMS);\n\n\t\tif (graph.size()>0) {\n\t\t\tif (builder != null) builder.append(\"x\");\n\n\t\t\tCrystalTransform transf = new CrystalTransform(this.crystallographicInfo.getSpaceGroup());\n\t\t\tStructureInterface interf = new StructureInterface(\n\t\t\t\t\tStructureTools.getAllAtomArray(chaini), StructureTools.getAllAtomArray(chainj),\n\t\t\t\t\tchaini.getName(), chainj.getName(),\n\t\t\t\t\tgraph,\n\t\t\t\t\ttransf, tt);\n\n\t\t\treturn interf;\n\n\t\t} else {\n\t\t\tif (builder != null) builder.append(\"o\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate void addVisitedTransform(CrystalTransform tt) {\n\t\tvisitedCrystalTransforms.add(tt);\n\t}\n\n\t/**\n\t * Checks whether given transformId/translation is symmetry redundant\n\t * Two transformations are symmetry redundant if their matrices (4d) multiplication gives the identity, i.e.\n\t * if one is the inverse of the other.\n\t * @param tt\n\t * @return\n\t */\n\tprivate boolean isRedundantTransform(CrystalTransform tt) {\n\n\t\tIterator<CrystalTransform> it = visitedCrystalTransforms.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tCrystalTransform v = it.next();\n\n\t\t\tif (tt.isEquivalent(v)) {\n\n\t\t\t\tlogger.debug(\"Skipping redundant transformation: \"+tt+\", equivalent to \"+v);\n\n\t\t\t\t// there's only 1 possible equivalent partner for each visited matrix\n\t\t\t\t// (since the equivalent is its inverse matrix and the inverse matrix is unique)\n\t\t\t\t// thus once the partner has been seen, we don't need to check it ever again\n\t\t\t\tit.remove();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void translate(Matrix4d m, Vector3d translation) {\n\t\tm.m03 = m.m03+translation.x;\n\t\tm.m13 = m.m13+translation.y;\n\t\tm.m23 = m.m23+translation.z;\n\t}\n\n\t/**\n\t * Apply the NCS operators in the given Structure adding new chains as needed.\n\t * All chains are (re)assigned ids of the form: original_chain_id+ncs_operator_index+\"n\".\n\t * @param structure\n\t *          the structure to expand\n\t * @param chainOrigNames\n\t *          new chain names mapped to the original chain names\n\t * @param chainNcsOps\n\t *          new chain names mapped to the ncs operators that was used to generate them\n\t */\n\tpublic static void expandNcsOps(Structure structure, Map<String,String> chainOrigNames, Map<String,Matrix4d> chainNcsOps) {\n\t\tPDBCrystallographicInfo xtalInfo = structure.getCrystallographicInfo();\n\t\tif (xtalInfo ==null) return;\n\n\t\tif (xtalInfo.getNcsOperators()==null || xtalInfo.getNcsOperators().length==0)\n\t\t\treturn;\n\n\t\tList<Chain> chainsToAdd = new ArrayList<>();\n\n\t\tMatrix4d identity = new Matrix4d();\n\t\tidentity.setIdentity();\n\n\t\tMatrix4d[] ncsOps = xtalInfo.getNcsOperators();\n\n\t\tfor (Chain c:structure.getChains()) {\n\t\t\tString cOrigId = c.getId();\n\t\t\tString cOrigName = c.getName();\n\n\t\t\tfor (int iOperator = 0; iOperator < ncsOps.length; iOperator++) {\n\t\t\t\tMatrix4d m = ncsOps[iOperator];\n\n\t\t\t\tChain clonedChain = (Chain)c.clone();\n\t\t\t\tString newChainId = cOrigId+(iOperator+1)+\"n\";\n\t\t\t\tString newChainName = cOrigName+(iOperator+1)+\"n\";\n\t\t\t\tclonedChain.setId(newChainId);\n\t\t\t\tclonedChain.setName(newChainName);\n\n\t\t\t\tsetChainIdsInResidueNumbers(clonedChain, newChainName);\n\t\t\t\tCalc.transform(clonedChain, m);\n\n\t\t\t\tchainsToAdd.add(clonedChain);\n\t\t\t\tc.getEntityInfo().addChain(clonedChain);\n\n\t\t\t\tchainOrigNames.put(newChainName,c.getId());\n\t\t\t\tchainNcsOps.put(newChainName,m);\n\t\t\t}\n\t\t\tc.setName(cOrigName+0+\"n\");\n\t\t\tc.setId(cOrigId+0+\"n\");\n\n\t\t\tchainNcsOps.put(c.getName(),identity);\n\t\t\tchainOrigNames.put(c.getName(),cOrigId);\n\t\t}\n\n\t\tchainsToAdd.forEach(structure::addChain);\n\t}\n\n\t/**\n\t * Auxiliary method to reset chain ids of residue numbers in a chain.\n\t * Used when cloning chains and resetting their ids: one needs to take care of\n\t * resetting the ids within residue numbers too.\n\t * @param c\n\t * @param newChainName\n\t */\n\tprivate static void setChainIdsInResidueNumbers(Chain c, String newChainName) {\n\t\tfor (Group g:c.getAtomGroups()) {\n\t\t\tg.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n\t\t}\n\t\tfor (Group g:c.getSeqResGroups()) {\n\t\t\tif (g.getResidueNumber()==null) continue;\n\t\t\tg.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n\t\t}\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.xtal;\n\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.AtomContactSet;\nimport org.biojava.nbio.structure.contact.StructureInterface;\nimport org.biojava.nbio.structure.contact.StructureInterfaceList;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Vector3d;\nimport java.util.*;\n\n\n/**\n * A class containing methods to find interfaces in a given crystallographic Structure by\n * reconstructing the crystal lattice through application of symmetry operators\n *\n * @author Jose Duarte\n *\n */\n\npublic class CrystalBuilder {\n\n\t// Default number of cell neighbors to try in interface search (in 3 directions of space).\n\t// In the search, only bounding box overlaps are tried, thus there's not so much overhead in adding\n\t// more cells. We actually tested it and using numCells from 1 to 10 didn't change runtimes at all.\n\t// Examples with interfaces in distant neighbor cells:\n\t//   2nd neighbors: 3hz3, 1wqj, 2de3, 1jcd\n\t//   3rd neighbors: 3bd3, 1men, 2gkp, 1wui\n\t//   5th neighbors: 2ahf, 2h2z\n\t//   6th neighbors: 1was (in fact interfaces appear only at 5th neighbors for it)\n\t// Maybe this could be avoided by previously translating the given molecule to the first cell,\n\t// BUT! some bona fide cases exist, e.g. 2d3e: it is properly placed at the origin but the molecule\n\t// is enormously long in comparison with the dimensions of the unit cell, some interfaces come at the 7th neighbor.\n\t// After a scan of the whole PDB (Oct 2013) using numCells=50, the highest one was 4jgc with\n\t// interfaces up to the 11th neighbor. Other high ones (9th neighbors) are 4jbm and 4k3t.\n\t// We set the default value to 12 based on that (having not seen any difference in runtime)\n\tpublic static final int DEF_NUM_CELLS = 12;\n\n\t/**\n\t * Default maximum distance between two chains to be considered an interface.\n\t * @see #getUniqueInterfaces(double)\n\t */\n\tpublic static final double DEFAULT_INTERFACE_DISTANCE_CUTOFF = 5.5;\n\n\tpublic static final Matrix4d IDENTITY = new Matrix4d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);\n\n\n\t/**\n\t * Whether to consider HETATOMs in contact calculations\n\t */\n\tprivate static final boolean INCLUDE_HETATOMS = true;\n\n\tprivate Structure structure;\n\tprivate PDBCrystallographicInfo crystallographicInfo;\n\tprivate int numPolyChainsAu;\n\tprivate int numOperatorsSg;\n\tprivate Map<String,Matrix4d> chainNcsOps = null;\n\tprivate Map<String,String> chainOrigNames = null;\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(CrystalBuilder.class);\n\n\tprivate int numCells;\n\n\tprivate ArrayList<CrystalTransform> visitedCrystalTransforms;\n\tprivate Map<String,Map<Matrix4d,StructureInterface>> visitedNcsChainPairs = null;\n\n\tprivate boolean searchBeyondAU;\n\tprivate Matrix4d[] ops;\n\n\t/**\n\t * Special constructor for NCS-aware CrystalBuilder.\n\t * The output list of interfaces will be pre-clustered by NCS-equivalence.\n\t * Run {@link CrystalBuilder#expandNcsOps(Structure, Map, Map)} first to extend the AU\n\t * and get the equivalence information.\n\t * @param structure\n\t *          NCS-extended structure\n\t * @param chainOrigNames\n\t *          chain names mapped to the original chain names (pre-NCS extension)\n\t * @param chainNcsOps\n\t *          chain names mapped to the ncs operators that was used to generate them\n\t */\n\tpublic CrystalBuilder(Structure structure, Map<String,String> chainOrigNames, Map<String,Matrix4d> chainNcsOps) {\n\t\tthis(structure);\n\t\tthis.chainOrigNames = chainOrigNames;\n\t\tthis.chainNcsOps = chainNcsOps;\n\t}\n\n\tpublic CrystalBuilder(Structure structure) {\n\t\tthis.structure = structure;\n\t\tthis.crystallographicInfo = structure.getCrystallographicInfo();\n\t\tthis.numPolyChainsAu = structure.getPolyChains().size();\n\n\t\tthis.searchBeyondAU = false;\n\t\tif (structure.isCrystallographic()) {\n\n\t\t\tthis.searchBeyondAU = true;\n\n\t\t\t// we need to check space group not null for the cases where the entry is crystallographic but\n\t\t\t// the space group is not a standard one recognized by biojava, e.g. 1mnk (SG: 'I 21')\n\t\t\tif (this.crystallographicInfo.isNonStandardSg()) {\n\t\t\t\tlogger.warn(\"Space group is non-standard, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// just in case we still check for space group null (a user pdb file could potentially be crystallographic and have no space group)\n\t\t\tif (this.crystallographicInfo.getSpaceGroup() == null) {\n\t\t\t\tlogger.warn(\"Space group is null, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// we need to check crystal cell not null for the rare cases where the entry is crystallographic but\n\t\t\t// the crystal cell is not given, e.g. 2i68, 2xkm, 4bpq\n\t\t\tif (this.crystallographicInfo.getCrystalCell() == null) {\n\t\t\t\tlogger.warn(\"Could not find a crystal cell definition, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\n\t\t\t// check for cases like 4hhb that are in a non-standard coordinate frame convention, see https://github.com/eppic-team/owl/issues/4\n\t\t\tif (this.crystallographicInfo.isNonStandardCoordFrameConvention()) {\n\t\t\t\tlogger.warn(\"Non-standard coordinate frame convention, will only calculate asymmetric unit interfaces.\");\n\t\t\t\tthis.searchBeyondAU = false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.searchBeyondAU) {\n\t\t\t// explore the crystal\n\t\t\tthis.numOperatorsSg = this.crystallographicInfo.getSpaceGroup().getMultiplicity();\n\t\t\tthis.ops = this.crystallographicInfo.getTransformationsOrthonormal();\n\t\t} else {\n\t\t\t// look for contacts within structure as given\n\t\t\tthis.numOperatorsSg = 1;\n\t\t\tthis.ops = new Matrix4d[1];\n\t\t\tthis.ops[0] = new Matrix4d(IDENTITY);\n\t\t}\n\n\t\tthis.numCells = DEF_NUM_CELLS;\n\n\t}\n\n\n\t/**\n\t * @return true if this CrystalBuilder is NCS-aware.\n\t */\n\tpublic boolean hasNcsOps() {\n\t\treturn chainNcsOps != null;\n\t}\n\n\t/**\n\t * Set the number of neighboring crystal cells that will be used in the search for contacts\n\t * @param numCells\n\t */\n\tpublic void setNumCells(int numCells) {\n\t\tthis.numCells = numCells;\n\t}\n\n\tprivate void initialiseVisited() {\n\t\tvisitedCrystalTransforms = new ArrayList<>();\n\t\tif(this.hasNcsOps()) {\n\t\t\tvisitedNcsChainPairs = new HashMap<>();\n\t\t}\n\t}\n\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon\n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains\n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within\n\t * the default cutoff distance.\n\t * @return\n\t * @see #DEFAULT_INTERFACE_DISTANCE_CUTOFF\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces() {\n\t\treturn getUniqueInterfaces(DEFAULT_INTERFACE_DISTANCE_CUTOFF);\n\t}\n\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon\n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains\n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within\n\t * the given cutoff distance.\n\t * @param cutoff the distance cutoff for 2 chains to be considered in contact\n\t * @return\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces(double cutoff) {\n\n\n\t\tStructureInterfaceList set = new StructureInterfaceList();\n\n\t\t// certain structures in the PDB are not macromolecules (contain no polymeric chains at all), e.g. 1ao2\n\t\t// with the current mmCIF parsing, those will be empty since purely non-polymeric chains are removed\n\t\t// see commit e9562781f23da0ebf3547146a307d7edd5741090\n\t\tif (numPolyChainsAu==0) {\n\t\t\tlogger.warn(\"No chains present in the structure! No interfaces will be calculated\");\n\t\t\treturn set;\n\t\t}\n\n\n\n\t\t// initialising the visited ArrayList for keeping track of symmetry redundancy\n\t\tinitialiseVisited();\n\n\n\n\t\t// the isCrystallographic() condition covers 3 cases:\n\t\t// a) entries with expMethod X-RAY/other diffraction and defined crystalCell (most usual case)\n\t\t// b) entries with expMethod null but defined crystalCell (e.g. PDB file with CRYST1 record but no expMethod annotation)\n\t\t// c) entries with expMethod not X-RAY (e.g. NMR) and defined crystalCell (NMR entries do have a dummy CRYST1 record \"1 1 1 90 90 90 P1\")\n\t\t// d) isCrystallographic will be false if the structure is crystallographic but the space group was not recognized\n\n\n\t\tcalcInterfacesCrystal(set, cutoff);\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * Calculate interfaces between original asymmetric unit and neighboring\n\t * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0\n\t * @param set\n\t * @param cutoff\n\t */\n\tprivate void calcInterfacesCrystal(StructureInterfaceList set, double cutoff) {\n\n\n\t\t// initialising debugging vars\n\t\tlong start = -1;\n\t\tlong end = -1;\n\t\tint trialCount = 0;\n\t\tint skippedRedundant = 0;\n\t\tint skippedAUsNoOverlap = 0;\n\t\tint skippedChainsNoOverlap = 0;\n\t\tint skippedSelfEquivalent = 0;\n\n\t\t// The bounding boxes of all AUs of the unit cell\n\t\tUnitCellBoundingBox bbGrid = new UnitCellBoundingBox(numOperatorsSg, numPolyChainsAu);;\n\t\t// we calculate all the bounds of each of the asym units, those will then be reused and translated\n\t\tbbGrid.setBbs(structure, ops, INCLUDE_HETATOMS);\n\n\n\t\t// if not crystallographic there's no search to do in other cells, only chains within \"AU\" will be checked\n\t\tif (!searchBeyondAU) numCells = 0;\n\n\t\tboolean verbose = logger.isDebugEnabled();\n\n\t\tif (verbose) {\n\t\t\ttrialCount = 0;\n\t\t\tstart= System.currentTimeMillis();\n\t\t\tint neighbors = (2*numCells+1)*(2*numCells+1)*(2*numCells+1)-1;\n\t\t\tint auTrials = (numPolyChainsAu*(numPolyChainsAu-1))/2;\n\t\t\tint trials = numPolyChainsAu*numOperatorsSg*numPolyChainsAu*neighbors;\n\t\t\tlogger.debug(\"Chain clash trials within original AU: \"+auTrials);\n\t\t\tlogger.debug(\n\t\t\t\t\t\"Chain clash trials between the original AU and the neighbouring \"+neighbors+\n\t\t\t\t\t\" whole unit cells (\"+numCells+\" neighbours)\" +\n\t\t\t\t\t\"(2x\"+numPolyChainsAu+\"chains x \"+numOperatorsSg+\"AUs x \"+neighbors+\"cells) : \"+trials);\n\t\t\tlogger.debug(\"Total trials: \"+(auTrials+trials));\n\t\t}\n\n\t\tList<Chain> polyChains = structure.getPolyChains();\n\n\t\tfor (int a=-numCells;a<=numCells;a++) {\n\t\t\tfor (int b=-numCells;b<=numCells;b++) {\n\t\t\t\tfor (int c=-numCells;c<=numCells;c++) {\n\n\t\t\t\t\tPoint3i trans = new Point3i(a,b,c);\n\t\t\t\t\tVector3d transOrth = new Vector3d(a,b,c);\n\t\t\t\t\tif (a!=0 || b!=0 || c!=0) {\n\t\t\t\t\t\t// we avoid doing the transformation for 0,0,0 (in case it's not crystallographic)\n\t\t\t\t\t\tthis.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);\n\t\t\t\t\t}\n\n\t\t\t\t\tUnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n\n\t\t\t\t\tfor (int n=0;n<numOperatorsSg;n++) {\n\n\t\t\t\t\t\t// short-cut strategies\n\t\t\t\t\t\t// 1) we skip first of all if the bounding boxes of the AUs don't overlap\n\t\t\t\t\t\tif (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n), cutoff)) {\n\t\t\t\t\t\t\tskippedAUsNoOverlap++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2) we check if we didn't already see its equivalent symmetry operator partner\n\t\t\t\t\t\tCrystalTransform tt = new CrystalTransform(this.crystallographicInfo.getSpaceGroup(), n);\n\t\t\t\t\t\ttt.translate(trans);\n\t\t\t\t\t\tif (isRedundantTransform(tt)) {\n\t\t\t\t\t\t\tskippedRedundant++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddVisitedTransform(tt);\n\n\n\t\t\t\t\t\tboolean selfEquivalent = false;\n\n\t\t\t\t\t\t// 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\n\t\t\t\t\t\tif (tt.isEquivalent(tt)) {\n\t\t\t\t\t\t\tlogger.debug(\"Transform \"+tt+\" is equivalent to itself, will skip half of i-chains to j-chains comparisons\");\n\t\t\t\t\t\t\t// in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n\t\t\t\t\t\t\t// we set a flag and do that within the loop below\n\t\t\t\t\t\t\tselfEquivalent = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tStringBuilder builder = null;\n\t\t\t\t\t\tif (verbose) builder = new StringBuilder(String.valueOf(tt)).append(\" \");\n\n\t\t\t\t\t\t// Now that we know that boxes overlap and operator is not redundant, we have to go to the details\n\t\t\t\t\t\tint contactsFound = 0;\n\n\t\t\t\t\t\tfor (int j=0;j<numPolyChainsAu;j++) {\n\n\t\t\t\t\t\t\tfor (int i=0;i<numPolyChainsAu;i++) { // we only have to compare the original asymmetric unit to every full cell around\n\n\t\t\t\t\t\t\t\tif(selfEquivalent && (j>i)) {\n\t\t\t\t\t\t\t\t\t// in case of self equivalency of the operator we can safely skip half of the matrix\n\t\t\t\t\t\t\t\t\tskippedSelfEquivalent++;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// special case of original AU, we don't compare a chain to itself\n\t\t\t\t\t\t\t\tif (n==0 && a==0 && b==0 && c==0 && i==j) continue;\n\n\t\t\t\t\t\t\t\t// before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n\t\t\t\t\t\t\t\tif (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {\n\t\t\t\t\t\t\t\t\tskippedChainsNoOverlap++;\n\t\t\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\t\t\tbuilder.append(\".\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttrialCount++;\n\n\t\t\t\t\t\t\t\t// finally we've gone through all short-cuts and the 2 chains seem to be close enough:\n\t\t\t\t\t\t\t\t// we do the calculation of contacts\n\t\t\t\t\t\t\t\tChain chaini = polyChains.get(i);\n\t\t\t\t\t\t\t\tChain chainj = polyChains.get(j);\n\n\t\t\t\t\t\t\t\tif (n!=0 || a!=0 || b!=0 || c!=0) {\n\t\t\t\t\t\t\t\t\tMatrix4d mJCryst = new Matrix4d(ops[n]);\n\t\t\t\t\t\t\t\t\ttranslate(mJCryst, transOrth);\n\t\t\t\t\t\t\t\t\tchainj = (Chain)chainj.clone();\n\t\t\t\t\t\t\t\t\tCalc.transform(chainj,mJCryst);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tStructureInterface interf = calcContacts(chaini, chainj, cutoff, tt, builder);\n\t\t\t\t\t\t\t\tif (interf == null) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcontactsFound++;\n\t\t\t\t\t\t\t\tif(this.hasNcsOps()) {\n\t\t\t\t\t\t\t\t\tStructureInterface interfNcsRef = findNcsRef(interf);\n\t\t\t\t\t\t\t\t\tset.addNcsEquivalent(interf,interfNcsRef);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tset.add(interf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif( verbose ) {\n\t\t\t\t\t\t\tif (a==0 && b==0 && c==0 && n==0)\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+(numPolyChainsAu*(numPolyChainsAu-1))/2+\")\");\n\t\t\t\t\t\t\telse if (selfEquivalent)\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+(numPolyChainsAu*(numPolyChainsAu+1))/2+\")\");\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tbuilder.append(\" \"+contactsFound+\"(\"+numPolyChainsAu*numPolyChainsAu+\")\");\n\n\t\t\t\t\t\t\tlogger.debug(builder.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tend = System.currentTimeMillis();\n\t\tlogger.debug(\"\\n\"+trialCount+\" chain-chain clash trials done. Time \"+(end-start)/1000+\"s\");\n\t\tlogger.debug(\"  skipped (not overlapping AUs)       : \"+skippedAUsNoOverlap);\n\t\tlogger.debug(\"  skipped (not overlapping chains)    : \"+skippedChainsNoOverlap);\n\t\tlogger.debug(\"  skipped (sym redundant op pairs)    : \"+skippedRedundant);\n\t\tlogger.debug(\"  skipped (sym redundant self op)     : \"+skippedSelfEquivalent);\n\t\tlogger.debug(\"Found \"+set.size()+\" interfaces.\");\n\t}\n\n\n\t/**\n\t * Checks whether given interface is NCS-redundant, i.e., an identical interface between NCS copies of\n\t * these molecules has already been seen, and returns this (reference) interface.\n\t *\n\t * @param interf\n\t *          StructureInterface\n\t * @return  already seen interface that is NCS-equivalent to interf,\n\t *          null if such interface is not found.\n\t */\n\tprivate StructureInterface findNcsRef(StructureInterface interf) {\n\t\tif (!this.hasNcsOps()) {\n\t\t\treturn null;\n\t\t}\n\t\tString chainIName = interf.getMoleculeIds().getFirst();\n\t\tString iOrigName = chainOrigNames.get(chainIName);\n\n\t\tString chainJName = interf.getMoleculeIds().getSecond();\n\t\tString jOrigName = chainOrigNames.get(chainJName);\n\n\t\tMatrix4d mJCryst;\n\t\tif(this.searchBeyondAU) {\n\t\t\tmJCryst = interf.getTransforms().getSecond().getMatTransform();\n\t\t\tmJCryst = crystallographicInfo.getCrystalCell().transfToOrthonormal(mJCryst);\n\t\t} else {\n\t\t\tmJCryst = IDENTITY;\n\t\t}\n\n\t\t// Let X1,...Xn be the original coords, before NCS transforms (M1...Mk)\n\t\t// current chain i: M_i * X_i\n\t\t// current chain j: Cn * M_j * X_j\n\n\t\t// transformation to bring chain j near X_i: M_i^(-1) * Cn * M_j\n\t\t// transformation to bring chain i near X_j: (Cn * M_j)^(-1) * M_i = (M_i^(-1) * Cn * M_j)^(-1)\n\n\t\tif(chainNcsOps.get(chainIName) == null)\n\t\t\treturn null;\n\t\tMatrix4d mChainIInv = new Matrix4d(chainNcsOps.get(chainIName));\n\t\tmChainIInv.invert();\n\n\t\tMatrix4d mJNcs = new Matrix4d(chainNcsOps.get(chainJName));\n\n\t\tMatrix4d j2iNcsOrigin = new Matrix4d(mChainIInv);\n\t\tj2iNcsOrigin.mul(mJCryst);\n\t\t//overall transformation to bring current chainj from its NCS origin to i's\n\t\tj2iNcsOrigin.mul(mJNcs);\n\n\t\t//overall transformation to bring current chaini from its NCS origin to j's\n\t\tMatrix4d i2jNcsOrigin = new Matrix4d(j2iNcsOrigin);\n\t\ti2jNcsOrigin.invert();\n\n\t\tString matchChainIdsIJ = iOrigName + jOrigName;\n\t\tString matchChainIdsJI = jOrigName + iOrigName;\n\n\t\t// same original chain names\n\t\tOptional<Matrix4d> matchDirect =\n\t\t\t\tvisitedNcsChainPairs.computeIfAbsent(matchChainIdsIJ, k-> new HashMap<>()).entrySet().stream().\n\t\t\t\t\tmap(r->r.getKey()).\n\t\t\t\t\tfilter(r->r.epsilonEquals(j2iNcsOrigin,0.01)).\n\t\t\t\t\tfindFirst();\n\n\t\tMatrix4d matchMatrix = matchDirect.orElse(null);\n\t\tString matchChainIds = matchChainIdsIJ;\n\n\t\tif(matchMatrix == null) {\n\t\t\t// reversed original chain names with inverted transform\n\t\t\tOptional<Matrix4d> matchInverse =\n\t\t\t\t\tvisitedNcsChainPairs.computeIfAbsent(matchChainIdsJI, k-> new HashMap<>()).entrySet().stream().\n\t\t\t\t\tmap(r->r.getKey()).\n\t\t\t\t\tfilter(r->r.epsilonEquals(i2jNcsOrigin,0.01)).\n\t\t\t\t\tfindFirst();\n\t\t\tmatchMatrix = matchInverse.orElse(null);\n\t\t\tmatchChainIds = matchChainIdsJI;\n\t\t}\n\n\t\tStructureInterface matchInterface = null;\n\n\t\tif (matchMatrix == null) {\n\t\t\tvisitedNcsChainPairs.get(matchChainIdsIJ).put(j2iNcsOrigin,interf);\n\t\t} else {\n\t\t\tmatchInterface = visitedNcsChainPairs.get(matchChainIds).get(matchMatrix);\n\t\t}\n\n\t\treturn matchInterface;\n\t}\n\n\tprivate StructureInterface calcContacts(Chain chaini, Chain chainj, double cutoff, CrystalTransform tt, StringBuilder builder) {\n\t\t// note that we don't consider hydrogens when calculating contacts\n\t\tAtomContactSet graph = StructureTools.getAtomsInContact(chaini, chainj, cutoff, INCLUDE_HETATOMS);\n\n\t\tif (graph.size()>0) {\n\t\t\tif (builder != null) builder.append(\"x\");\n\n\t\t\tCrystalTransform transf = new CrystalTransform(this.crystallographicInfo.getSpaceGroup());\n\t\t\tStructureInterface interf = new StructureInterface(\n\t\t\t\t\tStructureTools.getAllAtomArray(chaini), StructureTools.getAllAtomArray(chainj),\n\t\t\t\t\tchaini.getName(), chainj.getName(),\n\t\t\t\t\tgraph,\n\t\t\t\t\ttransf, tt);\n\n\t\t\treturn interf;\n\n\t\t} else {\n\t\t\tif (builder != null) builder.append(\"o\");\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate void addVisitedTransform(CrystalTransform tt) {\n\t\tvisitedCrystalTransforms.add(tt);\n\t}\n\n\t/**\n\t * Checks whether given transformId/translation is symmetry redundant\n\t * Two transformations are symmetry redundant if their matrices (4d) multiplication gives the identity, i.e.\n\t * if one is the inverse of the other.\n\t * @param tt\n\t * @return\n\t */\n\tprivate boolean isRedundantTransform(CrystalTransform tt) {\n\n\t\tIterator<CrystalTransform> it = visitedCrystalTransforms.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tCrystalTransform v = it.next();\n\n\t\t\tif (tt.isEquivalent(v)) {\n\n\t\t\t\tlogger.debug(\"Skipping redundant transformation: \"+tt+\", equivalent to \"+v);\n\n\t\t\t\t// there's only 1 possible equivalent partner for each visited matrix\n\t\t\t\t// (since the equivalent is its inverse matrix and the inverse matrix is unique)\n\t\t\t\t// thus once the partner has been seen, we don't need to check it ever again\n\t\t\t\tit.remove();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic void translate(Matrix4d m, Vector3d translation) {\n\t\tm.m03 = m.m03+translation.x;\n\t\tm.m13 = m.m13+translation.y;\n\t\tm.m23 = m.m23+translation.z;\n\t}\n\n\t/**\n\t * Apply the NCS operators in the given Structure adding new chains as needed.\n\t * All chains are (re)assigned ids of the form: original_chain_id+ncs_operator_index+\"n\".\n\t * @param structure\n\t *          the structure to expand\n\t * @param chainOrigNames\n\t *          new chain names mapped to the original chain names\n\t * @param chainNcsOps\n\t *          new chain names mapped to the ncs operators that was used to generate them\n\t */\n\tpublic static void expandNcsOps(Structure structure, Map<String,String> chainOrigNames, Map<String,Matrix4d> chainNcsOps) {\n\t\tPDBCrystallographicInfo xtalInfo = structure.getCrystallographicInfo();\n\t\tif (xtalInfo ==null) return;\n\n\t\tif (xtalInfo.getNcsOperators()==null || xtalInfo.getNcsOperators().length==0)\n\t\t\treturn;\n\n\t\tList<Chain> chainsToAdd = new ArrayList<>();\n\n\t\tMatrix4d identity = new Matrix4d();\n\t\tidentity.setIdentity();\n\n\t\tMatrix4d[] ncsOps = xtalInfo.getNcsOperators();\n\n\t\tfor (Chain c:structure.getChains()) {\n\t\t\tString cOrigId = c.getId();\n\t\t\tString cOrigName = c.getName();\n\n\t\t\tfor (int iOperator = 0; iOperator < ncsOps.length; iOperator++) {\n\t\t\t\tMatrix4d m = ncsOps[iOperator];\n\n\t\t\t\tChain clonedChain = (Chain)c.clone();\n\t\t\t\tString newChainId = cOrigId+(iOperator+1)+\"n\";\n\t\t\t\tString newChainName = cOrigName+(iOperator+1)+\"n\";\n\t\t\t\tclonedChain.setId(newChainId);\n\t\t\t\tclonedChain.setName(newChainName);\n\n\t\t\t\tsetChainIdsInResidueNumbers(clonedChain, newChainName);\n\t\t\t\tCalc.transform(clonedChain, m);\n\n\t\t\t\tchainsToAdd.add(clonedChain);\n\t\t\t\tc.getEntityInfo().addChain(clonedChain);\n\n\t\t\t\tchainOrigNames.put(newChainName,cOrigName);\n\t\t\t\tchainNcsOps.put(newChainName,m);\n\t\t\t}\n\n\t\t\tchainNcsOps.put(cOrigName,identity);\n\t\t\tchainOrigNames.put(cOrigName,cOrigName);\n\t\t}\n\n\t\tchainsToAdd.forEach(structure::addChain);\n\t}\n\n\t/**\n\t * Auxiliary method to reset chain ids of residue numbers in a chain.\n\t * Used when cloning chains and resetting their ids: one needs to take care of\n\t * resetting the ids within residue numbers too.\n\t * @param c\n\t * @param newChainName\n\t */\n\tprivate static void setChainIdsInResidueNumbers(Chain c, String newChainName) {\n\t\tfor (Group g:c.getAtomGroups()) {\n\t\t\tg.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n\t\t}\n\t\tfor (Group g:c.getSeqResGroups()) {\n\t\t\tif (g.getResidueNumber()==null) continue;\n\t\t\tg.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n\t\t}\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.test.xtal;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.contact.StructureInterfaceList;\nimport org.biojava.nbio.structure.xtal.CrystalBuilder;\nimport org.junit.Test;\n\nimport javax.vecmath.Matrix4d;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.*;\n\npublic class TestCrystalBuilder {\n\n\t@Test\n\tpublic void test1NMR() throws IOException, StructureException {\n\n\t\t// a monomer NMR entry: must have no interfaces\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"1NMR\");\n\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(0,interfaces.size());\n\n\t}\n\n\t@Test\n\tpublic void test1B8G() throws IOException, StructureException {\n\n\t\t// a crystallographic entry: several interfaces\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"1B8G\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(8,interfaces.size());\n\n\n\t}\n\n\t@Test\n\tpublic void test2MFZ() throws IOException, StructureException {\n\n\t\t// a dimer NMR entry: must have 1 interface\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"2MFZ\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(1,interfaces.size());\n\n\t}\n\n\t@Test\n\tpublic void test4MF8() throws IOException, StructureException {\n\n\t\t// a crystallographic structure with protein+DNA: has only 3 prot-prot interfaces the rest are DNA-involving ones\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"4MF8\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(17,interfaces.size());\n\n\t}\n\n\t@Test\n\tpublic void test1AUY() throws IOException, StructureException {\n\t\t// a virus with NCS operators\n\t\tAtomCache cache = new AtomCache();\n\t\tStructureIO.setAtomCache(cache);\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"1AUY\");\n\n\t\tMap<String,Matrix4d> chainNcsOps = new HashMap<>();\n\t\tMap<String,String> chainOrigNames = new HashMap<>();\n\n\t\tCrystalBuilder.expandNcsOps(s1,chainOrigNames,chainNcsOps);\n\n\t\tCrystalBuilder cb = new CrystalBuilder(s1,chainOrigNames,chainNcsOps);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(186,interfaces.size());\n\t\tassertEquals(24,interfaces.getClustersNcs().size());\n\n\t\t// kill the cell info to simulate incorrect and/or missing\n\t\ts1.getCrystallographicInfo().setCrystalCell(null);\n\t\tcb = new CrystalBuilder(s1,chainOrigNames,chainNcsOps);\n\t\tinterfaces = cb.getUniqueInterfaces(5.5);\n\t\t//only interfaces within AU\n\t\tassertEquals(132,interfaces.size());\n\t\tassertEquals(12,interfaces.getClustersNcs().size());\n\t}\n\n\t@Test\n\tpublic void test1A37() throws IOException, StructureException {\n\t\t// a smaller structure with NCS operators\n\t\tAtomCache cache = new AtomCache();\n\t\tStructureIO.setAtomCache(cache);\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"1A37\");\n\n\t\tMap<String,Matrix4d> chainNcsOps = new HashMap<>();\n\t\tMap<String,String> chainOrigNames = new HashMap<>();\n\t\tCrystalBuilder.expandNcsOps(s1,chainOrigNames,chainNcsOps);\n\n\t\tCrystalBuilder cb = new CrystalBuilder(s1,chainOrigNames,chainNcsOps);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(17,interfaces.size());\n\t\tassertEquals(14,interfaces.getClustersNcs().size());\n\t}\n\n\t@Test\n\tpublic void test2H2Z() throws IOException, StructureException {\n\n\t\t// a crystallographic structure C 1 2 1.\n\t\t// Should have a minimum number of contacts of 3, from the C number given in:\n\t\t// Wukowitz & Yeates, Nature Structural Biology, 1995\n\t\t// the molecule happens to be placed quite far from the origin, so this tests if we really capture all contacts\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"2H2Z\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertEquals(3,interfaces.size());\n\n\t}\n\t\n\t@Test\n\tpublic void test4HHB() throws IOException, StructureException {\n\n\t\t// 4hhb is a very old entry with a non-standard coordinate frame convention, we should calculate only AU contacts\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\n\t\tStructureIO.setAtomCache(cache);\n\n\t\tcache.setUseMmCif(true);\n\t\tStructure s1 = StructureIO.getStructure(\"4HHB\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\t// 5 interfaces in the AU: the 4 of the tetramer + 1 cross-interface \n\t\tassertEquals(5, interfaces.size());\n\n\t}\n\n}\n","changedTest":"","commitMessage":"fixed confusion between chain name and chain id, original chains retain original names\n","test_commitMessage":"","allZero":false}