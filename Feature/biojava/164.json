{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/routines/AlignerHelper.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/routines/AlignerHelperTest.java","prod_time":"2015-01-20 20:01:34","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"45235c07b7f2d056274565a021b86d3ee2c5f76c","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on August 13, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment.routines;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence.Step;\n//import org.slf4j.Logger;\n//import org.slf4j.LoggerFactory;\n\n\n/**\n * Static utility to construct alignment routines from a common library of methods.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n */\npublic class AlignerHelper {\n\n\t//private static final Logger logger = LoggerFactory.getLogger(AlignerHelper.class);\n\t\n    // types\n\n    /**\n     * Defines a traceback pointer for the three edit operations: substitution (match/replacement of a query compound\n     * with a target compound), deletion (removal of a query compound leaving a gap in the target sequence), and\n     * insertion (addition of a target compound opening a gap in the query sequence).\n     */\n    public enum Last {\n        SUBSTITUTION,\n        DELETION,\n        INSERTION\n    }\n\n    /**\n     * Defines a 'cut' row for divide-and-conquer alignment in which a new anchor is found.\n     */\n    public static class Cut {\n\n        private int queryIndex;\n        private int[][] targetIndices, tiLast, ti1, ti2;\n\n        public Cut(int queryIndex, int[] dim) {\n            this.queryIndex = queryIndex;\n            targetIndices = ti1 = new int[dim[1]][dim[2]];\n            ti2 = new int[dim[1]][dim[2]];\n        }\n\n        public int getQueryIndex() {\n            return queryIndex;\n        }\n\n        public int getTargetIndex(int z) {\n            return targetIndices[targetIndices.length - 1][z];\n        }\n\n        public void update(int x, Subproblem subproblem, Last[][] pointers) {\n            if (pointers[subproblem.getTargetStartIndex()].length == 1) {\n                if (queryIndex == x - 1) {\n                    updateLinearInitial(subproblem, pointers);\n                } else if (queryIndex < x) {\n                    updateLinearAdvance(subproblem, pointers);\n                }\n            } else {\n                if (queryIndex == x - 1) {\n                    updateInitial(subproblem, pointers);\n                } else if (queryIndex < x) {\n                    updateAdvance(subproblem, pointers);\n                }\n            }\n        }\n\n        private void updateAdvance(Subproblem subproblem, Last[][] pointers) {\n            tiLast = targetIndices;\n            targetIndices = (targetIndices == ti2) ? ti1 : ti2;\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    targetIndices[y][0] = tiLast[y - 1][pointers[y][0].ordinal()];\n                }\n                if (pointers[y][1] != null) {\n                    targetIndices[y][1] = tiLast[y][pointers[y][1].ordinal()];\n                }\n                if (pointers[y][2] != null) {\n                    targetIndices[y][2] = targetIndices[y - 1][pointers[y][2].ordinal()];\n                }\n            }\n        }\n\n        private void updateInitial(Subproblem subproblem, Last[][] pointers) {\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    targetIndices[y][0] = y - 1;\n                }\n                if (pointers[y][1] != null) {\n                    targetIndices[y][1] = y;\n                }\n                if (pointers[y][2] != null) {\n                    targetIndices[y][2] = targetIndices[y - 1][2];\n                }\n            }\n        }\n\n        private void updateLinearAdvance(Subproblem subproblem, Last[][] pointers) {\n            tiLast = targetIndices;\n            targetIndices = (targetIndices == ti2) ? ti1 : ti2;\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                switch (pointers[y][0]) {\n                case DELETION:\n                    targetIndices[y][0] = tiLast[y][0];\n                    break;\n                case SUBSTITUTION:\n                    targetIndices[y][0] = tiLast[y - 1][0];\n                    break;\n                case INSERTION:\n                    targetIndices[y][0] = targetIndices[y - 1][0];\n                }\n            }\n        }\n\n        private void updateLinearInitial(Subproblem subproblem, Last[][] pointers) {\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    switch (pointers[y][0]) {\n                    case DELETION:\n                        targetIndices[y][0] = y;\n                        break;\n                    case SUBSTITUTION:\n                        targetIndices[y][0] = y - 1;\n                        break;\n                    case INSERTION:\n                        targetIndices[y][0] = targetIndices[y - 1][0];\n                    }\n                }\n            }\n        }\n\n    }\n    public static int addAnchors(Cut[] cuts, int[] scores, boolean addScore, int[] anchors) {\n        int zMax = 0, subscore = scores[0];\n        for (int z = 1; z < scores.length; z++) {\n            if (scores[z] > subscore) {\n                zMax = z;\n                subscore = scores[z];\n            }\n        }\n        for (Cut c : cuts) {\n            anchors[c.getQueryIndex()] = c.getTargetIndex(zMax);\n        }\n        return addScore ? (int) subscore : 0;\n    }\n\n    public static Cut[] getCuts(int k, Subproblem subproblem, int[] dim, boolean anchor0) {\n        Cut[] cuts;\n        int m = subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);\n        if (k < m) {\n            cuts = new Cut[k];\n            int firstCutIndex = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0);\n            for (int i = 0; i < k; i++) {            \t\n            \tcuts[i] = new Cut(firstCutIndex + i * (m - 1) / (k - 1), dim);\n            }\n        } else {\n            cuts = new Cut[m];\n            for (int i = 0, x = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {\n                cuts[i] = new Cut(x, dim);\n            }\n        }\n        return cuts;\n    }\n    /**\n     * Compounds in query and target sequences that must align\n     * @author Daniel Cameron\n     */\n    public static class Anchor {\n    \tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\t\tpublic int getTargetIndex() {\n\t\t\treturn targetIndex;\n\t\t}\n\t\tprivate final int queryIndex;\n    \tprivate final int targetIndex;\n    \tpublic Anchor(int queryIndex, int targetIndex) {\n    \t\tthis.queryIndex = queryIndex;\n    \t\tthis.targetIndex = targetIndex;\n    \t}\n    \tpublic static class QueryIndexComparator implements Comparator<Anchor> {\n\t\t\t@Override\n\t\t\tpublic int compare(Anchor o1, Anchor o2) {\n\t\t\t\treturn o1.getQueryIndex() - o2.getQueryIndex();\n\t\t\t}\n    \t}\n    }\n    /**\n     * Alignment subproblem. The bounds of the subproblem are the\n     * indicies representing the inclusive bounds of the dynamic programming\n     * alignment problem.\n     * @author Daniel Cameron\n     */\n    public static class Subproblem {\n    \tpublic int getTargetStartIndex() {\n\t\t\treturn targetStartIndex;\n\t\t}\n\t\tpublic int getQueryEndIndex() {\n\t\t\treturn queryEndIndex;\n\t\t}\n\t\tpublic int getTargetEndIndex() {\n\t\t\treturn targetEndIndex;\n\t\t}\n\t\tpublic int getQueryStartIndex() {\n\t\t\treturn queryStartIndex;\n\t\t}\n\t\t/**\n\t\t * Indicates whether the start query and start target index compounds\n\t\t * are anchored to each other\n\t\t * @return true if the compounds are anchored in the alignment, false otherwise\n\t\t */\n\t\tpublic boolean isStartAnchored() {\n\t\t\treturn isAnchored;\n\t\t}\n\t\tprivate int queryStartIndex; // [0]\n    \tprivate int targetStartIndex; // [1]\n    \tprivate int queryEndIndex; // [2]\n    \tprivate int targetEndIndex; // [3]\n    \tprivate boolean isAnchored;\n    \tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex) {\n    \t\tthis(queryStartIndex, targetStartIndex, queryEndIndex, targetEndIndex, false);\n    \t}\n    \tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex, boolean isAnchored) {\n    \t\tthis.queryStartIndex = queryStartIndex;\n    \t\tthis.targetStartIndex = targetStartIndex;\n    \t\tthis.queryEndIndex = queryEndIndex;\n    \t\tthis.targetEndIndex = targetEndIndex;\n    \t\tthis.isAnchored = isAnchored;\n    \t}\n    \t/**\n    \t * Converts a list of anchors into a subproblem list.\n    \t * @param anchors anchored read pairs\n    \t * @param querySequenceLength length of query sequence\n    \t * @param targetSequenceLength length of target sequence\n    \t * @return list alignment subproblems\n    \t */\n    \tpublic static List<Subproblem> getSubproblems(List<Anchor> anchors, int querySequenceLength, int targetSequenceLength) {\n    \t\tCollections.sort(anchors, new Anchor.QueryIndexComparator());\n    \t\tList<Subproblem> list = new ArrayList<Subproblem>();\n    \t\tAnchor last = new Anchor(-1, -1); // sentinal anchor\n    \t\tboolean isAnchored = false;\n    \t\tfor (int i = 0; i < anchors.size(); i++) {\n    \t\t\tif (anchors.get(i).targetIndex <= last.targetIndex ||\n\t\t\t\t\tanchors.get(i).queryIndex <= last.queryIndex) {\n    \t\t\t\tthrow new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n    \t\t\t}\n    \t\t\tlist.add(new Subproblem(\n    \t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\t\tanchors.get(i).queryIndex,\n\t\t\t\t\t\tanchors.get(i).targetIndex,\n\t\t\t\t\t\tisAnchored));\n    \t\t\tlast = anchors.get(i);\n    \t\t\tisAnchored = true;\n    \t\t}\n    \t\tlist.add(new Subproblem(\n    \t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\tquerySequenceLength,\n\t\t\t\t\ttargetSequenceLength,\n\t\t\t\t\tisAnchored));\n    \t\treturn list;\n    \t}\n    }\n    // updates cut rows given the latest row of traceback pointers\n    public static void setCuts(int x, Subproblem subproblem, Last[][] pointers, Cut[]cuts) {\n        for (Cut c : cuts) {\n            c.update(x, subproblem, pointers);\n        }\n    }\n    /**\n     * Calculates the optimal alignment score for the given sequence positions with an affine or constant gap penalty\n     * @param x position in query\n     * @param y position in target\n     * @param gop gap opening penalty\n     * @param gep gap extension penalty\n     * @param sub compound match score\n     * @param scores dynamic programming score matrix to fill at the given position\n     * @return traceback direction for substitution, deletion and insertion\n     */\n    public static Last[] setScorePoint(int x, int y, int gop, int gep, int sub, int[][][] scores) {\n        Last[] pointers = new Last[3];\n\n        // substitution\n        if (scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][0] && scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][2]) {\n            scores[x][y][0] = (int) (scores[x - 1][y - 1][1] + sub);\n            pointers[0] = Last.DELETION;\n        } else if (scores[x - 1][y - 1][0] >= scores[x - 1][y - 1][2]) {\n            scores[x][y][0] = (int) (scores[x - 1][y - 1][0] + sub);\n            pointers[0] = Last.SUBSTITUTION;\n        } else {\n            scores[x][y][0] = (int) (scores[x - 1][y - 1][2] + sub);\n            pointers[0] = Last.INSERTION;\n        }\n\n        // deletion\n        if (scores[x - 1][y][1] >= scores[x - 1][y][0] + gop) {\n            scores[x][y][1] = (int) (scores[x - 1][y][1] + gep);\n            pointers[1] = Last.DELETION;\n        } else {\n            scores[x][y][1] = (int) (scores[x - 1][y][0] + gop + gep);\n            pointers[1] = Last.SUBSTITUTION;\n        }\n\n        // insertion\n        if (scores[x][y - 1][0] + gop >= scores[x][y - 1][2]) {\n            scores[x][y][2] = (int) (scores[x][y - 1][0] + gop + gep);\n            pointers[2] = Last.SUBSTITUTION;\n        } else {\n            scores[x][y][2] = (int) (scores[x][y - 1][2] + gep);\n            pointers[2] = Last.INSERTION;\n        }\n\n        return pointers;\n    }\n    /**\n     * Calculates the optimal alignment score for the given sequence positions and a linear gap penalty\n     * @param x position in query\n     * @param y position in target\n     * @param gep gap extension penalty\n     * @param sub compound match score\n     * @param scores dynamic programming score matrix to fill at the given position\n     * @return traceback directions for substitution, deletion and insertion respectively\n     */\n    public static Last setScorePoint(int x, int y, int gep, int sub, int[][][] scores) {\n        int d = scores[x - 1][y][0] + gep;\n        int i = scores[x][y - 1][0] + gep;\n        int s = scores[x - 1][y - 1][0] + sub;\n        if (d >= s && d >= i) {\n            scores[x][y][0] = (int) d;\n            return Last.DELETION;\n        } else if (s >= i) {\n            scores[x][y][0] = (int) s;\n            return Last.SUBSTITUTION;\n        } else {\n            scores[x][y][0] = (int) i;\n            return Last.INSERTION;\n        }\n    }\n\n    // scores global alignment for a given position in the query sequence\n    public static Last[][] setScoreVector(int x, Subproblem subproblem, int gop, int gep, int[] subs, boolean storing,\n            int[][][] scores) {\n        return setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gop, gep, subs, storing, scores, subproblem.isStartAnchored());\n    }\n\n    // scores global alignment for a given position in the query sequence\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n            boolean storing, int[][][] scores, boolean startAnchored) {\n        Last[][] pointers = new Last[ye + 1][];\n        int min = Integer.MIN_VALUE - gop - gep;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            scores[xb][yb][1] = scores[xb][yb][2] = gop;\n            pointers[yb] = new Last[] {null, null, null};\n            if (startAnchored) {\n        \t\tassert (xb > 0 && yb > 0);\n        \t\tint subproblemStartingScore = (int) (scores[xb - 1][yb - 1][0] + subs[yb]);\n        \t\tscores[xb][yb][0] = (int) (subproblemStartingScore);\n        \t\tscores[xb][yb][1] = (int) (subproblemStartingScore + gop);\n        \t\tscores[xb][yb][2] = (int) (subproblemStartingScore + gop);\n        \t\tpointers[yb] = new Last[] {Last.SUBSTITUTION, Last.SUBSTITUTION, Last.SUBSTITUTION};\n        \t}\n            Last[] insertion = new Last[] { null, null, Last.INSERTION };\n            for (int y = yb + 1; y <= ye; y++) {\n                scores[xb][y][0] = scores[xb][y][1] = min;\n                scores[xb][y][2] = (int) (scores[xb][y - 1][2] + gep);\n                pointers[y] = insertion;\n            }\n        } else {\n            scores[x][yb][0] = scores[x][yb][2] = min;\n            scores[x][yb][1] = (int) (scores[x - 1][yb][1] + gep);\n            pointers[yb] = new Last[] { null, Last.DELETION, null };\n            for (int y = yb + 1; y <= ye; y++) {\n                pointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n            }\n        }\n        return pointers;\n    }\n\n    // scores global alignment for a given position in the query sequence for a linear gap penalty\n    public static Last[][] setScoreVector(int x, Subproblem subproblem, int gep, int[] subs, boolean storing,\n            int[][][] scores) {\n        return setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gep, subs, storing, scores, subproblem.isStartAnchored());\n    }\n\n    // scores global alignment for a given position in the query sequence for a linear gap penalty\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n            int[][][] scores, boolean startAnchored) {\n        Last[][] pointers = new Last[ye + 1][1];\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n        \tif (startAnchored) {\n        \t\tassert (xb > 0 && yb > 0);\n        \t\tscores[xb][yb][0] = (int) (scores[xb - 1][yb - 1][0] + subs[yb]);\n        \t\tpointers[yb][0] = Last.SUBSTITUTION;\n        \t}\n            for (int y = yb + 1; y <= ye; y++) {\n                scores[xb][y][0] = (int) (scores[xb][y - 1][0] + gep);\n                pointers[y][0] = Last.INSERTION;\n            }\n        } else {\n            scores[x][yb][0] = (int) (scores[x - 1][yb][0] + gep);\n            pointers[yb][0] = Last.DELETION;\n            for (int y = yb + 1; y <= ye; y++) {\n                pointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n            }\n        }\n        return pointers;\n    }\n\n    // scores local alignment for a given position in the query sequence\n    public static Last[][] setScoreVector(int x, int gop, int gep, int[] subs, boolean storing,\n            int[][][] scores, int[] xyMax, int score) {\n        return setScoreVector(x, 0, 0, scores[0].length - 1, gop, gep, subs, storing, scores, xyMax, score);\n    }\n\n    // scores local alignment for a given position in the query sequence\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n            boolean storing, int[][][] scores, int[] xyMax, int score) {\n        Last[][] pointers;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            pointers = new Last[ye + 1][scores[0][0].length];\n        } else {\n            pointers = new Last[ye + 1][];\n            pointers[0] = new Last[scores[0][0].length];   \n            for (int y = 1; y < scores[0].length; y++) {\n                pointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n                for (int z = 0; z < scores[0][0].length; z++) {\n                    if (scores[x][y][z] <= 0) {\n                        scores[x][y][z] = 0;\n                        pointers[y][z] = null;\n                    }\n                }\n                if (scores[x][y][0] > score) {\n                    xyMax[0] = x;\n                    xyMax[1] = y;\n                    score = scores[x][y][0];\n                }\n            }\n        }\n        return pointers;\n    }\n    \n    // scores local alignment for a given position in the query sequence for a linear gap penalty\n    public static Last[][] setScoreVector(int x, int gep, int[] subs, boolean storing, int[][][] scores,\n            int[] xyMax, int score) {\n        return setScoreVector(x, 0, 0, scores[0].length - 1, gep, subs, storing, scores, xyMax, score);\n    }\n\n    // scores local alignment for a given position in the query sequence for a linear gap penalty\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n            int[][][] scores, int[] xyMax, int score) {\n        Last[][] pointers;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            pointers = new Last[ye + 1][1];\n        } else {\n            pointers = new Last[ye + 1][];\n            pointers[0] = new Last[1];\n            for (int y = 1; y < scores[x].length; y++) {\n                pointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n                if (scores[x][y][0] <= 0) {\n                    scores[x][y][0] = 0;\n                    pointers[y][0] = null;\n                } else if (scores[x][y][0] > score) {\n                    xyMax[0] = x;\n                    xyMax[1] = y;\n                    score = scores[x][y][0];\n                }\n            }\n        }\n        return pointers;\n    }\n    private static void ensureScoringMatrixColumn(int x, boolean storingFullMatrix, int[][][] scores) {\n    \tif (!storingFullMatrix && x > 1) {\n            scores[x] = scores[x - 2];\n        }\n    }\n    \n    // finds alignment path through traceback matrix\n    public static int[] setSteps(Last[][][] traceback, boolean local, int[] xyMax, Last last, List<Step> sx,\n            List<Step> sy) {\n        int x = xyMax[0], y = xyMax[1];\n        boolean linear = (traceback[x][y].length == 1);\n        while (local ? (linear ? last : traceback[x][y][last.ordinal()]) != null : x > 0 || y > 0) {\n            switch (last) {\n            case DELETION:\n                sx.add(Step.COMPOUND);\n                sy.add(Step.GAP);\n                last = linear ? traceback[--x][y][0] : traceback[x--][y][1];\n                break;\n            case SUBSTITUTION:\n                sx.add(Step.COMPOUND);\n                sy.add(Step.COMPOUND);\n                last = linear ? traceback[--x][--y][0] : traceback[x--][y--][0];\n                break;\n            case INSERTION:\n                sx.add(Step.GAP);\n                sy.add(Step.COMPOUND);\n                last = linear ? traceback[x][--y][0] : traceback[x][y--][2];\n            }\n        }\n        Collections.reverse(sx);\n        Collections.reverse(sy);\n        return new int[] {x, y};\n    }\n\n    // finds global alignment path through traceback matrix\n    public static int[] setSteps(Last[][][] traceback, int[][][] scores, List<Step> sx, List<Step> sy) {\n        int xMax = scores.length - 1, yMax = scores[xMax].length - 1;\n        boolean linear = (traceback[xMax][yMax].length == 1);\n        \n        Last last = \n        \t\t\n        \tlinear ? \n        \t\ttraceback[xMax][yMax][0] : \n        \t\t\t\n        \t\t(scores[xMax][yMax][1] > scores[xMax][yMax][0] &&\n        \t\t scores[xMax][yMax][1] > scores[xMax][yMax][2] ) ? \n        \t\t\t\t\t\t\n        \t\t\t\tLast.DELETION : \n        \t\t\t\t\t(scores[xMax][yMax][0] > scores[xMax][yMax][2]) ? \n        \t\t\t\t\t\t\tLast.SUBSTITUTION : \n        \t\t\t\t\t\t\tLast.INSERTION;\n        \n        \t\t\n        return setSteps(traceback, false, new int[] {xMax, yMax}, last, sx, sy);\n    }\n\n    // finds local alignment path through traceback matrix\n    public static int[] setSteps(Last[][][] traceback, int[] xyMax, List<Step> sx, List<Step> sy) {\n        return setSteps(traceback, true, xyMax, Last.SUBSTITUTION, sx, sy);\n    }\n    \n    public static String tracebackToString(Last[][][] traceback) {\n    \tStringBuilder sb = new StringBuilder();\n    \tfor (int z = 0; z < 3; z++) {\n    \t\tfor (int i = 0; i < traceback.length; i++) {\n    \t\t\tif (traceback[i] != null) {\n\t    \t\t\tfor (int j = 0; j < traceback[i].length; j++) {\n\t    \t\t\t\tif (traceback[i][j] == null || z >= traceback[i][j].length || traceback[i][j][z] == null) {\n\t    \t\t\t\t\tsb.append('.');\n\t    \t\t\t\t} else {\n\t\t    \t\t\t\tswitch (traceback[i][j][z]) {\n\t\t    \t            case DELETION:\n\t\t    \t            \tsb.append('^');\n\t\t    \t            \tbreak;\n\t\t    \t            case SUBSTITUTION:\n\t\t    \t            \tsb.append('\\\\');\n\t\t    \t                break;\n\t\t    \t            case INSERTION:\n\t\t    \t            \tsb.append('<');\n\t\t    \t            \tbreak;\n\t\t    \t            }\n\t    \t\t\t\t}\n\t    \t\t\t}\n    \t\t\t}\n    \t\t\tsb.append('\\n');\n    \t\t}\n    \t\tsb.append(\"\\n\\n\");\n    \t}\n    \treturn sb.toString();\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on August 13, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment.routines;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence.Step;\n//import org.slf4j.Logger;\n//import org.slf4j.LoggerFactory;\n\n\n/**\n * Static utility to construct alignment routines from a common library of methods.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n */\npublic class AlignerHelper {\n\n\t//private static final Logger logger = LoggerFactory.getLogger(AlignerHelper.class);\n\t\n    // types\n\n    /**\n     * Define a traceback pointer for the three edit operations: substitution (match/replacement of a query compound\n     * with a target compound), deletion (removal of a query compound leaving a gap in the target sequence), and\n     * insertion (addition of a target compound opening a gap in the query sequence).\n     */\n    public enum Last {\n        SUBSTITUTION,\n        DELETION,\n        INSERTION\n    }\n\n    /**\n     * Defines a 'cut' row for divide-and-conquer alignment in which a new anchor is found.\n     */\n    public static class Cut {\n\n        private int queryIndex;\n        private int[][] targetIndices, tiLast, ti1, ti2;\n\n        public Cut(int queryIndex, int[] dim) {\n            this.queryIndex = queryIndex;\n            targetIndices = ti1 = new int[dim[1]][dim[2]];\n            ti2 = new int[dim[1]][dim[2]];\n        }\n\n        public int getQueryIndex() {\n            return queryIndex;\n        }\n\n        public int getTargetIndex(int z) {\n            return targetIndices[targetIndices.length - 1][z];\n        }\n\n        public void update(int x, Subproblem subproblem, Last[][] pointers) {\n            if (pointers[subproblem.getTargetStartIndex()].length == 1) {\n                if (queryIndex == x - 1) {\n                    updateLinearInitial(subproblem, pointers);\n                } else if (queryIndex < x) {\n                    updateLinearAdvance(subproblem, pointers);\n                }\n            } else {\n                if (queryIndex == x - 1) {\n                    updateInitial(subproblem, pointers);\n                } else if (queryIndex < x) {\n                    updateAdvance(subproblem, pointers);\n                }\n            }\n        }\n\n        private void updateAdvance(Subproblem subproblem, Last[][] pointers) {\n            tiLast = targetIndices;\n            targetIndices = (targetIndices == ti2) ? ti1 : ti2;\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    targetIndices[y][0] = tiLast[y - 1][pointers[y][0].ordinal()];\n                }\n                if (pointers[y][1] != null) {\n                    targetIndices[y][1] = tiLast[y][pointers[y][1].ordinal()];\n                }\n                if (pointers[y][2] != null) {\n                    targetIndices[y][2] = targetIndices[y - 1][pointers[y][2].ordinal()];\n                }\n            }\n        }\n\n        private void updateInitial(Subproblem subproblem, Last[][] pointers) {\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    targetIndices[y][0] = y - 1;\n                }\n                if (pointers[y][1] != null) {\n                    targetIndices[y][1] = y;\n                }\n                if (pointers[y][2] != null) {\n                    targetIndices[y][2] = targetIndices[y - 1][2];\n                }\n            }\n        }\n\n        private void updateLinearAdvance(Subproblem subproblem, Last[][] pointers) {\n            tiLast = targetIndices;\n            targetIndices = (targetIndices == ti2) ? ti1 : ti2;\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                switch (pointers[y][0]) {\n                case DELETION:\n                    targetIndices[y][0] = tiLast[y][0];\n                    break;\n                case SUBSTITUTION:\n                    targetIndices[y][0] = tiLast[y - 1][0];\n                    break;\n                case INSERTION:\n                    targetIndices[y][0] = targetIndices[y - 1][0];\n                }\n            }\n        }\n\n        private void updateLinearInitial(Subproblem subproblem, Last[][] pointers) {\n            for (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n                if (pointers[y][0] != null) {\n                    switch (pointers[y][0]) {\n                    case DELETION:\n                        targetIndices[y][0] = y;\n                        break;\n                    case SUBSTITUTION:\n                        targetIndices[y][0] = y - 1;\n                        break;\n                    case INSERTION:\n                        targetIndices[y][0] = targetIndices[y - 1][0];\n                    }\n                }\n            }\n        }\n\n    }\n    public static int addAnchors(Cut[] cuts, int[] scores, boolean addScore, int[] anchors) {\n        int zMax = 0, subscore = scores[0];\n        for (int z = 1; z < scores.length; z++) {\n            if (scores[z] > subscore) {\n                zMax = z;\n                subscore = scores[z];\n            }\n        }\n        for (Cut c : cuts) {\n            anchors[c.getQueryIndex()] = c.getTargetIndex(zMax);\n        }\n        return addScore ? (int) subscore : 0;\n    }\n\n    public static Cut[] getCuts(int k, Subproblem subproblem, int[] dim, boolean anchor0) {\n        Cut[] cuts;\n        int m = subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);\n        if (k < m) {\n            cuts = new Cut[k];\n            int firstCutIndex = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0);\n            for (int i = 0; i < k; i++) {            \t\n            \tcuts[i] = new Cut(firstCutIndex + i * (m - 1) / (k - 1), dim);\n            }\n        } else {\n            cuts = new Cut[m];\n            for (int i = 0, x = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {\n                cuts[i] = new Cut(x, dim);\n            }\n        }\n        return cuts;\n    }\n    /**\n     * Compounds in query and target sequences that must align\n     * @author Daniel Cameron\n     */\n    public static class Anchor {\n    \tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\t\tpublic int getTargetIndex() {\n\t\t\treturn targetIndex;\n\t\t}\n\t\tprivate final int queryIndex;\n    \tprivate final int targetIndex;\n    \tpublic Anchor(int queryIndex, int targetIndex) {\n    \t\tthis.queryIndex = queryIndex;\n    \t\tthis.targetIndex = targetIndex;\n    \t}\n    \tpublic static class QueryIndexComparator implements Comparator<Anchor> {\n\t\t\t@Override\n\t\t\tpublic int compare(Anchor o1, Anchor o2) {\n\t\t\t\treturn o1.getQueryIndex() - o2.getQueryIndex();\n\t\t\t}\n    \t}\n    }\n    /**\n     * Alignment subproblem. The bounds of the subproblem are the\n     * indicies representing the inclusive bounds of the dynamic programming\n     * alignment problem.\n     * @author Daniel Cameron\n     */\n    public static class Subproblem {\n    \tpublic int getTargetStartIndex() {\n\t\t\treturn targetStartIndex;\n\t\t}\n\t\tpublic int getQueryEndIndex() {\n\t\t\treturn queryEndIndex;\n\t\t}\n\t\tpublic int getTargetEndIndex() {\n\t\t\treturn targetEndIndex;\n\t\t}\n\t\tpublic int getQueryStartIndex() {\n\t\t\treturn queryStartIndex;\n\t\t}\n\t\t/**\n\t\t * Indicates whether the start query and start target index compounds\n\t\t * are anchored to each other\n\t\t * @return true if the compounds are anchored in the alignment, false otherwise\n\t\t */\n\t\tpublic boolean isStartAnchored() {\n\t\t\treturn isAnchored;\n\t\t}\n\t\tprivate int queryStartIndex; // [0]\n    \tprivate int targetStartIndex; // [1]\n    \tprivate int queryEndIndex; // [2]\n    \tprivate int targetEndIndex; // [3]\n    \tprivate boolean isAnchored;\n    \tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex) {\n    \t\tthis(queryStartIndex, targetStartIndex, queryEndIndex, targetEndIndex, false);\n    \t}\n    \tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex, boolean isAnchored) {\n    \t\tthis.queryStartIndex = queryStartIndex;\n    \t\tthis.targetStartIndex = targetStartIndex;\n    \t\tthis.queryEndIndex = queryEndIndex;\n    \t\tthis.targetEndIndex = targetEndIndex;\n    \t\tthis.isAnchored = isAnchored;\n    \t}\n    \t/**\n    \t * Convert a list of anchors into a subproblem list.\n    \t * @param anchors anchored read pairs\n    \t * @param querySequenceLength length of query sequence\n    \t * @param targetSequenceLength length of target sequence\n    \t * @return list alignment subproblems\n    \t */\n    \tpublic static List<Subproblem> getSubproblems(List<Anchor> anchors, int querySequenceLength, int targetSequenceLength) {\n    \t\tCollections.sort(anchors, new Anchor.QueryIndexComparator());\n    \t\tList<Subproblem> list = new ArrayList<Subproblem>();\n    \t\tAnchor last = new Anchor(-1, -1); // sentinal anchor\n    \t\tboolean isAnchored = false;\n    \t\tfor (int i = 0; i < anchors.size(); i++) {\n    \t\t\tif (anchors.get(i).targetIndex <= last.targetIndex ||\n\t\t\t\t\tanchors.get(i).queryIndex <= last.queryIndex) {\n    \t\t\t\tthrow new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n    \t\t\t}\n    \t\t\tlist.add(new Subproblem(\n    \t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\t\tanchors.get(i).queryIndex,\n\t\t\t\t\t\tanchors.get(i).targetIndex,\n\t\t\t\t\t\tisAnchored));\n    \t\t\tlast = anchors.get(i);\n    \t\t\tisAnchored = true;\n    \t\t}\n    \t\tlist.add(new Subproblem(\n    \t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\tquerySequenceLength,\n\t\t\t\t\ttargetSequenceLength,\n\t\t\t\t\tisAnchored));\n    \t\treturn list;\n    \t}\n    }\n    // updates cut rows given the latest row of traceback pointers\n    public static void setCuts(int x, Subproblem subproblem, Last[][] pointers, Cut[]cuts) {\n        for (Cut c : cuts) {\n            c.update(x, subproblem, pointers);\n        }\n    }\n    /**\n     * Calculate the optimal alignment score for the given sequence positions with an affine or constant gap penalty\n     * @param x position in query\n     * @param y position in target\n     * @param gop gap opening penalty\n     * @param gep gap extension penalty\n     * @param sub compound match score\n     * @param scores dynamic programming score matrix to fill at the given position\n     * @return traceback direction for substitution, deletion and insertion\n     */\n    public static Last[] setScorePoint(int x, int y, int gop, int gep, int sub, int[][][] scores) {\n        Last[] pointers = new Last[3];\n\n        // substitution\n        if (scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][0] && scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][2]) {\n            scores[x][y][0] = scores[x - 1][y - 1][1] + sub;\n            pointers[0] = Last.DELETION;\n        } else if (scores[x - 1][y - 1][0] >= scores[x - 1][y - 1][2]) {\n            scores[x][y][0] = scores[x - 1][y - 1][0] + sub;\n            pointers[0] = Last.SUBSTITUTION;\n        } else {\n            scores[x][y][0] = scores[x - 1][y - 1][2] + sub;\n            pointers[0] = Last.INSERTION;\n        }\n\n        // deletion\n        if (scores[x - 1][y][1] >= scores[x - 1][y][0] + gop) {\n            scores[x][y][1] = scores[x - 1][y][1] + gep;\n            pointers[1] = Last.DELETION;\n        } else {\n            scores[x][y][1] = scores[x - 1][y][0] + gop + gep;\n            pointers[1] = Last.SUBSTITUTION;\n        }\n\n        // insertion\n        if (scores[x][y - 1][0] + gop >= scores[x][y - 1][2]) {\n            scores[x][y][2] = scores[x][y - 1][0] + gop + gep;\n            pointers[2] = Last.SUBSTITUTION;\n        } else {\n            scores[x][y][2] = scores[x][y - 1][2] + gep;\n            pointers[2] = Last.INSERTION;\n        }\n\n        return pointers;\n    }\n    /**\n     * Calculates the optimal alignment score for the given sequence positions and a linear gap penalty\n     * @param x position in query\n     * @param y position in target\n     * @param gep gap extension penalty\n     * @param sub compound match score\n     * @param scores dynamic programming score matrix to fill at the given position\n     * @return traceback directions for substitution, deletion and insertion respectively\n     */\n    public static Last setScorePoint(int x, int y, int gep, int sub, int[][][] scores) {\n        int d = scores[x - 1][y][0] + gep;\n        int i = scores[x][y - 1][0] + gep;\n        int s = scores[x - 1][y - 1][0] + sub;\n        if (d >= s && d >= i) {\n            scores[x][y][0] = (int) d;\n            return Last.DELETION;\n        } else if (s >= i) {\n            scores[x][y][0] = (int) s;\n            return Last.SUBSTITUTION;\n        } else {\n            scores[x][y][0] = (int) i;\n            return Last.INSERTION;\n        }\n    }\n\n    /**\n     * Score global alignment for a given position in the query sequence\n     * @param x\n     * @param subproblem\n     * @param gop\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, Subproblem subproblem, int gop, int gep, int[] subs, boolean storing,\n            int[][][] scores) {\n        return setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gop, gep, subs, storing, scores, subproblem.isStartAnchored());\n    }\n\n    /**\n     * Score global alignment for a given position in the query sequence\n     * @param x\n     * @param xb\n     * @param yb\n     * @param ye\n     * @param gop\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param startAnchored\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n            boolean storing, int[][][] scores, boolean startAnchored) {\n        Last[][] pointers = new Last[ye + 1][];\n        int min = Integer.MIN_VALUE - gop - gep;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            scores[xb][yb][1] = scores[xb][yb][2] = 0;\n            pointers[yb] = new Last[] {null, null, null};\n            if (startAnchored) {\n        \t\tassert (xb > 0 && yb > 0);\n        \t\tint subproblemStartingScore = scores[xb - 1][yb - 1][0] + subs[yb];\n        \t\tscores[xb][yb][0] = subproblemStartingScore;\n        \t\tscores[xb][yb][1] = subproblemStartingScore + gop;\n        \t\tscores[xb][yb][2] = subproblemStartingScore + gop;\n        \t\tpointers[yb] = new Last[] {Last.SUBSTITUTION, Last.SUBSTITUTION, Last.SUBSTITUTION};\n        \t}\n            Last[] insertion = new Last[] { null, null, Last.INSERTION };\n            for (int y = yb + 1; y <= ye; y++) {\n                scores[xb][y][0] = scores[xb][y][1] = min;\n                scores[xb][y][2] = (int) (scores[xb][y - 1][2] + gep);\n                pointers[y] = insertion;\n            }\n        } else {\n            scores[x][yb][0] = scores[x][yb][2] = min;\n            scores[x][yb][1] = scores[x - 1][yb][1] + gep;\n            pointers[yb] = new Last[] { null, Last.DELETION, null };\n            for (int y = yb + 1; y <= ye; y++) {\n                pointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n            }\n        }\n        return pointers;\n    }\n\n    /**\n     * Score global alignment for a given position in the query sequence for a linear gap penalty\n     * @param x\n     * @param subproblem\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, Subproblem subproblem, int gep, int[] subs, boolean storing,\n            int[][][] scores) {\n        return setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gep, subs, storing, scores, subproblem.isStartAnchored());\n    }\n\n    /**\n     * Score global alignment for a given position in the query sequence for a linear gap penalty\n     * @param x\n     * @param xb\n     * @param yb\n     * @param ye\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param startAnchored\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n            int[][][] scores, boolean startAnchored) {\n        Last[][] pointers = new Last[ye + 1][1];\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n        \tif (startAnchored) {\n        \t\tassert (xb > 0 && yb > 0);\n        \t\tscores[xb][yb][0] = (int) (scores[xb - 1][yb - 1][0] + subs[yb]);\n        \t\tpointers[yb][0] = Last.SUBSTITUTION;\n        \t}\n            for (int y = yb + 1; y <= ye; y++) {\n                scores[xb][y][0] = (int) (scores[xb][y - 1][0] + gep);\n                pointers[y][0] = Last.INSERTION;\n            }\n        } else {\n            scores[x][yb][0] = (int) (scores[x - 1][yb][0] + gep);\n            pointers[yb][0] = Last.DELETION;\n            for (int y = yb + 1; y <= ye; y++) {\n                pointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n            }\n        }\n        return pointers;\n    }\n\n    /**\n     * Score local alignment for a given position in the query sequence\n     * @param x\n     * @param gop\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param xyMax\n     * @param score\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int gop, int gep, int[] subs, boolean storing,\n            int[][][] scores, int[] xyMax, int score) {\n        return setScoreVector(x, 0, 0, scores[0].length - 1, gop, gep, subs, storing, scores, xyMax, score);\n    }\n\n    /**\n     * Score local alignment for a given position in the query sequence\n     * @param x\n     * @param xb\n     * @param yb\n     * @param ye\n     * @param gop\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param xyMax\n     * @param score\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n            boolean storing, int[][][] scores, int[] xyMax, int score) {\n        Last[][] pointers;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            pointers = new Last[ye + 1][scores[0][0].length];\n        } else {\n            pointers = new Last[ye + 1][];\n            pointers[0] = new Last[scores[0][0].length];   \n            for (int y = 1; y < scores[0].length; y++) {\n                pointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n                for (int z = 0; z < scores[0][0].length; z++) {\n                    if (scores[x][y][z] <= 0) {\n                        scores[x][y][z] = 0;\n                        pointers[y][z] = null;\n                    }\n                }\n                if (scores[x][y][0] > score) {\n                    xyMax[0] = x;\n                    xyMax[1] = y;\n                    score = scores[x][y][0];\n                }\n            }\n        }\n        return pointers;\n    }\n    \n    /**\n     * Score local alignment for a given position in the query sequence for a linear gap penalty\n     * @param x\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param xyMax\n     * @param score\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int gep, int[] subs, boolean storing, int[][][] scores,\n            int[] xyMax, int score) {\n        return setScoreVector(x, 0, 0, scores[0].length - 1, gep, subs, storing, scores, xyMax, score);\n    }\n\n    /**\n     * Score local alignment for a given position in the query sequence for a linear gap penalty\n     * @param x\n     * @param xb\n     * @param yb\n     * @param ye\n     * @param gep\n     * @param subs\n     * @param storing\n     * @param scores\n     * @param xyMax\n     * @param score\n     * @return\n     */\n    public static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n            int[][][] scores, int[] xyMax, int score) {\n        Last[][] pointers;\n        ensureScoringMatrixColumn(x, storing, scores);\n        if (x == xb) {\n            pointers = new Last[ye + 1][1];\n        } else {\n            pointers = new Last[ye + 1][];\n            pointers[0] = new Last[1];\n            for (int y = 1; y < scores[x].length; y++) {\n                pointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n                if (scores[x][y][0] <= 0) {\n                    scores[x][y][0] = 0;\n                    pointers[y][0] = null;\n                } else if (scores[x][y][0] > score) {\n                    xyMax[0] = x;\n                    xyMax[1] = y;\n                    score = scores[x][y][0];\n                }\n            }\n        }\n        return pointers;\n    }\n    \n    private static void ensureScoringMatrixColumn(int x, boolean storingFullMatrix, int[][][] scores) {\n    \tif (!storingFullMatrix && x > 1) {\n            scores[x] = scores[x - 2];\n        }\n    }\n    \n    /**\n     * Find alignment path through traceback matrix\n     * @param traceback\n     * @param local\n     * @param xyMax\n     * @param last\n     * @param sx\n     * @param sy\n     * @return\n     */\n    public static int[] setSteps(Last[][][] traceback, boolean local, int[] xyMax, Last last, List<Step> sx,\n            List<Step> sy) {\n        int x = xyMax[0], y = xyMax[1];\n        boolean linear = (traceback[x][y].length == 1);\n        while (local ? (linear ? last : traceback[x][y][last.ordinal()]) != null : x > 0 || y > 0) {\n            switch (last) {\n            case DELETION:\n                sx.add(Step.COMPOUND);\n                sy.add(Step.GAP);\n                last = linear ? traceback[--x][y][0] : traceback[x--][y][1];\n                break;\n            case SUBSTITUTION:\n                sx.add(Step.COMPOUND);\n                sy.add(Step.COMPOUND);\n                last = linear ? traceback[--x][--y][0] : traceback[x--][y--][0];\n                break;\n            case INSERTION:\n                sx.add(Step.GAP);\n                sy.add(Step.COMPOUND);\n                last = linear ? traceback[x][--y][0] : traceback[x][y--][2];\n            }\n        }\n        Collections.reverse(sx);\n        Collections.reverse(sy);\n        return new int[] {x, y};\n    }\n\n    /**\n     * Find global alignment path through traceback matrix\n     * @param traceback\n     * @param scores\n     * @param sx\n     * @param sy\n     * @return\n     */\n    public static int[] setSteps(Last[][][] traceback, int[][][] scores, List<Step> sx, List<Step> sy) {\n        int xMax = scores.length - 1, yMax = scores[xMax].length - 1;\n        boolean linear = (traceback[xMax][yMax].length == 1);\n        \n        Last last = \n        \t\t\n        \tlinear ? \n        \t\ttraceback[xMax][yMax][0] : \n        \t\t\t\n        \t\t(scores[xMax][yMax][1] > scores[xMax][yMax][0] &&\n        \t\t scores[xMax][yMax][1] > scores[xMax][yMax][2] ) ? \n        \t\t\t\t\t\t\n        \t\t\t\tLast.DELETION : \n        \t\t\t\t\t(scores[xMax][yMax][0] > scores[xMax][yMax][2]) ? \n        \t\t\t\t\t\t\tLast.SUBSTITUTION : \n        \t\t\t\t\t\t\tLast.INSERTION;\n        \n        \t\t\n        return setSteps(traceback, false, new int[] {xMax, yMax}, last, sx, sy);\n    }\n\n    /**\n     * Find local alignment path through traceback matrix\n     * @param traceback\n     * @param xyMax\n     * @param sx\n     * @param sy\n     * @return\n     */\n    public static int[] setSteps(Last[][][] traceback, int[] xyMax, List<Step> sx, List<Step> sy) {\n        return setSteps(traceback, true, xyMax, Last.SUBSTITUTION, sx, sy);\n    }\n    \n    public static String tracebackToString(Last[][][] traceback) {\n    \tStringBuilder sb = new StringBuilder();\n    \tfor (int z = 0; z < 3; z++) {\n    \t\tfor (int i = 0; i < traceback.length; i++) {\n    \t\t\tif (traceback[i] != null) {\n\t    \t\t\tfor (int j = 0; j < traceback[i].length; j++) {\n\t    \t\t\t\tif (traceback[i][j] == null || z >= traceback[i][j].length || traceback[i][j][z] == null) {\n\t    \t\t\t\t\tsb.append('.');\n\t    \t\t\t\t} else {\n\t\t    \t\t\t\tswitch (traceback[i][j][z]) {\n\t\t    \t            case DELETION:\n\t\t    \t            \tsb.append('^');\n\t\t    \t            \tbreak;\n\t\t    \t            case SUBSTITUTION:\n\t\t    \t            \tsb.append('\\\\');\n\t\t    \t                break;\n\t\t    \t            case INSERTION:\n\t\t    \t            \tsb.append('<');\n\t\t    \t            \tbreak;\n\t\t    \t            }\n\t    \t\t\t\t}\n\t    \t\t\t}\n    \t\t\t}\n    \t\t\tsb.append('\\n');\n    \t\t}\n    \t\tsb.append(\"\\n\\n\");\n    \t}\n    \treturn sb.toString();\n    }\n}\n","originTest":"package org.biojava3.alignment.routines;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava3.alignment.routines.AlignerHelper.Anchor;\nimport org.biojava3.alignment.routines.AlignerHelper.Cut;\nimport org.biojava3.alignment.routines.AlignerHelper.Subproblem;\nimport org.junit.Test;\n\n/**\n * \n * @author Daniel Cameron\n *\n */\npublic class AlignerHelperTest {\n\t@Test\n\tpublic void getCuts_should_not_return_start_position_for_starting_anchor() {\n\t\tCut[] cuts = AlignerHelper.getCuts(10, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, true);\n\t\tassertNotEquals(5, cuts[0].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getCuts_should_return_all_positions_when_cuts_exceeds_query_size() {\n\t\tCut[] cuts = AlignerHelper.getCuts(10, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, false);\n\t\tassertEquals(5, cuts.length);\n\t\tassertEquals(5, cuts[0].getQueryIndex());\n\t\tassertEquals(6, cuts[1].getQueryIndex());\n\t\tassertEquals(7, cuts[2].getQueryIndex());\n\t\tassertEquals(8, cuts[3].getQueryIndex());\n\t\tassertEquals(9, cuts[4].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getCuts_should_return_spaced_cuts_when_query_interval_larger_than_cut_size() {\n\t\tCut[] cuts = AlignerHelper.getCuts(3, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, false);\n\t\tassertEquals(3, cuts.length);\n\t\tassertEquals(5, cuts[0].getQueryIndex());\n\t\tassertEquals(7, cuts[1].getQueryIndex());\n\t\tassertEquals(9, cuts[2].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_return_score_indicies_of_alignment_subproblems() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 2));\n\t\tanchors.add(new Anchor(5, 5));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(1, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(2, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(2, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(3, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(5, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(5, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(6, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(6, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_zero_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(1, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(false, problems.get(0).isStartAnchored());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_start_and_end_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(0, 0));\n\t\tanchors.add(new Anchor(9, 14));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(0, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(0, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(false, problems.get(0).isStartAnchored());\n\t\tassertEquals(1, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(1, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(9, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(14, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(true, problems.get(1).isStartAnchored());\n\t\tassertEquals(10, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(15, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t\tassertEquals(true, problems.get(2).isStartAnchored());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_adjacent_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 1));\n\t\tanchors.add(new Anchor(2, 3));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(2, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(2, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(2, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(3, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(3, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(4, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t}\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void getSubproblems_should_not_allow_repeated_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 1));\n\t\tanchors.add(new Anchor(1, 2));\n\t\tAlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t}\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void getSubproblems_should_not_allow_unalignable_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 2));\n\t\tanchors.add(new Anchor(2, 1));\n\t\tAlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t}\n}\n","changedTest":"","commitMessage":"Fixed bug in global alignment: opening gap penalty should not be applied\nto start of alignment","test_commitMessage":"","allZero":true}