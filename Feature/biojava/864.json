{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/mmtf/MmtfUtils.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/mmtf/TestMmtfUtils.java","prod_time":"2018-05-22 05:12:38","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"37a96c1ca768d0f67c5a351cae82dac495414e8c","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.GroupType;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(MmtfUtils.class);\n\t\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t * @param extraUrl the string describing the URL (or file path) from which\n\t * to get missing CCD entries.\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tDownloadChemCompProvider.serverBaseUrl = extraUrl;\n\t\tDownloadChemCompProvider.useDefaultUrlLayout = false;\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\tLOGGER.warn(\"Could not calculate secondary structure (error {}). Will try to get a DSSP file from the RCSB web server instead.\", e.getMessage());\n\t\t\t\n\t\t\ttry {\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t} catch(Exception bige){\n\t\t\t\tLOGGER.warn(\"Could not get a DSSP file from RCSB web server. There will not be secondary structure assignment for this structure ({}). Error: {}\", bioJavaStruct.getPDBCode(), bige.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tif(experimentalTechniques==null){\n\t\t\treturn new String[0];\n\t\t}\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform, chainindices it relates to.\n\t * @param bioassemblyInfo  the bioassembly info object for this structure\n\t * @param chainIdToIndexMap the map of chain ids to the index that chain corresponds to.\n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t    Map<Matrix4d, List<Integer>> matMap = new LinkedHashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\n\t    Map<double[], int[]> outMap = new LinkedHashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tpublic static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\tSecStrucType secStrucType = getSecStructTypeFromDsspIndex(dsspIndex);\n\t\tSecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNED\", secStrucType);\n\t\tif(secStrucType!=null){\n\t\t\tgroup.setProperty(\"secstruc\", secStrucState);\n\t\t}\n\t\telse{\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the DSSP type based on a numerical index.\n\t * @param dsspIndex the integer index of the type to set\n\t * @return the instance of the SecStrucType object holding this secondary\n\t * structure type.\n\t */\n\tpublic static SecStrucType getSecStructTypeFromDsspIndex(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getId();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n\n\t/**\n\t * Get a list of N 4*4 matrices from a single list of doubles of length 16*N.\n\t * @param ncsOperMatrixList the input list of doubles\n\t * @return the list of 4*4 matrics \n\t */\n\tpublic static Matrix4d[] getNcsAsMatrix4d(double[][] ncsOperMatrixList) {\n\t\tif(ncsOperMatrixList==null){\n\t\t\treturn null;\n\t\t}\n\t\tint numMats = ncsOperMatrixList.length;\n\t\tif(numMats==0){\n\t\t\treturn null;\n\t\t}\n\t\tif(numMats==1 && ncsOperMatrixList[0].length==0){\n\t\t\treturn null;\n\t\t}\n\t\tMatrix4d[] outList = new Matrix4d[numMats];\n\t\tfor(int i=0; i<numMats; i++){\n\t\t\toutList[i] = new Matrix4d(ncsOperMatrixList[i]);\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Get a list of length N*16 of a list of Matrix4d*N.\n\t * @param ncsOperators the {@link Matrix4d} list \n\t * @return the list of length N*16 of the list of matrices\n\t */\n\tpublic static double[][] getNcsAsArray(Matrix4d[] ncsOperators) {\n\t\tif(ncsOperators==null){\n\t\t\treturn new double[0][0];\n\t\t}\n\t\tdouble[][] outList = new double[ncsOperators.length][16];\n\t\tfor(int i=0; i<ncsOperators.length;i++){\n\t\t\toutList[i] = convertToDoubleArray(ncsOperators[i]);\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Insert the group in the given position in the sequence.\n\t * @param chain the chain to add the seq res group to\n\t * @param group the group to add\n\t * @param sequenceIndexId the index to add it in\n\t */\n\tpublic static void insertSeqResGroup(Chain chain, Group group, int sequenceIndexId) {\n\t\tList<Group> seqResGroups = chain.getSeqResGroups();\n\t\taddGroupAtId(seqResGroups, group, sequenceIndexId);\n\t}\n\n\t/**\n\t * Add the missing groups to the SeqResGroups.\n\t * @param modelChain the chain to add the information for\n\t * @param sequence the sequence of the construct\n\t */\n\tpublic static void addSeqRes(Chain modelChain, String sequence) {\n\t\tList<Group> seqResGroups = modelChain.getSeqResGroups();\n\t\tGroupType chainType = getChainType(modelChain.getAtomGroups());\n\t\tfor(int i=0; i<sequence.length(); i++){\n\t\t\tchar singleLetterCode = sequence.charAt(i);\n\t\t\tGroup group = null;\n\t\t\tif(seqResGroups.size()<=i){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgroup=seqResGroups.get(i);\n\t\t\t}\n\t\t\tif(group!=null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgroup = getSeqResGroup(modelChain, singleLetterCode, chainType);\n\t\t\taddGroupAtId(seqResGroups, group, i);\n\t\t\tseqResGroups.set(i, group);\n\t\t}\n\t}\n\n\tprivate static GroupType getChainType(List<Group> groups) {\n\t\tfor(Group group : groups) {\n\t\t\tif(group==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(group.getType()!=GroupType.HETATM){\n\t\t\t\treturn group.getType();\n\t\t\t}\n\t\t}\n\t\treturn GroupType.HETATM;\n\t}\n\n\tprivate static <T> void addGroupAtId(List<T> seqResGroups, T group, int sequenceIndexId) {\n\t\twhile(seqResGroups.size()<=sequenceIndexId){\n\t\t\tseqResGroups.add(null);\n\t\t}\n\t\tif(sequenceIndexId>=0){\n\t\t\tseqResGroups.set(sequenceIndexId, group);\n\t\t}\t\t\n\t}\n\t\n\tprivate static Group getSeqResGroup(Chain modelChain, char singleLetterCode, GroupType type) {\n\t\tif(type==GroupType.AMINOACID){\n\t\t\tAminoAcidImpl a = new AminoAcidImpl();\n\t\t\ta.setRecordType(AminoAcid.SEQRESRECORD);\n\t\t\ta.setAminoType(singleLetterCode);\n\t\t\tChemComp chemComp = new ChemComp();\n\t\t\tchemComp.setOne_letter_code(\"\"+singleLetterCode);\n\t\t\ta.setChemComp(chemComp);\n\t\t\treturn a;\n\n\t\t} else if (type==GroupType.NUCLEOTIDE) {\n\t\t\tNucleotideImpl n = new NucleotideImpl();\n\t\t\tChemComp chemComp = new ChemComp();\n\t\t\tchemComp.setOne_letter_code(\"\"+singleLetterCode);\n\t\t\tn.setChemComp(chemComp);\n\t\t\treturn n;\n\t\t}\n\t\telse{\n\t\t\treturn null;\n\t\t}\n\t}\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.GroupType;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(MmtfUtils.class);\n\t\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t * @param extraUrl the string describing the URL (or file path) from which\n\t * to get missing CCD entries.\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tDownloadChemCompProvider.serverBaseUrl = extraUrl;\n\t\tDownloadChemCompProvider.useDefaultUrlLayout = false;\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\tLOGGER.warn(\"Could not calculate secondary structure (error {}). Will try to get a DSSP file from the RCSB web server instead.\", e.getMessage());\n\t\t\t\n\t\t\ttry {\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t} catch(Exception bige){\n\t\t\t\tLOGGER.warn(\"Could not get a DSSP file from RCSB web server. There will not be secondary structure assignment for this structure ({}). Error: {}\", bioJavaStruct.getPDBCode(), bige.getMessage());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tif(experimentalTechniques==null){\n\t\t\treturn new String[0];\n\t\t}\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform, chainindices it relates to.\n\t * @param bioassemblyInfo  the bioassembly info object for this structure\n\t * @param chainIdToIndexMap the map of chain ids to the index that chain corresponds to.\n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t    Map<Matrix4d, List<Integer>> matMap = new LinkedHashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\n\t    Map<double[], int[]> outMap = new LinkedHashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tpublic static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\n\t/**\n\t * Get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\tSecStrucType secStrucType = getSecStructTypeFromDsspIndex(dsspIndex);\n\t\tSecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNED\", secStrucType);\n\t\tif(secStrucType!=null){\n\t\t\tgroup.setProperty(\"secstruc\", secStrucState);\n\t\t}\n\t\telse{\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the DSSP type based on a numerical index.\n\t * @param dsspIndex the integer index of the type to set\n\t * @return the instance of the SecStrucType object holding this secondary\n\t * structure type.\n\t */\n\tpublic static SecStrucType getSecStructTypeFromDsspIndex(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new LinkedHashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getId();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n\n\t/**\n\t * Get a list of N 4*4 matrices from a single list of doubles of length 16*N.\n\t * @param ncsOperMatrixList the input list of doubles\n\t * @return the list of 4*4 matrics \n\t */\n\tpublic static Matrix4d[] getNcsAsMatrix4d(double[][] ncsOperMatrixList) {\n\t\tif(ncsOperMatrixList==null){\n\t\t\treturn null;\n\t\t}\n\t\tint numMats = ncsOperMatrixList.length;\n\t\tif(numMats==0){\n\t\t\treturn null;\n\t\t}\n\t\tif(numMats==1 && ncsOperMatrixList[0].length==0){\n\t\t\treturn null;\n\t\t}\n\t\tMatrix4d[] outList = new Matrix4d[numMats];\n\t\tfor(int i=0; i<numMats; i++){\n\t\t\toutList[i] = new Matrix4d(ncsOperMatrixList[i]);\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Get a list of length N*16 of a list of Matrix4d*N.\n\t * @param ncsOperators the {@link Matrix4d} list \n\t * @return the list of length N*16 of the list of matrices\n\t */\n\tpublic static double[][] getNcsAsArray(Matrix4d[] ncsOperators) {\n\t\tif(ncsOperators==null){\n\t\t\treturn new double[0][0];\n\t\t}\n\t\tdouble[][] outList = new double[ncsOperators.length][16];\n\t\tfor(int i=0; i<ncsOperators.length;i++){\n\t\t\toutList[i] = convertToDoubleArray(ncsOperators[i]);\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Insert the group in the given position in the sequence.\n\t * @param chain the chain to add the seq res group to\n\t * @param group the group to add\n\t * @param sequenceIndexId the index to add it in\n\t */\n\tpublic static void insertSeqResGroup(Chain chain, Group group, int sequenceIndexId) {\n\t\tList<Group> seqResGroups = chain.getSeqResGroups();\n\t\taddGroupAtId(seqResGroups, group, sequenceIndexId);\n\t}\n\n\t/**\n\t * Add the missing groups to the SeqResGroups.\n\t * @param modelChain the chain to add the information for\n\t * @param sequence the sequence of the construct\n\t */\n\tpublic static void addSeqRes(Chain modelChain, String sequence) {\n\t\tList<Group> seqResGroups = modelChain.getSeqResGroups();\n\t\tGroupType chainType = getChainType(modelChain.getAtomGroups());\n\t\tfor(int i=0; i<sequence.length(); i++){\n\t\t\tchar singleLetterCode = sequence.charAt(i);\n\t\t\tGroup group = null;\n\t\t\tif(seqResGroups.size()<=i){\n\t\t\t}\n\t\t\telse{\n\t\t\t\tgroup=seqResGroups.get(i);\n\t\t\t}\n\t\t\tif(group!=null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgroup = getSeqResGroup(modelChain, singleLetterCode, chainType);\n\t\t\taddGroupAtId(seqResGroups, group, i);\n\t\t\tseqResGroups.set(i, group);\n\t\t}\n\t}\n\n\tprivate static GroupType getChainType(List<Group> groups) {\n\t\tfor(Group group : groups) {\n\t\t\tif(group==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if(group.getType()!=GroupType.HETATM){\n\t\t\t\treturn group.getType();\n\t\t\t}\n\t\t}\n\t\treturn GroupType.HETATM;\n\t}\n\n\tprivate static <T> void addGroupAtId(List<T> seqResGroups, T group, int sequenceIndexId) {\n\t\twhile(seqResGroups.size()<=sequenceIndexId){\n\t\t\tseqResGroups.add(null);\n\t\t}\n\t\tif(sequenceIndexId>=0){\n\t\t\tseqResGroups.set(sequenceIndexId, group);\n\t\t}\t\t\n\t}\n\t\n\tprivate static Group getSeqResGroup(Chain modelChain, char singleLetterCode, GroupType type) {\n\t\tif(type==GroupType.AMINOACID){\n\t\t\tAminoAcidImpl a = new AminoAcidImpl();\n\t\t\ta.setRecordType(AminoAcid.SEQRESRECORD);\n\t\t\ta.setAminoType(singleLetterCode);\n\t\t\tChemComp chemComp = new ChemComp();\n\t\t\tchemComp.setOne_letter_code(\"\"+singleLetterCode);\n\t\t\ta.setChemComp(chemComp);\n\t\t\treturn a;\n\n\t\t} else if (type==GroupType.NUCLEOTIDE) {\n\t\t\tNucleotideImpl n = new NucleotideImpl();\n\t\t\tChemComp chemComp = new ChemComp();\n\t\t\tchemComp.setOne_letter_code(\"\"+singleLetterCode);\n\t\t\tn.setChemComp(chemComp);\n\t\t\treturn n;\n\t\t}\n\t\telse{\n\t\t\treturn null;\n\t\t}\n\t}\n}","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.BondImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.HetatomImpl;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.io.mmtf.MmtfUtils;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.BravaisLattice;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\n/**\n * Test the MMTF utils class\n * @author Anthony Bradley\n *\n */\npublic class TestMmtfUtils {\n\n\t/**\n\t * Integration test to see that the microheterogenity is being dealt with correctly.\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void microHeterogenity() throws IOException, StructureException {\n\t\tMmtfUtils.setUpBioJava();\n\t\tStructure inputStructure = StructureIO.getStructure(\"4ck4\");\n\t\t// Count the number of groups\n\t\tGroup before = inputStructure.getChains().get(0).getAtomGroup(17);\n\t\tassertTrue(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t\tList<Atom> totalAtoms = new ArrayList<>(getAllAtoms(inputStructure));\n\t\tint totGroups = 0;\n\t\tint totAtomsCounter = 0;\n\t\tSet<Atom> totAtoms = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroups += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounter+=g.getAtoms().size();\n\t\t\t\ttotAtoms.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsCounter+=alt.getAtoms().size();\n\t\t\t\t\ttotAtoms.addAll(alt.getAtoms());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Now \"fix\" the microheterogenity\n\t\tMmtfUtils.fixMicroheterogenity(inputStructure);\n\t\tassertEquals(before, inputStructure.getChains().get(0).getAtomGroup(17));\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(18).hasAltLoc());\n\t\tint totGroupsAfter = 0;\n\t\tint totAtomsCounterAfter = 0;\n\t\tSet<Atom> totAtomsAfter = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroupsAfter += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounterAfter+=g.getAtoms().size();\n\t\t\t\ttotAtomsAfter.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsAfter.addAll(alt.getAtoms());\n\t\t\t\t\ttotAtomsCounterAfter+=alt.getAtoms().size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Find the atoms after the fix.\n\t\tList<Atom> totalAtomsAfter = new ArrayList<>(getAllAtoms(inputStructure));\n\t\t// Get all of the duplicate atoms\n\t\tSet<Atom> duplicates = findDuplicates(totalAtomsAfter);\n\t\tfor (Atom a : duplicates) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t// There should be no duplicates\n\t\tassertEquals(duplicates.size(), 0);\n\t\tassertEquals(totalAtoms.size(), totalAtomsAfter.size());\n\t\t// Check there are two more groups afterwards\n\t\tassertEquals(totGroupsAfter-2, totGroups);\n\t\t// Check there are no more atoms afterwards\n\t\tassertEquals(totAtomsAfter.size(), totAtoms.size());\n\t\t// Check the counter are the same too\n\t\tassertEquals(totAtomsCounterAfter, totAtomsCounter);\n\n\t}\n\n\t/**\n\t * Function to get all the atoms in the strucutre as a list.\n\t * @param bioJavaStruct the biojava structure\n\t * @return a list of all the unique atoms in the structure\n\t */\n\tprivate List<Atom> getAllAtoms(Structure bioJavaStruct) {\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tfor(Atom a: MmtfUtils.getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(a);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Test that getting the space group info as a string works.\n\t */\n\t@Test\n\tpublic void testGetSpaceGroupAsString() {\n\t\tassertEquals(\"NA\", MmtfUtils.getSpaceGroupAsString(null));\n\t\tSpaceGroup spaceGroup = new SpaceGroup(21, 1, 1, \"P212121\", \"P 21 21 21\", BravaisLattice.TRICLINIC);\n\t\tassertEquals(\"P212121\", MmtfUtils.getSpaceGroupAsString(spaceGroup));\n\t}\n\n\t/**\n\t * Test that getting the unit cell as an array of doubles works.\n\t */\n\t@Test\n\tpublic void testGetUnitCellAsArray() {\n\t\tPDBCrystallographicInfo xtalInfo = new PDBCrystallographicInfo();\n\t\tCrystalCell cell = new CrystalCell();\n\t\tcell.setA(1.0);\n\t\tcell.setB(2.0);\n\t\tcell.setC(3.0);\n\t\tcell.setAlpha(4.0);\n\t\tcell.setBeta(5.0);\n\t\tcell.setGamma(6.0);\n\t\tfloat[] testArray = new float[] {1.0f,2.0f,3.0f,4.0f,5.0f,6.0f};\n\t\txtalInfo.setCrystalCell(cell);\n\t\tfloat[] outputArray = MmtfUtils.getUnitCellAsArray(xtalInfo);\n\t\tassertArrayEquals(testArray, outputArray, 0.0f);\n\t}\n\n\t/**\n\t * Test getting the list of experimental methods as string array.\n\t */\n\t@Test\n\tpublic void testGetExperimentalMethods() {\n\t\tSet<ExperimentalTechnique> experimentalTechniques = new HashSet<>();\n\t\texperimentalTechniques.add(ExperimentalTechnique.XRAY_DIFFRACTION);\n\t\texperimentalTechniques.add(ExperimentalTechnique.ELECTRON_MICROSCOPY);\n\t\tString[] techniques = MmtfUtils.techniquesToStringArray(experimentalTechniques);\n\t\tString[] testTechniques = {\"X-RAY DIFFRACTION\", \"ELECTRON MICROSCOPY\"};\n\t\tArrays.sort(techniques);\n\t\tArrays.sort(testTechniques);\n\t\tassertArrayEquals(testTechniques, techniques);\n\t}\n\n\t/**\n\t * Test the conversion of a matrix to an array of doubles.\n\t */\n\t@Test \n\tpublic void testConvertToDoubleArray() {\n\t\tMatrix4d matrix4d = new Matrix4d();\n\t\tmatrix4d.m00 = 0.0;\n\t\tmatrix4d.m01 = 0.1;\n\t\tmatrix4d.m02 = 0.2;\n\t\tmatrix4d.m03 = 0.3;\n\t\tmatrix4d.m10 = 1.0;\n\t\tmatrix4d.m11 = 1.1;\n\t\tmatrix4d.m12 = 1.2;\n\t\tmatrix4d.m13 = 1.3;\n\t\tmatrix4d.m20 = 2.0;\n\t\tmatrix4d.m21 = 2.1;\n\t\tmatrix4d.m22 = 2.2;\n\t\tmatrix4d.m23 = 2.3;\n\t\tmatrix4d.m30 = 3.0;\n\t\tmatrix4d.m31 = 3.1;\n\t\tmatrix4d.m32 = 3.2;\n\t\tmatrix4d.m33 = 3.3;\n\t\tdouble[] testData = new double[] {0.0, 0.1, 0.2, 0.3,\n\t\t\t\t1.0, 1.1, 1.2, 1.3,\n\t\t\t\t2.0, 2.1, 2.2, 2.3,\n\t\t\t\t3.0, 3.1, 3.2, 3.3};\n\t\tassertArrayEquals(testData,MmtfUtils.convertToDoubleArray(matrix4d), 0.0);\n\t}\n\n\t/**\n\t * Test to check the conversion of BioassemblyInfo to a primitive map.\n\t */\n\t@Test\n\tpublic void testMakePrimitiveBioasembly() {\n\t\tdouble[] testData = new double[] {0.0, 0.1, 0.2, 0.3,\n\t\t\t\t1.0, 1.1, 1.2, 1.3,\n\t\t\t\t2.0, 2.1, 2.2, 2.3,\n\t\t\t\t3.0, 3.1, 3.2, 3.3};\n\t\tBioAssemblyInfo bioAssemblyInfo = new BioAssemblyInfo();\n\t\tList<BiologicalAssemblyTransformation> transforms = new ArrayList<>();\n\t\tBiologicalAssemblyTransformation biologicalAssemblyTransformation = new BiologicalAssemblyTransformation();\n\t\tbiologicalAssemblyTransformation.setChainId(\"C\");\n\t\tbiologicalAssemblyTransformation.setTransformationMatrix(new Matrix4d(testData));\n\t\ttransforms.add(biologicalAssemblyTransformation);\n\t\tbioAssemblyInfo.setTransforms(transforms);\n\t\t// Map the chain to the second index\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tchainIdToIndexMap.put(\"C\", 2);\n\t\t// Now do the conversion and test they are the same\n\t\tMap<double[], int[]> transMap = MmtfUtils.getTransformMap(bioAssemblyInfo, chainIdToIndexMap);\n\t\tassertArrayEquals(testData, (double[]) transMap.keySet().toArray()[0], 0.0);\n\t\tassertArrayEquals(new int[] {2} , (int[]) transMap.values().toArray()[0]);\n\t}\n\n\n\t/**\n\t * Test getting the data as an appropriately formatted string.\n\t */\n\tpublic void testGetIsoDateString() {\n\t\tDate inputDate = new Date();\n\t\tinputDate.setTime(86500);\n\t\t// One day after \n\t\tassertEquals(\"1970-01-02\",MmtfUtils.dateToIsoString(inputDate));\n\t}\n\n\t/**\n\t * Test getting the number of groups from a structure.\n\t */\n\t@Test\n\tpublic void testGetNumGroups() {\n\t\tStructure structure = new StructureImpl();\n\t\tChain chain = new ChainImpl();\n\t\tGroup groupOne = new  AminoAcidImpl();\n\t\tGroup groupTwo = new HetatomImpl();\n\t\tGroup groupThree = new NucleotideImpl();\n\t\tstructure.addChain(chain);\n\t\tchain.addGroup(groupOne);\n\t\tchain.addGroup(groupTwo);\n\t\tchain.addGroup(groupThree);\n\t\tassertEquals(3,MmtfUtils.getNumGroups(structure));\n\t}\n\n\n\t/**\n\t * Test getting the correct atoms from a group\n\t */\n\t@Test\n\tpublic void testGetAtomsForGroup() {\n\t\tGroup group = new AminoAcidImpl();\n\t\tGroup altLoc = new AminoAcidImpl();\n\t\tAtom atomOne = new AtomImpl();\n\t\tatomOne.setX(1.00);\n\t\tAtom atomTwo = new AtomImpl();\n\t\tatomTwo.setX(2.00);\n\t\tAtom atomThree = new AtomImpl();\n\t\tatomThree.setX(3.00);\n\t\tatomThree.setAltLoc('B');\n\t\tAtom atomFour = new AtomImpl();\n\t\tatomFour.setX(4.00);\n\t\tList<Atom> inputList = new ArrayList<>();\n\t\tinputList.add(atomOne);\n\t\tinputList.add(atomTwo);\n\t\tinputList.add(atomFour);\n\t\tinputList.add(atomThree);\n\t\tgroup.addAtom(atomOne);\n\t\tgroup.addAtom(atomTwo);\n\t\tgroup.addAtom(atomFour);\n\t\taltLoc.addAtom(atomOne);\n\t\taltLoc.addAtom(atomTwo);\n\t\taltLoc.addAtom(atomThree);\n\t\tgroup.addAltLoc(altLoc);\n\t\tList<Atom> atomList = MmtfUtils.getAtomsForGroup(group);\n\t\tassertEquals(inputList, atomList);\n\t}\n\n\n\t/**\n\t * Test getting the number of bonds from a list of atoms.\n\t */\n\t@Test\n\tpublic void testGetNumBondsFromGroup() {\n\t\tList<Atom> atoms = new ArrayList<>();\n\t\tAtom atomOne = new AtomImpl();\n\t\tAtom atomTwo = new AtomImpl();\n\t\tAtom atomThree = new AtomImpl();\n\t\tatoms.add(atomOne);\n\t\tatoms.add(atomTwo);\n\t\tatoms.add(atomThree);\n\t\t// Make the same bond twice iwth different atom orders\n\t\tnew BondImpl(atomOne, atomTwo, 2);\n\t\tnew BondImpl(atomTwo, atomOne, 2);\n\t\t// Make the same bond twice\n\t\tnew BondImpl(atomOne, atomThree, 2);\n\t\tnew BondImpl(atomOne, atomThree, 2);\n\t\t// Make this bond twice with different orders\n\t\tnew BondImpl(atomTwo, atomThree, 2);\t\t\n\t\tnew BondImpl(atomTwo, atomThree, 1);\n\t\tassertEquals(3, MmtfUtils.getNumBondsInGroup(atoms));\n\t}\n\t/**\n\t * Test that getting the secondary structure type works.\n\t */\n\t@Test\n\tpublic void testGetSetSecStructType() {\n\t\tGroup group = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(group, 0);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 0);\n\t\tMmtfUtils.setSecStructType(group, 1);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 1);\n\t\tMmtfUtils.setSecStructType(group, 2);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 2);\n\t\tMmtfUtils.setSecStructType(group, 3);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 3);\n\t\tMmtfUtils.setSecStructType(group, 4);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 4);\n\t\tMmtfUtils.setSecStructType(group, 5);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 5);\n\t\tMmtfUtils.setSecStructType(group, 6);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 6);\n\t\tMmtfUtils.setSecStructType(group, 7);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 7);\n\t\t// Now test two null possibilities\n\t\tGroup newGroup = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(newGroup, -1);\n\t\tassertEquals(MmtfUtils.getSecStructType(newGroup), -1);\t\n\t\t// Now test two null possibilities\n\t\tGroup newerGroup = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(newerGroup, 10);\n\t\tassertEquals(MmtfUtils.getSecStructType(newerGroup), -1);\t\n\t}\n\n\t/**\n\t * Test that setting the secondary structure types behaves as expected.\n\t */\n\t@Test\n\tpublic void testGetSecStructTypeFromDsspIndex(){\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(0).name,\"pi Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(1).name,\"Bend\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(2).name,\"alpha Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(3).name,\"Extended\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(4).name,\"3-10 Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(5).name,\"Bridge\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(6).name,\"Turn\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(7).name,\"Coil\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(-1), null);\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(10), null);\n\n\t}\n\n\t/**\n\t * Test that getting the structure data info works.\n\t */\n\t@Test\n\tpublic void testGetStructureInfo() {\n\t\tStructure structure = new StructureImpl();\n\t\tChain chain = new ChainImpl();\n\t\tchain.setId(\"A\");\n\t\tMap<String,Integer> testMap = new HashMap<>();\n\t\ttestMap.put(\"A\", 0);\n\t\tList<Chain> chainList = new ArrayList<>();\n\t\tchainList.add(chain);\n\t\tGroup group = new AminoAcidImpl();\n\t\tchain.addGroup(group);\n\t\tAtom atomOne = new AtomImpl();\n\t\tAtom atomTwo = new AtomImpl();\n\t\tList<Atom> atomList = new ArrayList<>();\n\t\tatomList.add(atomOne);\n\t\tatomList.add(atomTwo);\n\t\tnew BondImpl(atomOne, atomTwo, 1);\n\t\tstructure.addChain(chain);\n\t\tgroup.addAtom(atomOne);\n\t\tgroup.addAtom(atomTwo);\n\t\t// Get the structure\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = MmtfUtils.getStructureInfo(structure);\n\t\tassertEquals(mmtfSummaryDataBean.getAllAtoms(), atomList);\n\t\tassertEquals(testMap, mmtfSummaryDataBean.getChainIdToIndexMap());\n\t\tassertEquals(chainList, mmtfSummaryDataBean.getAllChains());\n\t\tassertEquals(1, mmtfSummaryDataBean.getNumBonds());\n\t}\n\n\tprivate Set<Atom> findDuplicates(List<Atom> listContainingDuplicates)\n\t{ \n\t\tfinal Set<Atom> setToReturn = new HashSet<>(); \n\t\tfinal Set<Atom> set1 = new HashSet<>();\n\n\t\tfor (Atom yourInt : listContainingDuplicates)\n\t\t{\n\t\t\tif (!set1.add(yourInt))\n\t\t\t{\n\t\t\t\tsetToReturn.add(yourInt);\n\t\t\t}\n\t\t}\n\t\treturn setToReturn;\n\t}\n\n\t/**\n\t * Test that the NCS data can be roundtripped.\n\t */\n\t@Test\n\tpublic void testGetNcsMatrix() {\n\t\tdouble[][] testData = new double[][] {{1.0, 2.0,3.0,4.0,\n\t\t\t11.0,12.0,13.0,14.0,\n\t\t\t21.0,22.0,23.0,24.0,\n\t\t\t31.0,32.0,33.0,34.0}};\n\t\t\ttestInput(testData);\n\t}\n\n\t/**\n\t * Test that the NCS data can be roundtripped.\n\t */\n\t@Test\n\tpublic void testEmptyNcsMatrix() {\n\t\tdouble[][] testData = new double[0][0];\n\t\ttestInput(testData);\n\t\tdouble[][] output = MmtfUtils.getNcsAsArray(new Matrix4d[0]);\n\t\tassertNotNull(output);\n\t}\n\n\t/**\n\t * Test what happens if the NCS is null\n\t */\n\t@Test\n\tpublic void testNullNcsMatrix(){\n\t\tdouble[][] output = MmtfUtils.getNcsAsArray(null);\n\t\tassertNotNull(output);\n\t\tMatrix4d[] outputMat = MmtfUtils.getNcsAsMatrix4d(null);\n\t\tassertNull(outputMat);\n\t\tdouble[][] outputMatArr = MmtfUtils.getNcsAsArray(outputMat);\n\t\tassertNotNull(outputMatArr);\n\t}\n\n\n\t/**\n\t * Test that the NCS data can be roundtripped - when two matrices are present.\n\t */\n\t@Test\n\tpublic void testGetNcsMatrixHard() {\n\t\tdouble[][] testData = new double[][] {{1.0, 2.0,3.0,4.0,\n\t\t\t11.0,12.0,13.0,14.0,\n\t\t\t21.0,22.0,23.0,24.0,\n\t\t\t31.0,32.0,33.0,34.0,},{\n\t\t\t\t1.0, 2.0,3.0,4.0,\n\t\t\t\t11.0,12.0,13.0,14.0,\n\t\t\t\t21.0,22.0,23.0,24.0,\n\t\t\t\t31.0,32.0,33.0,34.0}};\n\t\t\t\ttestInput(testData);\n\t}\n\n\tprivate void testInput(double[][] testData) {\n\t\tMatrix4d[] matArr = MmtfUtils.getNcsAsMatrix4d(testData);\n\t\tdouble[][] roundTrippedData = MmtfUtils.getNcsAsArray(matArr);\n\t\tfor(int i=0; i<testData.length; i++){\n\t\t\tassertArrayEquals(testData[i], roundTrippedData[i], 0.0);\t\t\n\t\t}\n\t}\n}\n\n","changedTest":"","commitMessage":"Fix for #770, use LinkedHashMaps to keep order of biological assembly\nrecords, added unit test for 3bw1.","test_commitMessage":"","allZero":false}