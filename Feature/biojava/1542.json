{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/io/FastaAFPChainConverter.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/io/FastaAFPChainConverterTest.java","prod_time":"2013-06-11 06:37:21","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":3,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"f76aaed083f4c8093345e71dc1a0224d45bd5154","test_commitID":"","isfound":"not found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AlignmentTools;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.FastaReaderHelper;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows Exception {\n\t\tLinkedHashMap<String, ProteinSequence> sequences = FastaReaderHelper.readFastaProteinSequence(fastaFile);\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws Exception {\n\t\treturn fastaToAfpChain(new ProteinSequence(sequence1), new ProteinSequence(sequence2), structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequence1 == null || sequence2 == null || structure1 == null || structure2 == null)\n\t\t\treturn null;\n\n\t\tResidueNumber[] rn1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] rn2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\tList<ResidueNumber> participating1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> participating2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < rn1.length; i++) {\n\t\t\tif (rn1[i] != null && rn2[i] != null) {\n\t\t\t\tparticipating1.add(rn1[i]);\n\t\t\t\tparticipating2.add(rn2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] participating1Array = new ResidueNumber[participating1.size()];\n\t\tfor (int i = 0; i < participating1.size(); i++) {\n\t\t\tparticipating1Array[i] = participating1.get(i);\n\t\t}\n\t\tResidueNumber[] participating2Array = new ResidueNumber[participating2.size()];\n\t\tfor (int i = 0; i < participating2.size(); i++) {\n\t\t\tparticipating2Array[i] = participating2.get(i);\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, participating1Array, participating2Array);\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tAtomCache cache = new AtomCache();\n\t\tStructure structure1 = cache.getStructure(args[1]);\n\t\tStructure structure2 = cache.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","changedPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AlignmentTools;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.FastaReaderHelper;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows Exception {\n\t\tLinkedHashMap<String, ProteinSequence> sequences = FastaReaderHelper.readFastaProteinSequence(fastaFile);\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws Exception {\n\t\treturn fastaToAfpChain(new ProteinSequence(sequence1), new ProteinSequence(sequence2), structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\t\t\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tif (sequence1 == null || sequence2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A sequence is null\");\n\t\t}\n\t\t\n\t\tResidueNumber[] rn1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] rn2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\tList<ResidueNumber> participating1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> participating2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < rn1.length; i++) {\n\t\t\tif (rn1[i] != null && rn2[i] != null) {\n\t\t\t\tparticipating1.add(rn1[i]);\n\t\t\t\tparticipating2.add(rn2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] participating1Array = new ResidueNumber[participating1.size()];\n\t\tfor (int i = 0; i < participating1.size(); i++) {\n\t\t\tparticipating1Array[i] = participating1.get(i);\n\t\t}\n\t\tResidueNumber[] participating2Array = new ResidueNumber[participating2.size()];\n\t\tfor (int i = 0; i < participating2.size(); i++) {\n\t\t\tparticipating2Array[i] = participating2.get(i);\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, participating1Array, participating2Array);\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tAtomCache cache = new AtomCache();\n\t\tStructure structure1 = cache.getStructure(args[1]);\n\t\tStructure structure2 = cache.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.custommonkey.xmlunit.DetailedDiff;\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.Difference;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.custommonkey.xmlunit.examples.RecursiveElementNameAndTextQualifier;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A test for {@link FastaAFPChainConverter}.\n * @author dmyersturnbull\n *\n */\npublic class FastaAFPChainConverterTest {\n\n\tstatic {\n\t\tXMLUnit.setIgnoreWhitespace(true);\n\t\tXMLUnit.setIgnoreComments(true);\n\t\tXMLUnit.setIgnoreAttributeOrder(true);\n\t}\n\n\tpublic static void printDetailedDiff(Diff diff, PrintStream ps) {\n\t\tDetailedDiff detDiff = new DetailedDiff(diff);\n\t\tfor (Object object : detDiff.getAllDifferences()) {\n\t\t\tDifference difference = (Difference) object;\n\t\t\tps.println(difference);\n\t\t}\n\t}\n\n\t/**\n\t * Compares two XML files without regard to the order of elements or attributes, and ignoring any element named \\\"releaseDate\\\".\n\t * @return Whether the files are \\\"similar\\\"\n\t */\n\tpublic static boolean compareXml(File expectedFile, File actualFile) {\n\t\ttry {\n\t\t\tFileReader expectedFr = new FileReader(expectedFile);\n\t\t\tFileReader actualFr = new FileReader(actualFile);\n\t\t\tDiff diff = new Diff(expectedFr, actualFr);\n\t\t\t// ignore order\n\t\t\t// look at element, id, and weight (weight is a nested element)\n\t\t\tdiff.overrideElementQualifier(new RecursiveElementNameAndTextQualifier());\n\t\t\tfinal boolean isSimilar = diff.similar();\n\t\t\tif (!isSimilar) printDetailedDiff(diff, System.err);\n\t\t\texpectedFr.close();\n\t\t\tactualFr.close();\n\t\t\treturn isSimilar;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() {\n\t\tcache = new AtomCache();\n\t}\n\t\n\t@Test\n\tpublic void testIncomplete() throws IOException, StructureException {\n\t\tStructure s1 = cache.getStructure(\"1w0p\");\n\t\tStructure s2 = cache.getStructure(\"1qdm\");\n\t\tProteinSequence seq1 = new ProteinSequence(\"GWGG----SEL--YRRNTSLNS--QQDW-------QSNAKIRIVDGAA-----NQIQ\");\n\t\tProteinSequence seq2 = new ProteinSequence(\"WMQNQLAQNKT--QDLILDYVNQLCNRL---PSPMESAV----DCGSLGSMPDIEFT\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.fastaToAfpChain(seq1, seq2, s1, s2);\n\t\tassertEquals(\"Wrong number of EQRs\", 33, afpChain.getNrEQR());\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tFile expected = new File(\"src/test/resources/1w0p_1qdm.xml\");\n\t\tFile x = File.createTempFile(\"1w0p_1qdm_output\", \"xml.tmp\");\n\t\tx.deleteOnExit();\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(x));\n\t\tbw.write(xml);\n\t\tbw.close();\n\t\tassertTrue(\"AFPChain is wrong\", compareXml(expected, x));\n\t}\n\n}\n","changedTest":"","commitMessage":"Throw an exception if a structure or sequence is null (just safer).","test_commitMessage":"","allZero":false}