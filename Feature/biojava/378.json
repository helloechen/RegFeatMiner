{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/util/MultipleAlignmentWriter.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/util/TestMultipleAlignmentWriter.java","prod_time":"2015-07-24 00:02:21","test_time":"2015-07-24 00:13:30","type":"RENAME","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"e18e02cb442c88ac3e61df9441e6ffc00aae034c","test_commitID":"d8c5d2fe6025a432a240a9154b422b13bda64a42","isfound":"found test change","originPro":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.util.PrettyXMLWriter;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.xml.MultipleAlignmentXMLConverter;\n\n/**\n * This class contains functions for the conversion of \n * {@link MultipleAlignment} to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues, \n * Transformation Matrices, XML.\n * \n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence \n\t * alignment String in FASTA format.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\t\t\n\t\t//Get the alignment sequences\n\t\tList<String> alnSequences = \n\t\t\t\tMultipleAlignmentTools.getSequenceAlignment(alignment);\n\t\t\n\t\tString fasta = \"\";\n\t\tfor (int st=0; st<alignment.size(); st++){\n\t\t\t//Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\"+alignment.getEnsemble().getStructureNames().get(st)+\n\t\t\t\t\t\"\\n\"+ alnSequences.get(st)+\"\\n\";\n\t\t}\t\n\t\treturn fasta;\n\t}\n\t\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format. \n\t * Includes summary information about the alignment in the top and a \n\t * multiple sequence alignment at the bottom.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\t\t\n\t\t//Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString()+\"\\n\\n\");\n\t\t\n\t\t//Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools.\n\t\t\t\tgetSequenceAlignment(alignment, mapSeqToStruct);\n\t\t\n\t\t//Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos=0; pos<alnSequences.get(0).length(); pos++){\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(\n\t\t\t\t\talignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) {\n\t\t\t\tblockNumbers = blockNumbers.concat(\"\"+(blockNr+1));\n\t\t\t} else blockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\t\t\n\t\t//Write the Sequence Alignment\n\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\tif (str<9) {\n\t\t\t\tfatcat.append(\"Chain 0\"+(str+1)+\n\t\t\t\t\t\t\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\t} else {\n\t\t\t\tfatcat.append(\"Chain \"+(str+1)+\n\t\t\t\t\t\t\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\t}\n\t\t\tif (str!=alignment.size()-1) {\n\t\t\t\tfatcat.append(\"          \"+blockNumbers+\"\\n\");\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\t\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of \n\t * aligned residues.\n\t * Format is one line per residue group, tab delimited:\n\t * <ul><li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)\n\t * </li></ul>\n\t * Example:\n\t * <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>Note that this format loses information about blocks.\n\t * \n\t * @param multAln MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t//Write structure names & PDB codes\n\t\tfor (int str=0; str<multAln.size(); str++){\n\t\t\tresidueGroup.append(\"#Struct\"+(str+1)+\":\\t\");\n\t\t\tresidueGroup.append(\n\t\t\t\t\tmultAln.getEnsemble().getStructureNames().get(str));\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t//Whrite header for columns\n\t\tfor (int str=0; str<multAln.size(); str++) residueGroup.append(\n\t\t\t\t\"#Num\"+(str+1)+\"\\tChain\"+(str+1)+\"\\tAA\"+(str+1)+\"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\t\t\n\t\t//Write optimally aligned pairs\n\t\tfor(Block b:multAln.getBlocks()) {\n\t\t\tfor(int res=0;res<b.length();res++) {\n\t\t\t\tfor (int str=0; str<multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null){\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getEnsemble().\n\t\t\t\t\t\t\t\tgetAtomArrays().get(str)[residue];\n\t\t\n\t\t\t\t\t\tresidueGroup.append(\n\t\t\t\t\t\t\t\tatom.getGroup().getResidueNumber().toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\n\t\t\t\t\t\t\t\tatom.getGroup().getChain().getChainID());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\t\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String \n\t * output.\n\t * \n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\t\tList<Matrix4d> transforms = alignment.getTransformations();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++){\n\t\t\t\n\t\t\tList<Matrix4d> btransforms = \n\t\t\t\t\talignment.getBlockSets().get(bs).getTransformations();\n\t\t\tif (btransforms == null && bs==0) btransforms = transforms;\n\t\t\tif (btransforms == null || btransforms.size() < 1) continue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \" );\n\t\t\t\ttxt.append(bs+1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tString origString = \"ref\";\n\n\t\t\t\ttxt.append(String.format(\"     X\"+(str+1)+ \" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Y\"+(str+1)+\" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,1), \n\t\t\t\t\t\tbtransforms.get(str).getElement(1,2), \n\t\t\t\t\t\tbtransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Z\"+(str+1)+\" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,1), \n\t\t\t\t\t\tbtransforms.get(str).getElement(2,2), \n\t\t\t\t\t\tbtransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n\t\n\t/**\n\t * Converts all the information of a multiple alignment ensemble into an\n\t * XML String format. Cached variables, like transformation matrices and\n\t * scores, are also converted.\n\t * \n\t * @param ensemble the MultipleAlignmentEnsemble to convert.\n\t * @return String XML representation of the ensemble\n\t * @throws IOException\n\t * @see MultipleAlignmentXMLConverter Helper methods for XML conversion\n\t */\n\tpublic static String toXML(MultipleAlignmentEnsemble ensemble) \n\t\t\tthrows IOException {\n\t\t\n\t\tStringWriter result = new StringWriter();\n\t\tPrintWriter writer = new PrintWriter(result);\n\t\tPrettyXMLWriter xml = new PrettyXMLWriter(writer);\n\t\t\n\t\tMultipleAlignmentXMLConverter.printXMLensemble(xml, ensemble);\n\t\t\n\t\twriter.close();\n\t\t\n\t\treturn result.toString();\n\t}\n}","changedPro":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.util.PrettyXMLWriter;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.xml.MultipleAlignmentXMLConverter;\n\n/**\n * This class contains functions for the conversion of \n * {@link MultipleAlignment} to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues, \n * Transformation Matrices, XML.\n * \n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence \n\t * alignment String in FASTA format.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\t\t\n\t\t//Get the alignment sequences\n\t\tList<String> alnSequences = \n\t\t\t\tMultipleAlignmentTools.getSequenceAlignment(alignment);\n\t\t\n\t\tString fasta = \"\";\n\t\tfor (int st=0; st<alignment.size(); st++){\n\t\t\t//Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\"+alignment.getEnsemble().getStructureNames().get(st)+\n\t\t\t\t\t\"\\n\"+ alnSequences.get(st)+\"\\n\";\n\t\t}\t\n\t\treturn fasta;\n\t}\n\t\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format. \n\t * Includes summary information about the alignment in the top and a \n\t * multiple sequence alignment at the bottom.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\t\t\n\t\t//Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString()+\"\\n\\n\");\n\t\t\n\t\t//Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools.\n\t\t\t\tgetSequenceAlignment(alignment, mapSeqToStruct);\n\t\t\n\t\t//Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos=0; pos<alnSequences.get(0).length(); pos++){\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(\n\t\t\t\t\talignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) {\n\t\t\t\tblockNumbers = blockNumbers.concat(\"\"+(blockNr+1));\n\t\t\t} else blockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\t\t\n\t\t//Write the Sequence Alignment\n\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\tif (str<9) {\n\t\t\t\tfatcat.append(\"Chain 0\"+(str+1)+\n\t\t\t\t\t\t\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\t} else {\n\t\t\t\tfatcat.append(\"Chain \"+(str+1)+\n\t\t\t\t\t\t\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\t}\n\t\t\tif (str!=alignment.size()-1) {\n\t\t\t\tfatcat.append(\"          \"+blockNumbers+\"\\n\");\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\t\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of \n\t * aligned residues.\n\t * Format is one line per residue group, tab delimited:\n\t * <ul><li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)\n\t * </li></ul>\n\t * Example:\n\t * <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>Note that this format loses information about blocks.\n\t * \n\t * @param multAln MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t//Write structure names & PDB codes\n\t\tfor (int str=0; str<multAln.size(); str++){\n\t\t\tresidueGroup.append(\"#Struct\"+(str+1)+\":\\t\");\n\t\t\tresidueGroup.append(\n\t\t\t\t\tmultAln.getEnsemble().getStructureNames().get(str));\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t//Whrite header for columns\n\t\tfor (int str=0; str<multAln.size(); str++) residueGroup.append(\n\t\t\t\t\"#Num\"+(str+1)+\"\\tChain\"+(str+1)+\"\\tAA\"+(str+1)+\"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\t\t\n\t\t//Write optimally aligned pairs\n\t\tfor(Block b:multAln.getBlocks()) {\n\t\t\tfor(int res=0;res<b.length();res++) {\n\t\t\t\tfor (int str=0; str<multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null){\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getAtomArrays().get(str)[residue];\n\t\t\n\t\t\t\t\t\tresidueGroup.append(\n\t\t\t\t\t\t\t\tatom.getGroup().getResidueNumber().toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\n\t\t\t\t\t\t\t\tatom.getGroup().getChain().getChainID());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\t\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String \n\t * output.\n\t * \n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++){\n\t\t\t\n\t\t\tList<Matrix4d> btransforms = \n\t\t\t\t\talignment.getBlockSet(bs).getTransformations();\n\t\t\tif (btransforms == null || btransforms.size() < 1) continue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \" );\n\t\t\t\ttxt.append(bs+1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tString origString = \"ref\";\n\n\t\t\t\ttxt.append(String.format(\"     X\"+(str+1)+ \" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Y\"+(str+1)+\" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,1), \n\t\t\t\t\t\tbtransforms.get(str).getElement(1,2), \n\t\t\t\t\t\tbtransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Z\"+(str+1)+\" = (%9.6f)*X\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+ \n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+ \n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,1), \n\t\t\t\t\t\tbtransforms.get(str).getElement(2,2), \n\t\t\t\t\t\tbtransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n\t\n\t/**\n\t * Converts all the information of a multiple alignment ensemble into an\n\t * XML String format. Cached variables, like transformation matrices and\n\t * scores, are also converted.\n\t * \n\t * @param ensemble the MultipleAlignmentEnsemble to convert.\n\t * @return String XML representation of the ensemble\n\t * @throws IOException\n\t * @see MultipleAlignmentXMLConverter Helper methods for XML conversion\n\t */\n\tpublic static String toXML(MultipleAlignmentEnsemble ensemble) \n\t\t\tthrows IOException {\n\t\t\n\t\tStringWriter result = new StringWriter();\n\t\tPrintWriter writer = new PrintWriter(result);\n\t\tPrettyXMLWriter xml = new PrettyXMLWriter(writer);\n\t\t\n\t\tMultipleAlignmentXMLConverter.printXMLensemble(xml, ensemble);\n\t\t\n\t\twriter.close();\n\t\t\n\t\treturn result.toString();\n\t}\n}","originTest":"package org.biojava.nbio.structure.align.multiple;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\nimport org.biojava.nbio.structure.StructureException;\r\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentWriter;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.*;\r\n\r\n/**\r\n * Test the correctness of various Text outputs \r\n * for {@link MultipleAlignment}s.<p>\r\n * Currently tested:\r\n * <ul><li>FASTA\r\n * <li>FatCat format\r\n * <li>Aligned Residues\r\n * <li>Transformation Matrices\r\n * <li>XML format\r\n * </ul>\r\n * \r\n * @author Aleix Lafita\r\n *\r\n */\r\npublic class TestMultipleAlignmentWriter {\r\n\r\n\tprivate MultipleAlignment alignment1;\r\n\tprivate MultipleAlignment alignment2;\r\n\r\n\t/**\r\n\t * Build the alignments in common for every writer output, \r\n\t * so that they do not have to be created each time.\r\n\t * @throws IOException \r\n\t * @throws StructureException \r\n\t */\r\n\tpublic TestMultipleAlignmentWriter() \r\n\t\t\tthrows StructureException, IOException{\r\n\r\n\t\talignment1 = TestSampleGenerator.testAlignment1();\r\n\t\talignment2 = TestSampleGenerator.testAlignment2();\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFASTA1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.fasta\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFASTA2() throws IOException {\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.fasta\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFatCat1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.fatcat\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testFatCat2() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.fatcat\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testAlignedResidues1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1_alnres.tsv\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testAlignedResidues2() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2_alnres.tsv\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testTransformMatrices1() throws IOException{\r\n\t\t\r\n\t\tString result = MultipleAlignmentWriter.\r\n\t\t\t\ttoTransformMatrices(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.transforms\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testTransformMatrices2() throws IOException{\r\n\t\t\r\n\t\tString result = MultipleAlignmentWriter.\r\n\t\t\t\ttoTransformMatrices(alignment2);\r\n\t\tSystem.out.println(result);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.transforms\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testXMLformat1() throws IOException{\r\n\r\n\t\tMultipleAlignmentEnsemble ensemble = alignment1.getEnsemble();\r\n\t\tString result = MultipleAlignmentWriter.toXML(ensemble);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.xml\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testXMLformat2() throws IOException{\r\n\r\n\t\tMultipleAlignmentEnsemble ensemble = alignment2.getEnsemble();\r\n\t\tString result = MultipleAlignmentWriter.toXML(ensemble);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.xml\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n}","changedTest":"package org.biojava.nbio.structure.align.multiple.util;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\n\r\nimport org.biojava.nbio.structure.StructureException;\r\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\r\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\r\nimport org.biojava.nbio.structure.align.multiple.TestSampleGenerator;\r\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentWriter;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.*;\r\n\r\n/**\r\n * Test the correctness of various Text outputs \r\n * for {@link MultipleAlignment}s.<p>\r\n * Currently tested:\r\n * <ul><li>FASTA\r\n * <li>FatCat format\r\n * <li>Aligned Residues\r\n * <li>Transformation Matrices\r\n * <li>XML format\r\n * </ul>\r\n * \r\n * @author Aleix Lafita\r\n *\r\n */\r\npublic class TestMultipleAlignmentWriter {\r\n\r\n\tprivate MultipleAlignment alignment1;\r\n\tprivate MultipleAlignment alignment2;\r\n\r\n\t/**\r\n\t * Build the alignments in common for every writer output, \r\n\t * so that they do not have to be created each time.\r\n\t * @throws IOException \r\n\t * @throws StructureException \r\n\t */\r\n\tpublic TestMultipleAlignmentWriter() \r\n\t\t\tthrows StructureException, IOException{\r\n\r\n\t\talignment1 = TestSampleGenerator.testAlignment1();\r\n\t\talignment2 = TestSampleGenerator.testAlignment2();\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFASTA1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.fasta\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFASTA2() throws IOException {\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.fasta\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testFatCat1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.fatcat\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testFatCat2() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.fatcat\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testAlignedResidues1() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1_alnres.tsv\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testAlignedResidues2() throws IOException{\r\n\r\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment2);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2_alnres.tsv\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testTransformMatrices1() throws IOException{\r\n\t\t\r\n\t\tString result = MultipleAlignmentWriter.\r\n\t\t\t\ttoTransformMatrices(alignment1);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.transforms\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testTransformMatrices2() throws IOException{\r\n\t\t\r\n\t\tString result = MultipleAlignmentWriter.\r\n\t\t\t\ttoTransformMatrices(alignment2);\r\n\t\tSystem.out.println(result);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.transforms\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\r\n\t}\r\n\r\n\t@Test\r\n\tpublic void testXMLformat1() throws IOException{\r\n\r\n\t\tMultipleAlignmentEnsemble ensemble = alignment1.getEnsemble();\r\n\t\tString result = MultipleAlignmentWriter.toXML(ensemble);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA1.xml\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testXMLformat2() throws IOException{\r\n\r\n\t\tMultipleAlignmentEnsemble ensemble = alignment2.getEnsemble();\r\n\t\tString result = MultipleAlignmentWriter.toXML(ensemble);\r\n\r\n\t\tFileReader file = new FileReader(\r\n\t\t\t\t\"src/test/resources/testMSTA2.xml\");\r\n\t\tBufferedReader reader = new BufferedReader(file);\r\n\t\tString line = null;\r\n\t\tStringBuilder stringBuilder = new StringBuilder();\r\n\r\n\t\twhile ((line = reader.readLine()) != null) {\r\n\t\t\tstringBuilder.append(line);\r\n\t\t\tstringBuilder.append(\"\\n\");\r\n\t\t}\r\n\t\treader.close();\r\n\r\n\t\tString expected = stringBuilder.toString();\r\n\t\tassertEquals(expected,result);\r\n\t}\r\n}","commitMessage":"Remove the 3D transformations in MultipleAlignment\n\nIt was confusing to have the 3D information duplicated in\nMultipleAlignment and BlockSet, now this information is only stored in\nthe last object type. Update all methods that used 3D information.","test_commitMessage":"Rename and move Tests for consistency","allZero":false}