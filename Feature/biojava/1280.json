{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleProfile.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleProfileTest.java","prod_time":"2010-09-29 03:03:29","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":24,"add_classname_line":0,"add_condition_line":10,"add_field_line":1,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":3,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"0ace05c9131ba81996a659c57e4d5152a272fd2f","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfileView;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.compound.AmbiguityDNACompoundSet;\nimport org.biojava3.core.sequence.compound.AmbiguityRNACompoundSet;\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\nimport org.biojava3.core.sequence.compound.RNACompoundSet;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Profile<S, C> {\n\n    private List<AlignedSequence<S, C>> list;\n    private List<S> originals;\n    private int length;\n\n    /**\n     * Creates a pair profile for the given already aligned sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @throws IllegalArgumentException if sequences differ in size\n     */\n    protected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n        if (query.getLength() != target.getLength()) {\n            throw new IllegalArgumentException(\"Aligned sequences differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<S, C>>();\n        list.add(query);\n        list.add(target);\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.add((S) query.getOriginalSequence());\n        originals.add((S) target.getOriginalSequence());\n        originals = Collections.unmodifiableList(originals);\n        length = query.getLength();\n    }\n\n    /**\n     * Creates a profile from a single sequence.\n     *\n     * @param sequence sequence to seed profile\n     */\n    public SimpleProfile(S sequence) {\n        List<Step> s = new ArrayList<Step>();\n        for (int i = 0; i < sequence.getLength(); i++) {\n            s.add(Step.COMPOUND);\n        }\n        list = new ArrayList<AlignedSequence<S, C>>();\n        list.add(new SimpleAlignedSequence<S, C>(sequence, s));\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.add(sequence);\n        originals = Collections.unmodifiableList(originals);\n        length = sequence.getLength();\n    }\n\n    /**\n     * Creates a pair profile for the given sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n     * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n     * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    protected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n        if (sx.size() != sy.size()) {\n            throw new IllegalArgumentException(\"Alignments differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<S, C>>();\n        list.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n        list.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.add(query);\n        originals.add(target);\n        originals = Collections.unmodifiableList(originals);\n        length = sx.size();\n    }\n\n    /**\n     * Creates a pair profile for the given profiles.\n     *\n     * @param query the first profile of the pair\n     * @param target the second profile of the pair\n     * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n     */\n    protected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n        if (sx.size() != sy.size()) {\n            throw new IllegalArgumentException(\"Alignments differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<S, C>>();\n        for (AlignedSequence<S, C> s : query) {\n            list.add(new SimpleAlignedSequence<S, C>(s, sx));\n        }\n        for (AlignedSequence<S, C> s : target) {\n            list.add(new SimpleAlignedSequence<S, C>(s, sy));\n        }\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.addAll(query.getOriginalSequences());\n        originals.addAll(target.getOriginalSequences());\n        originals = Collections.unmodifiableList(originals);\n        length = sx.size();\n    }\n\n    // methods for Profile\n\n    @Override\n    public AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n        return list.get(listIndex - 1);\n    }\n\n    @Override\n    public AlignedSequence<S, C> getAlignedSequence(S sequence) {\n        for (AlignedSequence<S, C> s : list) {\n            if (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n                return s;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public List<AlignedSequence<S, C>> getAlignedSequences() {\n        return list;\n    }\n\n    @Override\n    public List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n        List<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n        for (int i : listIndices) {\n            tempList.add(getAlignedSequence(i));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n        List<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n        for (S s : sequences) {\n            tempList.add(getAlignedSequence(s));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public C getCompoundAt(int listIndex, int alignmentIndex) {\n        return getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public C getCompoundAt(S sequence, int alignmentIndex) {\n        AlignedSequence<S, C> s = getAlignedSequence(sequence);\n        return (s == null) ? null : s.getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public int[] getCompoundCountsAt(int alignmentIndex) {\n        return getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n    }\n\n    @Override\n    public int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n        int[] counts = new int[compounds.size()];\n        C gap = getCompoundSet().getCompoundForString(\"-\");\n        int igap = compounds.indexOf(gap);\n        for (C compound : getCompoundsAt(alignmentIndex)) {\n            int i = compounds.indexOf(compound);\n            if (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n                counts[i]++;\n            }\n        }\n        return counts;\n    }\n\n    @Override\n    public List<C> getCompoundsAt(int alignmentIndex) {\n        // TODO handle circular alignments\n        List<C> column = new ArrayList<C>();\n        for (AlignedSequence<S, C> s : list) {\n            column.add(s.getCompoundAt(alignmentIndex));\n        }\n        return Collections.unmodifiableList(column);\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return list.get(0).getCompoundSet();\n    }\n\n    @Override\n    public float[] getCompoundWeightsAt(int alignmentIndex) {\n        return getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n    }\n\n    @Override\n    public float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n        float[] weights = new float[compounds.size()];\n        int[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n        float total = 0.0f;\n        for (int i : counts) {\n            total += i;\n        }\n        if (total > 0.0f) {\n            for (int i = 0; i < weights.length; i++) {\n                weights[i] = counts[i]/total;\n            }\n        }\n        return weights;\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int[] getIndicesAt(int alignmentIndex) {\n        int[] indices = new int[list.size()];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n        }\n        return indices;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public List<S> getOriginalSequences() {\n        return originals;\n    }\n\n    @Override\n    public int getSize() {\n        int size = 0;\n        for (AlignedSequence<S, C> s : list) {\n            size += s.getOverlapCount();\n        }\n        return size;\n    }\n\n    @Override\n    public ProfileView<S, C> getSubProfile(Location location) {\n        // TODO ProfileView<S, C> getSubProfile(Location)\n        return null;\n    }\n\n    @Override\n    public boolean hasGap(int alignmentIndex) {\n        C gap = getCompoundSet().getCompoundForString(\"-\");\n        for (C compound : getCompoundsAt(alignmentIndex)) {\n            if (getCompoundSet().compoundsEquivalent(compound, gap)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isCircular() {\n        for (AlignedSequence<S, C> s : list) {\n            if (s.isCircular()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString(int width) {\n        return toString(width, null, getIDFormat(), true, true, true, true, true);\n    }\n\n    @Override\n    public String toString(StringFormat format) {\n        switch (format) {\n        case ALN:\n        case CLUSTALW:\n        default:\n            return toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), getIDFormat() + \"   \", false, true,\n                    true, false, true);\n        case FASTA:\n            return toString(60, null, \">%s%n\", false, false, false, false, false);\n        case GCG:\n        case MSF:\n            String idFormat = getIDFormat();\n            StringBuilder header = new StringBuilder();\n            header.append(String.format(\"MSA from BioJava%n%n MSF: %d  Type: %s  Check: %d ..%n%n\", getLength(),\n                    getGCGType(), getGCGChecksum()));\n            for (AlignedSequence<S, C> as : list) {\n                header.append(String.format(\" Name: \" + idFormat + \" Len: %d  Check: %4d  Weight: %.1f%n\",\n                        as.getAccession(), getLength(), getGCGChecksum(as), 1.0f)); // TODO show weights in MSF header\n            }\n            header.append(String.format(\"%n//%n%n\"));\n            // TODO? convert gap characters to '.'\n            return toString(50, header.toString(), idFormat, false, false, true, false, false);\n        }\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return toString(getLength(), null, null, false, false, false, false, false);\n    }\n\n    // method for Iterable\n\n    @Override\n    public Iterator<AlignedSequence<S, C>> iterator() {\n        return list.iterator();\n    }\n\n    // helper methods\n\n    // calculates GCG checksum for entire Profile\n    private int getGCGChecksum() {\n        int check = 0;\n        for (AlignedSequence<S, C> as : list) {\n            check += getGCGChecksum(as);\n        }\n        return check % 10000;\n    }\n\n    // calculates GCG checksum for a given Sequence\n    private int getGCGChecksum(AlignedSequence<S, C> sequence) {\n        String s = sequence.toString().toUpperCase();\n        int count = 0, check = 0;\n        for (int i = 0; i < s.length(); i++) {\n            count++;\n            check += count * s.charAt(i);\n            if (count == 57) {\n                count = 0;\n            }\n        }\n        return check % 10000;\n    }\n\n    // determines GCG type\n    private String getGCGType() {\n        CompoundSet<C> cs = getCompoundSet();\n        return (cs == DNACompoundSet.getDNACompoundSet() || cs == AmbiguityDNACompoundSet.getDNACompoundSet()) ? \"D\" :\n                (cs == RNACompoundSet.getRNACompoundSet() || cs == AmbiguityRNACompoundSet.getRNACompoundSet()) ? \"R\" :\n                \"P\";\n    }\n\n    // creates format String for accession IDs\n    private String getIDFormat() {\n        int length = 0;\n        for (AlignedSequence<S, C> as : list) {\n            length = Math.max(length, (as.getAccession() == null) ? 0 : as.getAccession().toString().length());\n        }\n        return (length == 0) ? null : \"%-\" + (length + 1) + \"s\";\n    }\n\n    // creates formatted String\n    private String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n            boolean interlaced, boolean aligIndices, boolean aligConservation) {\n        // TODO handle circular alignments\n        StringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n        width = Math.max(1, width);\n        int seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n        String seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n        if (interlaced) {\n            String aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n                    \"d%n\";\n            for (int i = 0; i < getLength(); i += width) {\n                int start = i + 1, end = Math.min(getLength(), i + width);\n                if (i > 0) {\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligIndices) {\n                    if (end < i + width) {\n                        int line = end - start + 1;\n                        aligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n                                \"d%n\";\n                    }\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, \"\"));\n                    }\n                    if (seqIndexPre) {\n                        s.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n                    }\n                    s.append(String.format(aligIndFormat, start, end));\n                }\n                for (AlignedSequence<S, C> as : list) {\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, as.getAccession()));\n                    }\n                    if (seqIndexPre) {\n                        s.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n                    }\n                    s.append(as.getSequenceAsString(start, end, Strand.UNDEFINED));\n                    if (seqIndexPost) {\n                        s.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n                    }\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligConservation) {\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, \"\"));\n                    }\n                    if (seqIndexPre) {\n                        s.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n                    }\n                    // TODO conservation annotation\n                    s.append(String.format(\"%n\"));\n                }\n            }\n        } else {\n            for (AlignedSequence<S, C> as : list) {\n                if (idFormat != null) {\n                    s.append(String.format(idFormat, as.getAccession()));\n                }\n                for (int i = 0; i < getLength(); i += width) {\n                    int start = i + 1, end = Math.min(getLength(), i + width);\n                    if (seqIndexPre) {\n                        s.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n                    }\n                    s.append(as.getSequenceAsString(start, end, Strand.UNDEFINED));\n                    if (seqIndexPost) {\n                        s.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n                    }\n                    s.append(String.format(\"%n\"));\n                }\n            }\n        }\n        return s.toString();\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfileView;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.compound.AmbiguityDNACompoundSet;\nimport org.biojava3.core.sequence.compound.AmbiguityRNACompoundSet;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\nimport org.biojava3.core.sequence.compound.RNACompoundSet;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\n\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Profile<S, C> {\n\n\tprivate List<AlignedSequence<S, C>> list;\n\tprivate List<S> originals;\n\tprivate int length;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tprotected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tif (query.getLength() != target.getLength()) {\n\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(query);\n\t\tlist.add(target);\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add((S) query.getOriginalSequence());\n\t\toriginals.add((S) target.getOriginalSequence());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = query.getLength();\n\t}\n\n\t/**\n\t * Creates a profile from a single sequence.\n\t *\n\t * @param sequence sequence to seed profile\n\t */\n\tpublic SimpleProfile(S sequence) {\n\t\tList<Step> s = new ArrayList<Step>();\n\t\tfor (int i = 0; i < sequence.getLength(); i++) {\n\t\t\ts.add(Step.COMPOUND);\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(sequence, s));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(sequence);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sequence.getLength();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tprotected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n\t\tlist.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query);\n\t\toriginals.add(target);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given profiles.\n\t *\n\t * @param query the first profile of the pair\n\t * @param target the second profile of the pair\n\t * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n\t */\n\tprotected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (AlignedSequence<S, C> s : query) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sx));\n\t\t}\n\t\tfor (AlignedSequence<S, C> s : target) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sy));\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.addAll(query.getOriginalSequences());\n\t\toriginals.addAll(target.getOriginalSequences());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t// methods for Profile\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n\t\treturn list.get(listIndex - 1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(S sequence) {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences() {\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (int i : listIndices) {\n\t\t\ttempList.add(getAlignedSequence(i));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (S s : sequences) {\n\t\t\ttempList.add(getAlignedSequence(s));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int listIndex, int alignmentIndex) {\n\t\treturn getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(S sequence, int alignmentIndex) {\n\t\tAlignedSequence<S, C> s = getAlignedSequence(sequence);\n\t\treturn (s == null) ? null : s.getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex) {\n\t\treturn getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n\t\tint[] counts = new int[compounds.size()];\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tint igap = compounds.indexOf(gap);\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tint i = compounds.indexOf(compound);\n\t\t\tif (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\tcounts[i]++;\n\t\t\t}\n\t\t}\n\t\treturn counts;\n\t}\n\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\t// TODO handle circular alignments\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn list.get(0).getCompoundSet();\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex) {\n\t\treturn getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n\t\tfloat[] weights = new float[compounds.size()];\n\t\tint[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n\t\tfloat total = 0.0f;\n\t\tfor (int i : counts) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total > 0.0f) {\n\t\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = counts[i]/total;\n\t\t\t}\n\t\t}\n\t\treturn weights;\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int[] getIndicesAt(int alignmentIndex) {\n\t\tint[] indices = new int[list.size()];\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tindices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n\t\t}\n\t\treturn indices;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic List<S> getOriginalSequences() {\n\t\treturn originals;\n\t}\n\n\t@Override\n\tpublic int getSize() {\n\t\tint size = 0;\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tsize += s.getOverlapCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic ProfileView<S, C> getSubProfile(Location location) {\n\t\t// TODO ProfileView<S, C> getSubProfile(Location)\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasGap(int alignmentIndex) {\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tif (getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.isCircular()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, getIDFormat(), true, true, true, true, true);\n\t}\n\n\t@Override\n\tpublic String toString(StringFormat format) {\n\t\tswitch (format) {\n\t\tcase ALN:\n\t\tcase CLUSTALW:\n\t\tdefault:\n\t\t\treturn toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), getIDFormat() + \"   \", false, true,\n\t\t\t\t\ttrue, false, true);\n\t\tcase FASTA:\n\t\t\treturn toString(60, null, \">%s%n\", false, false, false, false, false);\n\t\tcase GCG:\n\t\tcase MSF:\n\t\t\tString idFormat = getIDFormat();\n\t\t\tStringBuilder header = new StringBuilder();\n\t\t\theader.append(String.format(\"MSA from BioJava%n%n MSF: %d  Type: %s  Check: %d ..%n%n\", getLength(),\n\t\t\t\t\tgetGCGType(), getGCGChecksum()));\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\theader.append(String.format(\" Name: \" + idFormat + \" Len: %d  Check: %4d  Weight: %.1f %n\",\n\t\t\t\t\t\tas.getAccession(), getLength(), getGCGChecksum(as), 1.0f)); // TODO show weights in MSF header\n\t\t\t}\n\t\t\theader.append(String.format(\"%n//%n%n\"));\n\t\t\t// TODO? convert gap characters to '.'\n\t\t\treturn toString(50, header.toString(), idFormat, false, false, true, false, false);\n\t\tcase PDBWEB:            \n\t\t\treturn toString(60,null,null, true,true,true,true,true );\n\t\t}\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false, false);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<AlignedSequence<S, C>> iterator() {\n\t\treturn list.iterator();\n\t}\n\n\t// helper methods\n\n\t// calculates GCG checksum for entire Profile\n\tprivate int getGCGChecksum() {\n\t\tint check = 0;\n\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\tcheck += getGCGChecksum(as);\n\t\t}\n\t\treturn check % 10000;\n\t}\n\n\t// calculates GCG checksum for a given Sequence\n\tprivate int getGCGChecksum(AlignedSequence<S, C> sequence) {\n\t\tString s = sequence.toString().toUpperCase();\n\t\tint count = 0, check = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tcount++;\n\t\t\tcheck += count * s.charAt(i);\n\t\t\tif (count == 57) {\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn check % 10000;\n\t}\n\n\t// determines GCG type\n\tprivate String getGCGType() {\n\t\tCompoundSet<C> cs = getCompoundSet();\n\t\treturn (cs == DNACompoundSet.getDNACompoundSet() || cs == AmbiguityDNACompoundSet.getDNACompoundSet()) ? \"D\" :\n\t\t\t(cs == RNACompoundSet.getRNACompoundSet() || cs == AmbiguityRNACompoundSet.getRNACompoundSet()) ? \"R\" :\n\t\t\t\t\"P\";\n\t}\n\n\t// creates format String for accession IDs\n\tprivate String getIDFormat() {\n\t\tint length = 0;\n\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\tlength = Math.max(length, (as.getAccession() == null) ? 0 : as.getAccession().toString().length());\n\t\t}\n\t\treturn (length == 0) ? null : \"%-\" + (length + 1) + \"s\";\n\t}\n\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n\t\t\tboolean interlaced, boolean aligIndices, boolean aligConservation) {\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\t\twidth = Math.max(1, width);\n\t\tint seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n\t\tString seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSequenceAsString(start, end, Strand.UNDEFINED));\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\n\t\t\t\t\tif ( aligConservation && list.size() == 2){\n\t\t\t\t\t\tif ( counter == 1)\n\t\t\t\t\t\t\tprintConservation(s,idFormat,seqIndexPad,seqIndexPre, start,end,list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (aligConservation) {\n\t\t\t\t\t// TODO conservation annotation\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSequenceAsString(start, end, Strand.UNDEFINED));\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tprivate void printConservation(StringBuilder s, String idFormat,\n\t\t\tint seqIndexPad, boolean seqIndexPre, int start, int end, List<AlignedSequence<S, C>> list2) {\n\t\tif ( list.size() == 2) {\n\n\t\t\tif (idFormat != null) {\n\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t}\n\t\t\t\n\t\t\tif (seqIndexPre) {\n\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t}\n\n\t\t\tAlignedSequence<S,C> as1 = list.get(0);\n\t\t\tAlignedSequence<S,C> as2 = list.get(1);\n\n\t\t\tString subseq1 = as1.getSequenceAsString(start, end, Strand.UNDEFINED);\n\t\t\tString subseq2 = as2.getSequenceAsString(start, end, Strand.UNDEFINED);\n\n\t\t\tfor ( int ii =0 ; ii < subseq1.length() ; ii++){\n\t\t\t\tif ( ii >= subseq2.length())\n\t\t\t\t\tbreak;\n\t\t\t\tchar c1 = subseq1.charAt(ii);\n\t\t\t\tchar c2 = subseq2.charAt(ii);\n\n\t\t\t\tif ( c1 == c2) \n\t\t\t\t\ts.append(\"|\");                    \t\t\t\n\t\t\t\telse if (  isSimilar(c1,c2))  \n\t\t\t\t\ts.append(\".\");\n\t\t\t\telse \n\t\t\t\t\ts.append(\" \");\n\t\t\t\t\t\t\n\t\t\t}\n\n\t\t\ts.append(String.format(\"%n\"));\n\n\t\t}\n\n\t}\n\n\tprivate static SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n\t\n\tprivate boolean isSimilar(char c1, char c2) {\n\t\t\n\t\tAminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\t\t\n\t\tAminoAcidCompound aa1 = set.getCompoundForString(\"\"+c1);\n\t\tAminoAcidCompound aa2 = set.getCompoundForString(\"\"+c2);\n\t\t\n\t\tshort val = matrix.getValue(aa1,aa2);\n\t\tif ( val > 0 )\n\t\t\treturn true;\n\t\t\n\t\treturn false;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.Profile.StringFormat;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class SimpleProfileTest {\n\n    private ProteinSequence query, target;\n    private Profile<ProteinSequence, AminoAcidCompound> global, local, single;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        query.setAccession(new AccessionID(\"Query\"));\n        target.setAccession(new AccessionID(\"Target\"));\n        global = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n                new Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}), 0, 0);\n        local = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n                Step.GAP, Step.COMPOUND}), 0, 1);\n        single = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query);\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleProfile() {\n        new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n                new Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND}), 0, 0);\n    }\n\n    @Test\n    public void testGetAlignedSequenceInt() {\n        assertEquals(global.getAlignedSequence(1).toString(), \"ARND-\");\n        assertEquals(global.getAlignedSequence(2).toString(), \"-R-DG\");\n        assertEquals(local.getAlignedSequence(1).toString(), \"RND\");\n        assertEquals(local.getAlignedSequence(2).toString(), \"R-D\");\n        assertEquals(single.getAlignedSequence(1).toString(), \"ARND\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds() {\n        global.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds2() {\n        global.getAlignedSequence(3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds3() {\n        local.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds4() {\n        local.getAlignedSequence(3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds5() {\n        single.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds6() {\n        single.getAlignedSequence(2);\n    }\n\n    @Test\n    public void testGetAlignedSequenceS() {\n        assertEquals(global.getAlignedSequence(query).toString(), \"ARND-\");\n        assertEquals(global.getAlignedSequence(target).toString(), \"-R-DG\");\n        assertNull(global.getAlignedSequence(new ProteinSequence(\"AR\")));\n        assertEquals(local.getAlignedSequence(query).toString(), \"RND\");\n        assertEquals(local.getAlignedSequence(target).toString(), \"R-D\");\n        assertNull(local.getAlignedSequence(new ProteinSequence(\"AR\")));\n        assertEquals(single.getAlignedSequence(query).toString(), \"ARND\");\n        assertNull(single.getAlignedSequence(target));\n    }\n\n    @Test\n    public void testGetAlignedSequences() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"-R-DG\");\n        list = local.getAlignedSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"RND\");\n        assertEquals(list.get(1).toString(), \"R-D\");\n        list = single.getAlignedSequences();\n        assertEquals(list.size(), 1);\n        assertEquals(list.get(0).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesIntArray() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(2, 1, 2);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"-R-DG\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n        list = local.getAlignedSequences(2, 2, 1);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"R-D\");\n        assertEquals(list.get(1).toString(), \"R-D\");\n        assertEquals(list.get(2).toString(), \"RND\");\n        list = single.getAlignedSequences(1, 1);\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND\");\n        assertEquals(list.get(1).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesSArray() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(query, query,\n                target);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n        list = local.getAlignedSequences(target, query, target);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"R-D\");\n        assertEquals(list.get(1).toString(), \"RND\");\n        assertEquals(list.get(2).toString(), \"R-D\");\n        list = single.getAlignedSequences(query, query);\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND\");\n        assertEquals(list.get(1).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetCompoundAtIntInt() {\n        assertEquals(global.getCompoundAt(1, 4).getShortName(), \"D\");\n        assertEquals(global.getCompoundAt(2, 3).getShortName(), \"-\");\n        assertEquals(local.getCompoundAt(1, 1).getShortName(), \"R\");\n        assertEquals(local.getCompoundAt(2, 2).getShortName(), \"-\");\n        assertEquals(single.getCompoundAt(1, 3).getShortName(), \"N\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds() {\n        global.getCompoundAt(0, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds2() {\n        global.getCompoundAt(3, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds3() {\n        global.getCompoundAt(1, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds4() {\n        global.getCompoundAt(2, 6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds5() {\n        local.getCompoundAt(0, 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds6() {\n        local.getCompoundAt(3, 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds7() {\n        local.getCompoundAt(1, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds8() {\n        local.getCompoundAt(2, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds9() {\n        single.getCompoundAt(1, 0);\n    }\n\n    @Test\n    public void testGetCompoundAtSInt() {\n        assertEquals(global.getCompoundAt(query, 2).getShortName(), \"R\");\n        assertEquals(global.getCompoundAt(target, 5).getShortName(), \"G\");\n        assertNull(global.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n        assertEquals(local.getCompoundAt(query, 2).getShortName(), \"N\");\n        assertEquals(local.getCompoundAt(target, 3).getShortName(), \"D\");\n        assertNull(local.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n        assertEquals(single.getCompoundAt(query, 2).getShortName(), \"R\");\n        assertNull(single.getCompoundAt(target, 3));\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds() {\n        global.getCompoundAt(query, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds2() {\n        global.getCompoundAt(target, 6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds3() {\n        local.getCompoundAt(target, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds4() {\n        local.getCompoundAt(query, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds5() {\n        single.getCompoundAt(query, 0);\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(global.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(local.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(single.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n    }\n\n    @Test\n    public void testGetCompoundsAt() {\n        List<AminoAcidCompound> column = global.getCompoundsAt(5);\n        assertEquals(column.size(), 2);\n        assertEquals(column.get(0).getShortName(), \"-\");\n        assertEquals(column.get(1).getShortName(), \"G\");\n        column = local.getCompoundsAt(2);\n        assertEquals(column.size(), 2);\n        assertEquals(column.get(0).getShortName(), \"N\");\n        assertEquals(column.get(1).getShortName(), \"-\");\n        column = single.getCompoundsAt(2);\n        assertEquals(column.size(), 1);\n        assertEquals(column.get(0).getShortName(), \"R\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds() {\n        global.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds2() {\n        global.getCompoundsAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds3() {\n        local.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds4() {\n        local.getCompoundsAt(4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds5() {\n        single.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds6() {\n        single.getCompoundsAt(5);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"E\")), -1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"R\")), 1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 2);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"K\")), -1);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"G\")), -1);\n    }\n\n    @Test\n    public void testGetIndicesAt() {\n        assertArrayEquals(global.getIndicesAt(1), new int[] {1, 1});\n        assertArrayEquals(global.getIndicesAt(2), new int[] {2, 1});\n        assertArrayEquals(global.getIndicesAt(3), new int[] {3, 1});\n        assertArrayEquals(global.getIndicesAt(4), new int[] {4, 2});\n        assertArrayEquals(global.getIndicesAt(5), new int[] {4, 3});\n        assertArrayEquals(local.getIndicesAt(1), new int[] {2, 1});\n        assertArrayEquals(local.getIndicesAt(2), new int[] {3, 1});\n        assertArrayEquals(local.getIndicesAt(3), new int[] {4, 2});\n        assertArrayEquals(single.getIndicesAt(1), new int[] {1});\n        assertArrayEquals(single.getIndicesAt(2), new int[] {2});\n        assertArrayEquals(single.getIndicesAt(3), new int[] {3});\n        assertArrayEquals(single.getIndicesAt(4), new int[] {4});\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds() {\n        global.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds2() {\n        global.getIndicesAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds3() {\n        local.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds4() {\n        local.getIndicesAt(4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds5() {\n        single.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds6() {\n        single.getIndicesAt(5);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 5);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"E\")), -1);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"R\")), 1);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 2);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"K\")), -1);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"G\")), -1);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(global.getLength(), 5);\n        assertEquals(local.getLength(), 3);\n        assertEquals(single.getLength(), 4);\n    }\n\n    @Test\n    public void testGetOriginalSequences() {\n        List<ProteinSequence> list = global.getOriginalSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0), query);\n        assertEquals(list.get(1), target);\n        list = local.getOriginalSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0), query);\n        assertEquals(list.get(1), target);\n        list = single.getOriginalSequences();\n        assertEquals(list.size(), 1);\n        assertEquals(list.get(0), query);\n    }\n\n    @Test\n    public void testGetSize() {\n        assertEquals(global.getSize(), 2);\n        assertEquals(local.getSize(), 2);\n        assertEquals(single.getSize(), 1);\n    }\n\n    @Ignore // TODO SimpleProfile.getSubProfile(Location)\n    @Test\n    public void testGetSubProfile() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(global.isCircular());\n        assertFalse(local.isCircular());\n        assertFalse(single.isCircular());\n    }\n\n    @Test\n    public void testToStringInt() {\n        // TODO conservation annotation\n        assertEquals(global.toString(3), String.format(\n                \"          1 3%n\" +\n                \"Query   1 ARN 3%n\" +\n                \"Target  1 -R- 1%n\" +\n                \"          %n%n\" +\n                \"          4 5%n\" +\n                \"Query   4 D- 4%n\" +\n                \"Target  2 DG 3%n\" +\n                \"          %n\"));\n        assertEquals(local.toString(4), String.format(\n                \"          1 3%n\" +\n                \"Query   2 RND 4%n\" +\n                \"Target  1 R-D 2%n\" +\n                \"          %n\"));\n        assertEquals(single.toString(4), String.format(\n                \"         1  4%n\" +\n                \"Query  1 ARND 4%n\" +\n                \"         %n\"));\n    }\n\n    @Test\n    public void testToStringFormatted() {\n        // TODO conservation annotation\n        assertEquals(global.toString(StringFormat.ALN), String.format(\n                \"CLUSTAL W MSA from BioJava%n%n\" +\n                \"Query     ARND- 4%n\" +\n                \"Target    -R-DG 3%n\" +\n                \"          %n\"));\n        assertEquals(local.toString(StringFormat.FASTA), String.format(\n                \">Query%n\" +\n                \"RND%n\" +\n                \">Target%n\" +\n                \"R-D%n\"));\n        assertEquals(single.toString(StringFormat.MSF), String.format(\n                \"MSA from BioJava%n%n\" +\n                \" MSF: 4  Type: P  Check: 735 ..%n%n\" +\n                \" Name: Query  Len: 4  Check:  735  Weight: 1.0%n\" +\n                \"%n//%n%n\" +\n                \"Query ARND%n\"));\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(global.toString(), String.format(\"ARND-%n-R-DG%n\"));\n        assertEquals(local.toString(), String.format(\"RND%nR-D%n\"));\n        assertEquals(single.toString(), String.format(\"ARND%n\"));\n    }\n\n    @Test\n    public void testIterator() {\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : global) {\n            assertEquals(s.toString().length(), 5);\n        }\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : local) {\n            assertEquals(s.toString().length(), 3);\n        }\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : single) {\n            assertEquals(s.toString().length(), 4);\n        }\n    }\n\n}\n","changedTest":"","commitMessage":"adding display of sequence conservation for pairwise alignments\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8258 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}