{"repository":"biojava","prod_path":"biojava-alignment/src/main/java/org/biojava/nbio/alignment/routines/AlignerHelper.java","test_path":"biojava-alignment/src/test/java/org/biojava/nbio/alignment/routines/AlignerHelperTest.java","prod_time":"2016-06-15 10:16:00","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":1,"add_condition_line":0,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":1,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"23136cb0f51ac7a04c3f50afb83624b268edc5f9","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on August 13, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment.routines;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n//import org.slf4j.Logger;\n//import org.slf4j.LoggerFactory;\n\n\n/**\n * Static utility to construct alignment routines from a common library of methods.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n */\npublic class AlignerHelper {\n\n\t//private static final Logger logger = LoggerFactory.getLogger(AlignerHelper.class);\n\n\t// types\n\n\t/**\n\t * Define a traceback pointer for the three edit operations: substitution (match/replacement of a query compound\n\t * with a target compound), deletion (removal of a query compound leaving a gap in the target sequence), and\n\t * insertion (addition of a target compound opening a gap in the query sequence).\n\t */\n\tpublic enum Last {\n\t\tSUBSTITUTION,\n\t\tDELETION,\n\t\tINSERTION\n\t}\n\n\t/**\n\t * Defines a 'cut' row for divide-and-conquer alignment in which a new anchor is found.\n\t */\n\tpublic static class Cut {\n\n\t\tprivate int queryIndex;\n\t\tprivate int[][] targetIndices, tiLast, ti1, ti2;\n\n\t\tpublic Cut(int queryIndex, int[] dim) {\n\t\t\tthis.queryIndex = queryIndex;\n\t\t\ttargetIndices = ti1 = new int[dim[1]][dim[2]];\n\t\t\tti2 = new int[dim[1]][dim[2]];\n\t\t}\n\n\t\tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\n\t\tpublic int getTargetIndex(int z) {\n\t\t\treturn targetIndices[targetIndices.length - 1][z];\n\t\t}\n\n\t\tpublic void update(int x, Subproblem subproblem, Last[][] pointers) {\n\t\t\tif (pointers[subproblem.getTargetStartIndex()].length == 1) {\n\t\t\t\tif (queryIndex == x - 1) {\n\t\t\t\t\tupdateLinearInitial(subproblem, pointers);\n\t\t\t\t} else if (queryIndex < x) {\n\t\t\t\t\tupdateLinearAdvance(subproblem, pointers);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (queryIndex == x - 1) {\n\t\t\t\t\tupdateInitial(subproblem, pointers);\n\t\t\t\t} else if (queryIndex < x) {\n\t\t\t\t\tupdateAdvance(subproblem, pointers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateAdvance(Subproblem subproblem, Last[][] pointers) {\n\t\t\ttiLast = targetIndices;\n\t\t\ttargetIndices = (targetIndices == ti2) ? ti1 : ti2;\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y - 1][pointers[y][0].ordinal()];\n\t\t\t\t}\n\t\t\t\tif (pointers[y][1] != null) {\n\t\t\t\t\ttargetIndices[y][1] = tiLast[y][pointers[y][1].ordinal()];\n\t\t\t\t}\n\t\t\t\tif (pointers[y][2] != null) {\n\t\t\t\t\ttargetIndices[y][2] = targetIndices[y - 1][pointers[y][2].ordinal()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateInitial(Subproblem subproblem, Last[][] pointers) {\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\ttargetIndices[y][0] = y - 1;\n\t\t\t\t}\n\t\t\t\tif (pointers[y][1] != null) {\n\t\t\t\t\ttargetIndices[y][1] = y;\n\t\t\t\t}\n\t\t\t\tif (pointers[y][2] != null) {\n\t\t\t\t\ttargetIndices[y][2] = targetIndices[y - 1][2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateLinearAdvance(Subproblem subproblem, Last[][] pointers) {\n\t\t\ttiLast = targetIndices;\n\t\t\ttargetIndices = (targetIndices == ti2) ? ti1 : ti2;\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tswitch (pointers[y][0]) {\n\t\t\t\tcase DELETION:\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y][0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y - 1][0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSERTION:\n\t\t\t\t\ttargetIndices[y][0] = targetIndices[y - 1][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateLinearInitial(Subproblem subproblem, Last[][] pointers) {\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\tswitch (pointers[y][0]) {\n\t\t\t\t\tcase DELETION:\n\t\t\t\t\t\ttargetIndices[y][0] = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\t\ttargetIndices[y][0] = y - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase INSERTION:\n\t\t\t\t\t\ttargetIndices[y][0] = targetIndices[y - 1][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static int addAnchors(Cut[] cuts, int[] scores, boolean addScore, int[] anchors) {\n\t\tint zMax = 0, subscore = scores[0];\n\t\tfor (int z = 1; z < scores.length; z++) {\n\t\t\tif (scores[z] > subscore) {\n\t\t\t\tzMax = z;\n\t\t\t\tsubscore = scores[z];\n\t\t\t}\n\t\t}\n\t\tfor (Cut c : cuts) {\n\t\t\tanchors[c.getQueryIndex()] = c.getTargetIndex(zMax);\n\t\t}\n\t\treturn addScore ? (int) subscore : 0;\n\t}\n\n\tpublic static Cut[] getCuts(int k, Subproblem subproblem, int[] dim, boolean anchor0) {\n\t\tCut[] cuts;\n\t\tint m = subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);\n\t\tif (k < m) {\n\t\t\tcuts = new Cut[k];\n\t\t\tint firstCutIndex = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tcuts[i] = new Cut(firstCutIndex + i * (m - 1) / (k - 1), dim);\n\t\t\t}\n\t\t} else {\n\t\t\tcuts = new Cut[m];\n\t\t\tfor (int i = 0, x = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {\n\t\t\t\tcuts[i] = new Cut(x, dim);\n\t\t\t}\n\t\t}\n\t\treturn cuts;\n\t}\n\t/**\n\t * Compounds in query and target sequences that must align\n\t * @author Daniel Cameron\n\t */\n\tpublic static class Anchor {\n\t\tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\t\tpublic int getTargetIndex() {\n\t\t\treturn targetIndex;\n\t\t}\n\t\tprivate final int queryIndex;\n\t\tprivate final int targetIndex;\n\t\tpublic Anchor(int queryIndex, int targetIndex) {\n\t\t\tthis.queryIndex = queryIndex;\n\t\t\tthis.targetIndex = targetIndex;\n\t\t}\n\t\tpublic static class QueryIndexComparator implements Comparator<Anchor> {\n\t\t\t@Override\n\t\t\tpublic int compare(Anchor o1, Anchor o2) {\n\t\t\t\treturn o1.getQueryIndex() - o2.getQueryIndex();\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Alignment subproblem. The bounds of the subproblem are the\n\t * indicies representing the inclusive bounds of the dynamic programming\n\t * alignment problem.\n\t * @author Daniel Cameron\n\t */\n\tpublic static class Subproblem {\n\t\tpublic int getTargetStartIndex() {\n\t\t\treturn targetStartIndex;\n\t\t}\n\t\tpublic int getQueryEndIndex() {\n\t\t\treturn queryEndIndex;\n\t\t}\n\t\tpublic int getTargetEndIndex() {\n\t\t\treturn targetEndIndex;\n\t\t}\n\t\tpublic int getQueryStartIndex() {\n\t\t\treturn queryStartIndex;\n\t\t}\n\t\t/**\n\t\t * Indicates whether the start query and start target index compounds\n\t\t * are anchored to each other\n\t\t * @return true if the compounds are anchored in the alignment, false otherwise\n\t\t */\n\t\tpublic boolean isStartAnchored() {\n\t\t\treturn isAnchored;\n\t\t}\n\t\tprivate int queryStartIndex; // [0]\n\t\tprivate int targetStartIndex; // [1]\n\t\tprivate int queryEndIndex; // [2]\n\t\tprivate int targetEndIndex; // [3]\n\t\tprivate boolean isAnchored;\n\t\tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex) {\n\t\t\tthis(queryStartIndex, targetStartIndex, queryEndIndex, targetEndIndex, false);\n\t\t}\n\t\tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex, boolean isAnchored) {\n\t\t\tthis.queryStartIndex = queryStartIndex;\n\t\t\tthis.targetStartIndex = targetStartIndex;\n\t\t\tthis.queryEndIndex = queryEndIndex;\n\t\t\tthis.targetEndIndex = targetEndIndex;\n\t\t\tthis.isAnchored = isAnchored;\n\t\t}\n\t\t/**\n\t\t * Convert a list of anchors into a subproblem list.\n\t\t * @param anchors anchored read pairs\n\t\t * @param querySequenceLength length of query sequence\n\t\t * @param targetSequenceLength length of target sequence\n\t\t * @return list alignment subproblems\n\t\t */\n\t\tpublic static List<Subproblem> getSubproblems(List<Anchor> anchors, int querySequenceLength, int targetSequenceLength) {\n\t\t\tCollections.sort(anchors, new Anchor.QueryIndexComparator());\n\t\t\tList<Subproblem> list = new ArrayList<Subproblem>();\n\t\t\tAnchor last = new Anchor(-1, -1); // sentinal anchor\n\t\t\tboolean isAnchored = false;\n\t\t\tfor (int i = 0; i < anchors.size(); i++) {\n\t\t\t\tif (anchors.get(i).targetIndex <= last.targetIndex ||\n\t\t\t\t\tanchors.get(i).queryIndex <= last.queryIndex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n\t\t\t\t}\n\t\t\t\tlist.add(new Subproblem(\n\t\t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\t\tanchors.get(i).queryIndex,\n\t\t\t\t\t\tanchors.get(i).targetIndex,\n\t\t\t\t\t\tisAnchored));\n\t\t\t\tlast = anchors.get(i);\n\t\t\t\tisAnchored = true;\n\t\t\t}\n\t\t\tlist.add(new Subproblem(\n\t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\tquerySequenceLength,\n\t\t\t\t\ttargetSequenceLength,\n\t\t\t\t\tisAnchored));\n\t\t\treturn list;\n\t\t}\n\t}\n\t// updates cut rows given the latest row of traceback pointers\n\tpublic static void setCuts(int x, Subproblem subproblem, Last[][] pointers, Cut[]cuts) {\n\t\tfor (Cut c : cuts) {\n\t\t\tc.update(x, subproblem, pointers);\n\t\t}\n\t}\n\t/**\n\t * Calculate the optimal alignment score for the given sequence positions with an affine or constant gap penalty\n\t * @param x position in query\n\t * @param y position in target\n\t * @param gop gap opening penalty\n\t * @param gep gap extension penalty\n\t * @param sub compound match score\n\t * @param scores dynamic programming score matrix to fill at the given position\n\t * @return traceback direction for substitution, deletion and insertion\n\t */\n\tpublic static Last[] setScorePoint(int x, int y, int gop, int gep, int sub, int[][][] scores) {\n\t\tLast[] pointers = new Last[3];\n\n\t\t// substitution\n\t\tif (scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][0] && scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][2]) {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][1] + sub;\n\t\t\tpointers[0] = Last.DELETION;\n\t\t} else if (scores[x - 1][y - 1][0] >= scores[x - 1][y - 1][2]) {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][0] + sub;\n\t\t\tpointers[0] = Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][2] + sub;\n\t\t\tpointers[0] = Last.INSERTION;\n\t\t}\n\n\t\t// deletion\n\t\tif (scores[x - 1][y][1] >= scores[x - 1][y][0] + gop) {\n\t\t\tscores[x][y][1] = scores[x - 1][y][1] + gep;\n\t\t\tpointers[1] = Last.DELETION;\n\t\t} else {\n\t\t\tscores[x][y][1] = scores[x - 1][y][0] + gop + gep;\n\t\t\tpointers[1] = Last.SUBSTITUTION;\n\t\t}\n\n\t\t// insertion\n\t\tif (scores[x][y - 1][0] + gop >= scores[x][y - 1][2]) {\n\t\t\tscores[x][y][2] = scores[x][y - 1][0] + gop + gep;\n\t\t\tpointers[2] = Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][2] = scores[x][y - 1][2] + gep;\n\t\t\tpointers[2] = Last.INSERTION;\n\t\t}\n\n\t\treturn pointers;\n\t}\n\t/**\n\t * Calculates the optimal alignment score for the given sequence positions and a linear gap penalty\n\t * @param x position in query\n\t * @param y position in target\n\t * @param gep gap extension penalty\n\t * @param sub compound match score\n\t * @param scores dynamic programming score matrix to fill at the given position\n\t * @return traceback directions for substitution, deletion and insertion respectively\n\t */\n\tpublic static Last setScorePoint(int x, int y, int gep, int sub, int[][][] scores) {\n\t\tint d = scores[x - 1][y][0] + gep;\n\t\tint i = scores[x][y - 1][0] + gep;\n\t\tint s = scores[x - 1][y - 1][0] + sub;\n\t\tif (d >= s && d >= i) {\n\t\t\tscores[x][y][0] = d;\n\t\t\treturn Last.DELETION;\n\t\t} else if (s >= i) {\n\t\t\tscores[x][y][0] = s;\n\t\t\treturn Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][0] = i;\n\t\t\treturn Last.INSERTION;\n\t\t}\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence\n\t * @param x\n\t * @param subproblem\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, Subproblem subproblem, int gop, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores) {\n\t\treturn setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gop, gep, subs, storing, scores, subproblem.isStartAnchored());\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param startAnchored\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n\t\t\tboolean storing, int[][][] scores, boolean startAnchored) {\n\t\tLast[][] pointers = new Last[ye + 1][];\n\t\tint min = Integer.MIN_VALUE - gop - gep;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tscores[xb][yb][1] = scores[xb][yb][2] = gop;\n\t\t\tpointers[yb] = new Last[] {null, null, null};\n\t\t\tif (startAnchored) {\n\t\t\t\tassert (xb > 0 && yb > 0);\n\t\t\t\tint subproblemStartingScore = scores[xb - 1][yb - 1][0] + subs[yb];\n\t\t\t\tscores[xb][yb][0] = subproblemStartingScore;\n\t\t\t\tscores[xb][yb][1] = subproblemStartingScore + gop;\n\t\t\t\tscores[xb][yb][2] = subproblemStartingScore + gop;\n\t\t\t\tpointers[yb] = new Last[] {Last.SUBSTITUTION, Last.SUBSTITUTION, Last.SUBSTITUTION};\n\t\t\t}\n\t\t\tLast[] insertion = new Last[] { null, null, Last.INSERTION };\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tscores[xb][y][0] = scores[xb][y][1] = min;\n\t\t\t\tscores[xb][y][2] = scores[xb][y - 1][2] + gep;\n\t\t\t\tpointers[y] = insertion;\n\t\t\t}\n\t\t} else {\n\t\t\tscores[x][yb][0] = scores[x][yb][2] = min;\n\t\t\tscores[x][yb][1] = scores[x - 1][yb][1] + gep;\n\t\t\tpointers[yb] = new Last[] { null, Last.DELETION, null };\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tpointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param subproblem\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, Subproblem subproblem, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores) {\n\t\treturn setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gep, subs, storing, scores, subproblem.isStartAnchored());\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param startAnchored\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, boolean startAnchored) {\n\t\tLast[][] pointers = new Last[ye + 1][1];\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tif (startAnchored) {\n\t\t\t\tassert (xb > 0 && yb > 0);\n\t\t\t\tscores[xb][yb][0] = scores[xb - 1][yb - 1][0] + subs[yb];\n\t\t\t\tpointers[yb][0] = Last.SUBSTITUTION;\n\t\t\t}\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tscores[xb][y][0] = scores[xb][y - 1][0] + gep;\n\t\t\t\tpointers[y][0] = Last.INSERTION;\n\t\t\t}\n\t\t} else {\n\t\t\tscores[x][yb][0] = scores[x - 1][yb][0] + gep;\n\t\t\tpointers[yb][0] = Last.DELETION;\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tpointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence\n\t * @param x\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int gop, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, int[] xyMax, int score) {\n\t\treturn setScoreVector(x, 0, 0, scores[0].length - 1, gop, gep, subs, storing, scores, xyMax, score);\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n\t\t\tboolean storing, int[][][] scores, int[] xyMax, int score) {\n\t\tLast[][] pointers;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tpointers = new Last[ye + 1][scores[0][0].length];\n\t\t} else {\n\t\t\tpointers = new Last[ye + 1][];\n\t\t\tpointers[0] = new Last[scores[0][0].length];\n\t\t\tfor (int y = 1; y < scores[0].length; y++) {\n\t\t\t\tpointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n\t\t\t\tfor (int z = 0; z < scores[0][0].length; z++) {\n\t\t\t\t\tif (scores[x][y][z] <= 0) {\n\t\t\t\t\t\tscores[x][y][z] = 0;\n\t\t\t\t\t\tpointers[y][z] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (scores[x][y][0] > score) {\n\t\t\t\t\txyMax[0] = x;\n\t\t\t\t\txyMax[1] = y;\n\t\t\t\t\tscore = scores[x][y][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int gep, int[] subs, boolean storing, int[][][] scores,\n\t\t\tint[] xyMax, int score) {\n\t\treturn setScoreVector(x, 0, 0, scores[0].length - 1, gep, subs, storing, scores, xyMax, score);\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, int[] xyMax, int score) {\n\t\tLast[][] pointers;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tpointers = new Last[ye + 1][1];\n\t\t} else {\n\t\t\tpointers = new Last[ye + 1][];\n\t\t\tpointers[0] = new Last[1];\n\t\t\tfor (int y = 1; y < scores[x].length; y++) {\n\t\t\t\tpointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n\t\t\t\tif (scores[x][y][0] <= 0) {\n\t\t\t\t\tscores[x][y][0] = 0;\n\t\t\t\t\tpointers[y][0] = null;\n\t\t\t\t} else if (scores[x][y][0] > score) {\n\t\t\t\t\txyMax[0] = x;\n\t\t\t\t\txyMax[1] = y;\n\t\t\t\t\tscore = scores[x][y][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\tprivate static void ensureScoringMatrixColumn(int x, boolean storingFullMatrix, int[][][] scores) {\n\t\tif (!storingFullMatrix && x > 1) {\n\t\t\tscores[x] = scores[x - 2];\n\t\t}\n\t}\n\n\t/**\n\t * Find alignment path through traceback matrix\n\t * @param traceback\n\t * @param local\n\t * @param xyMax\n\t * @param last\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, boolean local, int[] xyMax, Last last, List<Step> sx,\n\t\t\tList<Step> sy) {\n\t\tint x = xyMax[0], y = xyMax[1];\n\t\tboolean linear = (traceback[x][y].length == 1);\n\t\twhile (local ? (linear ? last : traceback[x][y][last.ordinal()]) != null : x > 0 || y > 0) {\n\t\t\tswitch (last) {\n\t\t\tcase DELETION:\n\t\t\t\tsx.add(Step.COMPOUND);\n\t\t\t\tsy.add(Step.GAP);\n\t\t\t\tlast = linear ? traceback[--x][y][0] : traceback[x--][y][1];\n\t\t\t\tbreak;\n\t\t\tcase SUBSTITUTION:\n\t\t\t\tsx.add(Step.COMPOUND);\n\t\t\t\tsy.add(Step.COMPOUND);\n\t\t\t\tlast = linear ? traceback[--x][--y][0] : traceback[x--][y--][0];\n\t\t\t\tbreak;\n\t\t\tcase INSERTION:\n\t\t\t\tsx.add(Step.GAP);\n\t\t\t\tsy.add(Step.COMPOUND);\n\t\t\t\tlast = linear ? traceback[x][--y][0] : traceback[x][y--][2];\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(sx);\n\t\tCollections.reverse(sy);\n\t\treturn new int[] {x, y};\n\t}\n\n\t/**\n\t * Find global alignment path through traceback matrix\n\t * @param traceback\n\t * @param scores\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, int[][][] scores, List<Step> sx, List<Step> sy) {\n\t\tint xMax = scores.length - 1, yMax = scores[xMax].length - 1;\n\t\tboolean linear = (traceback[xMax][yMax].length == 1);\n\n\t\tLast last =\n\n\t\t\tlinear ?\n\t\t\t\ttraceback[xMax][yMax][0] :\n\n\t\t\t\t(scores[xMax][yMax][1] > scores[xMax][yMax][0] &&\n\t\t\t\t scores[xMax][yMax][1] > scores[xMax][yMax][2] ) ?\n\n\t\t\t\t\t\tLast.DELETION :\n\t\t\t\t\t\t\t(scores[xMax][yMax][0] > scores[xMax][yMax][2]) ?\n\t\t\t\t\t\t\t\t\tLast.SUBSTITUTION :\n\t\t\t\t\t\t\t\t\tLast.INSERTION;\n\n\n\t\treturn setSteps(traceback, false, new int[] {xMax, yMax}, last, sx, sy);\n\t}\n\n\t/**\n\t * Find local alignment path through traceback matrix\n\t * @param traceback\n\t * @param xyMax\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, int[] xyMax, List<Step> sx, List<Step> sy) {\n\t\treturn setSteps(traceback, true, xyMax, Last.SUBSTITUTION, sx, sy);\n\t}\n\n\tpublic static String tracebackToString(Last[][][] traceback) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int z = 0; z < 3; z++) {\n\t\t\tfor (int i = 0; i < traceback.length; i++) {\n\t\t\t\tif (traceback[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < traceback[i].length; j++) {\n\t\t\t\t\t\tif (traceback[i][j] == null || z >= traceback[i][j].length || traceback[i][j][z] == null) {\n\t\t\t\t\t\t\tsb.append('.');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch (traceback[i][j][z]) {\n\t\t\t\t\t\t\tcase DELETION:\n\t\t\t\t\t\t\t\tsb.append('^');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\t\t\t\tsb.append('\\\\');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase INSERTION:\n\t\t\t\t\t\t\t\tsb.append('<');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on August 13, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment.routines;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n//import org.slf4j.Logger;\n//import org.slf4j.LoggerFactory;\n\n\n/**\n * Static utility to construct alignment routines from a common library of methods.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n */\npublic class AlignerHelper {\n\n\t//private static final Logger logger = LoggerFactory.getLogger(AlignerHelper.class);\n\n\t// types\n\n\t/**\n\t * Define a traceback pointer for the three edit operations: substitution (match/replacement of a query compound\n\t * with a target compound), deletion (removal of a query compound leaving a gap in the target sequence), and\n\t * insertion (addition of a target compound opening a gap in the query sequence).\n\t */\n\tpublic enum Last {\n\t\tSUBSTITUTION,\n\t\tDELETION,\n\t\tINSERTION\n\t}\n\n\t/**\n\t * Defines a 'cut' row for divide-and-conquer alignment in which a new anchor is found.\n\t */\n\tpublic static class Cut {\n\n\t\tprivate int queryIndex;\n\t\tprivate int[][] targetIndices, tiLast, ti1, ti2;\n\n\t\tpublic Cut(int queryIndex, int[] dim) {\n\t\t\tthis.queryIndex = queryIndex;\n\t\t\ttargetIndices = ti1 = new int[dim[1]][dim[2]];\n\t\t\tti2 = new int[dim[1]][dim[2]];\n\t\t}\n\n\t\tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\n\t\tpublic int getTargetIndex(int z) {\n\t\t\treturn targetIndices[targetIndices.length - 1][z];\n\t\t}\n\n\t\tpublic void update(int x, Subproblem subproblem, Last[][] pointers) {\n\t\t\tif (pointers[subproblem.getTargetStartIndex()].length == 1) {\n\t\t\t\tif (queryIndex == x - 1) {\n\t\t\t\t\tupdateLinearInitial(subproblem, pointers);\n\t\t\t\t} else if (queryIndex < x) {\n\t\t\t\t\tupdateLinearAdvance(subproblem, pointers);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (queryIndex == x - 1) {\n\t\t\t\t\tupdateInitial(subproblem, pointers);\n\t\t\t\t} else if (queryIndex < x) {\n\t\t\t\t\tupdateAdvance(subproblem, pointers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateAdvance(Subproblem subproblem, Last[][] pointers) {\n\t\t\ttiLast = targetIndices;\n\t\t\ttargetIndices = (targetIndices == ti2) ? ti1 : ti2;\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y - 1][pointers[y][0].ordinal()];\n\t\t\t\t}\n\t\t\t\tif (pointers[y][1] != null) {\n\t\t\t\t\ttargetIndices[y][1] = tiLast[y][pointers[y][1].ordinal()];\n\t\t\t\t}\n\t\t\t\tif (pointers[y][2] != null) {\n\t\t\t\t\ttargetIndices[y][2] = targetIndices[y - 1][pointers[y][2].ordinal()];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateInitial(Subproblem subproblem, Last[][] pointers) {\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\ttargetIndices[y][0] = y - 1;\n\t\t\t\t}\n\t\t\t\tif (pointers[y][1] != null) {\n\t\t\t\t\ttargetIndices[y][1] = y;\n\t\t\t\t}\n\t\t\t\tif (pointers[y][2] != null) {\n\t\t\t\t\ttargetIndices[y][2] = targetIndices[y - 1][2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateLinearAdvance(Subproblem subproblem, Last[][] pointers) {\n\t\t\ttiLast = targetIndices;\n\t\t\ttargetIndices = (targetIndices == ti2) ? ti1 : ti2;\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tswitch (pointers[y][0]) {\n\t\t\t\tcase DELETION:\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y][0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\ttargetIndices[y][0] = tiLast[y - 1][0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase INSERTION:\n\t\t\t\t\ttargetIndices[y][0] = targetIndices[y - 1][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void updateLinearInitial(Subproblem subproblem, Last[][] pointers) {\n\t\t\tfor (int y = subproblem.getTargetStartIndex(); y <= subproblem.getTargetEndIndex(); y++) {\n\t\t\t\tif (pointers[y][0] != null) {\n\t\t\t\t\tswitch (pointers[y][0]) {\n\t\t\t\t\tcase DELETION:\n\t\t\t\t\t\ttargetIndices[y][0] = y;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\t\ttargetIndices[y][0] = y - 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase INSERTION:\n\t\t\t\t\t\ttargetIndices[y][0] = targetIndices[y - 1][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tpublic static int addAnchors(Cut[] cuts, int[] scores, boolean addScore, int[] anchors) {\n\t\tint zMax = 0, subscore = scores[0];\n\t\tfor (int z = 1; z < scores.length; z++) {\n\t\t\tif (scores[z] > subscore) {\n\t\t\t\tzMax = z;\n\t\t\t\tsubscore = scores[z];\n\t\t\t}\n\t\t}\n\t\tfor (Cut c : cuts) {\n\t\t\tanchors[c.getQueryIndex()] = c.getTargetIndex(zMax);\n\t\t}\n\t\treturn addScore ? (int) subscore : 0;\n\t}\n\n\tpublic static Cut[] getCuts(int k, Subproblem subproblem, int[] dim, boolean anchor0) {\n\t\tCut[] cuts;\n\t\tint m = subproblem.getQueryEndIndex() - subproblem.getQueryStartIndex() - (anchor0 ? 1 : 0);\n\t\tif (k < m) {\n\t\t\tcuts = new Cut[k];\n\t\t\tint firstCutIndex = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0);\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tcuts[i] = new Cut(firstCutIndex + i * (m - 1) / (k - 1), dim);\n\t\t\t}\n\t\t} else {\n\t\t\tcuts = new Cut[m];\n\t\t\tfor (int i = 0, x = subproblem.getQueryStartIndex() + (anchor0 ? 1 : 0); i < m; i++, x++) {\n\t\t\t\tcuts[i] = new Cut(x, dim);\n\t\t\t}\n\t\t}\n\t\treturn cuts;\n\t}\n\t/**\n\t * Compounds in query and target sequences that must align\n\t * @author Daniel Cameron\n\t */\n\tpublic static class Anchor {\n\t\tpublic int getQueryIndex() {\n\t\t\treturn queryIndex;\n\t\t}\n\t\tpublic int getTargetIndex() {\n\t\t\treturn targetIndex;\n\t\t}\n\t\tprivate final int queryIndex;\n\t\tprivate final int targetIndex;\n\t\tpublic Anchor(int queryIndex, int targetIndex) {\n\t\t\tthis.queryIndex = queryIndex;\n\t\t\tthis.targetIndex = targetIndex;\n\t\t}\n\t\tpublic static class QueryIndexComparator implements Comparator<Anchor>, Serializable {\n            private static final long serialVersionUID = 1;\n\n\t\t\t@Override\n\t\t\tpublic int compare(Anchor o1, Anchor o2) {\n\t\t\t\treturn o1.getQueryIndex() - o2.getQueryIndex();\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Alignment subproblem. The bounds of the subproblem are the\n\t * indicies representing the inclusive bounds of the dynamic programming\n\t * alignment problem.\n\t * @author Daniel Cameron\n\t */\n\tpublic static class Subproblem {\n\t\tpublic int getTargetStartIndex() {\n\t\t\treturn targetStartIndex;\n\t\t}\n\t\tpublic int getQueryEndIndex() {\n\t\t\treturn queryEndIndex;\n\t\t}\n\t\tpublic int getTargetEndIndex() {\n\t\t\treturn targetEndIndex;\n\t\t}\n\t\tpublic int getQueryStartIndex() {\n\t\t\treturn queryStartIndex;\n\t\t}\n\t\t/**\n\t\t * Indicates whether the start query and start target index compounds\n\t\t * are anchored to each other\n\t\t * @return true if the compounds are anchored in the alignment, false otherwise\n\t\t */\n\t\tpublic boolean isStartAnchored() {\n\t\t\treturn isAnchored;\n\t\t}\n\t\tprivate int queryStartIndex; // [0]\n\t\tprivate int targetStartIndex; // [1]\n\t\tprivate int queryEndIndex; // [2]\n\t\tprivate int targetEndIndex; // [3]\n\t\tprivate boolean isAnchored;\n\t\tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex) {\n\t\t\tthis(queryStartIndex, targetStartIndex, queryEndIndex, targetEndIndex, false);\n\t\t}\n\t\tpublic Subproblem(int queryStartIndex, int targetStartIndex, int queryEndIndex, int targetEndIndex, boolean isAnchored) {\n\t\t\tthis.queryStartIndex = queryStartIndex;\n\t\t\tthis.targetStartIndex = targetStartIndex;\n\t\t\tthis.queryEndIndex = queryEndIndex;\n\t\t\tthis.targetEndIndex = targetEndIndex;\n\t\t\tthis.isAnchored = isAnchored;\n\t\t}\n\t\t/**\n\t\t * Convert a list of anchors into a subproblem list.\n\t\t * @param anchors anchored read pairs\n\t\t * @param querySequenceLength length of query sequence\n\t\t * @param targetSequenceLength length of target sequence\n\t\t * @return list alignment subproblems\n\t\t */\n\t\tpublic static List<Subproblem> getSubproblems(List<Anchor> anchors, int querySequenceLength, int targetSequenceLength) {\n\t\t\tCollections.sort(anchors, new Anchor.QueryIndexComparator());\n\t\t\tList<Subproblem> list = new ArrayList<Subproblem>();\n\t\t\tAnchor last = new Anchor(-1, -1); // sentinal anchor\n\t\t\tboolean isAnchored = false;\n\t\t\tfor (int i = 0; i < anchors.size(); i++) {\n\t\t\t\tif (anchors.get(i).targetIndex <= last.targetIndex ||\n\t\t\t\t\tanchors.get(i).queryIndex <= last.queryIndex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n\t\t\t\t}\n\t\t\t\tlist.add(new Subproblem(\n\t\t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\t\tanchors.get(i).queryIndex,\n\t\t\t\t\t\tanchors.get(i).targetIndex,\n\t\t\t\t\t\tisAnchored));\n\t\t\t\tlast = anchors.get(i);\n\t\t\t\tisAnchored = true;\n\t\t\t}\n\t\t\tlist.add(new Subproblem(\n\t\t\t\t\tlast.queryIndex + 1,\n\t\t\t\t\tlast.targetIndex + 1,\n\t\t\t\t\tquerySequenceLength,\n\t\t\t\t\ttargetSequenceLength,\n\t\t\t\t\tisAnchored));\n\t\t\treturn list;\n\t\t}\n\t}\n\t// updates cut rows given the latest row of traceback pointers\n\tpublic static void setCuts(int x, Subproblem subproblem, Last[][] pointers, Cut[]cuts) {\n\t\tfor (Cut c : cuts) {\n\t\t\tc.update(x, subproblem, pointers);\n\t\t}\n\t}\n\t/**\n\t * Calculate the optimal alignment score for the given sequence positions with an affine or constant gap penalty\n\t * @param x position in query\n\t * @param y position in target\n\t * @param gop gap opening penalty\n\t * @param gep gap extension penalty\n\t * @param sub compound match score\n\t * @param scores dynamic programming score matrix to fill at the given position\n\t * @return traceback direction for substitution, deletion and insertion\n\t */\n\tpublic static Last[] setScorePoint(int x, int y, int gop, int gep, int sub, int[][][] scores) {\n\t\tLast[] pointers = new Last[3];\n\n\t\t// substitution\n\t\tif (scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][0] && scores[x - 1][y - 1][1] >= scores[x - 1][y - 1][2]) {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][1] + sub;\n\t\t\tpointers[0] = Last.DELETION;\n\t\t} else if (scores[x - 1][y - 1][0] >= scores[x - 1][y - 1][2]) {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][0] + sub;\n\t\t\tpointers[0] = Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][0] = scores[x - 1][y - 1][2] + sub;\n\t\t\tpointers[0] = Last.INSERTION;\n\t\t}\n\n\t\t// deletion\n\t\tif (scores[x - 1][y][1] >= scores[x - 1][y][0] + gop) {\n\t\t\tscores[x][y][1] = scores[x - 1][y][1] + gep;\n\t\t\tpointers[1] = Last.DELETION;\n\t\t} else {\n\t\t\tscores[x][y][1] = scores[x - 1][y][0] + gop + gep;\n\t\t\tpointers[1] = Last.SUBSTITUTION;\n\t\t}\n\n\t\t// insertion\n\t\tif (scores[x][y - 1][0] + gop >= scores[x][y - 1][2]) {\n\t\t\tscores[x][y][2] = scores[x][y - 1][0] + gop + gep;\n\t\t\tpointers[2] = Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][2] = scores[x][y - 1][2] + gep;\n\t\t\tpointers[2] = Last.INSERTION;\n\t\t}\n\n\t\treturn pointers;\n\t}\n\t/**\n\t * Calculates the optimal alignment score for the given sequence positions and a linear gap penalty\n\t * @param x position in query\n\t * @param y position in target\n\t * @param gep gap extension penalty\n\t * @param sub compound match score\n\t * @param scores dynamic programming score matrix to fill at the given position\n\t * @return traceback directions for substitution, deletion and insertion respectively\n\t */\n\tpublic static Last setScorePoint(int x, int y, int gep, int sub, int[][][] scores) {\n\t\tint d = scores[x - 1][y][0] + gep;\n\t\tint i = scores[x][y - 1][0] + gep;\n\t\tint s = scores[x - 1][y - 1][0] + sub;\n\t\tif (d >= s && d >= i) {\n\t\t\tscores[x][y][0] = d;\n\t\t\treturn Last.DELETION;\n\t\t} else if (s >= i) {\n\t\t\tscores[x][y][0] = s;\n\t\t\treturn Last.SUBSTITUTION;\n\t\t} else {\n\t\t\tscores[x][y][0] = i;\n\t\t\treturn Last.INSERTION;\n\t\t}\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence\n\t * @param x\n\t * @param subproblem\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, Subproblem subproblem, int gop, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores) {\n\t\treturn setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gop, gep, subs, storing, scores, subproblem.isStartAnchored());\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param startAnchored\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n\t\t\tboolean storing, int[][][] scores, boolean startAnchored) {\n\t\tLast[][] pointers = new Last[ye + 1][];\n\t\tint min = Integer.MIN_VALUE - gop - gep;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tscores[xb][yb][1] = scores[xb][yb][2] = gop;\n\t\t\tpointers[yb] = new Last[] {null, null, null};\n\t\t\tif (startAnchored) {\n\t\t\t\tassert (xb > 0 && yb > 0);\n\t\t\t\tint subproblemStartingScore = scores[xb - 1][yb - 1][0] + subs[yb];\n\t\t\t\tscores[xb][yb][0] = subproblemStartingScore;\n\t\t\t\tscores[xb][yb][1] = subproblemStartingScore + gop;\n\t\t\t\tscores[xb][yb][2] = subproblemStartingScore + gop;\n\t\t\t\tpointers[yb] = new Last[] {Last.SUBSTITUTION, Last.SUBSTITUTION, Last.SUBSTITUTION};\n\t\t\t}\n\t\t\tLast[] insertion = new Last[] { null, null, Last.INSERTION };\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tscores[xb][y][0] = scores[xb][y][1] = min;\n\t\t\t\tscores[xb][y][2] = scores[xb][y - 1][2] + gep;\n\t\t\t\tpointers[y] = insertion;\n\t\t\t}\n\t\t} else {\n\t\t\tscores[x][yb][0] = scores[x][yb][2] = min;\n\t\t\tscores[x][yb][1] = scores[x - 1][yb][1] + gep;\n\t\t\tpointers[yb] = new Last[] { null, Last.DELETION, null };\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tpointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param subproblem\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, Subproblem subproblem, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores) {\n\t\treturn setScoreVector(x, subproblem.getQueryStartIndex(), subproblem.getTargetStartIndex(), subproblem.getTargetEndIndex(), gep, subs, storing, scores, subproblem.isStartAnchored());\n\t}\n\n\t/**\n\t * Score global alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param startAnchored\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, boolean startAnchored) {\n\t\tLast[][] pointers = new Last[ye + 1][1];\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tif (startAnchored) {\n\t\t\t\tassert (xb > 0 && yb > 0);\n\t\t\t\tscores[xb][yb][0] = scores[xb - 1][yb - 1][0] + subs[yb];\n\t\t\t\tpointers[yb][0] = Last.SUBSTITUTION;\n\t\t\t}\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tscores[xb][y][0] = scores[xb][y - 1][0] + gep;\n\t\t\t\tpointers[y][0] = Last.INSERTION;\n\t\t\t}\n\t\t} else {\n\t\t\tscores[x][yb][0] = scores[x - 1][yb][0] + gep;\n\t\t\tpointers[yb][0] = Last.DELETION;\n\t\t\tfor (int y = yb + 1; y <= ye; y++) {\n\t\t\t\tpointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence\n\t * @param x\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int gop, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, int[] xyMax, int score) {\n\t\treturn setScoreVector(x, 0, 0, scores[0].length - 1, gop, gep, subs, storing, scores, xyMax, score);\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gop\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gop, int gep, int[] subs,\n\t\t\tboolean storing, int[][][] scores, int[] xyMax, int score) {\n\t\tLast[][] pointers;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tpointers = new Last[ye + 1][scores[0][0].length];\n\t\t} else {\n\t\t\tpointers = new Last[ye + 1][];\n\t\t\tpointers[0] = new Last[scores[0][0].length];\n\t\t\tfor (int y = 1; y < scores[0].length; y++) {\n\t\t\t\tpointers[y] = setScorePoint(x, y, gop, gep, subs[y], scores);\n\t\t\t\tfor (int z = 0; z < scores[0][0].length; z++) {\n\t\t\t\t\tif (scores[x][y][z] <= 0) {\n\t\t\t\t\t\tscores[x][y][z] = 0;\n\t\t\t\t\t\tpointers[y][z] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (scores[x][y][0] > score) {\n\t\t\t\t\txyMax[0] = x;\n\t\t\t\t\txyMax[1] = y;\n\t\t\t\t\tscore = scores[x][y][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int gep, int[] subs, boolean storing, int[][][] scores,\n\t\t\tint[] xyMax, int score) {\n\t\treturn setScoreVector(x, 0, 0, scores[0].length - 1, gep, subs, storing, scores, xyMax, score);\n\t}\n\n\t/**\n\t * Score local alignment for a given position in the query sequence for a linear gap penalty\n\t * @param x\n\t * @param xb\n\t * @param yb\n\t * @param ye\n\t * @param gep\n\t * @param subs\n\t * @param storing\n\t * @param scores\n\t * @param xyMax\n\t * @param score\n\t * @return\n\t */\n\tpublic static Last[][] setScoreVector(int x, int xb, int yb, int ye, int gep, int[] subs, boolean storing,\n\t\t\tint[][][] scores, int[] xyMax, int score) {\n\t\tLast[][] pointers;\n\t\tensureScoringMatrixColumn(x, storing, scores);\n\t\tif (x == xb) {\n\t\t\tpointers = new Last[ye + 1][1];\n\t\t} else {\n\t\t\tpointers = new Last[ye + 1][];\n\t\t\tpointers[0] = new Last[1];\n\t\t\tfor (int y = 1; y < scores[x].length; y++) {\n\t\t\t\tpointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n\t\t\t\tif (scores[x][y][0] <= 0) {\n\t\t\t\t\tscores[x][y][0] = 0;\n\t\t\t\t\tpointers[y][0] = null;\n\t\t\t\t} else if (scores[x][y][0] > score) {\n\t\t\t\t\txyMax[0] = x;\n\t\t\t\t\txyMax[1] = y;\n\t\t\t\t\tscore = scores[x][y][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn pointers;\n\t}\n\n\tprivate static void ensureScoringMatrixColumn(int x, boolean storingFullMatrix, int[][][] scores) {\n\t\tif (!storingFullMatrix && x > 1) {\n\t\t\tscores[x] = scores[x - 2];\n\t\t}\n\t}\n\n\t/**\n\t * Find alignment path through traceback matrix\n\t * @param traceback\n\t * @param local\n\t * @param xyMax\n\t * @param last\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, boolean local, int[] xyMax, Last last, List<Step> sx,\n\t\t\tList<Step> sy) {\n\t\tint x = xyMax[0], y = xyMax[1];\n\t\tboolean linear = (traceback[x][y].length == 1);\n\t\twhile (local ? (linear ? last : traceback[x][y][last.ordinal()]) != null : x > 0 || y > 0) {\n\t\t\tswitch (last) {\n\t\t\tcase DELETION:\n\t\t\t\tsx.add(Step.COMPOUND);\n\t\t\t\tsy.add(Step.GAP);\n\t\t\t\tlast = linear ? traceback[--x][y][0] : traceback[x--][y][1];\n\t\t\t\tbreak;\n\t\t\tcase SUBSTITUTION:\n\t\t\t\tsx.add(Step.COMPOUND);\n\t\t\t\tsy.add(Step.COMPOUND);\n\t\t\t\tlast = linear ? traceback[--x][--y][0] : traceback[x--][y--][0];\n\t\t\t\tbreak;\n\t\t\tcase INSERTION:\n\t\t\t\tsx.add(Step.GAP);\n\t\t\t\tsy.add(Step.COMPOUND);\n\t\t\t\tlast = linear ? traceback[x][--y][0] : traceback[x][y--][2];\n\t\t\t}\n\t\t}\n\t\tCollections.reverse(sx);\n\t\tCollections.reverse(sy);\n\t\treturn new int[] {x, y};\n\t}\n\n\t/**\n\t * Find global alignment path through traceback matrix\n\t * @param traceback\n\t * @param scores\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, int[][][] scores, List<Step> sx, List<Step> sy) {\n\t\tint xMax = scores.length - 1, yMax = scores[xMax].length - 1;\n\t\tboolean linear = (traceback[xMax][yMax].length == 1);\n\n\t\tLast last =\n\n\t\t\tlinear ?\n\t\t\t\ttraceback[xMax][yMax][0] :\n\n\t\t\t\t(scores[xMax][yMax][1] > scores[xMax][yMax][0] &&\n\t\t\t\t scores[xMax][yMax][1] > scores[xMax][yMax][2] ) ?\n\n\t\t\t\t\t\tLast.DELETION :\n\t\t\t\t\t\t\t(scores[xMax][yMax][0] > scores[xMax][yMax][2]) ?\n\t\t\t\t\t\t\t\t\tLast.SUBSTITUTION :\n\t\t\t\t\t\t\t\t\tLast.INSERTION;\n\n\n\t\treturn setSteps(traceback, false, new int[] {xMax, yMax}, last, sx, sy);\n\t}\n\n\t/**\n\t * Find local alignment path through traceback matrix\n\t * @param traceback\n\t * @param xyMax\n\t * @param sx\n\t * @param sy\n\t * @return\n\t */\n\tpublic static int[] setSteps(Last[][][] traceback, int[] xyMax, List<Step> sx, List<Step> sy) {\n\t\treturn setSteps(traceback, true, xyMax, Last.SUBSTITUTION, sx, sy);\n\t}\n\n\tpublic static String tracebackToString(Last[][][] traceback) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int z = 0; z < 3; z++) {\n\t\t\tfor (int i = 0; i < traceback.length; i++) {\n\t\t\t\tif (traceback[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < traceback[i].length; j++) {\n\t\t\t\t\t\tif (traceback[i][j] == null || z >= traceback[i][j].length || traceback[i][j][z] == null) {\n\t\t\t\t\t\t\tsb.append('.');\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tswitch (traceback[i][j][z]) {\n\t\t\t\t\t\t\tcase DELETION:\n\t\t\t\t\t\t\t\tsb.append('^');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase SUBSTITUTION:\n\t\t\t\t\t\t\t\tsb.append('\\\\');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase INSERTION:\n\t\t\t\t\t\t\t\tsb.append('<');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsb.append('\\n');\n\t\t\t}\n\t\t\tsb.append(\"\\n\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.alignment.routines;\n\nimport org.biojava.nbio.alignment.routines.AlignerHelper.Anchor;\nimport org.biojava.nbio.alignment.routines.AlignerHelper.Cut;\nimport org.biojava.nbio.alignment.routines.AlignerHelper.Subproblem;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\n\n/**\n *\n * @author Daniel Cameron\n *\n */\npublic class AlignerHelperTest {\n\t@Test\n\tpublic void getCuts_should_not_return_start_position_for_starting_anchor() {\n\t\tCut[] cuts = AlignerHelper.getCuts(10, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, true);\n\t\tassertNotEquals(5, cuts[0].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getCuts_should_return_all_positions_when_cuts_exceeds_query_size() {\n\t\tCut[] cuts = AlignerHelper.getCuts(10, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, false);\n\t\tassertEquals(5, cuts.length);\n\t\tassertEquals(5, cuts[0].getQueryIndex());\n\t\tassertEquals(6, cuts[1].getQueryIndex());\n\t\tassertEquals(7, cuts[2].getQueryIndex());\n\t\tassertEquals(8, cuts[3].getQueryIndex());\n\t\tassertEquals(9, cuts[4].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getCuts_should_return_spaced_cuts_when_query_interval_larger_than_cut_size() {\n\t\tCut[] cuts = AlignerHelper.getCuts(3, new Subproblem(5, 20, 10, 30), new int[] { 50, 50, 3 }, false);\n\t\tassertEquals(3, cuts.length);\n\t\tassertEquals(5, cuts[0].getQueryIndex());\n\t\tassertEquals(7, cuts[1].getQueryIndex());\n\t\tassertEquals(9, cuts[2].getQueryIndex());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_return_score_indicies_of_alignment_subproblems() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 2));\n\t\tanchors.add(new Anchor(5, 5));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(1, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(2, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(2, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(3, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(5, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(5, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(6, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(6, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_zero_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(1, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(false, problems.get(0).isStartAnchored());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_start_and_end_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(0, 0));\n\t\tanchors.add(new Anchor(9, 14));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(0, problems.get(0).getQueryStartIndex());\n\t\tassertEquals(0, problems.get(0).getTargetStartIndex());\n\t\tassertEquals(0, problems.get(0).getQueryEndIndex());\n\t\tassertEquals(0, problems.get(0).getTargetEndIndex());\n\t\tassertEquals(false, problems.get(0).isStartAnchored());\n\t\tassertEquals(1, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(1, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(9, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(14, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(true, problems.get(1).isStartAnchored());\n\t\tassertEquals(10, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(15, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t\tassertEquals(true, problems.get(2).isStartAnchored());\n\t}\n\t@Test\n\tpublic void getSubproblems_should_allow_adjacent_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 1));\n\t\tanchors.add(new Anchor(2, 3));\n\t\tList<Subproblem> problems = AlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t\tassertEquals(3, problems.size());\n\t\tassertEquals(2, problems.get(1).getQueryStartIndex());\n\t\tassertEquals(2, problems.get(1).getTargetStartIndex());\n\t\tassertEquals(2, problems.get(1).getQueryEndIndex());\n\t\tassertEquals(3, problems.get(1).getTargetEndIndex());\n\t\tassertEquals(3, problems.get(2).getQueryStartIndex());\n\t\tassertEquals(4, problems.get(2).getTargetStartIndex());\n\t\tassertEquals(10, problems.get(2).getQueryEndIndex());\n\t\tassertEquals(15, problems.get(2).getTargetEndIndex());\n\t}\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void getSubproblems_should_not_allow_repeated_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 1));\n\t\tanchors.add(new Anchor(1, 2));\n\t\tAlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t}\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void getSubproblems_should_not_allow_unalignable_anchors() {\n\t\tList<Anchor> anchors = new ArrayList<Anchor>();\n\t\tanchors.add(new Anchor(1, 2));\n\t\tanchors.add(new Anchor(2, 1));\n\t\tAlignerHelper.Subproblem.getSubproblems(anchors, 10, 15);\n\t}\n}\n","changedTest":"","commitMessage":"squid:S2063 - Comparators should be Serializable\n","test_commitMessage":"","allZero":false}