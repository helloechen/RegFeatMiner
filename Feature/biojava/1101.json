{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/xtal/SpaceGroup.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/xtal/TestSpaceGroup.java","prod_time":"2024-02-26 23:42:40","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":4,"add_classname_line":0,"add_condition_line":4,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":4,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ac75f31259e94a6d9d417e7faa2eaf2598c56f1a","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.xtal;\n\nimport org.biojava.nbio.structure.jama.EigenvalueDecomposition;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.xtal.io.TransfAlgebraicAdapter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Marshaller;\nimport jakarta.xml.bind.annotation.XmlAccessType;\nimport jakarta.xml.bind.annotation.XmlAccessorType;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * A crystallographic space group. We store the standard numeric identifier,\n * the international short symbol and the transformations corresponding to\n * each space group (as Matrix4ds and in algebraic notation).\n * The information for all (protein crystallography) space groups can be\n * parsed from the XML file in the resource directory.\n *\n * See: http://en.wikipedia.org/wiki/Space_group\n *\n * @author duarte_j\n * @see SymoplibParser\n */\n@XmlRootElement(name = \"SpaceGroup\", namespace =\"http://www.biojava.org\")\n@XmlAccessorType(XmlAccessType.PUBLIC_MEMBER)\npublic class SpaceGroup implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(SpaceGroup.class);\n\n\n\tprivate static final Pattern splitPat1 = Pattern.compile(\"((?:[+-]?[XYZ])+)([+-][0-9/.]+)\");\n\tprivate static final Pattern splitPat2 = Pattern.compile(\"([+-]?[0-9/.]+)((?:[+-][XYZ])+)\");\n\tprivate static final Pattern coordPat = Pattern.compile(\"(?:([+-])?([XYZ]))+?\"); // the last +? is for ungreedy matching\n\tprivate static final Pattern transCoefPat = Pattern.compile(\"([-+]?[0-9.]+)(?:/([0-9.]+))?\");\n\n\tprivate static final Pattern nonEnantPat = Pattern.compile(\"[-abcmnd]\");\n\n\tprotected static final double DELTA=0.0000001;\n\n\tprivate  int id;\n\tprivate  int multiplicity;\n\tprivate  int primitiveMultiplicity;\n\tprivate  String shortSymbol;\n\tprivate  String altShortSymbol;\n\tprivate  List<Matrix4d> transformations;\n\tprivate  List<String> transfAlgebraic;\n\tprivate  Vector3d[] cellTranslations; // in space groups I, C, F or H there are pure cell translations corresponding to recenterings\n\n\tprivate AxisAngle4d[] axisAngles;\n\n\tprivate int[] axisTypes; // indices of array are transformIds\n\n\tprivate BravaisLattice bravLattice;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate SpaceGroup(){\n\t\t// required by JAXB\n\n\t}\n\n\tpublic SpaceGroup(int id, int multiplicity, int primitiveMultiplicity, String shortSymbol, String altShortSymbol, BravaisLattice bravLattice) {\n\t\tthis.id = id;\n\t\tthis.multiplicity = multiplicity;\n\t\tthis.primitiveMultiplicity = primitiveMultiplicity;\n\t\tthis.shortSymbol = shortSymbol;\n\t\tthis.altShortSymbol = altShortSymbol;\n\t\ttransformations = new ArrayList<Matrix4d>(multiplicity);\n\t\ttransfAlgebraic = new ArrayList<String>(multiplicity);\n\t\tcellTranslations = new Vector3d[multiplicity/primitiveMultiplicity];\n\t\tthis.bravLattice = bravLattice;\n\t}\n\n\t/**\n\t * Get the space group for the given international short name, using\n\t * the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'\n\t * @param shortName\n\t * @return the SpaceGroup or null if the shortName is not valid\n\t * @see SymoplibParser#getSpaceGroup(String)\n\t */\n\tpublic static SpaceGroup parseSpaceGroup(String shortName) {\n\t\treturn SymoplibParser.getSpaceGroup(shortName);\n\t}\n\n\tpublic void addTransformation(String transfAlgebraic) {\n\t\tthis.transfAlgebraic.add(transfAlgebraic);\n\t\tthis.transformations.add(getMatrixFromAlgebraic(transfAlgebraic));\n\t}\n\n\tprotected void initializeCellTranslations() {\n\t\tif ( cellTranslations != null && cellTranslations.length >0) {\n\t\t\t// we already initialized this\n\t\t\treturn;\n\t\t}\n\t\tcellTranslations = new Vector3d[multiplicity/primitiveMultiplicity];\n\t\tcellTranslations[0] = new Vector3d(0,0,0);\n\n\t\tif ( transformations == null){\n\t\t\tlogger.warn(\"transformations == null\" + this.toXML());\n\t\t}\n\n\t\tif (multiplicity==primitiveMultiplicity) {\n\t\t\treturn;\n\t\t}\n\t\tint fold = multiplicity/primitiveMultiplicity;\n\n\n\n\t\tfor (int n=1;n<fold;n++) {\n\t\t\tif ( transformations.size() < (n* primitiveMultiplicity)){\n\t\t\t\tlogger.warn(\"WARNING number of transformations < \" +(n*primitiveMultiplicity));\n\t\t\t\tlogger.warn(this.toXML());\n\t\t\t}\n\t\t\tMatrix4d t = transformations.get(n*primitiveMultiplicity);\n\t\t\tcellTranslations[n] = new Vector3d(t.m03,t.m13,t.m23);\n\t\t}\n\t}\n\n\tpublic int getMultiplicity() {\n\t\treturn multiplicity;\n\t}\n\n\tpublic int getPrimitiveMultiplicity() {\n\t\treturn primitiveMultiplicity;\n\t}\n\n\tpublic Vector3d[] getCellTranslations() {\n\t\treturn cellTranslations;\n\t}\n\n\tpublic Vector3d getCellTranslation(int i) {\n\t\treturn cellTranslations[i];\n\t}\n\n\tpublic static Matrix4d getMatrixFromAlgebraic(String transfAlgebraic) {\n\t\tString[] parts = transfAlgebraic.toUpperCase().split(\",\");\n\t\tdouble[] xCoef = convertAlgebraicStrToCoefficients(parts[0].trim());\n\t\tdouble[] yCoef = convertAlgebraicStrToCoefficients(parts[1].trim());\n\t\tdouble[] zCoef = convertAlgebraicStrToCoefficients(parts[2].trim());\n\n\t\tMatrix4d mat = new Matrix4d();\n\t\tmat.setIdentity();\n\t\tmat.setRotation(new Matrix3d(xCoef[0],xCoef[1],xCoef[2],yCoef[0],yCoef[1],yCoef[2],zCoef[0],zCoef[1],zCoef[2]));\n\t\tmat.setTranslation(new Vector3d(xCoef[3],yCoef[3],zCoef[3]));\n\t\treturn mat;\n\t\t//return new Matrix4d(xCoef[0],xCoef[1],xCoef[2],xCoef[3],\n\t\t//\t\t\t\t\tyCoef[0],yCoef[1],yCoef[2],yCoef[3],\n\t\t//\t\t\t\t\tzCoef[0],zCoef[1],zCoef[2],zCoef[3],\n\t\t//\t\t\t\t\t0,0,0,1);\n\t}\n\n\tprivate static double[] convertAlgebraicStrToCoefficients(String algString) {\n\t\tString letters = null;\n\t\tString noLetters = null;\n\t\tMatcher m = splitPat1.matcher(algString);\n\t\tif (m.matches()) {\n\t\t\tletters = m.group(1);\n\t\t\tnoLetters = m.group(2);\n\t\t} else {\n\t\t\tm = splitPat2.matcher(algString);\n\t\t\tif (m.matches()) {\n\t\t\t\tletters = m.group(2);\n\t\t\t\tnoLetters = m.group(1);\n\t\t\t} else {\n\t\t\t\tletters = algString;\n\t\t\t}\n\t\t}\n\t\tdouble[] coefficients = new double[4];\n\t\tm = coordPat.matcher(letters);\n\t\twhile(m.find()){\n\t\t\tString sign = \"\";\n\t\t\tif (m.group(1)!=null) {\n\t\t\t\tsign = m.group(1);\n\t\t\t}\n\t\t\tdouble s = 1.0;\n\t\t\tif (sign.equals(\"-\")){\n\t\t\t\ts = -1.0;\n\t\t\t}\n\t\t\tString coord = m.group(2);\n\t\t\tif (coord.equals(\"X\")) {\n\t\t\t\tcoefficients[0] = s;\n\t\t\t} else if (coord.equals(\"Y\")) {\n\t\t\t\tcoefficients[1] = s;\n\t\t\t} else if (coord.equals(\"Z\")) {\n\t\t\t\tcoefficients[2] = s;\n\t\t\t}\n\t\t}\n\t\tif (noLetters!=null) {\n\t\t\tm = transCoefPat.matcher(noLetters);\n\t\t\tif (m.matches()) {\n\t\t\t\tdouble num = Double.parseDouble(m.group(1));\n\t\t\t\tdouble den = 1;\n\t\t\t\tif (m.group(2)!=null) {\n\t\t\t\t\tden = Double.parseDouble(m.group(2));\n\t\t\t\t}\n\t\t\t\tcoefficients[3] = num/den;\n\t\t\t}\n\t\t} else {\n\t\t\tcoefficients[3]=0;\n\t\t}\n\t\treturn coefficients;\n\t}\n\n\t/**\n\t * Gets the standard numeric identifier for the space group.\n\t * See for example http://en.wikipedia.org/wiki/Space_group\n\t * or the IUCr crystallographic tables\n\t * @return\n\t */\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * Gets the international short name (as used in PDB),\n\t * e.g. \"P 21 21 21\" or \"C 1 c 1\"\n\t * @return\n\t */\n\tpublic String getShortSymbol() {\n\t\treturn shortSymbol;\n\t}\n\n\t/**\n\t * Gets the alternative international short name (as sometimes used in PDB),\n\t * e.g. \"I 1 2 1\" instead of \"I 2\"\n\t * @return\n\t */\n\tpublic String getAltShortSymbol() {\n\t\treturn altShortSymbol;\n\t}\n\n\t/**\n\t * Gets all transformations except for the identity in crystal axes basis.\n\t * @return\n\t */\n\tpublic List<Matrix4d> getTransformations() {\n\t\tList<Matrix4d> transfs = new ArrayList<Matrix4d>();\n\t\tfor (int i=1;i<this.transformations.size();i++){\n\t\t\ttransfs.add(transformations.get(i));\n\t\t}\n\t\treturn transfs;\n\t}\n\n\tprivate void calcRotAxesAndAngles() {\n\n\t\taxisAngles = new AxisAngle4d[multiplicity];\n\n\t\t// identity operator (transformId==0)\n\t\taxisAngles[0] = new AxisAngle4d(new Vector3d(0,0,0), 0.0);\n\n\t\tfor (int i=1;i<this.transformations.size();i++){\n\t\t\tMatrix3d r = new Matrix3d(transformations.get(i).m00,transformations.get(i).m01,transformations.get(i).m02,\n\t\t\t\t\ttransformations.get(i).m10,transformations.get(i).m11,transformations.get(i).m12,\n\t\t\t\t\ttransformations.get(i).m20,transformations.get(i).m21,transformations.get(i).m22);\n\n\t\t\taxisAngles[i] = getRotAxisAndAngle(r);\n\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the axis fold type (1, 2, 3, 4, 5, 6 for rotations or -1, -2, -3, -4, -6 improper rotations)\n\t * from the trace of the rotation matrix, see for instance\n\t * http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n\t */\n\tprivate void calcAxisFoldTypes() {\n\t\taxisTypes = new int[multiplicity];\n\n\t\tfor (int i=0;i<this.transformations.size();i++){\n\n\t\t\taxisTypes[i] = getRotAxisType(transformations.get(i));\n\n\t\t}\n\t}\n\n\tpublic AxisAngle4d getRotAxisAngle(int transformId) {\n\t\tif (this.axisAngles == null) calcRotAxesAndAngles();\n\t\treturn this.axisAngles[transformId];\n\t}\n\n\t/**\n\t * Returns true if both given transform ids belong to the same crystallographic axis (a, b or c)\n\t * For two non-rotation transformations (i.e. identity operators) it returns true\n\t * @param tId1\n\t * @param tId2\n\t * @return\n\t */\n\tpublic boolean areInSameAxis(int tId1, int tId2) {\n\t\tif (tId1==tId2) return true;\n\n\t\tif (axisAngles== null) calcRotAxesAndAngles();\n\n\t\tif (getAxisFoldType(tId1)==1 && getAxisFoldType(tId2)==1) return true;\n\n\t\t// we can't deal yet with improper rotations: we return false whenever either of them is improper\n\t\tif (getAxisFoldType(tId1)<0 || getAxisFoldType(tId2)<0) return false;\n\n\t\tVector3d axis1 = new Vector3d(axisAngles[tId1].x, axisAngles[tId1].y, axisAngles[tId1].z);\n\t\tVector3d axis2 = new Vector3d(axisAngles[tId2].x, axisAngles[tId2].y, axisAngles[tId2].z);\n\n\t\t// TODO revise: we might need to consider that the 2 are in same direction but opposite senses\n\t\t// the method is not used at the moment anyway\n\t\tif (deltaComp(axis1.angle(axis2), 0.0, DELTA)) return true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Given a transformId returns the type of axis of rotation: 1 (no rotation), 2, 3, 4 or 6 -fold\n\t * and for improper rotations: -1, -2, -3, -4 and -6\n\t *\n\t * @param transformId\n\t * @return\n\t */\n\tpublic int getAxisFoldType(int transformId) {\n\t\tif (axisTypes== null) calcAxisFoldTypes();\n\t\treturn axisTypes[transformId];\n\t}\n\n\t/**\n\t * Gets a transformation by index expressed in crystal axes basis.\n\t * Index 0 corresponds always to the identity transformation.\n\t * Beware the returned Matrix4d is not a copy but it stays linked\n\t * to the one stored in this SpaceGroup object\n\t * @param i\n\t * @return\n\t */\n\tpublic Matrix4d getTransformation(int i) {\n\t\treturn transformations.get(i);\n\t}\n\n\t/**\n\t * Gets a transformation algebraic string given its index.\n\t * Index 0 corresponds always to the identity transformation.\n\t * @param i\n\t * @return\n\t */\n\tpublic String getTransfAlgebraic(int i) {\n\t\treturn transfAlgebraic.get(i);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t    final int prime = 31;\n\t    int result = 1;\n\t    result = prime * result + id;\n\t    return result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (! (o instanceof SpaceGroup)) {\n\t\t\treturn false;\n\t\t}\n\t\tSpaceGroup other = (SpaceGroup) o;\n\t\tif (other.getId()==this.getId()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets the number of symmetry operators corresponding to this SpaceGroup (counting\n\t * the identity operator)\n\t * @return\n\t */\n\tpublic int getNumOperators() {\n\t\treturn this.transformations.size();\n\t}\n\n\tpublic static String getAlgebraicFromMatrix(Matrix4d m) {\n\t\tString x = formatAlg(m.m00,m.m01,m.m02,m.m03);\n\t\tString y = formatAlg(m.m10,m.m11,m.m12,m.m13);\n\t\tString z = formatAlg(m.m20,m.m21,m.m22,m.m23);\n\t\tString alg = x+\",\"+y+\",\"+z;\n\t\treturn alg;\n\t}\n\n\tprivate static String formatAlg(double xcoef, double ycoef, double zcoef, double trans) {\n\t\tboolean[] leading = {false,false,false};\n\t\tif (xcoef!=0) {\n\t\t\tleading[0] = true;\n\t\t} else if (ycoef!=0) {\n\t\t\tleading[1] = true;\n\t\t} else if (zcoef!=0) {\n\t\t\tleading[2] = true;\n\t\t}\n\t\tString x = deltaComp(xcoef,0,DELTA)?\"\":formatCoef(xcoef,leading[0])+\"X\";\n\t\tString y = deltaComp(ycoef,0,DELTA)?\"\":formatCoef(ycoef,leading[1])+\"Y\";\n\t\tString z = deltaComp(zcoef,0,DELTA)?\"\":formatCoef(zcoef, leading[2])+\"Z\";\n\t\tString t = deltaComp(trans,0,DELTA)?\"\":formatTransCoef(trans);\n\t\treturn x+y+z+t;\n\n\t}\n\n\tprivate static String formatCoef(double c, boolean leading) {\n\t\tif (leading) {\n\t\t\treturn (deltaComp(Math.abs(c),1,DELTA)?(c>0?\"\":\"-\"):String.format(Locale.US, \"%4.2f\",c));\n\t\t} else {\n\t\t\treturn (deltaComp(Math.abs(c),1,DELTA)?(c>0?\"+\":\"-\"):String.format(Locale.US, \"%+4.2f\",c));\n\t\t}\n\t}\n\n\tprivate static String formatTransCoef(double c) {\n\t\tif (Math.abs((Math.rint(c)-c))<DELTA) { // this is an integer\n\t\t\treturn String.format(\"%+d\",(int)Math.rint(c));\n\t\t} else { // it is a fraction\n\t\t\tint num,den;\n\t\t\tint floor = (int)Math.floor(c);\n\t\t\tdouble decPart = c - floor;\n\t\t\tif (deltaComp(decPart,0.3333333,DELTA)) {\n\t\t\t\tnum=1;den=3;\n\t\t\t} else if (deltaComp(decPart,0.6666667,DELTA)) {\n\t\t\t\tnum=2;den=3;\n\t\t\t} else if (deltaComp(decPart,0.2500000,DELTA)) {\n\t\t\t\tnum=1;den=4;\n\t\t\t} else if (deltaComp(decPart,0.5000000,DELTA)) {\n\t\t\t\tnum=1;den=2;\n\t\t\t} else if (deltaComp(decPart,0.7500000,DELTA)) {\n\t\t\t\tnum=3;den=4;\n\t\t\t} else if (deltaComp(decPart,0.1666667,DELTA)) {\n\t\t\t\tnum=1;den=6;\n\t\t\t} else if (deltaComp(decPart,0.8333333,DELTA)) {\n\t\t\t\tnum=5;den=6;\n\t\t\t} else {\n\t\t\t\tnum=0;den=0; // this in an error\n\t\t\t}\n\t\t\tnum = floor*den+num;\n\t\t\treturn String.format(\"%+d/%d\", num,den);\n\t\t\t//return String.format(\"%+4.2f\",c);\n\t\t}\n\t}\n\n\tprotected static boolean deltaComp(double d1, double d2, double delta) {\n\t\treturn Math.abs(d1-d2)<delta;\n\t}\n\n\tpublic BravaisLattice getBravLattice() {\n\t\treturn bravLattice;\n\t}\n\n\tpublic boolean isEnantiomorphic() {\n\t\tMatcher m = nonEnantPat.matcher(shortSymbol);\n\t\tif (m.find()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Given a rotation matrix calculates the rotation axis and angle for it.\n\t * The angle is calculated from the trace, the axis from the eigenvalue\n\t * decomposition.\n\t * If given matrix is improper rotation or identity matrix then\n\t * axis (0,0,0) and angle 0 are returned.\n\t * @param m\n\t * @return\n\t * @throws IllegalArgumentException if given matrix is not a rotation matrix (determinant not 1 or -1)\n\t */\n\tpublic static AxisAngle4d getRotAxisAndAngle(Matrix3d m) {\n\t\tdouble determinant = m.determinant();\n\n\t\tif (!(Math.abs(determinant)-1.0<DELTA)) throw new IllegalArgumentException(\"Given matrix is not a rotation matrix\");\n\n\t\tAxisAngle4d axisAndAngle = new AxisAngle4d(new Vector3d(0,0,0),0);\n\n\t\tdouble[] d = {m.m00,m.m10,m.m20,\n\t\t\t\tm.m01,m.m11,m.m21,\n\t\t\t\tm.m02,m.m12,m.m22};\n\n\t\tMatrix r = new Matrix(d,3);\n\n\t\tif (!deltaComp(r.det(), 1.0, DELTA)) {\n\t\t\t// improper rotation: we return axis 0,0,0 and angle 0\n\t\t\treturn axisAndAngle;\n\t\t}\n\n\t\tEigenvalueDecomposition evd = new EigenvalueDecomposition(r);\n\n\t\tMatrix eval = evd.getD();\n\t\tif (deltaComp(eval.get(0, 0),1.0,DELTA) && deltaComp(eval.get(1, 1),1.0,DELTA) && deltaComp(eval.get(2, 2),1.0,DELTA)) {\n\t\t\t// the rotation is an identity: we return axis 0,0,0 and angle 0\n\t\t\treturn axisAndAngle;\n\t\t}\n\t\tint indexOfEv1;\n\t\tfor (indexOfEv1=0;indexOfEv1<3;indexOfEv1++) {\n\t\t\tif (deltaComp(eval.get(indexOfEv1, indexOfEv1),1,DELTA)) break;\n\t\t}\n\t\tMatrix evec = evd.getV();\n\t\taxisAndAngle.set(new Vector3d(evec.get(0,indexOfEv1), evec.get(1, indexOfEv1), evec.get(2, indexOfEv1)),\n\t\t\t\tMath.acos((eval.trace()-1.0)/2.0));\n\n\t\treturn axisAndAngle;\n\t}\n\n\t/**\n\t * Given a transformation matrix containing a rotation returns the type of rotation:\n\t * 1 for identity, 2 for 2-fold rotation, 3 for 3-fold rotation, 4 for 4-fold rotation,\n\t * 6 for 6-fold rotation,\n\t * -1 for inversions, -2 for mirror planes, -3 for 3-fold improper rotation,\n\t * -4 for 4-fold improper rotation and -6 for 6-fold improper rotation\n\t * @param m\n\t * @return\n\t */\n\tpublic static int getRotAxisType(Matrix4d m) {\n\t\tint axisType = 0;\n\n\t\tMatrix3d rot = new Matrix3d(m.m00,m.m01,m.m02,\n\t\t\t\tm.m10,m.m11,m.m12,\n\t\t\t\tm.m20,m.m21,m.m22);\n\n\t\tdouble determinant = rot.determinant();\n\n\t\tif (!deltaComp(determinant,1.0,DELTA) && !deltaComp(determinant, -1.0, DELTA)) {\n\t\t\tthrow new IllegalArgumentException(\"Given matrix does not seem to be a rotation matrix.\");\n\t\t}\n\n\t\tint trace = (int)(rot.m00+rot.m11+rot.m22);\n\t\tif (determinant>0) {\n\t\t\tswitch (trace) {\n\t\t\tcase 3:\n\t\t\t\taxisType=1;\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\taxisType=2;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\taxisType=3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taxisType=4;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taxisType=6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (trace) {\n\t\t\tcase -3:\n\t\t\t\taxisType=-1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taxisType=-2;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\taxisType=-3;\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\taxisType=-4;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\taxisType=-6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n\t\t\t}\n\t\t}\n\t\treturn axisType;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getShortSymbol();\n\t}\n\n\tpublic String toXML(){\n\n\n\t\tJAXBContext jaxbContextStringSortedSet = null;\n\n\t\ttry {\n\t\t\tjaxbContextStringSortedSet= JAXBContext.newInstance(SpaceGroup.class);\n\t\t} catch (JAXBException e){\n\t\t\tlogger.error(\"Error converting to XML\",e);\n\t\t\treturn null;\n\t\t}\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tPrintStream ps = new PrintStream(baos);\n\n\n\t\ttry {\n\n\t\t\tMarshaller m = jaxbContextStringSortedSet.createMarshaller();\n\n\t\t\tm.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\n\t\t\tm.marshal( this, ps);\n\n\n\t\t} catch (JAXBException e){\n\t\t\tlogger.error(\"Error converting to XML\",e);\n\t\t}\n\n\t\treturn baos.toString();\n\t}\n\n\t//@XmlElementWrapper(name=\"transfAlgebraicList\", namespace=\"http://www.biojava.org\")\n\t//@XmlElement\n\t@XmlJavaTypeAdapter(TransfAlgebraicAdapter.class)\n\tpublic List<String> getTransfAlgebraic() {\n\t\treturn transfAlgebraic;\n\t}\n\n\tpublic void setTransfAlgebraic(List<String> transfAlgebraic) {\n\t\t//System.out.println(\"setting transfAlgebraic \" + transfAlgebraic);\n\t\tif ( transformations == null || transformations.size() == 0)\n\t\t\ttransformations = new ArrayList<Matrix4d>(transfAlgebraic.size());\n\n\t\tif ( this.transfAlgebraic == null || this.transfAlgebraic.size() == 0)\n\t\t\tthis.transfAlgebraic = new ArrayList<String>(transfAlgebraic.size());\n\n\t\tfor ( String transf : transfAlgebraic){\n\t\t\taddTransformation(transf);\n\t\t}\n\t}\n\n\n\tpublic int[] getAxisTypes() {\n\t\treturn axisTypes;\n\t}\n\n\tpublic void setAxisTypes(int[] axisTypes) {\n\t\tthis.axisTypes = axisTypes;\n\t}\n\n\tpublic static long getSerialversionuid() {\n\t\treturn serialVersionUID;\n\t}\n\n\tpublic static Pattern getSplitpat1() {\n\t\treturn splitPat1;\n\t}\n\n\tpublic static Pattern getSplitpat2() {\n\t\treturn splitPat2;\n\t}\n\n\tpublic static Pattern getCoordpat() {\n\t\treturn coordPat;\n\t}\n\n\tpublic static Pattern getTranscoefpat() {\n\t\treturn transCoefPat;\n\t}\n\n\tpublic static Pattern getNonenantpat() {\n\t\treturn nonEnantPat;\n\t}\n\n\tpublic static double getDelta() {\n\t\treturn DELTA;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void setMultiplicity(int multiplicity) {\n\n\t\tthis.multiplicity = multiplicity;\n\t}\n\n\tpublic void setPrimitiveMultiplicity(int primitiveMultiplicity) {\n\t\tthis.primitiveMultiplicity = primitiveMultiplicity;\n\t}\n\n\tpublic void setShortSymbol(String shortSymbol) {\n\t\tthis.shortSymbol = shortSymbol;\n\t}\n\n\tpublic void setAltShortSymbol(String altShortSymbol) {\n\t\tthis.altShortSymbol = altShortSymbol;\n\t}\n\n\n\tpublic void setBravLattice(BravaisLattice bravLattice) {\n\t\tthis.bravLattice = bravLattice;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.xtal;\n\nimport org.biojava.nbio.structure.jama.EigenvalueDecomposition;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.xtal.io.TransfAlgebraicAdapter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\nimport jakarta.xml.bind.JAXBContext;\nimport jakarta.xml.bind.JAXBException;\nimport jakarta.xml.bind.Marshaller;\nimport jakarta.xml.bind.annotation.XmlAccessType;\nimport jakarta.xml.bind.annotation.XmlAccessorType;\nimport jakarta.xml.bind.annotation.XmlRootElement;\nimport jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n/**\n * A crystallographic space group. We store the standard numeric identifier,\n * the international short symbol and the transformations corresponding to\n * each space group (as Matrix4ds and in algebraic notation).\n * The information for all (protein crystallography) space groups can be\n * parsed from the XML file in the resource directory.\n *\n * See: http://en.wikipedia.org/wiki/Space_group\n *\n * @author duarte_j\n * @see SymoplibParser\n */\n@XmlRootElement(name = \"SpaceGroup\", namespace =\"http://www.biojava.org\")\n@XmlAccessorType(XmlAccessType.PUBLIC_MEMBER)\npublic class SpaceGroup implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(SpaceGroup.class);\n\n\n\tprivate static final Pattern splitPat1 = Pattern.compile(\"((?:[+-]?[XYZ])+)([+-][0-9/.]+)\");\n\tprivate static final Pattern splitPat2 = Pattern.compile(\"([+-]?[0-9/.]+)((?:[+-][XYZ])+)\");\n\tprivate static final Pattern coordPat = Pattern.compile(\"(?:([+-])?([XYZ]))+?\"); // the last +? is for ungreedy matching\n\tprivate static final Pattern transCoefPat = Pattern.compile(\"([-+]?[0-9.]+)(?:/([0-9.]+))?\");\n\n\tprivate static final Pattern nonEnantPat = Pattern.compile(\"[-abcmnd]\");\n\n\tprotected static final double DELTA=0.0000001;\n\n\tprivate  int id;\n\tprivate  int multiplicity;\n\tprivate  int primitiveMultiplicity;\n\tprivate  String shortSymbol;\n\tprivate  String altShortSymbol;\n\tprivate  List<Matrix4d> transformations;\n\tprivate  List<String> transfAlgebraic;\n\tprivate  Vector3d[] cellTranslations; // in space groups I, C, F or H there are pure cell translations corresponding to recenterings\n\n\tprivate AxisAngle4d[] axisAngles;\n\n\tprivate int[] axisTypes; // indices of array are transformIds\n\n\tprivate BravaisLattice bravLattice;\n\n\t@SuppressWarnings(\"unused\")\n\tprivate SpaceGroup(){\n\t\t// required by JAXB\n\n\t}\n\n\tpublic SpaceGroup(int id, int multiplicity, int primitiveMultiplicity, String shortSymbol, String altShortSymbol, BravaisLattice bravLattice) {\n\t\tthis.id = id;\n\t\tthis.multiplicity = multiplicity;\n\t\tthis.primitiveMultiplicity = primitiveMultiplicity;\n\t\tthis.shortSymbol = shortSymbol;\n\t\tthis.altShortSymbol = altShortSymbol;\n\t\ttransformations = new ArrayList<Matrix4d>(multiplicity);\n\t\ttransfAlgebraic = new ArrayList<String>(multiplicity);\n\t\tcellTranslations = new Vector3d[multiplicity/primitiveMultiplicity];\n\t\tthis.bravLattice = bravLattice;\n\t}\n\n\t/**\n\t * Get the space group for the given international short name, using\n\t * the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'\n\t * @param shortName\n\t * @return the SpaceGroup or null if the shortName is not valid\n\t * @see SymoplibParser#getSpaceGroup(String)\n\t */\n\tpublic static SpaceGroup parseSpaceGroup(String shortName) {\n\t\treturn SymoplibParser.getSpaceGroup(shortName);\n\t}\n\n\tpublic void addTransformation(String transfAlgebraic) {\n\t\tthis.transfAlgebraic.add(transfAlgebraic);\n\t\tthis.transformations.add(getMatrixFromAlgebraic(transfAlgebraic));\n\t}\n\n\tprotected void initializeCellTranslations() {\n\t\tif ( cellTranslations != null && cellTranslations.length >0) {\n\t\t\t// we already initialized this\n\t\t\treturn;\n\t\t}\n\t\tcellTranslations = new Vector3d[multiplicity/primitiveMultiplicity];\n\t\tcellTranslations[0] = new Vector3d(0,0,0);\n\n\t\tif ( transformations == null){\n\t\t\tlogger.warn(\"transformations == null\" + this.toXML());\n\t\t}\n\n\t\tif (multiplicity==primitiveMultiplicity) {\n\t\t\treturn;\n\t\t}\n\t\tint fold = multiplicity/primitiveMultiplicity;\n\n\n\n\t\tfor (int n=1;n<fold;n++) {\n\t\t\tif ( transformations.size() < (n* primitiveMultiplicity)){\n\t\t\t\tlogger.warn(\"WARNING number of transformations < \" +(n*primitiveMultiplicity));\n\t\t\t\tlogger.warn(this.toXML());\n\t\t\t}\n\t\t\tMatrix4d t = transformations.get(n*primitiveMultiplicity);\n\t\t\tcellTranslations[n] = new Vector3d(t.m03,t.m13,t.m23);\n\t\t}\n\t}\n\n\tpublic int getMultiplicity() {\n\t\treturn multiplicity;\n\t}\n\n\tpublic int getPrimitiveMultiplicity() {\n\t\treturn primitiveMultiplicity;\n\t}\n\n\tpublic Vector3d[] getCellTranslations() {\n\t\treturn cellTranslations;\n\t}\n\n\tpublic Vector3d getCellTranslation(int i) {\n\t\treturn cellTranslations[i];\n\t}\n\n\tpublic static Matrix4d getMatrixFromAlgebraic(String transfAlgebraic) {\n\t\tString[] parts = transfAlgebraic.toUpperCase().split(\",\");\n\t\tdouble[] xCoef = convertAlgebraicStrToCoefficients(parts[0].trim());\n\t\tdouble[] yCoef = convertAlgebraicStrToCoefficients(parts[1].trim());\n\t\tdouble[] zCoef = convertAlgebraicStrToCoefficients(parts[2].trim());\n\n\t\tMatrix4d mat = new Matrix4d();\n\t\tmat.setIdentity();\n\t\tmat.setRotation(new Matrix3d(xCoef[0],xCoef[1],xCoef[2],yCoef[0],yCoef[1],yCoef[2],zCoef[0],zCoef[1],zCoef[2]));\n\t\tmat.setTranslation(new Vector3d(xCoef[3],yCoef[3],zCoef[3]));\n\t\treturn mat;\n\t\t//return new Matrix4d(xCoef[0],xCoef[1],xCoef[2],xCoef[3],\n\t\t//\t\t\t\t\tyCoef[0],yCoef[1],yCoef[2],yCoef[3],\n\t\t//\t\t\t\t\tzCoef[0],zCoef[1],zCoef[2],zCoef[3],\n\t\t//\t\t\t\t\t0,0,0,1);\n\t}\n\n\tprivate static double[] convertAlgebraicStrToCoefficients(String algString) {\n\t\tString letters = null;\n\t\tString noLetters = null;\n\t\tMatcher m = splitPat1.matcher(algString);\n\t\tif (m.matches()) {\n\t\t\tletters = m.group(1);\n\t\t\tnoLetters = m.group(2);\n\t\t} else {\n\t\t\tm = splitPat2.matcher(algString);\n\t\t\tif (m.matches()) {\n\t\t\t\tletters = m.group(2);\n\t\t\t\tnoLetters = m.group(1);\n\t\t\t} else {\n\t\t\t\tletters = algString;\n\t\t\t}\n\t\t}\n\t\tdouble[] coefficients = new double[4];\n\t\tm = coordPat.matcher(letters);\n\t\twhile(m.find()){\n\t\t\tString sign = \"\";\n\t\t\tif (m.group(1)!=null) {\n\t\t\t\tsign = m.group(1);\n\t\t\t}\n\t\t\tdouble s = 1.0;\n\t\t\tif (\"-\".equals(sign)){\n\t\t\t\ts = -1.0;\n\t\t\t}\n\t\t\tString coord = m.group(2);\n\t\t\tif (\"X\".equals(coord)) {\n\t\t\t\tcoefficients[0] = s;\n\t\t\t} else if (\"Y\".equals(coord)) {\n\t\t\t\tcoefficients[1] = s;\n\t\t\t} else if (\"Z\".equals(coord)) {\n\t\t\t\tcoefficients[2] = s;\n\t\t\t}\n\t\t}\n\t\tif (noLetters!=null) {\n\t\t\tm = transCoefPat.matcher(noLetters);\n\t\t\tif (m.matches()) {\n\t\t\t\tdouble num = Double.parseDouble(m.group(1));\n\t\t\t\tdouble den = 1;\n\t\t\t\tif (m.group(2)!=null) {\n\t\t\t\t\tden = Double.parseDouble(m.group(2));\n\t\t\t\t}\n\t\t\t\tcoefficients[3] = num/den;\n\t\t\t}\n\t\t} else {\n\t\t\tcoefficients[3]=0;\n\t\t}\n\t\treturn coefficients;\n\t}\n\n\t/**\n\t * Gets the standard numeric identifier for the space group.\n\t * See for example http://en.wikipedia.org/wiki/Space_group\n\t * or the IUCr crystallographic tables\n\t * @return\n\t */\n\tpublic int getId() {\n\t\treturn id;\n\t}\n\n\t/**\n\t * Gets the international short name (as used in PDB),\n\t * e.g. \"P 21 21 21\" or \"C 1 c 1\"\n\t * @return\n\t */\n\tpublic String getShortSymbol() {\n\t\treturn shortSymbol;\n\t}\n\n\t/**\n\t * Gets the alternative international short name (as sometimes used in PDB),\n\t * e.g. \"I 1 2 1\" instead of \"I 2\"\n\t * @return\n\t */\n\tpublic String getAltShortSymbol() {\n\t\treturn altShortSymbol;\n\t}\n\n\t/**\n\t * Gets all transformations except for the identity in crystal axes basis.\n\t * @return\n\t */\n\tpublic List<Matrix4d> getTransformations() {\n\t\tList<Matrix4d> transfs = new ArrayList<Matrix4d>();\n\t\tfor (int i=1;i<this.transformations.size();i++){\n\t\t\ttransfs.add(transformations.get(i));\n\t\t}\n\t\treturn transfs;\n\t}\n\n\tprivate void calcRotAxesAndAngles() {\n\n\t\taxisAngles = new AxisAngle4d[multiplicity];\n\n\t\t// identity operator (transformId==0)\n\t\taxisAngles[0] = new AxisAngle4d(new Vector3d(0,0,0), 0.0);\n\n\t\tfor (int i=1;i<this.transformations.size();i++){\n\t\t\tMatrix3d r = new Matrix3d(transformations.get(i).m00,transformations.get(i).m01,transformations.get(i).m02,\n\t\t\t\t\ttransformations.get(i).m10,transformations.get(i).m11,transformations.get(i).m12,\n\t\t\t\t\ttransformations.get(i).m20,transformations.get(i).m21,transformations.get(i).m22);\n\n\t\t\taxisAngles[i] = getRotAxisAndAngle(r);\n\n\t\t}\n\t}\n\n\t/**\n\t * Calculates the axis fold type (1, 2, 3, 4, 5, 6 for rotations or -1, -2, -3, -4, -6 improper rotations)\n\t * from the trace of the rotation matrix, see for instance\n\t * http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n\t */\n\tprivate void calcAxisFoldTypes() {\n\t\taxisTypes = new int[multiplicity];\n\n\t\tfor (int i=0;i<this.transformations.size();i++){\n\n\t\t\taxisTypes[i] = getRotAxisType(transformations.get(i));\n\n\t\t}\n\t}\n\n\tpublic AxisAngle4d getRotAxisAngle(int transformId) {\n\t\tif (this.axisAngles == null) calcRotAxesAndAngles();\n\t\treturn this.axisAngles[transformId];\n\t}\n\n\t/**\n\t * Returns true if both given transform ids belong to the same crystallographic axis (a, b or c)\n\t * For two non-rotation transformations (i.e. identity operators) it returns true\n\t * @param tId1\n\t * @param tId2\n\t * @return\n\t */\n\tpublic boolean areInSameAxis(int tId1, int tId2) {\n\t\tif (tId1==tId2) return true;\n\n\t\tif (axisAngles== null) calcRotAxesAndAngles();\n\n\t\tif (getAxisFoldType(tId1)==1 && getAxisFoldType(tId2)==1) return true;\n\n\t\t// we can't deal yet with improper rotations: we return false whenever either of them is improper\n\t\tif (getAxisFoldType(tId1)<0 || getAxisFoldType(tId2)<0) return false;\n\n\t\tVector3d axis1 = new Vector3d(axisAngles[tId1].x, axisAngles[tId1].y, axisAngles[tId1].z);\n\t\tVector3d axis2 = new Vector3d(axisAngles[tId2].x, axisAngles[tId2].y, axisAngles[tId2].z);\n\n\t\t// TODO revise: we might need to consider that the 2 are in same direction but opposite senses\n\t\t// the method is not used at the moment anyway\n\t\tif (deltaComp(axis1.angle(axis2), 0.0, DELTA)) return true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Given a transformId returns the type of axis of rotation: 1 (no rotation), 2, 3, 4 or 6 -fold\n\t * and for improper rotations: -1, -2, -3, -4 and -6\n\t *\n\t * @param transformId\n\t * @return\n\t */\n\tpublic int getAxisFoldType(int transformId) {\n\t\tif (axisTypes== null) calcAxisFoldTypes();\n\t\treturn axisTypes[transformId];\n\t}\n\n\t/**\n\t * Gets a transformation by index expressed in crystal axes basis.\n\t * Index 0 corresponds always to the identity transformation.\n\t * Beware the returned Matrix4d is not a copy but it stays linked\n\t * to the one stored in this SpaceGroup object\n\t * @param i\n\t * @return\n\t */\n\tpublic Matrix4d getTransformation(int i) {\n\t\treturn transformations.get(i);\n\t}\n\n\t/**\n\t * Gets a transformation algebraic string given its index.\n\t * Index 0 corresponds always to the identity transformation.\n\t * @param i\n\t * @return\n\t */\n\tpublic String getTransfAlgebraic(int i) {\n\t\treturn transfAlgebraic.get(i);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t    final int prime = 31;\n\t    int result = 1;\n\t    result = prime * result + id;\n\t    return result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\tif (! (o instanceof SpaceGroup)) {\n\t\t\treturn false;\n\t\t}\n\t\tSpaceGroup other = (SpaceGroup) o;\n\t\tif (other.getId()==this.getId()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Gets the number of symmetry operators corresponding to this SpaceGroup (counting\n\t * the identity operator)\n\t * @return\n\t */\n\tpublic int getNumOperators() {\n\t\treturn this.transformations.size();\n\t}\n\n\tpublic static String getAlgebraicFromMatrix(Matrix4d m) {\n\t\tString x = formatAlg(m.m00,m.m01,m.m02,m.m03);\n\t\tString y = formatAlg(m.m10,m.m11,m.m12,m.m13);\n\t\tString z = formatAlg(m.m20,m.m21,m.m22,m.m23);\n\t\tString alg = x+\",\"+y+\",\"+z;\n\t\treturn alg;\n\t}\n\n\tprivate static String formatAlg(double xcoef, double ycoef, double zcoef, double trans) {\n\t\tboolean[] leading = {false,false,false};\n\t\tif (xcoef!=0) {\n\t\t\tleading[0] = true;\n\t\t} else if (ycoef!=0) {\n\t\t\tleading[1] = true;\n\t\t} else if (zcoef!=0) {\n\t\t\tleading[2] = true;\n\t\t}\n\t\tString x = deltaComp(xcoef,0,DELTA)?\"\":formatCoef(xcoef,leading[0])+\"X\";\n\t\tString y = deltaComp(ycoef,0,DELTA)?\"\":formatCoef(ycoef,leading[1])+\"Y\";\n\t\tString z = deltaComp(zcoef,0,DELTA)?\"\":formatCoef(zcoef, leading[2])+\"Z\";\n\t\tString t = deltaComp(trans,0,DELTA)?\"\":formatTransCoef(trans);\n\t\treturn x+y+z+t;\n\n\t}\n\n\tprivate static String formatCoef(double c, boolean leading) {\n\t\tif (leading) {\n\t\t\treturn (deltaComp(Math.abs(c),1,DELTA)?(c>0?\"\":\"-\"):String.format(Locale.US, \"%4.2f\",c));\n\t\t} else {\n\t\t\treturn (deltaComp(Math.abs(c),1,DELTA)?(c>0?\"+\":\"-\"):String.format(Locale.US, \"%+4.2f\",c));\n\t\t}\n\t}\n\n\tprivate static String formatTransCoef(double c) {\n\t\tif (Math.abs((Math.rint(c)-c))<DELTA) { // this is an integer\n\t\t\treturn String.format(\"%+d\",(int)Math.rint(c));\n\t\t} else { // it is a fraction\n\t\t\tint num,den;\n\t\t\tint floor = (int)Math.floor(c);\n\t\t\tdouble decPart = c - floor;\n\t\t\tif (deltaComp(decPart,0.3333333,DELTA)) {\n\t\t\t\tnum=1;den=3;\n\t\t\t} else if (deltaComp(decPart,0.6666667,DELTA)) {\n\t\t\t\tnum=2;den=3;\n\t\t\t} else if (deltaComp(decPart,0.2500000,DELTA)) {\n\t\t\t\tnum=1;den=4;\n\t\t\t} else if (deltaComp(decPart,0.5000000,DELTA)) {\n\t\t\t\tnum=1;den=2;\n\t\t\t} else if (deltaComp(decPart,0.7500000,DELTA)) {\n\t\t\t\tnum=3;den=4;\n\t\t\t} else if (deltaComp(decPart,0.1666667,DELTA)) {\n\t\t\t\tnum=1;den=6;\n\t\t\t} else if (deltaComp(decPart,0.8333333,DELTA)) {\n\t\t\t\tnum=5;den=6;\n\t\t\t} else {\n\t\t\t\tnum=0;den=0; // this in an error\n\t\t\t}\n\t\t\tnum = floor*den+num;\n\t\t\treturn String.format(\"%+d/%d\", num,den);\n\t\t\t//return String.format(\"%+4.2f\",c);\n\t\t}\n\t}\n\n\tprotected static boolean deltaComp(double d1, double d2, double delta) {\n\t\treturn Math.abs(d1-d2)<delta;\n\t}\n\n\tpublic BravaisLattice getBravLattice() {\n\t\treturn bravLattice;\n\t}\n\n\tpublic boolean isEnantiomorphic() {\n\t\tMatcher m = nonEnantPat.matcher(shortSymbol);\n\t\tif (m.find()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Given a rotation matrix calculates the rotation axis and angle for it.\n\t * The angle is calculated from the trace, the axis from the eigenvalue\n\t * decomposition.\n\t * If given matrix is improper rotation or identity matrix then\n\t * axis (0,0,0) and angle 0 are returned.\n\t * @param m\n\t * @return\n\t * @throws IllegalArgumentException if given matrix is not a rotation matrix (determinant not 1 or -1)\n\t */\n\tpublic static AxisAngle4d getRotAxisAndAngle(Matrix3d m) {\n\t\tdouble determinant = m.determinant();\n\n\t\tif (!(Math.abs(determinant)-1.0<DELTA)) throw new IllegalArgumentException(\"Given matrix is not a rotation matrix\");\n\n\t\tAxisAngle4d axisAndAngle = new AxisAngle4d(new Vector3d(0,0,0),0);\n\n\t\tdouble[] d = {m.m00,m.m10,m.m20,\n\t\t\t\tm.m01,m.m11,m.m21,\n\t\t\t\tm.m02,m.m12,m.m22};\n\n\t\tMatrix r = new Matrix(d,3);\n\n\t\tif (!deltaComp(r.det(), 1.0, DELTA)) {\n\t\t\t// improper rotation: we return axis 0,0,0 and angle 0\n\t\t\treturn axisAndAngle;\n\t\t}\n\n\t\tEigenvalueDecomposition evd = new EigenvalueDecomposition(r);\n\n\t\tMatrix eval = evd.getD();\n\t\tif (deltaComp(eval.get(0, 0),1.0,DELTA) && deltaComp(eval.get(1, 1),1.0,DELTA) && deltaComp(eval.get(2, 2),1.0,DELTA)) {\n\t\t\t// the rotation is an identity: we return axis 0,0,0 and angle 0\n\t\t\treturn axisAndAngle;\n\t\t}\n\t\tint indexOfEv1;\n\t\tfor (indexOfEv1=0;indexOfEv1<3;indexOfEv1++) {\n\t\t\tif (deltaComp(eval.get(indexOfEv1, indexOfEv1),1,DELTA)) break;\n\t\t}\n\t\tMatrix evec = evd.getV();\n\t\taxisAndAngle.set(new Vector3d(evec.get(0,indexOfEv1), evec.get(1, indexOfEv1), evec.get(2, indexOfEv1)),\n\t\t\t\tMath.acos((eval.trace()-1.0)/2.0));\n\n\t\treturn axisAndAngle;\n\t}\n\n\t/**\n\t * Given a transformation matrix containing a rotation returns the type of rotation:\n\t * 1 for identity, 2 for 2-fold rotation, 3 for 3-fold rotation, 4 for 4-fold rotation,\n\t * 6 for 6-fold rotation,\n\t * -1 for inversions, -2 for mirror planes, -3 for 3-fold improper rotation,\n\t * -4 for 4-fold improper rotation and -6 for 6-fold improper rotation\n\t * @param m\n\t * @return\n\t */\n\tpublic static int getRotAxisType(Matrix4d m) {\n\t\tint axisType = 0;\n\n\t\tMatrix3d rot = new Matrix3d(m.m00,m.m01,m.m02,\n\t\t\t\tm.m10,m.m11,m.m12,\n\t\t\t\tm.m20,m.m21,m.m22);\n\n\t\tdouble determinant = rot.determinant();\n\n\t\tif (!deltaComp(determinant,1.0,DELTA) && !deltaComp(determinant, -1.0, DELTA)) {\n\t\t\tthrow new IllegalArgumentException(\"Given matrix does not seem to be a rotation matrix.\");\n\t\t}\n\n\t\tint trace = (int)(rot.m00+rot.m11+rot.m22);\n\t\tif (determinant>0) {\n\t\t\tswitch (trace) {\n\t\t\tcase 3:\n\t\t\t\taxisType=1;\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\taxisType=2;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\taxisType=3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taxisType=4;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taxisType=6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (trace) {\n\t\t\tcase -3:\n\t\t\t\taxisType=-1;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taxisType=-2;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\taxisType=-3;\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\taxisType=-4;\n\t\t\t\tbreak;\n\t\t\tcase -2:\n\t\t\t\taxisType=-6;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n\t\t\t}\n\t\t}\n\t\treturn axisType;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getShortSymbol();\n\t}\n\n\tpublic String toXML(){\n\n\n\t\tJAXBContext jaxbContextStringSortedSet = null;\n\n\t\ttry {\n\t\t\tjaxbContextStringSortedSet= JAXBContext.newInstance(SpaceGroup.class);\n\t\t} catch (JAXBException e){\n\t\t\tlogger.error(\"Error converting to XML\",e);\n\t\t\treturn null;\n\t\t}\n\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tPrintStream ps = new PrintStream(baos);\n\n\n\t\ttry {\n\n\t\t\tMarshaller m = jaxbContextStringSortedSet.createMarshaller();\n\n\t\t\tm.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\n\n\t\t\tm.marshal( this, ps);\n\n\n\t\t} catch (JAXBException e){\n\t\t\tlogger.error(\"Error converting to XML\",e);\n\t\t}\n\n\t\treturn baos.toString();\n\t}\n\n\t//@XmlElementWrapper(name=\"transfAlgebraicList\", namespace=\"http://www.biojava.org\")\n\t//@XmlElement\n\t@XmlJavaTypeAdapter(TransfAlgebraicAdapter.class)\n\tpublic List<String> getTransfAlgebraic() {\n\t\treturn transfAlgebraic;\n\t}\n\n\tpublic void setTransfAlgebraic(List<String> transfAlgebraic) {\n\t\t//System.out.println(\"setting transfAlgebraic \" + transfAlgebraic);\n\t\tif ( transformations == null || transformations.size() == 0)\n\t\t\ttransformations = new ArrayList<Matrix4d>(transfAlgebraic.size());\n\n\t\tif ( this.transfAlgebraic == null || this.transfAlgebraic.size() == 0)\n\t\t\tthis.transfAlgebraic = new ArrayList<String>(transfAlgebraic.size());\n\n\t\tfor ( String transf : transfAlgebraic){\n\t\t\taddTransformation(transf);\n\t\t}\n\t}\n\n\n\tpublic int[] getAxisTypes() {\n\t\treturn axisTypes;\n\t}\n\n\tpublic void setAxisTypes(int[] axisTypes) {\n\t\tthis.axisTypes = axisTypes;\n\t}\n\n\tpublic static long getSerialversionuid() {\n\t\treturn serialVersionUID;\n\t}\n\n\tpublic static Pattern getSplitpat1() {\n\t\treturn splitPat1;\n\t}\n\n\tpublic static Pattern getSplitpat2() {\n\t\treturn splitPat2;\n\t}\n\n\tpublic static Pattern getCoordpat() {\n\t\treturn coordPat;\n\t}\n\n\tpublic static Pattern getTranscoefpat() {\n\t\treturn transCoefPat;\n\t}\n\n\tpublic static Pattern getNonenantpat() {\n\t\treturn nonEnantPat;\n\t}\n\n\tpublic static double getDelta() {\n\t\treturn DELTA;\n\t}\n\n\tpublic void setId(int id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic void setMultiplicity(int multiplicity) {\n\n\t\tthis.multiplicity = multiplicity;\n\t}\n\n\tpublic void setPrimitiveMultiplicity(int primitiveMultiplicity) {\n\t\tthis.primitiveMultiplicity = primitiveMultiplicity;\n\t}\n\n\tpublic void setShortSymbol(String shortSymbol) {\n\t\tthis.shortSymbol = shortSymbol;\n\t}\n\n\tpublic void setAltShortSymbol(String altShortSymbol) {\n\t\tthis.altShortSymbol = altShortSymbol;\n\t}\n\n\n\tpublic void setBravLattice(BravaisLattice bravLattice) {\n\t\tthis.bravLattice = bravLattice;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.xtal;\n\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\nimport java.util.Collection;\n\n/**\n * Testing of space group symop.lib parsing and for crystal operator calculation correctness\n *\n * @author duarte_j\n *\n */\npublic class TestSpaceGroup {\n\n\tprivate static final double DELTA = 0.000001;\n\t// use true for printing operators of all space groups (including non-enantiomorphics), or false to print only enantiomorphics\n\tprivate static boolean PRINT_OPERATORS_FROM_ALL_SGS = false;\n\n\t// print information per operator\n\tprivate static boolean VERBOSE = false;\n\n\t@Test\n\tpublic void testTransfConversion() {\n\t\tCollection<SpaceGroup> allSGs = SymoplibParser.getAllSpaceGroups().values();\n\n\t\tint countEn = 0;\n\t\tint countNonEn = 0;\n\t\tint countSpecial = 0;\n\t\tfor (SpaceGroup spaceGroup:allSGs) {\n\n\t\t\tif (spaceGroup.isEnantiomorphic() && spaceGroup.getId()<1000) {\n\t\t\t\tcountEn++;\n\t\t\t}\n\t\t\tif (!spaceGroup.isEnantiomorphic() && spaceGroup.getId()<1000) {\n\t\t\t\tcountNonEn++;\n\t\t\t}\n\t\t\tif (spaceGroup.getId()>1000) {\n\t\t\t\tcountSpecial++;\n\t\t\t}\n\n\t\t\tif (VERBOSE)\n\t\t\t\tSystem.out.println(spaceGroup.getId()+\"  \"+spaceGroup.getShortSymbol()+\" -- \"+spaceGroup.getMultiplicity()+\" \"+spaceGroup.getPrimitiveMultiplicity());\n\n\n\t\t\t// cell translations must be the same in each subgroup of operators (applies to I, C, F and H SGs)\n\t\t\tif (spaceGroup.getId()<1000) {\n\t\t\t\tint fold = spaceGroup.getMultiplicity()/spaceGroup.getPrimitiveMultiplicity();\n\t\t\t\tfor (int n=1;n<fold;n++) {\n\t\t\t\t\tfor (int j=0;j<spaceGroup.getPrimitiveMultiplicity();j++) {\n\t\t\t\t\t\tMatrix4d t = spaceGroup.getTransformation(n*spaceGroup.getPrimitiveMultiplicity()+j);\n\t\t\t\t\t\tMatrix4d tPrimitive = spaceGroup.getTransformation(j);\n\t\t\t\t\t\tVector3d cellTransl = new Vector3d(t.m03,t.m13,t.m23);\n\t\t\t\t\t\tVector3d primitive = new Vector3d(tPrimitive.m03,tPrimitive.m13,tPrimitive.m23);\n\t\t\t\t\t\tcellTransl.sub(spaceGroup.getCellTranslation(n));\n\n\t\t\t\t\t\tdouble diffx = primitive.x - cellTransl.x;\n\t\t\t\t\t\tdouble diffy = primitive.y - cellTransl.y;\n\t\t\t\t\t\tdouble diffz = primitive.z - cellTransl.z;\n\n\t\t\t\t\t\tif (!(\n\t\t\t\t\t\t\t\t(Math.abs(diffx)<0.000001 &&\n\t\t\t\t\t\t\t\t Math.abs(diffy)<0.000001 &&\n\t\t\t\t\t\t\t\t Math.abs(diffz)<0.000001)\n\t\t\t\t\t\t\t\t )) {\n\n\t\t\t\t\t\t\t//System.out.printf(\"DIFF NOT 0: \\n\" +\n\t\t\t\t\t\t\t//\t\t\" primitive (%5.2f,%5.2f,%5.2f), multiple (%5.2f,%5.2f,%5.2f), difference (%5.2f,%5.2f,%5.2f)\\n\",\n\t\t\t\t\t\t\t//\t\tprimitive.x, primitive.y, primitive.z,\n\t\t\t\t\t\t\t//\t\tcellTransl.x ,cellTransl.y, cellTransl.z,\n\t\t\t\t\t\t\t//\t\tdiffx, diffy, diffz);\n\n\t\t\t\t\t\t\t// they are positive and not larger than 1\n\t\t\t\t\t\t\tAssert.assertFalse(diffx>1 && diffx<0);\n\t\t\t\t\t\t\tAssert.assertFalse(diffy>1 && diffy<0);\n\t\t\t\t\t\t\tAssert.assertFalse(diffz>1 && diffz<0);\n\n\t\t\t\t\t\t\t// they are integer, i.e. 0 or 1\n\t\t\t\t\t\t\tAssert.assertTrue(diffx == (int)diffx);\n\t\t\t\t\t\t\tAssert.assertTrue(diffy == (int)diffy);\n\t\t\t\t\t\t\tAssert.assertTrue(diffz == (int)diffz);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int i=0;i<spaceGroup.getNumOperators();i++){\n\t\t\t\tCrystalCell unitCell = spaceGroup.getBravLattice().getExampleUnitCell();\n\t\t\t\tMatrix4d m = spaceGroup.getTransformation(i);\n\t\t\t\tMatrix4d mT = unitCell.transfToOrthonormal(m);\n\n\t\t\t\t// as stated in PDB documentation for SCALE matrix (our MTranspose matrix) the inverse determinant should match the cell volume\n\t\t\t\tAssert.assertEquals(unitCell.getVolume(),1.0/unitCell.getMTranspose().determinant(),DELTA);\n\t\t\t\t// and checking that our method to check scale matrix works as expected\n\t\t\t\tMatrix4d scaleMat = new Matrix4d(unitCell.getMTranspose(),new Vector3d(0,0,0),1);\n\t\t\t\tAssert.assertTrue(unitCell.checkScaleMatrixConsistency(scaleMat));\n\n\t\t\t\t// traces before and after transformation must coincide\n\t\t\t\tAssert.assertEquals(m.m00+m.m11+m.m22+m.m33, mT.m00+mT.m11+mT.m22+mT.m33, DELTA);\n\n\t\t\t\tMatrix3d rot = new Matrix3d(mT.m00,mT.m01,mT.m02,mT.m10,mT.m11,mT.m12,mT.m20,mT.m21,mT.m22);\n\n\t\t\t\t// determinant is either 1 or -1 (for improper rotations i.e. mirrors)\n\t\t\t\tAssert.assertTrue(Math.abs(rot.determinant()-1)<DELTA || Math.abs(rot.determinant()+1)<DELTA);\n\n\t\t\t\tCrystalTransform ct = new CrystalTransform(spaceGroup, i);\n\n\t\t\t\tif (spaceGroup.isEnantiomorphic() && spaceGroup.getId()<1000) {\n\n\t\t\t\t\t// determinant must be 1\n\t\t\t\t\tAssert.assertEquals(1.0,rot.determinant(), DELTA);\n\n\t\t\t\t\t// at least 1 eigenvalue must be 1 (there's one direction that remains unchanged under rotation)\n\t\t\t\t\tdouble[][] ar = {{mT.m00,mT.m01,mT.m02},{mT.m10,mT.m11,mT.m12},{mT.m20,mT.m21,mT.m22}};\n\t\t\t\t\tMatrix mat = new Matrix(ar);\n\t\t\t\t\tdouble[] eigenv = mat.svd().getSingularValues();\n\t\t\t\t\tAssert.assertTrue(eq(eigenv[0],1.0) || eq(eigenv[1],1.0) || eq(eigenv[2],1.0));\n\n\t\t\t\t\t// transpose must be equals to inverse\n\t\t\t\t\tMatrix3d rotTransp = new Matrix3d();\n\t\t\t\t\tMatrix3d rotInv = new Matrix3d();\n\t\t\t\t\trotTransp.transpose(rot);\n\t\t\t\t\trotInv.invert(rot);\n\n\t\t\t\t\tassertMatrixEquals(rotTransp,rotInv);\n\n\t\t\t\t\tint foldType = spaceGroup.getAxisFoldType(i);\n\n\t\t\t\t\tAssert.assertTrue(foldType==1 || foldType==2 || foldType==3 || foldType==4 || foldType==6);\n\n\t\t\t\t\tif (!ct.isPureTranslation()) {\n\t\t\t\t\t\tAssert.assertTrue(ct.isIdentity() || ct.isRotation());\n\t\t\t\t\t}\n\t\t\t\t\tif (!ct.isRotation()) {\n\t\t\t\t\t\tAssert.assertTrue(ct.isIdentity() || ct.isPureTranslation());\n\t\t\t\t\t}\n\t\t\t\t\tif (!ct.isPureTranslation() && ct.isFractionalTranslation()) {\n\t\t\t\t\t\tAssert.assertTrue(foldType!=1);\n\t\t\t\t\t\tAssert.assertTrue(ct.isRotation());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// i=0 is identity\n\t\t\t\tif (i==0) {\n\t\t\t\t\tAssert.assertTrue(ct.isIdentity());\n\t\t\t\t\tAssert.assertFalse(ct.isPureCrystalTranslation());\n\t\t\t\t\tAssert.assertTrue(ct.getTransformType()==TransformType.AU);\n\t\t\t\t}\n\n\t\t\t\tAssert.assertFalse(ct.isPureCrystalTranslation());\n\t\t\t\tAssert.assertFalse(ct.getTransformType()==TransformType.XTALTRANSL);\n\n\n\t\t\t\t// rotation axes and type\n\n\t\t\t\tint foldType = spaceGroup.getAxisFoldType(i);\n\t\t\t\tMatrix3d W = new Matrix3d(m.m00,m.m01,m.m02,m.m10,m.m11,m.m12,m.m20,m.m21,m.m22);\n\t\t\t\tAxisAngle4d axisAngle = spaceGroup.getRotAxisAngle(i);\n\t\t\t\tif (W.determinant()>0) { // i.e. 1\n\t\t\t\t\tswitch (foldType) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tAssert.assertEquals(0, axisAngle.angle, DELTA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tAssert.assertEquals(Math.PI, axisAngle.angle, DELTA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tAssert.assertEquals(2.0*Math.PI/3.0, axisAngle.angle, DELTA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tAssert.assertEquals(Math.PI/2.0, axisAngle.angle, DELTA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tAssert.assertEquals(Math.PI/3.0, axisAngle.angle, DELTA);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t} else { // i.e. determinant -1\n\t\t\t\t\tswitch (foldType) {\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tAssert.assertEquals(0,axisAngle.angle,DELTA);\n\t\t\t\t\t\t// no glide planes\n\t\t\t\t\t\tAssert.assertTrue(ct.getTranslScrewComponent().epsilonEquals(new Vector3d(0,0,0), DELTA));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -2:\n\t\t\t\t\t\tAssert.assertEquals(0,axisAngle.angle,DELTA);\n\t\t\t\t\t\t// glide planes can happen\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -3:\n\t\t\t\t\t\tAssert.assertEquals(0,axisAngle.angle,DELTA);\n\t\t\t\t\t\t// no glide planes\n\t\t\t\t\t\tAssert.assertTrue(ct.getTranslScrewComponent().epsilonEquals(new Vector3d(0,0,0), DELTA));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -4:\n\t\t\t\t\t\tAssert.assertEquals(0,axisAngle.angle,DELTA);\n\t\t\t\t\t\t// no glide planes\n\t\t\t\t\t\tAssert.assertTrue(ct.getTranslScrewComponent().epsilonEquals(new Vector3d(0,0,0), DELTA));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase -6:\n\t\t\t\t\t\tAssert.assertEquals(0,axisAngle.angle,DELTA);\n\t\t\t\t\t\t// no glide planes\n\t\t\t\t\t\tAssert.assertTrue(ct.getTranslScrewComponent().epsilonEquals(new Vector3d(0,0,0), DELTA));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tVector3d axis = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n\t\t\t\tVector3d translScrewComponent = ct.getTranslScrewComponent();\n\n\t\t\t\t// if both non-0, then both have to be on the same direction (with perhaps different sense)\n\t\t\t\tif (!axis.epsilonEquals(new Vector3d(0,0,0), DELTA) &&\n\t\t\t\t\t!translScrewComponent.epsilonEquals(new Vector3d(0,0,0), DELTA)) {\n\n\t\t\t\t\tAssert.assertTrue ((eq(axis.angle(translScrewComponent),0.0)) ||\n\t\t\t\t\t\t\t\t\t\teq(axis.angle(translScrewComponent),Math.PI) );\n\t\t\t\t}\n\n\t\t\t\t// we only print the enantiomorphic ones, otherwise there's too much output\n\n\t\t\t\tif (spaceGroup.isEnantiomorphic() || PRINT_OPERATORS_FROM_ALL_SGS)\n\t\t\t\t\tif (VERBOSE)\n\t\t\t\t\t\tSystem.out.print(\n\t\t\t\t\t\t\tString.format(\"%2d %2d\",i,1+i-spaceGroup.getPrimitiveMultiplicity()*(i/spaceGroup.getPrimitiveMultiplicity()))+\" \"+\n\t\t\t\t\t\t\tString.format(\"%20s\",spaceGroup.getTransfAlgebraic(i))+\" \"+\n\t\t\t\t\t\t\tString.format(\"(%5.2f,%5.2f,%5.2f)\",axis.x,axis.y,axis.z)+\" \"+\n\t\t\t\t\t\t\tString.format(\"%2d\",foldType)+\" \" +\n\t\t\t\t\t\t\tString.format(\"(%5.2f,%5.2f,%5.2f)\",translScrewComponent.x,translScrewComponent.y,translScrewComponent.z));\n\n\n\t\t\t\tif (ct.getTransformType().isScrew()) { // tests for both screw or glide planes (i.e. a non-zero scre transl component)\n\n\t\t\t\t\tif (spaceGroup.isEnantiomorphic()  || PRINT_OPERATORS_FROM_ALL_SGS) {\n\t\t\t\t\t\tif (VERBOSE)\n\t\t\t\t\t\t\tSystem.out.print(\" -- SCREW AXIS\");\n\t\t\t\t\t\tif (foldType==-2) {\n\t\t\t\t\t\t\tif (VERBOSE)\n\t\t\t\t\t\t\t\tSystem.out.print(\" (GLIDE)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tAssert.assertTrue(\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.GLIDE ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.TWOFOLDSCREW ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.THREEFOLDSCREW ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.FOURFOLDSCREW ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.SIXFOLDSCREW);\n\n\t\t\t\t\tAssert.assertFalse(ct.isPureTranslation());\n\t\t\t\t}\n\n\t\t\t\tif (ct.isPureTranslation()) {\n\t\t\t\t\tAssert.assertEquals(1,foldType);\n\n\t\t\t\t\tif (spaceGroup.isEnantiomorphic()  || PRINT_OPERATORS_FROM_ALL_SGS) {\n\t\t\t\t\t\tif (VERBOSE)\n\t\t\t\t\t\t\tSystem.out.print(\" -- FRACTIONAL TRANSLATION\");\n\t\t\t\t\t}\n\n\t\t\t\t\tAssert.assertTrue(ct.isFractionalTranslation());\n\t\t\t\t\tAssert.assertTrue(ct.getTransformType()==TransformType.CELLTRANSL);\n\t\t\t\t}\n\t\t\t\tif (ct.isRotation() && !ct.isFractionalTranslation()) {\n\t\t\t\t\tAssert.assertTrue(ct.getTransformType()==TransformType.TWOFOLD ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.THREEFOLD ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.FOURFOLD ||\n\t\t\t\t\t\t\tct.getTransformType()==TransformType.SIXFOLD);\n\t\t\t\t\tAssert.assertTrue(!ct.getTransformType().isScrew());\n\t\t\t\t}\n\n\t\t\t\tif (spaceGroup.isEnantiomorphic() || PRINT_OPERATORS_FROM_ALL_SGS) {\n\t\t\t\t\tif (VERBOSE) {\n\t\t\t\t\t\tSystem.out.print(\" -- \"+ct.getTransformType().getShortName());\n\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\n\t\tAssert.assertEquals(266, allSGs.size()); // the total count must be 266\n\t\tAssert.assertEquals(65, countEn);        // enantiomorphic groups (protein crystallography groups)\n\t\tAssert.assertEquals(165, countNonEn);    // i.e. 266-65-36\n\t\tAssert.assertEquals(36, countSpecial);   // the rest of the groups present un symop.lib (sometimes used in PDB)\n\t}\n\n\tprivate static void assertMatrixEquals(Matrix3d m1, Matrix3d m2) {\n\t\tfor (int i=0;i<3;i++) {\n\t\t\tfor (int j=0;j<3;j++) {\n\t\t\t\t Assert.assertEquals(m1.getElement(i, j),m2.getElement(i, j),DELTA);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean eq(double d1, double d2) {\n\t\treturn (Math.abs(d1-d2)<DELTA);\n\t}\n\n\t// to debug the testing code (run as java program so that we can use normal debugger)\n\tpublic static void main(String[] args) throws Exception {\n\t\tTestSpaceGroup test = new TestSpaceGroup();\n\t\ttest.testTransfConversion();\n\t}\n\n}\n","changedTest":"","commitMessage":"fix: issue #1081 Sonar S1132 Strings literals should be placed on the left side when checking for equality\n","test_commitMessage":"","allZero":false}