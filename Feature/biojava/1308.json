{"repository":"biojava","prod_path":"biojava3-core/src/main/java/org/biojava3/core/sequence/MultipleSequenceAlignment.java","test_path":"biojava3-core/src/test/java/org/biojava3/core/sequence/MultipleSequenceAlignmentTest.java","prod_time":"2010-12-17 20:44:49","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":1,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":1,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b69ff5dd0d457bab43b54e359f11dbc08fc34de0","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\n\npackage org.biojava3.core.sequence;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.biojava3.core.sequence.io.util.IOUtils;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.LightweightProfile;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a minimal data structure for reading and writing a sequence alignment.  The full {@code Profile} data\n * structure in the alignment module provides additional functionality.\n *\n * @author Scooter Willis\n * @author Mark Chapman\n */\npublic class MultipleSequenceAlignment<S extends Sequence<C>, C extends Compound> implements LightweightProfile<S, C> {\n\n    private List<S> sequences = new ArrayList<S>();\n    private int length = -1;\n\n    public void addAlignedSequence(S sequence){\n        if(length == -1){\n            length = sequence.getLength();\n        }\n        if(sequence.getLength() != length){\n            throw new IllegalArgumentException(sequence.getAccession() + \" length = \" + sequence.getLength() +\n                    \" not equal to MSA length = \" + length);\n        }\n        sequences.add(sequence);\n    }\n\n    public boolean removeAlignedSequence(S sequence){\n        return sequences.remove(sequence);\n    }\n\n    // methods for LightweightProfile\n\n    @Override\n    public S getAlignedSequence(int listIndex) {\n        return sequences.get(listIndex - 1);\n    }\n\n    @Override\n    public List<S> getAlignedSequences() {\n        return Collections.unmodifiableList(sequences);\n    }\n\n    @Override\n    public List<C> getCompoundsAt(int alignmentIndex) {\n        List<C> column = new ArrayList<C>();\n        for (S s : sequences) {\n            column.add(s.getCompoundAt(alignmentIndex));\n        }\n        return Collections.unmodifiableList(column);\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return sequences.get(0).getCompoundSet();\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public int getSize() {\n        return sequences.size();\n    }\n\n    @Override\n    public String toString(int width) {\n        return toString(width, null, IOUtils.getIDFormat(sequences), true, true, true, false);\n    }\n\n    @Override\n    public String toString(StringFormat format) {\n        switch (format) {\n        case ALN:\n        case CLUSTALW:\n        default:\n            return toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(sequences) +\n                    \"   \", true, false, true, false);\n        case FASTA:\n            return toString(60, null, \">%s%n\", false, false, false, false);\n        case GCG:\n        case MSF:\n            return toString(50, IOUtils.getGCGHeader(sequences), IOUtils.getIDFormat(sequences), true, false, false,\n                    false);\n        case PDBWEB:\n            return toString(60, null, \"%s\", true, false, true, true);\n        }\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return toString(getLength(), null, null, false, false, false, false);\n    }\n\n    // helper methods\n\n    // creates formatted String\n    private String toString(int width, String header, String idFormat, boolean interlaced, boolean aligIndices,\n            boolean aligConservation, boolean webDisplay) {\n\n        // TODO handle circular alignments\n        StringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n        if (webDisplay && sequences.size() == 2) {\n            s.append(\"<div><pre>\");\n        }\n\n        width = Math.max(1, width);\n        if (interlaced) {\n            String aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n                    \"d%n\";\n            for (int i = 0; i < getLength(); i += width) {\n                int start = i + 1, end = Math.min(getLength(), i + width);\n                if (i > 0) {\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligIndices) {\n                    if (end < i + width) {\n                        int line = end - start + 1;\n                        aligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n                                \"d%n\";\n                    }\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, \"\"));\n                    }\n                    s.append(String.format(aligIndFormat, start, end));\n                }\n                int counter = 0;\n                for (S as : sequences) {\n                    counter++;\n                    if (webDisplay && sequences.size() == 2) {\n                        printSequenceAlignmentWeb(s, counter, idFormat, start, end);\n                    } else {\n                        if (idFormat != null) {\n                            s.append(String.format(idFormat, as.getAccession()));\n                        }\n                        s.append(as.getSubSequence(start, end).getSequenceAsString());\n                        s.append(String.format(\"%n\"));\n                    }\n                    if (aligConservation && sequences.size() == 2 && counter == 1) {\n                        printConservation(s, idFormat, start, end, webDisplay);\n                    }\n                }\n            }\n        } else {\n            for (S as : sequences) {\n                if (idFormat != null) {\n                    s.append(String.format(idFormat, as.getAccession()));\n                }\n                for (int i = 0; i < getLength(); i += width) {\n                    int start = i + 1, end = Math.min(getLength(), i + width);\n                    s.append(as.getSubSequence(start, end).getSequenceAsString());\n                    s.append(String.format(\"%n\"));\n                }\n            }\n        }\n\n        if (webDisplay && aligConservation && sequences.size() == 2) {\n            s.append(IOUtils.getPDBLegend());\n        }\n        return s.toString();\n    }\n\n    private void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, int start, int end) {\n        S as = sequences.get(counter - 1), seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n        if (idFormat != null) {\n            s.append(String.format(idFormat, as.getAccession()));\n        }\n\n        String mySeq = as.getSubSequence(start, end).getSequenceAsString();\n        String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n        CompoundSet<C> cs = getCompoundSet();\n\n        for (int i = 0; i < s1.length(); i++) {\n            if (i >= s2.length() || i >= mySeq.length())\n                break;\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            char c = mySeq.charAt(i);\n            s.append(IOUtils.getPDBCharacter(true, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n                    seq2.getCompoundAt(i)), c));\n        }\n\n        s.append(String.format(\"%n\"));\n    }\n\n    private void printConservation(StringBuilder s, String idFormat, int start, int end, boolean webDisplay) {\n        S seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n        if (idFormat != null) {\n            AccessionID ac1 = sequences.get(0).getAccession();\n            String id1 = (ac1 == null) ? \"null\" : ac1.getID();\n            id1 = id1.replaceAll(\".\", \" \");\n            s.append(String.format(idFormat, id1));\n        }\n\n        String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n        CompoundSet<C> cs = getCompoundSet();\n\n        for (int i = 0; i < s1.length(); i++) {\n            if (i >= s2.length())\n                break;\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            s.append(IOUtils.getPDBConservation(webDisplay, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n                    seq2.getCompoundAt(i))));\n        }\n\n        s.append(String.format(\"%n\"));\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\n\npackage org.biojava3.core.sequence;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.biojava3.core.sequence.io.util.IOUtils;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.LightweightProfile;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a minimal data structure for reading and writing a sequence alignment.  The full {@code Profile} data\n * structure in the alignment module provides additional functionality.\n *\n * @author Scooter Willis\n * @author Mark Chapman\n */\npublic class MultipleSequenceAlignment<S extends Sequence<C>, C extends Compound> implements LightweightProfile<S, C> {\n\n    private List<S> sequences = new ArrayList<S>();\n    private Integer length = null;\n\n    /**\n     * A sequence that has been aligned to other sequences will have inserts. \n     * @param sequence\n     */\n    public void addAlignedSequence(S sequence){\n        if(length == null){\n            length = sequence.getLength();\n        }\n        if(sequence.getLength() != length){\n            throw new IllegalArgumentException(sequence.getAccession() + \" length = \" + sequence.getLength() +\n                    \" not equal to MSA length = \" + length);\n        }\n        sequences.add(sequence);\n    }\n\n    /**\n     * Remove a sequence\n     * @param sequence\n     * @return\n     */\n    public boolean removeAlignedSequence(S sequence){\n        return sequences.remove(sequence);\n    }\n//methods for LightweightProfile\n\n    /**\n     * Uses bioIndex starting at 1 instead of 0\n     * @param listIndex\n     * @return\n     */\n     \n\n    @Override\n    public S getAlignedSequence(int listIndex) {\n        return sequences.get(listIndex - 1);\n    }\n\n    /**\n     * Get the list of sequences\n     * @return\n     */\n    @Override\n    public List<S> getAlignedSequences() {\n        return Collections.unmodifiableList(sequences);\n    }\n\n    /**\n     * Get a list of compounds at a sequence position\n     * @param alignmentIndex\n     * @return\n     */\n    @Override\n    public List<C> getCompoundsAt(int alignmentIndex) {\n        List<C> column = new ArrayList<C>();\n        for (S s : sequences) {\n            column.add(s.getCompoundAt(alignmentIndex));\n        }\n        return Collections.unmodifiableList(column);\n    }\n\n    /**\n     * Get the Compounds defined in the first sequence\n     * @return\n     */\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return sequences.get(0).getCompoundSet();\n    }\n\n    /**\n     * Get the length of the MSA where it is assumed that\n     * all sequence position\n     * @return\n     */\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    /**\n     * Get the number of sequences in the MSA\n     * @return\n     */\n    @Override\n    public int getSize() {\n        return sequences.size();\n    }\n\n    /**\n     * Get a string representation of the MSA with a fixed width\n     * @param width\n     * @return\n     */\n    @Override\n    public String toString(int width) {\n        return toString(width, null, IOUtils.getIDFormat(sequences), true, true, true, false);\n    }\n\n    /**\n     * Support for different MSA formats\n     * @param format\n     * @return\n     */\n    @Override\n    public String toString(StringFormat format) {\n        switch (format) {\n        case ALN:\n        case CLUSTALW:\n        default:\n            return toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(sequences) +\n                    \"   \", true, false, true, false);\n        case FASTA:\n            return toString(60, null, \">%s%n\", false, false, false, false);\n        case GCG:\n        case MSF:\n            return toString(50, IOUtils.getGCGHeader(sequences), IOUtils.getIDFormat(sequences), true, false, false,\n                    false);\n        case PDBWEB:\n            return toString(60, null, \"%s\", true, false, true, true);\n        }\n    }\n\n    /**\n     * String representation of the MSA\n     * @return\n     */\n\n    @Override\n    public String toString() {\n        return toString(getLength(), null, null, false, false, false, false);\n    }\n\n    // helper methods\n\n    /**\n     * Helper method that does all the formating work\n     * @param width\n     * @param header\n     * @param idFormat\n     * @param interlaced\n     * @param aligIndices\n     * @param aligConservation\n     * @param webDisplay\n     * @return\n     */\n    // creates formatted String\n    private String toString(int width, String header, String idFormat, boolean interlaced, boolean aligIndices,\n            boolean aligConservation, boolean webDisplay) {\n\n        // TODO handle circular alignments\n        StringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n        if (webDisplay && sequences.size() == 2) {\n            s.append(\"<div><pre>\");\n        }\n\n        width = Math.max(1, width);\n        if (interlaced) {\n            String aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n                    \"d%n\";\n            for (int i = 0; i < getLength(); i += width) {\n                int start = i + 1, end = Math.min(getLength(), i + width);\n                if (i > 0) {\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligIndices) {\n                    if (end < i + width) {\n                        int line = end - start + 1;\n                        aligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n                                \"d%n\";\n                    }\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, \"\"));\n                    }\n                    s.append(String.format(aligIndFormat, start, end));\n                }\n                int counter = 0;\n                for (S as : sequences) {\n                    counter++;\n                    if (webDisplay && sequences.size() == 2) {\n                        printSequenceAlignmentWeb(s, counter, idFormat, start, end);\n                    } else {\n                        if (idFormat != null) {\n                            s.append(String.format(idFormat, as.getAccession()));\n                        }\n                        s.append(as.getSubSequence(start, end).getSequenceAsString());\n                        s.append(String.format(\"%n\"));\n                    }\n                    if (aligConservation && sequences.size() == 2 && counter == 1) {\n                        printConservation(s, idFormat, start, end, webDisplay);\n                    }\n                }\n            }\n        } else {\n            for (S as : sequences) {\n                if (idFormat != null) {\n                    s.append(String.format(idFormat, as.getAccession()));\n                }\n                for (int i = 0; i < getLength(); i += width) {\n                    int start = i + 1, end = Math.min(getLength(), i + width);\n                    s.append(as.getSubSequence(start, end).getSequenceAsString());\n                    s.append(String.format(\"%n\"));\n                }\n            }\n        }\n\n        if (webDisplay && aligConservation && sequences.size() == 2) {\n            s.append(IOUtils.getPDBLegend());\n        }\n        return s.toString();\n    }\n\n    /**\n     *\n     * @param s\n     * @param counter\n     * @param idFormat\n     * @param start\n     * @param end\n     */\n    private void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, int start, int end) {\n        S as = sequences.get(counter - 1), seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n        if (idFormat != null) {\n            s.append(String.format(idFormat, as.getAccession()));\n        }\n\n        String mySeq = as.getSubSequence(start, end).getSequenceAsString();\n        String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n        CompoundSet<C> cs = getCompoundSet();\n\n        for (int i = 0; i < s1.length(); i++) {\n            if (i >= s2.length() || i >= mySeq.length())\n                break;\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            char c = mySeq.charAt(i);\n            s.append(IOUtils.getPDBCharacter(true, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n                    seq2.getCompoundAt(i)), c));\n        }\n\n        s.append(String.format(\"%n\"));\n    }\n\n    /**\n     *\n     * @param s\n     * @param idFormat\n     * @param start\n     * @param end\n     * @param webDisplay\n     */\n    private void printConservation(StringBuilder s, String idFormat, int start, int end, boolean webDisplay) {\n        S seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n        if (idFormat != null) {\n            AccessionID ac1 = sequences.get(0).getAccession();\n            String id1 = (ac1 == null) ? \"null\" : ac1.getID();\n            id1 = id1.replaceAll(\".\", \" \");\n            s.append(String.format(idFormat, id1));\n        }\n\n        String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n        CompoundSet<C> cs = getCompoundSet();\n\n        for (int i = 0; i < s1.length(); i++) {\n            if (i >= s2.length())\n                break;\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            s.append(IOUtils.getPDBConservation(webDisplay, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n                    seq2.getCompoundAt(i))));\n        }\n\n        s.append(String.format(\"%n\"));\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on November 21, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.core.sequence;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class MultipleSequenceAlignmentTest {\n\n    private MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msaProteins;\n    private MultipleSequenceAlignment<DNASequence,NucleotideCompound> msaDNA;\n\n    @Before\n    public void setup() {\n        msaProteins = new MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound>();\n        for (int i = 0; i < 8; i++) {\n            msaProteins.addAlignedSequence(new ProteinSequence(\"ARNDCEQGHILKMFPSTWYVBZJX\"));\n        }\n        msaDNA = new MultipleSequenceAlignment<DNASequence, NucleotideCompound>();\n        for (int i = 0; i < 7; i++) {\n            msaDNA.addAlignedSequence(new DNASequence(\"ATCGATCGATCGATCG\"));\n        }\n    }\n\n    @Test\n    public void testGetCompoundsAt() {\n        AminoAcidCompound aminoAcid = AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(\"N\");\n        List<AminoAcidCompound> colProteins = new ArrayList<AminoAcidCompound>();\n        for (int i = 0; i < 8; i++) {\n            colProteins.add(aminoAcid);\n        }\n        assertEquals(msaProteins.getCompoundsAt(3), colProteins);\n        NucleotideCompound nucleotide = DNACompoundSet.getDNACompoundSet().getCompoundForString(\"C\");\n        List<NucleotideCompound> colDNA = new ArrayList<NucleotideCompound>();\n        for (int i = 0; i < 7; i++) {\n            colDNA.add(nucleotide);\n        }\n        assertEquals(msaDNA.getCompoundsAt(3), colDNA);\n    }\n\n}\n","changedTest":"","commitMessage":"JavaDoc changes\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8590 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}