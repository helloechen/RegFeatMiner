{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/alignment/SimpleProfile.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/alignment/SimpleProfileTest.java","prod_time":"2016-01-29 13:28:22","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":1,"add_condition_line":0,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":1,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e06a702d1be803d21f1efaa46c6d4d02a3cc275d","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfileView;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.util.*;\n\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Profile<S, C> {\n\n\tprivate List<AlignedSequence<S, C>> list;\n\tprivate List<S> originals;\n\tprivate int length;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tprotected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tif (query.getLength() != target.getLength()) {\n\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(query);\n\t\tlist.add(target);\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add((S) query.getOriginalSequence());\n\t\toriginals.add((S) target.getOriginalSequence());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = query.getLength();\n\t}\n\n\t/**\n\t * Creates a profile from a single sequence.\n\t *\n\t * @param sequence sequence to seed profile\n\t */\n\tpublic SimpleProfile(S sequence) {\n\t\tList<Step> s = new ArrayList<Step>();\n\t\tfor (int i = 0; i < sequence.getLength(); i++) {\n\t\t\ts.add(Step.COMPOUND);\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(sequence, s));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(sequence);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sequence.getLength();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tprotected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n\t\tlist.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query);\n\t\toriginals.add(target);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given profiles.\n\t *\n\t * @param query the first profile of the pair\n\t * @param target the second profile of the pair\n\t * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n\t */\n\tprotected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (AlignedSequence<S, C> s : query) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sx));\n\t\t}\n\t\tfor (AlignedSequence<S, C> s : target) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sy));\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.addAll(query.getOriginalSequences());\n\t\toriginals.addAll(target.getOriginalSequences());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t /**\n     * Creates a profile for the already aligned sequences.\n     * @param alignedSequences the already aligned sequences\n     * @throws IllegalArgument if aligned sequences differ in length or\n     * collection is empty.\n     */\n    public SimpleProfile(Collection<AlignedSequence<S,C>> alignedSequences) {\n        list = new ArrayList<AlignedSequence<S,C>>();\n        originals = new ArrayList<S>();\n        \n        Iterator<AlignedSequence<S,C>> itr = alignedSequences.iterator();\n        if(!itr.hasNext()) {\n            throw new IllegalArgumentException(\"alignedSequences must not be empty\");\n        }\n        \n        AlignedSequence<S, C> curAlignedSeq = itr.next();\n        length = curAlignedSeq.getLength();\n        list.add(curAlignedSeq);\n        originals.add((S) curAlignedSeq.getOriginalSequence());\n        \n        while (itr.hasNext()) {\n            curAlignedSeq = itr.next();\n            if (curAlignedSeq.getLength() != length) {\n                throw new IllegalArgumentException(\"Aligned sequences differ in size\");\n            }\n            list.add(curAlignedSeq);\n            originals.add((S) curAlignedSeq.getOriginalSequence());\n        }\n        list = Collections.unmodifiableList(list);\n        originals = Collections.unmodifiableList(originals);\n    }\n\t\n\t\n\t// methods for Profile\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n\t\treturn list.get(listIndex - 1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(S sequence) {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences() {\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (int i : listIndices) {\n\t\t\ttempList.add(getAlignedSequence(i));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (S s : sequences) {\n\t\t\ttempList.add(getAlignedSequence(s));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int listIndex, int alignmentIndex) {\n\t\treturn getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(S sequence, int alignmentIndex) {\n\t\tAlignedSequence<S, C> s = getAlignedSequence(sequence);\n\t\treturn (s == null) ? null : s.getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex) {\n\t\treturn getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n\t\tint[] counts = new int[compounds.size()];\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tint igap = compounds.indexOf(gap);\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tint i = compounds.indexOf(compound);\n\t\t\tif (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\tcounts[i]++;\n\t\t\t}\n\t\t}\n\t\treturn counts;\n\t}\n\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\t// TODO handle circular alignments\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn list.get(0).getCompoundSet();\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex) {\n\t\treturn getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n\t\tfloat[] weights = new float[compounds.size()];\n\t\tint[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n\t\tfloat total = 0.0f;\n\t\tfor (int i : counts) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total > 0.0f) {\n\t\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = counts[i]/total;\n\t\t\t}\n\t\t}\n\t\treturn weights;\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int[] getIndicesAt(int alignmentIndex) {\n\t\tint[] indices = new int[list.size()];\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tindices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n\t\t}\n\t\treturn indices;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic List<S> getOriginalSequences() {\n\t\treturn originals;\n\t}\n\n\t@Override\n\tpublic int getSize() {\n\t\tint size = 0;\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tsize += s.getOverlapCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic ProfileView<S, C> getSubProfile(Location location) {\n\t\t// TODO ProfileView<S, C> getSubProfile(Location)\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasGap(int alignmentIndex) {\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tif (getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.isCircular()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(list), true, true, true, true, true, false);\n\t}\n\n\t@Override\n\tpublic String toString(StringFormat format) {\n        switch (format) {\n        case ALN:\n        case CLUSTALW:\n        default:\n            return toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(list) + \"   \",\n                    false, true, true, false, true, false);\n        case FASTA:\n            return toString(60, null, \">%s%n\", false, false, false, false, false, false);\n        case GCG:\n        case MSF:\n            return toString(50, IOUtils.getGCGHeader(list), IOUtils.getIDFormat(list), false, false, true, false,\n                    false, false);\n        case PDBWEB:\n            return toString(60, null, \"%10s\", true, true, true, false, true, true);\n        }\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false, false, false);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<AlignedSequence<S, C>> iterator() {\n\t\treturn list.iterator();\n\t}\n\n\t// helper methods\n\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n\t\t\tboolean interlaced, boolean aligIndices, boolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\t\t\n\t\tif ( webDisplay && list.size() == 2){\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tint seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n\t\tString seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\t\tcounter++;\n\n\t\t\t\t\tif ( webDisplay && list.size() == 2){\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, seqIndexPre, seqIndexFormatPre, seqIndexPost,\n\t\t\t\t\t\t        seqIndexFormatPost, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\n\t\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aligConservation && list.size() == 2 && counter == 1) {\n\t\t\t\t\t    printConservation(s, idFormat, seqIndexPad, seqIndexPre, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && list.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, boolean seqIndexPre,\n\t        String seqIndexFormatPre, boolean seqIndexPost, String seqIndexFormatPost, int start, int end) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1), as = list.get(counter - 1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t}\n\n        String mySeq = as.getSubSequence(start, end).getSequenceAsString();\n        String s1 = as1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, isSimilar(c1, c2), c));\n\t\t}\n\n\t\tif (seqIndexPost) {\n\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t}\n\t\ts.append(String.format(\"%n\"));\n\n\t}\n\n\tprivate void printConservation(StringBuilder s, String idFormat, int seqIndexPad, boolean seqIndexPre, int start,\n\t        int end, boolean webDisplay) {\n\t    AlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1);\n\n\t    if (idFormat != null) {\n\t        AccessionID ac1 = as1.getAccession();\n\t        String id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t        id1 = id1.replaceAll(\".\", \" \");\n\t        s.append(String.format(idFormat, id1));\n\t    }\n\n\t    if (seqIndexPre) {\n\t        s.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t    }\n\n\t    String subseq1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t    String subseq2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t    for ( int ii =0 ; ii < subseq1.length() ; ii++){\n\t        if ( ii >= subseq2.length())\n\t            break;\n\t        char c1 = subseq1.charAt(ii);\n\t        char c2 = subseq2.charAt(ii);\n\t        s.append(IOUtils.getPDBConservation(webDisplay, c1, c2, isSimilar(c1, c2)));\n\t    }\n\n\t    s.append(String.format(\"%n\"));\n\t}\n\n\tprotected static final SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n\n\tprivate boolean isSimilar(char c1, char c2) {\n\t\tAminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\n\t\tAminoAcidCompound aa1 = set.getCompoundForString(\"\"+c1);\n\t\tAminoAcidCompound aa2 = set.getCompoundForString(\"\"+c2);\n\n\t\tshort val = matrix.getValue(aa1,aa2);\n\t\treturn val > 0;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfileView;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.io.Serializable;\nimport java.util.*;\n\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Serializable, Profile<S, C> {\n\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate List<AlignedSequence<S, C>> list;\n\tprivate List<S> originals;\n\tprivate int length;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tprotected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tif (query.getLength() != target.getLength()) {\n\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(query);\n\t\tlist.add(target);\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add((S) query.getOriginalSequence());\n\t\toriginals.add((S) target.getOriginalSequence());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = query.getLength();\n\t}\n\n\t/**\n\t * Creates a profile from a single sequence.\n\t *\n\t * @param sequence sequence to seed profile\n\t */\n\tpublic SimpleProfile(S sequence) {\n\t\tList<Step> s = new ArrayList<Step>();\n\t\tfor (int i = 0; i < sequence.getLength(); i++) {\n\t\t\ts.add(Step.COMPOUND);\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(sequence, s));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(sequence);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sequence.getLength();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tprotected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n\t\tlist.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query);\n\t\toriginals.add(target);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given profiles.\n\t *\n\t * @param query the first profile of the pair\n\t * @param target the second profile of the pair\n\t * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n\t */\n\tprotected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (AlignedSequence<S, C> s : query) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sx));\n\t\t}\n\t\tfor (AlignedSequence<S, C> s : target) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sy));\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.addAll(query.getOriginalSequences());\n\t\toriginals.addAll(target.getOriginalSequences());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t /**\n     * Creates a profile for the already aligned sequences.\n     * @param alignedSequences the already aligned sequences\n     * @throws IllegalArgument if aligned sequences differ in length or\n     * collection is empty.\n     */\n    public SimpleProfile(Collection<AlignedSequence<S,C>> alignedSequences) {\n        list = new ArrayList<AlignedSequence<S,C>>();\n        originals = new ArrayList<S>();\n        \n        Iterator<AlignedSequence<S,C>> itr = alignedSequences.iterator();\n        if(!itr.hasNext()) {\n            throw new IllegalArgumentException(\"alignedSequences must not be empty\");\n        }\n        \n        AlignedSequence<S, C> curAlignedSeq = itr.next();\n        length = curAlignedSeq.getLength();\n        list.add(curAlignedSeq);\n        originals.add((S) curAlignedSeq.getOriginalSequence());\n        \n        while (itr.hasNext()) {\n            curAlignedSeq = itr.next();\n            if (curAlignedSeq.getLength() != length) {\n                throw new IllegalArgumentException(\"Aligned sequences differ in size\");\n            }\n            list.add(curAlignedSeq);\n            originals.add((S) curAlignedSeq.getOriginalSequence());\n        }\n        list = Collections.unmodifiableList(list);\n        originals = Collections.unmodifiableList(originals);\n    }\n\t\n\t\n\t// methods for Profile\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n\t\treturn list.get(listIndex - 1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(S sequence) {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences() {\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (int i : listIndices) {\n\t\t\ttempList.add(getAlignedSequence(i));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (S s : sequences) {\n\t\t\ttempList.add(getAlignedSequence(s));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int listIndex, int alignmentIndex) {\n\t\treturn getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(S sequence, int alignmentIndex) {\n\t\tAlignedSequence<S, C> s = getAlignedSequence(sequence);\n\t\treturn (s == null) ? null : s.getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex) {\n\t\treturn getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n\t\tint[] counts = new int[compounds.size()];\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tint igap = compounds.indexOf(gap);\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tint i = compounds.indexOf(compound);\n\t\t\tif (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\tcounts[i]++;\n\t\t\t}\n\t\t}\n\t\treturn counts;\n\t}\n\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\t// TODO handle circular alignments\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn list.get(0).getCompoundSet();\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex) {\n\t\treturn getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n\t\tfloat[] weights = new float[compounds.size()];\n\t\tint[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n\t\tfloat total = 0.0f;\n\t\tfor (int i : counts) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total > 0.0f) {\n\t\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = counts[i]/total;\n\t\t\t}\n\t\t}\n\t\treturn weights;\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int[] getIndicesAt(int alignmentIndex) {\n\t\tint[] indices = new int[list.size()];\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tindices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n\t\t}\n\t\treturn indices;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic List<S> getOriginalSequences() {\n\t\treturn originals;\n\t}\n\n\t@Override\n\tpublic int getSize() {\n\t\tint size = 0;\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tsize += s.getOverlapCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic ProfileView<S, C> getSubProfile(Location location) {\n\t\t// TODO ProfileView<S, C> getSubProfile(Location)\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasGap(int alignmentIndex) {\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tif (getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.isCircular()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(list), true, true, true, true, true, false);\n\t}\n\n\t@Override\n\tpublic String toString(StringFormat format) {\n        switch (format) {\n        case ALN:\n        case CLUSTALW:\n        default:\n            return toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(list) + \"   \",\n                    false, true, true, false, true, false);\n        case FASTA:\n            return toString(60, null, \">%s%n\", false, false, false, false, false, false);\n        case GCG:\n        case MSF:\n            return toString(50, IOUtils.getGCGHeader(list), IOUtils.getIDFormat(list), false, false, true, false,\n                    false, false);\n        case PDBWEB:\n            return toString(60, null, \"%10s\", true, true, true, false, true, true);\n        }\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false, false, false);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<AlignedSequence<S, C>> iterator() {\n\t\treturn list.iterator();\n\t}\n\n\t// helper methods\n\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n\t\t\tboolean interlaced, boolean aligIndices, boolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\t\t\n\t\tif ( webDisplay && list.size() == 2){\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tint seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n\t\tString seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\t\tcounter++;\n\n\t\t\t\t\tif ( webDisplay && list.size() == 2){\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, seqIndexPre, seqIndexFormatPre, seqIndexPost,\n\t\t\t\t\t\t        seqIndexFormatPost, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\n\t\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aligConservation && list.size() == 2 && counter == 1) {\n\t\t\t\t\t    printConservation(s, idFormat, seqIndexPad, seqIndexPre, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && list.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, boolean seqIndexPre,\n\t        String seqIndexFormatPre, boolean seqIndexPost, String seqIndexFormatPost, int start, int end) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1), as = list.get(counter - 1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t}\n\n        String mySeq = as.getSubSequence(start, end).getSequenceAsString();\n        String s1 = as1.getSubSequence(start, end).getSequenceAsString();\n        String s2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, isSimilar(c1, c2), c));\n\t\t}\n\n\t\tif (seqIndexPost) {\n\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t}\n\t\ts.append(String.format(\"%n\"));\n\n\t}\n\n\tprivate void printConservation(StringBuilder s, String idFormat, int seqIndexPad, boolean seqIndexPre, int start,\n\t        int end, boolean webDisplay) {\n\t    AlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1);\n\n\t    if (idFormat != null) {\n\t        AccessionID ac1 = as1.getAccession();\n\t        String id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t        id1 = id1.replaceAll(\".\", \" \");\n\t        s.append(String.format(idFormat, id1));\n\t    }\n\n\t    if (seqIndexPre) {\n\t        s.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t    }\n\n\t    String subseq1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t    String subseq2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t    for ( int ii =0 ; ii < subseq1.length() ; ii++){\n\t        if ( ii >= subseq2.length())\n\t            break;\n\t        char c1 = subseq1.charAt(ii);\n\t        char c2 = subseq2.charAt(ii);\n\t        s.append(IOUtils.getPDBConservation(webDisplay, c1, c2, isSimilar(c1, c2)));\n\t    }\n\n\t    s.append(String.format(\"%n\"));\n\t}\n\n\tprotected static final SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n\n\tprivate boolean isSimilar(char c1, char c2) {\n\t\tAminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\n\t\tAminoAcidCompound aa1 = set.getCompoundForString(\"\"+c1);\n\t\tAminoAcidCompound aa2 = set.getCompoundForString(\"\"+c2);\n\n\t\tshort val = matrix.getValue(aa1,aa2);\n\t\treturn val > 0;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.Profile.StringFormat;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class SimpleProfileTest {\n\n    private ProteinSequence query, target;\n    private Profile<ProteinSequence, AminoAcidCompound> global, local, single;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        query.setAccession(new AccessionID(\"Query\"));\n        target.setAccession(new AccessionID(\"Target\"));\n        global = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n                new Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}), 0, 0);\n        local = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n                Step.GAP, Step.COMPOUND}), 0, 1);\n        single = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query);\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleProfile() {\n        new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n                new Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND}), 0, 0);\n    }\n\n    @Test\n    public void testGetAlignedSequenceInt() {\n        assertEquals(global.getAlignedSequence(1).toString(), \"ARND-\");\n        assertEquals(global.getAlignedSequence(2).toString(), \"-R-DG\");\n        assertEquals(local.getAlignedSequence(1).toString(), \"RND\");\n        assertEquals(local.getAlignedSequence(2).toString(), \"R-D\");\n        assertEquals(single.getAlignedSequence(1).toString(), \"ARND\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds() {\n        global.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds2() {\n        global.getAlignedSequence(3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds3() {\n        local.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds4() {\n        local.getAlignedSequence(3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds5() {\n        single.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds6() {\n        single.getAlignedSequence(2);\n    }\n\n    @Test\n    public void testGetAlignedSequenceS() throws CompoundNotFoundException { \n        assertEquals(global.getAlignedSequence(query).toString(), \"ARND-\");\n        assertEquals(global.getAlignedSequence(target).toString(), \"-R-DG\");\n        assertNull(global.getAlignedSequence(new ProteinSequence(\"AR\")));\n        assertEquals(local.getAlignedSequence(query).toString(), \"RND\");\n        assertEquals(local.getAlignedSequence(target).toString(), \"R-D\");\n        assertNull(local.getAlignedSequence(new ProteinSequence(\"AR\")));\n        assertEquals(single.getAlignedSequence(query).toString(), \"ARND\");\n        assertNull(single.getAlignedSequence(target));\n    }\n\n    @Test\n    public void testGetAlignedSequences() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"-R-DG\");\n        list = local.getAlignedSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"RND\");\n        assertEquals(list.get(1).toString(), \"R-D\");\n        list = single.getAlignedSequences();\n        assertEquals(list.size(), 1);\n        assertEquals(list.get(0).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesIntArray() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(2, 1, 2);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"-R-DG\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n        list = local.getAlignedSequences(2, 2, 1);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"R-D\");\n        assertEquals(list.get(1).toString(), \"R-D\");\n        assertEquals(list.get(2).toString(), \"RND\");\n        list = single.getAlignedSequences(1, 1);\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND\");\n        assertEquals(list.get(1).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesSArray() {\n        List<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(query, query,\n                target);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n        list = local.getAlignedSequences(target, query, target);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"R-D\");\n        assertEquals(list.get(1).toString(), \"RND\");\n        assertEquals(list.get(2).toString(), \"R-D\");\n        list = single.getAlignedSequences(query, query);\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND\");\n        assertEquals(list.get(1).toString(), \"ARND\");\n    }\n\n    @Test\n    public void testGetCompoundAtIntInt() {\n        assertEquals(global.getCompoundAt(1, 4).getShortName(), \"D\");\n        assertEquals(global.getCompoundAt(2, 3).getShortName(), \"-\");\n        assertEquals(local.getCompoundAt(1, 1).getShortName(), \"R\");\n        assertEquals(local.getCompoundAt(2, 2).getShortName(), \"-\");\n        assertEquals(single.getCompoundAt(1, 3).getShortName(), \"N\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds() {\n        global.getCompoundAt(0, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds2() {\n        global.getCompoundAt(3, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds3() {\n        global.getCompoundAt(1, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds4() {\n        global.getCompoundAt(2, 6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds5() {\n        local.getCompoundAt(0, 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds6() {\n        local.getCompoundAt(3, 2);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds7() {\n        local.getCompoundAt(1, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds8() {\n        local.getCompoundAt(2, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds9() {\n        single.getCompoundAt(1, 0);\n    }\n\n    @Test\n    public void testGetCompoundAtSInt() throws CompoundNotFoundException { \n        assertEquals(global.getCompoundAt(query, 2).getShortName(), \"R\");\n        assertEquals(global.getCompoundAt(target, 5).getShortName(), \"G\");\n        assertNull(global.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n        assertEquals(local.getCompoundAt(query, 2).getShortName(), \"N\");\n        assertEquals(local.getCompoundAt(target, 3).getShortName(), \"D\");\n        assertNull(local.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n        assertEquals(single.getCompoundAt(query, 2).getShortName(), \"R\");\n        assertNull(single.getCompoundAt(target, 3));\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds() {\n        global.getCompoundAt(query, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds2() {\n        global.getCompoundAt(target, 6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds3() {\n        local.getCompoundAt(target, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds4() {\n        local.getCompoundAt(query, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds5() {\n        single.getCompoundAt(query, 0);\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(global.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(local.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(single.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n    }\n\n    @Test\n    public void testGetCompoundsAt() {\n        List<AminoAcidCompound> column = global.getCompoundsAt(5);\n        assertEquals(column.size(), 2);\n        assertEquals(column.get(0).getShortName(), \"-\");\n        assertEquals(column.get(1).getShortName(), \"G\");\n        column = local.getCompoundsAt(2);\n        assertEquals(column.size(), 2);\n        assertEquals(column.get(0).getShortName(), \"N\");\n        assertEquals(column.get(1).getShortName(), \"-\");\n        column = single.getCompoundsAt(2);\n        assertEquals(column.size(), 1);\n        assertEquals(column.get(0).getShortName(), \"R\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds() {\n        global.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds2() {\n        global.getCompoundsAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds3() {\n        local.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds4() {\n        local.getCompoundsAt(4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds5() {\n        single.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds6() {\n        single.getCompoundsAt(5);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"E\")), -1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"R\")), 1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 2);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"K\")), -1);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(single.getIndexOf(cs.getCompoundForString(\"G\")), -1);\n    }\n\n    @Test\n    public void testGetIndicesAt() {\n        assertArrayEquals(global.getIndicesAt(1), new int[] {1, 1});\n        assertArrayEquals(global.getIndicesAt(2), new int[] {2, 1});\n        assertArrayEquals(global.getIndicesAt(3), new int[] {3, 1});\n        assertArrayEquals(global.getIndicesAt(4), new int[] {4, 2});\n        assertArrayEquals(global.getIndicesAt(5), new int[] {4, 3});\n        assertArrayEquals(local.getIndicesAt(1), new int[] {2, 1});\n        assertArrayEquals(local.getIndicesAt(2), new int[] {3, 1});\n        assertArrayEquals(local.getIndicesAt(3), new int[] {4, 2});\n        assertArrayEquals(single.getIndicesAt(1), new int[] {1});\n        assertArrayEquals(single.getIndicesAt(2), new int[] {2});\n        assertArrayEquals(single.getIndicesAt(3), new int[] {3});\n        assertArrayEquals(single.getIndicesAt(4), new int[] {4});\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds() {\n        global.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds2() {\n        global.getIndicesAt(6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds3() {\n        local.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds4() {\n        local.getIndicesAt(4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds5() {\n        single.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds6() {\n        single.getIndicesAt(5);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 5);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"E\")), -1);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"R\")), 1);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 2);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"K\")), -1);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(single.getLastIndexOf(cs.getCompoundForString(\"G\")), -1);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(global.getLength(), 5);\n        assertEquals(local.getLength(), 3);\n        assertEquals(single.getLength(), 4);\n    }\n\n    @Test\n    public void testGetOriginalSequences() {\n        List<ProteinSequence> list = global.getOriginalSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0), query);\n        assertEquals(list.get(1), target);\n        list = local.getOriginalSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0), query);\n        assertEquals(list.get(1), target);\n        list = single.getOriginalSequences();\n        assertEquals(list.size(), 1);\n        assertEquals(list.get(0), query);\n    }\n\n    @Test\n    public void testGetSize() {\n        assertEquals(global.getSize(), 2);\n        assertEquals(local.getSize(), 2);\n        assertEquals(single.getSize(), 1);\n    }\n\n    @Ignore // TODO SimpleProfile.getSubProfile(Location)\n    @Test\n    public void testGetSubProfile() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(global.isCircular());\n        assertFalse(local.isCircular());\n        assertFalse(single.isCircular());\n    }\n\n    @Test\n    public void testToStringInt() {\n    \n    \t\n    \n    \t\n        assertEquals(global.toString(3), String.format(\n                \"          1 3%n\" +\n                \"Query   1 ARN 3%n\" +                \n                \"           | %n\"+\n                \"Target  1 -R- 1%n\" +\n                \"%n\" +\n                \"          4 5%n\" +\n                \"Query   4 D- 4%n\" +\n                \"          | %n\"+\n                \"Target  2 DG 3%n\"));\n        assertEquals(local.toString(4), String.format(\n                \"          1 3%n\" +\n                \"Query   2 RND 4%n\" +\n                \"          | |%n\"+\n                \"Target  1 R-D 2%n\"));\n        assertEquals(single.toString(4), String.format(\n                \"         1  4%n\" +\n                \"Query  1 ARND 4%n\" ));\n    }\n\n    @Test\n    public void testToStringFormatted() {\n       \n        assertEquals(global.toString(StringFormat.ALN), String.format(\n                \"CLUSTAL W MSA from BioJava%n%n\" +\n                \"Query     ARND- 4%n\" +\n                \"           | | %n\"+\n                \"Target    -R-DG 3%n\"));\n        assertEquals(local.toString(StringFormat.FASTA), String.format(\n                \">Query%n\" +\n                \"RND%n\" +\n                \">Target%n\" +\n                \"R-D%n\"));\n        assertEquals(single.toString(StringFormat.MSF), String.format(\n                \"MSA from BioJava%n%n\" +\n                \" MSF: 4  Type: P  Check: 735 ..%n%n\" +\n                \" Name: Query  Len: 4  Check:  735  Weight: 1.0%n\" +\n                \"%n//%n%n\" +\n                \"Query ARND%n\"));\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(global.toString(), String.format(\"ARND-%n-R-DG%n\"));\n        assertEquals(local.toString(), String.format(\"RND%nR-D%n\"));\n        assertEquals(single.toString(), String.format(\"ARND%n\"));\n    }\n\n    @Test\n    public void testIterator() {\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : global) {\n            assertEquals(s.toString().length(), 5);\n        }\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : local) {\n            assertEquals(s.toString().length(), 3);\n        }\n        for (AlignedSequence<ProteinSequence, AminoAcidCompound> s : single) {\n            assertEquals(s.toString().length(), 4);\n        }\n    }\n\n}\n","changedTest":"","commitMessage":"Adding serializable interface to a few classes","test_commitMessage":"","allZero":false}