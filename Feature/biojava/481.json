{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/internal/SingleRefiner.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/internal/TestSingleRefiner.java","prod_time":"2016-01-25 17:10:15","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":1,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"998e3603fdddaceca6f33913af79d4f9bf0b5855","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableSet;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\n\n/**\n * Creates a refined alignment with the CE-Symm alternative self-alignment.\n * Needs the order of symmetry and assumes that the last subunit aligns\n * with the first, being thus a CLOSE symmetry.\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.2.0\n * \n */\npublic class SingleRefiner implements Refiner {\n\t\n\t@Override\n\tpublic AFPChain refine(List<AFPChain> afpAlignments, Atom[] atoms, \n\t\t\tint order) throws RefinerFailedException, StructureException {\n\t\t\n\t\tif (order < 2)\tthrow new RefinerFailedException(\n\t\t\t\t\"Symmetry not found in the structure: order < 2.\");\n\t\t\n\t\treturn refineSymmetry(afpAlignments.get(0), atoms, atoms, order);\n\t}\n\t\n\t/**\n\t * Refines a CE-Symm alignment so that it is perfectly symmetric.\n\t *\n\t * The resulting alignment will have a one-to-one correspondance between\n\t * aligned residues of each symmetric part.\n\t * @param afpChain Input alignment from CE-Symm\n\t * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n\t * @return The refined alignment\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain refineSymmetry(AFPChain afpChain, Atom[] ca1, Atom[] ca2, int k) throws StructureException {\n\t\t// The current alignment\n\t\tMap<Integer, Integer> alignment = AlignmentTools.alignmentAsMap(afpChain);\n\n\t\t// Do the alignment\n\t\tMap<Integer, Integer> refined = refineSymmetry(alignment, k);\n\t\t\n\t\t//Substitute and partition the alignment\n\t\tAFPChain refinedAFP = AlignmentTools.replaceOptAln(afpChain, ca1, ca2, refined);\n\t\treturn partitionAFPchain(refinedAFP, ca1, ca2, k);\n\t}\n\n\t/**\n\t * Refines a CE-Symm alignment so that it is perfectly symmetric.\n\t *\n\t * The resulting alignment will have a one-to-one correspondance between\n\t * aligned residues of each symmetric part.\n\t * @param alignment The input alignment, as a map. This will be modified.\n\t * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n\t * @return A modified map with the refined alignment\n\t * @throws StructureException\n\t */\n\tpublic static Map<Integer, Integer> refineSymmetry(Map<Integer, Integer> alignment,int k) throws StructureException {\n\n\t\t// Store scores\n\t\tMap<Integer, Double> scores = null;\n\t\tscores = initializeScores(alignment,scores, k);\n\n\t\t// Store eligible residues\n\t\t// Eligible if:\n\t\t//  1. score(x)>0\n\t\t//  2. f^K-1(x) is defined\n\t\t//\t3. score(f^K-1(x))>0\n\n\t\tTreeSet<Integer> forwardLoops = new TreeSet<Integer>();\n\t\tTreeSet<Integer> backwardLoops = new TreeSet<Integer>();\n\n\n\t\tList<Integer> eligible = null;\n\t\teligible = initializeEligible(alignment,scores,eligible,k,forwardLoops,backwardLoops);\n\n\t\t/* For future heap implementation\n\t\tComparator<Integer> scoreComparator = new Comparator<Integer>() {\n\t\t\t@Override public int compare(Integer o1, Integer o2) {\n\t\t\t\tif(scores.containsKey(o1)) {\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// If both have defined scores, compare the scores\n\t\t\t\t\t\treturn scores.get(o1).compareTo(scores.get(o2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// o2 has infinite score, so o1 < o2\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//o1 has infinite score\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// o1 > o2\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//both undefined\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<Integer> heap = new PriorityQueue<Integer>(alignment.size(), scoreComparator);\n\t\t */\n\t\t//int step = 0;\n\t\twhile (!eligible.isEmpty()) {\n\t\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\t\t// Find eligible residue with lowest scores\n\t\t\tInteger bestRes = null;\n\t\t\tdouble bestResScore = Double.POSITIVE_INFINITY;\n\t\t\tfor(Integer res : eligible) {\n\t\t\t\tDouble score = scores.get(res);\n\t\t\t\tif (score != null && score < bestResScore) {\n\t\t\t\t\tbestResScore = score;\n\t\t\t\t\tbestRes = res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find f^k-1(bestRes)\n\t\t\tInteger resK1 = bestRes;\n\t\t\tfor (int i = 0; i < k - 1; i++) {\n\t\t\t\tassert (resK1 != null);\n\t\t\t\tresK1 = alignment.get(resK1);\n\n\t\t\t\t// Update scores\n\t\t\t\tscores.put(resK1, 0.0);\n\t\t\t}\n\t\t\tscores.put(bestRes, 0.0);\n\n\t\t\t// Modify alignment\n\t\t\talignment.put(resK1, bestRes);\n\n\t\t\tscores = initializeScores(alignment, scores, k);\n\n\t\t\tMap<Integer, Double> virginScores = initializeScores(alignment, null, k);\n\t\t\tif (scores.size() != virginScores.size()) {\n\t\t\t\tSystem.out.println(\"Size missmatch\");\n\t\t\t} else {\n\t\t\t\tfor (Integer key : scores.keySet()) {\n\t\t\t\t\tif (!virginScores.containsKey(key) || !scores.get(key).equals(virginScores.get(key))) {\n\t\t\t\t\t\tSystem.out.format(\"Mismatch %d -> %f/%f%n\", key, scores.get(key), virginScores.get(key));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update eligible\n\t\t\t// TODO only update residues which could become ineligible\n\t\t\teligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n\n\t\t\t// System.out.format(\"Modifying %d -> %d. %d now eligible.%n\", resK1,bestRes,eligible.size());\n\t\t}\n\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\t// Remove remaining edges\n\t\tIterator<Integer> alignmentIt = alignment.keySet().iterator();\n\t\twhile (alignmentIt.hasNext()) {\n\t\t\tInteger res = alignmentIt.next();\n\t\t\tDouble score = scores.get(res);\n\t\t\tif (score == null || score > 0.0) {\n\t\t\t\talignmentIt.remove();\n\t\t\t}\n\t\t}\n\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\treturn alignment;\n\t}\n\n\t/**\n\t * Helper method to initialize eligible residues.\n\t *\n\t * Eligible if:\n\t *  1. score(x)>0\n\t *  2. f^K-1(x) is defined\n\t *  3. score(f^K-1(x))>0\n\t *  4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t * @param alignment The alignment with respect to which to calculate eligibility\n\t * @param scores An up-to-date map from residues to their scores\n\t * @param eligible Starting list of eligible residues. If null will be generated.\n\t * @param k\n\t * @param backwardLoops\n\t * @param forwardLoops\n\t * @return eligible after modification\n\t */\n\tprivate static List<Integer> initializeEligible(Map<Integer, Integer> alignment,\n\t\t\tMap<Integer, Double> scores, List<Integer> eligible, int k, NavigableSet<Integer> forwardLoops, NavigableSet<Integer> backwardLoops) {\n\t\t// Eligible if:\n\t\t// 1. score(x)>0\n\t\t// 2. f^K-1(x) is defined\n\t\t// 3. score(f^K-1(x))>0\n\t\t// 4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t\t// 5. Not in a loop of length less than k\n\n\t\t// Assume all residues are eligible to start\n\t\tif(eligible == null) {\n\t\t\teligible = new LinkedList<Integer>(alignment.keySet());\n\t\t}\n\n\t\t// Precalculate f^K-1(x)\n\t\t// Map<Integer, Integer> alignK1 = AlignmentTools.applyAlignment(alignment, k-1);\n\t\tMap<Integer, Integer> alignK1 = applyAlignmentAndCheckCycles(alignment, k - 1, eligible);\n\n\t\t// Remove ineligible residues\n\t\tIterator<Integer> eligibleIt = eligible.iterator();\n\t\twhile(eligibleIt.hasNext()) {\n\t\t\tInteger res = eligibleIt.next();\n\n\t\t\t//  2. f^K-1(x) is defined\n\t\t\tif(!alignK1.containsKey(res)) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tInteger k1 = alignK1.get(res);\n\t\t\tif(k1 == null) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//  1. score(x)>0\n\t\t\tDouble score = scores.get(res);\n\t\t\tif(score == null || score <= 0.0) {\n\t\t\t\teligibleIt.remove();\n\n\t\t\t\t// res is in a loop. Add it to the proper set\n\t\t\t\tif(res <= alignment.get(res)) {\n\t\t\t\t\t//forward\n\t\t\t\t\tforwardLoops.add(res);\n\t\t\t\t} else {\n\t\t\t\t\t//backward\n\t\t\t\t\tbackwardLoops.add(res);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//\t3. score(f^K-1(x))>0\n\t\t\tDouble scoreK1 = scores.get(k1);\n\t\t\tif(scoreK1 == null || scoreK1 <= 0.0) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\n\t\t// Now that loops are up-to-date, check for loop crossings\n\t\teligibleIt = eligible.iterator();\n\t\twhile(eligibleIt.hasNext()) {\n\t\t\tInteger res = eligibleIt.next();\n\n\t\t\t//4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t\t\t//Test equivalent: All loop edges should be properly ordered wrt edge f^k-1(x) -> x\n\n\t\t\tInteger src = alignK1.get(res);\n\n\t\t\tif( src < res  ) {\n\t\t\t\t//forward\n\t\t\t\t// get interval [a,b) containing res\n\t\t\t\tInteger a = forwardLoops.floor(src);\n\t\t\t\tInteger b = forwardLoops.higher(src);\n\n\t\t\t\t// Ineligible unless f(a) < res < f(b)\n\t\t\t\tif(a != null && alignment.get(a) > res ) {\n\t\t\t\t\teligibleIt.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b != null && alignment.get(b) < res ) {\n\t\t\t\t\teligibleIt.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn eligible;\n\t}\n\n\n\t/**\n\t * Like {@link AlignmentTools#applyAlignment(Map, int)}, returns a map of k applications of alignmentMap. However,\n\t * it also sets loops of size less than k as ineligible.\n\t *\n\t * @param alignmentMap\n\t *            f(x)\n\t * @param k\n\t * @param eligible\n\t *            Eligible residues. Residues from small cycles are removed.\n\t * @return f^k(x)\n\t */\n\tprivate static Map<Integer, Integer> applyAlignmentAndCheckCycles(Map<Integer, Integer> alignmentMap, int k, List<Integer> eligible) {\n\n\t\t// Convert to lists to establish a fixed order (avoid concurrent modification)\n\t\tList<Integer> preimage = new ArrayList<Integer>(alignmentMap.keySet()); // currently unmodified\n\t\tList<Integer> image = new ArrayList<Integer>(preimage);\n\n\t\tfor (int n = 1; n <= k; n++) {\n\t\t\t// apply alignment\n\t\t\tfor (int i = 0; i < image.size(); i++) {\n\t\t\t\tfinal Integer pre = image.get(i);\n\t\t\t\tfinal Integer post = (pre == null ? null : alignmentMap.get(pre));\n\t\t\t\timage.set(i, post);\n\n\t\t\t\t// Make cycles ineligible\n\t\t\t\tif (post != null && post.equals(preimage.get(i))) {\n\t\t\t\t\teligible.remove(preimage.get(i)); // Could be O(n) with List impl\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<Integer, Integer> imageMap = new HashMap<Integer, Integer>(alignmentMap.size());\n\n\t\t// now populate with actual values\n\t\tfor (int i = 0; i < preimage.size(); i++) {\n\t\t\tInteger pre = preimage.get(i);\n\t\t\tInteger postK = image.get(i);\n\t\t\timageMap.put(pre, postK);\n\t\t}\n\t\treturn imageMap;\n\t}\n\n\t/**\n\t * Calculates all scores for an alignment\n\t * @param alignment\n\t * @param scores A mapping from residues to scores, which will be updated or\n\t * \tcreated if null\n\t * @return scores\n\t */\n\tprivate static Map<Integer, Double> initializeScores(Map<Integer, Integer> alignment,\n\t\t\tMap<Integer, Double> scores, int k) {\n\t\tif(scores == null) {\n\t\t\tscores = new HashMap<Integer, Double>(alignment.size());\n\t\t} else {\n\t\t\tscores.clear();\n\t\t}\n\t\tMap<Integer,Integer> alignK = AlignmentTools.applyAlignment(alignment, k);\n\n\t\t// calculate input range\n\t\tint maxPre = Integer.MIN_VALUE;\n\t\tint minPre = Integer.MAX_VALUE;\n\t\tfor(Integer pre : alignment.keySet()) {\n\t\t\tif(pre>maxPre) maxPre = pre;\n\t\t\tif(pre<minPre) minPre = pre;\n\t\t}\n\n\t\tfor(Integer pre : alignment.keySet()) {\n\t\t\tInteger image = alignK.get(pre);\n\n\t\t\t// Use the absolute error score, |x - f^k(x)|\n\t\t\tdouble score = scoreAbsError(pre,image,minPre,maxPre);\n\t\t\tscores.put(pre, score);\n\t\t}\n\t\treturn scores;\n\t}\n\n\n\n\t/**\n\t * Calculate the score for a residue, specifically the Absolute Error\n\t * \tscore(x) = |x-f^k(x)|\n\t *\n\t * Also includes a small bias based on residue number, for uniqueness..\n\t * @param pre x\n\t * @param image f^k(x)\n\t * @param minPre lowest possible residue number\n\t * @param maxPre highest possible residue number\n\t * @return\n\t */\n\tprivate static double scoreAbsError(Integer pre, Integer image,int minPre,int maxPre) {\n\t\t// Use the absolute error score, |x - f^k(x)|\n\t\tdouble error;\n\t\tif(image == null) {\n\t\t\terror = Double.POSITIVE_INFINITY;\n\t\t} else {\n\t\t\terror = Math.abs(pre - image);\n\t\t}\n\n\t\t//TODO favor lower degree-in\n\n\t\t// Add fractional portion relative to sequence position, for uniqueness\n\t\tif(error > 0)\n\t\t\terror += (double)(pre-minPre)/(1+maxPre-minPre);\n\n\t\treturn error;\n\t}\n\t\n\t/**\n\t *  Partitions an afpChain alignment into order blocks of aligned residues.\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @param order\n\t * @return\n\t * @throws StructureException\n\t */\n\tprivate static AFPChain partitionAFPchain(AFPChain afpChain, \n\t\t\tAtom[] ca1, Atom[] ca2, int order) throws StructureException{\n\t\t\n\t\tint[][][] newAlgn = new int[order][][];\n\t\tint subunitLen = afpChain.getOptLength()/order;\n\t\t\n\t\t//Extract all the residues considered in the first chain of the alignment\n\t\tList<Integer> alignedRes = new ArrayList<Integer>();\n\t\tfor (int su=0; su<afpChain.getBlockNum(); su++){\n\t\t\tfor (int i=0; i<afpChain.getOptLen()[su]; i++){\n\t\t\t\talignedRes.add(afpChain.getOptAln()[su][0][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Build the new alignment\n\t\tfor (int su=0; su<order; su++){\n\t\t\tnewAlgn[su] = new int[2][];\n\t\t\tnewAlgn[su][0] = new  int[subunitLen];\n\t\t\tnewAlgn[su][1] = new  int[subunitLen];\n\t\t\tfor (int i=0; i<subunitLen; i++){\n\t\t\t\tnewAlgn[su][0][i] = alignedRes.get(subunitLen*su+i);\n\t\t\t\tnewAlgn[su][1][i] = alignedRes.get(\n\t\t\t\t\t\t(subunitLen*(su+1)+i)%alignedRes.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn AlignmentTools.replaceOptAln(newAlgn, afpChain, ca1, ca2);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableSet;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\n\n/**\n * Creates a refined alignment with the CE-Symm alternative self-alignment.\n * Needs the order of symmetry and assumes that the last subunit aligns\n * with the first, being thus a CLOSE symmetry.\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.2.0\n * \n */\npublic class SingleRefiner implements Refiner {\n\t\n\t@Override\n\tpublic AFPChain refine(List<AFPChain> afpAlignments, Atom[] atoms, \n\t\t\tint order) throws RefinerFailedException, StructureException {\n\t\t\n\t\tif (order < 2)\tthrow new RefinerFailedException(\n\t\t\t\t\"Symmetry not found in the structure: order < 2.\");\n\t\t\n\t\treturn refineSymmetry(afpAlignments.get(0), atoms, atoms, order);\n\t}\n\t\n\t/**\n\t * Refines a CE-Symm alignment so that it is perfectly symmetric.\n\t *\n\t * The resulting alignment will have a one-to-one correspondance between\n\t * aligned residues of each symmetric part.\n\t * @param afpChain Input alignment from CE-Symm\n\t * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n\t * @return The refined alignment\n\t * @throws StructureException\n\t * @throws RefinerFailedException \n\t */\n\tpublic static AFPChain refineSymmetry(AFPChain afpChain, Atom[] ca1, Atom[] ca2, int k)\n\t\t\tthrows StructureException, RefinerFailedException {\n\t\t// The current alignment\n\t\tMap<Integer, Integer> alignment = AlignmentTools.alignmentAsMap(afpChain);\n\n\t\t// Do the alignment\n\t\tMap<Integer, Integer> refined = refineSymmetry(alignment, k);\n\t\t\n\t\t//Substitute and partition the alignment\n\t\tAFPChain refinedAFP = AlignmentTools.replaceOptAln(afpChain, ca1, ca2, refined);\n\t\trefinedAFP = partitionAFPchain(refinedAFP, ca1, ca2, k);\n\t\tif (refinedAFP.getOptLength() < 1) \n\t\t\tthrow new RefinerFailedException(\"Refiner returned empty alignment\");\n\t\treturn refinedAFP;\n\t}\n\n\t/**\n\t * Refines a CE-Symm alignment so that it is perfectly symmetric.\n\t *\n\t * The resulting alignment will have a one-to-one correspondance between\n\t * aligned residues of each symmetric part.\n\t * @param alignment The input alignment, as a map. This will be modified.\n\t * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n\t * @return A modified map with the refined alignment\n\t * @throws StructureException\n\t */\n\tpublic static Map<Integer, Integer> refineSymmetry(Map<Integer, Integer> alignment,int k) throws StructureException {\n\n\t\t// Store scores\n\t\tMap<Integer, Double> scores = null;\n\t\tscores = initializeScores(alignment,scores, k);\n\n\t\t// Store eligible residues\n\t\t// Eligible if:\n\t\t//  1. score(x)>0\n\t\t//  2. f^K-1(x) is defined\n\t\t//\t3. score(f^K-1(x))>0\n\n\t\tTreeSet<Integer> forwardLoops = new TreeSet<Integer>();\n\t\tTreeSet<Integer> backwardLoops = new TreeSet<Integer>();\n\n\n\t\tList<Integer> eligible = null;\n\t\teligible = initializeEligible(alignment,scores,eligible,k,forwardLoops,backwardLoops);\n\n\t\t/* For future heap implementation\n\t\tComparator<Integer> scoreComparator = new Comparator<Integer>() {\n\t\t\t@Override public int compare(Integer o1, Integer o2) {\n\t\t\t\tif(scores.containsKey(o1)) {\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// If both have defined scores, compare the scores\n\t\t\t\t\t\treturn scores.get(o1).compareTo(scores.get(o2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// o2 has infinite score, so o1 < o2\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//o1 has infinite score\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// o1 > o2\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//both undefined\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<Integer> heap = new PriorityQueue<Integer>(alignment.size(), scoreComparator);\n\t\t */\n\t\t//int step = 0;\n\t\twhile (!eligible.isEmpty()) {\n\t\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\t\t// Find eligible residue with lowest scores\n\t\t\tInteger bestRes = null;\n\t\t\tdouble bestResScore = Double.POSITIVE_INFINITY;\n\t\t\tfor(Integer res : eligible) {\n\t\t\t\tDouble score = scores.get(res);\n\t\t\t\tif (score != null && score < bestResScore) {\n\t\t\t\t\tbestResScore = score;\n\t\t\t\t\tbestRes = res;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Find f^k-1(bestRes)\n\t\t\tInteger resK1 = bestRes;\n\t\t\tfor (int i = 0; i < k - 1; i++) {\n\t\t\t\tassert (resK1 != null);\n\t\t\t\tresK1 = alignment.get(resK1);\n\n\t\t\t\t// Update scores\n\t\t\t\tscores.put(resK1, 0.0);\n\t\t\t}\n\t\t\tscores.put(bestRes, 0.0);\n\n\t\t\t// Modify alignment\n\t\t\talignment.put(resK1, bestRes);\n\n\t\t\tscores = initializeScores(alignment, scores, k);\n\n\t\t\tMap<Integer, Double> virginScores = initializeScores(alignment, null, k);\n\t\t\tif (scores.size() != virginScores.size()) {\n\t\t\t\tSystem.out.println(\"Size missmatch\");\n\t\t\t} else {\n\t\t\t\tfor (Integer key : scores.keySet()) {\n\t\t\t\t\tif (!virginScores.containsKey(key) || !scores.get(key).equals(virginScores.get(key))) {\n\t\t\t\t\t\tSystem.out.format(\"Mismatch %d -> %f/%f%n\", key, scores.get(key), virginScores.get(key));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update eligible\n\t\t\t// TODO only update residues which could become ineligible\n\t\t\teligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n\n\t\t\t// System.out.format(\"Modifying %d -> %d. %d now eligible.%n\", resK1,bestRes,eligible.size());\n\t\t}\n\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\t// Remove remaining edges\n\t\tIterator<Integer> alignmentIt = alignment.keySet().iterator();\n\t\twhile (alignmentIt.hasNext()) {\n\t\t\tInteger res = alignmentIt.next();\n\t\t\tDouble score = scores.get(res);\n\t\t\tif (score == null || score > 0.0) {\n\t\t\t\talignmentIt.remove();\n\t\t\t}\n\t\t}\n\t\t//System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n\n\t\treturn alignment;\n\t}\n\n\t/**\n\t * Helper method to initialize eligible residues.\n\t *\n\t * Eligible if:\n\t *  1. score(x)>0\n\t *  2. f^K-1(x) is defined\n\t *  3. score(f^K-1(x))>0\n\t *  4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t * @param alignment The alignment with respect to which to calculate eligibility\n\t * @param scores An up-to-date map from residues to their scores\n\t * @param eligible Starting list of eligible residues. If null will be generated.\n\t * @param k\n\t * @param backwardLoops\n\t * @param forwardLoops\n\t * @return eligible after modification\n\t */\n\tprivate static List<Integer> initializeEligible(Map<Integer, Integer> alignment,\n\t\t\tMap<Integer, Double> scores, List<Integer> eligible, int k, NavigableSet<Integer> forwardLoops, NavigableSet<Integer> backwardLoops) {\n\t\t// Eligible if:\n\t\t// 1. score(x)>0\n\t\t// 2. f^K-1(x) is defined\n\t\t// 3. score(f^K-1(x))>0\n\t\t// 4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t\t// 5. Not in a loop of length less than k\n\n\t\t// Assume all residues are eligible to start\n\t\tif(eligible == null) {\n\t\t\teligible = new LinkedList<Integer>(alignment.keySet());\n\t\t}\n\n\t\t// Precalculate f^K-1(x)\n\t\t// Map<Integer, Integer> alignK1 = AlignmentTools.applyAlignment(alignment, k-1);\n\t\tMap<Integer, Integer> alignK1 = applyAlignmentAndCheckCycles(alignment, k - 1, eligible);\n\n\t\t// Remove ineligible residues\n\t\tIterator<Integer> eligibleIt = eligible.iterator();\n\t\twhile(eligibleIt.hasNext()) {\n\t\t\tInteger res = eligibleIt.next();\n\n\t\t\t//  2. f^K-1(x) is defined\n\t\t\tif(!alignK1.containsKey(res)) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tInteger k1 = alignK1.get(res);\n\t\t\tif(k1 == null) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//  1. score(x)>0\n\t\t\tDouble score = scores.get(res);\n\t\t\tif(score == null || score <= 0.0) {\n\t\t\t\teligibleIt.remove();\n\n\t\t\t\t// res is in a loop. Add it to the proper set\n\t\t\t\tif(res <= alignment.get(res)) {\n\t\t\t\t\t//forward\n\t\t\t\t\tforwardLoops.add(res);\n\t\t\t\t} else {\n\t\t\t\t\t//backward\n\t\t\t\t\tbackwardLoops.add(res);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//\t3. score(f^K-1(x))>0\n\t\t\tDouble scoreK1 = scores.get(k1);\n\t\t\tif(scoreK1 == null || scoreK1 <= 0.0) {\n\t\t\t\teligibleIt.remove();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\n\t\t// Now that loops are up-to-date, check for loop crossings\n\t\teligibleIt = eligible.iterator();\n\t\twhile(eligibleIt.hasNext()) {\n\t\t\tInteger res = eligibleIt.next();\n\n\t\t\t//4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n\t\t\t//Test equivalent: All loop edges should be properly ordered wrt edge f^k-1(x) -> x\n\n\t\t\tInteger src = alignK1.get(res);\n\n\t\t\tif( src < res  ) {\n\t\t\t\t//forward\n\t\t\t\t// get interval [a,b) containing res\n\t\t\t\tInteger a = forwardLoops.floor(src);\n\t\t\t\tInteger b = forwardLoops.higher(src);\n\n\t\t\t\t// Ineligible unless f(a) < res < f(b)\n\t\t\t\tif(a != null && alignment.get(a) > res ) {\n\t\t\t\t\teligibleIt.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b != null && alignment.get(b) < res ) {\n\t\t\t\t\teligibleIt.remove();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn eligible;\n\t}\n\n\n\t/**\n\t * Like {@link AlignmentTools#applyAlignment(Map, int)}, returns a map of k applications of alignmentMap. However,\n\t * it also sets loops of size less than k as ineligible.\n\t *\n\t * @param alignmentMap\n\t *            f(x)\n\t * @param k\n\t * @param eligible\n\t *            Eligible residues. Residues from small cycles are removed.\n\t * @return f^k(x)\n\t */\n\tprivate static Map<Integer, Integer> applyAlignmentAndCheckCycles(Map<Integer, Integer> alignmentMap, int k, List<Integer> eligible) {\n\n\t\t// Convert to lists to establish a fixed order (avoid concurrent modification)\n\t\tList<Integer> preimage = new ArrayList<Integer>(alignmentMap.keySet()); // currently unmodified\n\t\tList<Integer> image = new ArrayList<Integer>(preimage);\n\n\t\tfor (int n = 1; n <= k; n++) {\n\t\t\t// apply alignment\n\t\t\tfor (int i = 0; i < image.size(); i++) {\n\t\t\t\tfinal Integer pre = image.get(i);\n\t\t\t\tfinal Integer post = (pre == null ? null : alignmentMap.get(pre));\n\t\t\t\timage.set(i, post);\n\n\t\t\t\t// Make cycles ineligible\n\t\t\t\tif (post != null && post.equals(preimage.get(i))) {\n\t\t\t\t\teligible.remove(preimage.get(i)); // Could be O(n) with List impl\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tMap<Integer, Integer> imageMap = new HashMap<Integer, Integer>(alignmentMap.size());\n\n\t\t// now populate with actual values\n\t\tfor (int i = 0; i < preimage.size(); i++) {\n\t\t\tInteger pre = preimage.get(i);\n\t\t\tInteger postK = image.get(i);\n\t\t\timageMap.put(pre, postK);\n\t\t}\n\t\treturn imageMap;\n\t}\n\n\t/**\n\t * Calculates all scores for an alignment\n\t * @param alignment\n\t * @param scores A mapping from residues to scores, which will be updated or\n\t * \tcreated if null\n\t * @return scores\n\t */\n\tprivate static Map<Integer, Double> initializeScores(Map<Integer, Integer> alignment,\n\t\t\tMap<Integer, Double> scores, int k) {\n\t\tif(scores == null) {\n\t\t\tscores = new HashMap<Integer, Double>(alignment.size());\n\t\t} else {\n\t\t\tscores.clear();\n\t\t}\n\t\tMap<Integer,Integer> alignK = AlignmentTools.applyAlignment(alignment, k);\n\n\t\t// calculate input range\n\t\tint maxPre = Integer.MIN_VALUE;\n\t\tint minPre = Integer.MAX_VALUE;\n\t\tfor(Integer pre : alignment.keySet()) {\n\t\t\tif(pre>maxPre) maxPre = pre;\n\t\t\tif(pre<minPre) minPre = pre;\n\t\t}\n\n\t\tfor(Integer pre : alignment.keySet()) {\n\t\t\tInteger image = alignK.get(pre);\n\n\t\t\t// Use the absolute error score, |x - f^k(x)|\n\t\t\tdouble score = scoreAbsError(pre,image,minPre,maxPre);\n\t\t\tscores.put(pre, score);\n\t\t}\n\t\treturn scores;\n\t}\n\n\n\n\t/**\n\t * Calculate the score for a residue, specifically the Absolute Error\n\t * \tscore(x) = |x-f^k(x)|\n\t *\n\t * Also includes a small bias based on residue number, for uniqueness..\n\t * @param pre x\n\t * @param image f^k(x)\n\t * @param minPre lowest possible residue number\n\t * @param maxPre highest possible residue number\n\t * @return\n\t */\n\tprivate static double scoreAbsError(Integer pre, Integer image,int minPre,int maxPre) {\n\t\t// Use the absolute error score, |x - f^k(x)|\n\t\tdouble error;\n\t\tif(image == null) {\n\t\t\terror = Double.POSITIVE_INFINITY;\n\t\t} else {\n\t\t\terror = Math.abs(pre - image);\n\t\t}\n\n\t\t//TODO favor lower degree-in\n\n\t\t// Add fractional portion relative to sequence position, for uniqueness\n\t\tif(error > 0)\n\t\t\terror += (double)(pre-minPre)/(1+maxPre-minPre);\n\n\t\treturn error;\n\t}\n\t\n\t/**\n\t *  Partitions an afpChain alignment into order blocks of aligned residues.\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @param order\n\t * @return\n\t * @throws StructureException\n\t */\n\tprivate static AFPChain partitionAFPchain(AFPChain afpChain, \n\t\t\tAtom[] ca1, Atom[] ca2, int order) throws StructureException{\n\t\t\n\t\tint[][][] newAlgn = new int[order][][];\n\t\tint subunitLen = afpChain.getOptLength()/order;\n\t\t\n\t\t//Extract all the residues considered in the first chain of the alignment\n\t\tList<Integer> alignedRes = new ArrayList<Integer>();\n\t\tfor (int su=0; su<afpChain.getBlockNum(); su++){\n\t\t\tfor (int i=0; i<afpChain.getOptLen()[su]; i++){\n\t\t\t\talignedRes.add(afpChain.getOptAln()[su][0][i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Build the new alignment\n\t\tfor (int su=0; su<order; su++){\n\t\t\tnewAlgn[su] = new int[2][];\n\t\t\tnewAlgn[su][0] = new  int[subunitLen];\n\t\t\tnewAlgn[su][1] = new  int[subunitLen];\n\t\t\tfor (int i=0; i<subunitLen; i++){\n\t\t\t\tnewAlgn[su][0][i] = alignedRes.get(subunitLen*su+i);\n\t\t\t\tnewAlgn[su][1][i] = alignedRes.get(\n\t\t\t\t\t\t(subunitLen*(su+1)+i)%alignedRes.size());\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn AlignmentTools.replaceOptAln(newAlgn, afpChain, ca1, ca2);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\nimport org.biojava.nbio.structure.symmetry.internal.SingleRefiner;\n\n/**\n * @author blivens\n *\n */\npublic class TestSingleRefiner extends TestCase {\n\tList<Map<Integer, Integer>> alignments;\n\tList<Integer> orders;\n\tList<Map<Integer, Integer>> expecteds;\n\n\t@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\n\t\tMap<Integer,Integer> align;\n\t\tMap<Integer,Integer> expect;\n\n\t\t// Note that all the expecteds rely on scoreAbsError being used internally\n\t\t// by refineSymmetry\n\n\t\talignments = new ArrayList<Map<Integer,Integer>>();\n\t\torders = new ArrayList<Integer>();\n\t\texpecteds = new ArrayList<Map<Integer,Integer>>();\n\n\t\t/* 0. Chained alignment\n\t\t * 1\\\n\t\t * 2>6>10<--\n\t\t * 3>7>11</\n\t\t * 4>8>12</\n\t\t * 5>9>13<--\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t1,\t6);\n\t\talign.put(\t2,\t6);\n\t\talign.put(\t3,\t7);\n\t\talign.put(\t4,\t8);\n\t\talign.put(\t5,\t9);\n\t\talign.put(\t6,\t10);\n\t\talign.put(\t7,\t11);\n\t\talign.put(\t8,\t12);\n\t\talign.put(\t9,\t13);\n\t\talign.put(\t10,\t2);\n\t\talign.put(\t11,\t4);\n\t\talign.put(\t12,\t5);\n\t\talign.put(\t13,\t5);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/* 0. Expect\n\t\t * 2>6>10<--\n\t\t * 3>7>11<--\n\t\t * 4>8>12<--\n\t\t * 5>9>13<--\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpect.put(\t2,\t6);\n\t\texpect.put(\t3,\t7);\n\t\texpect.put(\t4,\t8);\n\t\texpect.put(\t5,\t9);\n\t\texpect.put(\t6,\t10);\n\t\texpect.put(\t7,\t11);\n\t\texpect.put(\t8,\t12);\n\t\texpect.put(\t9,\t13);\n\t\texpect.put(\t10,\t2);\n\t\texpect.put(\t11,\t3);\n\t\texpect.put(\t12,\t4);\n\t\texpect.put(\t13,\t5);\n\t\texpecteds.add( expect);\n\n\n\t\t/* 1. Entering ring\n\t\t * 1->5->9<--\n\t\t *    4->8<\\\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t1,\t5);\n\t\talign.put(\t5,\t9);\n\t\talign.put(\t9,\t1);\n\t\talign.put(\t4,\t8);\n\t\talign.put(\t8,\t1);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/* 1. Expect\n\t\t * 1->5->9<--\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpect.put(\t1,\t5);\n\t\texpect.put(\t5,\t9);\n\t\texpect.put(\t9,\t1);\n\t\texpecteds.add(expect);\n\n\t\t/* 2. independent chain, lowest res\n\t\t * 1->5->9<--\n\t\t * 2->6->10<\\\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t1,\t5);\n\t\talign.put(\t5,\t9);\n\t\talign.put(\t9,\t1);\n\t\talign.put(\t2,\t6);\n\t\talign.put(\t6,\t10);\n\t\talign.put(\t10,\t1);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/* 2. Expect\n\t\t * 1->5->9<--\n\t\t * 2->6->10<--\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpect.put(\t1,\t5);\n\t\texpect.put(\t5,\t9);\n\t\texpect.put(\t9,\t1);\n\t\texpect.put(\t2,\t6);\n\t\texpect.put(\t6,\t10);\n\t\texpect.put(\t10,\t2);\n\t\texpecteds.add(expect);\n\n\t\t/* 3. independent chain, not lowest res\n\t\t * 1->5->9<--\n\t\t * 2/^6->10<--\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t1,\t5);\n\t\talign.put(\t5,\t9);\n\t\talign.put(\t9,\t1);\n\t\talign.put(\t2,\t5);\n\t\talign.put(\t6,\t10);\n\t\talign.put(\t10,\t2);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/* 3. Expect\n\t\t * 1->5->9<--\n\t\t * 2->6->10<--\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpect.put(\t1,\t5);\n\t\texpect.put(\t5,\t9);\n\t\texpect.put(\t9,\t1);\n\t\texpect.put(\t2,\t6);\n\t\texpect.put(\t6,\t10);\n\t\texpect.put(\t10,\t2);\n\t\texpecteds.add(expect);\n\n\t\t/* 4. Wrong order\n\t\t * 3->7<--\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t3,\t7);\n\t\talign.put(\t7,\t3);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/*\n\t\t * 4. Expect empty\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpecteds.add(expect);\n\n\t\t/* 5. Prioritize score over chain length\n\t\t * 1->5->9</\n\t\t * 3->6->10\n\t\t */\n\t\talign = new HashMap<Integer,Integer>();\n\t\talign.put(\t1,\t5);\n\t\talign.put(\t5,\t9);\n\t\talign.put(\t9,\t3);\n\t\talign.put(\t3,\t6);\n\t\talign.put(\t6,\t10);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/* 5. Expect\n\t\t * 3->5->9<--\n\t\t */\n\t\texpect = new HashMap<Integer,Integer>();\n\t\texpect.put(\t3,\t5);\n\t\texpect.put(\t5,\t9);\n\t\texpect.put(\t9,\t3);\n\t\texpecteds.add(expect);\n\n\t\tassertEquals(\"Error with setup\", alignments.size(), expecteds.size());\n\n\t\t/*\n\t\t * 6. Small cycles can be repaired. 3>5>7>5\n\t\t */\n\t\talign = new HashMap<Integer, Integer>();\n\t\talign.put(3, 5);\n\t\talign.put(5, 7);\n\t\talign.put(7, 5);\n\t\talignments.add(align);\n\t\torders.add(3);\n\t\t/*\n\t\t * 6. Expect 3>5>7<--\n\t\t */\n\t\texpect = new HashMap<Integer, Integer>();\n\t\texpect.put(3, 5);\n\t\texpect.put(5, 7);\n\t\texpect.put(7, 3);\n\t\texpecteds.add(expect);\n\n\t\t/*\n\t\t * 7. It might be a good idea to allow cycles if their length divides the order. However, this isn't allowed\n\t\t * yet. 3>5<\n\t\t */\n\t\talign = new HashMap<Integer, Integer>();\n\t\talign.put(3, 5);\n\t\talign.put(5, 3);\n\t\talignments.add(align);\n\t\torders.add(4);\n\t\t/*\n\t\t * 7. Expect empty, but could argue for 3>5<--\n\t\t */\n\t\texpect = new HashMap<Integer, Integer>();\n\t\texpecteds.add(expect);\n\t}\n\n\tpublic void testExpected() throws StructureException {\n\n\t\tfor(int i=0;i<alignments.size(); i++) {\n\t\t\tMap<Integer,Integer> align = alignments.get(i);\n\t\t\tMap<Integer,Integer> expect = expecteds.get(i);\n\n\t\t\tMap<Integer, Integer> refined = SingleRefiner.refineSymmetry(align, 3);\n\t\t\tif (!expect.equals(refined)) {\n\t\t\t\tSystem.out.println(\"Actual: \" + AlignmentTools.toConciseAlignmentString(align));\n\t\t\t\tSystem.out.println(\"Expect: \" + AlignmentTools.toConciseAlignmentString(expect));\n\t\t\t}\n\t\t\tassertEquals(\"Alignment \" + i + \" refinement wrong\", expect, refined);\n\t\t}\n\t}\n\n\t/**\n\t * Refined alignments should be automorphic (one-to-one)\n\t * @param align\n\t */\n\tprivate void testAutomorphism(Map<Integer,Integer> align) {\n\t\tfor(Integer pre:align.keySet()) {\n\t\t\tInteger post = align.get(pre);\n\t\t\tassertNotNull(\"Not automorphic: f(\"+pre+\") not defined\",post);\n\t\t\tassertTrue(\"not automorphic: f(\"+pre+\") = \"+post+\" but f(\"+post+\") undefined\", align.containsKey(post));\n\t\t}\n\t}\n\n\tpublic void testAutomorphism() throws StructureException {\n\t\tfor(int i=0;i<alignments.size(); i++) {\n\t\t\tMap<Integer,Integer> align = alignments.get(i);\n\n\t\t\tMap<Integer,Integer> refined = SingleRefiner.refineSymmetry(align,orders.get(i));\n\t\t\ttestAutomorphism(refined);\n\t\t}\n\t}\n\n\tprivate void testSymmetric(Map<Integer,Integer> align, int k) {\n\t\tMap<Integer,Integer> alignK = AlignmentTools.applyAlignment(align, k);\n\t\tassertEquals(align.size(), alignK.size()); // Assumption; Should be tested by AlignmentToolsTest\n\n\t\tint refinementNum = 0;\n\t\tfor(Integer res : alignK.keySet()) {\n\t\t\tInteger resK = alignK.get(res);\n\t\t\tassertEquals(String.format(\"Asymmetric alignment in #%d. f^%d(%d)=%d\", refinementNum++, k, res, resK), res,\n\t\t\t\t\tresK);\n\t\t}\n\t}\n\n\tpublic void testSymmetric() throws StructureException {\n\t\tfor(int i=0;i<alignments.size(); i++) {\n\t\t\tMap<Integer,Integer> align = alignments.get(i);\n\n\t\t\tint order = orders.get(i);\n\n\t\t\tMap<Integer, Integer> refined = SingleRefiner.refineSymmetry(align, order);\n\t\t\ttestSymmetric(refined, order);\n\t\t}\n\t}\n\n\t/* Didn't end up being a useful function, so never implemented.\n\n\tpublic void testPartitionAlignment() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\t// test private partitionAlignment method\n\t\tMethod partitionAlignment = SymmRefiner.class.getDeclaredMethod(\"partitionAlignment\", new Class[] {Map.class});\n\t\tpartitionAlignment.setAccessible(true);\n\n\t\tMap<Integer,Integer> alignment = new HashMap<Integer, Integer>();\n\t\talignment.put(2, 11);\n\t\talignment.put(3, 12);\n\t\talignment.put(4, 13);\n\t\talignment.put(6, 14);\n\t\talignment.put(7, 15);\n\t\talignment.put(8, 16);\n\t\talignment.put(10, 18);\n\t\talignment.put(12, 20);\n\t\talignment.put(13, 21);\n\t\talignment.put(15, 22);\n\t\talignment.put(16, 23);\n\t\talignment.put(17, 24);\n\t\talignment.put(18, 2);\n\t\talignment.put(20, 3);\n\t\talignment.put(21, 4);\n\t\talignment.put(22, 6);\n\t\talignment.put(23, 8);\n\t\talignment.put(24, 10);\n\n\t\tList<Map<Integer,Integer>> expected = new ArrayList<Map<Integer,Integer>>();\n\t\t//Note: should be insensitive to order (like a set), but that's harder to compare\n\t\tMap<Integer,Integer> expectedAlign = new HashMap<Integer, Integer>();\n\t\texpectedAlign.put(2, 11);\n\t\texpectedAlign.put(10, 18);\n\t\texpectedAlign.put(17, 24);\n\t\texpectedAlign.put(18, 2);\n\t\texpectedAlign.put(24, 10);\n\t\texpected.add(expectedAlign);\n\n\t\texpectedAlign = new HashMap<Integer, Integer>();\n\t\texpectedAlign.put(6, 14);\n\t\texpectedAlign.put(7, 15);\n\t\texpectedAlign.put(15, 22);\n\t\texpectedAlign.put(22, 6);\n\t\texpected.add(expectedAlign);\n\n\n\t\tList<Map<Integer,Integer>> result;\n\n\t\tresult = (List<Map<Integer, Integer>>) partitionAlignment.invoke(null, expectedAlign);\n\n\t\tassertEquals(\"Expected number of partitions differs.\",expected.size(), result.size());\n\n\t\tIterator<Map<Integer, Integer>> expIt = expected.iterator();\n\t\tIterator<Map<Integer, Integer>> resultIt = result.iterator();\n\t\twhile(expIt.hasNext()) {\n\t\t\tMap<Integer, Integer> exp = expIt.next();\n\t\t\tMap<Integer, Integer> res = resultIt.next();\n\n\t\t\tassertEquals(\"Mapping differs.\",exp,res);\n\t\t}\n\n\t}\n\t */\n\n}\n","changedTest":"","commitMessage":"Fix bug in SingleRefiner for internal symmetry\n\nEmpty alignment were returned in strange cases.","test_commitMessage":"","allZero":false}