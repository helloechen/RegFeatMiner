{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/alignment/SimpleProfile.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/alignment/SimpleProfileTest.java","prod_time":"2016-06-05 21:57:25","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"fa52fd836e80350c60c3600b09504dc5dcd64f58","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfileView;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.io.Serializable;\nimport java.util.*;\n\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Serializable, Profile<S, C> {\n\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate List<AlignedSequence<S, C>> list;\n\tprivate List<S> originals;\n\tprivate int length;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tprotected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tif (query.getLength() != target.getLength()) {\n\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(query);\n\t\tlist.add(target);\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query.getOriginalSequence());\n\t\toriginals.add(target.getOriginalSequence());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = query.getLength();\n\t}\n\n\t/**\n\t * Creates a profile from a single sequence.\n\t *\n\t * @param sequence sequence to seed profile\n\t */\n\tpublic SimpleProfile(S sequence) {\n\t\tList<Step> s = new ArrayList<Step>();\n\t\tfor (int i = 0; i < sequence.getLength(); i++) {\n\t\t\ts.add(Step.COMPOUND);\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(sequence, s));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(sequence);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sequence.getLength();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tprotected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n\t\tlist.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query);\n\t\toriginals.add(target);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given profiles.\n\t *\n\t * @param query the first profile of the pair\n\t * @param target the second profile of the pair\n\t * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n\t */\n\tprotected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (AlignedSequence<S, C> s : query) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sx));\n\t\t}\n\t\tfor (AlignedSequence<S, C> s : target) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sy));\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.addAll(query.getOriginalSequences());\n\t\toriginals.addAll(target.getOriginalSequences());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t /**\n\t * Creates a profile for the already aligned sequences.\n\t * @param alignedSequences the already aligned sequences\n\t * @throws IllegalArgument if aligned sequences differ in length or\n\t * collection is empty.\n\t */\n\tpublic SimpleProfile(Collection<AlignedSequence<S,C>> alignedSequences) {\n\t\tlist = new ArrayList<AlignedSequence<S,C>>();\n\t\toriginals = new ArrayList<S>();\n\n\t\tIterator<AlignedSequence<S,C>> itr = alignedSequences.iterator();\n\t\tif(!itr.hasNext()) {\n\t\t\tthrow new IllegalArgumentException(\"alignedSequences must not be empty\");\n\t\t}\n\n\t\tAlignedSequence<S, C> curAlignedSeq = itr.next();\n\t\tlength = curAlignedSeq.getLength();\n\t\tlist.add(curAlignedSeq);\n\t\toriginals.add(curAlignedSeq.getOriginalSequence());\n\n\t\twhile (itr.hasNext()) {\n\t\t\tcurAlignedSeq = itr.next();\n\t\t\tif (curAlignedSeq.getLength() != length) {\n\t\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t\t}\n\t\t\tlist.add(curAlignedSeq);\n\t\t\toriginals.add(curAlignedSeq.getOriginalSequence());\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t}\n\n\n\t// methods for Profile\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n\t\treturn list.get(listIndex - 1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(S sequence) {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences() {\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (int i : listIndices) {\n\t\t\ttempList.add(getAlignedSequence(i));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (S s : sequences) {\n\t\t\ttempList.add(getAlignedSequence(s));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int listIndex, int alignmentIndex) {\n\t\treturn getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(S sequence, int alignmentIndex) {\n\t\tAlignedSequence<S, C> s = getAlignedSequence(sequence);\n\t\treturn (s == null) ? null : s.getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex) {\n\t\treturn getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n\t\tint[] counts = new int[compounds.size()];\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tint igap = compounds.indexOf(gap);\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tint i = compounds.indexOf(compound);\n\t\t\tif (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\tcounts[i]++;\n\t\t\t}\n\t\t}\n\t\treturn counts;\n\t}\n\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\t// TODO handle circular alignments\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn list.get(0).getCompoundSet();\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex) {\n\t\treturn getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n\t\tfloat[] weights = new float[compounds.size()];\n\t\tint[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n\t\tfloat total = 0.0f;\n\t\tfor (int i : counts) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total > 0.0f) {\n\t\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = counts[i]/total;\n\t\t\t}\n\t\t}\n\t\treturn weights;\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int[] getIndicesAt(int alignmentIndex) {\n\t\tint[] indices = new int[list.size()];\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tindices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n\t\t}\n\t\treturn indices;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic List<S> getOriginalSequences() {\n\t\treturn originals;\n\t}\n\n\t@Override\n\tpublic int getSize() {\n\t\tint size = 0;\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tsize += s.getOverlapCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic ProfileView<S, C> getSubProfile(Location location) {\n\t\t// TODO ProfileView<S, C> getSubProfile(Location)\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasGap(int alignmentIndex) {\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tif (getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.isCircular()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(list), true, true, true, true, true, false);\n\t}\n\n\t@Override\n\tpublic String toString(StringFormat format) {\n\t\tswitch (format) {\n\t\tcase ALN:\n\t\tcase CLUSTALW:\n\t\tdefault:\n\t\t\treturn toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(list) + \"   \",\n\t\t\t\t\tfalse, true, true, false, true, false);\n\t\tcase FASTA:\n\t\t\treturn toString(60, null, \">%s%n\", false, false, false, false, false, false);\n\t\tcase GCG:\n\t\tcase MSF:\n\t\t\treturn toString(50, IOUtils.getGCGHeader(list), IOUtils.getIDFormat(list), false, false, true, false,\n\t\t\t\t\tfalse, false);\n\t\tcase PDBWEB:\n\t\t\treturn toString(60, null, \"%10s\", true, true, true, false, true, true);\n\t\t}\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false, false, false);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<AlignedSequence<S, C>> iterator() {\n\t\treturn list.iterator();\n\t}\n\n\t// helper methods\n\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n\t\t\tboolean interlaced, boolean aligIndices, boolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n\t\tif ( webDisplay && list.size() == 2){\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tint seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n\t\tString seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\t\tcounter++;\n\n\t\t\t\t\tif ( webDisplay && list.size() == 2){\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, seqIndexPre, seqIndexFormatPre, seqIndexPost,\n\t\t\t\t\t\t\t\tseqIndexFormatPost, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\n\t\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aligConservation && list.size() == 2 && counter == 1) {\n\t\t\t\t\t\tprintConservation(s, idFormat, seqIndexPad, seqIndexPre, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && list.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, boolean seqIndexPre,\n\t\t\tString seqIndexFormatPre, boolean seqIndexPost, String seqIndexFormatPost, int start, int end) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1), as = list.get(counter - 1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t}\n\n\t\tString mySeq = as.getSubSequence(start, end).getSequenceAsString();\n\t\tString s1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, isSimilar(c1, c2), c));\n\t\t}\n\n\t\tif (seqIndexPost) {\n\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t}\n\t\ts.append(String.format(\"%n\"));\n\n\t}\n\n\tprivate void printConservation(StringBuilder s, String idFormat, int seqIndexPad, boolean seqIndexPre, int start,\n\t\t\tint end, boolean webDisplay) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\tAccessionID ac1 = as1.getAccession();\n\t\t\tString id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t\t\tid1 = id1.replaceAll(\".\", \" \");\n\t\t\ts.append(String.format(idFormat, id1));\n\t\t}\n\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t}\n\n\t\tString subseq1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t\tString subseq2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor ( int ii =0 ; ii < subseq1.length() ; ii++){\n\t\t\tif ( ii >= subseq2.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = subseq1.charAt(ii);\n\t\t\tchar c2 = subseq2.charAt(ii);\n\t\t\ts.append(IOUtils.getPDBConservation(webDisplay, c1, c2, isSimilar(c1, c2)));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n\tprotected static final SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n\n\tprivate boolean isSimilar(char c1, char c2) {\n\t\tAminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\n\t\tAminoAcidCompound aa1 = set.getCompoundForString(\"\"+c1);\n\t\tAminoAcidCompound aa2 = set.getCompoundForString(\"\"+c2);\n\n\t\tshort val = matrix.getValue(aa1,aa2);\n\t\treturn val > 0;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfileView;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.io.Serializable;\nimport java.util.*;\n\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Serializable, Profile<S, C> {\n\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate List<AlignedSequence<S, C>> list;\n\tprivate List<S> originals;\n\tprivate int length;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tprotected SimpleProfile(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tif (query.getLength() != target.getLength()) {\n\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(query);\n\t\tlist.add(target);\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query.getOriginalSequence());\n\t\toriginals.add(target.getOriginalSequence());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = query.getLength();\n\t}\n\n\t/**\n\t * Creates a profile from a single sequence.\n\t *\n\t * @param sequence sequence to seed profile\n\t */\n\tpublic SimpleProfile(S sequence) {\n\t\tList<Step> s = new ArrayList<Step>();\n\t\tfor (int i = 0; i < sequence.getLength(); i++) {\n\t\t\ts.add(Step.COMPOUND);\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(sequence, s));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(sequence);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sequence.getLength();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tprotected SimpleProfile(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tlist.add(new SimpleAlignedSequence<S, C>(query, sx, xb, xa));\n\t\tlist.add(new SimpleAlignedSequence<S, C>(target, sy, yb, ya));\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.add(query);\n\t\toriginals.add(target);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t/**\n\t * Creates a pair profile for the given profiles.\n\t *\n\t * @param query the first profile of the pair\n\t * @param target the second profile of the pair\n\t * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n\t */\n\tprotected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n\t\tif (sx.size() != sy.size()) {\n\t\t\tthrow new IllegalArgumentException(\"Alignments differ in size\");\n\t\t}\n\t\tlist = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (AlignedSequence<S, C> s : query) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sx));\n\t\t}\n\t\tfor (AlignedSequence<S, C> s : target) {\n\t\t\tlist.add(new SimpleAlignedSequence<S, C>(s, sy));\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = new ArrayList<S>();\n\t\toriginals.addAll(query.getOriginalSequences());\n\t\toriginals.addAll(target.getOriginalSequences());\n\t\toriginals = Collections.unmodifiableList(originals);\n\t\tlength = sx.size();\n\t}\n\n\t /**\n\t * Creates a profile for the already aligned sequences.\n\t * @param alignedSequences the already aligned sequences\n\t * @throws IllegalArgument if aligned sequences differ in length or\n\t * collection is empty.\n\t */\n\tpublic SimpleProfile(Collection<AlignedSequence<S,C>> alignedSequences) {\n\t\tlist = new ArrayList<AlignedSequence<S,C>>();\n\t\toriginals = new ArrayList<S>();\n\n\t\tIterator<AlignedSequence<S,C>> itr = alignedSequences.iterator();\n\t\tif(!itr.hasNext()) {\n\t\t\tthrow new IllegalArgumentException(\"alignedSequences must not be empty\");\n\t\t}\n\n\t\tAlignedSequence<S, C> curAlignedSeq = itr.next();\n\t\tlength = curAlignedSeq.getLength();\n\t\tlist.add(curAlignedSeq);\n\t\toriginals.add(curAlignedSeq.getOriginalSequence());\n\n\t\twhile (itr.hasNext()) {\n\t\t\tcurAlignedSeq = itr.next();\n\t\t\tif (curAlignedSeq.getLength() != length) {\n\t\t\t\tthrow new IllegalArgumentException(\"Aligned sequences differ in size\");\n\t\t\t}\n\t\t\tlist.add(curAlignedSeq);\n\t\t\toriginals.add(curAlignedSeq.getOriginalSequence());\n\t\t}\n\t\tlist = Collections.unmodifiableList(list);\n\t\toriginals = Collections.unmodifiableList(originals);\n\t}\n\n\n\t// methods for Profile\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(int listIndex) {\n\t\treturn list.get(listIndex - 1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getAlignedSequence(S sequence) {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences() {\n\t\treturn list;\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(int... listIndices) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (int i : listIndices) {\n\t\t\ttempList.add(getAlignedSequence(i));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic List<AlignedSequence<S, C>> getAlignedSequences(S... sequences) {\n\t\tList<AlignedSequence<S, C>> tempList = new ArrayList<AlignedSequence<S, C>>();\n\t\tfor (S s : sequences) {\n\t\t\ttempList.add(getAlignedSequence(s));\n\t\t}\n\t\treturn Collections.unmodifiableList(tempList);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int listIndex, int alignmentIndex) {\n\t\treturn getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(S sequence, int alignmentIndex) {\n\t\tAlignedSequence<S, C> s = getAlignedSequence(sequence);\n\t\treturn (s == null) ? null : s.getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex) {\n\t\treturn getCompoundCountsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic int[] getCompoundCountsAt(int alignmentIndex, List<C> compounds) {\n\t\tint[] counts = new int[compounds.size()];\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tint igap = compounds.indexOf(gap);\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tint i = compounds.indexOf(compound);\n\t\t\tif (i >= 0 && i != igap && !getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\tcounts[i]++;\n\t\t\t}\n\t\t}\n\t\treturn counts;\n\t}\n\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\t// TODO handle circular alignments\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn list.get(0).getCompoundSet();\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex) {\n\t\treturn getCompoundWeightsAt(alignmentIndex, getCompoundSet().getAllCompounds());\n\t}\n\n\t@Override\n\tpublic float[] getCompoundWeightsAt(int alignmentIndex, List<C> compounds) {\n\t\tfloat[] weights = new float[compounds.size()];\n\t\tint[] counts = getCompoundCountsAt(alignmentIndex, compounds);\n\t\tfloat total = 0.0f;\n\t\tfor (int i : counts) {\n\t\t\ttotal += i;\n\t\t}\n\t\tif (total > 0.0f) {\n\t\t\tfor (int i = 0; i < weights.length; i++) {\n\t\t\t\tweights[i] = counts[i]/total;\n\t\t\t}\n\t\t}\n\t\treturn weights;\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int[] getIndicesAt(int alignmentIndex) {\n\t\tint[] indices = new int[list.size()];\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tindices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n\t\t}\n\t\treturn indices;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (getCompoundsAt(i).contains(compound)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic List<S> getOriginalSequences() {\n\t\treturn originals;\n\t}\n\n\t@Override\n\tpublic int getSize() {\n\t\tint size = 0;\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tsize += s.getOverlapCount();\n\t\t}\n\t\treturn size;\n\t}\n\n\t@Override\n\tpublic ProfileView<S, C> getSubProfile(Location location) {\n\t\t// TODO ProfileView<S, C> getSubProfile(Location)\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean hasGap(int alignmentIndex) {\n\t\tC gap = getCompoundSet().getCompoundForString(\"-\");\n\t\tfor (C compound : getCompoundsAt(alignmentIndex)) {\n\t\t\tif (getCompoundSet().compoundsEquivalent(compound, gap)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\tfor (AlignedSequence<S, C> s : list) {\n\t\t\tif (s.isCircular()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(list), true, true, true, true, true, false);\n\t}\n\n\t@Override\n\tpublic String toString(StringFormat format) {\n\t\tswitch (format) {\n\t\tcase ALN:\n\t\tcase CLUSTALW:\n\t\tdefault:\n\t\t\treturn toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(list) + \"   \",\n\t\t\t\t\tfalse, true, true, false, true, false);\n\t\tcase FASTA:\n\t\t\treturn toString(60, null, \">%s%n\", false, false, false, false, false, false);\n\t\tcase GCG:\n\t\tcase MSF:\n\t\t\treturn toString(50, IOUtils.getGCGHeader(list), IOUtils.getIDFormat(list), false, false, true, false,\n\t\t\t\t\tfalse, false);\n\t\tcase PDBWEB:\n\t\t\treturn toString(60, null, \"%10s\", true, true, true, false, true, true);\n\t\t}\n\t}\n\n\t// method from Object\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false, false, false);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<AlignedSequence<S, C>> iterator() {\n\t\treturn list.iterator();\n\t}\n\n\t// helper methods\n\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean seqIndexPre, boolean seqIndexPost,\n\t\t\tboolean interlaced, boolean aligIndices, boolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n\t\tif ( webDisplay && list.size() == 2){\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tint seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n\t\tString seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\t\tcounter++;\n\n\t\t\t\t\tif ( webDisplay && list.size() == 2){\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, seqIndexPre, seqIndexFormatPre, seqIndexPost,\n\t\t\t\t\t\t\t\tseqIndexFormatPost, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\n\t\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aligConservation && list.size() == 2 && counter == 1) {\n\t\t\t\t\t\tprintConservation(s, idFormat, seqIndexPad, seqIndexPre, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t} else {\n\t\t\tfor (AlignedSequence<S, C> as : list) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\tif (seqIndexPre) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\tif (seqIndexPost) {\n\t\t\t\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && list.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, boolean seqIndexPre,\n\t\t\tString seqIndexFormatPre, boolean seqIndexPost, String seqIndexFormatPost, int start, int end) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1), as = list.get(counter - 1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n\t\t}\n\n\t\tString mySeq = as.getSubSequence(start, end).getSequenceAsString();\n\t\tString s1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, isSimilar(c1, c2), c));\n\t\t}\n\n\t\tif (seqIndexPost) {\n\t\t\ts.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n\t\t}\n\t\ts.append(String.format(\"%n\"));\n\n\t}\n\n\tprivate void printConservation(StringBuilder s, String idFormat, int seqIndexPad, boolean seqIndexPre, int start,\n\t\t\tint end, boolean webDisplay) {\n\t\tAlignedSequence<S,C> as1 = list.get(0), as2 = list.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\tAccessionID ac1 = as1.getAccession();\n\t\t\tString id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t\t\tid1 = id1.replaceAll(\".\", \" \");\n\t\t\ts.append(String.format(idFormat, id1));\n\t\t}\n\n\t\tif (seqIndexPre) {\n\t\t\ts.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n\t\t}\n\n\t\tString subseq1 = as1.getSubSequence(start, end).getSequenceAsString();\n\t\tString subseq2 = as2.getSubSequence(start, end).getSequenceAsString();\n\n\t\tfor ( int ii =0 ; ii < subseq1.length() ; ii++){\n\t\t\tif ( ii >= subseq2.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = subseq1.charAt(ii);\n\t\t\tchar c2 = subseq2.charAt(ii);\n\t\t\ts.append(IOUtils.getPDBConservation(webDisplay, c1, c2, isSimilar(c1, c2)));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n\tprotected static final SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n\n\tprivate boolean isSimilar(char c1, char c2) {\n\t\tAminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\n\t\tAminoAcidCompound aa1 = set.getCompoundForString(String.valueOf(c1));\n\t\tAminoAcidCompound aa2 = set.getCompoundForString(String.valueOf(c2));\n\n\t\tshort val = matrix.getValue(aa1,aa2);\n\t\treturn val > 0;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.Profile.StringFormat;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class SimpleProfileTest {\n\n\tprivate ProteinSequence query, target;\n\tprivate Profile<ProteinSequence, AminoAcidCompound> global, local, single;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tquery = new ProteinSequence(\"ARND\");\n\t\ttarget = new ProteinSequence(\"RDG\");\n\t\tquery.setAccession(new AccessionID(\"Query\"));\n\t\ttarget.setAccession(new AccessionID(\"Target\"));\n\t\tglobal = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n\t\t\t\tnew Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}), 0, 0);\n\t\tlocal = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n\t\t\t\tStep.GAP, Step.COMPOUND}), 0, 1);\n\t\tsingle = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query);\n\t}\n\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void testSimpleProfile() {\n\t\tnew SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), 0, 0, Arrays.asList(\n\t\t\t\tnew Step[] {Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND}), 0, 0);\n\t}\n\n\t@Test\n\tpublic void testGetAlignedSequenceInt() {\n\t\tassertEquals(global.getAlignedSequence(1).toString(), \"ARND-\");\n\t\tassertEquals(global.getAlignedSequence(2).toString(), \"-R-DG\");\n\t\tassertEquals(local.getAlignedSequence(1).toString(), \"RND\");\n\t\tassertEquals(local.getAlignedSequence(2).toString(), \"R-D\");\n\t\tassertEquals(single.getAlignedSequence(1).toString(), \"ARND\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds() {\n\t\tglobal.getAlignedSequence(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds2() {\n\t\tglobal.getAlignedSequence(3);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds3() {\n\t\tlocal.getAlignedSequence(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds4() {\n\t\tlocal.getAlignedSequence(3);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds5() {\n\t\tsingle.getAlignedSequence(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignedSequenceIntOutOfBounds6() {\n\t\tsingle.getAlignedSequence(2);\n\t}\n\n\t@Test\n\tpublic void testGetAlignedSequenceS() throws CompoundNotFoundException {\n\t\tassertEquals(global.getAlignedSequence(query).toString(), \"ARND-\");\n\t\tassertEquals(global.getAlignedSequence(target).toString(), \"-R-DG\");\n\t\tassertNull(global.getAlignedSequence(new ProteinSequence(\"AR\")));\n\t\tassertEquals(local.getAlignedSequence(query).toString(), \"RND\");\n\t\tassertEquals(local.getAlignedSequence(target).toString(), \"R-D\");\n\t\tassertNull(local.getAlignedSequence(new ProteinSequence(\"AR\")));\n\t\tassertEquals(single.getAlignedSequence(query).toString(), \"ARND\");\n\t\tassertNull(single.getAlignedSequence(target));\n\t}\n\n\t@Test\n\tpublic void testGetAlignedSequences() {\n\t\tList<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences();\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0).toString(), \"ARND-\");\n\t\tassertEquals(list.get(1).toString(), \"-R-DG\");\n\t\tlist = local.getAlignedSequences();\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0).toString(), \"RND\");\n\t\tassertEquals(list.get(1).toString(), \"R-D\");\n\t\tlist = single.getAlignedSequences();\n\t\tassertEquals(list.size(), 1);\n\t\tassertEquals(list.get(0).toString(), \"ARND\");\n\t}\n\n\t@Test\n\tpublic void testGetAlignedSequencesIntArray() {\n\t\tList<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(2, 1, 2);\n\t\tassertEquals(list.size(), 3);\n\t\tassertEquals(list.get(0).toString(), \"-R-DG\");\n\t\tassertEquals(list.get(1).toString(), \"ARND-\");\n\t\tassertEquals(list.get(2).toString(), \"-R-DG\");\n\t\tlist = local.getAlignedSequences(2, 2, 1);\n\t\tassertEquals(list.size(), 3);\n\t\tassertEquals(list.get(0).toString(), \"R-D\");\n\t\tassertEquals(list.get(1).toString(), \"R-D\");\n\t\tassertEquals(list.get(2).toString(), \"RND\");\n\t\tlist = single.getAlignedSequences(1, 1);\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0).toString(), \"ARND\");\n\t\tassertEquals(list.get(1).toString(), \"ARND\");\n\t}\n\n\t@Test\n\tpublic void testGetAlignedSequencesSArray() {\n\t\tList<AlignedSequence<ProteinSequence, AminoAcidCompound>> list = global.getAlignedSequences(query, query,\n\t\t\t\ttarget);\n\t\tassertEquals(list.size(), 3);\n\t\tassertEquals(list.get(0).toString(), \"ARND-\");\n\t\tassertEquals(list.get(1).toString(), \"ARND-\");\n\t\tassertEquals(list.get(2).toString(), \"-R-DG\");\n\t\tlist = local.getAlignedSequences(target, query, target);\n\t\tassertEquals(list.size(), 3);\n\t\tassertEquals(list.get(0).toString(), \"R-D\");\n\t\tassertEquals(list.get(1).toString(), \"RND\");\n\t\tassertEquals(list.get(2).toString(), \"R-D\");\n\t\tlist = single.getAlignedSequences(query, query);\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0).toString(), \"ARND\");\n\t\tassertEquals(list.get(1).toString(), \"ARND\");\n\t}\n\n\t@Test\n\tpublic void testGetCompoundAtIntInt() {\n\t\tassertEquals(global.getCompoundAt(1, 4).getShortName(), \"D\");\n\t\tassertEquals(global.getCompoundAt(2, 3).getShortName(), \"-\");\n\t\tassertEquals(local.getCompoundAt(1, 1).getShortName(), \"R\");\n\t\tassertEquals(local.getCompoundAt(2, 2).getShortName(), \"-\");\n\t\tassertEquals(single.getCompoundAt(1, 3).getShortName(), \"N\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds() {\n\t\tglobal.getCompoundAt(0, 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds2() {\n\t\tglobal.getCompoundAt(3, 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds3() {\n\t\tglobal.getCompoundAt(1, 0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds4() {\n\t\tglobal.getCompoundAt(2, 6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds5() {\n\t\tlocal.getCompoundAt(0, 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds6() {\n\t\tlocal.getCompoundAt(3, 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds7() {\n\t\tlocal.getCompoundAt(1, 0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds8() {\n\t\tlocal.getCompoundAt(2, 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtIntIntOutOfBounds9() {\n\t\tsingle.getCompoundAt(1, 0);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundAtSInt() throws CompoundNotFoundException {\n\t\tassertEquals(global.getCompoundAt(query, 2).getShortName(), \"R\");\n\t\tassertEquals(global.getCompoundAt(target, 5).getShortName(), \"G\");\n\t\tassertNull(global.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n\t\tassertEquals(local.getCompoundAt(query, 2).getShortName(), \"N\");\n\t\tassertEquals(local.getCompoundAt(target, 3).getShortName(), \"D\");\n\t\tassertNull(local.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n\t\tassertEquals(single.getCompoundAt(query, 2).getShortName(), \"R\");\n\t\tassertNull(single.getCompoundAt(target, 3));\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtSIntOutOfBounds() {\n\t\tglobal.getCompoundAt(query, 0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtSIntOutOfBounds2() {\n\t\tglobal.getCompoundAt(target, 6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtSIntOutOfBounds3() {\n\t\tlocal.getCompoundAt(target, 0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtSIntOutOfBounds4() {\n\t\tlocal.getCompoundAt(query, 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundAtSIntOutOfBounds5() {\n\t\tsingle.getCompoundAt(query, 0);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundSet() {\n\t\tassertEquals(global.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tassertEquals(local.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tassertEquals(single.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t}\n\n\t@Test\n\tpublic void testGetCompoundsAt() {\n\t\tList<AminoAcidCompound> column = global.getCompoundsAt(5);\n\t\tassertEquals(column.size(), 2);\n\t\tassertEquals(column.get(0).getShortName(), \"-\");\n\t\tassertEquals(column.get(1).getShortName(), \"G\");\n\t\tcolumn = local.getCompoundsAt(2);\n\t\tassertEquals(column.size(), 2);\n\t\tassertEquals(column.get(0).getShortName(), \"N\");\n\t\tassertEquals(column.get(1).getShortName(), \"-\");\n\t\tcolumn = single.getCompoundsAt(2);\n\t\tassertEquals(column.size(), 1);\n\t\tassertEquals(column.get(0).getShortName(), \"R\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds() {\n\t\tglobal.getCompoundsAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds2() {\n\t\tglobal.getCompoundsAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds3() {\n\t\tlocal.getCompoundsAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds4() {\n\t\tlocal.getCompoundsAt(4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds5() {\n\t\tsingle.getCompoundsAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundsAtOutOfBounds6() {\n\t\tsingle.getCompoundsAt(5);\n\t}\n\n\t@Test\n\tpublic void testGetIndexOf() {\n\t\tAminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"E\")), -1);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"R\")), 1);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"D\")), 3);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 2);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"K\")), -1);\n\t\tassertEquals(single.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n\t\tassertEquals(single.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n\t\tassertEquals(single.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n\t\tassertEquals(single.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n\t\tassertEquals(single.getIndexOf(cs.getCompoundForString(\"G\")), -1);\n\t}\n\n\t@Test\n\tpublic void testGetIndicesAt() {\n\t\tassertArrayEquals(global.getIndicesAt(1), new int[] {1, 1});\n\t\tassertArrayEquals(global.getIndicesAt(2), new int[] {2, 1});\n\t\tassertArrayEquals(global.getIndicesAt(3), new int[] {3, 1});\n\t\tassertArrayEquals(global.getIndicesAt(4), new int[] {4, 2});\n\t\tassertArrayEquals(global.getIndicesAt(5), new int[] {4, 3});\n\t\tassertArrayEquals(local.getIndicesAt(1), new int[] {2, 1});\n\t\tassertArrayEquals(local.getIndicesAt(2), new int[] {3, 1});\n\t\tassertArrayEquals(local.getIndicesAt(3), new int[] {4, 2});\n\t\tassertArrayEquals(single.getIndicesAt(1), new int[] {1});\n\t\tassertArrayEquals(single.getIndicesAt(2), new int[] {2});\n\t\tassertArrayEquals(single.getIndicesAt(3), new int[] {3});\n\t\tassertArrayEquals(single.getIndicesAt(4), new int[] {4});\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds() {\n\t\tglobal.getIndicesAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds2() {\n\t\tglobal.getIndicesAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds3() {\n\t\tlocal.getIndicesAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds4() {\n\t\tlocal.getIndicesAt(4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds5() {\n\t\tsingle.getIndicesAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndicesAtOutOfBounds6() {\n\t\tsingle.getIndicesAt(5);\n\t}\n\n\t@Test\n\tpublic void testGetLastIndexOf() {\n\t\tAminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 5);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"E\")), -1);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"R\")), 1);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"D\")), 3);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 2);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"K\")), -1);\n\t\tassertEquals(single.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n\t\tassertEquals(single.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n\t\tassertEquals(single.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n\t\tassertEquals(single.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n\t\tassertEquals(single.getLastIndexOf(cs.getCompoundForString(\"G\")), -1);\n\t}\n\n\t@Test\n\tpublic void testGetLength() {\n\t\tassertEquals(global.getLength(), 5);\n\t\tassertEquals(local.getLength(), 3);\n\t\tassertEquals(single.getLength(), 4);\n\t}\n\n\t@Test\n\tpublic void testGetOriginalSequences() {\n\t\tList<ProteinSequence> list = global.getOriginalSequences();\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0), query);\n\t\tassertEquals(list.get(1), target);\n\t\tlist = local.getOriginalSequences();\n\t\tassertEquals(list.size(), 2);\n\t\tassertEquals(list.get(0), query);\n\t\tassertEquals(list.get(1), target);\n\t\tlist = single.getOriginalSequences();\n\t\tassertEquals(list.size(), 1);\n\t\tassertEquals(list.get(0), query);\n\t}\n\n\t@Test\n\tpublic void testGetSize() {\n\t\tassertEquals(global.getSize(), 2);\n\t\tassertEquals(local.getSize(), 2);\n\t\tassertEquals(single.getSize(), 1);\n\t}\n\n\t@Ignore // TODO SimpleProfile.getSubProfile(Location)\n\t@Test\n\tpublic void testGetSubProfile() {\n\t\tfail(\"Not yet implemented\");\n\t}\n\n\t@Test\n\tpublic void testIsCircular() {\n\t\tassertFalse(global.isCircular());\n\t\tassertFalse(local.isCircular());\n\t\tassertFalse(single.isCircular());\n\t}\n\n\t@Test\n\tpublic void testToStringInt() {\n\n\n\n\n\t\tassertEquals(global.toString(3), String.format(\n\t\t\t\t\"          1 3%n\" +\n\t\t\t\t\"Query   1 ARN 3%n\" +\n\t\t\t\t\"           | %n\"+\n\t\t\t\t\"Target  1 -R- 1%n\" +\n\t\t\t\t\"%n\" +\n\t\t\t\t\"          4 5%n\" +\n\t\t\t\t\"Query   4 D- 4%n\" +\n\t\t\t\t\"          | %n\"+\n\t\t\t\t\"Target  2 DG 3%n\"));\n\t\tassertEquals(local.toString(4), String.format(\n\t\t\t\t\"          1 3%n\" +\n\t\t\t\t\"Query   2 RND 4%n\" +\n\t\t\t\t\"          | |%n\"+\n\t\t\t\t\"Target  1 R-D 2%n\"));\n\t\tassertEquals(single.toString(4), String.format(\n\t\t\t\t\"         1  4%n\" +\n\t\t\t\t\"Query  1 ARND 4%n\" ));\n\t}\n\n\t@Test\n\tpublic void testToStringFormatted() {\n\n\t\tassertEquals(global.toString(StringFormat.ALN), String.format(\n\t\t\t\t\"CLUSTAL W MSA from BioJava%n%n\" +\n\t\t\t\t\"Query     ARND- 4%n\" +\n\t\t\t\t\"           | | %n\"+\n\t\t\t\t\"Target    -R-DG 3%n\"));\n\t\tassertEquals(local.toString(StringFormat.FASTA), String.format(\n\t\t\t\t\">Query%n\" +\n\t\t\t\t\"RND%n\" +\n\t\t\t\t\">Target%n\" +\n\t\t\t\t\"R-D%n\"));\n\t\tassertEquals(single.toString(StringFormat.MSF), String.format(\n\t\t\t\t\"MSA from BioJava%n%n\" +\n\t\t\t\t\" MSF: 4  Type: P  Check: 735 ..%n%n\" +\n\t\t\t\t\" Name: Query  Len: 4  Check:  735  Weight: 1.0%n\" +\n\t\t\t\t\"%n//%n%n\" +\n\t\t\t\t\"Query ARND%n\"));\n\t}\n\n\t@Test\n\tpublic void testToString() {\n\t\tassertEquals(global.toString(), String.format(\"ARND-%n-R-DG%n\"));\n\t\tassertEquals(local.toString(), String.format(\"RND%nR-D%n\"));\n\t\tassertEquals(single.toString(), String.format(\"ARND%n\"));\n\t}\n\n\t@Test\n\tpublic void testIterator() {\n\t\tfor (AlignedSequence<ProteinSequence, AminoAcidCompound> s : global) {\n\t\t\tassertEquals(s.toString().length(), 5);\n\t\t}\n\t\tfor (AlignedSequence<ProteinSequence, AminoAcidCompound> s : local) {\n\t\t\tassertEquals(s.toString().length(), 3);\n\t\t}\n\t\tfor (AlignedSequence<ProteinSequence, AminoAcidCompound> s : single) {\n\t\t\tassertEquals(s.toString().length(), 4);\n\t\t}\n\t}\n\n}\n","changedTest":"","commitMessage":"squid:S2131 - Primitives should not be boxed just for String conversion\n","test_commitMessage":"","allZero":false}