{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/NeedlemanWunsch.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/NeedlemanWunschTest.java","prod_time":"2010-07-07 17:15:37","test_time":"2010-07-27 13:26:45","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"138b67585baa82a285f47bc4d8d51685f14e781a","test_commitID":"0118cdbd110bbd3b2355c465bb633dbc150cb032","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 11, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AbstractPairwiseSequenceAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Needleman and Wunsch defined an algorithm for pairwise global sequence alignments (from the first until the last\n * {@link Compound} of each {@link Sequence}).  This class performs such global sequence comparisons efficiently by\n * dynamic programming.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} of the alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class NeedlemanWunsch<S extends Sequence<C>, C extends Compound>\n        extends AbstractPairwiseSequenceAligner<S, C> {\n\n    /**\n     * Before running a pairwise global sequence alignment, data must be sent in via calls to\n     * {@link #setQuery(Sequence)}, {@link #setTarget(Sequence)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public NeedlemanWunsch() {\n    }\n\n    /**\n     * Prepares for a pairwise global sequence alignment.\n     *\n     * @param query the first {@link Sequence} of the pair to align\n     * @param target the second {@link Sequence} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public NeedlemanWunsch(S query, S target, GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    // helper methods\n\n    // scores with linear gap penalty; saves memory by skipping allocation of separate matching and gap arrays\n    @Override\n    protected void alignScoreLinear() {\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = (short) (scores[x - 1][0] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = (short) (scores[0][y - 1] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) Math.max(Math.max(scores[x - 1][y] + getGapPenalty().getExtensionPenalty(),\n                        scores[x][y - 1] + getGapPenalty().getExtensionPenalty()), scores[x - 1][y - 1] +\n                        getSubstitutionMatrix().getValue(getQuery().getCompoundAt(x), getTarget().getCompoundAt(y)));\n            }\n        }\n    }\n\n    // traces back through score matrix; chooses highroad alignment\n    @Override\n    protected void alignTracebackLinear(List<Step> sx, List<Step> sy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        while (x > 0 || y > 0) {\n            if (x == 0) {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            } else if (y == 0 || scores[x][y] == scores[x - 1][y] + getGapPenalty().getExtensionPenalty()) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n            } else if (scores[x][y] == scores[x - 1][y - 1] + getSubstitutionMatrix().getValue(\n                    getQuery().getCompoundAt(x), getTarget().getCompoundAt(y))) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n            } else {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            }\n        }\n    }\n\n    // scores with affine gap penalty\n    @Override\n    protected void alignScoreAffine(short[][] ix, short[][] iy) {\n        GapPenalty gapPenalty = getGapPenalty();\n        short min = (short) (Short.MIN_VALUE - gapPenalty.getOpenPenalty() - gapPenalty.getExtensionPenalty());\n        ix[0][0] = iy[0][0] = gapPenalty.getOpenPenalty();\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = iy[x][0] = min;\n            ix[x][0] = (short) (ix[x - 1][0] + gapPenalty.getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = ix[0][y] = min;\n            iy[0][y] = (short) (iy[0][y - 1] + gapPenalty.getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) (Math.max(Math.max(scores[x - 1][y - 1], ix[x - 1][y - 1]), iy[x - 1][y - 1]) +\n                        getSubstitutionMatrix().getValue(getQuery().getCompoundAt(x), getTarget().getCompoundAt(y)));\n                ix[x][y] = (short) (Math.max(scores[x - 1][y] + gapPenalty.getOpenPenalty(), ix[x - 1][y]) +\n                        gapPenalty.getExtensionPenalty());\n                iy[x][y] = (short) (Math.max(scores[x][y - 1] + gapPenalty.getOpenPenalty(), iy[x][y - 1]) +\n                        gapPenalty.getExtensionPenalty());\n            }\n        }\n    }\n\n    // traces back through score matrices; chooses highroad alignment\n    @Override\n    protected void alignTracebackAffine(List<Step> sx, List<Step> sy, short[][] ix, short[][] iy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        int max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n        Last last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n        while (x > 0 || y > 0) {\n            switch (last) {\n            case IX:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() > ix[x][y]) ? Last.M : Last.IX;\n                break;\n            case M:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n                max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n                last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n                break;\n            case IY:\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() >= iy[x][y]) ? Last.M : Last.IY;\n            }\n        }\n    }\n\n    // sets output fields\n    @Override\n    protected void alignSetOutputs(List<Step> sx, List<Step> sy) {\n        score = scores[scores.length - 1][scores[0].length - 1];\n        profile = pair = new SimpleSequencePair<S, C>(getQuery(), getTarget(), sx, sy);\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 11, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AbstractPairwiseSequenceAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Needleman and Wunsch defined an algorithm for pairwise global sequence alignments (from the first until the last\n * {@link Compound} of each {@link Sequence}).  This class performs such global sequence comparisons efficiently by\n * dynamic programming.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} of the alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class NeedlemanWunsch<S extends Sequence<C>, C extends Compound>\n        extends AbstractPairwiseSequenceAligner<S, C> {\n\n    /**\n     * Before running a pairwise global sequence alignment, data must be sent in via calls to\n     * {@link #setQuery(Sequence)}, {@link #setTarget(Sequence)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public NeedlemanWunsch() {\n    }\n\n    /**\n     * Prepares for a pairwise global sequence alignment.\n     *\n     * @param query the first {@link Sequence} of the pair to align\n     * @param target the second {@link Sequence} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public NeedlemanWunsch(S query, S target, GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    // helper methods\n\n    // scores with linear gap penalty; saves memory by skipping allocation of separate matching and gap arrays\n    @Override\n    protected void alignScoreLinear() {\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = (short) (scores[x - 1][0] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = (short) (scores[0][y - 1] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) Math.max(Math.max(scores[x - 1][y] + getGapPenalty().getExtensionPenalty(),\n                        scores[x][y - 1] + getGapPenalty().getExtensionPenalty()), scores[x - 1][y - 1] +\n                        alignScoreColumns(x, y));\n            }\n        }\n    }\n\n    // traces back through score matrix; chooses highroad alignment\n    @Override\n    protected void alignTracebackLinear(List<Step> sx, List<Step> sy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        while (x > 0 || y > 0) {\n            if (x == 0) {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            } else if (y == 0 || scores[x][y] == scores[x - 1][y] + getGapPenalty().getExtensionPenalty()) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n            } else if (scores[x][y] == scores[x - 1][y - 1] + alignScoreColumns(x, y)) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n            } else {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            }\n        }\n    }\n\n    // scores with affine gap penalty\n    @Override\n    protected void alignScoreAffine(short[][] ix, short[][] iy) {\n        GapPenalty gapPenalty = getGapPenalty();\n        short min = (short) (Short.MIN_VALUE - gapPenalty.getOpenPenalty() - gapPenalty.getExtensionPenalty());\n        ix[0][0] = iy[0][0] = gapPenalty.getOpenPenalty();\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = iy[x][0] = min;\n            ix[x][0] = (short) (ix[x - 1][0] + gapPenalty.getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = ix[0][y] = min;\n            iy[0][y] = (short) (iy[0][y - 1] + gapPenalty.getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) (Math.max(Math.max(scores[x - 1][y - 1], ix[x - 1][y - 1]), iy[x - 1][y - 1]) +\n                        alignScoreColumns(x, y));\n                ix[x][y] = (short) (Math.max(scores[x - 1][y] + gapPenalty.getOpenPenalty(), ix[x - 1][y]) +\n                        gapPenalty.getExtensionPenalty());\n                iy[x][y] = (short) (Math.max(scores[x][y - 1] + gapPenalty.getOpenPenalty(), iy[x][y - 1]) +\n                        gapPenalty.getExtensionPenalty());\n            }\n        }\n    }\n\n    // traces back through score matrices; chooses highroad alignment\n    @Override\n    protected void alignTracebackAffine(List<Step> sx, List<Step> sy, short[][] ix, short[][] iy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        int max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n        Last last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n        while (x > 0 || y > 0) {\n            switch (last) {\n            case IX:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() > ix[x][y]) ? Last.M : Last.IX;\n                break;\n            case M:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n                max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n                last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n                break;\n            case IY:\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() >= iy[x][y]) ? Last.M : Last.IY;\n            }\n        }\n    }\n\n    // sets output fields\n    @Override\n    protected void alignSetOutputs(List<Step> sx, List<Step> sy) {\n        score = scores[scores.length - 1][scores[0].length - 1];\n        profile = pair = new SimpleSequencePair<S, C>(getQuery(), getTarget(), sx, sy);\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 17, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class NeedlemanWunschTest {\n\n    private ProteinSequence query, target;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private NeedlemanWunsch<ProteinSequence, AminoAcidCompound> alignment, self;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        gaps = new SimpleGapPenalty((short) 10, (short) 1);\n        blosum62 = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        alignment = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, target, gaps, blosum62);\n        self = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, query, gaps, blosum62);\n    }\n\n    @Test\n    public void testNeedlemanWunsch() {\n        NeedlemanWunsch<ProteinSequence, AminoAcidCompound> nw =\n                new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>();\n        nw.setQuery(query);\n        nw.setTarget(target);\n        nw.setGapPenalty(gaps);\n        nw.setSubstitutionMatrix(blosum62);\n        assertEquals(nw.getScore(), alignment.getScore());\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(alignment.getQuery(), query);\n        assertEquals(self.getQuery(), query);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(alignment.getTarget(), target);\n        assertEquals(self.getTarget(), query);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(alignment.getGapPenalty(), gaps);\n        assertEquals(self.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(alignment.getSubstitutionMatrix(), blosum62);\n        assertEquals(self.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(alignment.isStoringScoreMatrix());\n        assertFalse(self.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        short[][] scores = alignment.getScoreMatrix();\n        assertEquals(scores[2][1], -6);\n        scores = self.getScoreMatrix();\n        assertEquals(scores[3][4], 4);\n    }\n\n    @Test\n    public void testGetScoreMatrixAsString() {\n        assertEquals(alignment.getScoreMatrixAsString(), String.format(\n                \"        R   D   G%n\" +\n                \"    0 -11 -12 -13%n\" +\n                \"A -11  -1 -12 -12%n\" +\n                \"R -12  -6  -3 -14%n\" +\n                \"N -13 -12  -5  -3%n\" +\n                \"D -14 -14  -6  -6%n\"));\n        assertEquals(self.getScoreMatrixAsString(), String.format(\n                \"        A   R   N   D%n\" +\n                \"    0 -11 -12 -13 -14%n\" +\n                \"A -11   4  -7  -8  -9%n\" +\n                \"R -12  -7   9  -2  -3%n\" +\n                \"N -13  -8  -2  15   4%n\" +\n                \"D -14  -9  -3   4  21%n\"));\n    }\n\n    @Test\n    public void testGetScoreMatrixAt() {\n        assertEquals(alignment.getScoreMatrixAt(1,1), -1);\n        assertEquals(self.getScoreMatrixAt(1,1), 4);\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(alignment.getComputationTime() > 0);\n        assertTrue(self.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(alignment.getProfile().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getProfile().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n    @Test\n    public void testGetMaxScore() {\n        assertEquals(alignment.getMaxScore(), 21);\n        assertEquals(self.getMaxScore(), 21);\n    }\n\n    @Test\n    public void testGetMinScore() {\n        assertEquals(alignment.getMinScore(), -27);\n        assertEquals(self.getMinScore(), -28);\n    }\n\n    @Test\n    public void testGetScore() {\n        assertEquals(alignment.getScore(), -6);\n        assertEquals(self.getScore(), 21);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(alignment.getPair().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getPair().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 17, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class NeedlemanWunschTest {\n\n    private ProteinSequence query, target;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private NeedlemanWunsch<ProteinSequence, AminoAcidCompound> alignment, self;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        gaps = new SimpleGapPenalty((short) 10, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        alignment = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, target, gaps, blosum62);\n        self = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, query, gaps, blosum62);\n    }\n\n    @Test\n    public void testNeedlemanWunsch() {\n        NeedlemanWunsch<ProteinSequence, AminoAcidCompound> nw =\n                new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>();\n        nw.setQuery(query);\n        nw.setTarget(target);\n        nw.setGapPenalty(gaps);\n        nw.setSubstitutionMatrix(blosum62);\n        assertEquals(nw.getScore(), alignment.getScore());\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(alignment.getQuery(), query);\n        assertEquals(self.getQuery(), query);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(alignment.getTarget(), target);\n        assertEquals(self.getTarget(), query);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(alignment.getGapPenalty(), gaps);\n        assertEquals(self.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(alignment.getSubstitutionMatrix(), blosum62);\n        assertEquals(self.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(alignment.isStoringScoreMatrix());\n        assertFalse(self.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        short[][] scores = alignment.getScoreMatrix();\n        assertEquals(scores[2][1], -6);\n        scores = self.getScoreMatrix();\n        assertEquals(scores[3][4], 4);\n    }\n\n    @Test\n    public void testGetScoreMatrixAsString() {\n        assertEquals(alignment.getScoreMatrixAsString(), String.format(\n                \"        R   D   G%n\" +\n                \"    0 -11 -12 -13%n\" +\n                \"A -11  -1 -12 -12%n\" +\n                \"R -12  -6  -3 -14%n\" +\n                \"N -13 -12  -5  -3%n\" +\n                \"D -14 -14  -6  -6%n\"));\n        assertEquals(self.getScoreMatrixAsString(), String.format(\n                \"        A   R   N   D%n\" +\n                \"    0 -11 -12 -13 -14%n\" +\n                \"A -11   4  -7  -8  -9%n\" +\n                \"R -12  -7   9  -2  -3%n\" +\n                \"N -13  -8  -2  15   4%n\" +\n                \"D -14  -9  -3   4  21%n\"));\n    }\n\n    @Test\n    public void testGetScoreMatrixAt() {\n        assertEquals(alignment.getScoreMatrixAt(1,1), -1);\n        assertEquals(self.getScoreMatrixAt(1,1), 4);\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(alignment.getComputationTime() > 0);\n        assertTrue(self.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(alignment.getProfile().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getProfile().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n    @Test\n    public void testGetMaxScore() {\n        assertEquals(alignment.getMaxScore(), 21);\n        assertEquals(self.getMaxScore(), 21);\n    }\n\n    @Test\n    public void testGetMinScore() {\n        assertEquals(alignment.getMinScore(), -27);\n        assertEquals(self.getMinScore(), -28);\n    }\n\n    @Test\n    public void testGetScore() {\n        assertEquals(alignment.getScore(), -6);\n        assertEquals(self.getScore(), 21);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(alignment.getPair().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getPair().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n}\n","commitMessage":"refactored aligners\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8071 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"updated tests to use SubstitutionMatrixHelper\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8144 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}