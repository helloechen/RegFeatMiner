{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/UnitQuaternions.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestUnitQuaternions.java","prod_time":"2016-08-05 20:52:04","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f85ce2cd07a3118590f6ba97eea338247591ca14","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\n\nimport org.biojava.nbio.structure.jama.EigenvalueDecomposition;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * UnitQuaternions is a static Class that contains methods for calculating and\n * using unit quaternions. It assumes the use of {@link Quat4d} Class from\n * vecmath to represent the unit quaternions, and it also implements some of the\n * basic methods that the library is missing.\n * <p>\n * A Unit Quaternion is a four-dimensional vector used to describe a\n * three-dimensional attitude representation (axis and angle of rotation). By\n * definition, unit quaternions are always normalized, so their length is always\n * 1.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class UnitQuaternions {\n\n\t/** Prevent instantiation */\n\tprivate UnitQuaternions() {\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing the quaternion\n\t * orientations of the principal axes of each set of points in 3D.\n\t * <p>\n\t * First, the quaternion orientation of each set of points is calculated\n\t * using their principal axes with {@link #orientation(Point3d[])}. Then,\n\t * the two quaternions are compared using the method\n\t * {@link #orientationMetric(Quat4d, Quat4d)}.\n\t * <p>\n\t * A requisite for this method to work properly is that both sets of points\n\t * have to define the same shape (or very low RMSD), otherwise some of the\n\t * principal axes might change or be inverted, resulting in an unreliable\n\t * metric. For shapes with some deviations in their shape, use the metric\n\t * {@link #orientationAngle(Point3d[], Point3d[])}.\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Point3d[] a, Point3d[] b) {\n\n\t\tQuat4d qa = orientation(a);\n\t\tQuat4d qb = orientation(b);\n\n\t\treturn orientationMetric(qa, qb);\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing two unit quaternion\n\t * orientations.\n\t * <p>\n\t * The two quaternions are compared using the formula: d(q1,q2) =\n\t * arccos(|q1*q2|). The range of the metric is [0, Pi/2], where 0 means the\n\t * same orientation and Pi/2 means the opposite orientation.\n\t * <p>\n\t * The formula is taken from: Huynh, D. Q. (2009). Metrics for 3D rotations:\n\t * comparison and analysis. Journal of Mathematical Imaging and Vision,\n\t * 35(2), 155–164. http://doi.org/10.1007/s10851-009-0161-2\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Quat4d q1, Quat4d q2) {\n\t\treturn Math.acos(Math.abs(dotProduct(q1, q2)));\n\t}\n\n\t/**\n\t * The orientation represents the rotation of the principal axes with\n\t * respect to the axes of the coordinate system (unit vectors [1,0,0],\n\t * [0,1,0] and [0,0,1]).\n\t * <p>\n\t * The orientation can be expressed as a unit quaternion.\n\t * \n\t * @param points\n\t *            array of Point3d\n\t * @return the orientation of the point cloud as a unit quaternion\n\t */\n\tpublic static Quat4d orientation(Point3d[] points) {\n\n\t\tMomentsOfInertia moi = new MomentsOfInertia();\n\n\t\tfor (Point3d p : points)\n\t\t\tmoi.addPoint(p, 1.0);\n\n\t\t// Convert rotation matrix to quaternion\n\t\tQuat4d quat = new Quat4d();\n\t\tquat.set(moi.getOrientationMatrix());\n\n\t\treturn quat;\n\t}\n\n\t/**\n\t * Calculate the rotation angle component of the input unit quaternion.\n\t * \n\t * @param q\n\t *            unit quaternion Quat4d\n\t * @return the angle in radians of the input quaternion\n\t */\n\tpublic static double angle(Quat4d q) {\n\t\tAxisAngle4d axis = new AxisAngle4d();\n\t\taxis.set(q);\n\t\treturn axis.angle;\n\t}\n\n\t/**\n\t * The angle of the relative orientation of the two sets of points in 3D.\n\t * Equivalent to {@link #angle(Quat4d)} of the unit quaternion obtained by\n\t * {@link #relativeOrientation(Point3d[], Point3d[])}\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the angle in radians of the relative orientation of the points\n\t */\n\tpublic static double orientationAngle(Point3d[] a, Point3d[] b) {\n\t\tQuat4d q = relativeOrientation(a, b);\n\t\treturn angle(q);\n\t}\n\n\t/**\n\t * Calculate the relative quaternion orientation of two arrays of points.\n\t * \n\t * @param a\n\t *            point array\n\t * @param b\n\t *            point array\n\t * @return a unit quaternion representing the relative orientation\n\t */\n\tpublic static Quat4d relativeOrientation(Point3d[] a, Point3d[] b) {\n\t\tMatrix m = CalcPoint.formMatrix(a, b);\n\t\tEigenvalueDecomposition eig = m.eig();\n\t\tdouble[][] v = eig.getV().getArray();\n\t\tQuat4d q = new Quat4d(v[1][3], v[2][3], v[3][3], v[0][3]);\n\t\tq.normalize();\n\t\tq.conjugate();\n\t\treturn q;\n\t}\n\n\t/**\n\t * Compute the dot (inner) product of two quaternions.\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the value of the quaternion dot product\n\t */\n\tpublic static double dotProduct(Quat4d q1, Quat4d q2) {\n\t\treturn q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\n\t}\n\n}\n","changedPro":"package org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\n\nimport org.biojava.nbio.structure.jama.EigenvalueDecomposition;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * UnitQuaternions is a static Class that contains methods for calculating and\n * using unit quaternions. It assumes the use of {@link Quat4d} Class from\n * vecmath to represent the unit quaternions, and it also implements some of the\n * basic methods that the library is missing.\n * <p>\n * A Unit Quaternion is a four-dimensional vector used to describe a\n * three-dimensional attitude representation (axis and angle of rotation). By\n * definition, unit quaternions are always normalized, so their length is always\n * 1.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class UnitQuaternions {\n\n\t/** Prevent instantiation */\n\tprivate UnitQuaternions() {\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing the quaternion\n\t * orientations of the principal axes of each set of points in 3D.\n\t * <p>\n\t * First, the quaternion orientation of each set of points is calculated\n\t * using their principal axes with {@link #orientation(Point3d[])}. Then,\n\t * the two quaternions are compared using the method\n\t * {@link #orientationMetric(Quat4d, Quat4d)}.\n\t * <p>\n\t * A requisite for this method to work properly is that both sets of points\n\t * have to define the same shape (or very low RMSD), otherwise some of the\n\t * principal axes might change or be inverted, resulting in an unreliable\n\t * metric. For shapes with some deviations in their shape, use the metric\n\t * {@link #orientationAngle(Point3d[], Point3d[])}.\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Point3d[] a, Point3d[] b) {\n\n\t\tQuat4d qa = orientation(a);\n\t\tQuat4d qb = orientation(b);\n\n\t\treturn orientationMetric(qa, qb);\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing two unit quaternion\n\t * orientations.\n\t * <p>\n\t * The two quaternions are compared using the formula: d(q1,q2) =\n\t * arccos(|q1*q2|). The range of the metric is [0, Pi/2], where 0 means the\n\t * same orientation and Pi/2 means the opposite orientation.\n\t * <p>\n\t * The formula is taken from: Huynh, D. Q. (2009). Metrics for 3D rotations:\n\t * comparison and analysis. Journal of Mathematical Imaging and Vision,\n\t * 35(2), 155–164. http://doi.org/10.1007/s10851-009-0161-2\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Quat4d q1, Quat4d q2) {\n\t\treturn Math.acos(Math.abs(dotProduct(q1, q2)));\n\t}\n\n\t/**\n\t * The orientation represents the rotation of the principal axes with\n\t * respect to the axes of the coordinate system (unit vectors [1,0,0],\n\t * [0,1,0] and [0,0,1]).\n\t * <p>\n\t * The orientation can be expressed as a unit quaternion.\n\t * \n\t * @param points\n\t *            array of Point3d\n\t * @return the orientation of the point cloud as a unit quaternion\n\t */\n\tpublic static Quat4d orientation(Point3d[] points) {\n\n\t\tMomentsOfInertia moi = new MomentsOfInertia();\n\n\t\tfor (Point3d p : points)\n\t\t\tmoi.addPoint(p, 1.0);\n\n\t\t// Convert rotation matrix to quaternion\n\t\tQuat4d quat = new Quat4d();\n\t\tquat.set(moi.getOrientationMatrix());\n\n\t\treturn quat;\n\t}\n\n\t/**\n\t * Calculate the rotation angle component of the input unit quaternion.\n\t * \n\t * @param q\n\t *            unit quaternion Quat4d\n\t * @return the angle in radians of the input quaternion\n\t */\n\tpublic static double angle(Quat4d q) {\n\t\tAxisAngle4d axis = new AxisAngle4d();\n\t\taxis.set(q);\n\t\treturn axis.angle;\n\t}\n\n\t/**\n\t * The angle of the relative orientation of the two sets of points in 3D.\n\t * Equivalent to {@link #angle(Quat4d)} of the unit quaternion obtained by\n\t * {@link #relativeOrientation(Point3d[], Point3d[])}.\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the angle in radians of the relative orientation of the points\n\t */\n\tpublic static double orientationAngle(Point3d[] a, Point3d[] b) {\n\t\tQuat4d q = relativeOrientation(a, b);\n\t\treturn angle(q);\n\t}\n\n\t/**\n\t * Calculate the relative quaternion orientation of two arrays of points.\n\t * \n\t * @param a\n\t *            point array\n\t * @param b\n\t *            point array\n\t * @return a unit quaternion representing the relative orientation\n\t */\n\tpublic static Quat4d relativeOrientation(Point3d[] a, Point3d[] b) {\n\t\tMatrix m = CalcPoint.formMatrix(a, b);\n\t\tEigenvalueDecomposition eig = m.eig();\n\t\tdouble[][] v = eig.getV().getArray();\n\t\tQuat4d q = new Quat4d(v[1][3], v[2][3], v[3][3], v[0][3]);\n\t\tq.normalize();\n\t\tq.conjugate();\n\t\treturn q;\n\t}\n\n\t/**\n\t * Compute the dot (inner) product of two quaternions.\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the value of the quaternion dot product\n\t */\n\tpublic static double dotProduct(Quat4d q1, Quat4d q2) {\n\t\treturn q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\n\t}\n\n}\n","originTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\n\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.geometry.UnitQuaternions;\nimport org.junit.Test;\n\n/**\n * Test the methods in the {@link UnitQuaternions} class.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestUnitQuaternions {\n\n\t/**\n\t * Test {@link UnitQuaternions#orientation(javax.vecmath.Point3d[])}.\n\t * <p>\n\t * Tests the identity orientation, orientation around one coordinate axis\n\t * and orientation around a non-coordinate axis.\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testOrientation() throws IOException, StructureException {\n\n\t\t// Get points from a structure. It is difficult to generate points\n\t\t// with no bias in their distribution (too uniform, ie).\n\t\tStructure pdb = StructureIO.getStructure(\"4hhb.A\");\n\t\tPoint3d[] cloud = Calc.atomsToPoints(StructureTools\n\t\t\t\t.getRepresentativeAtomArray(pdb));\n\n\t\t// Center the cloud at the origin\n\t\tCalcPoint.center(cloud);\n\n\t\t// Orient its principal axes to the coordinate axis\n\t\tQuat4d orientation = UnitQuaternions.orientation(cloud);\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.set(orientation);\n\t\ttransform.invert();\n\t\tCalcPoint.transform(transform, cloud);\n\n\t\t// The orientation found now should be 0 (it has been re-oriented)\n\t\torientation = UnitQuaternions.orientation(cloud);\n\t\tAxisAngle4d axis = new AxisAngle4d();\n\t\taxis.set(orientation);\n\n\t\t// No significant rotation\n\t\tassertEquals(orientation.x, 0.0, 0.01);\n\t\tassertEquals(orientation.y, 0.0, 0.01);\n\t\tassertEquals(orientation.z, 0.0, 0.01);\n\t\tassertEquals(axis.angle, 0.0, 0.01);\n\n\t\t// Now try to recover an orientation\n\t\tQuat4d quat = new Quat4d(0.418, 0.606, 0.303, 0.606);\n\n\t\tMatrix4d mat = new Matrix4d();\n\t\tmat.set(quat);\n\n\t\tCalcPoint.transform(mat, cloud);\n\n\t\torientation = UnitQuaternions.orientation(cloud);\n\n\t\t// Test recovering the quaternion (q and -q same rotation)\n\t\tassertEquals(Math.abs(orientation.x), quat.x, 0.01);\n\t\tassertEquals(Math.abs(orientation.y), quat.y, 0.01);\n\t\tassertEquals(Math.abs(orientation.z), quat.z, 0.01);\n\t\tassertEquals(Math.abs(orientation.w), quat.w, 0.01);\n\t}\n\n\t/**\n\t * Test {@link UnitQuaternions#orientationMetric(Point3d[], Point3d[])}.\n\t * <p>\n\t * Tests the range of values of the metric with a perfect correlation,\n\t * perfect anticorrelation and intermediate values.\n\t */\n\t@Test\n\tpublic void testOrientationMetricRange() {\n\n\t\t// no rotation quaternion\n\t\tQuat4d qa = new Quat4d(0, 0, 0, 1);\n\t\tQuat4d qb = new Quat4d(qa);\n\n\t\t// Two equal quaternions produce the minimum score of 0\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), 0, 0.01);\n\n\t\t// 90 degrees rotation over x\n\t\tqa = new Quat4d(0.707, 0, 0, 0.707);\n\n\t\t// 270 degrees rotation over x\n\t\tqb = new Quat4d(0.707, 0, 0, -0.707);\n\n\t\t// two quaternions with 180 degree axis produce the max score Pi / 2\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 2,\n\t\t\t\t0.01);\n\n\t\t// 90 degrees rotation over y\n\t\tqb = new Quat4d(0, 0.707, 0, 0.707);\n\n\t\t// two quaternions with 90 degree axis produce the score Pi / 4\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3,\n\t\t\t\t0.01);\n\n\t\t// two quaternions with 45 degree axis produce the score Pi / 8\n\t\tqb = new Quat4d(0.383, 0, 0, 0.924);\n\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 8,\n\t\t\t\t0.01);\n\n\t\t// 90 degrees rotation over x in negative\n\t\tqb = new Quat4d(0, -0.707, 0, -0.707);\n\n\t\t// assert no negative angles are returned\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3,\n\t\t\t\t0.01);\n\n\t}\n\n\t/**\n\t * Test {@link UnitQuaternions#orientationMetric(Point3d[], Point3d[])} on a\n\t * real structure, which will be deviating a little bit every time.\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testOrientationMetricIncrement() throws IOException,\n\t\t\tStructureException {\n\t\t\n\t\t// The rotation increment will be Pi/10, Pi/15 and Pi/12 degrees in X,Y and Z\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.rotX(Math.PI / 10);\n\t\ttransform.rotY(Math.PI / 12);\n\t\ttransform.rotZ(Math.PI / 15);\n\n\t\t// Get points from a structure.\n\t\tStructure pdb = StructureIO.getStructure(\"4hhb.A\");\n\t\tPoint3d[] cloud = Calc.atomsToPoints(StructureTools\n\t\t\t\t.getRepresentativeAtomArray(pdb));\n\t\tPoint3d[] cloud2 = CalcPoint.clonePoint3dArray(cloud);\n\n\t\t// Center the clouds at the origin\n\t\tCalcPoint.center(cloud);\n\t\tCalcPoint.center(cloud2);\n\n\t\t// Their orientation is equal at this stage\n\t\tdouble m0 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertEquals(m0, 0.0, 0.001);\n\t\t\n\t\t// Assert it keeps incrementing every time transform is applied\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m1 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m1 > m0);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m2 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m2 > m1);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m3 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m3 > m2);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m4 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m4 > m3);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m5 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m5 > m4);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m6 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m6 > m5);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m7 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m7 > m6);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m8 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m8 > m7);\n\t\t\n\t\tCalcPoint.transform(transform, cloud2);\n\t\tdouble m9 = UnitQuaternions.orientationMetric(cloud, cloud2);\n\t\tassertTrue(m9 > m8);\n\t}\n\n}\n","changedTest":"","commitMessage":"Introduce comparison by RMSD and orientation angle in QsAlign","test_commitMessage":"","allZero":true}