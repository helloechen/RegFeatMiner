{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/client/StructureName.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/client/TestStructureName.java","prod_time":"2016-03-02 04:22:15","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"2f61673967c790755692c838ac1c1a9a1c4b7cd1","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.client;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.PassthroughIdentifier;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.URLIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPDomain;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** \n * A utility class that makes working with names of structures, domains and ranges easier.\n * \n * Accepts a wide range of identifier formats, including {@link ScopDomain},\n * {@link CathDomain}, PDP domains, and {@link SubstructureIdentifier} residue\n * ranges.\n * \n * Where possible, data is extracted from the input string. Otherwise, range \n * information may be loaded from one of the factory classes:\n * {@link CathFactory},{@link ScopFactory}, etc.\n * \n * @see #getName the name. e.g. 4hhb, 4hhb.A, d4hhba_, PDP:4HHBAa etc.\n */\n\npublic class StructureName implements Comparable<StructureName>, Serializable, StructureIdentifier {\n\tprivate static final long serialVersionUID = 4021229518711762957L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureName.class);\n\n\tprotected String name;\n\tprotected String pdbId;\n\tprotected String chainId;\n\n\tprivate static final Pattern cathPattern = Pattern.compile(\"^([0-9][a-z0-9]{3})(\\\\w)([0-9]{2})$\",Pattern.CASE_INSENSITIVE);\n\t// ds046__ is a special case with no PDB entry\n\tprivate static final Pattern scopPattern = Pattern.compile(\"^d([0-9][a-z0-9]{3}|s046)(\\\\w|\\\\.)(\\\\w)$\",Pattern.CASE_INSENSITIVE);\n\t// ECOD chains and domains can't be automatically distinguished. Ex: e3j9zS13 is chain 'S1', e1wz2B14 is chain 'B'\n\tprivate static final Pattern ecodPattern = Pattern.compile(\"^e([0-9][a-zA-Z0-9]{3})(?:\\\\w|\\\\.)\\\\w+$\",Pattern.CASE_INSENSITIVE);\n\n\tprivate enum Source {\n\t\tPDB,\n\t\tSCOP,\n\t\tPDP,\n\t\tCATH,\n\t\tURL,\n\t\tFILE,\n\t\tECOD,\n\t};\n\n\tprivate Source mySource = null; \n\n\t// cache for realize() method\n\tprivate StructureIdentifier realized = null;\n\t\n\t/**\n\t * Create a new StructureName from the given identifier, which may be a \n\t * domain name, a substructure identifier, etc.\n\t * \n\t * The source and PDB-Id are extracted at compile time, but fully\n\t * interpreting the ID, which may require additional parsing or remote\n\t * calls, is done lazily.\n\t * @param name An identifier string\n\t * @throws IllegalArgumentException if the name has a recognizable source but is semantically invalid\n\t */\n\tpublic StructureName(String name){\n\t\tthis.name = name;\n\n\t\tinit();//sets pdbId and mySource\n\t}\n\n\n\t/**\n\t * Tries to determine the source and pdbId without fully realizing the identifier,\n\t * which could require I/O depending on the source\n\t * @throws IllegalArgumentException if the source is recognizable but invalid\n\t */\n\tprivate void init(){\n\t\t// SCOP domain\n\t\tMatcher matcher = scopPattern.matcher(name);\n\t\tif ( matcher.matches() ) {\n\t\t\tmySource = Source.SCOP;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// PDP\n\t\tif ( name.startsWith(AtomCache.PDP_DOMAIN_IDENTIFIER)){\n\t\t\t// starts with PDP:\n\t\t\t// eg: PDP:3LGFAa\n\t\t\tmySource = Source.PDP;\n\t\t\tmatcher = PDPDomain.PDP_NAME_PATTERN.matcher(name);\n\t\t\tif(! matcher.matches() ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Malformed PDP domain name\");\n\t\t\t}\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// CATH\n\t\tmatcher = cathPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.CATH;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// ECOD\n\t\tmatcher = ecodPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.ECOD;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t}\n\t\t// URL\n\t\ttry {\n\t\t\tURL url = new URL(name);\n\t\t\tmySource = Source.URL;\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = URLIdentifier.guessPDBID( path.substring(path.lastIndexOf('/')+1) );\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t} catch(MalformedURLException e) {}\n\t\t// File\n\t\tFile file = new File(FileDownloadUtils.expandUserHome(name));\n\t\tif( file.canRead() && !file.isDirectory() ) {\n\t\t\tmySource = Source.FILE;\n\t\t\tpdbId = null;\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Default to PDB\n\t\tmySource = Source.PDB;\n\t\tSubstructureIdentifier si = new SubstructureIdentifier(getIdentifier());\n\t\trealized = si; // Safe to realize immediately\n\n\t\tpdbId = si.getPdbId();\n\t\t// Set chainId if unique\n\t\tSet<String> chains = getChainIds(si);\n\t\tif(chains.size() == 1) {\n\t\t\tthis.chainId = chains.iterator().next();\n\t\t} else if(chains.size() > 1) {\n\t\t\tthis.chainId = \".\";\n\t\t} else {\n\t\t\tthis.chainId = null;\n\t\t}\n\t}\n\n\tprivate static Set<String> getChainIds(SubstructureIdentifier si) {\n\t\tSet<String> chains = new TreeSet<String>();\n\t\tList<ResidueRange> ranges = si.getResidueRanges();\n\t\tfor(ResidueRange range : ranges) {\n\t\t\tString chain = range.getChainId();\n\t\t\tif(chain != null) {\n\t\t\t\tchains.add(chain);\n\t\t\t}\n\t\t}\n\t\treturn chains;\n\t}\n\n\t/**\n\t * Get the PDB ID for this name, if any.\n\t * \n\t * Equivalent to {@link SubstructureIdentifier#getPdbId()\n\t * toCanonical().getPdbId()}\n\t * @return The upper-case PDB Name, or null if not applicable\n\t * @throws StructureException Wraps errors which occur when converting to canonical form\n\t */\n\tpublic String getPdbId() throws StructureException {\n\t\tif( pdbId == null) {\n\t\t\tpdbId = toCanonical().getPdbId();\n\t\t}\n\t\treturn pdbId.toUpperCase();\n\t}\n\n\t/**\n\t * Gets the chain ID, for structures where it is unique and well-defined.\n\t * May return '.' for multi-chain ranges, '_' for wildcard chains, or\n\t * null if the information is unavailable.\n\t * \n\t * <p>This method should only be used casually. For precise chainIds, it\n\t * is better to use {@link #toCanonical()} and iterate through the\n\t * residue ranges.\n\t * @return\n\t */\n\tpublic String getChainId() {\n\t\treturn chainId;\n\t}\n\t/**\n\t * \n\t * @return the identifier string\n\t * @deprecated use {@link #getIdentifier()}\n\t */\n\t@Deprecated\n\tpublic String getName(){\n\n\t\treturn getIdentifier();\n\t}\n\n\t/**\n\t * Get the original form of the identifier\n\t */\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString(){\n\n\t\treturn name;\n\t}\n\n\n\tpublic boolean isScopName() {\n\t\treturn mySource == Source.SCOP;\n\t}\n\n\tpublic boolean isPDPDomain(){\n\t\treturn mySource == Source.PDP;\n\t}\n\n\tpublic boolean isCathID(){\n\t\treturn mySource == Source.CATH;\n\t}\n\n\tpublic boolean isPdbId(){\n\t\treturn mySource == Source.PDB;\n\t}\n\n\tpublic boolean isURL() {\n\t\treturn mySource == Source.URL;\n\t}\n\n\tpublic boolean isFile() {\n\t\treturn mySource == Source.FILE;\n\t}\n\t\n\tpublic boolean isEcodDomain() {\n\t\treturn mySource == Source.ECOD;\n\t}\n\n\t/**\n\t * \n\t * @return\n\t * @throws StructureException Wraps exceptions that may be thrown by\n\t *  individual implementations. For example, a SCOP identifier may require\n\t *  that the domain definitions be available for download.\n\t */\n\tprivate StructureIdentifier realize() throws StructureException {\n\t\tif( realized == null ) {\n\n\t\t\tswitch(mySource) {\n\t\t\tcase CATH:\n\t\t\t\trealized = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tcase ECOD:\n\t\t\t\ttry {\n\t\t\t\t\trealized = EcodFactory.getEcodDatabase().getDomainsById(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to get ECOD domain \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCOP:\n\t\t\t\t// Fuzzy matching of the domain name to the current default factory\n\t\t\t\trealized = guessScopDomain(getIdentifier(),ScopFactory.getSCOP());\n\t\t\t\tif(realized == null) {\n\t\t\t\t\t// Guessing didn't work, so just use the PDBID and Chain from name\n\t\t\t\t\t// Guess that '_' means 'whole structure'\n\t\t\t\t\tif (chainId.equals(\"_\")) {\n\t\t\t\t\t\trealized = new SubstructureIdentifier(pdbId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trealized = new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));\n\t\t\t\t\t}\n\t\t\t\t\tlogger.error(\"Unable to find {}, so using {}\",name,realized);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FILE:\n\t\t\t\ttry {\n\t\t\t\t\trealized = new URLIdentifier(new File(FileDownloadUtils.expandUserHome(name)).toURI().toURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t// Should never happen\n\t\t\t\t\tthrow new StructureException(\"Unable to get URL for file: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URL:\n\t\t\t\ttry {\n\t\t\t\t\trealized = new URLIdentifier(name);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new StructureException(\"Invalid URL: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDP:\n\t\t\t\t//TODO -sbliven 2015-01-28\n\t\t\t\ttry {\n\t\t\t\t\tPDPProvider provider = new RemotePDPProvider(false);\n\t\t\t\t\trealized = provider.getPDPDomain(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to fetch PDP domain \"+name, e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDB:\n\t\t\t\trealized = new SubstructureIdentifier(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trealized = new PassthroughIdentifier(name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn realized;\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException {\n\t\treturn realize().toCanonical();\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn realize().reduce(input);\n\t}\n\t\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\t\t\tIOException {\n\t\treturn realize().loadStructure(cache);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tStructureName other = (StructureName) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Orders identifiers lexicographically by PDB ID and then full Identifier\n\t */\n\t@Override\n\tpublic int compareTo(StructureName o) {\n\t\tif ( this.equals(o))\n\t\t\treturn 0;\n\n\t\tString pdb1 = null;\n\t\tString pdb2 = null;\n\t\ttry {\n\t\t\tpdb1 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\t\ttry {\n\t\t\tpdb2 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\n\t\tint comp = 0;\n\n\t\t// Sort those with PDBIDs before those without\n\t\tif( pdb1 == null ) {\n\t\t\tif( pdb2 != null) {\n\t\t\t\treturn 1; // this > o\n\t\t\t}\n\t\t\t// both null\n\t\t} else if( pdb2 == null){\n\t\t\treturn -1; // this < o\n\t\t} else {\n\t\t\t// neither null\n\t\t\tcomp = pdb1.compareTo(pdb2);\n\t\t}\n\t\tif( comp != 0 ) {\n\t\t\treturn comp;\n\t\t}\n\n\t\t// break tie with full identifiers\n\t\tpdb1 = this.getIdentifier();\n\t\tpdb2 = o.getIdentifier();\n\n\t\t// Throws NPE for nulls\n\t\treturn pdb1.compareTo(pdb2);\n\t}\n\t\n\t/**\n\t * <p>\n\t * Guess a scop domain. If an exact match is found, return that.\n\t * \n\t * <p>\n\t * Otherwise, return the first scop domain found for the specified protein such that\n\t * <ul>\n\t * <li>The chains match, or one of the chains is '_' or '.'.\n\t * <li>The domains match, or one of the domains is '_'.\n\t * </ul>\n\t * \n\t * In some cases there may be several valid matches. In this case a warning\n\t * will be logged.\n\t * \n\t * @param name SCOP domain name, or a guess thereof\n\t * @param scopDB SCOP domain provider\n\t * @return The best match for name among the domains of scopDB, or null if none match.\n\t */\n\tpublic static ScopDomain guessScopDomain(String name, ScopDatabase scopDB) {\n\t\tList<ScopDomain> matches = new LinkedList<ScopDomain>();\n\n\t\t// Try exact match first\n\t\tScopDomain domain = scopDB.getDomainByScopID(name);\n\t\tif (domain != null) {\n\t\t\treturn domain;\n\t\t}\n\n\t\t// Didn't work. Guess it!\n\t\tlogger.warn(\"Warning, could not find SCOP domain: \" + name);\n\n\t\tMatcher scopMatch = scopPattern.matcher(name);\n\t\tif (scopMatch.matches()) {\n\t\t\tString pdbID = scopMatch.group(1);\n\t\t\tString chainID = scopMatch.group(2);\n\t\t\tString domainID = scopMatch.group(3);\n\n\t\t\tfor (ScopDomain potentialSCOP : scopDB.getDomainsForPDB(pdbID)) {\n\t\t\t\tMatcher potMatch = scopPattern.matcher(potentialSCOP.getScopId());\n\t\t\t\tif (potMatch.matches()) {\n\t\t\t\t\tif (chainID.equals(potMatch.group(2)) || chainID.equals(\"_\") || chainID.equals(\".\")\n\t\t\t\t\t\t\t|| potMatch.group(2).equals(\"_\") || potMatch.group(2).equals(\".\")) {\n\t\t\t\t\t\tif (domainID.equals(potMatch.group(3)) || domainID.equals(\"_\") || potMatch.group(3).equals(\"_\")) {\n\t\t\t\t\t\t\t// Match, or near match\n\t\t\t\t\t\t\tmatches.add(potentialSCOP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tIterator<ScopDomain> match = matches.iterator();\n\t\tif (match.hasNext()) {\n\t\t\tScopDomain bestMatch = match.next();\n\t\t\tif(logger.isWarnEnabled()) {\n\t\t\t\tStringBuilder warnMsg = new StringBuilder();\n\t\t\t\twarnMsg.append(\"Trying domain \" + bestMatch.getScopId() + \".\");\n\t\t\t\tif (match.hasNext()) {\n\t\t\t\t\twarnMsg.append(\" Other possibilities: \");\n\t\t\t\t\twhile (match.hasNext()) {\n\t\t\t\t\t\twarnMsg.append(match.next().getScopId() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twarnMsg.append(System.getProperty(\"line.separator\"));\n\t\t\t\tlogger.warn(warnMsg.toString());\n\t\t\t}\n\t\t\treturn bestMatch;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t\n\t\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.client;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.PassthroughIdentifier;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.URLIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPDomain;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** \n * A utility class that makes working with names of structures, domains and ranges easier.\n * \n * Accepts a wide range of identifier formats, including {@link ScopDomain},\n * {@link CathDomain}, PDP domains, and {@link SubstructureIdentifier} residue\n * ranges.\n * \n * Where possible, data is extracted from the input string. Otherwise, range \n * information may be loaded from one of the factory classes:\n * {@link CathFactory},{@link ScopFactory}, etc.\n * \n * @see #getName the name. e.g. 4hhb, 4hhb.A, d4hhba_, PDP:4HHBAa etc.\n */\n\npublic class StructureName implements Comparable<StructureName>, Serializable, StructureIdentifier {\n\tprivate static final long serialVersionUID = 4021229518711762957L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureName.class);\n\n\tprotected String name;\n\tprotected String pdbId;\n\tprotected String chainId;\n\n\tprivate static final Pattern cathPattern = Pattern.compile(\"^([0-9][a-z0-9]{3})(\\\\w)([0-9]{2})$\",Pattern.CASE_INSENSITIVE);\n\t// ds046__ is a special case with no PDB entry\n\tprivate static final Pattern scopPattern = Pattern.compile(\"^d([0-9][a-z0-9]{3}|s046)(\\\\w|\\\\.)(\\\\w)$\",Pattern.CASE_INSENSITIVE);\n\t// ECOD chains and domains can't be automatically distinguished. Ex: e3j9zS13 is chain 'S1', e1wz2B14 is chain 'B'\n\tprivate static final Pattern ecodPattern = Pattern.compile(\"^e([0-9][a-zA-Z0-9]{3})(?:\\\\w|\\\\.)\\\\w+$\",Pattern.CASE_INSENSITIVE);\n\n\tprivate enum Source {\n\t\tPDB,\n\t\tSCOP,\n\t\tPDP,\n\t\tCATH,\n\t\tURL,\n\t\tFILE,\n\t\tECOD,\n\t};\n\n\tprivate Source mySource = null; \n\n\t// cache for realize() method\n\tprivate StructureIdentifier realized = null;\n\t\n\t/**\n\t * Create a new StructureName from the given identifier, which may be a \n\t * domain name, a substructure identifier, etc.\n\t * \n\t * The source and PDB-Id are extracted at compile time, but fully\n\t * interpreting the ID, which may require additional parsing or remote\n\t * calls, is done lazily.\n\t * @param name An identifier string\n\t * @throws IllegalArgumentException if the name has a recognizable source but is semantically invalid\n\t */\n\tpublic StructureName(String name){\n\t\tthis.name = name;\n\n\t\tinit();//sets pdbId and mySource\n\t}\n\n\n\t/**\n\t * Tries to determine the source and pdbId without fully realizing the identifier,\n\t * which could require I/O depending on the source\n\t * @throws IllegalArgumentException if the source is recognizable but invalid\n\t */\n\tprivate void init(){\n\t\t// SCOP domain\n\t\tMatcher matcher = scopPattern.matcher(name);\n\t\tif ( matcher.matches() ) {\n\t\t\tmySource = Source.SCOP;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// PDP\n\t\tif ( name.startsWith(AtomCache.PDP_DOMAIN_IDENTIFIER)){\n\t\t\t// starts with PDP:\n\t\t\t// eg: PDP:3LGFAa\n\t\t\tmySource = Source.PDP;\n\t\t\tmatcher = PDPDomain.PDP_NAME_PATTERN.matcher(name);\n\t\t\tif(! matcher.matches() ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Malformed PDP domain name\");\n\t\t\t}\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// CATH\n\t\tmatcher = cathPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.CATH;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// ECOD\n\t\tmatcher = ecodPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.ECOD;\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t}\n\t\t// URL\n\t\ttry {\n\t\t\tURL url = new URL(name);\n\t\t\tmySource = Source.URL;\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = URLIdentifier.guessPDBID( path.substring(path.lastIndexOf('/')+1) );\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t} catch(MalformedURLException e) {}\n\t\t// File\n\t\tFile file = new File(FileDownloadUtils.expandUserHome(name));\n\t\tif( file.canRead() && !file.isDirectory() ) {\n\t\t\t// an attempt to mitigate issue #398. It doesn't fix it but it catches the most common case of passing a pdb id and finding a file in working dir matching it\n\t\t\tif (name.matches(\"\\\\d\\\\w\\\\w\\\\w\")) {\n\t\t\t\t// the plain pdb id case, this is unlikely to be what the user wants: let's let it through but warn about it\n\t\t\t\tlogger.warn(\"Provided 4-letter structure name '{}' matches file name in directory {}. Will read structure data from file {} and not consider the name as a structure identifier. If this is not what you want remove the file from the directory.\", name, file.getAbsoluteFile().getParent(), file.getAbsolutePath());\n\t\t\t} else {\n\t\t\t\tlogger.info(\"Provided structure name '{}' matches file name in directory {}. Will read structure data from file {}.\", name, file.getAbsoluteFile().getParent(), file.getAbsolutePath());\n\t\t\t}\n\t\t\tmySource = Source.FILE;\n\t\t\tpdbId = null;\n\t\t\tchainId = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Default to PDB\n\t\tmySource = Source.PDB;\n\t\tSubstructureIdentifier si = new SubstructureIdentifier(getIdentifier());\n\t\trealized = si; // Safe to realize immediately\n\n\t\tpdbId = si.getPdbId();\n\t\t// Set chainId if unique\n\t\tSet<String> chains = getChainIds(si);\n\t\tif(chains.size() == 1) {\n\t\t\tthis.chainId = chains.iterator().next();\n\t\t} else if(chains.size() > 1) {\n\t\t\tthis.chainId = \".\";\n\t\t} else {\n\t\t\tthis.chainId = null;\n\t\t}\n\t}\n\n\tprivate static Set<String> getChainIds(SubstructureIdentifier si) {\n\t\tSet<String> chains = new TreeSet<String>();\n\t\tList<ResidueRange> ranges = si.getResidueRanges();\n\t\tfor(ResidueRange range : ranges) {\n\t\t\tString chain = range.getChainId();\n\t\t\tif(chain != null) {\n\t\t\t\tchains.add(chain);\n\t\t\t}\n\t\t}\n\t\treturn chains;\n\t}\n\n\t/**\n\t * Get the PDB ID for this name, if any.\n\t * \n\t * Equivalent to {@link SubstructureIdentifier#getPdbId()\n\t * toCanonical().getPdbId()}\n\t * @return The upper-case PDB Name, or null if not applicable\n\t * @throws StructureException Wraps errors which occur when converting to canonical form\n\t */\n\tpublic String getPdbId() throws StructureException {\n\t\tif( pdbId == null) {\n\t\t\tpdbId = toCanonical().getPdbId();\n\t\t}\n\t\treturn pdbId.toUpperCase();\n\t}\n\n\t/**\n\t * Gets the chain ID, for structures where it is unique and well-defined.\n\t * May return '.' for multi-chain ranges, '_' for wildcard chains, or\n\t * null if the information is unavailable.\n\t * \n\t * <p>This method should only be used casually. For precise chainIds, it\n\t * is better to use {@link #toCanonical()} and iterate through the\n\t * residue ranges.\n\t * @return\n\t */\n\tpublic String getChainId() {\n\t\treturn chainId;\n\t}\n\t/**\n\t * \n\t * @return the identifier string\n\t * @deprecated use {@link #getIdentifier()}\n\t */\n\t@Deprecated\n\tpublic String getName(){\n\n\t\treturn getIdentifier();\n\t}\n\n\t/**\n\t * Get the original form of the identifier\n\t */\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString(){\n\n\t\treturn name;\n\t}\n\n\n\tpublic boolean isScopName() {\n\t\treturn mySource == Source.SCOP;\n\t}\n\n\tpublic boolean isPDPDomain(){\n\t\treturn mySource == Source.PDP;\n\t}\n\n\tpublic boolean isCathID(){\n\t\treturn mySource == Source.CATH;\n\t}\n\n\tpublic boolean isPdbId(){\n\t\treturn mySource == Source.PDB;\n\t}\n\n\tpublic boolean isURL() {\n\t\treturn mySource == Source.URL;\n\t}\n\n\tpublic boolean isFile() {\n\t\treturn mySource == Source.FILE;\n\t}\n\t\n\tpublic boolean isEcodDomain() {\n\t\treturn mySource == Source.ECOD;\n\t}\n\n\t/**\n\t * \n\t * @return\n\t * @throws StructureException Wraps exceptions that may be thrown by\n\t *  individual implementations. For example, a SCOP identifier may require\n\t *  that the domain definitions be available for download.\n\t */\n\tprivate StructureIdentifier realize() throws StructureException {\n\t\tif( realized == null ) {\n\n\t\t\tswitch(mySource) {\n\t\t\tcase CATH:\n\t\t\t\trealized = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tcase ECOD:\n\t\t\t\ttry {\n\t\t\t\t\trealized = EcodFactory.getEcodDatabase().getDomainsById(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to get ECOD domain \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCOP:\n\t\t\t\t// Fuzzy matching of the domain name to the current default factory\n\t\t\t\trealized = guessScopDomain(getIdentifier(),ScopFactory.getSCOP());\n\t\t\t\tif(realized == null) {\n\t\t\t\t\t// Guessing didn't work, so just use the PDBID and Chain from name\n\t\t\t\t\t// Guess that '_' means 'whole structure'\n\t\t\t\t\tif (chainId.equals(\"_\")) {\n\t\t\t\t\t\trealized = new SubstructureIdentifier(pdbId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\trealized = new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));\n\t\t\t\t\t}\n\t\t\t\t\tlogger.error(\"Unable to find {}, so using {}\",name,realized);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FILE:\n\t\t\t\ttry {\n\t\t\t\t\trealized = new URLIdentifier(new File(FileDownloadUtils.expandUserHome(name)).toURI().toURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t// Should never happen\n\t\t\t\t\tthrow new StructureException(\"Unable to get URL for file: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URL:\n\t\t\t\ttry {\n\t\t\t\t\trealized = new URLIdentifier(name);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new StructureException(\"Invalid URL: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDP:\n\t\t\t\t//TODO -sbliven 2015-01-28\n\t\t\t\ttry {\n\t\t\t\t\tPDPProvider provider = new RemotePDPProvider(false);\n\t\t\t\t\trealized = provider.getPDPDomain(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to fetch PDP domain \"+name, e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDB:\n\t\t\t\trealized = new SubstructureIdentifier(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trealized = new PassthroughIdentifier(name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn realized;\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException {\n\t\treturn realize().toCanonical();\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn realize().reduce(input);\n\t}\n\t\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\t\t\tIOException {\n\t\treturn realize().loadStructure(cache);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tStructureName other = (StructureName) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Orders identifiers lexicographically by PDB ID and then full Identifier\n\t */\n\t@Override\n\tpublic int compareTo(StructureName o) {\n\t\tif ( this.equals(o))\n\t\t\treturn 0;\n\n\t\tString pdb1 = null;\n\t\tString pdb2 = null;\n\t\ttry {\n\t\t\tpdb1 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\t\ttry {\n\t\t\tpdb2 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\n\t\tint comp = 0;\n\n\t\t// Sort those with PDBIDs before those without\n\t\tif( pdb1 == null ) {\n\t\t\tif( pdb2 != null) {\n\t\t\t\treturn 1; // this > o\n\t\t\t}\n\t\t\t// both null\n\t\t} else if( pdb2 == null){\n\t\t\treturn -1; // this < o\n\t\t} else {\n\t\t\t// neither null\n\t\t\tcomp = pdb1.compareTo(pdb2);\n\t\t}\n\t\tif( comp != 0 ) {\n\t\t\treturn comp;\n\t\t}\n\n\t\t// break tie with full identifiers\n\t\tpdb1 = this.getIdentifier();\n\t\tpdb2 = o.getIdentifier();\n\n\t\t// Throws NPE for nulls\n\t\treturn pdb1.compareTo(pdb2);\n\t}\n\t\n\t/**\n\t * <p>\n\t * Guess a scop domain. If an exact match is found, return that.\n\t * \n\t * <p>\n\t * Otherwise, return the first scop domain found for the specified protein such that\n\t * <ul>\n\t * <li>The chains match, or one of the chains is '_' or '.'.\n\t * <li>The domains match, or one of the domains is '_'.\n\t * </ul>\n\t * \n\t * In some cases there may be several valid matches. In this case a warning\n\t * will be logged.\n\t * \n\t * @param name SCOP domain name, or a guess thereof\n\t * @param scopDB SCOP domain provider\n\t * @return The best match for name among the domains of scopDB, or null if none match.\n\t */\n\tpublic static ScopDomain guessScopDomain(String name, ScopDatabase scopDB) {\n\t\tList<ScopDomain> matches = new LinkedList<ScopDomain>();\n\n\t\t// Try exact match first\n\t\tScopDomain domain = scopDB.getDomainByScopID(name);\n\t\tif (domain != null) {\n\t\t\treturn domain;\n\t\t}\n\n\t\t// Didn't work. Guess it!\n\t\tlogger.warn(\"Warning, could not find SCOP domain: \" + name);\n\n\t\tMatcher scopMatch = scopPattern.matcher(name);\n\t\tif (scopMatch.matches()) {\n\t\t\tString pdbID = scopMatch.group(1);\n\t\t\tString chainID = scopMatch.group(2);\n\t\t\tString domainID = scopMatch.group(3);\n\n\t\t\tfor (ScopDomain potentialSCOP : scopDB.getDomainsForPDB(pdbID)) {\n\t\t\t\tMatcher potMatch = scopPattern.matcher(potentialSCOP.getScopId());\n\t\t\t\tif (potMatch.matches()) {\n\t\t\t\t\tif (chainID.equals(potMatch.group(2)) || chainID.equals(\"_\") || chainID.equals(\".\")\n\t\t\t\t\t\t\t|| potMatch.group(2).equals(\"_\") || potMatch.group(2).equals(\".\")) {\n\t\t\t\t\t\tif (domainID.equals(potMatch.group(3)) || domainID.equals(\"_\") || potMatch.group(3).equals(\"_\")) {\n\t\t\t\t\t\t\t// Match, or near match\n\t\t\t\t\t\t\tmatches.add(potentialSCOP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tIterator<ScopDomain> match = matches.iterator();\n\t\tif (match.hasNext()) {\n\t\t\tScopDomain bestMatch = match.next();\n\t\t\tif(logger.isWarnEnabled()) {\n\t\t\t\tStringBuilder warnMsg = new StringBuilder();\n\t\t\t\twarnMsg.append(\"Trying domain \" + bestMatch.getScopId() + \".\");\n\t\t\t\tif (match.hasNext()) {\n\t\t\t\t\twarnMsg.append(\" Other possibilities: \");\n\t\t\t\t\twhile (match.hasNext()) {\n\t\t\t\t\t\twarnMsg.append(match.next().getScopId() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twarnMsg.append(System.getProperty(\"line.separator\"));\n\t\t\t\tlogger.warn(warnMsg.toString());\n\t\t\t}\n\t\t\treturn bestMatch;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t\n\t\n}\n","originTest":"package org.biojava.nbio.structure.align.client;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.junit.Test;\n\npublic class TestStructureName {\n\n\t@Test\n\tpublic void testMultiCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"4V4F.AL\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\t\t\n\t\tstr = \"4v4f.AL\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\tstr = \"4v4f.al\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"al\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\tstr = \"4v4f.ABCD\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCD\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\t// More than 4 characters should work too. In principle there's no limit in mmCIF, though the PDB is \n\t\t// restricting chain ids to 4 chars \n\t\tstr = \"4v4f.ABCDEFGHIJ\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCDEFGHIJ\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\n\t}\n\t\n\t@Test\n\tpublic void testSingleCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"1SMT.A\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"A\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\t\t\n\t\tstr = \"1SMT.a\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"a\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\n\t\t\n\t}\n\n\t@Test\n\tpublic void testFiles() throws IOException {\n\t\tFile f = new File(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(f.exists());\n\t\tassertNull(f.getParentFile());\n\t\tStructureName sn = new StructureName(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(sn.isFile());\n\t\tassertTrue(sn.isPdbId());\n\t}\n\n}\n","changedTest":"","commitMessage":"Adding some logging for #398 that mitigatest the issue","test_commitMessage":"","allZero":false}