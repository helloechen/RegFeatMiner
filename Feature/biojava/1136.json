{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/util/MultipleAlignmentScorer.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/util/TestMultipleAlignmentScorer.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Utility class for calculating common scores of {@link MultipleAlignment}s.\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentScorer {\n\n\t// Names for commonly used scores\n\tpublic static final String PROBABILITY = \"Probability\";\n\tpublic static final String CE_SCORE = \"CE-score\";\n\tpublic static final String RMSD = \"RMSD\";\n\tpublic static final String AVGTM_SCORE = \"AvgTM-score\";\n\tpublic static final String MC_SCORE = \"MC-score\";\n\tpublic static final String REF_RMSD = \"Ref-RMSD\";\n\tpublic static final String REFTM_SCORE = \"RefTM-score\";\n\n\t/**\n\t * Calculates and puts the RMSD and the average TM-Score of the\n\t * MultipleAlignment.\n\t *\n\t * @param alignment\n\t * @throws StructureException\n\t * @see #getAvgTMScore(MultipleAlignment)\n\t * @see #getRMSD(MultipleAlignment)\n\t */\n\tpublic static void calculateScores(MultipleAlignment alignment)\n\t\t\tthrows StructureException {\n\n\t\t// Put RMSD\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\talignment.putScore(RMSD, getRMSD(trans));\n\n\t\t// Put AvgTM-Score\n\t\tList<Integer> lengths = new ArrayList<Integer>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\talignment.putScore(AVGTM_SCORE, getAvgTMScore(trans, lengths));\n\t}\n\n\t/**\n\t * Calculates the RMSD of all-to-all structure comparisons (distances) of\n\t * the given MultipleAlignment.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * The formula used is just the sqroot of the average distance of all\n\t * possible pairs of atoms. Thus, for R structures aligned over C columns\n\t * without gaps, we have\n\t *\n\t * <pre>\n\t * RMSD = \\sqrt{1/(C*(R*(R-1)/2)) * \\sum_{r1=1}^{R-1}\n\t * \\sum_{r2=r1+1}^{R-1} \\sum_{j=0}^{C-1} (atom[r1][c]-atom[r2][c])^2}\n\t * </pre>\n\t *\n\t * @param alignment\n\t * @return double RMSD\n\t */\n\tpublic static double getRMSD(MultipleAlignment alignment) {\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\treturn getRMSD(trans);\n\t}\n\n\t/**\n\t * Calculates the RMSD of all-to-all structure comparisons (distances),\n\t * given a set of superimposed atoms.\n\t *\n\t * @param transformed\n\t * @return double RMSD\n\t * @see #getRMSD(MultipleAlignment)\n\t */\n\tpublic static double getRMSD(List<Atom[]> transformed) {\n\n\t\tdouble sumSqDist = 0;\n\t\tint comparisons = 0;\n\n\t\tfor (int r1 = 0; r1 < transformed.size(); r1++) {\n\t\t\tfor (int c = 0; c < transformed.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif (refAtom == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdouble nonNullSqDist = 0;\n\t\t\t\tint nonNullLength = 0;\n\t\t\t\tfor (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tnonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n\t\t\t\t\t\tnonNullLength++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nonNullLength > 0) {\n\t\t\t\t\tcomparisons++;\n\t\t\t\t\tsumSqDist += nonNullSqDist / nonNullLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Math.sqrt(sumSqDist / comparisons);\n\t}\n\n\t/**\n\t * /** Calculates the average RMSD from all structures to a reference s\n\t * tructure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * For ungapped alignments, this is just the sqroot of the average distance\n\t * from an atom to the aligned atom from the reference. Thus, for R\n\t * structures aligned over C columns (with structure 0 as the reference), we\n\t * have:\n\t *\n\t * <pre>\n\t * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n\t * (atom[1][c]-atom[r][c])^2 }\n\t * </pre>\n\t * <p>\n\t * For gapped alignments, null atoms are omitted from consideration, so that\n\t * the RMSD is the average over all columns with non-null reference of the\n\t * average RMSD within the non-null elements of the column.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @param ref\n\t *            reference structure index\n\t * @return\n\t */\n\tpublic static double getRefRMSD(MultipleAlignment alignment, int ref) {\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\treturn getRefRMSD(trans, ref);\n\t}\n\n\t/**\n\t * Calculates the average RMSD from all structures to a reference s\n\t * tructure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * For ungapped alignments, this is just the sqroot of the average distance\n\t * from an atom to the aligned atom from the reference. Thus, for R\n\t * structures aligned over C columns (with structure 0 as the reference), we\n\t * have:\n\t *\n\t * <pre>\n\t * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n\t * (atom[1][c]-atom[r][c])^2 }\n\t * </pre>\n\t * <p>\n\t * For gapped alignments, null atoms are omitted from consideration, so that\n\t * the RMSD is the average over all columns with non-null reference of the\n\t * average RMSD within the non-null elements of the column.\n\t *\n\t * @param transformed\n\t * @param reference\n\t * @return\n\t */\n\tpublic static double getRefRMSD(List<Atom[]> transformed, int reference) {\n\n\t\tdouble sumSqDist = 0;\n\t\tint totalLength = 0;\n\t\tfor (int c = 0; c < transformed.get(reference).length; c++) {\n\t\t\tAtom refAtom = transformed.get(reference)[c];\n\t\t\tif (refAtom == null)\n\t\t\t\tcontinue;\n\n\t\t\tdouble nonNullSqDist = 0;\n\t\t\tint nonNullLength = 0;\n\t\t\tfor (int r = 0; r < transformed.size(); r++) {\n\t\t\t\tif (r == reference)\n\t\t\t\t\tcontinue;\n\t\t\t\tAtom atom = transformed.get(r)[c];\n\t\t\t\tif (atom != null) {\n\t\t\t\t\tnonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n\t\t\t\t\tnonNullLength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nonNullLength > 0) {\n\t\t\t\ttotalLength++;\n\t\t\t\tsumSqDist += nonNullSqDist / nonNullLength;\n\t\t\t}\n\t\t}\n\t\treturn Math.sqrt(sumSqDist / totalLength);\n\t}\n\n\t/**\n\t * Calculates the average TMScore of all the possible pairwise structure\n\t * comparisons of the given alignment.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @return double Average TMscore\n\t * @throws StructureException\n\t */\n\tpublic static double getAvgTMScore(MultipleAlignment alignment)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\tList<Integer> lengths = new ArrayList<Integer>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\treturn getAvgTMScore(trans, lengths);\n\t}\n\n\t/**\n\t * Calculates the average TMScore all the possible pairwise structure\n\t * comparisons of the given a set of superimposed Atoms and the original\n\t * structure lengths.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            aligned Atoms transformed\n\t * @param lengths\n\t *            lengths of the structures in residue number\n\t * @return double Average TMscore\n\t * @throws StructureException\n\t */\n\tpublic static double getAvgTMScore(List<Atom[]> transformed,\n\t\t\tList<Integer> lengths) throws StructureException {\n\n\t\tif (transformed.size() != lengths.size())\n\t\t\tthrow new IllegalArgumentException(\"Input sizes differ.\");\n\n\t\tdouble sumTM = 0;\n\t\tint comparisons = 0;\n\n\t\tfor (int r1 = 0; r1 < transformed.size(); r1++) {\n\t\t\tfor (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n\t\t\t\tint len = transformed.get(r1).length;\n\t\t\t\t// Remove nulls from both arrays\n\t\t\t\tAtom[] ref = new Atom[len];\n\t\t\t\tAtom[] aln = new Atom[len];\n\t\t\t\tint nonNullLen = 0;\n\t\t\t\tfor (int c = 0; c < len; c++) {\n\t\t\t\t\tif (transformed.get(r1)[c] != null\n\t\t\t\t\t\t\t&& transformed.get(r2)[c] != null) {\n\t\t\t\t\t\tref[nonNullLen] = transformed.get(r1)[c];\n\t\t\t\t\t\taln[nonNullLen] = transformed.get(r2)[c];\n\t\t\t\t\t\tnonNullLen++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Truncate nulls\n\t\t\t\tif (nonNullLen < len) {\n\t\t\t\t\tref = Arrays.copyOf(ref, nonNullLen);\n\t\t\t\t\taln = Arrays.copyOf(aln, nonNullLen);\n\t\t\t\t}\n\t\t\t\tsumTM += Calc.getTMScore(ref, aln, lengths.get(r1),\n\t\t\t\t\t\tlengths.get(r2));\n\t\t\t\tcomparisons++;\n\t\t\t}\n\t\t}\n\t\treturn sumTM / comparisons;\n\t}\n\n\t/**\n\t * Calculates the average TMScore from all structures to a reference\n\t * structure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @param reference\n\t *            Index of the reference structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static double getRefTMScore(MultipleAlignment alignment, int ref)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\tList<Integer> lengths = new ArrayList<Integer>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\treturn getRefTMScore(trans, lengths, ref);\n\t}\n\n\t/**\n\t * Calculates the average TMScore from all structures to a reference\n\t * structure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            Arrays of aligned atoms, after superposition\n\t * @param lengths\n\t *            lengths of the full input structures\n\t * @param reference\n\t *            Index of the reference structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static double getRefTMScore(List<Atom[]> transformed,\n\t\t\tList<Integer> lengths, int reference) throws StructureException {\n\n\t\tif (transformed.size() != lengths.size())\n\t\t\tthrow new IllegalArgumentException(\"Input sizes differ\");\n\n\t\tdouble sumTM = 0;\n\t\tint comparisons = 0;\n\n\t\tint len = transformed.get(reference).length;\n\t\tfor (int r = 0; r < transformed.size(); r++) {\n\t\t\tif (r == reference)\n\t\t\t\tcontinue;\n\t\t\t// remove nulls from both arrays\n\t\t\tAtom[] ref = new Atom[len];\n\t\t\tAtom[] aln = new Atom[len];\n\t\t\tint nonNullLen = 0;\n\t\t\tfor (int c = 0; c < len; c++) {\n\t\t\t\tif (transformed.get(reference)[c] != null\n\t\t\t\t\t\t&& transformed.get(r)[c] != null) {\n\t\t\t\t\tref[nonNullLen] = transformed.get(reference)[c];\n\t\t\t\t\taln[nonNullLen] = transformed.get(r)[c];\n\t\t\t\t\tnonNullLen++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// truncate nulls\n\t\t\tif (nonNullLen < len) {\n\t\t\t\tref = Arrays.copyOf(ref, nonNullLen);\n\t\t\t\taln = Arrays.copyOf(aln, nonNullLen);\n\t\t\t}\n\t\t\tsumTM += Calc.getTMScore(ref, aln,\n\t\t\t\t\tlengths.get(reference), lengths.get(r));\n\t\t\tcomparisons++;\n\t\t}\n\t\treturn sumTM / comparisons;\n\t}\n\n\t/**\n\t * Calculates the MC score, specific for the MultipleAlignment algorithm.\n\t * The score function is modified from the original CEMC paper, making it\n\t * continuous and differentiable.\n\t * <p>\n\t * The maximum score of a match is 20, and the penalties for gaps are part\n\t * of the input. The half-score distance, d0, is chosen as in the TM-score.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @param gapOpen\n\t *            penalty for gap opening (reasonable values are in the range\n\t *            (1.0-20.0)\n\t * @param gapExtension\n\t *            penalty for extending a gap (reasonable values are in the\n\t *            range (0.5-10.0)\n\t * @param dCutoff\n\t *            the distance cutoff\n\t * @return the value of the score\n\t * @throws StructureException\n\t */\n\tpublic static double getMCScore(MultipleAlignment alignment,\n\t\t\tdouble gapOpen, double gapExtension, double dCutoff)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\t// Calculate d0: same as the one in TM score\n\t\tint minLen = Integer.MAX_VALUE;\n\t\tfor (Atom[] atoms : alignment.getAtomArrays())\n\t\t\tif (atoms.length < minLen)\n\t\t\t\tminLen = atoms.length;\n\t\tdouble d0 = 1.24 * Math.cbrt((minLen) - 15.) - 1.8;\n\n\t\t// Calculate the distance cutoff penalization\n\t\tdouble A = 20.0 / (1 + (dCutoff * dCutoff) / (d0 * d0));\n\n\t\treturn getMCScore(trans, d0, gapOpen, gapExtension, A);\n\t}\n\n\t/**\n\t * Calculates the MC score, specific for the MultipleAlignment algorithm.\n\t * The score function is modified from the original CEMC paper, making it\n\t * continuous and differentiable.\n\t * <p>\n\t * The maximum score of a match is 20, and the penalties for gaps are part\n\t * of the input.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            List of transformed Atom arrays\n\t * @param d0\n\t *            parameter for the half-score distance\n\t * @param gapOpen\n\t *            penalty for gap opening (reasonable values are in the range\n\t *            (1.0-20.0)\n\t * @param gapExtension\n\t *            penalty for extending a gap (reasonable values are in the\n\t *            range (0.5-10.0)\n\t * @param A\n\t *            the distance cutoff penalization\n\t * @return the value of the score\n\t * @throws StructureException\n\t */\n\tprivate static double getMCScore(List<Atom[]> trans, double d0,\n\t\t\tdouble gapOpen, double gapExtension, double A)\n\t\t\tthrows StructureException {\n\n\t\tint size = trans.size();\n\t\tint length = trans.get(0).length;\n\t\tMatrix residueDistances = new Matrix(size, length, -1);\n\t\tdouble scoreMC = 0.0;\n\t\tint openGaps = 0;\n\t\tint extensionGaps = 0;\n\n\t\t// Calculate the average residue distances\n\t\tfor (int r1 = 0; r1 < size; r1++) {\n\t\t\tboolean gapped = false;\n\t\t\tfor (int c = 0; c < trans.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = trans.get(r1)[c];\n\t\t\t\t// Calculate the gap extension and opening on the fly\n\t\t\t\tif (refAtom == null) {\n\t\t\t\t\tif (gapped)\n\t\t\t\t\t\textensionGaps++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgapped = true;\n\t\t\t\t\t\topenGaps++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tgapped = false;\n\n\t\t\t\tfor (int r2 = r1 + 1; r2 < size; r2++) {\n\t\t\t\t\tAtom atom = trans.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\t\t\t\t\t\tif (residueDistances.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresidueDistances.set(r1, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresidueDistances.set(r1, c,\n\t\t\t\t\t\t\t\t\tresidueDistances.get(r1, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (residueDistances.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresidueDistances.set(r2, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresidueDistances.set(r2, c,\n\t\t\t\t\t\t\t\t\tresidueDistances.get(r2, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int c = 0; c < length; c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (residueDistances.get(r, c) != -1)\n\t\t\t\t\tnonNullRes++;\n\t\t\t}\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (residueDistances.get(r, c) != -1) {\n\t\t\t\t\tresidueDistances.set(r, c, residueDistances.get(r, c)\n\t\t\t\t\t\t\t/ nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Sum all the aligned residue scores\n\t\tfor (int row = 0; row < size; row++) {\n\t\t\tfor (int col = 0; col < length; col++) {\n\t\t\t\tif (residueDistances.get(row, col) == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble d1 = residueDistances.get(row, col);\n\t\t\t\tdouble resScore = 20.0 / (1 + (d1 * d1) / (d0 * d0));\n\t\t\t\tscoreMC += resScore - A;\n\t\t\t}\n\t\t}\n\n\t\t// Apply the Gap penalty and return\n\t\treturn scoreMC - (openGaps * gapOpen + extensionGaps * gapExtension);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Utility class for calculating common scores of {@link MultipleAlignment}s.\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentScorer {\n\n\t// Names for commonly used scores\n\tpublic static final String PROBABILITY = \"Probability\";\n\tpublic static final String CE_SCORE = \"CE-score\";\n\tpublic static final String RMSD = \"RMSD\";\n\tpublic static final String AVGTM_SCORE = \"AvgTM-score\";\n\tpublic static final String MC_SCORE = \"MC-score\";\n\tpublic static final String REF_RMSD = \"Ref-RMSD\";\n\tpublic static final String REFTM_SCORE = \"RefTM-score\";\n\n\t/**\n\t * Calculates and puts the RMSD and the average TM-Score of the\n\t * MultipleAlignment.\n\t *\n\t * @param alignment\n\t * @throws StructureException\n\t * @see #getAvgTMScore(MultipleAlignment)\n\t * @see #getRMSD(MultipleAlignment)\n\t */\n\tpublic static void calculateScores(MultipleAlignment alignment)\n\t\t\tthrows StructureException {\n\n\t\t// Put RMSD\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\talignment.putScore(RMSD, getRMSD(trans));\n\n\t\t// Put AvgTM-Score\n\t\tList<Integer> lengths = new ArrayList<>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\talignment.putScore(AVGTM_SCORE, getAvgTMScore(trans, lengths));\n\t}\n\n\t/**\n\t * Calculates the RMSD of all-to-all structure comparisons (distances) of\n\t * the given MultipleAlignment.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * The formula used is just the sqroot of the average distance of all\n\t * possible pairs of atoms. Thus, for R structures aligned over C columns\n\t * without gaps, we have\n\t *\n\t * <pre>\n\t * RMSD = \\sqrt{1/(C*(R*(R-1)/2)) * \\sum_{r1=1}^{R-1}\n\t * \\sum_{r2=r1+1}^{R-1} \\sum_{j=0}^{C-1} (atom[r1][c]-atom[r2][c])^2}\n\t * </pre>\n\t *\n\t * @param alignment\n\t * @return double RMSD\n\t */\n\tpublic static double getRMSD(MultipleAlignment alignment) {\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\treturn getRMSD(trans);\n\t}\n\n\t/**\n\t * Calculates the RMSD of all-to-all structure comparisons (distances),\n\t * given a set of superimposed atoms.\n\t *\n\t * @param transformed\n\t * @return double RMSD\n\t * @see #getRMSD(MultipleAlignment)\n\t */\n\tpublic static double getRMSD(List<Atom[]> transformed) {\n\n\t\tdouble sumSqDist = 0;\n\t\tint comparisons = 0;\n\n\t\tfor (int r1 = 0; r1 < transformed.size(); r1++) {\n\t\t\tfor (int c = 0; c < transformed.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif (refAtom == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tdouble nonNullSqDist = 0;\n\t\t\t\tint nonNullLength = 0;\n\t\t\t\tfor (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tnonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n\t\t\t\t\t\tnonNullLength++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nonNullLength > 0) {\n\t\t\t\t\tcomparisons++;\n\t\t\t\t\tsumSqDist += nonNullSqDist / nonNullLength;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Math.sqrt(sumSqDist / comparisons);\n\t}\n\n\t/**\n\t * /** Calculates the average RMSD from all structures to a reference s\n\t * tructure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * For ungapped alignments, this is just the sqroot of the average distance\n\t * from an atom to the aligned atom from the reference. Thus, for R\n\t * structures aligned over C columns (with structure 0 as the reference), we\n\t * have:\n\t *\n\t * <pre>\n\t * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n\t * (atom[1][c]-atom[r][c])^2 }\n\t * </pre>\n\t * <p>\n\t * For gapped alignments, null atoms are omitted from consideration, so that\n\t * the RMSD is the average over all columns with non-null reference of the\n\t * average RMSD within the non-null elements of the column.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @param ref\n\t *            reference structure index\n\t * @return\n\t */\n\tpublic static double getRefRMSD(MultipleAlignment alignment, int ref) {\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\t\treturn getRefRMSD(trans, ref);\n\t}\n\n\t/**\n\t * Calculates the average RMSD from all structures to a reference s\n\t * tructure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t * <p>\n\t * For ungapped alignments, this is just the sqroot of the average distance\n\t * from an atom to the aligned atom from the reference. Thus, for R\n\t * structures aligned over C columns (with structure 0 as the reference), we\n\t * have:\n\t *\n\t * <pre>\n\t * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n\t * (atom[1][c]-atom[r][c])^2 }\n\t * </pre>\n\t * <p>\n\t * For gapped alignments, null atoms are omitted from consideration, so that\n\t * the RMSD is the average over all columns with non-null reference of the\n\t * average RMSD within the non-null elements of the column.\n\t *\n\t * @param transformed\n\t * @param reference\n\t * @return\n\t */\n\tpublic static double getRefRMSD(List<Atom[]> transformed, int reference) {\n\n\t\tdouble sumSqDist = 0;\n\t\tint totalLength = 0;\n\t\tfor (int c = 0; c < transformed.get(reference).length; c++) {\n\t\t\tAtom refAtom = transformed.get(reference)[c];\n\t\t\tif (refAtom == null)\n\t\t\t\tcontinue;\n\n\t\t\tdouble nonNullSqDist = 0;\n\t\t\tint nonNullLength = 0;\n\t\t\tfor (int r = 0; r < transformed.size(); r++) {\n\t\t\t\tif (r == reference)\n\t\t\t\t\tcontinue;\n\t\t\t\tAtom atom = transformed.get(r)[c];\n\t\t\t\tif (atom != null) {\n\t\t\t\t\tnonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n\t\t\t\t\tnonNullLength++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nonNullLength > 0) {\n\t\t\t\ttotalLength++;\n\t\t\t\tsumSqDist += nonNullSqDist / nonNullLength;\n\t\t\t}\n\t\t}\n\t\treturn Math.sqrt(sumSqDist / totalLength);\n\t}\n\n\t/**\n\t * Calculates the average TMScore of all the possible pairwise structure\n\t * comparisons of the given alignment.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @return double Average TMscore\n\t * @throws StructureException\n\t */\n\tpublic static double getAvgTMScore(MultipleAlignment alignment)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\tList<Integer> lengths = new ArrayList<>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\treturn getAvgTMScore(trans, lengths);\n\t}\n\n\t/**\n\t * Calculates the average TMScore all the possible pairwise structure\n\t * comparisons of the given a set of superimposed Atoms and the original\n\t * structure lengths.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            aligned Atoms transformed\n\t * @param lengths\n\t *            lengths of the structures in residue number\n\t * @return double Average TMscore\n\t * @throws StructureException\n\t */\n\tpublic static double getAvgTMScore(List<Atom[]> transformed,\n\t\t\tList<Integer> lengths) throws StructureException {\n\n\t\tif (transformed.size() != lengths.size())\n\t\t\tthrow new IllegalArgumentException(\"Input sizes differ.\");\n\n\t\tdouble sumTM = 0;\n\t\tint comparisons = 0;\n\n\t\tfor (int r1 = 0; r1 < transformed.size(); r1++) {\n\t\t\tfor (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n\t\t\t\tint len = transformed.get(r1).length;\n\t\t\t\t// Remove nulls from both arrays\n\t\t\t\tAtom[] ref = new Atom[len];\n\t\t\t\tAtom[] aln = new Atom[len];\n\t\t\t\tint nonNullLen = 0;\n\t\t\t\tfor (int c = 0; c < len; c++) {\n\t\t\t\t\tif (transformed.get(r1)[c] != null\n\t\t\t\t\t\t\t&& transformed.get(r2)[c] != null) {\n\t\t\t\t\t\tref[nonNullLen] = transformed.get(r1)[c];\n\t\t\t\t\t\taln[nonNullLen] = transformed.get(r2)[c];\n\t\t\t\t\t\tnonNullLen++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Truncate nulls\n\t\t\t\tif (nonNullLen < len) {\n\t\t\t\t\tref = Arrays.copyOf(ref, nonNullLen);\n\t\t\t\t\taln = Arrays.copyOf(aln, nonNullLen);\n\t\t\t\t}\n\t\t\t\tsumTM += Calc.getTMScore(ref, aln, lengths.get(r1),\n\t\t\t\t\t\tlengths.get(r2));\n\t\t\t\tcomparisons++;\n\t\t\t}\n\t\t}\n\t\treturn sumTM / comparisons;\n\t}\n\n\t/**\n\t * Calculates the average TMScore from all structures to a reference\n\t * structure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @param reference\n\t *            Index of the reference structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static double getRefTMScore(MultipleAlignment alignment, int ref)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\tList<Integer> lengths = new ArrayList<>(alignment.size());\n\t\tfor (Atom[] atoms : alignment.getAtomArrays()) {\n\t\t\tlengths.add(atoms.length);\n\t\t}\n\t\treturn getRefTMScore(trans, lengths, ref);\n\t}\n\n\t/**\n\t * Calculates the average TMScore from all structures to a reference\n\t * structure, given a set of superimposed atoms.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            Arrays of aligned atoms, after superposition\n\t * @param lengths\n\t *            lengths of the full input structures\n\t * @param reference\n\t *            Index of the reference structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static double getRefTMScore(List<Atom[]> transformed,\n\t\t\tList<Integer> lengths, int reference) throws StructureException {\n\n\t\tif (transformed.size() != lengths.size())\n\t\t\tthrow new IllegalArgumentException(\"Input sizes differ\");\n\n\t\tdouble sumTM = 0;\n\t\tint comparisons = 0;\n\n\t\tint len = transformed.get(reference).length;\n\t\tfor (int r = 0; r < transformed.size(); r++) {\n\t\t\tif (r == reference)\n\t\t\t\tcontinue;\n\t\t\t// remove nulls from both arrays\n\t\t\tAtom[] ref = new Atom[len];\n\t\t\tAtom[] aln = new Atom[len];\n\t\t\tint nonNullLen = 0;\n\t\t\tfor (int c = 0; c < len; c++) {\n\t\t\t\tif (transformed.get(reference)[c] != null\n\t\t\t\t\t\t&& transformed.get(r)[c] != null) {\n\t\t\t\t\tref[nonNullLen] = transformed.get(reference)[c];\n\t\t\t\t\taln[nonNullLen] = transformed.get(r)[c];\n\t\t\t\t\tnonNullLen++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// truncate nulls\n\t\t\tif (nonNullLen < len) {\n\t\t\t\tref = Arrays.copyOf(ref, nonNullLen);\n\t\t\t\taln = Arrays.copyOf(aln, nonNullLen);\n\t\t\t}\n\t\t\tsumTM += Calc.getTMScore(ref, aln,\n\t\t\t\t\tlengths.get(reference), lengths.get(r));\n\t\t\tcomparisons++;\n\t\t}\n\t\treturn sumTM / comparisons;\n\t}\n\n\t/**\n\t * Calculates the MC score, specific for the MultipleAlignment algorithm.\n\t * The score function is modified from the original CEMC paper, making it\n\t * continuous and differentiable.\n\t * <p>\n\t * The maximum score of a match is 20, and the penalties for gaps are part\n\t * of the input. The half-score distance, d0, is chosen as in the TM-score.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t * @param gapOpen\n\t *            penalty for gap opening (reasonable values are in the range\n\t *            (1.0-20.0)\n\t * @param gapExtension\n\t *            penalty for extending a gap (reasonable values are in the\n\t *            range (0.5-10.0)\n\t * @param dCutoff\n\t *            the distance cutoff\n\t * @return the value of the score\n\t * @throws StructureException\n\t */\n\tpublic static double getMCScore(MultipleAlignment alignment,\n\t\t\tdouble gapOpen, double gapExtension, double dCutoff)\n\t\t\tthrows StructureException {\n\n\t\tList<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n\n\t\t// Calculate d0: same as the one in TM score\n\t\tint minLen = Integer.MAX_VALUE;\n\t\tfor (Atom[] atoms : alignment.getAtomArrays())\n\t\t\tif (atoms.length < minLen)\n\t\t\t\tminLen = atoms.length;\n\t\tdouble d0 = 1.24 * Math.cbrt((minLen) - 15.) - 1.8;\n\n\t\t// Calculate the distance cutoff penalization\n\t\tdouble A = 20.0 / (1 + (dCutoff * dCutoff) / (d0 * d0));\n\n\t\treturn getMCScore(trans, d0, gapOpen, gapExtension, A);\n\t}\n\n\t/**\n\t * Calculates the MC score, specific for the MultipleAlignment algorithm.\n\t * The score function is modified from the original CEMC paper, making it\n\t * continuous and differentiable.\n\t * <p>\n\t * The maximum score of a match is 20, and the penalties for gaps are part\n\t * of the input.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            List of transformed Atom arrays\n\t * @param d0\n\t *            parameter for the half-score distance\n\t * @param gapOpen\n\t *            penalty for gap opening (reasonable values are in the range\n\t *            (1.0-20.0)\n\t * @param gapExtension\n\t *            penalty for extending a gap (reasonable values are in the\n\t *            range (0.5-10.0)\n\t * @param A\n\t *            the distance cutoff penalization\n\t * @return the value of the score\n\t * @throws StructureException\n\t */\n\tprivate static double getMCScore(List<Atom[]> trans, double d0,\n\t\t\tdouble gapOpen, double gapExtension, double A)\n\t\t\tthrows StructureException {\n\n\t\tint size = trans.size();\n\t\tint length = trans.get(0).length;\n\t\tMatrix residueDistances = new Matrix(size, length, -1);\n\t\tdouble scoreMC = 0.0;\n\t\tint openGaps = 0;\n\t\tint extensionGaps = 0;\n\n\t\t// Calculate the average residue distances\n\t\tfor (int r1 = 0; r1 < size; r1++) {\n\t\t\tboolean gapped = false;\n\t\t\tfor (int c = 0; c < trans.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = trans.get(r1)[c];\n\t\t\t\t// Calculate the gap extension and opening on the fly\n\t\t\t\tif (refAtom == null) {\n\t\t\t\t\tif (gapped)\n\t\t\t\t\t\textensionGaps++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tgapped = true;\n\t\t\t\t\t\topenGaps++;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tgapped = false;\n\n\t\t\t\tfor (int r2 = r1 + 1; r2 < size; r2++) {\n\t\t\t\t\tAtom atom = trans.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\t\t\t\t\t\tif (residueDistances.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresidueDistances.set(r1, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresidueDistances.set(r1, c,\n\t\t\t\t\t\t\t\t\tresidueDistances.get(r1, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (residueDistances.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresidueDistances.set(r2, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresidueDistances.set(r2, c,\n\t\t\t\t\t\t\t\t\tresidueDistances.get(r2, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int c = 0; c < length; c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (residueDistances.get(r, c) != -1)\n\t\t\t\t\tnonNullRes++;\n\t\t\t}\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (residueDistances.get(r, c) != -1) {\n\t\t\t\t\tresidueDistances.set(r, c, residueDistances.get(r, c)\n\t\t\t\t\t\t\t/ nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Sum all the aligned residue scores\n\t\tfor (int row = 0; row < size; row++) {\n\t\t\tfor (int col = 0; col < length; col++) {\n\t\t\t\tif (residueDistances.get(row, col) == -1)\n\t\t\t\t\tcontinue;\n\t\t\t\tdouble d1 = residueDistances.get(row, col);\n\t\t\t\tdouble resScore = 20.0 / (1 + (d1 * d1) / (d0 * d0));\n\t\t\t\tscoreMC += resScore - A;\n\t\t\t}\n\t\t}\n\n\t\t// Apply the Gap penalty and return\n\t\treturn scoreMC - (openGaps * gapOpen + extensionGaps * gapExtension);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of various Score calculations for\n * {@link MultipleAlignment}s.\n * <p>\n * Currently tested:\n * <ul><li>Reference and total RMSD\n * <li>Reference and average TM-Score\n * <li>MC-Score\n * </ul>\n *\n * @author Aleix Lafita\n *\n */\npublic class TestMultipleAlignmentScorer {\n\n\t@Test\n\tpublic void testRefRMSD() throws Exception{\n\n\t\t//Identity Test: RefRMSD has to be equal to 0.0\n\t\tMultipleAlignment identMSA = identityMSTA();\n\t\tdouble refRMSD1 = MultipleAlignmentScorer.getRefRMSD(identMSA, 0);\n\t\tassertEquals(0.0, refRMSD1, 0.000001);\n\n\t\t//Simple Test: RefRMSD has to be equal to sqrt(2.5)\n\t\tMultipleAlignment simpleMSA = simpleMSTA();\n\t\tdouble refRMSD2 = MultipleAlignmentScorer.getRefRMSD(simpleMSA, 0);\n\t\tassertEquals(1.5811388, refRMSD2, 0.000001);\n\n\t\t//Gapped Test: RefRMSD has to be equal to 1.0\n\t\tMultipleAlignment gappedMSA = gappedMSTA();\n\t\tdouble refRMSD3 = MultipleAlignmentScorer.getRefRMSD(gappedMSA, 0);\n\t\tassertEquals(1.0, refRMSD3, 0.000001);\n\t}\n\n\t@Test\n\tpublic void testRMSD() throws Exception{\n\n\t\t//Identity Test: RMSD has to be equal to 0.0\n\t\tMultipleAlignment identMSA = identityMSTA();\n\t\tdouble RMSD1 = MultipleAlignmentScorer.getRMSD(identMSA);\n\t\tassertEquals(0.0, RMSD1, 0.000001);\n\n\t\t//Simple Test: RMSD has to be equal to 1.3228756\n\t\tMultipleAlignment simpleMSA = simpleMSTA();\n\t\tdouble RMSD2 = MultipleAlignmentScorer.getRMSD(simpleMSA);\n\t\tassertEquals(1.3228756, RMSD2, 0.000001);\n\n\t\t//Gapped Test: RMSD has to be equal to 1.0\n\t\tMultipleAlignment gappedMSA = gappedMSTA();\n\t\tdouble RMSD3 = MultipleAlignmentScorer.getRMSD(gappedMSA);\n\t\tassertEquals(0.8340576, RMSD3, 0.000001);\n\t}\n\n\t@Test\n\tpublic void testRefTMScore() throws Exception{\n\n\t\t//Identity Test: RefTM-Score has to be equal to 1.0\n\t\tMultipleAlignment identMSA = identityMSTA();\n\t\tdouble refTM1 = MultipleAlignmentScorer.getRefTMScore(identMSA, 0);\n\t\tassertEquals(1.0, refTM1, 0.000001);\n\n\t\t//Simple Test: RefTM-Score has to be equal to 0.6831032\n\t\tMultipleAlignment simpleMSA = simpleMSTA();\n\t\tdouble refTM2 = MultipleAlignmentScorer.getRefTMScore(simpleMSA, 0);\n\t\tassertEquals(0.6831032, refTM2, 0.000001);\n\n\t\t//Simple Test: RefTM-Score has to be equal to 0.6831032\n\t\tMultipleAlignment gappedMSA = gappedMSTA();\n\t\tdouble refTM3 = MultipleAlignmentScorer.getRefTMScore(gappedMSA, 0);\n\t\tassertEquals(0.2672780, refTM3, 0.000001);\n\t}\n\n\t@Test\n\tpublic void testAvgTMScore() throws Exception{\n\n\t\t//Identity Test: AvgTM-Score has to be equal to 1.0\n\t\tMultipleAlignment identMSA = identityMSTA();\n\t\tdouble avgTM1 = MultipleAlignmentScorer.getAvgTMScore(identMSA);\n\t\tassertEquals(1.0, avgTM1, 0.000001);\n\n\t\t//Simple Test: AvgTM-Score has to be equal to 0.7261305\n\t\tMultipleAlignment simpleMSA = simpleMSTA();\n\t\tdouble avgTM2 = MultipleAlignmentScorer.getAvgTMScore(simpleMSA);\n\t\tassertEquals(0.7261305, avgTM2, 0.000001);\n\n\t\t//Simple Test: AvgTM-Score has to be equal to 0.2831998\n\t\tMultipleAlignment gappedMSA = gappedMSTA();\n\t\tdouble avgTM3 = MultipleAlignmentScorer.getAvgTMScore(gappedMSA);\n\t\tassertEquals(0.2831998, avgTM3, 0.000001);\n\t}\n\n\t@Test\n\tpublic void testMCScore() throws Exception {\n\n\t\t//Identity Test: MultipleMC-Score has to be equal to 576.21\n\t\tMultipleAlignment identMSA = identityMSTA();\n\t\tdouble MC1 = MultipleAlignmentScorer.getMCScore(identMSA, 10, 5, 10);\n\t\tassertEquals(574.98, MC1, 0.01);\n\n\t\t//Simple Test: MultipleMC-Score has to be equal to 2351.93\n\t\tMultipleAlignment simpleMSA = simpleMSTA();\n\t\tdouble MC2 = MultipleAlignmentScorer.getMCScore(simpleMSA, 10, 5, 10);\n\t\tassertEquals(2197.20, MC2, 0.01);\n\n\t\t//Simple Test: MultipleMC-Score has to be equal to 489.74\n\t\tMultipleAlignment gappedMSA = gappedMSTA();\n\t\tdouble MC3 = MultipleAlignmentScorer.getMCScore(gappedMSA, 10, 5, 10);\n\t\tassertEquals(478.52, MC3, 0.01);\n\t}\n\n\t/**\n\t * Generates an identity MultipleAlignment: 3 structures with\n\t * the same Atoms and perfectly aligned, so that TM-score = 1\n\t * and RMSD = 0.\n\t * @return MultipleAlignment identity\n\t * @throws StructureException\n\t */\n\tprivate MultipleAlignment identityMSTA() throws StructureException {\n\n\t\t//Generate the identical Atom arrays\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>(20);\n\t\tfor (int i=0; i<3; i++) atomArrays.add(makeDummyCA(20));\n\n\t\t//Generate the identity alignment (1-1-1,2-2-2,etc)\n\t\tList<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n\t\tfor (int str=0; str<3; str++){\n\t\t\tList<Integer> chain = new ArrayList<Integer>(20);\n\t\t\tfor (int res=0; res<20; res++) chain.add(res);\n\t\t\talnRes.add(chain);\n\t\t}\n\n\t\t//MultipleAlignment generation\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.getEnsemble().setAtomArrays(atomArrays);\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(alnRes);\n\n\t\t//Superimpose the alignment (which should give the identity matrices)\n\t\tReferenceSuperimposer imposer = new ReferenceSuperimposer();\n\t\timposer.superimpose(msa);\n\n\t\treturn msa;\n\t}\n\n\t/**\n\t * Generates a simple MultipleAlignment: 3 structures with the same\n\t * Atoms but incorreclty aligned (offset of 1 position) without gaps.\n\t *\n\t * @return MultipleAlignment simple MSTA\n\t * @throws StructureException\n\t */\n\tprivate MultipleAlignment simpleMSTA() throws StructureException{\n\n\t\t//Generate three identical Atom arrays\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>(52);\n\t\tfor (int i=0; i<3; i++) atomArrays.add(makeDummyCA(52));\n\n\t\t//Generate the incorrect alignment (0-1-2,1-2-3,etc)\n\t\tList<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n\t\tfor (int str=0; str<3; str++){\n\t\t\tList<Integer> chain = new ArrayList<Integer>(50);\n\t\t\tfor (int res=0; res<50; res++) chain.add(res+str);\n\t\t\talnRes.add(chain);\n\t\t}\n\n\t\t//MultipleAlignment generation\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.getEnsemble().setAtomArrays(atomArrays);\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(alnRes);\n\n\t\t//We want the identity transfromations to maintain the missalignment\n\t\tMatrix4d ident = new Matrix4d();\n\t\tident.setIdentity();\n\t\tbs.setTransformations(Arrays.asList(ident,ident,ident));\n\n\t\treturn msa;\n\t}\n\n\t/**\n\t * Generates a simple MultipleAlignment: 3 structures with the\n\t * same Atoms but incorreclty aligned with gaps.\n\t *\n\t * @return MultipleAlignment gapped MSTA\n\t * @throws StructureException\n\t */\n\tprivate MultipleAlignment gappedMSTA() throws StructureException{\n\n\t\t//Generate three identical Atom arrays\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>(30);\n\t\tfor (int i=0; i<3; i++) atomArrays.add(makeDummyCA(30));\n\n\t\t//Generate alignment with nulls and some missalignments\n\t\tList<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n\t\tList<Integer> chain1 = Arrays.asList(\n\t\t\t\t1, 2, \t 3, 5, 8, 10, 12, \t 15, 17,  19, 22, null, 24, 27);\n\t\tList<Integer> chain2 = Arrays.asList(\n\t\t\t\t1, null, 3, 6, 9, 11, 12,   15, null, 18, 22, 24,   26, 28);\n\t\tList<Integer> chain3 = Arrays.asList(\n\t\t\t\t1, 2,    4, 7, 9, 10, null, 15, null, 17, 22, 24,   26, 28);\n\n\t\talnRes.add(chain1);\n\t\talnRes.add(chain2);\n\t\talnRes.add(chain3);\n\n\t\t//MultipleAlignment generation\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.getEnsemble().setAtomArrays(atomArrays);\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(alnRes);\n\n\t\t//We want the identity transfromations to mantain the missalignments\n\t\tMatrix4d ident = new Matrix4d();\n\t\tident.setIdentity();\n\t\tbs.setTransformations(Arrays.asList(ident,ident,ident));\n\n\t\treturn msa;\n\t}\n\n\t/**\n\t * Makes dummy CA atoms at 1A intervals. Only the x coordinate increments\n\t * by one at each consecutive Atom.\n\t */\n\tprivate Atom[] makeDummyCA(int len) {\n\t\tAtom[] ca1;\n\t\tChain chain1 = new ChainImpl();\n\t\tca1 = new Atom[len];\n\t\tfor(int i=0;i<len;i++) {\n\t\t\tca1[i] = new AtomImpl();\n\t\t\tca1[i].setName(\"CA\");\n\t\t\tca1[i].setCoords(new double[] { i, 0, 0 });\n\t\t\tGroup aa = new AminoAcidImpl();\n\t\t\taa.setPDBName(\"GLY\");\n\t\t\taa.setResidueNumber( ResidueNumber.fromString(i+\"\"));\n\t\t\taa.addAtom(ca1[i]);\n\t\t\tchain1.addGroup(aa);\n\t\t}\n\t\treturn ca1;\n\t}\n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":false}