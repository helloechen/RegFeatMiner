{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/mmtf/MmtfStructureReader.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/mmtf/TestMmtfStructureReader.java","prod_time":"2020-11-14 09:45:12","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"43f8dcdd80aab451c0b9ad86f8079aa9d3ee9646","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.BondImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Element;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.EntityType;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.HetatomImpl;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.io.mmcif.chem.PolymerType;\nimport org.biojava.nbio.structure.io.mmcif.chem.ResidueType;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.api.StructureAdapterInterface;\nimport org.rcsb.mmtf.dataholders.MmtfStructure;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * A biojava specific structure inflator for MMTF.\n * Should be ported to biojava code.\n *\n * @author Anthony Bradley\n * @since 5.0\n * \n */\npublic class MmtfStructureReader implements StructureAdapterInterface, Serializable {\n\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 6772030485225130853L;\n\n\t/** The logger */\n\tprivate static final Logger logger = LoggerFactory.getLogger(MmtfStructureReader.class);\n\n\t/** The structure. */\n\tprivate Structure structure;\n\n\t/** The model number. */\n\tprivate int modelNumber;\n\n\t/** The chain. */\n\tprivate Chain chain;\n\n\t/** The group. */\n\tprivate Group group;\n\n\t/** The atoms in a group. */\n\tprivate List<Atom> atomsInGroup;\n\n\t/** All the atoms. */\n\tprivate Atom[] allAtoms;\n\tprivate int atomCounter;\n\n\t/** The list of EntityInformation */\n\tprivate List<EntityInfo> entityInfoList;\n\n\t/** All the chains */\n\tprivate List<Chain> chainList;\n\n\t/** All the chains as a list of maps */\n\tprivate List<Map<String,Chain>> chainMap;\n\n\tprivate List<double[]> transformList;\n\n\tprivate int bioassIndex;\n\n\tprivate Map<String,String> chainSequenceMap;\n\n\t/**\n\t * Instantiates a new bio java structure decoder.\n\t */\n\tpublic MmtfStructureReader() {\n\t\tstructure = new StructureImpl();\n\t\tmodelNumber = 0;\n\t\tentityInfoList = new ArrayList<>();\n\t\tchainList = new ArrayList<>();\n\t\tchainMap = new ArrayList<>();\n\t\ttransformList = new ArrayList<>();\n\t\tchainSequenceMap = new HashMap<>();\n\t}\n\n\t/**\n\t * Gets the structure.\n\t *\n\t * @return the structure\n\t */\n\tpublic Structure getStructure() {\n\t\treturn structure;\n\t}\n\n\t@Override\n\tpublic void finalizeStructure() {\n\t\t// Number the remaining ones\n\t\tint counter =0;\n\t\t// Add the entity info\n\t\tfor (EntityInfo entityInfo : entityInfoList) {\n\t\t\tcounter++;\n\t\t\tentityInfo.setMolId(counter);\n\t\t}\n\t\tstructure.setEntityInfos(entityInfoList);\n\t\t// Add the actual chains\n\t\tfor(int i=0; i<chainMap.size(); i++) {\n\t\t\t// Now add the chain information\n\t\t\tMap<String, Chain> modelChainMap = chainMap.get(i);\n\t\t\tfor(Chain modelChain : modelChainMap.values()){\n\t\t\t\tstructure.addChain(modelChain, i);\n\t\t\t\tString sequence = chainSequenceMap.get(modelChain.getId());\n\t\t\t\tif (sequence == null) {\n\t\t\t\t\tlogger.warn(\"Sequence is null for chain with asym_id {}. Most likely the chain is non-polymeric. Will not add seqres groups for it.\", modelChain.getId());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tMmtfUtils.addSeqRes(modelChain, sequence);\n\t\t\t}\n\t\t}\n\t\tStructureTools.cleanUpAltLocs(structure);\n\t}\n\n\t@Override\n\tpublic void initStructure(int totalNumBonds, int totalNumAtoms, int totalNumGroups,\n\t\t\tint totalNumChains, int totalNumModels, String modelId) {\n\t\tstructure.setPDBCode(modelId);\n\t\tallAtoms = new Atom[totalNumAtoms];\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#setModelInfo(int, int)\n\t */\n\t@Override\n\tpublic void setModelInfo(int inputModelNumber,\n\t\t\tint chainCount) {\n\t\tmodelNumber = inputModelNumber;\n\t\tstructure.addModel(new ArrayList<Chain>(chainCount));\n\t\tchainMap.add(new HashMap<>());\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setChainInfo(java.lang.String, int)\n\t */\n\t@Override\n\tpublic void setChainInfo(String chainId, String chainName, int groupCount) {\n\t\t// First check to see if the chain exists\n\t\tMap<String, Chain> modelChainMap = chainMap.get(modelNumber);\n\t\tif(modelChainMap.containsKey(chainId)){\n\t\t\tchain = modelChainMap.get(chainId);\n\t\t}\n\t\t// If we need to set a new chain do this\n\t\telse{\n\t\t\tchain = new ChainImpl();\n\t\t\tchain.setId(chainId.trim());\n\t\t\tchain.setName(chainName);\n\t\t\tchain.setAtomGroups(new ArrayList<>(groupCount));\n\t\t\tmodelChainMap.put(chainId, chain);\n\t\t\tchainList.add(chain);\n\t\t}\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setGroupInfo(java.lang.String, int, char, int, int)\n\t */\n\t@Override\n\tpublic void setGroupInfo(String groupName, int groupNumber,\n\t\t\tchar insertionCode, String chemCompType, int atomCount, int bondCount,\n\t\t\tchar singleLetterCode, int sequenceIndexId, int secStructType) {\n\t\t// Get the polymer type\n\t\tResidueType residueType = ResidueType.getResidueTypeFromString(chemCompType);\n\t\tif (residueType == null)\n\t\t\tthrow new IllegalStateException(\"Couldn't resolve residue type for \"+ chemCompType);\n\n\t\tint polymerType = getGroupTypIndicator(residueType.polymerType);\n\t\tswitch (polymerType) {\n\t\tcase 1:\n\t\t\tAminoAcid aa = new AminoAcidImpl();\n\t\t\t// Now set the one letter code\n\t\t\taa.setAminoType(singleLetterCode);\n\t\t\tgroup = aa;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgroup = new NucleotideImpl();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgroup = new HetatomImpl();\n\t\t\tbreak;\n\t\t}\n\t\tatomsInGroup = new ArrayList<>();\n\t\tChemComp chemComp = new ChemComp();\n\t\tchemComp.setOne_letter_code(String.valueOf(singleLetterCode));\n\t\tchemComp.setType(chemCompType.toUpperCase());\n\t\tchemComp.setResidueType(residueType);\n\t\tchemComp.setPolymerType(residueType.polymerType);\n\t\tgroup.setChemComp(chemComp);\n\t\tgroup.setPDBName(groupName);\n\t\tif (insertionCode == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {\n\t\t\tgroup.setResidueNumber(chain.getName().trim(), groupNumber, null);\n\t\t} else {\n\t\t\tgroup.setResidueNumber(chain.getName().trim(),\n\t\t\t\t\tgroupNumber, insertionCode);\n\t\t}\n\t\tgroup.setAtoms(new ArrayList<>(atomCount));\n\t\tif (polymerType==1 || polymerType==2) {\n\t\t\tMmtfUtils.insertSeqResGroup(chain, group, sequenceIndexId);\n\t\t}\n\t\tif (atomCount > 0) {\n\t\t\tchain.addGroup(group);\n\t\t}\n\t\tMmtfUtils.setSecStructType(group, secStructType);\n\t}\n\n\t/**\n\t *\n\t * @return\n\t */\n\tprivate Group getGroupWithSameResNumButDiffPDBName() {\n\t\t// If this chain already has this group number\n\t\tfor (Group g : chain.getAtomGroups() ) {\n\t\t\tif (g.getResidueNumber().equals(group.getResidueNumber())) {\n\t\t\t\tif( ! g.getPDBName().equals(group.getPDBName() )){\n\t\t\t\t\treturn g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setAtomInfo(java.lang.String, int, char, float, float,\n\t * float, float, float, java.lang.String, int)\n\t */\n\t@Override\n\tpublic void setAtomInfo(String atomName,\n\t\t\tint serialNumber, char alternativeLocationId, float x,\n\t\t\tfloat y, float z, float occupancy,\n\t\t\tfloat temperatureFactor,\n\t\t\tString element, int charge) {\n\t\tAtom atom = new AtomImpl();\n\t\tGroup altGroup = null;\n\t\tatom.setPDBserial(serialNumber);\n\t\tatom.setName(atomName.trim());\n\t\tatom.setElement(Element.valueOfIgnoreCase(element));\n\t\tif(alternativeLocationId==MmtfStructure.UNAVAILABLE_CHAR_VALUE){\n\t\t\talternativeLocationId = ' ';\n\t\t}\n\t\tif (alternativeLocationId != ' ') {\n\t\t\t// Get the altGroup\n\t\t\taltGroup = getCorrectAltLocGroup(alternativeLocationId);\n\t\t\tatom.setAltLoc(alternativeLocationId);\n\t\t} else {\n\t\t\tatom.setAltLoc(Character.valueOf(' '));\n\t\t}\n\t\tatom.setX(x);\n\t\tatom.setY(y);\n\t\tatom.setZ(z);\n\t\tatom.setOccupancy(occupancy);\n\t\tatom.setTempFactor(temperatureFactor);\n\t\tatom.setCharge((short) charge);\n\t\tif (altGroup == null) {\n\t\t\tgroup.addAtom(atom);\n\t\t} else {\n\t\t\taltGroup.setChain(chain);\n\t\t\taltGroup.addAtom(atom);\n\t\t}\n\n\t\t// IF the main group doesn't have this atom\n\t\tif (!group.hasAtom(atom.getName())) {\n\n\t\t\t// If it's not a microheterogenity case\n\t\t\tif (group.getPDBName().equals(atom.getGroup().getPDBName())) {\n\t\t\t\t// And it's not a deuterated case.  'nanoheterogenity'\n\t\t\t\tif(!StructureTools.hasNonDeuteratedEquiv(atom,group)){\n\t\t\t\t\tgroup.addAtom(atom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tatomsInGroup.add(atom);\n\t\tallAtoms[atomCounter] = atom;\n\t\tatomCounter++;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInter\n\t * face#setGroupBonds(int, int, int)\n\t */\n\t@Override\n\tpublic void setGroupBond(int indOne, int indTwo, int bondOrder) {\n\t\t\n\t\t// Get the atoms\n\t\tAtom atomOne = atomsInGroup.get(indOne);\n\t\tAtom atomTwo = atomsInGroup.get(indTwo);\n\t\t\n\t\t// set the new bond\n\t\tnew BondImpl(atomOne, atomTwo, bondOrder);\n\t\t\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoder\n\t * Interface#setInterGroupBonds(int, int, int)\n\t */\n\t@Override\n\tpublic void setInterGroupBond(int indOne, int indTwo, int bondOrder) {\n\t\t\n\t\t// Get the atoms\n\t\tAtom atomOne = allAtoms[indOne];\n\t\tAtom atomTwo = allAtoms[indTwo];\n\t\t\n\t\t// set the new bond (this \n\t\tnew BondImpl(atomOne, atomTwo, bondOrder);\n\t}\n\n\n\t/**\n\t * Generates Alternate location groups.\n\t *\n\t * @param altLoc the alt loc\n\t * @return the correct alt loc group\n\t */\n\tprivate Group getCorrectAltLocGroup(Character altLoc) {\n\t\t// see if we know this altLoc already;\n\t\tList<Atom> atoms = group.getAtoms();\n\t\tif (atoms.size() > 0) {\n\t\t\tAtom a1 = atoms.get(0);\n\t\t\t// we are just adding atoms to the current group\n\t\t\t// probably there is a second group following later...\n\t\t\tif (a1.getAltLoc().equals(altLoc)) {\n\t\t\t\treturn group;\t}\n\t\t}\n\n\t\t// Get the altLocGroup\n\t\tGroup altLocgroup = group.getAltLocGroup(altLoc);\n\t\tif (altLocgroup != null) {\n\t\t\treturn altLocgroup;\n\t\t}\n\t\t// If the group already exists (microheterogenity).\n\t\tGroup oldGroup = getGroupWithSameResNumButDiffPDBName();\n\t\tif (oldGroup!= null){\n\t\t\tGroup altLocG = group;\n\t\t\tgroup = oldGroup;\n\t\t\tgroup.addAltLoc(altLocG);\n\t\t\tchain.getAtomGroups().remove(altLocG);\n\t\t\treturn altLocG;\n\t\t}\n\t\t// no matching altLoc group found.\n\t\t// build it up.\n\t\tif (group.getAtoms().size() == 0) {\n\t\t\treturn group;\n\t\t}\n\t\tGroup altLocG = (Group) group.clone();\n\t\t// drop atoms from cloned group...\n\t\t// https://redmine.open-bio.org/issues/3307\n\t\taltLocG.setAtoms(new ArrayList<Atom>());\n\t\taltLocG.getAltLocs().clear();\n\t\tgroup.addAltLoc(altLocG);\n\t\treturn altLocG;\n\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setXtalInfo(java.lang.String, java.util.List)\n\t */\n\t@Override\n\tpublic void setXtalInfo(String spaceGroupString, float[] unitCell, double[][] ncsOperMatrixList) {\n\t\t// Now set the xtalographic information\n\t\tPDBCrystallographicInfo pci = new PDBCrystallographicInfo();\n\t\tSpaceGroup spaceGroup = SpaceGroup.parseSpaceGroup(spaceGroupString);\n\t\tpci.setSpaceGroup(spaceGroup);\n\t\tif (unitCell.length > 0) {\n\t\t\tCrystalCell cell = new CrystalCell(unitCell[0], unitCell[1],\n\t\t\t\t\tunitCell[2], unitCell[3], unitCell[4], unitCell[5]);\n\t\t\tpci.setCrystalCell(cell);\n\t\t\tstructure.setCrystallographicInfo(pci);\n\t\t}\n\n\t\tpci.setNcsOperators(MmtfUtils.getNcsAsMatrix4d(ncsOperMatrixList));\n\t}\n\n\n\t/**\n\t * Get the type of group (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n\t * @param polymerType\n\t * @return The type of group. (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n\t */\n\tprivate int getGroupTypIndicator(PolymerType polymerType) {\n\t\tif(PolymerType.PROTEIN_ONLY.contains(polymerType)){\n\t\t\treturn 1;\n\t\t}\n\t\tif(PolymerType.POLYNUCLEOTIDE_ONLY.contains(polymerType)){\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\t@Override\n\tpublic void setBioAssemblyTrans(int bioAssemblyId, int[] inputChainIndices, double[] inputTransform, String name) {\n\t\t// Biojava uses this as a one indexed id.\n\t\tbioAssemblyId++;\n\t\tif(bioassIndex!=bioAssemblyId){\n\t\t\ttransformList = new ArrayList<>();\n\t\t\tbioassIndex = bioAssemblyId;\n\t\t}\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\t// Get the bioassembly data\n\t\tMap<Integer, BioAssemblyInfo> bioAssemblies = pdbHeader.getBioAssemblies();\n\t\t// Get the bioassembly itself (if it exists\n\t\tBioAssemblyInfo bioAssInfo;\n\t\tif (bioAssemblies.containsKey(bioAssemblyId)){\n\t\t\tbioAssInfo = bioAssemblies.get(bioAssemblyId);\n\t\t}\n\t\telse{\n\t\t\tbioAssInfo = new  BioAssemblyInfo();\n\t\t\tbioAssInfo.setTransforms(new ArrayList<BiologicalAssemblyTransformation>());\n\t\t\tbioAssemblies.put(bioAssemblyId, bioAssInfo);\n\t\t\tbioAssInfo.setId(bioAssemblyId);\n\t\t}\n\n\t\tfor(int currChainIndex : inputChainIndices){\n\t\t\tBiologicalAssemblyTransformation bioAssTrans = new BiologicalAssemblyTransformation();\n\t\t\tInteger transId = transformList.indexOf(inputTransform)+1;\n\t\t\tif(transId==0){\n\t\t\t\ttransformList.add(inputTransform);\n\t\t\t\ttransId = transformList.indexOf(inputTransform)+1;\n\t\t\t}\n\t\t\tbioAssTrans.setId(transId.toString());\n\t\t\t// If it actually has an index - if it doesn't it is because the chain has no density.\n\t\t\tif (currChainIndex!=-1){\n\t\t\t\tbioAssTrans.setChainId(chainList.get(currChainIndex).getId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Now set matrix\n\t\t\tMatrix4d mat4d = new Matrix4d(inputTransform);\n\t\t\tbioAssTrans.setTransformationMatrix(mat4d);\n\t\t\t// Now add this\n\t\t\tbioAssInfo.getTransforms().add(bioAssTrans);\n\t\t\t// sort transformations into a unique order\n\t\t\tCollections.sort(bioAssInfo.getTransforms());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setEntityInfo(int[] chainIndices, String sequence, String description, String type) {\n\t\t// First get the chains\n\t\tEntityInfo entityInfo = new EntityInfo();\n\t\tentityInfo.setDescription(description);\n\t\tentityInfo.setType(EntityType.entityTypeFromString(type));\n\t\tList<Chain> chains = new ArrayList<>();\n\t\t// Now loop through the chain ids and make a list of them\n\t\tfor( int index : chainIndices) {\n\t\t\tchains.add(chainList.get(index));\n\t\t\tchainList.get(index).setEntityInfo(entityInfo);\n\t\t\tchainSequenceMap.put(chainList.get(index).getId(), sequence);\n\t\t}\n\t\tentityInfo.setChains(chains);\n\t\tentityInfoList.add(entityInfo);\n\t}\n\n\t@Override\n\tpublic void setHeaderInfo(float rFree, float rWork, float resolution, String title, String depositionDate,\n\t\t\tString releaseDate, String[] experimentalMethods) {\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\t// Get the pdb header\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\tpdbHeader.setTitle(title);\n\t\tpdbHeader.setResolution(resolution);\n\t\tpdbHeader.setRfree(rFree);\n\t\tpdbHeader.setRwork(rWork);\n\t\t// Now loop through the techniques and add them in\n\t\tif (experimentalMethods!=null) {\n\t\t\tfor (String techniqueStr : experimentalMethods) {\n\t\t\t\tpdbHeader.setExperimentalTechnique(techniqueStr);\n\t\t\t}\n\t\t}\n\t\t// Set the dates\n\t\tif(depositionDate!=null){\n\t\t\ttry {\n\t\t\t\tDate depDate = formatter.parse(depositionDate);\n\t\t\t\tpdbHeader.setDepDate(depDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tlogger.warn(\"Could not parse date string '{}', depositon date will be unavailable\", depositionDate);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpdbHeader.setDepDate(new Date(0));\n\t\t}\n\t\tif(releaseDate!=null){\n\t\t\ttry {\n\t\t\t\tDate relDate = formatter.parse(releaseDate);\n\t\t\t\tpdbHeader.setRelDate(relDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tlogger.warn(\"Could not parse date string '{}', release date will be unavailable\", releaseDate);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpdbHeader.setRelDate(new Date(0));\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.Serializable;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.BondImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Element;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.EntityType;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.HetatomImpl;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.io.mmcif.chem.PolymerType;\nimport org.biojava.nbio.structure.io.mmcif.chem.ResidueType;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.api.StructureAdapterInterface;\nimport org.rcsb.mmtf.dataholders.MmtfStructure;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * A biojava specific structure inflator for MMTF.\n * Should be ported to biojava code.\n *\n * @author Anthony Bradley\n * @since 5.0\n * \n */\npublic class MmtfStructureReader implements StructureAdapterInterface, Serializable {\n\n\t/** The Constant serialVersionUID. */\n\tprivate static final long serialVersionUID = 6772030485225130853L;\n\n\t/** The logger */\n\tprivate static final Logger logger = LoggerFactory.getLogger(MmtfStructureReader.class);\n\n\t/** The structure. */\n\tprivate Structure structure;\n\n\t/** The model number. */\n\tprivate int modelNumber;\n\n\t/** The chain. */\n\tprivate Chain chain;\n\n\t/** The group. */\n\tprivate Group group;\n\n\t/** The atoms in a group. */\n\tprivate List<Atom> atomsInGroup;\n\n\t/** All the atoms. */\n\tprivate Atom[] allAtoms;\n\tprivate int atomCounter;\n\n\t/** The list of EntityInformation */\n\tprivate List<EntityInfo> entityInfoList;\n\n\t/** All the chains */\n\tprivate List<Chain> chainList;\n\n\t/** All the chains as a list of maps */\n\tprivate List<LinkedHashMap<String,Chain>> chainMap;\n\n\tprivate List<double[]> transformList;\n\n\tprivate int bioassIndex;\n\n\tprivate Map<String,String> chainSequenceMap;\n\n\t/**\n\t * Instantiates a new bio java structure decoder.\n\t */\n\tpublic MmtfStructureReader() {\n\t\tstructure = new StructureImpl();\n\t\tmodelNumber = 0;\n\t\tentityInfoList = new ArrayList<>();\n\t\tchainList = new ArrayList<>();\n\t\tchainMap = new ArrayList<>();\n\t\ttransformList = new ArrayList<>();\n\t\tchainSequenceMap = new HashMap<>();\n\t}\n\n\t/**\n\t * Gets the structure.\n\t *\n\t * @return the structure\n\t */\n\tpublic Structure getStructure() {\n\t\treturn structure;\n\t}\n\n\t@Override\n\tpublic void finalizeStructure() {\n\t\t// Number the remaining ones\n\t\tint counter =0;\n\t\t// Add the entity info\n\t\tfor (EntityInfo entityInfo : entityInfoList) {\n\t\t\tcounter++;\n\t\t\tentityInfo.setMolId(counter);\n\t\t}\n\t\tstructure.setEntityInfos(entityInfoList);\n\t\t// Add the actual chains\n\t\tfor(int i=0; i<chainMap.size(); i++) {\n\t\t\t// Now add the chain information\n\t\t\tMap<String, Chain> modelChainMap = chainMap.get(i);\n\t\t\tfor(Chain modelChain : modelChainMap.values()){\n\t\t\t\tstructure.addChain(modelChain, i);\n\t\t\t\tString sequence = chainSequenceMap.get(modelChain.getId());\n\t\t\t\tif (sequence == null) {\n\t\t\t\t\tlogger.warn(\"Sequence is null for chain with asym_id {}. Most likely the chain is non-polymeric. Will not add seqres groups for it.\", modelChain.getId());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tMmtfUtils.addSeqRes(modelChain, sequence);\n\t\t\t}\n\t\t}\n\t\tStructureTools.cleanUpAltLocs(structure);\n\t}\n\n\t@Override\n\tpublic void initStructure(int totalNumBonds, int totalNumAtoms, int totalNumGroups,\n\t\t\tint totalNumChains, int totalNumModels, String modelId) {\n\t\tstructure.setPDBCode(modelId);\n\t\tallAtoms = new Atom[totalNumAtoms];\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#setModelInfo(int, int)\n\t */\n\t@Override\n\tpublic void setModelInfo(int inputModelNumber,\n\t\t\tint chainCount) {\n\t\tmodelNumber = inputModelNumber;\n\t\tstructure.addModel(new ArrayList<Chain>(chainCount));\n\t\tchainMap.add(new LinkedHashMap<>());\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setChainInfo(java.lang.String, int)\n\t */\n\t@Override\n\tpublic void setChainInfo(String chainId, String chainName, int groupCount) {\n\t\t// First check to see if the chain exists\n\t\tMap<String, Chain> modelChainMap = chainMap.get(modelNumber);\n\t\tif(modelChainMap.containsKey(chainId)){\n\t\t\tchain = modelChainMap.get(chainId);\n\t\t}\n\t\t// If we need to set a new chain do this\n\t\telse{\n\t\t\tchain = new ChainImpl();\n\t\t\tchain.setId(chainId.trim());\n\t\t\tchain.setName(chainName);\n\t\t\tchain.setAtomGroups(new ArrayList<>(groupCount));\n\t\t\tmodelChainMap.put(chainId, chain);\n\t\t\tchainList.add(chain);\n\t\t}\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setGroupInfo(java.lang.String, int, char, int, int)\n\t */\n\t@Override\n\tpublic void setGroupInfo(String groupName, int groupNumber,\n\t\t\tchar insertionCode, String chemCompType, int atomCount, int bondCount,\n\t\t\tchar singleLetterCode, int sequenceIndexId, int secStructType) {\n\t\t// Get the polymer type\n\t\tResidueType residueType = ResidueType.getResidueTypeFromString(chemCompType);\n\t\tif (residueType == null)\n\t\t\tthrow new IllegalStateException(\"Couldn't resolve residue type for \"+ chemCompType);\n\n\t\tint polymerType = getGroupTypIndicator(residueType.polymerType);\n\t\tswitch (polymerType) {\n\t\tcase 1:\n\t\t\tAminoAcid aa = new AminoAcidImpl();\n\t\t\t// Now set the one letter code\n\t\t\taa.setAminoType(singleLetterCode);\n\t\t\tgroup = aa;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tgroup = new NucleotideImpl();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgroup = new HetatomImpl();\n\t\t\tbreak;\n\t\t}\n\t\tatomsInGroup = new ArrayList<>();\n\t\tChemComp chemComp = new ChemComp();\n\t\tchemComp.setOne_letter_code(String.valueOf(singleLetterCode));\n\t\tchemComp.setType(chemCompType.toUpperCase());\n\t\tchemComp.setResidueType(residueType);\n\t\tchemComp.setPolymerType(residueType.polymerType);\n\t\tgroup.setChemComp(chemComp);\n\t\tgroup.setPDBName(groupName);\n\t\tif (insertionCode == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {\n\t\t\tgroup.setResidueNumber(chain.getName().trim(), groupNumber, null);\n\t\t} else {\n\t\t\tgroup.setResidueNumber(chain.getName().trim(),\n\t\t\t\t\tgroupNumber, insertionCode);\n\t\t}\n\t\tgroup.setAtoms(new ArrayList<>(atomCount));\n\t\tif (polymerType==1 || polymerType==2) {\n\t\t\tMmtfUtils.insertSeqResGroup(chain, group, sequenceIndexId);\n\t\t}\n\t\tif (atomCount > 0) {\n\t\t\tchain.addGroup(group);\n\t\t}\n\t\tMmtfUtils.setSecStructType(group, secStructType);\n\t}\n\n\t/**\n\t *\n\t * @return\n\t */\n\tprivate Group getGroupWithSameResNumButDiffPDBName() {\n\t\t// If this chain already has this group number\n\t\tfor (Group g : chain.getAtomGroups() ) {\n\t\t\tif (g.getResidueNumber().equals(group.getResidueNumber())) {\n\t\t\t\tif( ! g.getPDBName().equals(group.getPDBName() )){\n\t\t\t\t\treturn g;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setAtomInfo(java.lang.String, int, char, float, float,\n\t * float, float, float, java.lang.String, int)\n\t */\n\t@Override\n\tpublic void setAtomInfo(String atomName,\n\t\t\tint serialNumber, char alternativeLocationId, float x,\n\t\t\tfloat y, float z, float occupancy,\n\t\t\tfloat temperatureFactor,\n\t\t\tString element, int charge) {\n\t\tAtom atom = new AtomImpl();\n\t\tGroup altGroup = null;\n\t\tatom.setPDBserial(serialNumber);\n\t\tatom.setName(atomName.trim());\n\t\tatom.setElement(Element.valueOfIgnoreCase(element));\n\t\tif(alternativeLocationId==MmtfStructure.UNAVAILABLE_CHAR_VALUE){\n\t\t\talternativeLocationId = ' ';\n\t\t}\n\t\tif (alternativeLocationId != ' ') {\n\t\t\t// Get the altGroup\n\t\t\taltGroup = getCorrectAltLocGroup(alternativeLocationId);\n\t\t\tatom.setAltLoc(alternativeLocationId);\n\t\t} else {\n\t\t\tatom.setAltLoc(Character.valueOf(' '));\n\t\t}\n\t\tatom.setX(x);\n\t\tatom.setY(y);\n\t\tatom.setZ(z);\n\t\tatom.setOccupancy(occupancy);\n\t\tatom.setTempFactor(temperatureFactor);\n\t\tatom.setCharge((short) charge);\n\t\tif (altGroup == null) {\n\t\t\tgroup.addAtom(atom);\n\t\t} else {\n\t\t\taltGroup.setChain(chain);\n\t\t\taltGroup.addAtom(atom);\n\t\t}\n\n\t\t// IF the main group doesn't have this atom\n\t\tif (!group.hasAtom(atom.getName())) {\n\n\t\t\t// If it's not a microheterogenity case\n\t\t\tif (group.getPDBName().equals(atom.getGroup().getPDBName())) {\n\t\t\t\t// And it's not a deuterated case.  'nanoheterogenity'\n\t\t\t\tif(!StructureTools.hasNonDeuteratedEquiv(atom,group)){\n\t\t\t\t\tgroup.addAtom(atom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tatomsInGroup.add(atom);\n\t\tallAtoms[atomCounter] = atom;\n\t\tatomCounter++;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInter\n\t * face#setGroupBonds(int, int, int)\n\t */\n\t@Override\n\tpublic void setGroupBond(int indOne, int indTwo, int bondOrder) {\n\t\t\n\t\t// Get the atoms\n\t\tAtom atomOne = atomsInGroup.get(indOne);\n\t\tAtom atomTwo = atomsInGroup.get(indTwo);\n\t\t\n\t\t// set the new bond\n\t\tnew BondImpl(atomOne, atomTwo, bondOrder);\n\t\t\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoder\n\t * Interface#setInterGroupBonds(int, int, int)\n\t */\n\t@Override\n\tpublic void setInterGroupBond(int indOne, int indTwo, int bondOrder) {\n\t\t\n\t\t// Get the atoms\n\t\tAtom atomOne = allAtoms[indOne];\n\t\tAtom atomTwo = allAtoms[indTwo];\n\t\t\n\t\t// set the new bond (this \n\t\tnew BondImpl(atomOne, atomTwo, bondOrder);\n\t}\n\n\n\t/**\n\t * Generates Alternate location groups.\n\t *\n\t * @param altLoc the alt loc\n\t * @return the correct alt loc group\n\t */\n\tprivate Group getCorrectAltLocGroup(Character altLoc) {\n\t\t// see if we know this altLoc already;\n\t\tList<Atom> atoms = group.getAtoms();\n\t\tif (atoms.size() > 0) {\n\t\t\tAtom a1 = atoms.get(0);\n\t\t\t// we are just adding atoms to the current group\n\t\t\t// probably there is a second group following later...\n\t\t\tif (a1.getAltLoc().equals(altLoc)) {\n\t\t\t\treturn group;\t}\n\t\t}\n\n\t\t// Get the altLocGroup\n\t\tGroup altLocgroup = group.getAltLocGroup(altLoc);\n\t\tif (altLocgroup != null) {\n\t\t\treturn altLocgroup;\n\t\t}\n\t\t// If the group already exists (microheterogenity).\n\t\tGroup oldGroup = getGroupWithSameResNumButDiffPDBName();\n\t\tif (oldGroup!= null){\n\t\t\tGroup altLocG = group;\n\t\t\tgroup = oldGroup;\n\t\t\tgroup.addAltLoc(altLocG);\n\t\t\tchain.getAtomGroups().remove(altLocG);\n\t\t\treturn altLocG;\n\t\t}\n\t\t// no matching altLoc group found.\n\t\t// build it up.\n\t\tif (group.getAtoms().size() == 0) {\n\t\t\treturn group;\n\t\t}\n\t\tGroup altLocG = (Group) group.clone();\n\t\t// drop atoms from cloned group...\n\t\t// https://redmine.open-bio.org/issues/3307\n\t\taltLocG.setAtoms(new ArrayList<Atom>());\n\t\taltLocG.getAltLocs().clear();\n\t\tgroup.addAltLoc(altLocG);\n\t\treturn altLocG;\n\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setXtalInfo(java.lang.String, java.util.List)\n\t */\n\t@Override\n\tpublic void setXtalInfo(String spaceGroupString, float[] unitCell, double[][] ncsOperMatrixList) {\n\t\t// Now set the xtalographic information\n\t\tPDBCrystallographicInfo pci = new PDBCrystallographicInfo();\n\t\tSpaceGroup spaceGroup = SpaceGroup.parseSpaceGroup(spaceGroupString);\n\t\tpci.setSpaceGroup(spaceGroup);\n\t\tif (unitCell.length > 0) {\n\t\t\tCrystalCell cell = new CrystalCell(unitCell[0], unitCell[1],\n\t\t\t\t\tunitCell[2], unitCell[3], unitCell[4], unitCell[5]);\n\t\t\tpci.setCrystalCell(cell);\n\t\t\tstructure.setCrystallographicInfo(pci);\n\t\t}\n\n\t\tpci.setNcsOperators(MmtfUtils.getNcsAsMatrix4d(ncsOperMatrixList));\n\t}\n\n\n\t/**\n\t * Get the type of group (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n\t * @param polymerType\n\t * @return The type of group. (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n\t */\n\tprivate int getGroupTypIndicator(PolymerType polymerType) {\n\t\tif(PolymerType.PROTEIN_ONLY.contains(polymerType)){\n\t\t\treturn 1;\n\t\t}\n\t\tif(PolymerType.POLYNUCLEOTIDE_ONLY.contains(polymerType)){\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\n\t@Override\n\tpublic void setBioAssemblyTrans(int bioAssemblyId, int[] inputChainIndices, double[] inputTransform, String name) {\n\t\t// Biojava uses this as a one indexed id.\n\t\tbioAssemblyId++;\n\t\tif(bioassIndex!=bioAssemblyId){\n\t\t\ttransformList = new ArrayList<>();\n\t\t\tbioassIndex = bioAssemblyId;\n\t\t}\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\t// Get the bioassembly data\n\t\tMap<Integer, BioAssemblyInfo> bioAssemblies = pdbHeader.getBioAssemblies();\n\t\t// Get the bioassembly itself (if it exists\n\t\tBioAssemblyInfo bioAssInfo;\n\t\tif (bioAssemblies.containsKey(bioAssemblyId)){\n\t\t\tbioAssInfo = bioAssemblies.get(bioAssemblyId);\n\t\t}\n\t\telse{\n\t\t\tbioAssInfo = new  BioAssemblyInfo();\n\t\t\tbioAssInfo.setTransforms(new ArrayList<BiologicalAssemblyTransformation>());\n\t\t\tbioAssemblies.put(bioAssemblyId, bioAssInfo);\n\t\t\tbioAssInfo.setId(bioAssemblyId);\n\t\t}\n\n\t\tfor(int currChainIndex : inputChainIndices){\n\t\t\tBiologicalAssemblyTransformation bioAssTrans = new BiologicalAssemblyTransformation();\n\t\t\tInteger transId = transformList.indexOf(inputTransform)+1;\n\t\t\tif(transId==0){\n\t\t\t\ttransformList.add(inputTransform);\n\t\t\t\ttransId = transformList.indexOf(inputTransform)+1;\n\t\t\t}\n\t\t\tbioAssTrans.setId(transId.toString());\n\t\t\t// If it actually has an index - if it doesn't it is because the chain has no density.\n\t\t\tif (currChainIndex!=-1){\n\t\t\t\tbioAssTrans.setChainId(chainList.get(currChainIndex).getId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Now set matrix\n\t\t\tMatrix4d mat4d = new Matrix4d(inputTransform);\n\t\t\tbioAssTrans.setTransformationMatrix(mat4d);\n\t\t\t// Now add this\n\t\t\tbioAssInfo.getTransforms().add(bioAssTrans);\n\t\t\t// sort transformations into a unique order\n\t\t\tCollections.sort(bioAssInfo.getTransforms());\n\t\t}\n\t}\n\n\t@Override\n\tpublic void setEntityInfo(int[] chainIndices, String sequence, String description, String type) {\n\t\t// First get the chains\n\t\tEntityInfo entityInfo = new EntityInfo();\n\t\tentityInfo.setDescription(description);\n\t\tentityInfo.setType(EntityType.entityTypeFromString(type));\n\t\tList<Chain> chains = new ArrayList<>();\n\t\t// Now loop through the chain ids and make a list of them\n\t\tfor( int index : chainIndices) {\n\t\t\tchains.add(chainList.get(index));\n\t\t\tchainList.get(index).setEntityInfo(entityInfo);\n\t\t\tchainSequenceMap.put(chainList.get(index).getId(), sequence);\n\t\t}\n\t\tentityInfo.setChains(chains);\n\t\tentityInfoList.add(entityInfo);\n\t}\n\n\t@Override\n\tpublic void setHeaderInfo(float rFree, float rWork, float resolution, String title, String depositionDate,\n\t\t\tString releaseDate, String[] experimentalMethods) {\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\t// Get the pdb header\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\tpdbHeader.setTitle(title);\n\t\tpdbHeader.setResolution(resolution);\n\t\tpdbHeader.setRfree(rFree);\n\t\tpdbHeader.setRwork(rWork);\n\t\t// Now loop through the techniques and add them in\n\t\tif (experimentalMethods!=null) {\n\t\t\tfor (String techniqueStr : experimentalMethods) {\n\t\t\t\tpdbHeader.setExperimentalTechnique(techniqueStr);\n\t\t\t}\n\t\t}\n\t\t// Set the dates\n\t\tif(depositionDate!=null){\n\t\t\ttry {\n\t\t\t\tDate depDate = formatter.parse(depositionDate);\n\t\t\t\tpdbHeader.setDepDate(depDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tlogger.warn(\"Could not parse date string '{}', depositon date will be unavailable\", depositionDate);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpdbHeader.setDepDate(new Date(0));\n\t\t}\n\t\tif(releaseDate!=null){\n\t\t\ttry {\n\t\t\t\tDate relDate = formatter.parse(releaseDate);\n\t\t\t\tpdbHeader.setRelDate(relDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\tlogger.warn(\"Could not parse date string '{}', release date will be unavailable\", releaseDate);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tpdbHeader.setRelDate(new Date(0));\n\t\t}\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.io.mmtf;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.IOException;\nimport java.nio.file.Paths;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Test the Biojava MMTF reader.\n * \n * @author Anthony Bradley\n * @author Aleix Lafita\n *\n */\npublic class TestMmtfStructureReader {\n\n\t/**\n\t * Test reading an MMTF file into a BioJava structure.\n\t */\n\t@Test\n\tpublic void testRead() throws IOException {\n\t\t\n\t\t// Get the MMTF file from the resources folder\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\tString resource = \"org/biojava/nbio/structure/io/mmtf/4CUP.mmtf\";\n\t\t\n\t\t// Load the structure into memory\n\t\tStructure structure = MmtfActions.readFromFile((\n\t\t\t\tPaths.get(classLoader.getResource(resource).getPath())));\n\t\t\n\t\t// Check header properties of the structure\n\t\tassertEquals(structure.getPDBCode(), \"4CUP\");\n\t\tassertEquals(MmtfUtils.dateToIsoString(structure.getPDBHeader().getDepDate()), \n\t\t\t\t\"2014-03-21\");\n\t\t\n\t\tassertEquals(structure.getChains().size(), 6);\n\t}\n\t\n\t/**\n\t * Compare structures loaded from MMCIF and MMTF files.\n\t */\n\t@Test\n\tpublic void compareMmcif() throws IOException, StructureException {\n\t\t\n\t\t// Get the MMTF and MMCIF files from the resources folder\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\tString resource = \"org/biojava/nbio/structure/io/mmtf/4CUP\";\n\t\t\n\t\t// Load the structures into memory\n\t\tStructure mmtf = MmtfActions.readFromFile((\n\t\t\t\tPaths.get(classLoader.getResource(resource + \".mmtf\").getPath())));\n\t\tStructure mmcif = StructureIO.getStructure(classLoader.getResource(resource + \".cif\").getPath());\n\t\t\n\t\t// Compare the dates of the structure\n\t\tassertEquals(mmcif.getPDBHeader().getDepDate(), \n\t\t\t\tmmtf.getPDBHeader().getDepDate());\n\t\t\n\t\t// Compare the experimental method\n\t\tassertEquals(mmcif.getPDBHeader().getExperimentalTechniques(), \n\t\t\t\tmmtf.getPDBHeader().getExperimentalTechniques());\n\t\t\n\t\t// Compare the SEQRES, see issue https://github.com/biojava/biojava/issues/671\n\t\tassertEquals(mmcif.getChainByIndex(0).getSeqResSequence(), \n\t\t\t\tmmtf.getChainByIndex(0).getSeqResSequence());\n\t\t\n\t}\n\n\t/**\n\t * Test for issue https://github.com/biojava/biojava/issues/792\n\t */\n\t@Test\n\t@Ignore(\"Issue not fixed yet\")\n\tpublic void checkNonStandardAminoSeqresGroupsPopulated() throws StructureException, IOException {\n\t    // 2X3T, see issue https://github.com/biojava/biojava/issues/792\n        // Load a structure in mmtf format\n        AtomCache cache = new AtomCache();\n        FileParsingParameters params = new FileParsingParameters();\n        cache.setFileParsingParams(params);\n        cache.setUseMmCif(false);\n        cache.setUseMmtf(true);\n\n        StructureIO.setAtomCache(cache);\n\n        ChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider());\n\n        Structure structure1 = StructureIO.getStructure(\"2X3T\");\n        // chain E is a glycopeptide with unobserved non-standard aminoacids. Because of mmtf limitations (representing seqres sequences as 1-letter strings) the non-standard unobserved residues are read as null\n        List<Group> seqresGroups = structure1.getChain(\"E\").getSeqResGroups();\n        for (Group g : seqresGroups) {\n            assertNotNull(\"SeqRes group should not be null\", g);\n        }\n\n    }\n\n}\n","changedTest":"","commitMessage":"Update MmtfStructureReader.java","test_commitMessage":"","allZero":false}