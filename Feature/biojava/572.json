{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/mmtf/MmtfUtils.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/mmtf/TestMmtfUtils.java","prod_time":"2016-04-20 02:17:07","test_time":"2016-04-20 02:17:07","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":1,"del_annotation_line":1,"del_call_line":20,"del_classname_line":0,"del_condition_line":6,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":6,"del_return_line":4,"label":"POSITIVE","prod_commitID":"789765abaa7ccea4b7572337222c928bf31043d6","test_commitID":"789765abaa7ccea4b7572337222c928bf31043d6","isfound":"found test change","originPro":"package org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.FileNotFoundException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava. - with an extra URL\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\t//\t\tCustomChemCompProvider cc = new CustomChemCompProvider();\n\t\t//\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\t//\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to get all the atoms in the strucutre as a list.\n\t * @param bioJavaStruct the biojava structure\n\t * @return a list of all the unique atoms in the structure\n\t */\n\tpublic static List<Atom> getAllAtoms(Structure bioJavaStruct) {\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tfor(Atom a: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(a);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Function to get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\n\t/**\n\t * Function to generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\ttry{\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t}\n\t\t\tcatch(FileNotFoundException enew){\n\t\t\t}\n\t\t\tcatch(Exception bige){\n\t\t\t\tSystem.out.println(bige);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform -> chainindices it relates to\n\t * @param bioassemblyInfo\n\t * @param chainIdToIndexMap \n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t\tMap<Matrix4d, List<Integer>> matMap = new HashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\t\tMap<double[], int[]> outMap = new HashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tprivate static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Get a list of all the chains in a structure.\n\t * @param structure the input structure\n\t * @return the list of chains\n\t */\n\tpublic static List<Chain> getAllChains(Structure structure) {\n\t\tList<Chain> chainList = new ArrayList<>();\n\t\tfor (int i=0; i<structure.nrModels(); i++) {\n\t\t\tchainList.addAll(structure.getChains(i));\n\t\t}\n\t\treturn chainList;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Get the number of unique bonds in the strucutre.\n\t * @param allAtoms\n\t * @return the number of bonds\n\t */\n\tpublic static int getNumBonds(List<Atom> allAtoms) {\n\t\tint bondCount = 0;\n\t\tfor(int indexAtomOne=0;indexAtomOne<allAtoms.size();indexAtomOne++) {\n\t\t\tAtom atomOne = allAtoms.get(indexAtomOne);\n\t\t\tif(atomOne.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atomOne.getBonds()) {\n\t\t\t\tif(allAtoms.indexOf(bond.getOther(atomOne))>indexAtomOne){\n\t\t\t\t\tbondCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCount;\n\t}\t\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\t@SuppressWarnings(\"unused\")\n\t\tSecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNMENT\",getSecStructType(dsspIndex));\n\t}\n\n\n\tprivate static SecStrucType getSecStructType(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Function to get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getChainID();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.FileNotFoundException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava. - with an extra URL\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\t//\t\tCustomChemCompProvider cc = new CustomChemCompProvider();\n\t\t//\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\t//\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Function to generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\ttry{\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t}\n\t\t\tcatch(FileNotFoundException enew){\n\t\t\t}\n\t\t\tcatch(Exception bige){\n\t\t\t\tSystem.out.println(bige);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform, chainindices it relates to.\n\t * @param bioassemblyInfo  the bioassembly info object for this structure\n\t * @param chainIdToIndexMap the map of chain ids to the index that chain corresponds to.\n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t\tMap<Matrix4d, List<Integer>> matMap = new HashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\t\tMap<double[], int[]> outMap = new HashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tpublic static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\n\t/**\n\t * Function to get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\t SecStrucType secStrucType = getSecStructTypeFromDsspIndex(dsspIndex);\n\t\t SecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNED\", secStrucType);\n\t\t if(secStrucType!=null){\n\t\t group.setProperty(\"secstruc\", secStrucState);\n\t\t }\n\t\t else{\n\t\t }\n\t}\n\n\t\n\t/**\n\t * Helper function to set the DSSP type based on a numerical index.\n\t * @param dsspIndex the integer index of the type to set\n\t * @return the instance of the SecStrucType object holding this secondary\n\t * structure type.\n\t */\n\tpublic static SecStrucType getSecStructTypeFromDsspIndex(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Function to get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getChainID();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.io.mmtf;\n\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.io.mmtf.MmtfUtils;\n\n/**\n * Test the MMTF utils class\n * @author Anthony Bradley\n *\n */\npublic class TestMmtfUtils {\n\t\n\t/**\n\t * Integration test to see that the microheterogenity is being dealt with correctly.\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void microHeterogenity() throws IOException, StructureException {\n\t\tMmtfUtils.setUpBioJava();\n\t\tStructure inputStructure = StructureIO.getStructure(\"4ck4\");\n\t\t// Count the number of groups\n\t\tGroup before = inputStructure.getChains().get(0).getAtomGroup(17);\n\t\tassertTrue(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t    List<Atom> totalAtoms = new ArrayList<>(MmtfUtils.getAllAtoms(inputStructure));\n\t\tint totGroups = 0;\n\t\tint totAtomsCounter = 0;\n\t\tSet<Atom> totAtoms = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroups += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounter+=g.getAtoms().size();\n\t\t\t\ttotAtoms.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsCounter+=alt.getAtoms().size();\n\t\t\t\t\ttotAtoms.addAll(alt.getAtoms());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Now \"fix\" the microheterogenity\n\t\tMmtfUtils.fixMicroheterogenity(inputStructure);\n\t\tassertEquals(before, inputStructure.getChains().get(0).getAtomGroup(17));\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(18).hasAltLoc());\n\t\tint totGroupsAfter = 0;\n\t\tint totAtomsCounterAfter = 0;\n\t\tSet<Atom> totAtomsAfter = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroupsAfter += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounterAfter+=g.getAtoms().size();\n\t\t\t\ttotAtomsAfter.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsAfter.addAll(alt.getAtoms());\n\t\t\t\t\ttotAtomsCounterAfter+=alt.getAtoms().size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Find the atoms after the fix.\n\t    List<Atom> totalAtomsAfter = new ArrayList<>(MmtfUtils.getAllAtoms(inputStructure));\n\t\t// Get all of the duplicate atoms\n\t\tSet<Atom> duplicates = findDuplicates(totalAtomsAfter);\n\t\tfor (Atom a : duplicates) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t// There should be no duplicates\n\t\tassertEquals(duplicates.size(), 0);\n\t    assertEquals(totalAtoms.size(), totalAtomsAfter.size());\n\t\t// Check there are two more groups afterwards\n\t\tassertEquals(totGroupsAfter-2, totGroups);\n\t\t// Check there are no more atoms afterwards\n\t\tassertEquals(totAtomsAfter.size(), totAtoms.size());\n\t\t// Check the counter are the same too\n\t\tassertEquals(totAtomsCounterAfter, totAtomsCounter);\n\t\t\n\t}\n\t\n\t\n//TODO ADD TESTS FOR THESE FUNCTIONS\n//\tgetAllAtoms\n//\t\n//\tgetAtomsForGroup\n//\t\n//\tcalculateDsspSecondaryStructure\n//\t\n//\tsetHeaderInfo\n//\t\n//\tgenerateSerializableBioAssembly\n//\n//\tgetChainIdToIndexMap\n\t\n\tprivate Set<Atom> findDuplicates(List<Atom> listContainingDuplicates)\n\t{ \n\t  final Set<Atom> setToReturn = new HashSet<>(); \n\t  final Set<Atom> set1 = new HashSet<>();\n\n\t  for (Atom yourInt : listContainingDuplicates)\n\t  {\n\t   if (!set1.add(yourInt))\n\t   {\n\t    setToReturn.add(yourInt);\n\t   }\n\t  }\n\t  return setToReturn;\n\t}\n}\n\n","changedTest":"package org.biojava.nbio.structure.io.mmtf;\n\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.BondImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.HetatomImpl;\nimport org.biojava.nbio.structure.NucleotideImpl;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.io.mmtf.MmtfUtils;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.BravaisLattice;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\n/**\n * Test the MMTF utils class\n * @author Anthony Bradley\n *\n */\npublic class TestMmtfUtils {\n\t\n\t/**\n\t * Integration test to see that the microheterogenity is being dealt with correctly.\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void microHeterogenity() throws IOException, StructureException {\n\t\tMmtfUtils.setUpBioJava();\n\t\tStructure inputStructure = StructureIO.getStructure(\"4ck4\");\n\t\t// Count the number of groups\n\t\tGroup before = inputStructure.getChains().get(0).getAtomGroup(17);\n\t\tassertTrue(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t    List<Atom> totalAtoms = new ArrayList<>(getAllAtoms(inputStructure));\n\t\tint totGroups = 0;\n\t\tint totAtomsCounter = 0;\n\t\tSet<Atom> totAtoms = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroups += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounter+=g.getAtoms().size();\n\t\t\t\ttotAtoms.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsCounter+=alt.getAtoms().size();\n\t\t\t\t\ttotAtoms.addAll(alt.getAtoms());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Now \"fix\" the microheterogenity\n\t\tMmtfUtils.fixMicroheterogenity(inputStructure);\n\t\tassertEquals(before, inputStructure.getChains().get(0).getAtomGroup(17));\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(18).hasAltLoc());\n\t\tint totGroupsAfter = 0;\n\t\tint totAtomsCounterAfter = 0;\n\t\tSet<Atom> totAtomsAfter = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroupsAfter += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounterAfter+=g.getAtoms().size();\n\t\t\t\ttotAtomsAfter.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsAfter.addAll(alt.getAtoms());\n\t\t\t\t\ttotAtomsCounterAfter+=alt.getAtoms().size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Find the atoms after the fix.\n\t    List<Atom> totalAtomsAfter = new ArrayList<>(getAllAtoms(inputStructure));\n\t\t// Get all of the duplicate atoms\n\t\tSet<Atom> duplicates = findDuplicates(totalAtomsAfter);\n\t\tfor (Atom a : duplicates) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t// There should be no duplicates\n\t\tassertEquals(duplicates.size(), 0);\n\t    assertEquals(totalAtoms.size(), totalAtomsAfter.size());\n\t\t// Check there are two more groups afterwards\n\t\tassertEquals(totGroupsAfter-2, totGroups);\n\t\t// Check there are no more atoms afterwards\n\t\tassertEquals(totAtomsAfter.size(), totAtoms.size());\n\t\t// Check the counter are the same too\n\t\tassertEquals(totAtomsCounterAfter, totAtomsCounter);\n\t\t\n\t}\n\t\n\t/**\n\t * Function to get all the atoms in the strucutre as a list.\n\t * @param bioJavaStruct the biojava structure\n\t * @return a list of all the unique atoms in the structure\n\t */\n\tprivate List<Atom> getAllAtoms(Structure bioJavaStruct) {\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tfor(Atom a: MmtfUtils.getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(a);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\t\n\t/**\n\t * Test that getting the space group info as a string works.\n\t */\n\t@Test\n\tpublic void testGetSpaceGroupAsString() {\n\t\tassertEquals(\"NA\", MmtfUtils.getSpaceGroupAsString(null));\n\t\tSpaceGroup spaceGroup = new SpaceGroup(21, 1, 1, \"P212121\", \"P 21 21 21\", BravaisLattice.TRICLINIC);\n\t\tassertEquals(\"P212121\", MmtfUtils.getSpaceGroupAsString(spaceGroup));\n\t}\n\t\n\t/**\n\t * Test that getting the unit cell as an array of doubles works.\n\t */\n\t@Test\n\tpublic void testGetUnitCellAsArray() {\n\t\tPDBCrystallographicInfo xtalInfo = new PDBCrystallographicInfo();\n\t\tCrystalCell cell = new CrystalCell();\n\t\tcell.setA(1.0);\n\t\tcell.setB(2.0);\n\t\tcell.setC(3.0);\n\t\tcell.setAlpha(4.0);\n\t\tcell.setBeta(5.0);\n\t\tcell.setGamma(6.0);\n\t\tfloat[] testArray = new float[] {1.0f,2.0f,3.0f,4.0f,5.0f,6.0f};\n\t\txtalInfo.setCrystalCell(cell);\n\t\tfloat[] outputArray = MmtfUtils.getUnitCellAsArray(xtalInfo);\n\t\tassertArrayEquals(testArray, outputArray, 0.0f);\n\t}\n\t\n\t/**\n\t * Test getting the list of experimental methods as string array.\n\t */\n\t@Test\n\tpublic void testGetExperimentalMethods() {\n\t\tSet<ExperimentalTechnique> experimentalTechniques = new HashSet<>();\n\t\texperimentalTechniques.add(ExperimentalTechnique.XRAY_DIFFRACTION);\n\t\texperimentalTechniques.add(ExperimentalTechnique.ELECTRON_MICROSCOPY);\n\t\tString[] techniques = MmtfUtils.techniquesToStringArray(experimentalTechniques);\n\t\tString[] testTechniques = {\"X-RAY DIFFRACTION\", \"ELECTRON MICROSCOPY\"};\n\t\tArrays.sort(techniques);\n\t\tArrays.sort(testTechniques);\n\t\tassertArrayEquals(testTechniques, techniques);\n\t}\n\t\n\t/**\n\t * Test the conversion of a matrix to an array of doubles.\n\t */\n\t@Test \n\tpublic void testConvertToDoubleArray() {\n\t\tMatrix4d matrix4d = new Matrix4d();\n\t\tmatrix4d.m00 = 0.0;\n\t\tmatrix4d.m01 = 0.1;\n\t\tmatrix4d.m02 = 0.2;\n\t\tmatrix4d.m03 = 0.3;\n\t\tmatrix4d.m10 = 1.0;\n\t\tmatrix4d.m11 = 1.1;\n\t\tmatrix4d.m12 = 1.2;\n\t\tmatrix4d.m13 = 1.3;\n\t\tmatrix4d.m20 = 2.0;\n\t\tmatrix4d.m21 = 2.1;\n\t\tmatrix4d.m22 = 2.2;\n\t\tmatrix4d.m23 = 2.3;\n\t\tmatrix4d.m30 = 3.0;\n\t\tmatrix4d.m31 = 3.1;\n\t\tmatrix4d.m32 = 3.2;\n\t\tmatrix4d.m33 = 3.3;\n\t\tdouble[] testData = new double[] {0.0, 0.1, 0.2, 0.3,\n\t\t\t1.0, 1.1, 1.2, 1.3,\n\t\t\t2.0, 2.1, 2.2, 2.3,\n\t\t\t3.0, 3.1, 3.2, 3.3};\n\t\tassertArrayEquals(testData,MmtfUtils.convertToDoubleArray(matrix4d), 0.0);\n\t}\n\t\n\t/**\n\t * Test to check the conversion of BioassemblyInfo to a primitive map.\n\t */\n\t@Test\n\tpublic void testMakePrimitiveBioasembly() {\n\t\tdouble[] testData = new double[] {0.0, 0.1, 0.2, 0.3,\n\t\t\t1.0, 1.1, 1.2, 1.3,\n\t\t\t2.0, 2.1, 2.2, 2.3,\n\t\t\t3.0, 3.1, 3.2, 3.3};\n\t\tBioAssemblyInfo bioAssemblyInfo = new BioAssemblyInfo();\n\t\tList<BiologicalAssemblyTransformation> transforms = new ArrayList<>();\n\t\tBiologicalAssemblyTransformation biologicalAssemblyTransformation = new BiologicalAssemblyTransformation();\n\t\tbiologicalAssemblyTransformation.setChainId(\"C\");\n\t\tbiologicalAssemblyTransformation.setTransformationMatrix(new Matrix4d(testData));\n\t\ttransforms.add(biologicalAssemblyTransformation);\n\t\tbioAssemblyInfo.setTransforms(transforms);\n\t\t// Map the chain to the second index\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tchainIdToIndexMap.put(\"C\", 2);\n\t\t\n\t\t// Now do the conversion and test they are the same\n\t\tMap<double[], int[]> transMap = MmtfUtils.getTransformMap(bioAssemblyInfo, chainIdToIndexMap);\n\t\tassertArrayEquals(testData, (double[]) transMap.keySet().toArray()[0], 0.0);\n\t\tassertArrayEquals(new int[] {2} , (int[]) transMap.values().toArray()[0]);\n\t}\n\t\n\t\n\t/**\n\t * Test getting the data as an appropriately formatted string.\n\t */\n\tpublic void testGetIsoDateString() {\n\t\tDate inputDate = new Date();\n\t\tinputDate.setTime(86500);\n\t\t// One day after \n\t\tassertEquals(\"1970-01-02\",MmtfUtils.dateToIsoString(inputDate));\n\t}\n\t\n\t/**\n\t * Test getting the number of groups from a structure.\n\t */\n\t@Test\n\tpublic void testGetNumGroups() {\n\t\tStructure structure = new StructureImpl();\n\t\tChain chain = new ChainImpl();\n\t\tGroup groupOne = new  AminoAcidImpl();\n\t\tGroup groupTwo = new HetatomImpl();\n\t\tGroup groupThree = new NucleotideImpl();\n\t\tstructure.addChain(chain);\n\t\tchain.addGroup(groupOne);\n\t\tchain.addGroup(groupTwo);\n\t\tchain.addGroup(groupThree);\n\t\tassertEquals(3,MmtfUtils.getNumGroups(structure));\n\t}\n\t\n\t\n\t/**\n\t * Test getting the correct atoms from a group\n\t */\n\t@Test\n\tpublic void testGetAtomsForGroup() {\n\t\tGroup group = new AminoAcidImpl();\n\t\tGroup altLoc = new AminoAcidImpl();\n\t\tAtom atomOne = new AtomImpl();\n\t\tatomOne.setX(1.00);\n\t\tAtom atomTwo = new AtomImpl();\n\t\tatomTwo.setX(2.00);\n\t\tAtom atomThree = new AtomImpl();\n\t\tatomThree.setX(3.00);\n\t\tatomThree.setAltLoc('B');\n\t\tAtom atomFour = new AtomImpl();\n\t\tatomFour.setX(4.00);\n\t\tList<Atom> inputList = new ArrayList<>();\n\t\tinputList.add(atomOne);\n\t\tinputList.add(atomTwo);\n\t\tinputList.add(atomFour);\n\t\tinputList.add(atomThree);\n\t\tgroup.addAtom(atomOne);\n\t\tgroup.addAtom(atomTwo);\n\t\tgroup.addAtom(atomFour);\n\t\taltLoc.addAtom(atomOne);\n\t\taltLoc.addAtom(atomTwo);\n\t\taltLoc.addAtom(atomThree);\n\t\tgroup.addAltLoc(altLoc);\n\t\tList<Atom> atomList = MmtfUtils.getAtomsForGroup(group);\n\t\tassertEquals(inputList, atomList);\n\t}\n\t\n\t\n\t/**\n\t * Test getting the number of bonds from a list of atoms.\n\t */\n\t@Test\n\tpublic void testGetNumBondsFromGroup() {\n\t\tList<Atom> atoms = new ArrayList<>();\n\t\tAtom atomOne = new AtomImpl();\n\t\tAtom atomTwo = new AtomImpl();\n\t\tAtom atomThree = new AtomImpl();\n\t\tatoms.add(atomOne);\n\t\tatoms.add(atomTwo);\n\t\tatoms.add(atomThree);\n\t\t// Make the same bond twice iwth different atom orders\n\t\tnew BondImpl(atomOne, atomTwo, 2);\n\t\tnew BondImpl(atomTwo, atomOne, 2);\n\t\t// Make the same bond twice\n\t\tnew BondImpl(atomOne, atomThree, 2);\n\t\tnew BondImpl(atomOne, atomThree, 2);\n\t\t// Make this bond twice with different orders\n\t\tnew BondImpl(atomTwo, atomThree, 2);\t\t\n\t\tnew BondImpl(atomTwo, atomThree, 1);\n\t\tassertEquals(3, MmtfUtils.getNumBondsInGroup(atoms));\n\t}\n\t/**\n\t * Test that getting the secondary structure type works.\n\t */\n\t@Test\n\tpublic void testGetSetSecStructType() {\n\t\tGroup group = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(group, 0);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 0);\n\t\tMmtfUtils.setSecStructType(group, 1);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 1);\n\t\tMmtfUtils.setSecStructType(group, 2);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 2);\n\t\tMmtfUtils.setSecStructType(group, 3);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 3);\n\t\tMmtfUtils.setSecStructType(group, 4);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 4);\n\t\tMmtfUtils.setSecStructType(group, 5);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 5);\n\t\tMmtfUtils.setSecStructType(group, 6);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 6);\n\t\tMmtfUtils.setSecStructType(group, 7);\n\t\tassertEquals(MmtfUtils.getSecStructType(group), 7);\n\t\t// Now test two null possibilities\n\t\tGroup newGroup = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(newGroup, -1);\n\t\tassertEquals(MmtfUtils.getSecStructType(newGroup), -1);\t\n\t\t// Now test two null possibilities\n\t\tGroup newerGroup = new AminoAcidImpl();\n\t\tMmtfUtils.setSecStructType(newerGroup, 10);\n\t\tassertEquals(MmtfUtils.getSecStructType(newerGroup), -1);\t\n\t}\n\t\n\t/**\n\t * Test that setting the secondary structure types behaves as expected.\n\t */\n\t@Test\n\tpublic void testGetSecStructTypeFromDsspIndex(){\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(0).name,\"pi Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(1).name,\"Bend\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(2).name,\"alpha Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(3).name,\"Extended\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(4).name,\"3-10 Helix\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(5).name,\"Bridge\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(6).name,\"Turn\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(7).name,\"Coil\");\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(-1), null);\n\t\tassertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(10), null);\n\n\t}\n\t\n\t/**\n\t * Test that getting the structure data info works.\n\t */\n\t@Test\n\tpublic void testGetStructureInfo() {\n\t\tStructure structure = new StructureImpl();\n\t\tChain chain = new ChainImpl();\n\t\tchain.setChainID(\"A\");\n\t\tMap<String,Integer> testMap = new HashMap<>();\n\t\ttestMap.put(\"A\", 0);\n\t\tList<Chain> chainList = new ArrayList<>();\n\t\tchainList.add(chain);\n\t\tGroup group = new AminoAcidImpl();\n\t\tchain.addGroup(group);\n\t\tAtom atomOne = new AtomImpl();\n\t\tAtom atomTwo = new AtomImpl();\n\t\tList<Atom> atomList = new ArrayList<>();\n\t\tatomList.add(atomOne);\n\t\tatomList.add(atomTwo);\n\t\tnew BondImpl(atomOne, atomTwo, 1);\n\t\tstructure.addChain(chain);\n\t\tgroup.addAtom(atomOne);\n\t\tgroup.addAtom(atomTwo);\n\t\t// Get the structure\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = MmtfUtils.getStructureInfo(structure);\n\t\tassertEquals(mmtfSummaryDataBean.getAllAtoms(), atomList);\n\t\tassertEquals(testMap, mmtfSummaryDataBean.getChainIdToIndexMap());\n\t\tassertEquals(chainList, mmtfSummaryDataBean.getAllChains());\n\t\tassertEquals(1, mmtfSummaryDataBean.getNumBonds());\n\t}\n\t\n\tprivate Set<Atom> findDuplicates(List<Atom> listContainingDuplicates)\n\t{ \n\t  final Set<Atom> setToReturn = new HashSet<>(); \n\t  final Set<Atom> set1 = new HashSet<>();\n\n\t  for (Atom yourInt : listContainingDuplicates)\n\t  {\n\t   if (!set1.add(yourInt))\n\t   {\n\t    setToReturn.add(yourInt);\n\t   }\n\t  }\n\t  return setToReturn;\n\t}\n}\n\n","commitMessage":"Added more comprehensive test suite for the utils class.\n","test_commitMessage":"Added more comprehensive test suite for the utils class.\n","allZero":false}