{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/scop/ScopFactory.java","test_path":"integrationtest/src/test/java/org/biojava/structure/test/scop/ScopFactoryTest.java","prod_time":"2015-01-22 06:06:12","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":5,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"7eb3aabf16e5d675223cb31510cf15773ba55f80","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.bio.structure.scop;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n\n/**\n * Controls the global ScopDatabase being used.\n * \n * <p>Defaults to a {@link RemoteScopInstallation}, which is fast for small numbers\n * of queries. For many queries, using {@link #getSCOP(String, boolean) getSCOP(version,true)}\n * may be faster, since it makes only one network request.\n * \n * <p>Example: Fetch the structure corresponding to an old version of scop\n * \n * <pre>\n * ScopInstallation scop = new ScopInstallation();\n * scop.setScopVersion(\"1.69\");\n * ScopFactory.setScopDatabase(scop);\n * AtomCache cache = new AtomCache();\n * cache.setFetchFileEvenIfObsolete(true); //fetch older PDBs\n * cache.setStrictSCOP(false); // correct simple errors in domain names\n * Structure s = cache.getStructure(\"d3hbia_\");\n * @author sbliven\n *\n */\npublic class ScopFactory {\n\n\t// berkeley 2\n\tpublic static final String VERSION_2_0_4 = \"2.04\";\n\tpublic static final String VERSION_2_0_3 = \"2.03\";\n\tpublic static final String VERSION_2_0_2 = \"2.02\";\n\tpublic static final String VERSION_2_0_1 = \"2.01\";\n\t// berkeley 1 (aliases of above)\n\tpublic static final String VERSION_1_75C = VERSION_2_0_3;\n\tpublic static final String VERSION_1_75B = VERSION_2_0_2;\n\tpublic static final String VERSION_1_75A = VERSION_2_0_1;\n\t// original SCOP\n\t// latest SCOP release from SCOP website = 1.75;\n\tpublic static final String VERSION_1_75 = \"1.75\";\n\t// outdated stable versions\n\tpublic static final String VERSION_1_73 = \"1.73\";\n\tpublic static final String VERSION_1_71 = \"1.71\";\n\tpublic static final String VERSION_1_69 = \"1.69\";\n\tpublic static final String VERSION_1_67 = \"1.67\";\n\tpublic static final String VERSION_1_65 = \"1.65\";\n\tpublic static final String VERSION_1_63 = \"1.63\";\n\tpublic static final String VERSION_1_61 = \"1.61\";\n\tpublic static final String VERSION_1_59 = \"1.59\";\n\tpublic static final String VERSION_1_57 = \"1.57\";\n\tpublic static final String VERSION_1_55 = \"1.55\";\n\n\t// The most recent version as of compilation time\n\tpublic static final String LATEST_VERSION = VERSION_2_0_4;\n\n\t// Hold one instance for each version\n\tprivate static Map<String,ScopDatabase> versionedScopDBs = new HashMap<String, ScopDatabase>(); \n\tprivate static String defaultVersion = LATEST_VERSION;\n\n\t/**\n\t * Get the current default instance for the default version\n\t * @return\n\t */\n\tpublic static ScopDatabase getSCOP(){\n\t\treturn getSCOP(defaultVersion);\n\t}\n\n\t/**\n\t * \n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t * @return\n\t * @see #getSCOP(String, boolean)\n\t */\n\tpublic static ScopDatabase getSCOP(boolean forceLocalData) {\n\t\treturn getSCOP(defaultVersion, forceLocalData);\n\t}\n\n\t/**\n\t * requests a particular version of SCOP.\n\t *\n\t * Where possible, this will be the current default instance.\n\t * Otherwise a new instance will be created.\n\t * @param version\n\t * @return\n\t */\n\tpublic static ScopDatabase getSCOP(String version){\n\t\t// Default to a remote installation\n\t\treturn getSCOP(version,false);\n\t}\n\n\t/**\n\t * Gets an instance of the specified scop version.\n\t * \n\t * <p>\n\t * The particular implementation returned is influenced by the <tt>forceLocalData</tt>\n\t * parameter. When false, the instance returned will generally be a\n\t * {@link RemoteScopInstallation}, although this may be influenced by\n\t * previous calls to this class. When true, the result is guaranteed to\n\t * implement {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}).\n\t * \n\t * <p>\n\t * Note that  \n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t * @return an\n\t */\n\tpublic static ScopDatabase getSCOP(String version, boolean forceLocalData){\n\t\tif( version == null ) {\n\t\t\tversion = defaultVersion;\n\t\t}\n\t\tScopDatabase scop = versionedScopDBs.get(version);\n\t\tif ( forceLocalData) {\n\t\t\t// Use a local installation\n\t\t\tif( scop == null || !(scop instanceof LocalScopDatabase) ) {\n\t\t\t\tBerkeleyScopInstallation berkeley = new BerkeleyScopInstallation();\n\t\t\t\tberkeley.setScopVersion(version);\n\t\t\t\tversionedScopDBs.put(version,berkeley);\n\t\t\t\treturn berkeley;\n\t\t\t}\n\t\t\treturn scop;\n\t\t} else {\n\t\t\t// Use a remote installation\n\t\t\tif( scop == null ) {\n\t\t\t\tscop = new RemoteScopInstallation();\n\t\t\t\tscop.setScopVersion(version);\n\t\t\t\tversionedScopDBs.put(version,scop);\n\t\t\t}\n\t\t\treturn scop;\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the default scop version\n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t */\n\tpublic static void setScopDatabase(String version) {\n\t\tgetSCOP(version);\n\t\tdefaultVersion = version;\n\t}\n\t\n\t/**\n\t * Set the default scop version\n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t */\n\tpublic static void setScopDatabase(String version, boolean forceLocalData) {\n\t\t//System.out.println(\"ScopFactory: Setting ScopDatabase to version: \" + version + \" forced local: \" + forceLocalData);\n\t\tgetSCOP(version,forceLocalData);\n\t\tdefaultVersion = version;\n\t}\n\n\t/**\n\t * Set the default scop version and instance\n\t * @param scop\n\t */\n\tpublic static void setScopDatabase(ScopDatabase scop){\n\t\t//System.out.println(\"ScopFactory: Setting ScopDatabase to type: \" + scop.getClass().getName());\n\t\tdefaultVersion = scop.getScopVersion();\n\t\tversionedScopDBs.put(defaultVersion,scop);\n\t}\n}\n","changedPro":"package org.biojava.bio.structure.scop;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n\n/**\n * Controls the global ScopDatabase being used.\n * \n * <p>Defaults to a {@link RemoteScopInstallation}, which is fast for small numbers\n * of queries. For many queries, using {@link #getSCOP(String, boolean) getSCOP(version,true)}\n * may be faster, since it makes only one network request.\n * \n * <p>Example: Fetch the structure corresponding to an old version of scop\n * \n * <pre>\n * ScopInstallation scop = new ScopInstallation();\n * scop.setScopVersion(\"1.69\");\n * ScopFactory.setScopDatabase(scop);\n * AtomCache cache = new AtomCache();\n * cache.setFetchFileEvenIfObsolete(true); //fetch older PDBs\n * cache.setStrictSCOP(false); // correct simple errors in domain names\n * Structure s = cache.getStructure(\"d3hbia_\");\n * @author sbliven\n *\n */\npublic class ScopFactory {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScopFactory.class);\n\n\t// berkeley 2\n\tpublic static final String VERSION_2_0_4 = \"2.04\";\n\tpublic static final String VERSION_2_0_3 = \"2.03\";\n\tpublic static final String VERSION_2_0_2 = \"2.02\";\n\tpublic static final String VERSION_2_0_1 = \"2.01\";\n\t// berkeley 1 (aliases of above)\n\tpublic static final String VERSION_1_75C = VERSION_2_0_3;\n\tpublic static final String VERSION_1_75B = VERSION_2_0_2;\n\tpublic static final String VERSION_1_75A = VERSION_2_0_1;\n\t// original SCOP\n\t// latest SCOP release from SCOP website = 1.75;\n\tpublic static final String VERSION_1_75 = \"1.75\";\n\t// outdated stable versions\n\tpublic static final String VERSION_1_73 = \"1.73\";\n\tpublic static final String VERSION_1_71 = \"1.71\";\n\tpublic static final String VERSION_1_69 = \"1.69\";\n\tpublic static final String VERSION_1_67 = \"1.67\";\n\tpublic static final String VERSION_1_65 = \"1.65\";\n\tpublic static final String VERSION_1_63 = \"1.63\";\n\tpublic static final String VERSION_1_61 = \"1.61\";\n\tpublic static final String VERSION_1_59 = \"1.59\";\n\tpublic static final String VERSION_1_57 = \"1.57\";\n\tpublic static final String VERSION_1_55 = \"1.55\";\n\n\t// The most recent version as of compilation time\n\tpublic static final String LATEST_VERSION = VERSION_2_0_4;\n\n\t// Hold one instance for each version\n\tprivate static Map<String,ScopDatabase> versionedScopDBs = new HashMap<String, ScopDatabase>(); \n\tprivate static String defaultVersion = LATEST_VERSION;\n\n\t/**\n\t * Get the current default instance for the default version\n\t * @return\n\t */\n\tpublic static ScopDatabase getSCOP(){\n\t\treturn getSCOP(defaultVersion);\n\t}\n\n\t/**\n\t * \n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t * @return\n\t * @see #getSCOP(String, boolean)\n\t */\n\tpublic static ScopDatabase getSCOP(boolean forceLocalData) {\n\t\treturn getSCOP(defaultVersion, forceLocalData);\n\t}\n\n\t/**\n\t * requests a particular version of SCOP.\n\t *\n\t * Where possible, this will be the current default instance.\n\t * Otherwise a new instance will be created.\n\t * @param version\n\t * @return\n\t */\n\tpublic static ScopDatabase getSCOP(String version){\n\t\t// Default to a remote installation\n\t\treturn getSCOP(version,false);\n\t}\n\n\t/**\n\t * Gets an instance of the specified scop version.\n\t * \n\t * <p>\n\t * The particular implementation returned is influenced by the <tt>forceLocalData</tt>\n\t * parameter. When false, the instance returned will generally be a\n\t * {@link RemoteScopInstallation}, although this may be influenced by\n\t * previous calls to this class. When true, the result is guaranteed to\n\t * implement {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}).\n\t * \n\t * <p>\n\t * Note that  \n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t * @return an\n\t */\n\tpublic static ScopDatabase getSCOP(String version, boolean forceLocalData){\n\t\tif( version == null ) {\n\t\t\tversion = defaultVersion;\n\t\t}\n\t\tScopDatabase scop = versionedScopDBs.get(version);\n\t\tif ( forceLocalData) {\n\t\t\t// Use a local installation\n\t\t\tif( scop == null || !(scop instanceof LocalScopDatabase) ) {\n\t\t\t\tlogger.info(\"Creating new {}, version {}\", BerkeleyScopInstallation.class.getSimpleName(), version);\n\t\t\t\tBerkeleyScopInstallation berkeley = new BerkeleyScopInstallation();\n\t\t\t\tberkeley.setScopVersion(version);\n\t\t\t\tversionedScopDBs.put(version,berkeley);\n\t\t\t\treturn berkeley;\n\t\t\t}\n\t\t\treturn scop;\n\t\t} else {\n\t\t\t// Use a remote installation\n\t\t\tif( scop == null ) {\n\t\t\t\tlogger.info(\"Creating new {}, version {}\", RemoteScopInstallation.class.getSimpleName(), version);\n\t\t\t\tscop = new RemoteScopInstallation();\n\t\t\t\tscop.setScopVersion(version);\n\t\t\t\tversionedScopDBs.put(version,scop);\n\t\t\t}\n\t\t\treturn scop;\n\t\t}\n\t}\n\n\n\t/**\n\t * Set the default scop version\n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t */\n\tpublic static void setScopDatabase(String version) {\n\t\tgetSCOP(version);\n\t\tdefaultVersion = version;\n\t}\n\t\n\t/**\n\t * Set the default scop version\n\t * @param version A version number, such as {@link #VERSION_1_75A}\n\t * @param forceLocalData Whether to use a local installation or a remote installation\n\t */\n\tpublic static void setScopDatabase(String version, boolean forceLocalData) {\n\t\tlogger.debug(\"ScopFactory: Setting ScopDatabase to version: {}, forced local: {}\", version, forceLocalData);\n\t\tgetSCOP(version,forceLocalData);\n\t\tdefaultVersion = version;\n\t}\n\n\t/**\n\t * Set the default scop version and instance\n\t * @param scop\n\t */\n\tpublic static void setScopDatabase(ScopDatabase scop){\n\t\tlogger.debug(\"ScopFactory: Setting ScopDatabase to type: {}\", scop.getClass().getName());\n\t\tdefaultVersion = scop.getScopVersion();\n\t\tversionedScopDBs.put(defaultVersion,scop);\n\t}\n}\n","originTest":"package org.biojava.structure.test.scop;\n\nimport static org.junit.Assert.*;\n\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\n\nimport org.biojava.bio.structure.scop.BerkeleyScopInstallation;\nimport org.biojava.bio.structure.scop.RemoteScopInstallation;\nimport org.biojava.bio.structure.scop.ScopDatabase;\nimport org.biojava.bio.structure.scop.ScopFactory;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class ScopFactoryTest {\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\t// reset static values\n\t\tField versionedScopDBs = ScopFactory.class.getDeclaredField(\"versionedScopDBs\");\n\t\tversionedScopDBs.setAccessible(true);\n\t\tversionedScopDBs.set(null, new HashMap<String, ScopDatabase>());\n\t\tField defaultVersion = ScopFactory.class.getDeclaredField(\"defaultVersion\");\n\t\tdefaultVersion.setAccessible(true);\n\t\tdefaultVersion.set(null, ScopFactory.LATEST_VERSION);\n\t}\n\n\t@Test\n\tpublic void testVersionCaching() {\n\t\tScopDatabase scop1,scop2,scop3;\n\t\tscop1 = ScopFactory.getSCOP(ScopFactory.LATEST_VERSION);\n\t\tscop2 = ScopFactory.getSCOP(ScopFactory.LATEST_VERSION);\n\t\tassertSame(scop1, scop2);\n\n\t\tscop2 = ScopFactory.getSCOP(ScopFactory.VERSION_1_75);\n\t\tassertNotSame(scop1,scop2);\n\t\tscop3 = ScopFactory.getSCOP(ScopFactory.VERSION_1_75);\n\t\tassertSame(scop2,scop3);\n\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75);\n\t\tscop3 = ScopFactory.getSCOP();\n\t\tassertSame(scop2,scop3);\n\n\t\tScopFactory.setScopDatabase(ScopFactory.LATEST_VERSION);\n\t\tscop3 = ScopFactory.getSCOP();\n\t\tassertSame(scop1,scop3);\n\t}\n\n\t@Test\n\tpublic void testVersions() {\n\t\tScopDatabase scop;\n\n\t\tscop = ScopFactory.getSCOP();\n\t\tassertEquals(ScopFactory.LATEST_VERSION, scop.getScopVersion());\n\n\t\tscop = ScopFactory.getSCOP(ScopFactory.VERSION_1_75);\n\t\tassertEquals(ScopFactory.VERSION_1_75, scop.getScopVersion());\n\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75, false);\n\t\tscop = ScopFactory.getSCOP();\n\t\tassertEquals(ScopFactory.VERSION_1_75, scop.getScopVersion());\n\t\tassertSame( RemoteScopInstallation.class,scop.getClass());\n\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75, true);\n\t\tscop = ScopFactory.getSCOP();\n\t\tassertEquals(ScopFactory.VERSION_1_75, scop.getScopVersion());\n\t\tassertSame( BerkeleyScopInstallation.class,scop.getClass());\n\n\t\tScopFactory.setScopDatabase(ScopFactory.LATEST_VERSION, true);\n\t\tscop = ScopFactory.getSCOP();\n\t\tassertEquals(ScopFactory.LATEST_VERSION, scop.getScopVersion());\n\t\tassertSame( BerkeleyScopInstallation.class,scop.getClass());\n\n\t}\n}\n","changedTest":"","commitMessage":"Issue #111 for SCOP, and a little of #155. Also simplified some code, made clone() call super.clone(), and switched from StringWriter and StringBuffer to the faster (asynchronous) StringBuilder.\n\nSmall improvements to rcsb package and to Astral class.\n","test_commitMessage":"","allZero":false}