{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/align/ce/OptimalCECPMain.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/align/ce/OptimalCECPMainTest.java","prod_time":"2011-09-13 08:38:43","test_time":"2011-10-21 05:48:26","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"NEGATIVE","prod_commitID":"35e17d7a40bc23091ee1a04fcceb1f5b49110ed8","test_commitID":"5267be3813539bf88e8eca1c3c178f998e4f0198","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPChainScorer;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class OptimalCECPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\n\tpublic static final String algorithmName = \"jCE Optimal Circular Permutation\";\n\n\tpublic static final String version = \"1.0\";\n\n\tprotected OptimalCECPParameters params;\n\t\n\t/**\n\t * \n\t */\n\tpublic OptimalCECPMain() {\n\t\tsuper();\n\t\tparams = new OptimalCECPParameters();\n\t}\n\t\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\t\n\t/**\n\t * @return an {@link OptimalCECPParameters} object \n\t */\n\t@Override\n\tpublic ConfigStrucAligParams getParameters() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param params Should be an {@link OptimalCECPParameters} object specifying alignment options\n\t */\n\t@Override\n\tpublic void setParameters(ConfigStrucAligParams params){\n\t\tif (! (params instanceof OptimalCECPParameters )){\n\t\t\tthrow new IllegalArgumentException(\"provided parameter object is not of type CeParameter\");\n\t\t}\n\t\tthis.params = (OptimalCECPParameters) params;\n\t}\n\t\n\t/**\n\t * Circularly permutes arr in place.\n\t * \n\t * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n\t * direction. Perhaps it would be more efficient to use the Collections version?\n\t * @param <T>\n\t * @param arr The array to be permuted\n\t * @param cp The number of residues to shift leftward, or equivalently, the index of\n\t *  the first element after the permutation point.\n\t */\n\tprivate static <T> void permuteArray(T[] arr, int cp) {\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = arr.length+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= arr.length) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\tList<T> temp = new ArrayList<T>(cp);\n\n\t\t// shift residues left\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\ttemp.add(arr[i]);\n\t\t}\n\t\tfor(int j=cp;j<arr.length;j++) {\n\t\t\tarr[j-cp]=arr[j];\n\t\t}\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\tarr[arr.length-cp+i] = temp.get(i);\n\t\t}\n\t}\n\t\n\t/**\n\t * Circularly permutes arr in place.\n\t * \n\t * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n\t * direction. Perhaps it would be more efficient to use the Collections version?\n\t * @param <T>\n\t * @param arr The array to be permuted\n\t * @param cp The number of residues to shift leftward, or equivalently, the index of\n\t *  the first element after the permutation point.\n\t */\n\tprivate static void permuteArray(int[] arr, int cp) {\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = arr.length+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= arr.length) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\tList<Integer> temp = new ArrayList<Integer>(cp);\n\n\t\t// shift residues left\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\ttemp.add(arr[i]);\n\t\t}\n\t\tfor(int j=cp;j<arr.length;j++) {\n\t\t\tarr[j-cp]=arr[j];\n\t\t}\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\tarr[arr.length-cp+i] = temp.get(i);\n\t\t}\n\t}\n\n\t/**\n\t * Aligns ca1 with ca2 permuted by <i>cp</i> residues.\n\t * <p><strong>WARNING:</strong> Modifies ca2 during the permutation. Be sure\n\t * to make a copy before calling this method.\n\t * \n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @param cp\n\t * @return\n\t * @throws StructureException \n\t */\n\tpublic AFPChain alignPermuted(Atom[] ca1, Atom[] ca2, Object param, int cp) throws StructureException {\n\t\t// initial permutation\n\t\tpermuteArray(ca2,cp);\n\t\t\n\t\t// perform alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2, param);\n\t\t\n\t\t// un-permute alignment\n\t\tpermuteAFPChain(afpChain, -cp);\n\t\t\n\t\tif(afpChain.getName2() != null) {\n\t\t\tafpChain.setName2(afpChain.getName2()+\" CP=\"+cp);\n\t\t}\n\t\t\n\t\t// Specify the permuted\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Permute the second protein of afpChain by the specified number of residues.\n\t * @param afpChain Input alignment\n\t * @param cp Amount leftwards (or rightward, if negative) to shift the \n\t * @return A new alignment equivalent to afpChain after the permutations\n\t */\n\tprivate static void permuteAFPChain(AFPChain afpChain, int cp) {\n\t\t\n\t\tint ca2len = afpChain.getCa2Length();\n\t\t\t\t\n\t\t//fix up cp to be positive\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = ca2len+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= ca2len) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\t// Fix up optAln\n\t\tpermuteOptAln(afpChain,cp);\n\t\t\n\t\tif(afpChain.getBlockNum() > 1)\n\t\t\tafpChain.setSequentialAlignment(false);\n\t\t// fix up matrices\n\t\t// ca1 corresponds to row indices, while ca2 corresponds to column indices.\n\t\tafpChain.setDistanceMatrix(permuteMatrix(afpChain.getDistanceMatrix(),0,-cp));\n\t\t// this is square, so permute both\n\t\tafpChain.setDisTable2(permuteMatrix(afpChain.getDisTable2(),-cp,-cp));\n\n\t\t//TODO fix up other AFP parameters?\n\t\t\n\t}\n\t\n\t/**\n\t * Permutes <i>mat</i> by moving the rows of the matrix upwards by <i>cp</i>\n\t * rows.\n\t * @param mat The original matrix\n\t * @param cpRows Number of rows upward to move entries\n\t * @param cpCols Number of columns leftward to move entries\n\t * @return The permuted matrix\n\t */\n\tprivate static Matrix permuteMatrix(Matrix mat, int cpRows, int cpCols) {\n\t\t//fix up cp to be positive\n\t\tif(cpRows == 0 && cpCols == 0) {\n\t\t\treturn mat.copy();\n\t\t}\n\t\tif(cpRows < 0) {\n\t\t\tcpRows = mat.getRowDimension()+cpRows;\n\t\t}\n\t\tif(cpRows < 0 || cpRows >= mat.getRowDimension()) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Can't permute rows by %d: only %d rows.\", \n\t\t\t\t\tcpRows, mat.getRowDimension() )\n\t\t\t);\n\t\t}\n\n\t\tif(cpCols < 0) {\n\t\t\tcpCols = mat.getColumnDimension()+cpCols;\n\t\t}\n\t\tif(cpCols < 0 || cpCols >= mat.getColumnDimension()) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Can't permute cols by %d: only %d rows.\", \n\t\t\t\t\tcpCols, mat.getColumnDimension() )\n\t\t\t);\n\t\t}\n\t\t\n\t\tint[] rows = new int[mat.getRowDimension()];\n\t\tfor(int i=0;i<rows.length;i++) {\n\t\t\trows[i] = (i+cpRows)%rows.length;\n\t\t}\n\t\tint[] cols = new int[mat.getColumnDimension()];\n\t\tfor(int i=0;i<cols.length;i++) {\n\t\t\tcols[i] = (i+cpCols)%cols.length;\n\t\t}\n\t\t\n\t\tMatrix newMat = mat.getMatrix(rows, cols);\n\t\tassert(newMat.getRowDimension() == mat.getRowDimension());\n\t\tassert(newMat.getColumnDimension() == mat.getColumnDimension());\n\t\tassert(newMat.get(0, 0) ==\n\t\t\tmat.get(cpRows%mat.getRowDimension(), cpCols%mat.getColumnDimension()));\n\t\t\n\t\t\n\t\tnewMat.set(0, 0, -1);\n\t\tnewMat.set(10, 20, -1);\n\t\treturn newMat;\n\t}\n\n\t/**\n\t * Modifies the {@link AFPChain#setOptAln(int[][][]) optAln} of an AFPChain\n\t * by permuting the second protein.\n\t * \n\t * Sets residue numbers in the second protein to <i>(i-cp)%len</i>\n\t * \n\t * @param afpChain\n\t * @param cp Amount leftwards (or rightward, if negative) to shift the\n\t */\n\tprivate static void permuteOptAln(AFPChain afpChain, int cp)\n\t{\n\t\tint ca2len = afpChain.getCa2Length();\n\n\t\tif( ca2len <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"No Ca2Length specified in \"+afpChain);\n\t\t}\n\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp <= -ca2len || cp >= ca2len) {\n\t\t\t// could just take cp%ca2len, but probably its a bug if abs(cp)>=ca2len\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Permutation point %d must be between %d and %d for %s\",\n\t\t\t\t\tcp, 1-ca2len,ca2len-1, afpChain.getName2() ) );\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = cp + ca2len;\n\t\t}\n\n\t\t// the unprocessed alignment\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// the processed alignment\n\t\tList<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum()*2);\n\t\t\n\t\t//Update residue indices\n\t\t// newi = (oldi-cp) % N\n\t\tfor(int block = 0; block < afpChain.getBlockNum(); block++) {\n\t\t\tif(optLen[block]<1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// set up storage for the current block\n\t\t\tList<List<Integer>> currBlock = new ArrayList<List<Integer>>(2);\n\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\tblocks.add(currBlock);\n\n\t\t\t// pos = 0 case\n\t\t\tcurrBlock.get(0).add( optAln[block][0][0] );\n\t\t\tcurrBlock.get(1).add( (optAln[block][1][0]+cp ) % ca2len);\n\t\t\t\n\t\t\tfor(int pos = 1; pos < optLen[block]; pos++) {\n\t\t\t\t//check if we need to start a new block\n\t\t\t\t//this happens when the new alignment crosses the protein terminus\n\t\t\t\tif( optAln[block][1][pos-1]+cp<ca2len && \n\t\t\t\t\t\toptAln[block][1][pos]+cp >= ca2len) {\n\t\t\t\t\tcurrBlock = new ArrayList<List<Integer>>(2);\n\t\t\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\t\t\tblocks.add(currBlock);\n\t\t\t\t}\n\t\t\t\tcurrBlock.get(0).add( optAln[block][0][pos] );\n\t\t\t\tcurrBlock.get(1).add( (optAln[block][1][pos]+cp ) % ca2len);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// save permuted blocks to afpChain\n\t\tassignOptAln(afpChain,blocks);\n\t}\n\n\t/**\n\t * Sometimes it's convenient to store an alignment using java collections,\n\t * where <tt>blocks.get(blockNum).get(0).get(pos)</tt> specifies the aligned\n\t * residue at position <i>pos</i> of block <i>blockNum</i> of the first\n\t * protein.\n\t * \n\t * This method takes such a collection and stores it into the afpChain's\n\t * {@link AFPChain#setOptAln(int[][][]) optAln}, setting the associated\n\t * length variables as well.\n\t * \n\t * @param afpChain\n\t * @param blocks\n\t */\n\tprivate static void assignOptAln(AFPChain afpChain, List<List<List<Integer>>> blocks)\n\t{\n\t\t\n\t\tint[][][] optAln = new int[blocks.size()][][];\n\t\tint[] optLen = new int[blocks.size()];\n\t\tint optLength = 0;\n\t\tint numBlocks = blocks.size();\n\t\t\n\t\tfor(int block = 0; block < numBlocks; block++) {\n\t\t\t// block should be 2xN rectangular\n\t\t\tassert(blocks.get(block).size() == 2);\n\t\t\tassert( blocks.get(block).get(0).size() == blocks.get(block).get(1).size());\n\n\t\t\toptLen[block] = blocks.get(block).get(0).size();\n\t\t\toptLength+=optLen[block];\n\t\t\t\n\t\t\toptAln[block] = new int[][] {\n\t\t\t\t\tnew int[optLen[block]],\n\t\t\t\t\tnew int[optLen[block]]\n\t\t\t};\n\t\t\tfor(int pos = 0; pos < optLen[block]; pos++) {\n\t\t\t\toptAln[block][0][pos] = blocks.get(block).get(0).get(pos);\n\t\t\t\toptAln[block][1][pos] = blocks.get(block).get(1).get(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tafpChain.setBlockNum(numBlocks);\n\t\tafpChain.setOptAln(optAln);\n\t\tafpChain.setOptLen(optLen);\n\t\tafpChain.setOptLength(optLength);\n\t\t\n\t\t// TODO I don't know what these do. Should they be set?\n\t\t//afpChain.setBlockSize(blockSize);\n\t\t//afpChain.setBlockResList(blockResList);\n\t\t//afpChain.setChainLen(chainLen);\n\t\t\n\t}\n\n\t/**\n\t * Finds the optimal alignment between two proteins allowing for a circular\n\t * permutation (CP).\n\t * \n\t * The precise algorithm is controlled by the \n\t * {@link OptimalCECPParameters parameters}. If the parameter\n\t * {@link OptimalCECPParameters#isTryAllCPs() tryAllCPs} is true, all possible\n\t * CP sites are tried and the optimal site is returned. Otherwise, the\n\t * {@link OptimalCECPParameters#getCPPoint() cpPoint} parameter is used to\n\t * determine the CP point, greatly reducing the computation required.\n\t * \n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param param {@link CeParameters} object\n\t * @return The best-scoring alignment\n\t * @throws StructureException\n\t * \n\t * @see #alignOptimal(Atom[], Atom[], Object, AFPChain[])\n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param)\n\tthrows StructureException\n\t{\n\t\tif(params.isTryAllCPs()) {\n\t\t\treturn alignOptimal(ca1,ca2,param,null);\n\t\t} else {\n\t\t\tint cpPoint = params.getCPPoint();\n\t\t\treturn alignPermuted(ca1, ca2, param, cpPoint);\n\t\t}\n\t}\n\n\t/**\n\t * Finds the optimal alignment between two proteins allowing for a circular\n\t * permutation (CP).\n\t * \n\t * This algorithm performs a CE alignment for each possible CP site. This is\n\t * quite slow. Use {@link #alignHeuristic(Atom[], Atom[], Object)} for a\n\t * faster algorithm.\n\t * \n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param param {@link CeParameters} object\n\t * @param alignments If not null, should be an empty array of the same length as\n\t *  ca2. This will be filled with the alignments from permuting ca2 by \n\t *  0 to n-1 residues.\n\t * @return The best-scoring alignment\n\t * @throws StructureException\n\t */\n\tpublic AFPChain alignOptimal(Atom[] ca1, Atom[] ca2, Object param, AFPChain[] alignments)\n\tthrows StructureException\n\t{\n\t\tlong startTime = System.currentTimeMillis();\n\t\t\n\t\tif(alignments.length != ca2.length) {\n\t\t\tthrow new IllegalArgumentException(\"scores param should have same length as ca2\");\n\t\t}\n\t\t// clone ca2 to prevent side effects from propegating\n\t\tAtom[] ca2p = StructureTools.cloneCAArray(ca2);\n\t\t\n\t\tAFPChain unaligned = super.align(ca1, ca2, param);\n\t\tAFPChain bestAlignment = unaligned;\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.print(\".\");\n\t\t}\n\n\t\tif(alignments != null) {\n\t\t\talignments[0] = unaligned;\n\t\t}\n\t\t\n\t\tfor(int cp=1;cp<ca2.length;cp++) {\n\t\t\t//permute one each time. Alters ca2p as a side effect\n\t\t\tAFPChain currentAlignment = alignPermuted(ca1,ca2p,param,1);\n\t\t\t\n\t\t\tif(debug) System.out.print(\".\");\n\t\t\t\n\t\t\t// fix up names, since cloning ca2 wipes it\n\t\t\ttry {\n\t\t\t\tcurrentAlignment.setName2(ca2[0].getGroup().getChain().getParent().getName()+\" CP=\"+cp);\n\t\t\t} catch( Exception e) {\n\t\t\t\t//null pointers, empty arrays, etc.\n\t\t\t}\n\t\t\tdouble currentScore = currentAlignment.getAlignScore();\n\t\t\t\n\t\t\tif(alignments != null) {\n\t\t\t\talignments[cp] = currentAlignment;\n\t\t\t}\n\t\t\t\n\t\t\tif(currentScore>bestAlignment.getAlignScore()) {\n\t\t\t\tbestAlignment = currentAlignment;\n\t\t\t}\n\t\t}\n\t\tif(debug) {\n\t\t\tlong elapsedTime = System.currentTimeMillis()-startTime;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.format(\"%d alignments took %.4f s (%.1f ms avg)\\n\",\n\t\t\t\t\tca2.length, elapsedTime/1000., (double)elapsedTime/ca2.length);\n\t\t}\n\n\t\t\n\t\treturn bestAlignment;\n\t\t\n\t}\n\n\n\n\t\n\tpublic static void main(String[] args){\n\t\ttry {\n\t\t\tString name1, name2;\n\n\t\t\tint cp=0;\n\t\t\t\n\t\t\t//Concanavalin\n\t\t\tname1 = \"2pel.A\";\n\t\t\tname2 = \"3cna\";\n\t\t\tcp = 122;\n\n\t\t\t//small case\n\t\t\t//name1 = \"d1qdmA1\";\n\t\t\t//name1 = \"1QDM.A\";\n\t\t\t//name2 = \"d1nklA_\";\n\t\t\t//cp = 41;\n\t\t\t\n\t\t\t//1itb selfsymmetry\n\t\t\t//name1 = \"1ITB.A\";\n\t\t\t//name2 = \"1ITB.A\";\n\t\t\t//cp = 92;\n\t\t\t\n\t\t\tOptimalCECPMain ce = (OptimalCECPMain) StructureAlignmentFactory.getAlgorithm(OptimalCECPMain.algorithmName);\n\t\t\tCeParameters params = (CeParameters) ce.getParameters();\n\t\t\tce.setParameters(params);\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\n\t\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\t\t\tAFPChain afpChain;\n\t\t\t/*\n\t\t\t// unpermuted alignment\n\t\t\tafpChain = ce.alignPermuted(ca1, ca2, params, 0);\n\n\t\t\tdisplayAlignment(afpChain, ca1, ca2);\n\t\t\t*/\n\t\t\t\n\t\t\t// permuted alignment\n\t\t\t// new copy of ca2, since alignPermuted has side effects\n\t\t\tAtom[] ca2clone = cache.getAtoms(name2);\n\t\t\tafpChain = ce.alignPermuted(ca1, ca2clone, params, cp);\n\n\t\t\tdisplayAlignment(afpChain, ca1, ca2);\n\n\t\t\t// find optimal solution\t\t\t\n\t\t\tAFPChain[] alignments = new AFPChain[ca2.length];\n\t\t\tafpChain = ce.alignOptimal(ca1, ca2, params, alignments);\n\t\t\tSystem.out.format(\"Optimal Score: %.2f\\n\", afpChain.getAlignScore());\n\t\t\t\n\t\t\tSystem.out.println(\"Pos\\tScore\\tTMScore\\tLen\\tRMSD\\tBlocks\");\n\t\t\tfor(int i = 0; i< alignments.length; i++) {\n\t\t\t\tdouble tm = AFPChainScorer.getTMScore(alignments[i], ca1, ca2);\n\t\t\t\tSystem.out.format(\"%d\\t%.2f\\t%.2f\\t%d\\t%.2f\\t%d\\n\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\talignments[i].getAlignScore(),\n\t\t\t\t\t\ttm,\n\t\t\t\t\t\talignments[i].getOptLength(),\n\t\t\t\t\t\talignments[i].getTotalRmsdOpt(),\n\t\t\t\t\t\talignments[i].getBlockNum()\n\t\t\t\t);\n\t\t\t}\t\n\t\t\t\n\t\t\tdisplayAlignment(afpChain,ca1,ca2);\n\t\t\t\n\t\t\tfor(int cpPos=0;cpPos<alignments.length;cpPos++) {\n\t\t\t\tAFPChain curr = alignments[cpPos];\n\t\t\t\tif( (!curr.isSequentialAlignment()) || curr.getBlockNum() > 1) {\n\t\t\t\t\tSystem.out.format(\"%d\\t%s\\t%d\\n\", cpPos,curr.isSequentialAlignment(),curr.getBlockNum());\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * Try showing a the afpChain in a GUI.\n\t * \n\t * <p>requires additional dependancies biojava3-structure-gui and JmolApplet\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @throws ClassNotFoundException\n\t * @throws NoSuchMethodException\n\t * @throws InvocationTargetException\n\t * @throws IllegalAccessException\n\t * @throws StructureException\n\t */\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPChainScorer;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class OptimalCECPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\n\tpublic static final String algorithmName = \"jCE Optimal Circular Permutation\";\n\n\tpublic static final String version = \"1.0\";\n\n\tprotected OptimalCECPParameters params;\n\t\n\t/**\n\t * \n\t */\n\tpublic OptimalCECPMain() {\n\t\tsuper();\n\t\tparams = new OptimalCECPParameters();\n\t}\n\t\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn OptimalCECPMain.algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn OptimalCECPMain.version;\n\t}\n\t\n\t/**\n\t * @return an {@link OptimalCECPParameters} object \n\t */\n\t@Override\n\tpublic ConfigStrucAligParams getParameters() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param params Should be an {@link OptimalCECPParameters} object specifying alignment options\n\t */\n\t@Override\n\tpublic void setParameters(ConfigStrucAligParams params){\n\t\tif (! (params instanceof OptimalCECPParameters )){\n\t\t\tthrow new IllegalArgumentException(\"provided parameter object is not of type CeParameter\");\n\t\t}\n\t\tthis.params = (OptimalCECPParameters) params;\n\t}\n\t\n\t/**\n\t * Circularly permutes arr in place.\n\t * \n\t * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n\t * direction. Perhaps it would be more efficient to use the Collections version?\n\t * @param <T>\n\t * @param arr The array to be permuted\n\t * @param cp The number of residues to shift leftward, or equivalently, the index of\n\t *  the first element after the permutation point.\n\t */\n\tprivate static <T> void permuteArray(T[] arr, int cp) {\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = arr.length+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= arr.length) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\tList<T> temp = new ArrayList<T>(cp);\n\n\t\t// shift residues left\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\ttemp.add(arr[i]);\n\t\t}\n\t\tfor(int j=cp;j<arr.length;j++) {\n\t\t\tarr[j-cp]=arr[j];\n\t\t}\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\tarr[arr.length-cp+i] = temp.get(i);\n\t\t}\n\t}\n\t\n\t/**\n\t * Circularly permutes arr in place.\n\t * \n\t * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n\t * direction. Perhaps it would be more efficient to use the Collections version?\n\t * @param <T>\n\t * @param arr The array to be permuted\n\t * @param cp The number of residues to shift leftward, or equivalently, the index of\n\t *  the first element after the permutation point.\n\t */\n\tprivate static void permuteArray(int[] arr, int cp) {\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = arr.length+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= arr.length) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\tList<Integer> temp = new ArrayList<Integer>(cp);\n\n\t\t// shift residues left\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\ttemp.add(arr[i]);\n\t\t}\n\t\tfor(int j=cp;j<arr.length;j++) {\n\t\t\tarr[j-cp]=arr[j];\n\t\t}\n\t\tfor(int i=0;i<cp;i++) {\n\t\t\tarr[arr.length-cp+i] = temp.get(i);\n\t\t}\n\t}\n\n\t/**\n\t * Aligns ca1 with ca2 permuted by <i>cp</i> residues.\n\t * <p><strong>WARNING:</strong> Modifies ca2 during the permutation. Be sure\n\t * to make a copy before calling this method.\n\t * \n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @param cp\n\t * @return\n\t * @throws StructureException \n\t */\n\tpublic AFPChain alignPermuted(Atom[] ca1, Atom[] ca2, Object param, int cp) throws StructureException {\n\t\t// initial permutation\n\t\tpermuteArray(ca2,cp);\n\t\t\n\t\t// perform alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2, param);\n\t\t\n\t\t// un-permute alignment\n\t\tpermuteAFPChain(afpChain, -cp);\n\t\t\n\t\tif(afpChain.getName2() != null) {\n\t\t\tafpChain.setName2(afpChain.getName2()+\" CP=\"+cp);\n\t\t}\n\t\t\n\t\t// Specify the permuted\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Permute the second protein of afpChain by the specified number of residues.\n\t * @param afpChain Input alignment\n\t * @param cp Amount leftwards (or rightward, if negative) to shift the \n\t * @return A new alignment equivalent to afpChain after the permutations\n\t */\n\tprivate static void permuteAFPChain(AFPChain afpChain, int cp) {\n\t\t\n\t\tint ca2len = afpChain.getCa2Length();\n\t\t\t\t\n\t\t//fix up cp to be positive\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = ca2len+cp;\n\t\t}\n\t\tif(cp < 0 || cp >= ca2len) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException(\n\t\t\t\t\t\"Permutation point (\"+cp+\") must be between -ca2.length and ca2.length-1\" );\n\t\t}\n\t\t\n\t\t// Fix up optAln\n\t\tpermuteOptAln(afpChain,cp);\n\t\t\n\t\tif(afpChain.getBlockNum() > 1)\n\t\t\tafpChain.setSequentialAlignment(false);\n\t\t// fix up matrices\n\t\t// ca1 corresponds to row indices, while ca2 corresponds to column indices.\n\t\tafpChain.setDistanceMatrix(permuteMatrix(afpChain.getDistanceMatrix(),0,-cp));\n\t\t// this is square, so permute both\n\t\tafpChain.setDisTable2(permuteMatrix(afpChain.getDisTable2(),-cp,-cp));\n\n\t\t//TODO fix up other AFP parameters?\n\t\t\n\t}\n\t\n\t/**\n\t * Permutes <i>mat</i> by moving the rows of the matrix upwards by <i>cp</i>\n\t * rows.\n\t * @param mat The original matrix\n\t * @param cpRows Number of rows upward to move entries\n\t * @param cpCols Number of columns leftward to move entries\n\t * @return The permuted matrix\n\t */\n\tprivate static Matrix permuteMatrix(Matrix mat, int cpRows, int cpCols) {\n\t\t//fix up cp to be positive\n\t\tif(cpRows == 0 && cpCols == 0) {\n\t\t\treturn mat.copy();\n\t\t}\n\t\tif(cpRows < 0) {\n\t\t\tcpRows = mat.getRowDimension()+cpRows;\n\t\t}\n\t\tif(cpRows < 0 || cpRows >= mat.getRowDimension()) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Can't permute rows by %d: only %d rows.\", \n\t\t\t\t\tcpRows, mat.getRowDimension() )\n\t\t\t);\n\t\t}\n\n\t\tif(cpCols < 0) {\n\t\t\tcpCols = mat.getColumnDimension()+cpCols;\n\t\t}\n\t\tif(cpCols < 0 || cpCols >= mat.getColumnDimension()) {\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Can't permute cols by %d: only %d rows.\", \n\t\t\t\t\tcpCols, mat.getColumnDimension() )\n\t\t\t);\n\t\t}\n\t\t\n\t\tint[] rows = new int[mat.getRowDimension()];\n\t\tfor(int i=0;i<rows.length;i++) {\n\t\t\trows[i] = (i+cpRows)%rows.length;\n\t\t}\n\t\tint[] cols = new int[mat.getColumnDimension()];\n\t\tfor(int i=0;i<cols.length;i++) {\n\t\t\tcols[i] = (i+cpCols)%cols.length;\n\t\t}\n\t\t\n\t\tMatrix newMat = mat.getMatrix(rows, cols);\n\t\tassert(newMat.getRowDimension() == mat.getRowDimension());\n\t\tassert(newMat.getColumnDimension() == mat.getColumnDimension());\n\t\tassert(newMat.get(0, 0) ==\n\t\t\tmat.get(cpRows%mat.getRowDimension(), cpCols%mat.getColumnDimension()));\n\t\t\n\t\t\n\t\tnewMat.set(0, 0, -1);\n\t\tnewMat.set(10, 20, -1);\n\t\treturn newMat;\n\t}\n\n\t/**\n\t * Modifies the {@link AFPChain#setOptAln(int[][][]) optAln} of an AFPChain\n\t * by permuting the second protein.\n\t * \n\t * Sets residue numbers in the second protein to <i>(i-cp)%len</i>\n\t * \n\t * @param afpChain\n\t * @param cp Amount leftwards (or rightward, if negative) to shift the\n\t */\n\tprivate static void permuteOptAln(AFPChain afpChain, int cp)\n\t{\n\t\tint ca2len = afpChain.getCa2Length();\n\n\t\tif( ca2len <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"No Ca2Length specified in \"+afpChain);\n\t\t}\n\n\t\t// Allow negative cp points for convenience.\n\t\tif(cp == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif(cp <= -ca2len || cp >= ca2len) {\n\t\t\t// could just take cp%ca2len, but probably its a bug if abs(cp)>=ca2len\n\t\t\tthrow new ArrayIndexOutOfBoundsException( String.format(\n\t\t\t\t\t\"Permutation point %d must be between %d and %d for %s\",\n\t\t\t\t\tcp, 1-ca2len,ca2len-1, afpChain.getName2() ) );\n\t\t}\n\t\tif(cp < 0) {\n\t\t\tcp = cp + ca2len;\n\t\t}\n\n\t\t// the unprocessed alignment\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// the processed alignment\n\t\tList<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum()*2);\n\t\t\n\t\t//Update residue indices\n\t\t// newi = (oldi-cp) % N\n\t\tfor(int block = 0; block < afpChain.getBlockNum(); block++) {\n\t\t\tif(optLen[block]<1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// set up storage for the current block\n\t\t\tList<List<Integer>> currBlock = new ArrayList<List<Integer>>(2);\n\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\tblocks.add(currBlock);\n\n\t\t\t// pos = 0 case\n\t\t\tcurrBlock.get(0).add( optAln[block][0][0] );\n\t\t\tcurrBlock.get(1).add( (optAln[block][1][0]+cp ) % ca2len);\n\t\t\t\n\t\t\tfor(int pos = 1; pos < optLen[block]; pos++) {\n\t\t\t\t//check if we need to start a new block\n\t\t\t\t//this happens when the new alignment crosses the protein terminus\n\t\t\t\tif( optAln[block][1][pos-1]+cp<ca2len && \n\t\t\t\t\t\toptAln[block][1][pos]+cp >= ca2len) {\n\t\t\t\t\tcurrBlock = new ArrayList<List<Integer>>(2);\n\t\t\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\t\t\tcurrBlock.add( new ArrayList<Integer>());\n\t\t\t\t\tblocks.add(currBlock);\n\t\t\t\t}\n\t\t\t\tcurrBlock.get(0).add( optAln[block][0][pos] );\n\t\t\t\tcurrBlock.get(1).add( (optAln[block][1][pos]+cp ) % ca2len);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// save permuted blocks to afpChain\n\t\tassignOptAln(afpChain,blocks);\n\t}\n\n\t/**\n\t * Sometimes it's convenient to store an alignment using java collections,\n\t * where <tt>blocks.get(blockNum).get(0).get(pos)</tt> specifies the aligned\n\t * residue at position <i>pos</i> of block <i>blockNum</i> of the first\n\t * protein.\n\t * \n\t * This method takes such a collection and stores it into the afpChain's\n\t * {@link AFPChain#setOptAln(int[][][]) optAln}, setting the associated\n\t * length variables as well.\n\t * \n\t * @param afpChain\n\t * @param blocks\n\t */\n\tprivate static void assignOptAln(AFPChain afpChain, List<List<List<Integer>>> blocks)\n\t{\n\t\t\n\t\tint[][][] optAln = new int[blocks.size()][][];\n\t\tint[] optLen = new int[blocks.size()];\n\t\tint optLength = 0;\n\t\tint numBlocks = blocks.size();\n\t\t\n\t\tfor(int block = 0; block < numBlocks; block++) {\n\t\t\t// block should be 2xN rectangular\n\t\t\tassert(blocks.get(block).size() == 2);\n\t\t\tassert( blocks.get(block).get(0).size() == blocks.get(block).get(1).size());\n\n\t\t\toptLen[block] = blocks.get(block).get(0).size();\n\t\t\toptLength+=optLen[block];\n\t\t\t\n\t\t\toptAln[block] = new int[][] {\n\t\t\t\t\tnew int[optLen[block]],\n\t\t\t\t\tnew int[optLen[block]]\n\t\t\t};\n\t\t\tfor(int pos = 0; pos < optLen[block]; pos++) {\n\t\t\t\toptAln[block][0][pos] = blocks.get(block).get(0).get(pos);\n\t\t\t\toptAln[block][1][pos] = blocks.get(block).get(1).get(pos);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tafpChain.setBlockNum(numBlocks);\n\t\tafpChain.setOptAln(optAln);\n\t\tafpChain.setOptLen(optLen);\n\t\tafpChain.setOptLength(optLength);\n\t\t\n\t\t// TODO I don't know what these do. Should they be set?\n\t\t//afpChain.setBlockSize(blockSize);\n\t\t//afpChain.setBlockResList(blockResList);\n\t\t//afpChain.setChainLen(chainLen);\n\t\t\n\t}\n\n\t/**\n\t * Finds the optimal alignment between two proteins allowing for a circular\n\t * permutation (CP).\n\t * \n\t * The precise algorithm is controlled by the \n\t * {@link OptimalCECPParameters parameters}. If the parameter\n\t * {@link OptimalCECPParameters#isTryAllCPs() tryAllCPs} is true, all possible\n\t * CP sites are tried and the optimal site is returned. Otherwise, the\n\t * {@link OptimalCECPParameters#getCPPoint() cpPoint} parameter is used to\n\t * determine the CP point, greatly reducing the computation required.\n\t * \n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param param {@link CeParameters} object\n\t * @return The best-scoring alignment\n\t * @throws StructureException\n\t * \n\t * @see #alignOptimal(Atom[], Atom[], Object, AFPChain[])\n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param)\n\tthrows StructureException\n\t{\n\t\tif(params.isTryAllCPs()) {\n\t\t\treturn alignOptimal(ca1,ca2,param,null);\n\t\t} else {\n\t\t\tint cpPoint = params.getCPPoint();\n\t\t\treturn alignPermuted(ca1, ca2, param, cpPoint);\n\t\t}\n\t}\n\n\t/**\n\t * Finds the optimal alignment between two proteins allowing for a circular\n\t * permutation (CP).\n\t * \n\t * This algorithm performs a CE alignment for each possible CP site. This is\n\t * quite slow. Use {@link #alignHeuristic(Atom[], Atom[], Object)} for a\n\t * faster algorithm.\n\t * \n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param param {@link CeParameters} object\n\t * @param alignments If not null, should be an empty array of the same length as\n\t *  ca2. This will be filled with the alignments from permuting ca2 by \n\t *  0 to n-1 residues.\n\t * @return The best-scoring alignment\n\t * @throws StructureException\n\t */\n\tpublic AFPChain alignOptimal(Atom[] ca1, Atom[] ca2, Object param, AFPChain[] alignments)\n\tthrows StructureException\n\t{\n\t\tlong startTime = System.currentTimeMillis();\n\t\t\n\t\tif(alignments.length != ca2.length) {\n\t\t\tthrow new IllegalArgumentException(\"scores param should have same length as ca2\");\n\t\t}\n\t\t// clone ca2 to prevent side effects from propegating\n\t\tAtom[] ca2p = StructureTools.cloneCAArray(ca2);\n\t\t\n\t\tAFPChain unaligned = super.align(ca1, ca2, param);\n\t\tAFPChain bestAlignment = unaligned;\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.print(\".\");\n\t\t}\n\n\t\tif(alignments != null) {\n\t\t\talignments[0] = unaligned;\n\t\t}\n\t\t\n\t\tfor(int cp=1;cp<ca2.length;cp++) {\n\t\t\t//permute one each time. Alters ca2p as a side effect\n\t\t\tAFPChain currentAlignment = alignPermuted(ca1,ca2p,param,1);\n\t\t\t\n\t\t\tif(debug) System.out.print(\".\");\n\t\t\t\n\t\t\t// fix up names, since cloning ca2 wipes it\n\t\t\ttry {\n\t\t\t\tcurrentAlignment.setName2(ca2[0].getGroup().getChain().getParent().getName()+\" CP=\"+cp);\n\t\t\t} catch( Exception e) {\n\t\t\t\t//null pointers, empty arrays, etc.\n\t\t\t}\n\t\t\tdouble currentScore = currentAlignment.getAlignScore();\n\t\t\t\n\t\t\tif(alignments != null) {\n\t\t\t\talignments[cp] = currentAlignment;\n\t\t\t}\n\t\t\t\n\t\t\tif(currentScore>bestAlignment.getAlignScore()) {\n\t\t\t\tbestAlignment = currentAlignment;\n\t\t\t}\n\t\t}\n\t\tif(debug) {\n\t\t\tlong elapsedTime = System.currentTimeMillis()-startTime;\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.format(\"%d alignments took %.4f s (%.1f ms avg)\\n\",\n\t\t\t\t\tca2.length, elapsedTime/1000., (double)elapsedTime/ca2.length);\n\t\t}\n\n\t\t\n\t\treturn bestAlignment;\n\t\t\n\t}\n\n\n\n\t\n\tpublic static void main(String[] args){\n\t\ttry {\n\t\t\tString name1, name2;\n\n\t\t\tint cp=0;\n\t\t\t\n\t\t\t//Concanavalin\n\t\t\tname1 = \"2pel.A\";\n\t\t\tname2 = \"3cna\";\n\t\t\tcp = 122;\n\n\t\t\t//small case\n\t\t\t//name1 = \"d1qdmA1\";\n\t\t\t//name1 = \"1QDM.A\";\n\t\t\t//name2 = \"d1nklA_\";\n\t\t\t//cp = 41;\n\t\t\t\n\t\t\t//1itb selfsymmetry\n\t\t\t//name1 = \"1ITB.A\";\n\t\t\t//name2 = \"1ITB.A\";\n\t\t\t//cp = 92;\n\t\t\t\n\t\t\tOptimalCECPMain ce = (OptimalCECPMain) StructureAlignmentFactory.getAlgorithm(OptimalCECPMain.algorithmName);\n\t\t\tCeParameters params = (CeParameters) ce.getParameters();\n\t\t\tce.setParameters(params);\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\n\t\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\t\t\tAFPChain afpChain;\n\t\t\t/*\n\t\t\t// unpermuted alignment\n\t\t\tafpChain = ce.alignPermuted(ca1, ca2, params, 0);\n\n\t\t\tdisplayAlignment(afpChain, ca1, ca2);\n\t\t\t*/\n\t\t\t\n\t\t\t// permuted alignment\n\t\t\t// new copy of ca2, since alignPermuted has side effects\n\t\t\tAtom[] ca2clone = cache.getAtoms(name2);\n\t\t\tafpChain = ce.alignPermuted(ca1, ca2clone, params, cp);\n\n\t\t\tdisplayAlignment(afpChain, ca1, ca2);\n\n\t\t\t// find optimal solution\t\t\t\n\t\t\tAFPChain[] alignments = new AFPChain[ca2.length];\n\t\t\tafpChain = ce.alignOptimal(ca1, ca2, params, alignments);\n\t\t\tSystem.out.format(\"Optimal Score: %.2f\\n\", afpChain.getAlignScore());\n\t\t\t\n\t\t\tSystem.out.println(\"Pos\\tScore\\tTMScore\\tLen\\tRMSD\\tBlocks\");\n\t\t\tfor(int i = 0; i< alignments.length; i++) {\n\t\t\t\tdouble tm = AFPChainScorer.getTMScore(alignments[i], ca1, ca2);\n\t\t\t\tSystem.out.format(\"%d\\t%.2f\\t%.2f\\t%d\\t%.2f\\t%d\\n\",\n\t\t\t\t\t\ti,\n\t\t\t\t\t\talignments[i].getAlignScore(),\n\t\t\t\t\t\ttm,\n\t\t\t\t\t\talignments[i].getOptLength(),\n\t\t\t\t\t\talignments[i].getTotalRmsdOpt(),\n\t\t\t\t\t\talignments[i].getBlockNum()\n\t\t\t\t);\n\t\t\t}\t\n\t\t\t\n\t\t\tdisplayAlignment(afpChain,ca1,ca2);\n\t\t\t\n\t\t\tfor(int cpPos=0;cpPos<alignments.length;cpPos++) {\n\t\t\t\tAFPChain curr = alignments[cpPos];\n\t\t\t\tif( (!curr.isSequentialAlignment()) || curr.getBlockNum() > 1) {\n\t\t\t\t\tSystem.out.format(\"%d\\t%s\\t%d\\n\", cpPos,curr.isSequentialAlignment(),curr.getBlockNum());\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t * Try showing a the afpChain in a GUI.\n\t * \n\t * <p>requires additional dependancies biojava3-structure-gui and JmolApplet\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @throws ClassNotFoundException\n\t * @throws NoSuchMethodException\n\t * @throws InvocationTargetException\n\t * @throws IllegalAccessException\n\t * @throws StructureException\n\t */\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","originTest":"/**\n * \n */\npackage org.biojava.bio.structure.align.ce;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class OptimalCECPMainTest extends TestCase {\n\n\tAtomCache cache = new AtomCache();\n\t\n\t/* (non-Javadoc)\n\t * @see junit.framework.TestCase#setUp()\n\t */\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\t/**\n\t * Tests private {@link OptimalCECPMain#permuteArray(Object[], int)}\n\t * @throws Exception\n\t */\n\tpublic void testPermuteArray() throws Exception {\n\t\t//test private member using reflection\n\t\tMethod permuteArray = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteArray\", Object[].class, int.class);\n\t\tpermuteArray.setAccessible(true);\n\n\t\tString[] arr0 = new String[] {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n\t\tString[] arr1 = new String[] {\"B\",\"C\",\"D\",\"E\",\"F\",\"A\"};\n\t\tString[] arr5 = new String[] {\"F\",\"A\",\"B\",\"C\",\"D\",\"E\"};\n\n\t\tString[] arrP;\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tassertTrue(\"Shallow equals!\",Arrays.deepEquals(arr0, arrP));\n\n\t\tpermuteArray.invoke(null, arrP, 1);\n\t\tassertTrue(String.format(\"Permuting by 1 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr1, arrP));\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tpermuteArray.invoke(null, arrP, 5);\n\t\tassertTrue(String.format(\"Permuting by 7 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr5, arrP));\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tpermuteArray.invoke(null, arrP, -1);\n\t\tassertTrue(String.format(\"Permuting by -1 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr5, arrP));\n\n\t\ttry {\n\t\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\t\tpermuteArray.invoke(null, arrP, 6);\n\t\t\tfail(\"Illegal index. Should throw exception.\");\n\t\t} catch( InvocationTargetException e) {\n\t\t\tif( ! (e.getCause() instanceof ArrayIndexOutOfBoundsException)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests private {@link OptimalCECPMain#permuteOptAln(AFPChain, int)}\n\t */\n\tpublic void testPermuteOptAln() throws Exception {\n\t\t//test private member using reflection\n\t\tMethod permuteOptAln = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteOptAln\", AFPChain.class, int.class);\n\t\tpermuteOptAln.setAccessible(true);\n\t\t\n\t\t// Two structures with nearly 100% sequence identity\n\t\t/* \n\t\t * Aligned (0-based index):\n\t\t * \t3LB9.A\t1HV1\n\t\t * \t------\t----\n\t\t * \t0-62\t122-184\n\t\t * \t63\t\t0\n\t\t * \t65-181\t1-117\n\t\t * \n\t\t * unaligned:\n\t\t * \t64\t\t-\n\t\t * \t-\t\t118-121\n\t\t * \n\t\t * PDB numbering:\n\t\t * \t+2\t\t+1\n\t\t *\n\t\t */\n\t\tString name1, name2;\n\t\tname1 = \"3LB9.A\";\n\t\tname2 = \"1HV1\";\n\t\t\n\t\tCeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\n\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\tAtom[] ca2 = cache.getAtoms(name2);\n\t\t\n\t\t// Create permuted CA chain\n\t\tMethod permuteArray = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteArray\", Object[].class, int.class);\n\t\tpermuteArray.setAccessible(true);\n\t\tAtom[] ca2p = StructureTools.cloneCAArray(ca2);\n\t\tpermuteArray.invoke(null, ca2p, 63);\n\t\t\n\t\tAFPChain cpAlignment = ce.align(ca1, ca2);\n\t\tSystem.out.println(cpAlignment.toCE(ca1, ca2));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\tassertNotNull(cpAlignment);\n\t\t\n\t\t\n\t\tint[] optLen = cpAlignment.getOptLen();\n\t\tint[][][] optAln = cpAlignment.getOptAln();\n\t\t\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",122,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",184,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",0,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",1,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 0\",118,optAln[1][0][54]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 1\",54,optAln[1][1][54]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 0\",119,optAln[1][0][55]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 1\",55,optAln[1][1][55]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",117,optAln[1][1][117]);\n\n\t\t\n\t\t// permute! should align at 0,0\n\t\tSystem.out.println(\"Permuting by 63 residues...\");\n\t\tpermuteOptAln.invoke(null, cpAlignment, 63);\n\t\tSystem.out.println(cpAlignment.toCE(ca1, ca2p));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\toptLen = cpAlignment.getOptLen();\n\t\toptAln = cpAlignment.getOptAln();\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\t\t\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",0,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",62,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",63,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",64,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",180,optAln[1][1][117]);\n\n\t\t\n\t\t// undo permutation\n\t\tSystem.out.println(\"Permuting by -63 residues...\");\n\t\tpermuteOptAln.invoke(null, cpAlignment, -63);\n\t\tSystem.out.println(cpAlignment.toCE(ca1, ca2));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\toptLen = cpAlignment.getOptLen();\n\t\toptAln = cpAlignment.getOptAln();\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",122,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",184,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",0,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",1,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 0\",118,optAln[1][0][54]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 1\",54,optAln[1][1][54]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 0\",119,optAln[1][0][55]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 1\",55,optAln[1][1][55]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",117,optAln[1][1][117]);\n\n\t}\n\n\t/**\n\t * Print an AFPChain manually for debugging\n\t * @param cpAlignment\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static void printOptAln(AFPChain cpAlignment) {\n\t\tint[] optLen = cpAlignment.getOptLen();\n\t\tint[][][] optAln = cpAlignment.getOptAln();\n\t\t\n\t\tfor(int block=0;block<cpAlignment.getBlockNum();block++) {\n\t\t\tfor(int pos=0;pos<optLen[block]; pos++) {\n\t\t\t\tSystem.out.format(\"%s\\t%s\\n\", optAln[block][0][pos],\n\t\t\t\t\t\toptAln[block][1][pos]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n","changedTest":"/**\n * \n */\npackage org.biojava.bio.structure.align.ce;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class OptimalCECPMainTest extends TestCase {\n\n\tAtomCache cache = new AtomCache();\n\t\n\t/* (non-Javadoc)\n\t * @see junit.framework.TestCase#setUp()\n\t */\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t}\n\t\n\t/**\n\t * Tests private {@link OptimalCECPMain#permuteArray(Object[], int)}\n\t * @throws Exception\n\t */\n\tpublic void testPermuteArray() throws Exception {\n\t\t//test private member using reflection\n\t\tMethod permuteArray = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteArray\", Object[].class, int.class);\n\t\tpermuteArray.setAccessible(true);\n\n\t\tString[] arr0 = new String[] {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"};\n\t\tString[] arr1 = new String[] {\"B\",\"C\",\"D\",\"E\",\"F\",\"A\"};\n\t\tString[] arr5 = new String[] {\"F\",\"A\",\"B\",\"C\",\"D\",\"E\"};\n\n\t\tString[] arrP;\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tassertTrue(\"Shallow equals!\",Arrays.deepEquals(arr0, arrP));\n\n\t\tpermuteArray.invoke(null, arrP, 1);\n\t\tassertTrue(String.format(\"Permuting by 1 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr1, arrP));\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tpermuteArray.invoke(null, arrP, 5);\n\t\tassertTrue(String.format(\"Permuting by 7 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr5, arrP));\n\n\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\tpermuteArray.invoke(null, arrP, -1);\n\t\tassertTrue(String.format(\"Permuting by -1 gave %s%s%s%s%s%s\",(Object[])arrP),\n\t\t\t\tArrays.deepEquals(arr5, arrP));\n\n\t\ttry {\n\t\t\tarrP = Arrays.copyOf(arr0, arr0.length);\n\t\t\tpermuteArray.invoke(null, arrP, 6);\n\t\t\tfail(\"Illegal index. Should throw exception.\");\n\t\t} catch( InvocationTargetException e) {\n\t\t\tif( ! (e.getCause() instanceof ArrayIndexOutOfBoundsException)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests private {@link OptimalCECPMain#permuteOptAln(AFPChain, int)}\n\t */\n\tpublic void testPermuteOptAln() throws Exception {\n\t\t//test private member using reflection\n\t\tMethod permuteOptAln = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteOptAln\", AFPChain.class, int.class);\n\t\tpermuteOptAln.setAccessible(true);\n\t\t\n\t\t// Two structures with nearly 100% sequence identity\n\t\t/* \n\t\t * Aligned (0-based index):\n\t\t * \t3LB9.A\t1HV1\n\t\t * \t------\t----\n\t\t * \t0-62\t122-184\n\t\t * \t63\t\t0\n\t\t * \t65-181\t1-117\n\t\t * \n\t\t * unaligned:\n\t\t * \t64\t\t-\n\t\t * \t-\t\t118-121\n\t\t * \n\t\t * PDB numbering:\n\t\t * \t+2\t\t+1\n\t\t *\n\t\t */\n\t\tString name1, name2;\n\t\tname1 = \"3LB9.A\";\n\t\tname2 = \"1HV1\";\n\t\t\n\t\tCeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\n\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\tAtom[] ca2 = cache.getAtoms(name2);\n\t\t\n\t\t// Create permuted CA chain\n\t\tMethod permuteArray = OptimalCECPMain.class.getDeclaredMethod(\n\t\t\t\t\"permuteArray\", Object[].class, int.class);\n\t\tpermuteArray.setAccessible(true);\n\t\tAtom[] ca2p = StructureTools.cloneCAArray(ca2);\n\t\tpermuteArray.invoke(null, ca2p, 63);\n\t\t\n\t\tAFPChain cpAlignment = ce.align(ca1, ca2);\n\t\t//System.out.println(cpAlignment.toCE(ca1, ca2));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\tassertNotNull(cpAlignment);\n\t\t\n\t\t\n\t\tint[] optLen = cpAlignment.getOptLen();\n\t\tint[][][] optAln = cpAlignment.getOptAln();\n\t\t\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",122,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",184,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",0,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",1,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 0\",118,optAln[1][0][54]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 1\",54,optAln[1][1][54]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 0\",119,optAln[1][0][55]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 1\",55,optAln[1][1][55]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",117,optAln[1][1][117]);\n\n\t\t\n\t\t// permute! should align at 0,0\n\t\t//System.out.println(\"Permuting by 63 residues...\");\n\t\tpermuteOptAln.invoke(null, cpAlignment, 63);\n\t\t//System.out.println(cpAlignment.toCE(ca1, ca2p));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\toptLen = cpAlignment.getOptLen();\n\t\toptAln = cpAlignment.getOptAln();\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\t\t\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",0,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",62,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",63,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",64,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",180,optAln[1][1][117]);\n\n\t\t\n\t\t// undo permutation\n\t\t//System.out.println(\"Permuting by -63 residues...\");\n\t\tpermuteOptAln.invoke(null, cpAlignment, -63);\n\t\t//System.out.println(cpAlignment.toCE(ca1, ca2));\n\t\t//printOptAln(cpAlignment);\n\t\t\n\t\toptLen = cpAlignment.getOptLen();\n\t\toptAln = cpAlignment.getOptAln();\n\t\t\n\t\tassertEquals(\"Wrong total length\",181,cpAlignment.getOptLength());\n\t\tassertEquals(\"Wrong number of blocks\",2, cpAlignment.getBlockNum());\n\t\tassertEquals(\"Wrong block 0 length\",63,optLen[0]);\n\t\tassertEquals(\"Wrong block 1 length\",118,optLen[1]);\n\n\t\t//just test some key positions in each block\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 0\",0,optAln[0][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 0, protein 1\",122,optAln[0][1][0]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 0\",62,optAln[0][0][62]);\n\t\tassertEquals(\"Wrong residue at end of block 0, protein 1\",184,optAln[0][1][62]);\n\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 0\",63,optAln[1][0][0]);\n\t\tassertEquals(\"Wrong residue at start of block 1, protein 1\",0,optAln[1][1][0]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 0\",65,optAln[1][0][1]);\n\t\tassertEquals(\"Wrong residue at pos 1 of block 1, protein 1\",1,optAln[1][1][1]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 0\",118,optAln[1][0][54]);\n\t\tassertEquals(\"Wrong residue at pos 54 of block 1, protein 1\",54,optAln[1][1][54]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 0\",119,optAln[1][0][55]);\n\t\tassertEquals(\"Wrong residue at pos 55 of block 1, protein 1\",55,optAln[1][1][55]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 0\",181,optAln[1][0][117]);\n\t\tassertEquals(\"Wrong residue at end of block 1, protein 1\",117,optAln[1][1][117]);\n\n\t}\n\n\t/**\n\t * Print an AFPChain manually for debugging\n\t * @param cpAlignment\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static void printOptAln(AFPChain cpAlignment) {\n\t\tint[] optLen = cpAlignment.getOptLen();\n\t\tint[][][] optAln = cpAlignment.getOptAln();\n\t\t\n\t\tfor(int block=0;block<cpAlignment.getBlockNum();block++) {\n\t\t\tfor(int pos=0;pos<optLen[block]; pos++) {\n\t\t\t\tSystem.out.format(\"%s\\t%s\\n\", optAln[block][0][pos],\n\t\t\t\t\t\toptAln[block][1][pos]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n","commitMessage":"Referred to some static variables by full name. This prevents confusion when subclasses define a variable with the same name.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9227 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"removing TmpAtomCache\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9337 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}