{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/DSSPParser.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestDSSPParser.java","prod_time":"2020-11-03 08:35:47","test_time":"2020-11-03 08:35:47","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":1,"label":"POSITIVE","prod_commitID":"a6e15ce75dadb7511f6f962330f1d0fcd0d1886f","test_commitID":"a6e15ce75dadb7511f6f962330f1d0fcd0d1886f","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.zip.GZIPInputStream;\n\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Class to parse a DSSP file (output of the DSSP program),\n * that contains the secondary structure assignment of a structure.\n * <p>\n * This class has been ported from the OWL Java library for\n * Structural Bioinformatics (https://github.com/eppic-team/owl).\n * <p>\n * As of September 2015, the DSSP source code and executables can\n * be downloaded from http://swift.cmbi.ru.nl/gv/dssp/.\n *\n * @author Aleix Lafita\n * @since 4.1.1\n *\n */\npublic class DSSPParser {\n\n\tprivate static final Logger logger =\n\t\t\tLoggerFactory.getLogger(DSSPParser.class);\n\n\t/**\n\t * Parse a DSSP output file and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspIs an InputStream to a DSSP file\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseInputStream(InputStream dsspIs,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(dsspIs));\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\t/**\n\t * Parse a DSSP output file and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspPath path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseFile(String dsspPath,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tFile file = new File(dsspPath);\n\t\tReader read = new FileReader(file);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\t/**\n\t * Fetch and parse the DSSP file of the specified pdb code\n\t * from the PDB web server and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param pdb path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> fetch(String pdb,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tURL url = new URL(\"http://files.rcsb.org/dssp/\" +\n\t\t\t\tpdb.toLowerCase().substring(1, 3) + \"/\" +\n\t\t\t\tpdb.toLowerCase() + \"/\" +\n\t\t\t\tpdb.toLowerCase() + \".dssp.gz\");\n\t\tInputStream in = new GZIPInputStream(url.openStream());\n\t\tReader read = new InputStreamReader(in);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\t/**\n\t * Parse a DSSP format String and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspOut String with the DSSP output to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseString(String dsspOut,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tReader read = new StringReader(dsspOut);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\tprivate static List<SecStrucState> generalParse(BufferedReader reader,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tString startLine = \"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC\";\n\t\tString line;\n\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\n\t\t//Find the first line of the DSSP output\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\tif(line.startsWith(startLine)) break;\n\t\t}\n\n\t\twhile((line = reader.readLine()) != null) {\n\n\t\t\tString indexStr = line.substring(0,5).trim();\n\t\t\tString resNumStr = line.substring(5,10).trim();\n\n\t\t\t//Only happens if dssp inserts a line indicating a chain break\n\t\t\tif(!resNumStr.equals(\"\")) {\n\n\t\t\t\tint index = Integer.parseInt(indexStr);\n\t\t\t\t//Get the group of the structure corresponding to the residue\n\t\t\t\tint resNum = Integer.parseInt(resNumStr);\n\t\t\t\tchar insCode = line.charAt(10);\n\t\t\t\tString chainId = line.substring(11,13).trim();\n\t\t\t\tResidueNumber r = new ResidueNumber(chainId, resNum, insCode);\n\t\t\t\tGroup parent = structure.getPolyChainByPDB(chainId)\n\t\t\t\t\t\t.getGroupByPDB(r);\n\t\t\t\tSecStrucType ssType =\n\t\t\t\t\t\tSecStrucType.fromCharacter(line.charAt(16));\n\n\t\t\t\tSecStrucState ss = new SecStrucState(parent,\n\t\t\t\t\t\tSecStrucInfo.DSSP_ASSIGNMENT, ssType);\n\n\t\t\t\t//Parse the Bridge partners - TODO parallel or antiparallel?\n\t\t\t\tString bp = line.substring(25,29).trim();\n\t\t\t\tif (bp != \"\") {\n\t\t\t\t\tBetaBridge bb = new BetaBridge(\n\t\t\t\t\t\t\tindex, Integer.valueOf(bp), BridgeType.parallel);\n\t\t\t\t\tss.addBridge(bb);\n\t\t\t\t} else logger.warn(\"Unable to parse beta Bridge for resn \"+index);\n\n\t\t\t\tbp = line.substring(29,33).trim();\n\t\t\t\tif (bp != \"\") {\n\t\t\t\t\tBetaBridge bb = new BetaBridge(\n\t\t\t\t\t\t\tindex, Integer.valueOf(bp), BridgeType.parallel);\n\t\t\t\t\tss.addBridge(bb);\n\t\t\t\t} else logger.warn(\"Unable to parse beta Bridge for resn \"+index);\n\n\t\t\t\t//Parse the energy terms of donor and acceptor\n\t\t\t\tfor (int i=0; i<4; i++){\n\n\t\t\t\t\tint a = 42 + i*11;\n\t\t\t\t\tint b = a + 8;\n\n\t\t\t\t\tString val = line.substring(a,b).trim();\n\t\t\t\t\tif (val == \"\") {\n\t\t\t\t\t\tlogger.warn(\"Unable to parse energy for resn \"+index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString[] p = val.split(\",\");\n\n\t\t\t\t\tint partner = Integer.parseInt(p[0]);\n\t\t\t\t\tif (partner != 0) partner += index;\n\t\t\t\t\tdouble energy = Double.valueOf(p[1]) * 1000.0;\n\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tss.getAccept1().setPartner(partner);\n\t\t\t\t\t\tss.getAccept1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tss.getDonor1().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tss.getAccept2().setPartner(partner);\n\t\t\t\t\t\tss.getAccept2().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tss.getDonor2().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Angle properties\n\t\t\t\tString val = line.substring(91,97).trim();\n\t\t\t\tif (val != \"\") ss.setKappa(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse kappa for resn \"+index);\n\n\t\t\t\tval = line.substring(103,109).trim();\n\t\t\t\tif (val != \"\") ss.setPhi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse phi for resn \"+index);\n\n\t\t\t\tval = line.substring(109,116).trim();\n\t\t\t\tif (val != \"\") ss.setPsi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse psi for resn \"+index);\n\n\t\t\t\tif (assign) parent.setProperty(Group.SEC_STRUC, ss);\n\t\t\t\tsecstruc.add(ss);\n\t\t\t}\n\t\t}\n\n\t\treader.close();\n\t\treturn secstruc;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Class to parse a DSSP file (output of the DSSP program),\n * that contains the secondary structure assignment of a structure.\n * <p>\n * This class has been ported from the OWL Java library for\n * Structural Bioinformatics (https://github.com/eppic-team/owl).\n * <p>\n * As of September 2015, the DSSP source code and executables can\n * be downloaded from http://swift.cmbi.ru.nl/gv/dssp/.\n *\n * @author Aleix Lafita\n * @since 4.1.1\n *\n */\npublic class DSSPParser {\n\n\tprivate static final Logger logger =\n\t\t\tLoggerFactory.getLogger(DSSPParser.class);\n\n\t/**\n\t * Parse a DSSP output file and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspIs an InputStream to a DSSP file\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseInputStream(InputStream dsspIs,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(dsspIs));\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\t/**\n\t * Parse a DSSP output file and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspPath path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseFile(String dsspPath,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tFile file = new File(dsspPath);\n\t\tReader read = new FileReader(file);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\t/**\n\t * Parse a DSSP format String and return the secondary structure\n\t * annotation as a List of {@link SecStrucState} objects.\n\t *\n\t * @param dsspOut String with the DSSP output to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseString(String dsspOut,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tReader read = new StringReader(dsspOut);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\n\tprivate static List<SecStrucState> generalParse(BufferedReader reader,\n\t\t\tStructure structure, boolean assign)\n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tString startLine = \"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC\";\n\t\tString line;\n\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\n\t\t//Find the first line of the DSSP output\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\tif(line.startsWith(startLine)) break;\n\t\t}\n\n\t\twhile((line = reader.readLine()) != null) {\n\n\t\t\tString indexStr = line.substring(0,5).trim();\n\t\t\tString resNumStr = line.substring(5,10).trim();\n\n\t\t\t//Only happens if dssp inserts a line indicating a chain break\n\t\t\tif(!resNumStr.equals(\"\")) {\n\n\t\t\t\tint index = Integer.parseInt(indexStr);\n\t\t\t\t//Get the group of the structure corresponding to the residue\n\t\t\t\tint resNum = Integer.parseInt(resNumStr);\n\t\t\t\tchar insCode = line.charAt(10);\n\t\t\t\tString chainId = line.substring(11,13).trim();\n\t\t\t\tResidueNumber r = new ResidueNumber(chainId, resNum, insCode);\n\t\t\t\tGroup parent = structure.getPolyChainByPDB(chainId)\n\t\t\t\t\t\t.getGroupByPDB(r);\n\t\t\t\tSecStrucType ssType =\n\t\t\t\t\t\tSecStrucType.fromCharacter(line.charAt(16));\n\n\t\t\t\tSecStrucState ss = new SecStrucState(parent,\n\t\t\t\t\t\tSecStrucInfo.DSSP_ASSIGNMENT, ssType);\n\n\t\t\t\t//Parse the Bridge partners - TODO parallel or antiparallel?\n\t\t\t\tString bp = line.substring(25,29).trim();\n\t\t\t\tif (bp != \"\") {\n\t\t\t\t\tBetaBridge bb = new BetaBridge(\n\t\t\t\t\t\t\tindex, Integer.valueOf(bp), BridgeType.parallel);\n\t\t\t\t\tss.addBridge(bb);\n\t\t\t\t} else logger.warn(\"Unable to parse beta Bridge for resn \"+index);\n\n\t\t\t\tbp = line.substring(29,33).trim();\n\t\t\t\tif (bp != \"\") {\n\t\t\t\t\tBetaBridge bb = new BetaBridge(\n\t\t\t\t\t\t\tindex, Integer.valueOf(bp), BridgeType.parallel);\n\t\t\t\t\tss.addBridge(bb);\n\t\t\t\t} else logger.warn(\"Unable to parse beta Bridge for resn \"+index);\n\n\t\t\t\t//Parse the energy terms of donor and acceptor\n\t\t\t\tfor (int i=0; i<4; i++){\n\n\t\t\t\t\tint a = 42 + i*11;\n\t\t\t\t\tint b = a + 8;\n\n\t\t\t\t\tString val = line.substring(a,b).trim();\n\t\t\t\t\tif (val == \"\") {\n\t\t\t\t\t\tlogger.warn(\"Unable to parse energy for resn \"+index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString[] p = val.split(\",\");\n\n\t\t\t\t\tint partner = Integer.parseInt(p[0]);\n\t\t\t\t\tif (partner != 0) partner += index;\n\t\t\t\t\tdouble energy = Double.valueOf(p[1]) * 1000.0;\n\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tss.getAccept1().setPartner(partner);\n\t\t\t\t\t\tss.getAccept1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tss.getDonor1().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tss.getAccept2().setPartner(partner);\n\t\t\t\t\t\tss.getAccept2().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tss.getDonor2().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Angle properties\n\t\t\t\tString val = line.substring(91,97).trim();\n\t\t\t\tif (val != \"\") ss.setKappa(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse kappa for resn \"+index);\n\n\t\t\t\tval = line.substring(103,109).trim();\n\t\t\t\tif (val != \"\") ss.setPhi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse phi for resn \"+index);\n\n\t\t\t\tval = line.substring(109,116).trim();\n\t\t\t\tif (val != \"\") ss.setPsi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse psi for resn \"+index);\n\n\t\t\t\tif (assign) parent.setProperty(Group.SEC_STRUC, ss);\n\t\t\t\tsecstruc.add(ss);\n\t\t\t}\n\t\t}\n\n\t\treader.close();\n\t\treturn secstruc;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.zip.GZIPInputStream;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test all the options for writting and fetching DSSP file formats. Also\n * compare that files match the prediction (assumed to be correct).\n *\n * @author Aleix Lafita\n *\n */\npublic class TestDSSPParser {\n\n\t@Test\n\tpublic void testDSSPParser() throws IOException, StructureException {\n\n\t\t// List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"5pti\");\n\n\t\tfor (String name : names) {\n\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tStructure s = cache.getStructure(name);\n\n\t\t\t// Test loading from file\n\t\t\tList<SecStrucState> file = DSSPParser.parseInputStream(new GZIPInputStream(\n\t\t\t\t\tthis.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/secstruc/\"+name+\".dssp.gz\")), s, false);\n\n\t\t\t// Test fetching from PDB\n\t\t\tList<SecStrucState> pdb = DSSPParser.fetch(name, s, false);\n\n\t\t\t// Test predicting, writting and parsing back\n\t\t\tSecStrucCalc sec = new SecStrucCalc();\n\t\t\tList<SecStrucState> pred = sec.calculate(s, false);\n\n\t\t\tList<SecStrucState> parseBack = DSSPParser.parseString(\n\t\t\t\t\tsec.toString(), s, false);\n\n\t\t\tassertTrue(\n\t\t\t\t\t\"SS assignment lengths do not match\",\n\t\t\t\t\tfile.size() == pdb.size()\n\t\t\t\t\t\t\t&& pred.size() == parseBack.size()\n\t\t\t\t\t\t\t&& pred.size() == file.size());\n\n\t\t\tfor (int i = 0; i < file.size(); i++) {\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", file.get(i), pdb.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", pred.get(i), parseBack.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", file.get(i), pred.get(i));\n\t\t\t}\n\t\t}\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.zip.GZIPInputStream;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test all the options for writting and fetching DSSP file formats. Also\n * compare that files match the prediction (assumed to be correct).\n *\n * @author Aleix Lafita\n *\n */\npublic class TestDSSPParser {\n\n\t@Test\n\tpublic void testDSSPParser() throws IOException, StructureException {\n\n\t\t// List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"5pti\");\n\n\t\tfor (String name : names) {\n\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tStructure s = cache.getStructure(name);\n\n\t\t\t// Test loading from file\n\t\t\tList<SecStrucState> file = DSSPParser.parseInputStream(new GZIPInputStream(\n\t\t\t\t\tthis.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/secstruc/\"+name+\".dssp.gz\")), s, false);\n\n\t\t\t// Test predicting, writing and parsing back\n\t\t\tSecStrucCalc sec = new SecStrucCalc();\n\t\t\tList<SecStrucState> pred = sec.calculate(s, false);\n\n\t\t\tList<SecStrucState> parseBack = DSSPParser.parseString(\n\t\t\t\t\tsec.toString(), s, false);\n\n\t\t\tassertTrue(\n\t\t\t\t\t\"SS assignment lengths do not match\",\n\t\t\t\t\tpred.size() == parseBack.size()\n\t\t\t\t\t\t\t&& pred.size() == file.size());\n\n\t\t\tfor (int i = 0; i < file.size(); i++) {\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", pred.get(i), parseBack.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", file.get(i), pred.get(i));\n\t\t\t}\n\t\t}\n\t}\n\n}\n","commitMessage":"Removing DSSPParser.fetch after RCSB deprecation\n","test_commitMessage":"Removing DSSPParser.fetch after RCSB deprecation\n","allZero":false}