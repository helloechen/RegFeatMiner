package SITAR;

import com.github.difflib.DiffUtils;
import com.github.difflib.patch.AbstractDelta;
import com.github.difflib.patch.Patch;


import java.util.List;
import java.util.Arrays;
import java.lang.String;
import java.util.ArrayList;

public class CodeCleaner {
    public static String removeCommentsAndImports(String code) {
        String punctuationRegex = "[\\p{P}]";
        // Remove multi-line comments
        code = code.replaceAll("(?s)/\\*.*?\\*/", "");
        // Remove single-line comments (//)
        code = code.replaceAll("//.*", "");
        // Remove import statements
        code = code.replaceAll("(?m)^\\s*import.*$", "");
        // Remove empty lines (including lines with only spaces or tabs)
        code = code.replaceAll("(?m)^\\s*$", "");

        code = code.replaceAll(punctuationRegex, " ");

        return code.trim();
    }

    public static String removeCommentsAndImportsCount(String code) {
        String punctuationRegex = "[\\p{P}]";
        // Remove multi-line comments
        code = code.replaceAll("(?s)/\\*.*?\\*/", "");
        // Remove single-line comments (//)
        code = code.replaceAll("//.*", "");
        // Remove empty lines (including lines with only spaces or tabs)
        code = code.replaceAll("(?m)^\\s*$", "");

        code = code.replaceAll(punctuationRegex, " ");

        return code.trim();
    }

    public static List<String> getModifiedUnits(String code, String code2) {
        List<String> change1 = new ArrayList<>();
//        String code = "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.configuration.tree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * <p>\n * A simple data class used by node models to store parameters of an update\n * operation.\n * </p>\n * <p>\n * The {@code Configuration} interface provides a method for setting the value\n * of a given key. The passed in value can be a single object or a collection of\n * values. This makes an update operation rather complicated because a\n * collection of nodes identified by the passed in key has to be matched to\n * another collection of values - and both collections can have different sizes.\n * Therefore, an update operation may involve changing of existing nodes, adding\n * new nodes (if there are more values than currently existing nodes), and\n * removing nodes (if there are more existing nodes than provided values). This\n * class collects all this information making it possible to actually perform\n * the update based on a passed in instance.\n * </p>\n *\n * @version $Id$\n * @since 2.0\n * @param <T> the type of nodes involved in this update operation\n */\npublic class NodeUpdateData<T>\n{\n    /** The map with the nodes whose value has to be changed. */\n    private final Map<T, Object> changedValues;\n\n    /** The collection with the new values to be added. */\n    private final Collection<Object> newValues;\n\n    /** The collection with the nodes to be removed. */\n    private final Collection<T> removedNodes;\n\n    /** The key of the current update operation. */\n    private final String key;\n\n    /**\n     * Creates a new instance of {@code NodeUpdateData} and initializes all its\n     * properties. All passed in collections are optional and can be\n     * <b>null</b>.\n     *\n     * @param changedValues the map defining the changed values\n     * @param newValues the collection with the new values\n     * @param removedNodes the collection with the nodes to be removed\n     * @param key the key of the update operation\n     */\n    public NodeUpdateData(Map<T, Object> changedValues,\n            Collection<Object> newValues, Collection<T> removedNodes, String key)\n    {\n        this.changedValues = copyMap(changedValues);\n        this.newValues = copyCollection(newValues);\n        this.removedNodes = copyCollection(removedNodes);\n        this.key = key;\n    }\n\n    /**\n     * Returns an unmodifiable map with the values to be changed. The keys of\n     * the map are the nodes affected, the values are the new values to be\n     * assigned to these nodes.\n     *\n     * @return the map with values to be changed\n     */\n    public Map<T, Object> getChangedValues()\n    {\n        return changedValues;\n    }\n\n    /**\n     * Returns a collection with the values to be newly added. For these values\n     * new nodes have to be created and added under the key stored in this\n     * object.\n     *\n     * @return the collection with new values\n     */\n    public Collection<Object> getNewValues()\n    {\n        return newValues;\n    }\n\n    /**\n     * Adds a collection with the nodes to be removed. These nodes are no longer\n     * needed and have to be removed from the node model processing this\n     * request.\n     *\n     * @return the collection with nodes to be removed\n     */\n    public Collection<T> getRemovedNodes()\n    {\n        return removedNodes;\n    }\n\n    /**\n     * Returns the key for this update operation.\n     *\n     * @return the key for this operation\n     */\n    public String getKey()\n    {\n        return key;\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in map which may be\n     * null.\n     *\n     * @param map the map to be copied\n     * @param <K> the type of the keys involved\n     * @param <V> the type of the values involved\n     * @return the unmodifiable copy\n     */\n    private static <K, V> Map<K, V> copyMap(Map<? extends K, ? extends V> map)\n    {\n        if (map == null)\n        {\n            return Collections.emptyMap();\n        }\n        else\n        {\n            return Collections.unmodifiableMap(new HashMap<K, V>(map));\n        }\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in collection with\n     * may be null.\n     *\n     * @param col the collection to be copied\n     * @param <T> the element type of the collection\n     * @return the unmodifiable copy\n     */\n    private static <T> Collection<T> copyCollection(Collection<? extends T> col)\n    {\n        if (col == null)\n        {\n            return Collections.emptySet();\n        }\n        else\n        {\n            return Collections.unmodifiableCollection(new ArrayList<T>(col));\n        }\n    }\n}\n";
//        String code2 = "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.configuration.tree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * <p>\n * A simple data class used by node models to store parameters of an update\n * operation.\n * </p>\n * <p>\n * The {@code Configuration} interface provides a method for setting the value\n * of a given key. The passed in value can be a single object or a collection of\n * values. This makes an update operation rather complicated because a\n * collection of query results selected by the passed in key has to be matched\n * to another collection of values - and both collections can have different\n * sizes. Therefore, an update operation may involve changing of existing nodes,\n * adding new nodes (if there are more values than currently existing nodes),\n * and removing nodes (if there are more existing nodes than provided values).\n * This class collects all this information making it possible to actually\n * perform the update based on a passed in instance.\n * </p>\n *\n * @version $Id$\n * @since 2.0\n * @param <T> the type of nodes involved in this update operation\n */\npublic class NodeUpdateData<T>\n{\n    /** The map with the query results whose value has to be changed. */\n    private final Map<QueryResult<T>, Object> changedValues;\n\n    /** The collection with the new values to be added. */\n    private final Collection<Object> newValues;\n\n    /** The collection with query results about the nodes to be removed. */\n    private final Collection<QueryResult<T>> removedNodes;\n\n    /** The key of the current update operation. */\n    private final String key;\n\n    /**\n     * Creates a new instance of {@code NodeUpdateData} and initializes all its\n     * properties. All passed in collections are optional and can be\n     * <b>null</b>.\n     *\n     * @param changedValues the map defining the changed values\n     * @param newValues the collection with the new values\n     * @param removedNodes the collection with the nodes to be removed\n     * @param key the key of the update operation\n     */\n    public NodeUpdateData(Map<QueryResult<T>, Object> changedValues,\n            Collection<Object> newValues,\n            Collection<QueryResult<T>> removedNodes, String key)\n    {\n        this.changedValues = copyMap(changedValues);\n        this.newValues = copyCollection(newValues);\n        this.removedNodes = copyCollection(removedNodes);\n        this.key = key;\n    }\n\n    /**\n     * Returns an unmodifiable map with the values to be changed. The keys of\n     * the map are the query results for the nodes affected, the values are the\n     * new values to be assigned to these nodes.\n     *\n     * @return the map with values to be changed\n     */\n    public Map<QueryResult<T>, Object> getChangedValues()\n    {\n        return changedValues;\n    }\n\n    /**\n     * Returns a collection with the values to be newly added. For these values\n     * new nodes have to be created and added under the key stored in this\n     * object.\n     *\n     * @return the collection with new values\n     */\n    public Collection<Object> getNewValues()\n    {\n        return newValues;\n    }\n\n    /**\n     * Adds a collection with the nodes to be removed. These nodes are no longer\n     * needed and have to be removed from the node model processing this\n     * request.\n     *\n     * @return the collection with nodes to be removed\n     */\n    public Collection<QueryResult<T>> getRemovedNodes()\n    {\n        return removedNodes;\n    }\n\n    /**\n     * Returns the key for this update operation.\n     *\n     * @return the key for this operation\n     */\n    public String getKey()\n    {\n        return key;\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in map which may be\n     * null.\n     *\n     * @param map the map to be copied\n     * @param <K> the type of the keys involved\n     * @param <V> the type of the values involved\n     * @return the unmodifiable copy\n     */\n    private static <K, V> Map<K, V> copyMap(Map<? extends K, ? extends V> map)\n    {\n        if (map == null)\n        {\n            return Collections.emptyMap();\n        }\n        else\n        {\n            return Collections.unmodifiableMap(new HashMap<K, V>(map));\n        }\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in collection with\n     * may be null.\n     *\n     * @param col the collection to be copied\n     * @param <T> the element type of the collection\n     * @return the unmodifiable copy\n     */\n    private static <T> Collection<T> copyCollection(Collection<? extends T> col)\n    {\n        if (col == null)\n        {\n            return Collections.emptySet();\n        }\n        else\n        {\n            return Collections.unmodifiableCollection(new ArrayList<T>(col));\n        }\n    }\n}\n";
        String cleanedCode = removeCommentsAndImports(code);
        String cleanedCode2 = removeCommentsAndImports(code2);
//        System.out.println(cleanedCode);
//        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++");
//        System.out.println(cleanedCode2);
        List<String> originalTokens = Arrays.asList(cleanedCode.split("\\s+"));
        List<String> modifiedTokens = Arrays.asList(cleanedCode2.split("\\s+"));

        Patch<String> patch = DiffUtils.diff(originalTokens, modifiedTokens);
        List<AbstractDelta<String>> deltas = patch.getDeltas();
        for (var delta : deltas) {
//            System.out.println(delta.getSource().getLines());
//            System.out.println(delta.getTarget().getLines());
//            System.out.println("+++++++");
            for(String s : delta.getSource().getLines()) {
                change1.add(s);
            }
            for(String s : delta.getTarget().getLines()) {
                change1.add(s);
            }
        }
        System.out.println(change1);
        return change1;
    }


    public static int getModifiedUnitsCount(String code, String code2) {
        List<String> change1 = new ArrayList<>();
//        String code = "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.configuration.tree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * <p>\n * A simple data class used by node models to store parameters of an update\n * operation.\n * </p>\n * <p>\n * The {@code Configuration} interface provides a method for setting the value\n * of a given key. The passed in value can be a single object or a collection of\n * values. This makes an update operation rather complicated because a\n * collection of nodes identified by the passed in key has to be matched to\n * another collection of values - and both collections can have different sizes.\n * Therefore, an update operation may involve changing of existing nodes, adding\n * new nodes (if there are more values than currently existing nodes), and\n * removing nodes (if there are more existing nodes than provided values). This\n * class collects all this information making it possible to actually perform\n * the update based on a passed in instance.\n * </p>\n *\n * @version $Id$\n * @since 2.0\n * @param <T> the type of nodes involved in this update operation\n */\npublic class NodeUpdateData<T>\n{\n    /** The map with the nodes whose value has to be changed. */\n    private final Map<T, Object> changedValues;\n\n    /** The collection with the new values to be added. */\n    private final Collection<Object> newValues;\n\n    /** The collection with the nodes to be removed. */\n    private final Collection<T> removedNodes;\n\n    /** The key of the current update operation. */\n    private final String key;\n\n    /**\n     * Creates a new instance of {@code NodeUpdateData} and initializes all its\n     * properties. All passed in collections are optional and can be\n     * <b>null</b>.\n     *\n     * @param changedValues the map defining the changed values\n     * @param newValues the collection with the new values\n     * @param removedNodes the collection with the nodes to be removed\n     * @param key the key of the update operation\n     */\n    public NodeUpdateData(Map<T, Object> changedValues,\n            Collection<Object> newValues, Collection<T> removedNodes, String key)\n    {\n        this.changedValues = copyMap(changedValues);\n        this.newValues = copyCollection(newValues);\n        this.removedNodes = copyCollection(removedNodes);\n        this.key = key;\n    }\n\n    /**\n     * Returns an unmodifiable map with the values to be changed. The keys of\n     * the map are the nodes affected, the values are the new values to be\n     * assigned to these nodes.\n     *\n     * @return the map with values to be changed\n     */\n    public Map<T, Object> getChangedValues()\n    {\n        return changedValues;\n    }\n\n    /**\n     * Returns a collection with the values to be newly added. For these values\n     * new nodes have to be created and added under the key stored in this\n     * object.\n     *\n     * @return the collection with new values\n     */\n    public Collection<Object> getNewValues()\n    {\n        return newValues;\n    }\n\n    /**\n     * Adds a collection with the nodes to be removed. These nodes are no longer\n     * needed and have to be removed from the node model processing this\n     * request.\n     *\n     * @return the collection with nodes to be removed\n     */\n    public Collection<T> getRemovedNodes()\n    {\n        return removedNodes;\n    }\n\n    /**\n     * Returns the key for this update operation.\n     *\n     * @return the key for this operation\n     */\n    public String getKey()\n    {\n        return key;\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in map which may be\n     * null.\n     *\n     * @param map the map to be copied\n     * @param <K> the type of the keys involved\n     * @param <V> the type of the values involved\n     * @return the unmodifiable copy\n     */\n    private static <K, V> Map<K, V> copyMap(Map<? extends K, ? extends V> map)\n    {\n        if (map == null)\n        {\n            return Collections.emptyMap();\n        }\n        else\n        {\n            return Collections.unmodifiableMap(new HashMap<K, V>(map));\n        }\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in collection with\n     * may be null.\n     *\n     * @param col the collection to be copied\n     * @param <T> the element type of the collection\n     * @return the unmodifiable copy\n     */\n    private static <T> Collection<T> copyCollection(Collection<? extends T> col)\n    {\n        if (col == null)\n        {\n            return Collections.emptySet();\n        }\n        else\n        {\n            return Collections.unmodifiableCollection(new ArrayList<T>(col));\n        }\n    }\n}\n";
//        String code2 = "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.configuration.tree;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * <p>\n * A simple data class used by node models to store parameters of an update\n * operation.\n * </p>\n * <p>\n * The {@code Configuration} interface provides a method for setting the value\n * of a given key. The passed in value can be a single object or a collection of\n * values. This makes an update operation rather complicated because a\n * collection of query results selected by the passed in key has to be matched\n * to another collection of values - and both collections can have different\n * sizes. Therefore, an update operation may involve changing of existing nodes,\n * adding new nodes (if there are more values than currently existing nodes),\n * and removing nodes (if there are more existing nodes than provided values).\n * This class collects all this information making it possible to actually\n * perform the update based on a passed in instance.\n * </p>\n *\n * @version $Id$\n * @since 2.0\n * @param <T> the type of nodes involved in this update operation\n */\npublic class NodeUpdateData<T>\n{\n    /** The map with the query results whose value has to be changed. */\n    private final Map<QueryResult<T>, Object> changedValues;\n\n    /** The collection with the new values to be added. */\n    private final Collection<Object> newValues;\n\n    /** The collection with query results about the nodes to be removed. */\n    private final Collection<QueryResult<T>> removedNodes;\n\n    /** The key of the current update operation. */\n    private final String key;\n\n    /**\n     * Creates a new instance of {@code NodeUpdateData} and initializes all its\n     * properties. All passed in collections are optional and can be\n     * <b>null</b>.\n     *\n     * @param changedValues the map defining the changed values\n     * @param newValues the collection with the new values\n     * @param removedNodes the collection with the nodes to be removed\n     * @param key the key of the update operation\n     */\n    public NodeUpdateData(Map<QueryResult<T>, Object> changedValues,\n            Collection<Object> newValues,\n            Collection<QueryResult<T>> removedNodes, String key)\n    {\n        this.changedValues = copyMap(changedValues);\n        this.newValues = copyCollection(newValues);\n        this.removedNodes = copyCollection(removedNodes);\n        this.key = key;\n    }\n\n    /**\n     * Returns an unmodifiable map with the values to be changed. The keys of\n     * the map are the query results for the nodes affected, the values are the\n     * new values to be assigned to these nodes.\n     *\n     * @return the map with values to be changed\n     */\n    public Map<QueryResult<T>, Object> getChangedValues()\n    {\n        return changedValues;\n    }\n\n    /**\n     * Returns a collection with the values to be newly added. For these values\n     * new nodes have to be created and added under the key stored in this\n     * object.\n     *\n     * @return the collection with new values\n     */\n    public Collection<Object> getNewValues()\n    {\n        return newValues;\n    }\n\n    /**\n     * Adds a collection with the nodes to be removed. These nodes are no longer\n     * needed and have to be removed from the node model processing this\n     * request.\n     *\n     * @return the collection with nodes to be removed\n     */\n    public Collection<QueryResult<T>> getRemovedNodes()\n    {\n        return removedNodes;\n    }\n\n    /**\n     * Returns the key for this update operation.\n     *\n     * @return the key for this operation\n     */\n    public String getKey()\n    {\n        return key;\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in map which may be\n     * null.\n     *\n     * @param map the map to be copied\n     * @param <K> the type of the keys involved\n     * @param <V> the type of the values involved\n     * @return the unmodifiable copy\n     */\n    private static <K, V> Map<K, V> copyMap(Map<? extends K, ? extends V> map)\n    {\n        if (map == null)\n        {\n            return Collections.emptyMap();\n        }\n        else\n        {\n            return Collections.unmodifiableMap(new HashMap<K, V>(map));\n        }\n    }\n\n    /**\n     * Creates an unmodifiable defensive copy of the passed in collection with\n     * may be null.\n     *\n     * @param col the collection to be copied\n     * @param <T> the element type of the collection\n     * @return the unmodifiable copy\n     */\n    private static <T> Collection<T> copyCollection(Collection<? extends T> col)\n    {\n        if (col == null)\n        {\n            return Collections.emptySet();\n        }\n        else\n        {\n            return Collections.unmodifiableCollection(new ArrayList<T>(col));\n        }\n    }\n}\n";
        String cleanedCode = removeCommentsAndImportsCount(code);
        String cleanedCode2 = removeCommentsAndImportsCount(code2);
//        System.out.println(cleanedCode);
//        System.out.println("+++++++++++++++++++++++++++++++++++++++++++++++++++");
//        System.out.println(cleanedCode2);
        List<String> originalTokens = Arrays.asList(cleanedCode.split("\\s+"));
        List<String> modifiedTokens = Arrays.asList(cleanedCode2.split("\\s+"));

        Patch<String> patch = DiffUtils.diff(originalTokens, modifiedTokens);
        List<AbstractDelta<String>> deltas = patch.getDeltas();
        for (var delta : deltas) {
//            System.out.println(delta.getSource().getLines());
//            System.out.println(delta.getTarget().getLines());
//            System.out.println("+++++++");
            for(String s : delta.getSource().getLines()) {
                change1.add(s);
            }
            for(String s : delta.getTarget().getLines()) {
                change1.add(s);
            }
        }
        System.out.println(change1);
        return change1.size();
    }
}