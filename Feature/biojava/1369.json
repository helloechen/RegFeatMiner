{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/align/ce/CeCPMain.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/align/ce/CeCPMainTest.java","prod_time":"2011-09-13 08:38:43","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"NEGATIVE","prod_commitID":"35e17d7a40bc23091ee1a04fcceb1f5b49110ed8","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPAlignmentDisplay;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class CeCPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\tpublic static final String algorithmName = \"jCE Circular Permutation\";\n\n\tpublic static final String version = \"1.0\";\n\t\n\n\tpublic CeCPMain(){\n\t\tsuper();\n\t\tthis.params.setMaxGapSize(0);\n\t}\n\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry {\n\t\t\tString name1, name2;\n\n\t\t\t//Concanavalin\n\t\t\tname1 = \"2pel.A\";\n\t\t\tname2 = \"3cna\";\n\n\t\t\t//small case\n\t\t\tname1 = \"d1qdmA1\";\n\t\t\t//name1 = \"1QDM.A\";\n\t\t\tname2 = \"d1nklA_\";\n\t\t\t\n\t\t\tCeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\t\t\tCeParameters params = (CeParameters) ce.getParameters();\n\t\t\tce.setParameters(params);\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\n\t\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.format(\"Aligning %s to %s\\n\",\n\t\t\t\t\tca1[0].getGroup().getChain().getParent().getName(),\n\t\t\t\t\tca2[0].getGroup().getChain().getParent().getName() );\n\t\t\t}\n\t\t\tAFPChain afpChain = ce.align(ca1, ca2);\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.format(\"Finished aligning %s to %s\\n\", afpChain.getName1(),afpChain.getName2());\n\t\t\t\tSystem.out.format(\"Heuristic Score: %.2f\\n\", afpChain.getAlignScore());\n\t\t\t}\n\t\t\t\n\t\t\tint cp = afpChain.getOptAln()[0][1][0];\n\t\t\tSystem.out.println(\"CP at \"+cp);\n\t\t\t\n\t\t\tdisplayAlignment(afpChain,ca1,ca2);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/** Circular permutation specific code to be run before a standard CE alignment\n\t * \n\t * @param ca2 original C-alpha atom array\n\t * @return new Atom array (a duplicated ca2)\n\t * @throws StructureException\n\t */\n\tpublic static Atom[] prepareAtomsForAlign(Atom[] ca2) throws StructureException{\n\t\t// Duplicate ca2\n\t\tAtom[] ca2m = new Atom[ca2.length*2];\n\n\t\tint pos = 0;\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone(); // works because each group has only a CA atom\n\t\t\tca2m[pos] = g.getAtom(StructureTools.caAtomName);\n\t\t\tpos++;\n\t\t}\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone();\n\t\t\tca2m[pos] = g.getAtom(StructureTools.caAtomName);\n\t\t\tpos++;\n\t\t}\n\t\treturn ca2m;\n\n\t}\n\n\n\t/**\n\t * Aligns ca1 and ca2 using a heuristic to check for CPs.\n\t * <p>\n\t * Aligns ca1 against a doubled ca2, then cleans up the alignment.\n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @return the alignment, possibly containing a CP.\n\t * @throws StructureException \n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param) throws StructureException{\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tAtom[] ca2m = prepareAtomsForAlign(ca2);\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Duplicating ca2 took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\t// Do alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2m,params);\n\t\t\n\t\t// since the process of creating ca2m strips the name info away, set it explicitely\n\t\ttry {\n\t\t\tafpChain.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t} catch( Exception e) {}\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Running %dx2*%d alignment took %s ms\\n\",ca1.length,ca2.length,System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\t\tafpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Finding CP point took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\treturn afpChain;\n\t}\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2m\n\t * @param calculator\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator ) throws StructureException{\n\t\t// remove bottom half of the matrix\n\t\tMatrix doubledMatrix = afpChain.getDistanceMatrix();\n\t\tassert(doubledMatrix.getRowDimension() == ca1.length);\n\t\tassert(doubledMatrix.getColumnDimension() == ca2m.length);\n\n\t\tMatrix singleMatrix = doubledMatrix.getMatrix(0, ca1.length-1, 0, (ca2m.length/2)-1);\n\t\tassert(singleMatrix.getRowDimension() == ca1.length);\n\t\tassert(singleMatrix.getColumnDimension() == (ca2m.length/2));\n\n\t\tafpChain.setDistanceMatrix(singleMatrix);\n\n\t\t// Check for circular permutations\n\t\tafpChain = filterDuplicateAFPs(afpChain,calculator,ca1,ca2m);\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Takes as input an AFPChain where ca2 has been artificially duplicated.\n\t * This raises the possibility that some residues of ca2 will appear in \n\t * multiple AFPs. This method filters out duplicates and makes sure that\n\t * all AFPs are numbered relative to the original ca2.\n\t * \n\t * The current version chooses a CP site such that the length of the\n\t * alignment is maximized.\n\t * \n\t * @param afpChain The alignment between ca1 and ca2-ca2. Blindly assumes \n\t *  that ca2 has been duplicated.\n\t * @return A new AFPChain consisting of ca1 to ca2, with each residue in\n\t *  at most 1 AFP.\n\t * @throws StructureException \n\t */\n\tprivate static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc, Atom[] ca1, Atom[] ca2duplicated) throws StructureException {\n\t\tAFPChain newAFPChain = new AFPChain(afpChain);\n\t\t//TODO redundant properties, set in the constructor\n\t\tnewAFPChain.setAlgorithmName(afpChain.getAlgorithmName());\n\t\tnewAFPChain.setVersion(afpChain.getVersion());\n\t\tnewAFPChain.setName1(afpChain.getName1());\n\t\tnewAFPChain.setName2(afpChain.getName2());\n\t\tnewAFPChain.setTMScore(afpChain.getTMScore());\n\t\t\n\t\tint ca2len = afpChain.getCa2Length()/2;\n\t\tnewAFPChain.setCa1Length(afpChain.getCa1Length());\n\t\tnewAFPChain.setCa2Length(ca2len);\n\t\t\n\t\t// Fix optimal alignment\t\t\n\t\tint[][][] align = afpChain.getOptAln();\n\t\tint alignLen = afpChain.getOptLength();\n\t\tassert(align.length == 1); // Assume that CE returns just one block\n\n\t\t// Determine the region where ca2 and ca2' overlap\n\t\tint nStart = align[0][1][0]; //alignment N-terminal\n\t\tint cEnd = align[0][1][alignLen-1]; // alignment C-terminal \n\t\t// overlap is between nStart and cEnd\n\n\t\tint firstRes = nStart; // start res number after trimming\n\t\tint lastRes = nStart+ca2len;  // last res number after trimming\n\t\tif(nStart >= ca2len || cEnd < ca2len) { // no circular permutation\n\t\t\tfirstRes=nStart;\n\t\t\tlastRes=cEnd;\n\t\t} else {\n\t\t\t// Rule: maximize the length of the alignment\n\n\t\t\tint overlapLength = cEnd+1 - nStart - ca2len;\n\t\t\tif(overlapLength <= 0) {\n\t\t\t\t// no overlap!\n\t\t\t\tfirstRes=nStart;\n\t\t\t\tlastRes=cEnd;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// overlap!\n\n\t\t\t\t// # res at or to the left of i within the overlap\n\t\t\t\tint[] nTermResCount = new int[overlapLength]; // increases monotonically\n\t\t\t\tnTermResCount[0] = 1;\n\n\t\t\t\tint alignPos = 1; // index of the next aligned pair\n\n\t\t\t\tfor(int i=1;i<overlapLength;i++) {\n\t\t\t\t\tif(align[0][1][alignPos] == nStart + i ) { // matches the aligned pair\n\t\t\t\t\t\t// the n-term contains the ith overlapping residue\n\t\t\t\t\t\tnTermResCount[i] = nTermResCount[i-1]+1;\n\t\t\t\t\t\talignPos++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnTermResCount[i] = nTermResCount[i-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Determine the position with the largest sum of lengths\n\t\t\t\tint cTermResCount = 0;\n\t\t\t\talignPos = alignLen - 1;\n\t\t\t\tint minResCount = overlapLength+1;\n\t\t\t\tfor(int i=0;i<overlapLength;i++) {\n\n\t\t\t\t\tif(nTermResCount[overlapLength-1-i] + cTermResCount <= minResCount ) {\n\t\t\t\t\t\tminResCount=nTermResCount[overlapLength-1-i] + cTermResCount;\n\t\t\t\t\t\tfirstRes = nStart+overlapLength - i;\n\t\t\t\t\t\tlastRes = cEnd - i;\n\t\t\t\t\t\tassert(lastRes == firstRes+ca2len-1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(align[0][1][alignPos] == cEnd - i) {\n\t\t\t\t\t\tcTermResCount++;\n\t\t\t\t\t\talignPos--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Adjust alignment length for trimming\n\t\t\t\talignLen -= minResCount;\n\n\t\t\t\tif(debug) {\n\t\t\t\t\tSystem.out.format(\"Found a CP at residue %d. Trimming %d residues (%d-%d,%d-%d).\\n\",\n\t\t\t\t\t\t\tfirstRes,minResCount,nStart,firstRes-1,firstRes+ca2len, cEnd);\n\t\t\t\t}\n\t\t\t\t//TODO Now have CP site, and could do a nxm alignment for further optimization.\n\t\t\t\t// For now, does not appear to be worth the 50% increase in time\n\t\t\t\t\n\t\t\t\t//TODO Bug: scores need to be recalculated\n\t\t\t}\n\t\t}\n\n\n\n\t\t// Fix numbering:\n\t\t// First, split up the atoms into left and right blocks\n\t\tList< ResiduePair > left = new ArrayList<ResiduePair>(); // residues from left of duplication\n\t\tList< ResiduePair > right = new ArrayList<ResiduePair>(); // residues from right of duplication\n\n\t\tfor(int i=0;i<afpChain.getOptLength();i++) {\n\t\t\tif( align[0][1][i] >= firstRes && align[0][1][i] <= lastRes ) { // not trimmed\n\t\t\t\tif(align[0][1][i] < ca2len) { // in first half of ca2\n\t\t\t\t\tleft.add(new ResiduePair(align[0][0][i],align[0][1][i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tright.add(new ResiduePair(align[0][0][i],align[0][1][i]-ca2len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(left.size()+right.size() == alignLen);\n\n\n\t\t// Now we don't care about left/right, so just call them \"blocks\"\n\t\tList<List<ResiduePair>> blocks = new ArrayList<List<ResiduePair>>(2);\n\t\tif( !left.isEmpty() ) {\n\t\t\tblocks.add(left);\n\t\t}\n\t\tif( !right.isEmpty()) {\n\t\t\tblocks.add(right);\n\t\t}\n\t\tleft=null; right = null;\n\n\t\t// Put the blocks back together into arrays for the AFPChain\n\t\tint[][][] newAlign = new int[blocks.size()][][];\n\t\tint[] blockLengths = new int[blocks.size()];\n\t\tfor(int blockNum = 0; blockNum < blocks.size(); blockNum++) {\n\t\t\t//Alignment\n\t\t\tList<ResiduePair> block = blocks.get(blockNum);\n\t\t\tnewAlign[blockNum] = new int[2][block.size()];\n\t\t\tfor(int i=0;i<block.size();i++) {\n\t\t\t\tResiduePair pair = block.get(i);\n\t\t\t\tnewAlign[blockNum][0][i] = pair.a;\n\t\t\t\tnewAlign[blockNum][1][i] = pair.b;\n\t\t\t}\n\n\t\t\t// Block lengths\n\t\t\tblockLengths[blockNum] = block.size();\n\t\t}\n\t\t// Set Alignment\n\t\tnewAFPChain.setOptAln(newAlign);\n\t\tnewAFPChain.setOptLen(blockLengths );\n\t\tnewAFPChain.setOptLength(alignLen);\n\t\tnewAFPChain.setBlockNum(blocks.size());\n\t\tnewAFPChain.setBlockResSize(blockLengths.clone());\n\t\tnewAFPChain.setSequentialAlignment(blocks.size() == 1);\n\n\t\t// TODO make the AFPSet consistent\n\t\t// TODO lots more block properties & old AFP properties \n\n\t\t// Recalculate superposition\n\t\tAtom[] atoms1 = new Atom[alignLen];\n\t\tAtom[] atoms2 = new Atom[alignLen];\n\n\t\tint pos=0;\n\t\tfor(List<ResiduePair> block:blocks ) {\n\t\t\tfor(ResiduePair pair:block) {\n\t\t\t\tatoms1[pos] = ca1[pair.a];\n\t\t\t\tatoms2[pos] = ca2duplicated[pair.b];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tassert(pos == alignLen);\n\n\t\t// Sets the rotation matrix in ceCalc to the proper value\n\t\tdouble rmsd = ceCalc.calc_rmsd(atoms1, atoms2, alignLen, true, false);\n\n\t\tdouble[] blockRMSDs = new double[blocks.size()];\n\t\tMatrix[] blockRotationMatrices = new Matrix[blocks.size()];\n\t\tAtom[] blockShifts = new Atom[blocks.size()];\n\n\t\tblockRMSDs[0] = rmsd;\n\t\tblockRotationMatrices[0] = ceCalc.getRotationMatrix();\n\t\tblockShifts[0] = ceCalc.getShift();\n\t\tfor(int i=1;i<blocks.size();i++) {\n\t\t\tblockRMSDs[i] = rmsd;\n\n\t\t\t// Don't move blocks relative to the first block\n\t\t\t/*Matrix identity = new Matrix(3,3);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tidentity.set(j, j, 1.);\n\t\t\tblockRotationMatrices[i] = identity;\n\n\t\t\tAtom zero = new AtomImpl();\n\t\t\tzero.setX(0.); zero.setY(0.); zero.setZ(0.);\n\t\t\tblockShifts[i] = zero;\n\t\t\t */\n\t\t\tblockRotationMatrices[i] = (Matrix) blockRotationMatrices[0].clone();\n\t\t\tblockShifts[i] = (Atom) blockShifts[0].clone();\n\t\t}\n\t\tnewAFPChain.setOptRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRotationMatrix(blockRotationMatrices);\n\t\tnewAFPChain.setBlockShiftVector(blockShifts);\n\n\t\t// Clean up remaining properties using the FatCat helper method\n\t\tAtom[] ca2 = new Atom[ca2len];\n\t\tfor(int i=0;i<ca2len;i++) {\n\t\t\tca2[i]=ca2duplicated[i];\n\t\t}\n\t\tAFPAlignmentDisplay.getAlign(newAFPChain, ca1, ca2duplicated);\n\t\t//\t\treturn afpChain;\n\n\t\treturn newAFPChain;\n\t}\n\n\n\t/**\n\t * A light class to store an alignment between two residues.\n\t * @author Spencer Bliven\n\t * @see #filterDuplicateAFPs()\n\t */\n\tprivate static class ResiduePair {\n\t\tpublic int a;\n\t\tpublic int b;\n\t\tpublic ResiduePair(int a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t}\n\t\n\t// try showing a GUI\n\t// requires additional dependencies biojava3-structure-gui and JmolApplet\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPAlignmentDisplay;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class CeCPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\tpublic static final String algorithmName = \"jCE Circular Permutation\";\n\n\tpublic static final String version = \"1.0\";\n\t\n\n\tpublic CeCPMain(){\n\t\tsuper();\n\t\tthis.params.setMaxGapSize(0);\n\t}\n\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn CeCPMain.algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn CeCPMain.version;\n\t}\n\n\tpublic static void main(String[] args){\n\t\ttry {\n\t\t\tString name1, name2;\n\n\t\t\t//Concanavalin\n\t\t\tname1 = \"2pel.A\";\n\t\t\tname2 = \"3cna\";\n\n\t\t\t//small case\n\t\t\tname1 = \"d1qdmA1\";\n\t\t\t//name1 = \"1QDM.A\";\n\t\t\tname2 = \"d1nklA_\";\n\t\t\t\n\t\t\tCeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\t\t\tCeParameters params = (CeParameters) ce.getParameters();\n\t\t\tce.setParameters(params);\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\n\t\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.format(\"Aligning %s to %s\\n\",\n\t\t\t\t\tca1[0].getGroup().getChain().getParent().getName(),\n\t\t\t\t\tca2[0].getGroup().getChain().getParent().getName() );\n\t\t\t}\n\t\t\tAFPChain afpChain = ce.align(ca1, ca2);\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.format(\"Finished aligning %s to %s\\n\", afpChain.getName1(),afpChain.getName2());\n\t\t\t\tSystem.out.format(\"Heuristic Score: %.2f\\n\", afpChain.getAlignScore());\n\t\t\t}\n\t\t\t\n\t\t\tint cp = afpChain.getOptAln()[0][1][0];\n\t\t\tSystem.out.println(\"CP at \"+cp);\n\t\t\t\n\t\t\tdisplayAlignment(afpChain,ca1,ca2);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/** Circular permutation specific code to be run before a standard CE alignment\n\t * \n\t * @param ca2 original C-alpha atom array\n\t * @return new Atom array (a duplicated ca2)\n\t * @throws StructureException\n\t */\n\tpublic static Atom[] prepareAtomsForAlign(Atom[] ca2) throws StructureException{\n\t\t// Duplicate ca2\n\t\tAtom[] ca2m = new Atom[ca2.length*2];\n\n\t\tint pos = 0;\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone(); // works because each group has only a CA atom\n\t\t\tca2m[pos] = g.getAtom(StructureTools.caAtomName);\n\t\t\tpos++;\n\t\t}\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone();\n\t\t\tca2m[pos] = g.getAtom(StructureTools.caAtomName);\n\t\t\tpos++;\n\t\t}\n\t\treturn ca2m;\n\n\t}\n\n\n\t/**\n\t * Aligns ca1 and ca2 using a heuristic to check for CPs.\n\t * <p>\n\t * Aligns ca1 against a doubled ca2, then cleans up the alignment.\n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @return the alignment, possibly containing a CP.\n\t * @throws StructureException \n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param) throws StructureException{\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tAtom[] ca2m = prepareAtomsForAlign(ca2);\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Duplicating ca2 took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\t// Do alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2m,params);\n\t\t\n\t\t// since the process of creating ca2m strips the name info away, set it explicitely\n\t\ttry {\n\t\t\tafpChain.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t} catch( Exception e) {}\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Running %dx2*%d alignment took %s ms\\n\",ca1.length,ca2.length,System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\t\tafpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Finding CP point took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\treturn afpChain;\n\t}\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2m\n\t * @param calculator\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator ) throws StructureException{\n\t\t// remove bottom half of the matrix\n\t\tMatrix doubledMatrix = afpChain.getDistanceMatrix();\n\t\tassert(doubledMatrix.getRowDimension() == ca1.length);\n\t\tassert(doubledMatrix.getColumnDimension() == ca2m.length);\n\n\t\tMatrix singleMatrix = doubledMatrix.getMatrix(0, ca1.length-1, 0, (ca2m.length/2)-1);\n\t\tassert(singleMatrix.getRowDimension() == ca1.length);\n\t\tassert(singleMatrix.getColumnDimension() == (ca2m.length/2));\n\n\t\tafpChain.setDistanceMatrix(singleMatrix);\n\n\t\t// Check for circular permutations\n\t\tafpChain = filterDuplicateAFPs(afpChain,calculator,ca1,ca2m);\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Takes as input an AFPChain where ca2 has been artificially duplicated.\n\t * This raises the possibility that some residues of ca2 will appear in \n\t * multiple AFPs. This method filters out duplicates and makes sure that\n\t * all AFPs are numbered relative to the original ca2.\n\t * \n\t * The current version chooses a CP site such that the length of the\n\t * alignment is maximized.\n\t * \n\t * @param afpChain The alignment between ca1 and ca2-ca2. Blindly assumes \n\t *  that ca2 has been duplicated.\n\t * @return A new AFPChain consisting of ca1 to ca2, with each residue in\n\t *  at most 1 AFP.\n\t * @throws StructureException \n\t */\n\tprivate static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc, Atom[] ca1, Atom[] ca2duplicated) throws StructureException {\n\t\tAFPChain newAFPChain = new AFPChain(afpChain);\n\t\t//TODO redundant properties, set in the constructor\n\t\tnewAFPChain.setAlgorithmName(afpChain.getAlgorithmName());\n\t\tnewAFPChain.setVersion(afpChain.getVersion());\n\t\tnewAFPChain.setName1(afpChain.getName1());\n\t\tnewAFPChain.setName2(afpChain.getName2());\n\t\tnewAFPChain.setTMScore(afpChain.getTMScore());\n\t\t\n\t\tint ca2len = afpChain.getCa2Length()/2;\n\t\tnewAFPChain.setCa1Length(afpChain.getCa1Length());\n\t\tnewAFPChain.setCa2Length(ca2len);\n\t\t\n\t\t// Fix optimal alignment\t\t\n\t\tint[][][] align = afpChain.getOptAln();\n\t\tint alignLen = afpChain.getOptLength();\n\t\tassert(align.length == 1); // Assume that CE returns just one block\n\n\t\t// Determine the region where ca2 and ca2' overlap\n\t\tint nStart = align[0][1][0]; //alignment N-terminal\n\t\tint cEnd = align[0][1][alignLen-1]; // alignment C-terminal \n\t\t// overlap is between nStart and cEnd\n\n\t\tint firstRes = nStart; // start res number after trimming\n\t\tint lastRes = nStart+ca2len;  // last res number after trimming\n\t\tif(nStart >= ca2len || cEnd < ca2len) { // no circular permutation\n\t\t\tfirstRes=nStart;\n\t\t\tlastRes=cEnd;\n\t\t} else {\n\t\t\t// Rule: maximize the length of the alignment\n\n\t\t\tint overlapLength = cEnd+1 - nStart - ca2len;\n\t\t\tif(overlapLength <= 0) {\n\t\t\t\t// no overlap!\n\t\t\t\tfirstRes=nStart;\n\t\t\t\tlastRes=cEnd;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// overlap!\n\n\t\t\t\t// # res at or to the left of i within the overlap\n\t\t\t\tint[] nTermResCount = new int[overlapLength]; // increases monotonically\n\t\t\t\tnTermResCount[0] = 1;\n\n\t\t\t\tint alignPos = 1; // index of the next aligned pair\n\n\t\t\t\tfor(int i=1;i<overlapLength;i++) {\n\t\t\t\t\tif(align[0][1][alignPos] == nStart + i ) { // matches the aligned pair\n\t\t\t\t\t\t// the n-term contains the ith overlapping residue\n\t\t\t\t\t\tnTermResCount[i] = nTermResCount[i-1]+1;\n\t\t\t\t\t\talignPos++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnTermResCount[i] = nTermResCount[i-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Determine the position with the largest sum of lengths\n\t\t\t\tint cTermResCount = 0;\n\t\t\t\talignPos = alignLen - 1;\n\t\t\t\tint minResCount = overlapLength+1;\n\t\t\t\tfor(int i=0;i<overlapLength;i++) {\n\n\t\t\t\t\tif(nTermResCount[overlapLength-1-i] + cTermResCount <= minResCount ) {\n\t\t\t\t\t\tminResCount=nTermResCount[overlapLength-1-i] + cTermResCount;\n\t\t\t\t\t\tfirstRes = nStart+overlapLength - i;\n\t\t\t\t\t\tlastRes = cEnd - i;\n\t\t\t\t\t\tassert(lastRes == firstRes+ca2len-1);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(align[0][1][alignPos] == cEnd - i) {\n\t\t\t\t\t\tcTermResCount++;\n\t\t\t\t\t\talignPos--;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Adjust alignment length for trimming\n\t\t\t\talignLen -= minResCount;\n\n\t\t\t\tif(debug) {\n\t\t\t\t\tSystem.out.format(\"Found a CP at residue %d. Trimming %d residues (%d-%d,%d-%d).\\n\",\n\t\t\t\t\t\t\tfirstRes,minResCount,nStart,firstRes-1,firstRes+ca2len, cEnd);\n\t\t\t\t}\n\t\t\t\t//TODO Now have CP site, and could do a nxm alignment for further optimization.\n\t\t\t\t// For now, does not appear to be worth the 50% increase in time\n\t\t\t\t\n\t\t\t\t//TODO Bug: scores need to be recalculated\n\t\t\t}\n\t\t}\n\n\n\n\t\t// Fix numbering:\n\t\t// First, split up the atoms into left and right blocks\n\t\tList< ResiduePair > left = new ArrayList<ResiduePair>(); // residues from left of duplication\n\t\tList< ResiduePair > right = new ArrayList<ResiduePair>(); // residues from right of duplication\n\n\t\tfor(int i=0;i<afpChain.getOptLength();i++) {\n\t\t\tif( align[0][1][i] >= firstRes && align[0][1][i] <= lastRes ) { // not trimmed\n\t\t\t\tif(align[0][1][i] < ca2len) { // in first half of ca2\n\t\t\t\t\tleft.add(new ResiduePair(align[0][0][i],align[0][1][i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tright.add(new ResiduePair(align[0][0][i],align[0][1][i]-ca2len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(left.size()+right.size() == alignLen);\n\n\n\t\t// Now we don't care about left/right, so just call them \"blocks\"\n\t\tList<List<ResiduePair>> blocks = new ArrayList<List<ResiduePair>>(2);\n\t\tif( !left.isEmpty() ) {\n\t\t\tblocks.add(left);\n\t\t}\n\t\tif( !right.isEmpty()) {\n\t\t\tblocks.add(right);\n\t\t}\n\t\tleft=null; right = null;\n\n\t\t// Put the blocks back together into arrays for the AFPChain\n\t\tint[][][] newAlign = new int[blocks.size()][][];\n\t\tint[] blockLengths = new int[blocks.size()];\n\t\tfor(int blockNum = 0; blockNum < blocks.size(); blockNum++) {\n\t\t\t//Alignment\n\t\t\tList<ResiduePair> block = blocks.get(blockNum);\n\t\t\tnewAlign[blockNum] = new int[2][block.size()];\n\t\t\tfor(int i=0;i<block.size();i++) {\n\t\t\t\tResiduePair pair = block.get(i);\n\t\t\t\tnewAlign[blockNum][0][i] = pair.a;\n\t\t\t\tnewAlign[blockNum][1][i] = pair.b;\n\t\t\t}\n\n\t\t\t// Block lengths\n\t\t\tblockLengths[blockNum] = block.size();\n\t\t}\n\t\t// Set Alignment\n\t\tnewAFPChain.setOptAln(newAlign);\n\t\tnewAFPChain.setOptLen(blockLengths );\n\t\tnewAFPChain.setOptLength(alignLen);\n\t\tnewAFPChain.setBlockNum(blocks.size());\n\t\tnewAFPChain.setBlockResSize(blockLengths.clone());\n\t\tnewAFPChain.setSequentialAlignment(blocks.size() == 1);\n\n\t\t// TODO make the AFPSet consistent\n\t\t// TODO lots more block properties & old AFP properties \n\n\t\t// Recalculate superposition\n\t\tAtom[] atoms1 = new Atom[alignLen];\n\t\tAtom[] atoms2 = new Atom[alignLen];\n\n\t\tint pos=0;\n\t\tfor(List<ResiduePair> block:blocks ) {\n\t\t\tfor(ResiduePair pair:block) {\n\t\t\t\tatoms1[pos] = ca1[pair.a];\n\t\t\t\tatoms2[pos] = ca2duplicated[pair.b];\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tassert(pos == alignLen);\n\n\t\t// Sets the rotation matrix in ceCalc to the proper value\n\t\tdouble rmsd = ceCalc.calc_rmsd(atoms1, atoms2, alignLen, true, false);\n\n\t\tdouble[] blockRMSDs = new double[blocks.size()];\n\t\tMatrix[] blockRotationMatrices = new Matrix[blocks.size()];\n\t\tAtom[] blockShifts = new Atom[blocks.size()];\n\n\t\tblockRMSDs[0] = rmsd;\n\t\tblockRotationMatrices[0] = ceCalc.getRotationMatrix();\n\t\tblockShifts[0] = ceCalc.getShift();\n\t\tfor(int i=1;i<blocks.size();i++) {\n\t\t\tblockRMSDs[i] = rmsd;\n\n\t\t\t// Don't move blocks relative to the first block\n\t\t\t/*Matrix identity = new Matrix(3,3);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t\tidentity.set(j, j, 1.);\n\t\t\tblockRotationMatrices[i] = identity;\n\n\t\t\tAtom zero = new AtomImpl();\n\t\t\tzero.setX(0.); zero.setY(0.); zero.setZ(0.);\n\t\t\tblockShifts[i] = zero;\n\t\t\t */\n\t\t\tblockRotationMatrices[i] = (Matrix) blockRotationMatrices[0].clone();\n\t\t\tblockShifts[i] = (Atom) blockShifts[0].clone();\n\t\t}\n\t\tnewAFPChain.setOptRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRotationMatrix(blockRotationMatrices);\n\t\tnewAFPChain.setBlockShiftVector(blockShifts);\n\n\t\t// Clean up remaining properties using the FatCat helper method\n\t\tAtom[] ca2 = new Atom[ca2len];\n\t\tfor(int i=0;i<ca2len;i++) {\n\t\t\tca2[i]=ca2duplicated[i];\n\t\t}\n\t\tAFPAlignmentDisplay.getAlign(newAFPChain, ca1, ca2duplicated);\n\t\t//\t\treturn afpChain;\n\n\t\treturn newAFPChain;\n\t}\n\n\n\t/**\n\t * A light class to store an alignment between two residues.\n\t * @author Spencer Bliven\n\t * @see #filterDuplicateAFPs()\n\t */\n\tprivate static class ResiduePair {\n\t\tpublic int a;\n\t\tpublic int b;\n\t\tpublic ResiduePair(int a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t}\n\t\n\t// try showing a GUI\n\t// requires additional dependencies biojava3-structure-gui and JmolApplet\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","originTest":"/**\n * \n */\npackage org.biojava.bio.structure.align.ce;\n\nimport static org.junit.Assert.*;\n\nimport java.lang.reflect.Method;\n\nimport org.biojava.bio.structure.AminoAcidImpl;\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.AtomImpl;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.ChainImpl;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.align.ce.CECalculator;\nimport org.biojava.bio.structure.align.ce.CeCPMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.junit.*;\n\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class CeCPMainTest {\n\n\t@Test\n\tpublic void testFilterDuplicateAFPs() throws Exception {\n\t\tMethod filterDuplicateAFPs = CeCPMain.class.getDeclaredMethod(\n\t\t\t\t\"filterDuplicateAFPs\", AFPChain.class, CECalculator.class, Atom[].class,Atom[].class);\n\t\tfilterDuplicateAFPs.setAccessible(true);\n\n\n\t\tint[][][] dupAlign = new int[1][2][];\n\n\t\tint ca2len = 12;\n\t\tdupAlign[0][0] = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13 };\n\t\tdupAlign[0][1] = new int[] { 3, 5, 6, 7, 8, 9,10,11, 0+ca2len, 1+ca2len, 2+ca2len, 3+ca2len, 4+ca2len, 7+ca2len };\n\n\t\tChain chain1 = new ChainImpl();\n\t\t//Some dummy Atoms. Just check they're unique\n\t\tAtom[] ca1 = new Atom[14];\n\t\tfor(int i=0;i<ca1.length;i++) {\n\t\t\tca1[i] = new AtomImpl();\n\t\t\tca1[i].setFullName(\" CA \");\n\t\t\tca1[i].setName(\"CA\");\n\t\t\tca1[i].setCoords(new double[] { i, 0, 0 });\n\t\t\tGroup aa = new AminoAcidImpl();\n\t\t\taa.setPDBName(\"GLY\");\n\t\t\taa.setResidueNumber( ResidueNumber.fromString(i+\"\"));\n\t\t\taa.addAtom(ca1[i]);\n\t\t\tchain1.addGroup(aa);\n\t\t}\n\t\tAtom[] ca2 = new Atom[ca2len*2];\n\t\tChain chain2 = new ChainImpl();\n\t\tfor(int i=0;i<ca2.length;i++) {\n\t\t\tca2[i] = new AtomImpl();\n\t\t\tca2[i].setFullName(\" CA \");\n\t\t\tca2[i].setName(\"CA\");\n\t\t\tca2[i].setCoords(new double[] { i%ca2len, 1, 1 });\n\t\t\tGroup aa = new AminoAcidImpl();\n\t\t\taa.addAtom(ca2[i]);\n\t\t\taa.setPDBName(\"GLY\");\n\t\t\taa.setResidueNumber( ResidueNumber.fromString(i+\"\"));\n\t\t\tchain2.addGroup(aa);\n\t\t}\n\n\t\tAFPChain afp = new AFPChain();\n\t\tafp.setOptAln(dupAlign);\n\t\tafp.setOptLength(dupAlign[0][1].length);\n\t\tafp.setCa2Length(ca2.length);\n\t\tafp.setBlockNum(1);\n\t\tafp.setOptLen(new int[] {dupAlign[0][1].length});\n\n\t\tAFPChain newAFP = (AFPChain) filterDuplicateAFPs.invoke(null, afp, new CECalculator(null), ca1, ca2);\n\n\t\tint[][][] align = newAFP.getOptAln();\n\t\tint[] blkLen = newAFP.getOptLen();\n\t\t// optimal alignment should be\n\t\t//  1  2  3  4  5  6  7 | 8  9 10 11 12\n\t\t//  5  6  7  8  9 10 11 | 0  1  2  3  4\n\n\t\tassertEquals(2,align.length);\n\t\tassertEquals(2,align[0].length);\n\t\tassertEquals(7,align[0][0].length);\n\t\tassertEquals(7,align[0][1].length);\n\t\tassertEquals(2,align[1].length);\n\t\tassertEquals(5,align[1][0].length);\n\t\tassertEquals(5,align[1][1].length);\n\n\t\tassertEquals(2,blkLen.length);\n\t\tassertEquals(7,blkLen[0]);\n\t\tassertEquals(5,blkLen[1]);\n\n\n\t\tfor(int i=0;i<align[0][0].length; i++) {\n\t\t\tassertEquals(align[0][0][i],i+1);\n\t\t\tassertEquals(align[0][1][i],(i+5)%12);\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Referred to some static variables by full name. This prevents confusion when subclasses define a variable with the same name.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9227 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}