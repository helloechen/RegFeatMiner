{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/SingleLinkageClusterer.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/SingleLinkageClustererTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\n\n\n/**\n * An implementation of a single linkage clusterer\n *\n * See http://en.wikipedia.org/wiki/Single-linkage_clustering\n *\n * @author Jose Duarte\n */\npublic class SingleLinkageClusterer {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SingleLinkageClusterer.class);\n\n\tprivate class LinkedPair {\n\n\t\tprivate int first;\n\t\tprivate int second;\n\t\tprivate double closestDistance;\n\n\t\tpublic LinkedPair(int first, int second, double minDistance) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t\tthis.closestDistance = minDistance;\n\t\t}\n\n\t\tpublic int getFirst() {\n\t\t\treturn first;\n\t\t}\n\n\t\tpublic int getSecond() {\n\t\t\treturn second;\n\t\t}\n\n\t\tpublic double getClosestDistance() {\n\t\t\treturn closestDistance;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\n\t\t\tString closestDistStr = null;\n\t\t\tif (closestDistance==Double.MAX_VALUE) {\n\t\t\t\tclosestDistStr = String.format(\"%6s\", \"inf\");\n\t\t\t} else {\n\t\t\t\tclosestDistStr = String.format(Locale.US, \"%6.2f\",closestDistance);\n\t\t\t}\n\n\t\t\treturn \"[\"+first+\",\"+second+\"-\"+closestDistStr+\"]\";\n\t\t}\n\n\t}\n\n\tprivate double[][] matrix;\n\n\tprivate boolean isScoreMatrix;\n\n\tprivate int numItems;\n\n\tprivate LinkedPair[] dendrogram;\n\n\t//private Set<Integer> toSkip;\n\n\tprivate ArrayList<Integer> indicesToCheck;\n\n\n\t/**\n\t * Constructs a new SingleLinkageClusterer\n\t * Subsequently use {@link #getDendrogram()} to get the full tree\n\t * or {@link #getClusters(double)} to get the clusters at a certain cutoff in the tree\n\t * Please note that the matrix will be altered during the clustering procedure. A copy must be\n\t * made before by the user if needing to use the original matrix further.\n\t * @param matrix the distance matrix with distance values in j>i half, all other values will be ignored\n\t * @param isScoreMatrix if false the matrix will be considered a distance matrix: lower values (distances) mean closer objects,\n\t * if true the matrix will be considered a score matrix: larger values (scores) mean closer objects\n\t * @throws IllegalArgumentException if matrix not square\n\t */\n\tpublic SingleLinkageClusterer(double[][] matrix, boolean isScoreMatrix) {\n\t\tthis.matrix = matrix;\n\t\tthis.isScoreMatrix = isScoreMatrix;\n\n\t\tif (matrix.length!=matrix[0].length) {\n\t\t\tthrow new IllegalArgumentException(\"Distance matrix for clustering must be a square matrix\");\n\t\t}\n\n\t\tthis.numItems = matrix.length;\n\n\t}\n\n\t/**\n\t * Get the full dendrogram (size n-1) result of the hierarchical clustering\n\t * @return\n\t */\n\tpublic LinkedPair[] getDendrogram() {\n\t\tif (dendrogram==null) {\n\t\t\tclusterIt();\n\t\t}\n\n\t\treturn dendrogram;\n\t}\n\n\t/**\n\t * Calculate the hierarchical clustering and store it in dendrogram array\n\t * This is the naive implementation (o(n3)) of single linkage clustering as outlined in wikipedia:\n\t * http://en.wikipedia.org/wiki/Single-linkage_clustering\n\t */\n\tprivate void clusterIt() {\n\n\t\tdendrogram = new LinkedPair[numItems-1];\n\n\n\t\tlogger.debug(\"Initial matrix: \\n{}\", matrixToString());\n\n\n\t\tfor (int m=0;m<numItems-1;m++) {\n\n\t\t\tupdateIndicesToCheck(m);\n\t\t\tLinkedPair pair = getClosestPair();\n\t\t\tmerge(pair);\n\t\t\tdendrogram[m] = pair;\n\n\t\t\t//if (debug) {\n\t\t\t//\tSystem.out.println(\"Matrix after iteration \"+m+\" (merged \"+pair.getFirst()+\",\"+pair.getSecond()+\")\");\n\t\t\t//\tprintMatrix();\n\t\t\t//}\n\t\t}\n\n\t}\n\n\t/**\n\t * Merge 2 rows/columns of the matrix by the linkage function (see {@link #link(double, double)}\n\t * @param closestPair\n\t */\n\tprivate void merge(LinkedPair closestPair) {\n\n\n\t\tint first = closestPair.getFirst();\n\t\tint second = closestPair.getSecond();\n\n\t\tfor (int other=0;other<numItems;other++) {\n\t\t\tmatrix[Math.min(first,other)][Math.max(first, other)] = link(getDistance(first, other), getDistance(second, other));\n\t\t}\n\n\t}\n\n\t/**\n\t * The linkage function: minimum of the 2 distances (i.e. single linkage clustering)\n\t * @param d1\n\t * @param d2\n\t * @return\n\t */\n\tprivate double link(double d1, double d2) {\n\t\tif (isScoreMatrix) {\n\t\t\treturn Math.max(d1,d2);\n\t\t} else {\n\t\t\treturn Math.min(d1,d2);\n\t\t}\n\t}\n\n\tprivate double getDistance(int first, int second) {\n\t\treturn matrix[Math.min(first, second)][Math.max(first, second)];\n\t}\n\n\tprivate void updateIndicesToCheck(int m) {\n\n\t\tif (indicesToCheck==null) {\n\t\t\tindicesToCheck = new ArrayList<Integer>(numItems);\n\n\t\t\tfor (int i=0;i<numItems;i++) {\n\t\t\t\tindicesToCheck.add(i);\n\t\t\t}\n\t\t}\n\n\t\tif (m==0) return;\n\n\t\tindicesToCheck.remove(new Integer(dendrogram[m-1].getFirst()));\n\t}\n\n\tprivate LinkedPair getClosestPair() {\n\n\t\tLinkedPair closestPair = null;\n\n\t\tif (isScoreMatrix) {\n\t\t\tdouble max = 0.0;\n\t\t\tfor (int i:indicesToCheck) {\n\n\t\t\t\tfor (int j:indicesToCheck) {\n\t\t\t\t\tif (j<=i) continue;\n\n\t\t\t\t\tif (matrix[i][j]>=max) {\n\t\t\t\t\t\tmax = matrix[i][j];\n\t\t\t\t\t\tclosestPair = new LinkedPair(i,j,max);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i:indicesToCheck) {\n\n\t\t\t\tfor (int j:indicesToCheck) {\n\t\t\t\t\tif (j<=i) continue;\n\n\t\t\t\t\tif (matrix[i][j]<=min) {\n\t\t\t\t\t\tmin = matrix[i][j];\n\t\t\t\t\t\tclosestPair = new LinkedPair(i,j,min);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closestPair;\n\t}\n\n\t/**\n\t * Get the clusters by cutting the dendrogram at given cutoff\n\t * @param cutoff\n\t * @return Map from cluster numbers to indices of the cluster members\n\t */\n\tpublic Map<Integer, Set<Integer>> getClusters(double cutoff) {\n\n\t\tif (dendrogram==null) {\n\t\t\tclusterIt();\n\t\t}\n\n\t\tMap<Integer, Set<Integer>> clusters = new TreeMap<Integer, Set<Integer>>();\n\n\t\tint clusterId = 1;\n\n\t\tfor (int i=0;i<numItems-1;i++) {\n\n\t\t\tif (isWithinCutoff(i, cutoff)) {\n\n\t\t\t\t//int containingClusterId = getContainingCluster(clusters, dendrogram[i]);\n\n\t\t\t\tint firstClusterId = -1;\n\t\t\t\tint secondClusterId = -1;\n\t\t\t\tfor (int cId:clusters.keySet()) {\n\t\t\t\t\tSet<Integer> members = clusters.get(cId);\n\n\t\t\t\t\tif (members.contains(dendrogram[i].getFirst())) {\n\t\t\t\t\t\tfirstClusterId = cId;\n\t\t\t\t\t}\n\t\t\t\t\tif (members.contains(dendrogram[i].getSecond())) {\n\t\t\t\t\t\tsecondClusterId = cId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (firstClusterId==-1 && secondClusterId==-1) {\n\t\t\t\t\t// neither member is in a cluster yet, let's assign a new cluster and put them both in\n\t\t\t\t\tSet<Integer> members = new TreeSet<Integer>();\n\t\t\t\t\tmembers.add(dendrogram[i].getFirst());\n\t\t\t\t\tmembers.add(dendrogram[i].getSecond());\n\t\t\t\t\tclusters.put(clusterId, members);\n\t\t\t\t\tclusterId++;\n\t\t\t\t} else if (firstClusterId!=-1 && secondClusterId==-1) {\n\t\t\t\t\t// first member was in firstClusterId already, we add second\n\t\t\t\t\tclusters.get(firstClusterId).add(dendrogram[i].getSecond());\n\t\t\t\t} else if (secondClusterId!=-1 && firstClusterId==-1) {\n\t\t\t\t\t// second member was in secondClusterId already, we add first\n\t\t\t\t\tclusters.get(secondClusterId).add(dendrogram[i].getFirst());\n\t\t\t\t} else {\n\t\t\t\t\t// both were in different clusters already\n\t\t\t\t\t// we need to join them: necessarily one must be of size 1 and the other of size>=1\n\t\t\t\t\tSet<Integer> firstCluster = clusters.get(firstClusterId);\n\t\t\t\t\tSet<Integer> secondCluster = clusters.get(secondClusterId);\n\t\t\t\t\tif (firstCluster.size()<secondCluster.size()) {\n\t\t\t\t\t\tlogger.debug(\"Joining cluster \"+firstClusterId+\" to cluster \"+secondClusterId);\n\t\t\t\t\t\t// we join first onto second\n\t\t\t\t\t\tfor (int member : firstCluster) {\n\t\t\t\t\t\t\tsecondCluster.add(member);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclusters.remove(firstClusterId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\"Joining cluster \"+secondClusterId+\" to cluster \"+firstClusterId);\n\t\t\t\t\t\t// we join second onto first\n\t\t\t\t\t\tfor (int member : secondCluster) {\n\t\t\t\t\t\t\tfirstCluster.add(member);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclusters.remove(secondClusterId);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\"Within cutoff:     {}\", dendrogram[i]);\n\n\t\t\t} else {\n\n\t\t\t\tlogger.debug(\"Not within cutoff: {}\", dendrogram[i]);\n\n\t\t\t}\n\t\t}\n\n\t\t// reassigning cluster numbers by creating a new map (there can be gaps in the numbering if cluster-joining happened)\n\t\tMap<Integer,Set<Integer>> finalClusters = new TreeMap<Integer, Set<Integer>>();\n\t\tint newClusterId = 1;\n\t\tfor (int oldClusterId:clusters.keySet()) {\n\t\t\tfinalClusters.put(newClusterId, clusters.get(oldClusterId));\n\t\t\tnewClusterId++;\n\t\t}\n\n\t\t// anything not clustered is assigned to a singleton cluster (cluster with one member)\n\t\tfor (int i=0;i<numItems;i++) {\n\t\t\tboolean isAlreadyClustered = false;\n\t\t\tfor (Set<Integer> cluster:finalClusters.values()) {\n\t\t\t\tif (cluster.contains(i)) {\n\t\t\t\t\tisAlreadyClustered = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isAlreadyClustered) {\n\t\t\t\tSet<Integer> members = new TreeSet<Integer>();\n\t\t\t\tmembers.add(i);\n\t\t\t\tfinalClusters.put(newClusterId, members);\n\t\t\t\tnewClusterId++;\n\t\t\t}\n\n\t\t}\n\n\t\tlogger.debug(\"Clusters: \\n{}\", clustersToString(finalClusters));\n\n\t\treturn finalClusters;\n\t}\n\n\tprivate boolean isWithinCutoff(int i, double cutoff) {\n\t\tif (isScoreMatrix) {\n\t\t\tif (dendrogram[i].getClosestDistance()>cutoff) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dendrogram[i].getClosestDistance()<cutoff) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String clustersToString(Map<Integer,Set<Integer>> finalClusters) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int cId:finalClusters.keySet()) {\n\t\t\tsb.append(cId).append(\": \");\n\t\t\tfor (int member:finalClusters.get(cId)) {\n\t\t\t\tsb.append(member).append(\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String matrixToString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i=0;i<numItems;i++) {\n\t\t\tfor (int j=0;j<numItems;j++) {\n\t\t\t\tif (i==j) {\n\t\t\t\t\tsb.append(String.format(\"%6s \",\"x\"));\n\t\t\t\t}\n\t\t\t\telse if (i<j) {\n\t\t\t\t\tif (matrix[i][j]==Double.MAX_VALUE) sb.append(String.format(\"%6s \",\"inf\"));\n\t\t\t\t\telse sb.append(String.format(Locale.US, \"%6.2f \",matrix[i][j]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (matrix[j][i]==Double.MAX_VALUE) sb.append(String.format(\"%6s \",\"inf\"));\n\t\t\t\t\telse sb.append(String.format(Locale.US, \"%6.2f \",matrix[j][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\n\n\n/**\n * An implementation of a single linkage clusterer\n *\n * See http://en.wikipedia.org/wiki/Single-linkage_clustering\n *\n * @author Jose Duarte\n */\npublic class SingleLinkageClusterer {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SingleLinkageClusterer.class);\n\n\tprivate class LinkedPair {\n\n\t\tprivate int first;\n\t\tprivate int second;\n\t\tprivate double closestDistance;\n\n\t\tpublic LinkedPair(int first, int second, double minDistance) {\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t\tthis.closestDistance = minDistance;\n\t\t}\n\n\t\tpublic int getFirst() {\n\t\t\treturn first;\n\t\t}\n\n\t\tpublic int getSecond() {\n\t\t\treturn second;\n\t\t}\n\n\t\tpublic double getClosestDistance() {\n\t\t\treturn closestDistance;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\n\t\t\tString closestDistStr = null;\n\t\t\tif (closestDistance==Double.MAX_VALUE) {\n\t\t\t\tclosestDistStr = String.format(\"%6s\", \"inf\");\n\t\t\t} else {\n\t\t\t\tclosestDistStr = String.format(Locale.US, \"%6.2f\",closestDistance);\n\t\t\t}\n\n\t\t\treturn \"[\"+first+\",\"+second+\"-\"+closestDistStr+\"]\";\n\t\t}\n\n\t}\n\n\tprivate double[][] matrix;\n\n\tprivate boolean isScoreMatrix;\n\n\tprivate int numItems;\n\n\tprivate LinkedPair[] dendrogram;\n\n\t//private Set<Integer> toSkip;\n\n\tprivate ArrayList<Integer> indicesToCheck;\n\n\n\t/**\n\t * Constructs a new SingleLinkageClusterer\n\t * Subsequently use {@link #getDendrogram()} to get the full tree\n\t * or {@link #getClusters(double)} to get the clusters at a certain cutoff in the tree\n\t * Please note that the matrix will be altered during the clustering procedure. A copy must be\n\t * made before by the user if needing to use the original matrix further.\n\t * @param matrix the distance matrix with distance values in j>i half, all other values will be ignored\n\t * @param isScoreMatrix if false the matrix will be considered a distance matrix: lower values (distances) mean closer objects,\n\t * if true the matrix will be considered a score matrix: larger values (scores) mean closer objects\n\t * @throws IllegalArgumentException if matrix not square\n\t */\n\tpublic SingleLinkageClusterer(double[][] matrix, boolean isScoreMatrix) {\n\t\tthis.matrix = matrix;\n\t\tthis.isScoreMatrix = isScoreMatrix;\n\n\t\tif (matrix.length!=matrix[0].length) {\n\t\t\tthrow new IllegalArgumentException(\"Distance matrix for clustering must be a square matrix\");\n\t\t}\n\n\t\tthis.numItems = matrix.length;\n\n\t}\n\n\t/**\n\t * Get the full dendrogram (size n-1) result of the hierarchical clustering\n\t * @return\n\t */\n\tpublic LinkedPair[] getDendrogram() {\n\t\tif (dendrogram==null) {\n\t\t\tclusterIt();\n\t\t}\n\n\t\treturn dendrogram;\n\t}\n\n\t/**\n\t * Calculate the hierarchical clustering and store it in dendrogram array\n\t * This is the naive implementation (o(n3)) of single linkage clustering as outlined in wikipedia:\n\t * http://en.wikipedia.org/wiki/Single-linkage_clustering\n\t */\n\tprivate void clusterIt() {\n\n\t\tdendrogram = new LinkedPair[numItems-1];\n\n\n\t\tlogger.debug(\"Initial matrix: \\n{}\", matrixToString());\n\n\n\t\tfor (int m=0;m<numItems-1;m++) {\n\n\t\t\tupdateIndicesToCheck(m);\n\t\t\tLinkedPair pair = getClosestPair();\n\t\t\tmerge(pair);\n\t\t\tdendrogram[m] = pair;\n\n\t\t\t//if (debug) {\n\t\t\t//\tSystem.out.println(\"Matrix after iteration \"+m+\" (merged \"+pair.getFirst()+\",\"+pair.getSecond()+\")\");\n\t\t\t//\tprintMatrix();\n\t\t\t//}\n\t\t}\n\n\t}\n\n\t/**\n\t * Merge 2 rows/columns of the matrix by the linkage function (see {@link #link(double, double)}\n\t * @param closestPair\n\t */\n\tprivate void merge(LinkedPair closestPair) {\n\n\n\t\tint first = closestPair.getFirst();\n\t\tint second = closestPair.getSecond();\n\n\t\tfor (int other=0;other<numItems;other++) {\n\t\t\tmatrix[Math.min(first,other)][Math.max(first, other)] = link(getDistance(first, other), getDistance(second, other));\n\t\t}\n\n\t}\n\n\t/**\n\t * The linkage function: minimum of the 2 distances (i.e. single linkage clustering)\n\t * @param d1\n\t * @param d2\n\t * @return\n\t */\n\tprivate double link(double d1, double d2) {\n\t\tif (isScoreMatrix) {\n\t\t\treturn Math.max(d1,d2);\n\t\t} else {\n\t\t\treturn Math.min(d1,d2);\n\t\t}\n\t}\n\n\tprivate double getDistance(int first, int second) {\n\t\treturn matrix[Math.min(first, second)][Math.max(first, second)];\n\t}\n\n\tprivate void updateIndicesToCheck(int m) {\n\n\t\tif (indicesToCheck==null) {\n\t\t\tindicesToCheck = new ArrayList<>(numItems);\n\n\t\t\tfor (int i=0;i<numItems;i++) {\n\t\t\t\tindicesToCheck.add(i);\n\t\t\t}\n\t\t}\n\n\t\tif (m==0) return;\n\n\t\tindicesToCheck.remove(new Integer(dendrogram[m-1].getFirst()));\n\t}\n\n\tprivate LinkedPair getClosestPair() {\n\n\t\tLinkedPair closestPair = null;\n\n\t\tif (isScoreMatrix) {\n\t\t\tdouble max = 0.0;\n\t\t\tfor (int i:indicesToCheck) {\n\n\t\t\t\tfor (int j:indicesToCheck) {\n\t\t\t\t\tif (j<=i) continue;\n\n\t\t\t\t\tif (matrix[i][j]>=max) {\n\t\t\t\t\t\tmax = matrix[i][j];\n\t\t\t\t\t\tclosestPair = new LinkedPair(i,j,max);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdouble min = Double.MAX_VALUE;\n\t\t\tfor (int i:indicesToCheck) {\n\n\t\t\t\tfor (int j:indicesToCheck) {\n\t\t\t\t\tif (j<=i) continue;\n\n\t\t\t\t\tif (matrix[i][j]<=min) {\n\t\t\t\t\t\tmin = matrix[i][j];\n\t\t\t\t\t\tclosestPair = new LinkedPair(i,j,min);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closestPair;\n\t}\n\n\t/**\n\t * Get the clusters by cutting the dendrogram at given cutoff\n\t * @param cutoff\n\t * @return Map from cluster numbers to indices of the cluster members\n\t */\n\tpublic Map<Integer, Set<Integer>> getClusters(double cutoff) {\n\n\t\tif (dendrogram==null) {\n\t\t\tclusterIt();\n\t\t}\n\n\t\tMap<Integer, Set<Integer>> clusters = new TreeMap<>();\n\n\t\tint clusterId = 1;\n\n\t\tfor (int i=0;i<numItems-1;i++) {\n\n\t\t\tif (isWithinCutoff(i, cutoff)) {\n\n\t\t\t\t//int containingClusterId = getContainingCluster(clusters, dendrogram[i]);\n\n\t\t\t\tint firstClusterId = -1;\n\t\t\t\tint secondClusterId = -1;\n\t\t\t\tfor (int cId:clusters.keySet()) {\n\t\t\t\t\tSet<Integer> members = clusters.get(cId);\n\n\t\t\t\t\tif (members.contains(dendrogram[i].getFirst())) {\n\t\t\t\t\t\tfirstClusterId = cId;\n\t\t\t\t\t}\n\t\t\t\t\tif (members.contains(dendrogram[i].getSecond())) {\n\t\t\t\t\t\tsecondClusterId = cId;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tif (firstClusterId==-1 && secondClusterId==-1) {\n\t\t\t\t\t// neither member is in a cluster yet, let's assign a new cluster and put them both in\n\t\t\t\t\tSet<Integer> members = new TreeSet<>();\n\t\t\t\t\tmembers.add(dendrogram[i].getFirst());\n\t\t\t\t\tmembers.add(dendrogram[i].getSecond());\n\t\t\t\t\tclusters.put(clusterId, members);\n\t\t\t\t\tclusterId++;\n\t\t\t\t} else if (firstClusterId!=-1 && secondClusterId==-1) {\n\t\t\t\t\t// first member was in firstClusterId already, we add second\n\t\t\t\t\tclusters.get(firstClusterId).add(dendrogram[i].getSecond());\n\t\t\t\t} else if (secondClusterId!=-1 && firstClusterId==-1) {\n\t\t\t\t\t// second member was in secondClusterId already, we add first\n\t\t\t\t\tclusters.get(secondClusterId).add(dendrogram[i].getFirst());\n\t\t\t\t} else {\n\t\t\t\t\t// both were in different clusters already\n\t\t\t\t\t// we need to join them: necessarily one must be of size 1 and the other of size>=1\n\t\t\t\t\tSet<Integer> firstCluster = clusters.get(firstClusterId);\n\t\t\t\t\tSet<Integer> secondCluster = clusters.get(secondClusterId);\n\t\t\t\t\tif (firstCluster.size()<secondCluster.size()) {\n\t\t\t\t\t\tlogger.debug(\"Joining cluster \"+firstClusterId+\" to cluster \"+secondClusterId);\n\t\t\t\t\t\t// we join first onto second\n\t\t\t\t\t\tfor (int member : firstCluster) {\n\t\t\t\t\t\t\tsecondCluster.add(member);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclusters.remove(firstClusterId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.debug(\"Joining cluster \"+secondClusterId+\" to cluster \"+firstClusterId);\n\t\t\t\t\t\t// we join second onto first\n\t\t\t\t\t\tfor (int member : secondCluster) {\n\t\t\t\t\t\t\tfirstCluster.add(member);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclusters.remove(secondClusterId);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\"Within cutoff:     {}\", dendrogram[i]);\n\n\t\t\t} else {\n\n\t\t\t\tlogger.debug(\"Not within cutoff: {}\", dendrogram[i]);\n\n\t\t\t}\n\t\t}\n\n\t\t// reassigning cluster numbers by creating a new map (there can be gaps in the numbering if cluster-joining happened)\n\t\tMap<Integer,Set<Integer>> finalClusters = new TreeMap<>();\n\t\tint newClusterId = 1;\n\t\tfor (int oldClusterId:clusters.keySet()) {\n\t\t\tfinalClusters.put(newClusterId, clusters.get(oldClusterId));\n\t\t\tnewClusterId++;\n\t\t}\n\n\t\t// anything not clustered is assigned to a singleton cluster (cluster with one member)\n\t\tfor (int i=0;i<numItems;i++) {\n\t\t\tboolean isAlreadyClustered = false;\n\t\t\tfor (Set<Integer> cluster:finalClusters.values()) {\n\t\t\t\tif (cluster.contains(i)) {\n\t\t\t\t\tisAlreadyClustered = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isAlreadyClustered) {\n\t\t\t\tSet<Integer> members = new TreeSet<>();\n\t\t\t\tmembers.add(i);\n\t\t\t\tfinalClusters.put(newClusterId, members);\n\t\t\t\tnewClusterId++;\n\t\t\t}\n\n\t\t}\n\n\t\tlogger.debug(\"Clusters: \\n{}\", clustersToString(finalClusters));\n\n\t\treturn finalClusters;\n\t}\n\n\tprivate boolean isWithinCutoff(int i, double cutoff) {\n\t\tif (isScoreMatrix) {\n\t\t\tif (dendrogram[i].getClosestDistance()>cutoff) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dendrogram[i].getClosestDistance()<cutoff) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate String clustersToString(Map<Integer,Set<Integer>> finalClusters) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int cId:finalClusters.keySet()) {\n\t\t\tsb.append(cId).append(\": \");\n\t\t\tfor (int member:finalClusters.get(cId)) {\n\t\t\t\tsb.append(member).append(\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate String matrixToString() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i=0;i<numItems;i++) {\n\t\t\tfor (int j=0;j<numItems;j++) {\n\t\t\t\tif (i==j) {\n\t\t\t\t\tsb.append(String.format(\"%6s \",\"x\"));\n\t\t\t\t}\n\t\t\t\telse if (i<j) {\n\t\t\t\t\tif (matrix[i][j]==Double.MAX_VALUE) sb.append(String.format(\"%6s \",\"inf\"));\n\t\t\t\t\telse sb.append(String.format(Locale.US, \"%6.2f \",matrix[i][j]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (matrix[j][i]==Double.MAX_VALUE) sb.append(String.format(\"%6s \",\"inf\"));\n\t\t\t\t\telse sb.append(String.format(Locale.US, \"%6.2f \",matrix[j][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\treturn sb.toString();\n\t}\n\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.jupiter.api.Test;\n\nclass SingleLinkageClustererTest {\n    \n    // from wikipedia example\n    // https://en.wikipedia.org/wiki/Single-linkage_clustering\n    // it should produce clusters ((0,1),2,4),3 at distance 8.5, 10.5 and 14\n    double [][] matrix = new double[][]{\n        {0, 17, 21,31,23},\n        {17,0,30,34,21},\n        {21,30,0,28,39},\n        {31,34,28,0,43},\n        {23,21,39,43,0}\n        };\n\n\n    @Test\n    void squareMatrixRequired() {\n        double [][] non_square_matrix = new double[][]{{1,2},{1,2,3},{1}};\n        assertThrows(IllegalArgumentException.class, ()->new SingleLinkageClusterer(non_square_matrix, false));\n    }\n    @Test\n    void clusterWikipediaExampleDistanceMatrix(){\n        SingleLinkageClusterer clusterer = new SingleLinkageClusterer(matrix, false);\n        Map<Integer, Set<Integer>> result = clusterer.getClusters(Double.MAX_VALUE);\n        assertEquals(5, result.get(1).size());\n\n        result = clusterer.getClusters(0);\n        assertEquals(1, result.get(1).size());\n    }\n\n    @Test\n    void clusterWikipediaExampleScoreMatrix(){\n        SingleLinkageClusterer clusterer = new SingleLinkageClusterer(matrix, true);\n        Map<Integer, Set<Integer>> result = clusterer.getClusters(0);\n        assertEquals(5, result.get(1).size());\n        result = clusterer.getClusters(Double.MAX_VALUE);\n        assertEquals(1, result.get(1).size());\n    }\n\n    \n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":true}