{"repository":"biojava","prod_path":"biojava3-sequencing/src/main/java/org/biojava3/sequencing/io/fastq/Fastq.java","test_path":"biojava3-sequencing/src/test/java/org/biojava3/sequencing/io/fastq/FastqTest.java","prod_time":"2012-02-27 06:59:31","test_time":"2012-02-27 06:59:31","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":37,"add_classname_line":1,"add_condition_line":22,"add_field_line":0,"add_import_line":7,"add_packageid_line":0,"add_parameter_line":9,"add_return_line":12,"del_annotation_line":0,"del_call_line":0,"del_classname_line":1,"del_condition_line":4,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":4,"del_return_line":0,"label":"POSITIVE","prod_commitID":"bd565ee3c906c1aa53135e58c797d5162117d1ad","test_commitID":"bd565ee3c906c1aa53135e58c797d5162117d1ad","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\n/**\n * FASTQ formatted sequence.\n *\n * @since 3.0.3\n */\npublic final class Fastq\n{\n    /** Description of this FASTQ formatted sequence. */\n    private final String description;\n\n    /** Sequence for this FASTQ formatted sequence. */\n    private final String sequence;\n\n    /** Quality scores for this FASTQ formatted sequence. */\n    private final String quality;\n\n    /** FASTQ sequence format variant for this FASTQ formatted sequence. */\n    private final FastqVariant variant;\n\n\n    /**\n     * Create a new FASTQ formatted sequence from the specified description, sequence, quality scores,\n     * and sequence format variant.\n     *\n     * @param description description of this FASTQ formatted sequence, must not be null\n     * @param sequence sequence for this FASTQ formatted sequence, must not be null\n     * @param quality quality scores for this FASTQ formatted sequence, must not be null\n     * @param variant FASTQ sequence format variant for this FASTQ formatted sequence, must not be null\n     */\n    Fastq(final String description,\n          final String sequence,\n          final String quality,\n          final FastqVariant variant)\n    {\n        if (description == null)\n        {\n            throw new IllegalArgumentException(\"description must not be null\");\n        }\n        if (sequence == null)\n        {\n            throw new IllegalArgumentException(\"sequence must not be null\");\n        }\n        if (quality == null)\n        {\n            throw new IllegalArgumentException(\"quality must not be null\");\n        }\n        if (variant == null)\n        {\n            throw new IllegalArgumentException(\"variant must not be null\");\n        }\n        this.description = description;\n        this.sequence = sequence;\n        this.quality = quality;\n        this.variant = variant;\n    }\n\n\n    /**\n     * Return the description of this FASTQ formatted sequence.\n     * The description will not be null.\n     *\n     * @return the description of this FASTQ formatted sequence\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Return the sequence for this FASTQ formatted sequence.\n     * The sequence will not be null.\n     *\n     * @return the sequence for this FASTQ formatted sequence\n     */\n    public String getSequence()\n    {\n        return sequence;\n    }\n\n    /**\n     * Return the quality scores for this FASTQ formatted sequence.\n     * The quality scores will not be null.\n     *\n     * @return the quality scores for this FASTQ formatted sequence\n     */\n    public String getQuality()\n    {\n        return quality;\n    }\n\n    /**\n     * Return the FASTQ sequence format variant for this FASTQ formatted sequence.\n     * The FASTQ sequence format variant will not be null.\n     *\n     * @return the FASTQ sequence format variant for this FASTQ formatted sequence\n     */\n    public FastqVariant getVariant()\n    {\n        return variant;\n    }\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.biojava3.core.sequence.DNASequence;\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\nimport org.biojava3.core.sequence.features.FeatureInterface;\nimport org.biojava3.core.sequence.features.QualityFeature;\nimport org.biojava3.core.sequence.template.AbstractSequence;\n\n/**\n * FASTQ formatted sequence.\n *\n * @since 3.0.3\n */\npublic final class Fastq {\n\n    /**\n     * Description of this FASTQ formatted sequence.\n     */\n    private final String description;\n    /**\n     * Sequence for this FASTQ formatted sequence.\n     */\n    private final String sequence;\n    /**\n     * Quality scores for this FASTQ formatted sequence.\n     */\n    private final String quality;\n    /**\n     * FASTQ sequence format variant for this FASTQ formatted sequence.\n     */\n    private final FastqVariant variant;\n\n    /**\n     * Create a new FASTQ formatted sequence from the specified description,\n     * sequence, quality scores, and sequence format variant.\n     *\n     * @param description description of this FASTQ formatted sequence, must not\n     * be null\n     * @param sequence sequence for this FASTQ formatted sequence, must not be\n     * null\n     * @param quality quality scores for this FASTQ formatted sequence, must not\n     * be null\n     * @param variant FASTQ sequence format variant for this FASTQ formatted\n     * sequence, must not be null\n     */\n    Fastq(final String description, final String sequence, final String quality,\n            final FastqVariant variant) {\n        if (description == null) {\n            throw new IllegalArgumentException(\"description must not be null\");\n        }\n        if (sequence == null) {\n            throw new IllegalArgumentException(\"sequence must not be null\");\n        }\n        if (quality == null) {\n            throw new IllegalArgumentException(\"quality must not be null\");\n        }\n        if (variant == null) {\n            throw new IllegalArgumentException(\"variant must not be null\");\n        }\n        this.description = description;\n        this.sequence = sequence;\n        this.quality = quality;\n        this.variant = variant;\n    }\n\n    Fastq(final DNASequence sequence, final FastqVariant variant) {\n        if (sequence == null) {\n            throw new IllegalArgumentException(\"sequence must not be null\");\n        }\n\n        this.description = sequence.getOriginalHeader();\n        this.sequence = sequence.getSequenceAsString();\n        this.variant = variant;\n        \n        List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeaturesByType(\"quality\");\n        \n        FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> qualfeature = null;\n        for (FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature : features) {\n            if (feature instanceof QualityFeature) {\n                //TODO better implementation for multiple quality features per DNASequence\n                qualfeature = feature;\n                break;\n            }\n        }\n        if (qualfeature != null) {\n            this.quality = encodeFeature(qualfeature, variant);\n        } else {\n            throw new IllegalArgumentException(\"sequence must have a quality feature\");\n        }\n    }\n\n    /**\n     * Return the description of this FASTQ formatted sequence. The description\n     * will not be null.\n     *\n     * @return the description of this FASTQ formatted sequence\n     */\n    public String getDescription() {\n        return description;\n    }\n\n    /**\n     * Return the sequence for this FASTQ formatted sequence. The sequence will\n     * not be null.\n     *\n     * @return the sequence for this FASTQ formatted sequence\n     */\n    public String getSequence() {\n        return sequence;\n    }\n\n    /**\n     * Return the quality scores for this FASTQ formatted sequence. The quality\n     * scores will not be null.\n     *\n     * @return the quality scores for this FASTQ formatted sequence\n     */\n    public String getQuality() {\n        return quality;\n    }\n\n    /**\n     * Return the FASTQ sequence format variant for this FASTQ formatted\n     * sequence. The FASTQ sequence format variant will not be null.\n     *\n     * @return the FASTQ sequence format variant for this FASTQ formatted\n     * sequence\n     */\n    public FastqVariant getVariant() {\n        return variant;\n    }\n\n    /**\n     * Return a biojava DNASequence with the quality values added as Feature.\n     * The encoded quality values are automatically transformed into Phred\n     * values.\n     *\n     * @return a biojava DNASequence with the quality values as feature\n     */\n    public DNASequence getDNASequence() {\n        DNASequence seq = new DNASequence(sequence);\n        seq.setOriginalHeader(description);\n        QualityFeature feat = new QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>(\"quality\", \"sequencing\");\n        feat.setQualities(getPhredQualities());\n        seq.addFeature(1, seq.getLength(), feat);\n        return seq;\n    }\n\n    private List<Number> getPhredQualities() {\n        List<Number> qualities = new ArrayList<Number>();\n        if (this.variant.equals(FastqVariant.FASTQ_SANGER)) {\n            // Phred+33,  raw reads typically (0, 40)\n            for (int i = 0; i < quality.length(); i++) {\n                int charval = quality.charAt(i);\n                qualities.add(charval - 33);\n            }\n        } else if (this.variant.equals(FastqVariant.FASTQ_SOLEXA)) {\n            // Solexa+64, raw reads typically (-5, 40)\n            for (int i = 0; i < quality.length(); i++) {\n                int charval = quality.charAt(i);\n                int phredvalue = getPhredFromSolexa(charval - 64);\n                qualities.add(phredvalue);\n            }\n        } else if (this.variant.equals(FastqVariant.FASTQ_ILLUMINA)) {\n            // Phred+64,  raw reads typically (0, 40) or (3,40)\n            for (int i = 0; i < quality.length(); i++) {\n                int charval = quality.charAt(i);\n                qualities.add(charval - 64);\n            }\n\n        } else if (this.variant.equals(FastqVariant.FASTQ_NEW_ILLUMINA)) {\n            // Phred+33,  raw reads typically (0, 41)\n            for (int i = 0; i < quality.length(); i++) {\n                int charval = quality.charAt(i);\n                qualities.add(charval - 33);\n            }\n        } else {\n            throw new IllegalArgumentException(\"unsupported variant\");\n        }\n\n        return qualities;\n    }\n\n    private int getPhredFromError(double error) {\n        return (int) Math.round(-10 * Math.log10(error));\n    }\n\n    private int getSolexaFromError(double error) {\n        return (int) Math.round(-10 * Math.log10(error / (1 - error)));\n    }\n\n    private int getPhredFromSolexa(int solexa) {\n        return (int) Math.round(10 * Math.log10(Math.pow(10, (solexa / 10.0)) + 1));\n    }\n\n    private int getSolexaFromPhred(int phred) {\n        return (int) Math.round(10 * Math.log10(Math.pow(10, (phred / 10.0)) - 1));\n    }\n\n    \n    private String encodeFeature(FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature, FastqVariant variant) {\n        if (feature instanceof QualityFeature) {\n            if (feature.getLocations().getLength() != this.sequence.length()) {\n                //TODO handle quality features with different locations more gracefully\n                throw new IllegalArgumentException(\"DNASequence quality feature must cover the whole sequence\");\n            }\n            QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound> feat = (QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>) feature;\n            StringBuilder sb = new StringBuilder();\n            List<Number> qualities = feat.getQualities();\n            for (Number number : qualities) {\n                sb.append(encodeQuality(number.intValue()));\n            }\n            return sb.toString();\n        }\n        return null;\n    }\n\n    private char encodeQuality(int quality) {\n        if (this.variant.equals(FastqVariant.FASTQ_SANGER)) {\n            char encoding = (char) (quality + 33);\n            return encoding;\n        } else if (this.variant.equals(FastqVariant.FASTQ_SOLEXA)) {\n            int solexa = getSolexaFromPhred(quality);\n            if (solexa < -5) {\n                solexa = -5;\n            }\n            char encoding = (char) (solexa + 64);\n            return encoding;\n        } else if (this.variant.equals(FastqVariant.FASTQ_ILLUMINA)) {\n            char encoding = (char) (quality + 64);\n            return encoding;\n        } else if (this.variant.equals(FastqVariant.FASTQ_NEW_ILLUMINA)) {\n            char encoding = (char) (quality + 33);\n            return encoding;\n        } else {\n            throw new IllegalArgumentException(\"unsupported variant\");\n        }\n    }\n}","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\n\nimport junit.framework.TestCase;\n\n/**\n * Unit test for Fastq.\n */\npublic final class FastqTest\n    extends TestCase\n{\n\n    public void testImmutable()\n    {\n        Class<Fastq> cls = Fastq.class;\n        assertTrue(Modifier.isPublic(cls.getModifiers()));\n        assertTrue(Modifier.isFinal(cls.getModifiers()));\n        Field[] fields = cls.getDeclaredFields();\n        for (Field field : fields)\n        {\n            assertTrue(Modifier.isPrivate(field.getModifiers()));\n            assertTrue(Modifier.isFinal(field.getModifiers()) ||\n                    (Modifier.isVolatile(field.getModifiers()) && Modifier.isTransient(field.getModifiers())));\n        }\n    }\n\n    public void testConstructor()\n    {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertNotNull(fastq);\n\n        try\n        {\n            new Fastq(null, \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null description) expected IllegalArgumentException\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        try\n        {\n            new Fastq(\"description\", null, \"quality_\", FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null sequence) expected IllegalArgumentException\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        try\n        {\n            new Fastq(\"description\", \"sequence\", null, FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null quality) expected IllegalArgumentException\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        try\n        {\n            new Fastq(\"description\", \"sequence\", \"quality_\", null);\n            fail(\"ctr(null variant) expected IllegalArgumentException\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n    }\n\n    public void testDescription()\n    {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getDescription() != null);\n        assertEquals(\"description\", fastq.getDescription());\n    }\n\n    public void testSequence()\n    {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getSequence() != null);\n        assertEquals(\"sequence\", fastq.getSequence());\n    }\n\n    public void testQuality()\n    {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getQuality() != null);\n        assertEquals(\"quality_\", fastq.getQuality());\n    }\n\n    public void testVariant()\n    {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getVariant() != null);\n        assertEquals(FastqVariant.FASTQ_SANGER, fastq.getVariant());\n    }\n\n    public void testEquals()\n    {\n        Fastq fastq0 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        Fastq fastq1 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n\n        assertFalse(fastq0.equals(null));\n        assertFalse(fastq1.equals(null));\n        assertFalse(fastq0.equals(new Object()));\n        assertFalse(fastq1.equals(new Object()));\n        assertTrue(fastq0.equals(fastq0));\n        assertTrue(fastq1.equals(fastq1));\n        assertFalse(fastq0 == fastq1);\n        assertFalse(fastq0.equals(fastq1));\n        assertFalse(fastq1.equals(fastq0));\n    }\n\n    public void testHashCode()\n    {\n        Fastq fastq0 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        Fastq fastq1 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n\n        assertEquals(fastq0.hashCode(), fastq0.hashCode());\n        assertEquals(fastq1.hashCode(), fastq1.hashCode());\n        if (fastq0.equals(fastq1))\n        {\n            assertEquals(fastq0.hashCode(), fastq1.hashCode());\n            assertEquals(fastq1.hashCode(), fastq0.hashCode());\n        }\n        if (fastq1.equals(fastq0))\n        {\n            assertEquals(fastq0.hashCode(), fastq1.hashCode());\n            assertEquals(fastq1.hashCode(), fastq0.hashCode());\n        }\n    }\n}","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.List;\nimport junit.framework.TestCase;\nimport org.biojava3.core.sequence.DNASequence;\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\nimport org.biojava3.core.sequence.features.FeatureInterface;\nimport org.biojava3.core.sequence.features.QualityFeature;\nimport org.biojava3.core.sequence.template.AbstractSequence;\n\n/**\n * Unit test for Fastq.\n */\npublic final class FastqTest extends TestCase {\n\n    public void testImmutable() {\n        Class<Fastq> cls = Fastq.class;\n        assertTrue(Modifier.isPublic(cls.getModifiers()));\n        assertTrue(Modifier.isFinal(cls.getModifiers()));\n        Field[] fields = cls.getDeclaredFields();\n        for (Field field : fields) {\n            assertTrue(Modifier.isPrivate(field.getModifiers()));\n            assertTrue(Modifier.isFinal(field.getModifiers())\n                    || (Modifier.isVolatile(field.getModifiers()) && Modifier.isTransient(field.getModifiers())));\n        }\n    }\n\n    public void testConstructor() {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertNotNull(fastq);\n\n        try {\n            fastq = new Fastq(null, \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null description) expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        try {\n            fastq = new Fastq(\"description\", null, \"quality_\", FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null sequence) expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        try {\n            fastq = new Fastq(\"description\", \"sequence\", null, FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null quality) expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        try {\n            fastq = new Fastq(\"description\", \"sequence\", \"quality_\", null);\n            fail(\"ctr(null variant) expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        try {\n            fastq = new Fastq(null, FastqVariant.FASTQ_SANGER);\n            fail(\"ctr(null DNASequence) expected IllegalArgumentException\");\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        DNASequence validseq = new DNASequence(\"ACGT\");\n        try {\n            fastq = new Fastq(validseq, null);\n        } catch (IllegalArgumentException e) {\n            // expected\n        }\n        QualityFeature qual = new QualityFeature<DNASequence, NucleotideCompound>(\"quality\", \"sequencing\");\n        List<Number> quals = new ArrayList<Number>();\n        quals.add(40);\n        quals.add(30);\n        quals.add(20);\n        quals.add(10);\n        qual.setQualities(quals);\n        validseq.addFeature(1, validseq.getLength(), qual);\n        try {\n            fastq = new Fastq(validseq, FastqVariant.FASTQ_SANGER);\n        } catch (Exception e) {\n            fail(\"unexpected exception\" + e.getMessage());\n        }\n    }\n\n    public void testDescription() {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getDescription() != null);\n        assertEquals(\"description\", fastq.getDescription());\n    }\n\n    public void testSequence() {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getSequence() != null);\n        assertEquals(\"sequence\", fastq.getSequence());\n    }\n\n    public void testQuality() {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getQuality() != null);\n        assertEquals(\"quality_\", fastq.getQuality());\n    }\n\n    public void testVariant() {\n        Fastq fastq = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        assertTrue(fastq.getVariant() != null);\n        assertEquals(FastqVariant.FASTQ_SANGER, fastq.getVariant());\n    }\n    \n    public void testQualityConversions() {\n        DNASequence seq = new DNASequence(\"ACGTA\");\n        QualityFeature qual = new QualityFeature<DNASequence, NucleotideCompound>(\"quality\", \"sequencing\");\n        List<Number> quals = new ArrayList<Number>();\n        quals.add(40);\n        quals.add(30);\n        quals.add(20);\n        quals.add(10);\n        quals.add(1);\n        qual.setQualities(quals);\n        seq.addFeature(1, seq.getLength(), qual);\n        Fastq fastq = new Fastq(seq, FastqVariant.FASTQ_SANGER);\n        assertEquals(\"I?5+\\\"\", fastq.getQuality());\n        Fastq sangerfastq = new Fastq(\"description\", \"ACGTA\", \"I?5+\\\"\", FastqVariant.FASTQ_SANGER);\n        DNASequence dnaSequence = sangerfastq.getDNASequence();\n        checkDNASequence(dnaSequence);\n        Fastq illuminafastq = new Fastq(dnaSequence, FastqVariant.FASTQ_ILLUMINA);\n        assertEquals(\"h^TJA\", illuminafastq.getQuality());\n        dnaSequence = illuminafastq.getDNASequence();\n        checkDNASequence(dnaSequence);\n        Fastq newilluminafastq = new Fastq(dnaSequence, FastqVariant.FASTQ_NEW_ILLUMINA);\n        assertEquals(\"I?5+\\\"\", newilluminafastq.getQuality());\n        dnaSequence = newilluminafastq.getDNASequence();\n        checkDNASequence(dnaSequence);\n        Fastq solexafastq = new Fastq(dnaSequence, FastqVariant.FASTQ_SOLEXA);\n        assertEquals(\"h^TJ;\", solexafastq.getQuality());\n        dnaSequence = solexafastq.getDNASequence();\n        checkDNASequence(dnaSequence);\n        sangerfastq = new Fastq(dnaSequence, FastqVariant.FASTQ_SANGER);\n        assertEquals(\"I?5+\\\"\", sangerfastq.getQuality());\n        dnaSequence = sangerfastq.getDNASequence();\n        checkDNASequence(dnaSequence);\n    }\n\n    private void checkDNASequence(DNASequence dnaSequence) {\n        assertEquals(\"ACGTA\", dnaSequence.getSequenceAsString());\n        List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = dnaSequence.getFeaturesByType(\"quality\");\n        assertEquals(1, features.size());\n        FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature = features.get(0);\n        assertTrue(feature instanceof QualityFeature);\n        QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound> qualfeature = (QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>) feature;\n        List<Number> qualities = qualfeature.getQualities();\n        assertEquals(5, qualities.size());\n        assertEquals(40, qualities.get(0));\n        assertEquals(30, qualities.get(1));\n        assertEquals(20, qualities.get(2));\n        assertEquals(10, qualities.get(3));\n        assertEquals(01, qualities.get(4));\n    }\n\n    public void testEquals() {\n        Fastq fastq0 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        Fastq fastq1 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n\n        assertFalse(fastq0.equals(null));\n        assertFalse(fastq1.equals(null));\n        assertFalse(fastq0.equals(new Object()));\n        assertFalse(fastq1.equals(new Object()));\n        assertTrue(fastq0.equals(fastq0));\n        assertTrue(fastq1.equals(fastq1));\n        assertFalse(fastq0 == fastq1);\n        assertFalse(fastq0.equals(fastq1));\n        assertFalse(fastq1.equals(fastq0));\n    }\n\n    public void testHashCode() {\n        Fastq fastq0 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n        Fastq fastq1 = new Fastq(\"description\", \"sequence\", \"quality_\", FastqVariant.FASTQ_SANGER);\n\n        assertEquals(fastq0.hashCode(), fastq0.hashCode());\n        assertEquals(fastq1.hashCode(), fastq1.hashCode());\n        if (fastq0.equals(fastq1)) {\n            assertEquals(fastq0.hashCode(), fastq1.hashCode());\n            assertEquals(fastq1.hashCode(), fastq0.hashCode());\n        }\n        if (fastq1.equals(fastq0)) {\n            assertEquals(fastq0.hashCode(), fastq1.hashCode());\n            assertEquals(fastq1.hashCode(), fastq0.hashCode());\n        }\n    }\n}","commitMessage":"implemented a new Fastq Reader/Writer for the new Illumina Fastq Formatting (according to Wikipedia it's version 1.8, new this month\nextended the Fastq class to be able to generate DNASequence representations with the Quality (as Phred Numbers) added as Feature\nextended the Fastq class to have a contructor that accepts a DNASequence\nsome test cases\ncode formatting\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9545 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"implemented a new Fastq Reader/Writer for the new Illumina Fastq Formatting (according to Wikipedia it's version 1.8, new this month\nextended the Fastq class to be able to generate DNASequence representations with the Quality (as Phred Numbers) added as Feature\nextended the Fastq class to have a contructor that accepts a DNASequence\nsome test cases\ncode formatting\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9545 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}