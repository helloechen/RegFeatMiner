{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/UnitQuaternions.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestUnitQuaternions.java","prod_time":"2016-08-02 22:19:15","test_time":"2016-08-02 22:19:45","type":"RENAME","proType":"RENAME","add_annotation_line":0,"add_call_line":1,"add_classname_line":1,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":1,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":2,"del_classname_line":1,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":1,"del_parameter_line":2,"del_return_line":3,"label":"POSITIVE","prod_commitID":"a2891b7ff7f026b5ecdc4f72310e8ff2dab55e1e","test_commitID":"878e005e6d2c92d1f45f167dab2017c0ae26caf3","isfound":"found test change","originPro":"package org.biojava.nbio.structure.symmetry.geometry;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\n\n/**\n * Quaternions is a static Class that contains methods for calculating and using\n * quaternions. It assumes the use of {@link Quat4d} Class from vecmath to\n * represent quaternions, and it also implements some of the methods that the\n * library is missing.\n * <p>\n * A Quaternion is a four-dimensional vector used to describe a\n * three-dimensional attitude representation (axis and angle of rotation).\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class Quaternions {\n\n\t/** Prevent instantiation */\n\tprivate Quaternions() {\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing the quaternion\n\t * orientations of two sets of points in 3D.\n\t * <p>\n\t * First, the quaternion orientation of each set of points is calculated\n\t * using their principal axes with {@link #orientation(Point3d[])}. Then,\n\t * the two quaternions are compared using the method\n\t * {@link #orientationMetric(Quat4d, Quat4d)}.\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Point3d[] a, Point3d[] b) {\n\n\t\tQuat4d qa = orientation(a);\n\t\tQuat4d qb = orientation(b);\n\n\t\treturn orientationMetric(qa, qb);\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing two unit quaternion\n\t * orientations.\n\t * <p>\n\t * The two quaternions are compared using the formula: d(q1,q2) =\n\t * arccos(|q1*q2|). The range of the metric is [0, Pi/2], where 0 means the\n\t * same orientation and Pi/2 means the opposite orientation.\n\t * <p>\n\t * The formula is taken from: Huynh, D. Q. (2009). Metrics for 3D rotations:\n\t * comparison and analysis. Journal of Mathematical Imaging and Vision,\n\t * 35(2), 155–164. http://doi.org/10.1007/s10851-009-0161-2\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Quat4d q1, Quat4d q2) {\n\t\treturn Math.acos(dotProduct(q1, q2));\n\t}\n\n\t/**\n\t * The orientation represents the rotation of the principal axes with\n\t * respect to the axes of the coordinate system (unit vectors [1,0,0],\n\t * [0,1,0] and [0,0,1]).\n\t * <p>\n\t * The orientation can be expressed as a unit quaternion.\n\t * \n\t * @param points\n\t *            array of Point3d\n\t * @return the orientation of the point cloud as a unit quaternion\n\t */\n\tpublic static Quat4d orientation(Point3d[] points) {\n\n\t\tMomentsOfInertia moi = new MomentsOfInertia();\n\n\t\tfor (Point3d p : points)\n\t\t\tmoi.addPoint(p, 1.0);\n\n\t\t// Convert rotation matrix to quaternion\n\t\tQuat4d quat = new Quat4d();\n\t\tquat.set(moi.getOrientationMatrix());\n\n\t\treturn quat;\n\t}\n\n\t/**\n\t * Return the euclidean length of the quaternion (the norm, the magnitude).\n\t * <p>\n\t * The length of the quaternion is obtained by taking the square root of the\n\t * dot product of the quaternion with its conjugate.\n\t * \n\t * @param q\n\t *            quaternion as Quat4d object\n\t * @return the euclidean length of the quaterion\n\t */\n\tpublic static double length(Quat4d q) {\n\t\treturn Math.sqrt(lengthSquared(q));\n\t}\n\n\t/**\n\t * Return the squared euclidean length of the quaternion. It is equivalent\n\t * to [{@link #length(Quat4d)}]^2.\n\t * <p>\n\t * The squared length of the quaternion is obtained by the dot product of\n\t * the quaternion with its conjugate.\n\t * \n\t * @param q\n\t *            quaternion as Quat4d object\n\t * @return the euclidean length of the quaterion\n\t */\n\tpublic static double lengthSquared(Quat4d q) {\n\t\treturn q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;\n\t}\n\n\t/**\n\t * Compute the dot (inner) product of two quaternions.\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the value of the quaternion dot product\n\t */\n\tpublic static double dotProduct(Quat4d q1, Quat4d q2) {\n\t\treturn q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\n\t}\n\n}\n","changedPro":"package org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\n\n/**\n * UnitQuaternions is a static Class that contains methods for calculating and\n * using unit quaternions. It assumes the use of {@link Quat4d} Class from\n * vecmath to represent the unit quaternions, and it also implements some of the\n * basic methods that the library is missing.\n * <p>\n * A Unit Quaternion is a four-dimensional vector used to describe a\n * three-dimensional attitude representation (axis and angle of rotation). By\n * definition, unit quaternions are always normalized, so their length is always\n * 1.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class UnitQuaternions {\n\n\t/** Prevent instantiation */\n\tprivate UnitQuaternions() {\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing the quaternion\n\t * orientations of two sets of points in 3D.\n\t * <p>\n\t * First, the quaternion orientation of each set of points is calculated\n\t * using their principal axes with {@link #orientation(Point3d[])}. Then,\n\t * the two quaternions are compared using the method\n\t * {@link #orientationMetric(Quat4d, Quat4d)}.\n\t * \n\t * @param a\n\t *            array of Point3d\n\t * @param b\n\t *            array of Point3d\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Point3d[] a, Point3d[] b) {\n\n\t\tQuat4d qa = orientation(a);\n\t\tQuat4d qb = orientation(b);\n\n\t\treturn orientationMetric(qa, qb);\n\t}\n\n\t/**\n\t * The orientation metric is obtained by comparing two unit quaternion\n\t * orientations.\n\t * <p>\n\t * The two quaternions are compared using the formula: d(q1,q2) =\n\t * arccos(|q1*q2|). The range of the metric is [0, Pi/2], where 0 means the\n\t * same orientation and Pi/2 means the opposite orientation.\n\t * <p>\n\t * The formula is taken from: Huynh, D. Q. (2009). Metrics for 3D rotations:\n\t * comparison and analysis. Journal of Mathematical Imaging and Vision,\n\t * 35(2), 155–164. http://doi.org/10.1007/s10851-009-0161-2\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the quaternion orientation metric\n\t */\n\tpublic static double orientationMetric(Quat4d q1, Quat4d q2) {\n\t\treturn Math.acos(Math.abs(dotProduct(q1, q2)));\n\t}\n\n\t/**\n\t * The orientation represents the rotation of the principal axes with\n\t * respect to the axes of the coordinate system (unit vectors [1,0,0],\n\t * [0,1,0] and [0,0,1]).\n\t * <p>\n\t * The orientation can be expressed as a unit quaternion.\n\t * \n\t * @param points\n\t *            array of Point3d\n\t * @return the orientation of the point cloud as a unit quaternion\n\t */\n\tpublic static Quat4d orientation(Point3d[] points) {\n\n\t\tMomentsOfInertia moi = new MomentsOfInertia();\n\n\t\tfor (Point3d p : points)\n\t\t\tmoi.addPoint(p, 1.0);\n\n\t\t// Convert rotation matrix to quaternion\n\t\tQuat4d quat = new Quat4d();\n\t\tquat.set(moi.getOrientationMatrix());\n\n\t\treturn quat;\n\t}\n\n\t/**\n\t * Compute the dot (inner) product of two quaternions.\n\t * \n\t * @param q1\n\t *            quaternion as Quat4d object\n\t * @param q2\n\t *            quaternion as Quat4d object\n\t * @return the value of the quaternion dot product\n\t */\n\tpublic static double dotProduct(Quat4d q1, Quat4d q2) {\n\t\treturn q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\n\t}\n\n}\n","originTest":"package org.biojava.nbio.structure.symmetry.geometry;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\nimport javax.vecmath.Vector3d;\n\nimport org.junit.Test;\n\n/**\n * Test the methods in the {@link Quaternions} class.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestQuaternions {\n\n\t/**\n\t * Test {@link Quaternions#orientation(javax.vecmath.Point3d[])}.\n\t * <p>\n\t * Tests the identity orientation, orientation around one coordinate axis\n\t * and orientation around a non-coordinate axis.\n\t */\n\t@Test\n\tpublic void testOrientation() {\n\n\t\t// Cloud of points colinear with the coordinate axes centroid at orig\n\t\t// Put more mass to x, then y, then z - give correct order of PCA axes\n\t\tPoint3d[] cloud = new Point3d[180];\n\t\tfor (int p = 0; p < 60; p++) {\n\n\t\t\t// Two points, one positive one negative\n\t\t\tdouble[] coords = { 0, 0, 0 };\n\t\t\tdouble[] coords_neg = { 0, 0, 0 };\n\n\t\t\tint value = 60 - p;\n\t\t\tint index = p / 20;\n\n\t\t\tcoords[index] = 2 * value;\n\t\t\tcoords_neg[index] = -value;\n\n\t\t\tcloud[3 * p] = new Point3d(coords);\n\t\t\tcloud[3 * p + 1] = new Point3d(coords_neg);\n\t\t\tcloud[3 * p + 2] = new Point3d(coords_neg);\n\t\t}\n\n\t\tQuat4d orientation = Quaternions.orientation(cloud);\n\t\torientation.normalize();\n\n\t\t// No rotation is equivalent to a quaternion with scalar 1 and rest 0\n\t\tassertEquals(orientation.x, 0.0, 0.01);\n\t\tassertEquals(orientation.y, 0.0, 0.01);\n\t\tassertEquals(orientation.z, 0.0, 0.01);\n\t\tassertEquals(Math.abs(orientation.w), 1.0, 0.01);\n\n\t\t// Rotate cloud 90 degrees through x axis and recover orientation\n\t\tAxisAngle4d axis90x = new AxisAngle4d(new Vector3d(1, 0, 0), 1.57079633);\n\t\tMatrix4d mat90x = new Matrix4d();\n\t\tmat90x.set(axis90x);\n\n\t\tPoint3d[] cloud2 = SuperPosition.clonePoint3dArray(cloud);\n\t\tSuperPosition.transform(mat90x, cloud2);\n\n\t\torientation = Quaternions.orientation(cloud2);\n\t\torientation.normalize();\n\t\tAxisAngle4d orientaxis = new AxisAngle4d();\n\t\torientaxis.set(orientation);\n\n\t\t// Angle of rotation 90 degrees around x axis\n\t\tassertEquals(Math.abs(orientaxis.x), 1.0, 0.01);\n\t\tassertEquals(orientaxis.y, 0.0, 0.01);\n\t\tassertEquals(orientaxis.z, 0.0, 0.01);\n\t\tassertEquals(orientaxis.angle, axis90x.angle, 0.01);\n\n\t\t// Now try a rotation through a non-coordinate axis\n\t\tQuat4d quat = new Quat4d(1.0, 1.0, 1.0, 1.0);\n\n\t\tMatrix4d mat = new Matrix4d();\n\t\tmat.set(quat);\n\n\t\tSuperPosition.transform(mat, cloud);\n\n\t\torientation = Quaternions.orientation(cloud);\n\t\torientation.normalize();\n\n\t\t// Test recovering the quaternion (q and -q same rotation)\n\t\tassertEquals(Math.abs(orientation.x), quat.x, 0.01);\n\t\tassertEquals(Math.abs(orientation.y), quat.y, 0.01);\n\t\tassertEquals(Math.abs(orientation.z), quat.z, 0.01);\n\t\tassertEquals(Math.abs(orientation.w), quat.w, 0.01);\n\t}\n\n\t/**\n\t * Test {@link Quaternions#orientationMetric(Point3d[], Point3d[])}.\n\t * <p>\n\t * Tests the range of values of the metric with a perfect correlation,\n\t * perfect anticorrelation and intermediate values.\n\t */\n\t@Test\n\tpublic void testOrientationMetric() {\n\n\t\t// no rotation quaternion\n\t\tQuat4d qa = new Quat4d(0, 0, 0, 1);\n\t\tQuat4d qb = new Quat4d(qa);\n\t\t\n\t\tassertEquals(Quaternions.orientationMetric(qa, qb), 0, 0.01);\n\t\t\n\t\t// rotate 180 degrees to get opposite orientation\n\t\tqb = new Quat4d(1, 0, 0, 0);\n\t\t\n\t\tassertEquals(Quaternions.orientationMetric(qa, qb), Math.PI / 2, 0.01);\n\t\t\n\t\t// rotate 90 degrees to get half-way orientation\n\t\tqb = new Quat4d(0.706, 0, 0, 0.706);\n\t\t\n\t\tassertEquals(Quaternions.orientationMetric(qa, qb), Math.PI / 4, 0.01);\n\t}\n}\n","changedTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Quat4d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.UnitQuaternions;\nimport org.junit.Test;\n\n/**\n * Test the methods in the {@link UnitQuaternions} class.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestUnitQuaternions {\n\n\t/**\n\t * Test {@link UnitQuaternions#orientation(javax.vecmath.Point3d[])}.\n\t * <p>\n\t * Tests the identity orientation, orientation around one coordinate axis\n\t * and orientation around a non-coordinate axis.\n\t */\n\t@Test\n\tpublic void testOrientation() {\n\n\t\t// Cloud of points colinear with the coordinate axes centroid at orig\n\t\t// Put more mass to x, then y, then z - give correct order of PCA axes\n\t\tPoint3d[] cloud = new Point3d[180];\n\t\tfor (int p = 0; p < 60; p++) {\n\n\t\t\t// Two points, one positive one negative\n\t\t\tdouble[] coords = { 0, 0, 0 };\n\t\t\tdouble[] coords_neg = { 0, 0, 0 };\n\n\t\t\tint value = 60 - p;\n\t\t\tint index = p / 20;\n\n\t\t\tcoords[index] = 2 * value;\n\t\t\tcoords_neg[index] = -value;\n\n\t\t\tcloud[3 * p] = new Point3d(coords);\n\t\t\tcloud[3 * p + 1] = new Point3d(coords_neg);\n\t\t\tcloud[3 * p + 2] = new Point3d(coords_neg);\n\t\t}\n\n\t\tQuat4d orientation = UnitQuaternions.orientation(cloud);\n\t\torientation.normalize();\n\n\t\t// No rotation is equivalent to a quaternion with scalar 1 and rest 0\n\t\tassertEquals(orientation.x, 0.0, 0.01);\n\t\tassertEquals(orientation.y, 0.0, 0.01);\n\t\tassertEquals(orientation.z, 0.0, 0.01);\n\t\tassertEquals(Math.abs(orientation.w), 1.0, 0.01);\n\n\t\t// Rotate cloud 90 degrees through x axis and recover orientation\n\t\tAxisAngle4d axis90x = new AxisAngle4d(new Vector3d(1, 0, 0), 1.57079633);\n\t\tMatrix4d mat90x = new Matrix4d();\n\t\tmat90x.set(axis90x);\n\n\t\tPoint3d[] cloud2 = SuperPosition.clonePoint3dArray(cloud);\n\t\tSuperPosition.transform(mat90x, cloud2);\n\n\t\torientation = UnitQuaternions.orientation(cloud2);\n\t\torientation.normalize();\n\t\tAxisAngle4d orientaxis = new AxisAngle4d();\n\t\torientaxis.set(orientation);\n\n\t\t// Angle of rotation 90 degrees around x axis\n\t\tassertEquals(Math.abs(orientaxis.x), 1.0, 0.01);\n\t\tassertEquals(orientaxis.y, 0.0, 0.01);\n\t\tassertEquals(orientaxis.z, 0.0, 0.01);\n\t\tassertEquals(orientaxis.angle, axis90x.angle, 0.01);\n\n\t\t// Now try a rotation through a non-coordinate axis\n\t\tQuat4d quat = new Quat4d(0.5, 0.5, 0.5, 0.5);\n\n\t\tMatrix4d mat = new Matrix4d();\n\t\tmat.set(quat);\n\n\t\tSuperPosition.transform(mat, cloud);\n\n\t\torientation = UnitQuaternions.orientation(cloud);\n\t\torientation.normalize();\n\n\t\t// Test recovering the quaternion (q and -q same rotation)\n\t\tassertEquals(Math.abs(orientation.x), quat.x, 0.01);\n\t\tassertEquals(Math.abs(orientation.y), quat.y, 0.01);\n\t\tassertEquals(Math.abs(orientation.z), quat.z, 0.01);\n\t\tassertEquals(Math.abs(orientation.w), quat.w, 0.01);\n\t}\n\n\t/**\n\t * Test {@link UnitQuaternions#orientationMetric(Point3d[], Point3d[])}.\n\t * <p>\n\t * Tests the range of values of the metric with a perfect correlation,\n\t * perfect anticorrelation and intermediate values.\n\t */\n\t@Test\n\tpublic void testOrientationMetric() {\n\n\t\t// no rotation quaternion\n\t\tQuat4d qa = new Quat4d(0, 0, 0, 1);\n\t\tQuat4d qb = new Quat4d(qa);\n\n\t\t// Two equal quaternions produce the minimum score of 0\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), 0, 0.01);\n\n\t\t// 90 degrees rotation over x\n\t\tqa = new Quat4d(0.707, 0, 0, 0.707);\n\n\t\t// 270 degrees rotation over x\n\t\tqb = new Quat4d(0.707, 0, 0, -0.707);\n\n\t\t// two quaternions with 180 degree axis produce the max score Pi / 2\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 2,\n\t\t\t\t0.01);\n\n\t\t// 90 degrees rotation over y\n\t\tqb = new Quat4d(0, 0.707, 0, 0.707);\n\n\t\t// two quaternions with 90 degree axis produce the score Pi / 4\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3,\n\t\t\t\t0.01);\n\n\t\t// two quaternions with 45 degree axis produce the score Pi / 8\n\t\tqb = new Quat4d(0.383, 0, 0, 0.924);\n\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 8,\n\t\t\t\t0.01);\n\t\t\n\t\t// 90 degrees rotation over x in negative\n\t\tqb = new Quat4d(0, -0.707, 0, -0.707);\n\t\t\n\t\t// assert no negative angles are returned\n\t\tassertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3,\n\t\t\t\t0.01);\n\t\t\n\t}\n}\n","commitMessage":"Move general geometry methods to new package #545","test_commitMessage":"Finish tests for Quaternion metrics and Superposition","allZero":false}