{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/Bond.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/TestBond.java","prod_time":"2013-11-23 05:20:30","test_time":"2014-03-01 05:32:16","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"00014646ae9b76a7f9f1eb8238562c5d11091040","test_commitID":"2e4aa39ac7b84edda02bbfc5ecc063e698d70e43","isfound":"found test change","originPro":"/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage org.biojava.bio.structure;\n\n/**\n * A simple bond -- it stores information about two atoms as well as information\n * about its bond order.\n * \n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\n * @author Ulysse Carion\n */\npublic class Bond {\n\tprivate Atom atomA;\n\tprivate Atom atomB;\n\tprivate int bondOrder;\n\n\t/**\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\n\t * between them.\n\t * <p>\n\t * Note that by forming a bond between atoms 'A' and 'B' with this\n\t * constructor, atoms 'A' and 'B' will be updated to have this bond in their\n\t * list of bonds. If you do not want this automatic updating, instead use\n\t * {@link #Bond(Atom, Atom, int, boolean)} with the\n\t * <code>addSelfToAtoms</code> flag set to <code>false</code>.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\n\t\tthis(atomA, atomB, bondOrder, true);\n\t}\n\n\t/**\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\n\t * between them.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t * @param addSelfToAtoms\n\t *            if set to true, this bond, once created, will automatically\n\t *            add itself to atomA and atomB's bond lists. (If this argument\n\t *            is set to false, the list returned from\n\t *            {@link Atom#getBonds()} will not contain this bond.)\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\n\t\tthis.atomA = atomA;\n\t\tthis.atomB = atomB;\n\t\tthis.bondOrder = bondOrder;\n\n\t\tif (addSelfToAtoms) {\n\t\t\taddSelfToAtoms();\n\t\t}\n\t}\n\n\t/**\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\n\t * then the list returned from calling {@link Atom#getBonds()} will not\n\t * include this bond.\n\t * <p>\n\t * If you created your Bond with the constructor\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\n\t * you and should not be called again.\n\t */\n\t// TODO first check if those bonds haven't been made already\n\tpublic void addSelfToAtoms() {\n\t\tatomA.getBonds().add(this);\n\t\tatomB.getBonds().add(this);\n\t}\n\n\t/**\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomB()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomA() {\n\t\treturn atomA;\n\t}\n\n\t/**\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomA()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomB() {\n\t\treturn atomB;\n\t}\n\n\t/**\n\t * A utility method to get the other atom in a bond, given one of its atoms.\n\t * If the atom passed is one of the atoms in this bond, then this method is\n\t * essentially equivalent to saying\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\n\t * <p>\n\t * <i>Note:</i> Comparison of atoms in this method is done with\n\t * <code>==</code>, not <code>equals</code>.\n\t * \n\t * @param exclude\n\t *            the atom of the bond to not return\n\t * @throws IllegalArgumentException\n\t *             if the passed atom is not in this bond\n\t * @return the atom in this bond that was not passed as an argument\n\t */\n\tpublic Atom getOther(Atom exclude) {\n\t\tif (exclude != atomA && exclude != atomB) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\n\t\t}\n\n\t\tif (exclude == atomA) {\n\t\t\treturn atomB;\n\t\t} else {\n\t\t\treturn atomA;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\n\t * single bond, '2' to a double bond, etc.\n\t * \n\t * @return this bond's bond order\n\t */\n\tpublic int getBondOrder() {\n\t\treturn bondOrder;\n\t}\n\n\t/**\n\t * Gets the distance between the two atoms of this bond.\n\t * <p>\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\n\t * this method will suppress the empty threat of a\n\t * {@link StructureException} that method makes.\n\t * \n\t * @return the distance between the two atoms of this bond.\n\t */\n\tpublic double getLength() {\n\t\ttry {\n\t\t\treturn Calc.getDistance(atomA, atomB);\n\t\t} catch (StructureException e) {\n\t\t\treturn -1; // this will never happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\n\t\t\t\t+ bondOrder + \"]\";\n\t}\n}\n","changedPro":"/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage org.biojava.bio.structure;\r\n\r\n/**\r\n * A simple bond -- it stores information about two atoms as well as information\r\n * about its bond order.\r\n * \r\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\r\n * @author Ulysse Carion\r\n */\r\npublic class Bond {\r\n\tprivate Atom atomA;\r\n\tprivate Atom atomB;\r\n\tprivate int bondOrder;\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * <p>\r\n\t * Note that by forming a bond between atoms 'A' and 'B' with this\r\n\t * constructor, atoms 'A' and 'B' will be updated to have this bond in their\r\n\t * list of bonds. If you do not want this automatic updating, instead use\r\n\t * {@link #Bond(Atom, Atom, int, boolean)} with the\r\n\t * <code>addSelfToAtoms</code> flag set to <code>false</code>.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\r\n\t\tthis(atomA, atomB, bondOrder, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t * @param addSelfToAtoms\r\n\t *            if set to true, this bond, once created, will automatically\r\n\t *            add itself to atomA and atomB's bond lists. (If this argument\r\n\t *            is set to false, the list returned from\r\n\t *            {@link Atom#getBonds()} will not contain this bond.)\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\r\n\t\tthis.atomA = atomA;\r\n\t\tthis.atomB = atomB;\r\n\t\tthis.bondOrder = bondOrder;\r\n\r\n\t\tif (addSelfToAtoms) {\r\n\t\t\taddSelfToAtoms();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\r\n\t * then the list returned from calling {@link Atom#getBonds()} will not\r\n\t * include this bond.\r\n\t * <p>\r\n\t * If you created your Bond with the constructor\r\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\r\n\t * you and should not be called again.\r\n\t */\r\n\t// TODO first check if those bonds haven't been made already\r\n\tpublic void addSelfToAtoms() {\r\n\t\tatomA.addBond(this);\r\n\t\tatomB.addBond(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomB()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomA() {\r\n\t\treturn atomA;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomA()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomB() {\r\n\t\treturn atomB;\r\n\t}\r\n\r\n\t/**\r\n\t * A utility method to get the other atom in a bond, given one of its atoms.\r\n\t * If the atom passed is one of the atoms in this bond, then this method is\r\n\t * essentially equivalent to saying\r\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\r\n\t * <p>\r\n\t * <i>Note:</i> Comparison of atoms in this method is done with\r\n\t * <code>==</code>, not <code>equals</code>.\r\n\t * \r\n\t * @param exclude\r\n\t *            the atom of the bond to not return\r\n\t * @throws IllegalArgumentException\r\n\t *             if the passed atom is not in this bond\r\n\t * @return the atom in this bond that was not passed as an argument\r\n\t */\r\n\tpublic Atom getOther(Atom exclude) {\r\n\t\tif (exclude != atomA && exclude != atomB) {\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\r\n\t\t}\r\n\r\n\t\tif (exclude == atomA) {\r\n\t\t\treturn atomB;\r\n\t\t} else {\r\n\t\t\treturn atomA;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\r\n\t * single bond, '2' to a double bond, etc.\r\n\t * \r\n\t * @return this bond's bond order\r\n\t */\r\n\tpublic int getBondOrder() {\r\n\t\treturn bondOrder;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance between the two atoms of this bond.\r\n\t * <p>\r\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\r\n\t * this method will suppress the empty threat of a\r\n\t * {@link StructureException} that method makes.\r\n\t * \r\n\t * @return the distance between the two atoms of this bond.\r\n\t */\r\n\tpublic double getLength() {\r\n\t\ttry {\r\n\t\t\treturn Calc.getDistance(atomA, atomB);\r\n\t\t} catch (StructureException e) {\r\n\t\t\treturn -1; // this will never happen.\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\r\n\t\t\t\t+ bondOrder + \"]\";\r\n\t}\r\n}\r\n","originTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Before;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\t\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tcache.setUseMmCif(false);\n\t\t\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\t\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\t\t\n\t\tStructureIO.setAtomCache(cache);\n\t\t\n\t\ts = StructureIO.getStructure(\"1kh9\");\n\t}\n\t\n\tpublic void testIntraResidueBonds() throws StructureException {\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\t\t\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void testPeptideBonds() throws StructureException {\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\t\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\t\t\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\t\n\tpublic void testLINKBonds() throws StructureException {\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(50).getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tpublic void testDisulfideBonds() throws StructureException {\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\t\t\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tpublic void testLigandBonds() throws StructureException {\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\t\t\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\t\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\t\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\t\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\t\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","changedTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Before;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\t\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tcache.setUseMmCif(false);\n\t\t\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\t\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\t\t\n\t\tStructureIO.setAtomCache(cache);\n\t\t\n\t\t\n\t}\n\t\n\tpublic void testIntraResidueBonds() throws StructureException, IOException {\n\t\t\n\t\tif ( s == null)\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\t\t\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void testPeptideBonds() throws StructureException, IOException {\n\t\tif ( s == null)\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\t\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\t\t\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\t\n\tpublic void testLINKBonds() throws StructureException, IOException {\n\t\tif ( s == null)\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(50).getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tpublic void testDisulfideBonds() throws StructureException, IOException {\n\t\tif ( s == null)\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\t\t\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tpublic void testLigandBonds() throws StructureException, IOException {\n\t\tif ( s == null)\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\t\t\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\t\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\t\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\t\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\t\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","commitMessage":"Initialize list of bonds lazily. The bond list in an Atom is now\ninitialized with Collections.emptyList(), rather than an ArrayList. This\ndoubles the speed of allocating Atoms, since the bond list is not\ncreated.","test_commitMessage":"a couple of more fixes to the junit tests for #76\n","allZero":false}