{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/SecStrucCalc.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestSecStrucCalc.java","prod_time":"2016-09-15 08:11:22","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"90b55c37e359008ae11fd4e73f84bd79b43e1e13","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.AtomContact;\nimport org.biojava.nbio.structure.contact.AtomContactSet;\nimport org.biojava.nbio.structure.contact.Grid;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Calculate and assign the secondary structure (SS) to the\n * Groups of a Structure object. This object also stores the result\n * of the calculation.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * Original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>.\n * Some parts are also taken from: T.E.Creighton, Proteins -\n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n *\n * @author Andreas Prlic\n * @author Aleix Lafita\n * @autho Anthony Bradley\n *\n */\npublic class SecStrucCalc {\n\n\t/**\n\t * DSSP assigns helices one residue shorter at each end, because the\n\t * residues at (i-1) and (i+n+1) are not assigned helix type although\n\t * they contain a consistent turn (H-bond). If this parameter\n\t * is true, the helices will be the length of the original DSSP\n\t * convention. If it is false, they will be two residue longer.\n\t */\n\tprivate static final boolean DSSP_HELICES = true;\n\n\tprivate static final Logger logger =\n\t\t\tLoggerFactory.getLogger(SecStrucCalc.class);\n\n\t/** min distance between two residues */\n\tpublic static final double MINDIST = 0.5;\n\n\t/** min distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static final double CA_MIN_DIST = 9.0;\n\n\t/** max distance CA atoms in peptide bond (backbone discontinuity) */\n\tpublic static final double MAX_PEPTIDE_BOND_LENGTH = 2.5;\n\n\t/** Minimal H-bond energy in cal/mol */\n\tpublic static final int HBONDLOWENERGY  = -9900;\n\n\t/** higher limit for H-bond energy */\n\tpublic static final double HBONDHIGHENERGY = -500.0;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t *      f  *  q1 *   q2  *  scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\tpublic static final double Q = -27888.0;\n\n\t// Three lists\n\tprivate SecStrucGroup[] groups;\n\tprivate List<Ladder> ladders;\n\tprivate List<BetaBridge> bridges;\n\tprivate Atom[] atoms;\n\t// Added by Anthony - to speed up intergroup calculations\n\tprivate AtomContactSet contactSet;\n\tprivate Map<String, Integer> indResMap;\n\tpublic SecStrucCalc(){\n\t\tladders = new ArrayList<Ladder>();\n\t\tbridges = new ArrayList<BetaBridge>();\n\t}\n\n\n\t/**\n\t * Predicts the secondary structure of this Structure object,\n\t * using a DSSP implementation.\n\t *\n\t * @param s Structure to predict the SS\n\t * @param assign sets the SS information to the Groups of s\n\t * @return a List of SS annotation objects\n\t */\n\tpublic List<SecStrucState> calculate(Structure s, boolean assign)\n\t\t\tthrows StructureException {\n\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\tfor(int i=0; i<s.nrModels(); i++) {\n\t\t\t// Reinitialise the global vars\n\t\t\tladders = new ArrayList<Ladder>();\n\t\t\tbridges = new ArrayList<BetaBridge>();\n\t\t\tgroups = initGroupArray(s, i);\n\t\t\t// Initialise the contact set for this structure\n\t\t\tinitContactSet();\n\t\t\tif (groups.length < 5) {\n\t\t\t\t// not enough groups to do anything\n\t\t\t\tthrow new StructureException(\"Not enough backbone groups in the\"\n\t\t\t\t\t\t+ \" Structure to calculate the secondary structure (\"\n\t\t\t\t\t\t+ groups.length+\" given, minimum 5)\" );\n\t\t\t}\n\n\t\t\tcalculateHAtoms();\n\t\t\tcalculateHBonds();\n\t\t\tcalculateDihedralAngles();\n\t\t\tcalculateTurns();\n\t\t\tbuildHelices();\n\t\t\tdetectBends();\n\t\t\tdetectStrands();\n\n\t\t\tfor (SecStrucGroup sg : groups){\n\t\t\t\tSecStrucState ss = (SecStrucState)\n\t\t\t\t\t\tsg.getProperty(Group.SEC_STRUC);\n\t\t\t\t// Add to return list and assign to original if flag is true\n\t\t\t\tsecstruc.add(ss);\n\t\t\t\tif (assign) sg.getOriginal().setProperty(Group.SEC_STRUC, ss);\n\t\t\t}\n\t\t}\n\t\treturn secstruc;\n\t}\n\n\t/**\n\t * Function to generate the contact sets\n\t */\n\tprivate void initContactSet() {\n\n\t\t// Initialise an array of atoms\n\t\tatoms = new Atom[groups.length];\n\t\t// Remake this local var\n\t\tindResMap = new HashMap<String, Integer>();\n\t\tfor (int i=0 ; i < groups.length ; i++){\n\t\t\tSecStrucGroup one = groups[i];\n\t\t\tindResMap.put(one.getResidueNumber().getChainName()+one.getResidueNumber().getSeqNum(), i);\n\t\t\tatoms[i] = one.getCA();\n\t\t}\n\t\tGrid grid = new Grid(CA_MIN_DIST);\n\t\tif(atoms.length==0){\n\t\t\tcontactSet = new AtomContactSet(CA_MIN_DIST);\n\t\t}\n\t\telse{\n\t\t\tgrid.addAtoms(atoms);\n\t\t\tcontactSet = grid.getContacts();\n\t\t}\n\t}\n\n\t/**\n\t * Updated code to detect strands\n\t */\n\tprivate void detectStrands() {\n\n\t\t//Find all the beta bridges of the structure\n\t\tfindBridges();\n\t\t//Create Ladders\n\t\tcreateLadders();\n\n\t\t//Detect beta bulges between ladders\n\t\tconnectLadders();\n\n\t\t//AND store SS assignments for Sheets, Strands and Bridges\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void createLadders(){\n\n\t\tfor (BetaBridge b : bridges){\n\t\t\tboolean found = false;\n\t\t\tfor (Ladder ladder : ladders){\n\t\t\t\tif (shouldExtendLadder(ladder, b)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tladder.to++; //we go forward in this direction\n\t\t\t\t\tswitch(b.type){\n\t\t\t\t\tcase parallel:\n\t\t\t\t\t\tladder.lto++; //increment second strand\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase antiparallel:\n\t\t\t\t\t\tladder.lfrom--; //decrement second strand\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found){\n\t\t\t\t//Create new ladder with a single Bridge\n\t\t\t\tLadder l = new Ladder();\n\t\t\t\tl.from = b.partner1;\n\t\t\t\tl.to = b.partner1;\n\t\t\t\tl.lfrom = b.partner2;\n\t\t\t\tl.lto = b.partner2;\n\t\t\t\tl.btype = b.type;\n\t\t\t\tladders.add(l);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void updateSheets() {\n\n\t\tlogger.debug(\" got \" +ladders.size() + \"  ladders!\");\n\n\t\tfor (Ladder ladder : ladders){\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor (int lcount = ladder.from; lcount <= ladder.to; lcount++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getType();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getType();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t\tsetSecStrucType(l2count, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( !stype.isHelixType() &&\n\t\t\t\t\t\t\t( !stype.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'\n\n\t\t\tif (ladder.connectedTo == 0) continue;\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif (ladder.btype.equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor (int lcount = ladder.from; lcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor (int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size(); j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif (hasBulge(l1,l2)) {\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\tlogger.debug(\"Bulge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\t/**\n\t * For beta structures, we define explicitly: a bulge-linked\n\t * ladder consists of two (perfect) ladder or bridges of the\n\t * same type connected by at most one extra residue on one\n\t * strand and at most four extra residues on the other strand,\n\t * all residues in bulge-linked ladders are marked \"E,\"\n\t * including the extra residues.\n\t */\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\n\t\tboolean bulge = ((l1.btype.equals(l2.btype)) &&\n\t\t\t\t(l2.from - l1.to < 6) &&\n\t\t\t\t(l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0));\n\n\t\tif (!bulge) return bulge;\n\n\t\tswitch(l1.btype){\n\t\tcase parallel:\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\n\t\t\tbreak;\n\n\t\tcase antiparallel:\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3)));\n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bulge;\n\t}\n\n\tprivate void registerBridge(int i, int j, BridgeType btype) {\n\n\t\tBetaBridge bridge = new BetaBridge(i,j,btype);\n\n\t\tboolean b1 = getSecStrucState(i).addBridge(bridge);\n\t\tboolean b2 = getSecStrucState(j).addBridge(bridge);\n\n\t\tif (!b1 && !b2)\n\t\t\tlogger.warn(\"Ignoring Bridge between residues\" + i + \" and \" + j\n\t\t\t\t\t+ \". DSSP assignment might differ.\");\n\n\t\tbridges.add(bridge);\n\t}\n\n\t/**\n\t * Conditions to extend a ladder with a given beta Bridge:\n\t * <li>The bridge and ladder are of the same type.\n\t * <li>The smallest bridge residue is sequential to the first\n\t * \t\tstrand ladder.\n\t * <li>The second bridge residue is either sequential (parallel)\n\t * \t\tor previous (antiparallel) to the second strand of the ladder\n\t * </li>\n\t * @param ladder the ladder candidate to extend\n\t * @param b the beta bridge that would extend the ladder\n\t * @return true if the bridge b extends the ladder\n\t */\n\tprivate boolean shouldExtendLadder(Ladder ladder, BetaBridge b) {\n\n\t\t//Only extend if they are of the same type\n\t\tboolean sameType = b.type.equals(ladder.btype);\n\t\tif (!sameType) return false;\n\n\t\t//Only extend if residue 1 is sequential to ladder strand\n\t\tboolean sequential = (b.partner1 == ladder.to+1);\n\t\tif (!sequential) return false;\n\n\t\tswitch(b.type){\n\t\tcase parallel:\n\t\t\t//Residue 2 should be sequential to second strand\n\t\t\tif (b.partner2 == ladder.lto+1) return true;\n\t\t\tbreak;\n\t\tcase antiparallel:\n\t\t\t//Residue 2 should be previous to second strand\n\t\t\tif (b.partner2 == ladder.lfrom-1) return true;\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\n\t/**\n\t * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and\n\t * j-1,j,j+1, form either a parallel or antiparallel bridge, depending on\n\t * which of two basic patterns is matched. We assign a bridge between\n\t * residues i and j if there are two H bonds characteristic of beta-\n\t * structure; in particular:\n\t * <p>\n\t * Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)]\n\t * \t\t\t\t\t\t\tor [Hbond(j-1,i) and Hbond(i,j+1)]\n\t * <p>\n\t * Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)]\n\t * \t\t\t\t\t\t\t\tor [Hbond(i-1,j+1) and Hbond(j-1,i+1)]\n\t *\n\t * Optimised to use the contact set\n\t */\n\tprivate void findBridges() {\n\t\t// Get the interator of contacts\n\t\tIterator<AtomContact> myIter = contactSet.iterator();\n\t\tList<Pair<Integer>> outList = new ArrayList<Pair<Integer>>();\n\n\t\t// Now iterate through this\n\t\twhile(myIter.hasNext()){\n\t\t\t// Get the next atom contact\n\t\t\tAtomContact ac = myIter.next();\n\t\t\tGroup g1 = ac.getPair().getFirst().getGroup();\n\t\t\tGroup g2 = ac.getPair().getSecond().getGroup();\n\t\t\t// Get the indices\n\t\t\tint i = indResMap.get(g1.getResidueNumber().getChainName()+g1.getResidueNumber().getSeqNum());\n\t\t\tint j = indResMap.get(g2.getResidueNumber().getChainName()+g2.getResidueNumber().getSeqNum());\n\t\t\t// If i>j switch them over\n\t\t\tif(i>j){\n\t\t\t\t// Switch them over\n\t\t\t\tint old = i;\n\t\t\t\ti = j;\n\t\t\t\tj = old;\n\t\t\t}\n\t\t\t// Only these\n\t\t\tif(j<i+3){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If it's the first\n\t\t\tif(i==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If it's the last\n\t\t\tif(i==groups.length-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j==groups.length-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPair<Integer> thisPair = new Pair<Integer>(i,j);\n\t\t\toutList.add(thisPair);\n\t\t}\n\t\t//\n\t\tCollections.sort(outList, new Comparator<Pair<Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Pair<Integer> o1, Pair<Integer> o2) {\n\t\t\t\tif(o1.getFirst()<o2.getFirst()){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if(o1.getFirst()>o2.getFirst()){\n\t\t\t\t\treturn +1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(o1.getSecond()<o2.getSecond()){\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(o1.getSecond()>o2.getSecond()){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\n\t\tfor(Pair<Integer> p: outList){\n\t\t\tint i = p.getFirst();\n\t\t\tint j = p.getSecond();\n\t\t\tBridgeType btype = null;\n\t\t\t// Now do the bonding\n\t\t\tif ((isBonded(i-1,j) && isBonded(j,i+1)) ||\n\t\t\t\t\t(isBonded(j-1,i) && isBonded(i,j+1))) {\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ((isBonded(i,j) && isBonded(j,i)) ||\n\t\t\t\t\t(isBonded(i-1,j+1) && (isBonded(j-1,i+1)))) {\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tregisterBridge(i, j, btype);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate void detectBends() {\n\n\t\tfor (int i = 2 ; i < groups.length-2 ;i++){\n\n\t\t\t//Check if all atoms form peptide bonds (backbone discontinuity)\n\t\t\tboolean bonded = true;\n\t\t\tfor (int k=0; k<4; k++){\n\t\t\t\tint index = i+k-2;\n\t\t\t\tAtom C = groups[index].getC();\n\t\t\t\tAtom N = groups[index+1].getN();\n\t\t\t\t//Peptide bond C-N\n\t\t\t\tif (Calc.getDistance(C, N) > MAX_PEPTIDE_BOND_LENGTH){\n\t\t\t\t\tbonded = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bonded) continue;\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\t//Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i + 2 )\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle = Calc.angle(caminus2, caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tstate.setKappa((float) angle);\n\n\t\t\t//Angles = 360 should be discarded\n\t\t\tif (angle > 70.0 && angle < 359.99) {\n\t\t\t\tsetSecStrucType(i, SecStrucType.bend);\n\t\t\t\tstate.setBend(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles()  {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState)\n\t\t\t\t\ta.getProperty(Group.SEC_STRUC);\n\t\t\tSecStrucState state2 = (SecStrucState)\n\t\t\t\t\tb.getProperty(Group.SEC_STRUC);\n\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn printDSSP();\n\t}\n\n\t/**\n\t * Generate a DSSP file format ouput String of this SS prediction.\n\t * @return String in DSSP output file format\n\t */\n\tpublic String printDSSP() {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\n\t\t//Header Line\n\t\tbuf.append(\"==== Secondary Structure Definition by BioJava\"\n\t\t\t\t+ \" DSSP implementation, Version October 2015 ====\"+nl);\n\n\t\t//First line with column definition\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     \"\n\t\t\t\t+ \"N-H-->O    O-->H-N    N-H-->O    O-->H-N    \"\n\t\t\t\t+ \"TCO  KAPPA ALPHA  PHI    PSI    \"\n\t\t\t\t+ \"X-CA   Y-CA   Z-CA \");\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tbuf.append(nl);\n\t\t\tSecStrucState ss = getSecStrucState(i);\n\t\t\tbuf.append(ss.printDSSPline(i));\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t * Generate a summary of this SS prediction with information about\n\t * the three types of helix turns in different row sequences.\n\t * <p>\n\t * This is similar to the summary output of Jmol, and useful to visualize\n\t * the helix patterns.\n\t *\n\t * @return String helix summary\n\t */\n\tpublic String printHelixSummary() {\n\n\t\tStringBuffer g = new StringBuffer(); //3-10 helix\n\t\tStringBuffer h = new StringBuffer(); //alpha helix\n\t\tStringBuffer i = new StringBuffer(); //pi-helix\n\t\tStringBuffer ss = new StringBuffer(); //SS summary\n\t\tStringBuffer aa = new StringBuffer(); //AA one-letter\n\t\tString nl = System.getProperty(\"line.separator\");\n\n\t\tg.append(\t\"3 turn: \");\n\t\th.append(\t\"4 turn: \");\n\t\ti.append(\t\"5 turn: \");\n\t\tss.append(\t\"SS:     \");\n\t\taa.append(\t\"AA:     \");\n\n\t\tfor (int k = 0; k < groups.length; k++){\n\n\t\t\tSecStrucState state = getSecStrucState(k);\n\t\t\tg.append(state.getTurn()[0]);\n\t\t\th.append(state.getTurn()[1]);\n\t\t\ti.append(state.getTurn()[2]);\n\t\t\tss.append(state.getType());\n\t\t\taa.append(StructureTools.get1LetterCode(groups[k].getPDBName()));\n\t\t}\n\n\t\treturn g.toString()+nl+h.toString()+nl+\n\t\t\t\ti.toString()+nl+ss.toString()+nl+aa.toString();\n\t}\n\n\t/**\n\t * Generate a FASTA sequence with the SS annotation letters in the\n\t * aminoacid sequence order.\n\t * @return String in FASTA sequence format\n\t */\n\tpublic String printFASTA() {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\tbuf.append(\">\"+groups[0].getChain().getStructure().getIdentifier()+nl);\n\n\t\tfor (int g = 0; g < groups.length; g++){\n\t\t\tbuf.append(getSecStrucState(g).getType());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t    final int prime = 31;\n\t    int result = 1;\n\t    result = prime * result + Arrays.hashCode(atoms);\n\t    return result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o){\n\n\t\tif (!(o instanceof SecStrucCalc)) return false;\n\t\telse {\n\t\t\tSecStrucCalc ss = (SecStrucCalc) o;\n\t\t\tif (groups.length != ss.groups.length) return false;\n\n\t\t\tfor (int g=0; g<groups.length; g++){\n\t\t\t\tSecStrucInfo g1 = getSecStrucState(g);\n\t\t\t\tSecStrucInfo g2 = ss.getSecStrucState(g);\n\t\t\t\tif (!g1.equals(g2)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s, int modelId) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t// \n\t\tfor ( Chain c : s.getChains(modelId)){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\n\t\t\t\t//We can also calc secstruc if it is a modified amino acid\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\n\t\t\t\t\tSecStrucState state = new SecStrucState(sg,\n\t\t\t\t\t\t\tSecStrucInfo.BIOJAVA_ASSIGNMENT,\n\t\t\t\t\t\t\tSecStrucType.coil);\n\n\t\t\t\t\tsg.setProperty(Group.SEC_STRUC, state);\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/**\n\t * Calculate the coordinates of the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location.\n\t */\n\tprivate void calculateHAtoms() throws StructureException {\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( !b.hasAtom(\"H\") ) {\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(), b.getN());\n\t\t\t\tb.setH(H);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Calculate the HBonds between different groups.\n\t * see Creighton page 147 f\n\t * Modified to use only the contact map\n\t */\n\tprivate void calculateHBonds() {\n\t\t/**\n\t\t * More efficient method for calculating C-Alpha pairs\n\t\t */\n\t\tif (groups.length < 5) return;\n\t\tIterator<AtomContact> otu = contactSet.iterator();\n\t\twhile(otu.hasNext()){\n\t\t\tAtomContact ac = otu.next();\n\t\t\tPair<Atom> pair = ac.getPair();\n\t\t\tGroup g1 = pair.getFirst().getGroup();\n\t\t\tGroup g2 = pair.getSecond().getGroup();\n\t\t\t// Now I need to get the index of the Group in the list groups\n\t\t\tint i = indResMap.get(g1.getResidueNumber().getChainName()+g1.getResidueNumber().getSeqNum());\n\t\t\tint j = indResMap.get(g2.getResidueNumber().getChainName()+g2.getResidueNumber().getSeqNum());\n\t\t\t// Now check this\n\t\t\tcheckAddHBond(i,j);\n\t\t\t//\"backwards\" hbonds are not allowed\n\t\t\tif (j!=(i+1)) checkAddHBond(j,i);\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\t\tif (!one.hasAtom(\"H\")) {\n\t\t\tlogger.debug(\"Residue \"+one.getResidueNumber()+\" has no H\");\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\n\t\tdouble energy = 0;\n\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\tlogger.warn(\"Energy calculation failed\", e);\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug(\"Energy between positions (\"+i+\",\"+j+\"): \"+energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/**\n\t * Calculate HBond energy of two groups in cal/mol\n\t * see Creighton page 147 f\n\t * <p>\n\t * Jeffrey, George A., An introduction to hydrogen bonding,\n\t * Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t * Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t */\n\tprivate static double calculateHBondEnergy(SecStrucGroup one,\n\t\t\tSecStrucGroup two) {\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber() +\n\t\t\t\t\" \" + one.getPDBName() + \" \" +two.getResidueNumber()+\n\t\t\t\t\" \" + two.getPDBName() + String.format(\" O (\"+\n\t\t\t\t\t\tO.getPDBserial()+\")..N (\"+ N.getPDBserial()+\n\t\t\t\t\t\t\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \",\n\t\t\t\t\t\tdno,dho,dhc,dnc,dno));\n\n\t\t//there seems to be a contact!\n\t\tif ( (dno < MINDIST) || (dhc < MINDIST) ||\n\t\t\t\t(dnc < MINDIST) || (dno < MINDIST)) {\n\t\t\treturn HBONDLOWENERGY;\n\t\t}\n\n\t\tdouble e1 = Q / dho - Q / dhc;\n\t\tdouble e2 = Q / dnc - Q / dno;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",\n\t\t\t\tN.getPDBserial(),O.getPDBserial(), (float) dno, energy));\n\n\t\t//Avoid too strong energy\n\t\tif (energy > HBONDLOWENERGY) return energy;\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * Store Hbonds in the Groups.\n\t * DSSP allows two HBonds per aminoacids to allow bifurcated bonds.\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tif (groups[i].getPDBName().equals(\"PRO\")) {\n\t\t\tlogger.debug(\"Ignore: PRO \" + groups[i].getResidueNumber());\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucState stateOne = getSecStrucState(i);\n\t\tSecStrucState stateTwo = getSecStrucState(j);\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\t//Acceptor: N-H-->O\n\t\tif (energy < acc1e) {\n\t\t\tlogger.debug(energy +\"<\"+acc1e);\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\tlogger.debug(energy +\"<\"+acc2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\n\t\t//The other side of the bond: donor O-->N-H\n\t\tif (energy <  don1e) {\n\t\t\tlogger.debug(energy +\"<\"+don1e);\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\t\t\tlogger.debug(energy +\"<\"+don2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\t\t}\n\t}\n\n\t/**\n\t * Detect helical turn patterns.\n\t */\n\tprivate void calculateTurns(){\n\n\t\tfor (int i = 0 ; i< groups.length; i++){\n\t\t\tfor (int turn = 3; turn <= 5; turn++) {\n\n\t\t\t\tif (i+turn >= groups.length) continue;\n\n\t\t\t\t//Check for H bond from NH(i+n) to CO(i)\n\t\t\t\tif (isBonded(i, i+turn)) {\n\t\t\t\t\tlogger.debug(\"Turn at (\"+i+\",\"+(i+turn)+\") turn \"+turn);\n\t\t\t\t\tgetSecStrucState(i).setTurn('>', turn);\n\t\t\t\t\tgetSecStrucState(i+turn).setTurn('<', turn);\n\t\t\t\t\t//Bracketed residues get the helix number\n\t\t\t\t\tfor (int j=i+1; j<i+turn; j++){\n\t\t\t\t\t\tInteger t = turn;\n\t\t\t\t\t\tchar helix = t.toString().charAt(0);\n\t\t\t\t\t\tgetSecStrucState(j).setTurn(helix, turn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Test if two groups are forming an H-Bond. The bond tested is\n\t * from the CO of group i to the NH of group j. Acceptor (i) and\n\t * donor (j). The donor of i has to be j, and the acceptor of j\n\t * has to be i.\n\t * DSSP defines H-Bonds if the energy < -500 cal/mol.\n\t *\n\t * @param i group one\n\t * @param j group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tSecStrucState one = getSecStrucState(i);\n\t\tSecStrucState two = getSecStrucState(j);\n\n\t\tdouble don1e = one.getDonor1().getEnergy();\n\t\tdouble don2e = one.getDonor2().getEnergy();\n\t\tdouble acc1e = two.getAccept1().getEnergy();\n\t\tdouble acc2e = two.getAccept2().getEnergy();\n\n\t\tint don1p = one.getDonor1().getPartner();\n\t\tint don2p = one.getDonor2().getPartner();\n\t\tint acc1p = two.getAccept1().getPartner();\n\t\tint acc2p = two.getAccept2().getPartner();\n\n\t\t//Either donor from i is j, or accept from j is i\n\t\tboolean hbond = (don1p == j && don1e < HBONDHIGHENERGY) ||\n\t\t\t\t(don2p == j && don2e < HBONDHIGHENERGY) ||\n\t\t\t\t(acc1p == i && acc1e < HBONDHIGHENERGY) ||\n\t\t\t\t(acc2p == i && acc2e < HBONDHIGHENERGY);\n\n\t\tif (hbond){\n\t\t\tlogger.debug(\"*** H-bond from CO of \" + i + \" to NH of \" + j);\n\t\t\treturn true;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * @link http://openbioinformatics.blogspot.com/\n\t * \t\t2009/08/how-to-calculate-h-atoms-for-nitrogens.html\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException {\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c, Atom o, Atom n)  {\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tprivate void buildHelices(){\n\n\t\t//Alpha-helix (i+4), 3-10-helix (i+3), Pi-helix (i+5)\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\t}\n\n\tprivate void checkSetTurns() {\n\n\t\tSecStrucType type = SecStrucType.turn;\n\n\t\tfor (int idx = 0; idx < 3; idx++) {\n\t\t\tfor (int i = 0; i < groups.length-1; i++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\t\tchar[] turn = state.getTurn();\n\n\t\t\t\t//Any turn opening matters\n\t\t\t\tif (turn[idx] == '>' || turn[idx] == 'X') {\n\t\t\t\t\t//Mark following n residues as turn\n\t\t\t\t\tfor (int k=1; k<idx+3; k++){\n\t\t\t\t\t\tsetSecStrucType(i+k, type);\n\t\t\t\t\t}\n\t\t\t\t\tif (!DSSP_HELICES) {\n\t\t\t\t\t\tsetSecStrucType(i, type);\n\t\t\t\t\t\tsetSecStrucType(i+idx+3, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A minimal helix is defined by two consecutive n-turns.\n\t * For example, a 4-helix, of minimal length 4 from residues\n\t * i to (i+3), requires turns (of type 4) at residues (i-1) and i.\n\t * <p>\n\t * Note that the orignal DSSP implementation does not assign\n\t * helix type to residue (i-1) and residue (i+n+1), although\n\t * they contain a helix turn. As they state in the original paper,\n\t * \"the helices are one residue shorter than they would be according\n\t * to rule 6.3 of IUPAC-IUB\".\n\t *\n\t * @param n\n\t * @param type\n\t */\n\tprivate void checkSetHelix(int n, SecStrucType type){\n\n\t\tint idx = n - 3;\n\t\tlogger.debug(\"Set helix \" + type + \" \" + n + \" \" + idx);\n\n\t\tfor (int i = 1; i < groups.length-n; i++) {\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tSecStrucState previousState = getSecStrucState(i-1);\n\n\t\t\t//Check that no other helix was assgined to this range\n\t\t\tif (state.getType().compareTo(type) < 0) continue;\n\t\t\tif (getSecStrucState(i+1).getType().compareTo(type) < 0) continue;\n\n\t\t\tchar turn = state.getTurn()[idx];\n\t\t\tchar pturn = previousState.getTurn()[idx];\n\n\t\t\t//Two consecutive n-turns present to define a n-helix\n\t\t\tif ((turn=='>' || turn=='X') && (pturn=='>' || pturn=='X')) {\n\t\t\t\t//Mark following n residues as turn\n\t\t\t\tfor (int k=0; k<n; k++){\n\t\t\t\t\tsetSecStrucType(i+k, type);\n\t\t\t\t}\n\t\t\t\tif (!DSSP_HELICES) {\n\t\t\t\t\tsetSecStrucType(i-1, type);\n\t\t\t\t\tsetSecStrucType(i+n, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the new type only if it has more preference than the\n\t * current residue SS type.\n\t * @param pos\n\t * @param type\n\t */\n\tprivate void setSecStrucType(int pos, SecStrucType type){\n\t\tSecStrucState ss = getSecStrucState(pos);\n\t\tif (type.compareTo(ss.getType()) < 0) ss.setType(type);\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(Group.SEC_STRUC);\n\t\treturn state;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.AtomContact;\nimport org.biojava.nbio.structure.contact.AtomContactSet;\nimport org.biojava.nbio.structure.contact.Grid;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Calculate and assign the secondary structure (SS) to the\n * Groups of a Structure object. This object also stores the result\n * of the calculation.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * Original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>.\n * Some parts are also taken from: T.E.Creighton, Proteins -\n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n *\n * @author Andreas Prlic\n * @author Aleix Lafita\n * @autho Anthony Bradley\n *\n */\npublic class SecStrucCalc {\n\n\t/**\n\t * DSSP assigns helices one residue shorter at each end, because the\n\t * residues at (i-1) and (i+n+1) are not assigned helix type although\n\t * they contain a consistent turn (H-bond). If this parameter\n\t * is true, the helices will be the length of the original DSSP\n\t * convention. If it is false, they will be two residue longer.\n\t */\n\tprivate static final boolean DSSP_HELICES = true;\n\n\tprivate static final Logger logger =\n\t\t\tLoggerFactory.getLogger(SecStrucCalc.class);\n\n\t/** min distance between two residues */\n\tpublic static final double MINDIST = 0.5;\n\n\t/** min distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static final double CA_MIN_DIST = 9.0;\n\n\t/** max distance CA atoms in peptide bond (backbone discontinuity) */\n\tpublic static final double MAX_PEPTIDE_BOND_LENGTH = 2.5;\n\n\t/** Minimal H-bond energy in cal/mol */\n\tpublic static final int HBONDLOWENERGY  = -9900;\n\n\t/** higher limit for H-bond energy */\n\tpublic static final double HBONDHIGHENERGY = -500.0;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t *      f  *  q1 *   q2  *  scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\tpublic static final double Q = -27888.0;\n\n\t// Three lists\n\tprivate SecStrucGroup[] groups;\n\tprivate List<Ladder> ladders;\n\tprivate List<BetaBridge> bridges;\n\tprivate Atom[] atoms;\n\t// Added by Anthony - to speed up intergroup calculations\n\tprivate AtomContactSet contactSet;\n\tprivate Map<String, Integer> indResMap;\n\tpublic SecStrucCalc(){\n\t\tladders = new ArrayList<Ladder>();\n\t\tbridges = new ArrayList<BetaBridge>();\n\t}\n\n\n\t/**\n\t * Predicts the secondary structure of this Structure object,\n\t * using a DSSP implementation.\n\t *\n\t * @param s Structure to predict the SS\n\t * @param assign sets the SS information to the Groups of s\n\t * @return a List of SS annotation objects\n\t */\n\tpublic List<SecStrucState> calculate(Structure s, boolean assign)\n\t\t\tthrows StructureException {\n\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\tfor(int i=0; i<s.nrModels(); i++) {\n\t\t\t// Reinitialise the global vars\n\t\t\tladders = new ArrayList<Ladder>();\n\t\t\tbridges = new ArrayList<BetaBridge>();\n\t\t\tgroups = initGroupArray(s, i);\n\t\t\t// Initialise the contact set for this structure\n\t\t\tinitContactSet();\n\t\t\tif (groups.length < 5) {\n\t\t\t\t// not enough groups to do anything\n\t\t\t\tthrow new StructureException(\"Not enough backbone groups in the\"\n\t\t\t\t\t\t+ \" Structure to calculate the secondary structure (\"\n\t\t\t\t\t\t+ groups.length+\" given, minimum 5)\" );\n\t\t\t}\n\n\t\t\tcalculateHAtoms();\n\t\t\tcalculateHBonds();\n\t\t\tcalculateDihedralAngles();\n\t\t\tcalculateTurns();\n\t\t\tbuildHelices();\n\t\t\tdetectBends();\n\t\t\tdetectStrands();\n\n\t\t\tfor (SecStrucGroup sg : groups){\n\t\t\t\tSecStrucState ss = (SecStrucState)\n\t\t\t\t\t\tsg.getProperty(Group.SEC_STRUC);\n\t\t\t\t// Add to return list and assign to original if flag is true\n\t\t\t\tsecstruc.add(ss);\n\t\t\t\tif (assign) sg.getOriginal().setProperty(Group.SEC_STRUC, ss);\n\t\t\t}\n\t\t}\n\t\treturn secstruc;\n\t}\n\n\t/**\n\t * Function to generate the contact sets\n\t */\n\tprivate void initContactSet() {\n\n\t\t// Initialise an array of atoms\n\t\tatoms = new Atom[groups.length];\n\t\t// Remake this local var\n\t\tindResMap = new HashMap<String, Integer>();\n\t\tfor (int i=0 ; i < groups.length ; i++){\n\t\t\tSecStrucGroup one = groups[i];\n\t\t\tindResMap.put(one.getResidueNumber().getChainName()+one.getResidueNumber().getSeqNum(), i);\n\t\t\tatoms[i] = one.getCA();\n\t\t}\n\t\tGrid grid = new Grid(CA_MIN_DIST);\n\t\tif(atoms.length==0){\n\t\t\tcontactSet = new AtomContactSet(CA_MIN_DIST);\n\t\t}\n\t\telse{\n\t\t\tgrid.addAtoms(atoms);\n\t\t\tcontactSet = grid.getAtomContacts();\n\t\t}\n\t}\n\n\t/**\n\t * Updated code to detect strands\n\t */\n\tprivate void detectStrands() {\n\n\t\t//Find all the beta bridges of the structure\n\t\tfindBridges();\n\t\t//Create Ladders\n\t\tcreateLadders();\n\n\t\t//Detect beta bulges between ladders\n\t\tconnectLadders();\n\n\t\t//AND store SS assignments for Sheets, Strands and Bridges\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void createLadders(){\n\n\t\tfor (BetaBridge b : bridges){\n\t\t\tboolean found = false;\n\t\t\tfor (Ladder ladder : ladders){\n\t\t\t\tif (shouldExtendLadder(ladder, b)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tladder.to++; //we go forward in this direction\n\t\t\t\t\tswitch(b.type){\n\t\t\t\t\tcase parallel:\n\t\t\t\t\t\tladder.lto++; //increment second strand\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase antiparallel:\n\t\t\t\t\t\tladder.lfrom--; //decrement second strand\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found){\n\t\t\t\t//Create new ladder with a single Bridge\n\t\t\t\tLadder l = new Ladder();\n\t\t\t\tl.from = b.partner1;\n\t\t\t\tl.to = b.partner1;\n\t\t\t\tl.lfrom = b.partner2;\n\t\t\t\tl.lto = b.partner2;\n\t\t\t\tl.btype = b.type;\n\t\t\t\tladders.add(l);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tprivate void updateSheets() {\n\n\t\tlogger.debug(\" got \" +ladders.size() + \"  ladders!\");\n\n\t\tfor (Ladder ladder : ladders){\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor (int lcount = ladder.from; lcount <= ladder.to; lcount++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getType();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getType();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t\tsetSecStrucType(l2count, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( !stype.isHelixType() &&\n\t\t\t\t\t\t\t( !stype.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'\n\n\t\t\tif (ladder.connectedTo == 0) continue;\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif (ladder.btype.equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor (int lcount = ladder.from; lcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor (int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size(); j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif (hasBulge(l1,l2)) {\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\tlogger.debug(\"Bulge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\t/**\n\t * For beta structures, we define explicitly: a bulge-linked\n\t * ladder consists of two (perfect) ladder or bridges of the\n\t * same type connected by at most one extra residue on one\n\t * strand and at most four extra residues on the other strand,\n\t * all residues in bulge-linked ladders are marked \"E,\"\n\t * including the extra residues.\n\t */\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\n\t\tboolean bulge = ((l1.btype.equals(l2.btype)) &&\n\t\t\t\t(l2.from - l1.to < 6) &&\n\t\t\t\t(l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0));\n\n\t\tif (!bulge) return bulge;\n\n\t\tswitch(l1.btype){\n\t\tcase parallel:\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\n\t\t\tbreak;\n\n\t\tcase antiparallel:\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3)));\n\n\t\t\tbreak;\n\t\t}\n\n\t\treturn bulge;\n\t}\n\n\tprivate void registerBridge(int i, int j, BridgeType btype) {\n\n\t\tBetaBridge bridge = new BetaBridge(i,j,btype);\n\n\t\tboolean b1 = getSecStrucState(i).addBridge(bridge);\n\t\tboolean b2 = getSecStrucState(j).addBridge(bridge);\n\n\t\tif (!b1 && !b2)\n\t\t\tlogger.warn(\"Ignoring Bridge between residues\" + i + \" and \" + j\n\t\t\t\t\t+ \". DSSP assignment might differ.\");\n\n\t\tbridges.add(bridge);\n\t}\n\n\t/**\n\t * Conditions to extend a ladder with a given beta Bridge:\n\t * <li>The bridge and ladder are of the same type.\n\t * <li>The smallest bridge residue is sequential to the first\n\t * \t\tstrand ladder.\n\t * <li>The second bridge residue is either sequential (parallel)\n\t * \t\tor previous (antiparallel) to the second strand of the ladder\n\t * </li>\n\t * @param ladder the ladder candidate to extend\n\t * @param b the beta bridge that would extend the ladder\n\t * @return true if the bridge b extends the ladder\n\t */\n\tprivate boolean shouldExtendLadder(Ladder ladder, BetaBridge b) {\n\n\t\t//Only extend if they are of the same type\n\t\tboolean sameType = b.type.equals(ladder.btype);\n\t\tif (!sameType) return false;\n\n\t\t//Only extend if residue 1 is sequential to ladder strand\n\t\tboolean sequential = (b.partner1 == ladder.to+1);\n\t\tif (!sequential) return false;\n\n\t\tswitch(b.type){\n\t\tcase parallel:\n\t\t\t//Residue 2 should be sequential to second strand\n\t\t\tif (b.partner2 == ladder.lto+1) return true;\n\t\t\tbreak;\n\t\tcase antiparallel:\n\t\t\t//Residue 2 should be previous to second strand\n\t\t\tif (b.partner2 == ladder.lfrom-1) return true;\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\n\t/**\n\t * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and\n\t * j-1,j,j+1, form either a parallel or antiparallel bridge, depending on\n\t * which of two basic patterns is matched. We assign a bridge between\n\t * residues i and j if there are two H bonds characteristic of beta-\n\t * structure; in particular:\n\t * <p>\n\t * Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)]\n\t * \t\t\t\t\t\t\tor [Hbond(j-1,i) and Hbond(i,j+1)]\n\t * <p>\n\t * Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)]\n\t * \t\t\t\t\t\t\t\tor [Hbond(i-1,j+1) and Hbond(j-1,i+1)]\n\t *\n\t * Optimised to use the contact set\n\t */\n\tprivate void findBridges() {\n\t\t// Get the interator of contacts\n\t\tIterator<AtomContact> myIter = contactSet.iterator();\n\t\tList<Pair<Integer>> outList = new ArrayList<Pair<Integer>>();\n\n\t\t// Now iterate through this\n\t\twhile(myIter.hasNext()){\n\t\t\t// Get the next atom contact\n\t\t\tAtomContact ac = myIter.next();\n\t\t\tGroup g1 = ac.getPair().getFirst().getGroup();\n\t\t\tGroup g2 = ac.getPair().getSecond().getGroup();\n\t\t\t// Get the indices\n\t\t\tint i = indResMap.get(g1.getResidueNumber().getChainName()+g1.getResidueNumber().getSeqNum());\n\t\t\tint j = indResMap.get(g2.getResidueNumber().getChainName()+g2.getResidueNumber().getSeqNum());\n\t\t\t// If i>j switch them over\n\t\t\tif(i>j){\n\t\t\t\t// Switch them over\n\t\t\t\tint old = i;\n\t\t\t\ti = j;\n\t\t\t\tj = old;\n\t\t\t}\n\t\t\t// Only these\n\t\t\tif(j<i+3){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If it's the first\n\t\t\tif(i==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// If it's the last\n\t\t\tif(i==groups.length-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(j==groups.length-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPair<Integer> thisPair = new Pair<Integer>(i,j);\n\t\t\toutList.add(thisPair);\n\t\t}\n\t\t//\n\t\tCollections.sort(outList, new Comparator<Pair<Integer>>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Pair<Integer> o1, Pair<Integer> o2) {\n\t\t\t\tif(o1.getFirst()<o2.getFirst()){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if(o1.getFirst()>o2.getFirst()){\n\t\t\t\t\treturn +1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(o1.getSecond()<o2.getSecond()){\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(o1.getSecond()>o2.getSecond()){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\n\n\t\tfor(Pair<Integer> p: outList){\n\t\t\tint i = p.getFirst();\n\t\t\tint j = p.getSecond();\n\t\t\tBridgeType btype = null;\n\t\t\t// Now do the bonding\n\t\t\tif ((isBonded(i-1,j) && isBonded(j,i+1)) ||\n\t\t\t\t\t(isBonded(j-1,i) && isBonded(i,j+1))) {\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ((isBonded(i,j) && isBonded(j,i)) ||\n\t\t\t\t\t(isBonded(i-1,j+1) && (isBonded(j-1,i+1)))) {\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tregisterBridge(i, j, btype);\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate void detectBends() {\n\n\t\tfor (int i = 2 ; i < groups.length-2 ;i++){\n\n\t\t\t//Check if all atoms form peptide bonds (backbone discontinuity)\n\t\t\tboolean bonded = true;\n\t\t\tfor (int k=0; k<4; k++){\n\t\t\t\tint index = i+k-2;\n\t\t\t\tAtom C = groups[index].getC();\n\t\t\t\tAtom N = groups[index+1].getN();\n\t\t\t\t//Peptide bond C-N\n\t\t\t\tif (Calc.getDistance(C, N) > MAX_PEPTIDE_BOND_LENGTH){\n\t\t\t\t\tbonded = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bonded) continue;\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\t//Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i + 2 )\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle = Calc.angle(caminus2, caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tstate.setKappa((float) angle);\n\n\t\t\t//Angles = 360 should be discarded\n\t\t\tif (angle > 70.0 && angle < 359.99) {\n\t\t\t\tsetSecStrucType(i, SecStrucType.bend);\n\t\t\t\tstate.setBend(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles()  {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState)\n\t\t\t\t\ta.getProperty(Group.SEC_STRUC);\n\t\t\tSecStrucState state2 = (SecStrucState)\n\t\t\t\t\tb.getProperty(Group.SEC_STRUC);\n\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn printDSSP();\n\t}\n\n\t/**\n\t * Generate a DSSP file format ouput String of this SS prediction.\n\t * @return String in DSSP output file format\n\t */\n\tpublic String printDSSP() {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\n\t\t//Header Line\n\t\tbuf.append(\"==== Secondary Structure Definition by BioJava\"\n\t\t\t\t+ \" DSSP implementation, Version October 2015 ====\"+nl);\n\n\t\t//First line with column definition\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     \"\n\t\t\t\t+ \"N-H-->O    O-->H-N    N-H-->O    O-->H-N    \"\n\t\t\t\t+ \"TCO  KAPPA ALPHA  PHI    PSI    \"\n\t\t\t\t+ \"X-CA   Y-CA   Z-CA \");\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tbuf.append(nl);\n\t\t\tSecStrucState ss = getSecStrucState(i);\n\t\t\tbuf.append(ss.printDSSPline(i));\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\n\t/**\n\t * Generate a summary of this SS prediction with information about\n\t * the three types of helix turns in different row sequences.\n\t * <p>\n\t * This is similar to the summary output of Jmol, and useful to visualize\n\t * the helix patterns.\n\t *\n\t * @return String helix summary\n\t */\n\tpublic String printHelixSummary() {\n\n\t\tStringBuffer g = new StringBuffer(); //3-10 helix\n\t\tStringBuffer h = new StringBuffer(); //alpha helix\n\t\tStringBuffer i = new StringBuffer(); //pi-helix\n\t\tStringBuffer ss = new StringBuffer(); //SS summary\n\t\tStringBuffer aa = new StringBuffer(); //AA one-letter\n\t\tString nl = System.getProperty(\"line.separator\");\n\n\t\tg.append(\t\"3 turn: \");\n\t\th.append(\t\"4 turn: \");\n\t\ti.append(\t\"5 turn: \");\n\t\tss.append(\t\"SS:     \");\n\t\taa.append(\t\"AA:     \");\n\n\t\tfor (int k = 0; k < groups.length; k++){\n\n\t\t\tSecStrucState state = getSecStrucState(k);\n\t\t\tg.append(state.getTurn()[0]);\n\t\t\th.append(state.getTurn()[1]);\n\t\t\ti.append(state.getTurn()[2]);\n\t\t\tss.append(state.getType());\n\t\t\taa.append(StructureTools.get1LetterCode(groups[k].getPDBName()));\n\t\t}\n\n\t\treturn g.toString()+nl+h.toString()+nl+\n\t\t\t\ti.toString()+nl+ss.toString()+nl+aa.toString();\n\t}\n\n\t/**\n\t * Generate a FASTA sequence with the SS annotation letters in the\n\t * aminoacid sequence order.\n\t * @return String in FASTA sequence format\n\t */\n\tpublic String printFASTA() {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\tbuf.append(\">\"+groups[0].getChain().getStructure().getIdentifier()+nl);\n\n\t\tfor (int g = 0; g < groups.length; g++){\n\t\t\tbuf.append(getSecStrucState(g).getType());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t    final int prime = 31;\n\t    int result = 1;\n\t    result = prime * result + Arrays.hashCode(atoms);\n\t    return result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o){\n\n\t\tif (!(o instanceof SecStrucCalc)) return false;\n\t\telse {\n\t\t\tSecStrucCalc ss = (SecStrucCalc) o;\n\t\t\tif (groups.length != ss.groups.length) return false;\n\n\t\t\tfor (int g=0; g<groups.length; g++){\n\t\t\t\tSecStrucInfo g1 = getSecStrucState(g);\n\t\t\t\tSecStrucInfo g2 = ss.getSecStrucState(g);\n\t\t\t\tif (!g1.equals(g2)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s, int modelId) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t// \n\t\tfor ( Chain c : s.getChains(modelId)){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\n\t\t\t\t//We can also calc secstruc if it is a modified amino acid\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\n\t\t\t\t\tSecStrucState state = new SecStrucState(sg,\n\t\t\t\t\t\t\tSecStrucInfo.BIOJAVA_ASSIGNMENT,\n\t\t\t\t\t\t\tSecStrucType.coil);\n\n\t\t\t\t\tsg.setProperty(Group.SEC_STRUC, state);\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/**\n\t * Calculate the coordinates of the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location.\n\t */\n\tprivate void calculateHAtoms() throws StructureException {\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( !b.hasAtom(\"H\") ) {\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(), b.getN());\n\t\t\t\tb.setH(H);\n\t\t\t}\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Calculate the HBonds between different groups.\n\t * see Creighton page 147 f\n\t * Modified to use only the contact map\n\t */\n\tprivate void calculateHBonds() {\n\t\t/**\n\t\t * More efficient method for calculating C-Alpha pairs\n\t\t */\n\t\tif (groups.length < 5) return;\n\t\tIterator<AtomContact> otu = contactSet.iterator();\n\t\twhile(otu.hasNext()){\n\t\t\tAtomContact ac = otu.next();\n\t\t\tPair<Atom> pair = ac.getPair();\n\t\t\tGroup g1 = pair.getFirst().getGroup();\n\t\t\tGroup g2 = pair.getSecond().getGroup();\n\t\t\t// Now I need to get the index of the Group in the list groups\n\t\t\tint i = indResMap.get(g1.getResidueNumber().getChainName()+g1.getResidueNumber().getSeqNum());\n\t\t\tint j = indResMap.get(g2.getResidueNumber().getChainName()+g2.getResidueNumber().getSeqNum());\n\t\t\t// Now check this\n\t\t\tcheckAddHBond(i,j);\n\t\t\t//\"backwards\" hbonds are not allowed\n\t\t\tif (j!=(i+1)) checkAddHBond(j,i);\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\t\tif (!one.hasAtom(\"H\")) {\n\t\t\tlogger.debug(\"Residue \"+one.getResidueNumber()+\" has no H\");\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\n\t\tdouble energy = 0;\n\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\tlogger.warn(\"Energy calculation failed\", e);\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug(\"Energy between positions (\"+i+\",\"+j+\"): \"+energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/**\n\t * Calculate HBond energy of two groups in cal/mol\n\t * see Creighton page 147 f\n\t * <p>\n\t * Jeffrey, George A., An introduction to hydrogen bonding,\n\t * Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t * Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t */\n\tprivate static double calculateHBondEnergy(SecStrucGroup one,\n\t\t\tSecStrucGroup two) {\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber() +\n\t\t\t\t\" \" + one.getPDBName() + \" \" +two.getResidueNumber()+\n\t\t\t\t\" \" + two.getPDBName() + String.format(\" O (\"+\n\t\t\t\t\t\tO.getPDBserial()+\")..N (\"+ N.getPDBserial()+\n\t\t\t\t\t\t\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \",\n\t\t\t\t\t\tdno,dho,dhc,dnc,dno));\n\n\t\t//there seems to be a contact!\n\t\tif ( (dno < MINDIST) || (dhc < MINDIST) ||\n\t\t\t\t(dnc < MINDIST) || (dno < MINDIST)) {\n\t\t\treturn HBONDLOWENERGY;\n\t\t}\n\n\t\tdouble e1 = Q / dho - Q / dhc;\n\t\tdouble e2 = Q / dnc - Q / dno;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",\n\t\t\t\tN.getPDBserial(),O.getPDBserial(), (float) dno, energy));\n\n\t\t//Avoid too strong energy\n\t\tif (energy > HBONDLOWENERGY) return energy;\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * Store Hbonds in the Groups.\n\t * DSSP allows two HBonds per aminoacids to allow bifurcated bonds.\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tif (groups[i].getPDBName().equals(\"PRO\")) {\n\t\t\tlogger.debug(\"Ignore: PRO \" + groups[i].getResidueNumber());\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucState stateOne = getSecStrucState(i);\n\t\tSecStrucState stateTwo = getSecStrucState(j);\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\t//Acceptor: N-H-->O\n\t\tif (energy < acc1e) {\n\t\t\tlogger.debug(energy +\"<\"+acc1e);\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\tlogger.debug(energy +\"<\"+acc2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\n\t\t//The other side of the bond: donor O-->N-H\n\t\tif (energy <  don1e) {\n\t\t\tlogger.debug(energy +\"<\"+don1e);\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\t\t\tlogger.debug(energy +\"<\"+don2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\t\t}\n\t}\n\n\t/**\n\t * Detect helical turn patterns.\n\t */\n\tprivate void calculateTurns(){\n\n\t\tfor (int i = 0 ; i< groups.length; i++){\n\t\t\tfor (int turn = 3; turn <= 5; turn++) {\n\n\t\t\t\tif (i+turn >= groups.length) continue;\n\n\t\t\t\t//Check for H bond from NH(i+n) to CO(i)\n\t\t\t\tif (isBonded(i, i+turn)) {\n\t\t\t\t\tlogger.debug(\"Turn at (\"+i+\",\"+(i+turn)+\") turn \"+turn);\n\t\t\t\t\tgetSecStrucState(i).setTurn('>', turn);\n\t\t\t\t\tgetSecStrucState(i+turn).setTurn('<', turn);\n\t\t\t\t\t//Bracketed residues get the helix number\n\t\t\t\t\tfor (int j=i+1; j<i+turn; j++){\n\t\t\t\t\t\tInteger t = turn;\n\t\t\t\t\t\tchar helix = t.toString().charAt(0);\n\t\t\t\t\t\tgetSecStrucState(j).setTurn(helix, turn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Test if two groups are forming an H-Bond. The bond tested is\n\t * from the CO of group i to the NH of group j. Acceptor (i) and\n\t * donor (j). The donor of i has to be j, and the acceptor of j\n\t * has to be i.\n\t * DSSP defines H-Bonds if the energy < -500 cal/mol.\n\t *\n\t * @param i group one\n\t * @param j group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tSecStrucState one = getSecStrucState(i);\n\t\tSecStrucState two = getSecStrucState(j);\n\n\t\tdouble don1e = one.getDonor1().getEnergy();\n\t\tdouble don2e = one.getDonor2().getEnergy();\n\t\tdouble acc1e = two.getAccept1().getEnergy();\n\t\tdouble acc2e = two.getAccept2().getEnergy();\n\n\t\tint don1p = one.getDonor1().getPartner();\n\t\tint don2p = one.getDonor2().getPartner();\n\t\tint acc1p = two.getAccept1().getPartner();\n\t\tint acc2p = two.getAccept2().getPartner();\n\n\t\t//Either donor from i is j, or accept from j is i\n\t\tboolean hbond = (don1p == j && don1e < HBONDHIGHENERGY) ||\n\t\t\t\t(don2p == j && don2e < HBONDHIGHENERGY) ||\n\t\t\t\t(acc1p == i && acc1e < HBONDHIGHENERGY) ||\n\t\t\t\t(acc2p == i && acc2e < HBONDHIGHENERGY);\n\n\t\tif (hbond){\n\t\t\tlogger.debug(\"*** H-bond from CO of \" + i + \" to NH of \" + j);\n\t\t\treturn true;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * @link http://openbioinformatics.blogspot.com/\n\t * \t\t2009/08/how-to-calculate-h-atoms-for-nitrogens.html\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException {\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c, Atom o, Atom n)  {\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tprivate void buildHelices(){\n\n\t\t//Alpha-helix (i+4), 3-10-helix (i+3), Pi-helix (i+5)\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\t}\n\n\tprivate void checkSetTurns() {\n\n\t\tSecStrucType type = SecStrucType.turn;\n\n\t\tfor (int idx = 0; idx < 3; idx++) {\n\t\t\tfor (int i = 0; i < groups.length-1; i++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\t\tchar[] turn = state.getTurn();\n\n\t\t\t\t//Any turn opening matters\n\t\t\t\tif (turn[idx] == '>' || turn[idx] == 'X') {\n\t\t\t\t\t//Mark following n residues as turn\n\t\t\t\t\tfor (int k=1; k<idx+3; k++){\n\t\t\t\t\t\tsetSecStrucType(i+k, type);\n\t\t\t\t\t}\n\t\t\t\t\tif (!DSSP_HELICES) {\n\t\t\t\t\t\tsetSecStrucType(i, type);\n\t\t\t\t\t\tsetSecStrucType(i+idx+3, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A minimal helix is defined by two consecutive n-turns.\n\t * For example, a 4-helix, of minimal length 4 from residues\n\t * i to (i+3), requires turns (of type 4) at residues (i-1) and i.\n\t * <p>\n\t * Note that the orignal DSSP implementation does not assign\n\t * helix type to residue (i-1) and residue (i+n+1), although\n\t * they contain a helix turn. As they state in the original paper,\n\t * \"the helices are one residue shorter than they would be according\n\t * to rule 6.3 of IUPAC-IUB\".\n\t *\n\t * @param n\n\t * @param type\n\t */\n\tprivate void checkSetHelix(int n, SecStrucType type){\n\n\t\tint idx = n - 3;\n\t\tlogger.debug(\"Set helix \" + type + \" \" + n + \" \" + idx);\n\n\t\tfor (int i = 1; i < groups.length-n; i++) {\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tSecStrucState previousState = getSecStrucState(i-1);\n\n\t\t\t//Check that no other helix was assgined to this range\n\t\t\tif (state.getType().compareTo(type) < 0) continue;\n\t\t\tif (getSecStrucState(i+1).getType().compareTo(type) < 0) continue;\n\n\t\t\tchar turn = state.getTurn()[idx];\n\t\t\tchar pturn = previousState.getTurn()[idx];\n\n\t\t\t//Two consecutive n-turns present to define a n-helix\n\t\t\tif ((turn=='>' || turn=='X') && (pturn=='>' || pturn=='X')) {\n\t\t\t\t//Mark following n residues as turn\n\t\t\t\tfor (int k=0; k<n; k++){\n\t\t\t\t\tsetSecStrucType(i+k, type);\n\t\t\t\t}\n\t\t\t\tif (!DSSP_HELICES) {\n\t\t\t\t\tsetSecStrucType(i-1, type);\n\t\t\t\t\tsetSecStrucType(i+n, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Set the new type only if it has more preference than the\n\t * current residue SS type.\n\t * @param pos\n\t * @param type\n\t */\n\tprivate void setSecStrucType(int pos, SecStrucType type){\n\t\tSecStrucState ss = getSecStrucState(pos);\n\t\tif (type.compareTo(ss.getType()) < 0) ss.setType(type);\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(Group.SEC_STRUC);\n\t\treturn state;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of the DSSP implementation in BioJava\n * for the calculation of secondary structure in a Structure object.\n *\n * EXAMPLES:\n * \t\t\tBig structures: 4v7r, 4V60 (use mmCif parser)\n * \t\t\tHelical: 4hhb, 4lup\n * \t\t\tMixed small: 5pti\n * \t\t\tFirst sheet: 1ze3, 3k19\n * \t\t\tInsertion code: 1how\n *          More than 2 Beta-Bridges: 2k4t\n *\n * @author Aleix Lafita\n *\n */\npublic class TestSecStrucCalc {\n\n\t@Test\n\tpublic void testSecStrucPred() throws StructureException, IOException {\n\n\t\t//List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\n\t\t\t\t\"5pti\", \"1tim\", \"4hhb\", \"1how\", \"4i4q\", \"2k4t\");\n\t\tSecStrucCalc sec = new SecStrucCalc();\n\t\t//Predict with BioJava the SS -> Anthony has moved this out of the loop.\n\t\t//SecStrucCalc does not need to be reinitialised every time\n\t\tfor (String name : names) {\n\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tStructure structure = cache.getStructure(name);\n\n\n\t\t\tList<SecStrucState> biojava = sec.calculate(structure, true);\n\n\t\t\t//Download the original DSSP implementation output\n\t\t\tList<SecStrucState> dssp = DSSPParser.fetch(name, structure, false);\n\n\t\t\tassertEquals(\"SS assignment lengths do not match\",\n\t\t\t\t\tbiojava.size(), dssp.size()*structure.nrModels());\n\n\t\t\tfor (int i=0; i<dssp.size(); i++){\n\t\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\",\n\t\t\t\t\t\tbiojava.get(i), dssp.get(i));\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t/**\n\t * Test that calculating the secondary structure for multi-model systems works.\n\t * Combine two PDBs into one multi-model system\n\t * Calculate the secondary structure\n\t * Combine with the combined list fetching from the server\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testMultiModelPred() throws StructureException, IOException {\n\n\t\tString pdbId = \"5pti\";\n\t\tString pdbIdTwo = \"4hhb\";\n\t\tSecStrucCalc sec = new SecStrucCalc();\n\t\t// Combine these into one structure with two models\n\t\tAtomCache cache = new AtomCache();\n\t\tStructure structure = cache.getStructure(pdbId);\n\t\tStructure structureTwo = cache.getStructure(pdbIdTwo);\n\t\t// Join them together\n\t\tstructure.addModel(structureTwo.getChains());\n\t\t\n\t\tList<SecStrucState> biojava = sec.calculate(structure, true);\n\n\t\t// Download the original DSSP implementation output\n\t\tList<SecStrucState> dssp = DSSPParser.fetch(pdbId,cache.getStructure(pdbId), false);\n\t\tdssp.addAll(DSSPParser.fetch(pdbIdTwo, cache.getStructure(pdbIdTwo), false));\n\t\t\n\t\tassertEquals(\"SS assignment lengths do not match\",\n\t\t\t\tbiojava.size(), dssp.size());\n\n\t\tfor (int i=0; i<dssp.size(); i++){\n\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\",\n\t\t\t\t\tbiojava.get(i), dssp.get(i));\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Some more work towards #545, some cleanup","test_commitMessage":"","allZero":false}