{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/alignment/SimpleSequencePair.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/alignment/SimpleSequencePairTest.java","prod_time":"2016-06-27 20:47:42","test_time":"2016-06-27 20:47:42","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":11,"add_classname_line":2,"add_condition_line":4,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":4,"add_return_line":3,"del_annotation_line":0,"del_call_line":5,"del_classname_line":2,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":3,"label":"POSITIVE","prod_commitID":"3722ce5573d167e6b42f9f5748a00fbd545c6b28","test_commitID":"3722ce5573d167e6b42f9f5748a00fbd545c6b28","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.SequencePair;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.util.List;\n\n/**\n * Implements a data structure for the results of pairwise sequence alignment.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleSequencePair<S extends Sequence<C>, C extends Compound> extends SimpleProfile<S, C>\nimplements SequencePair<S, C> {\n\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate int identicals = -1, similars = -1;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @throws IllegalArgumentException if sequences differ in size\n\t */\n\tpublic SimpleSequencePair(AlignedSequence<S, C> query, AlignedSequence<S, C> target) {\n\t\tsuper(query, target);\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences with a global alignment.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tpublic SimpleSequencePair(S query, S target, List<Step> sx, List<Step> sy) {\n\t\tthis(query, target, sx, 0, 0, sy, 0, 0);\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences with a local alignment.\n\t *\n\t * @param query the first sequence of the pair\n\t * @param target the second sequence of the pair\n\t * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param xb number of {@link Compound}s skipped in the query sequence before the aligned region\n\t * @param xa number of {@link Compound}s skipped in the query sequence after the aligned region\n\t * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param yb number of {@link Compound}s skipped in the target sequence before the aligned region\n\t * @param ya number of {@link Compound}s skipped in the target sequence after the aligned region\n\t * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n\t */\n\tpublic SimpleSequencePair(S query, S target, List<Step> sx, int xb, int xa, List<Step> sy, int yb, int ya) {\n\t\tsuper(query, target, sx, xb, xa, sy, yb, ya);\n\t}\n\n\t@Override\n\tpublic C getCompoundInQueryAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(1).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundInTargetAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(2).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInQueryAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(1).getSequenceIndexAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInQueryForTargetAt(int targetIndex) {\n\t\treturn getAlignedSequence(1).getSequenceIndexAt(getAlignedSequence(2).getAlignmentIndexAt(targetIndex));\n\t}\n\n\t@Override\n\tpublic int getIndexInTargetAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(2).getSequenceIndexAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInTargetForQueryAt(int queryIndex) {\n\t\treturn getAlignedSequence(2).getSequenceIndexAt(getAlignedSequence(1).getAlignmentIndexAt(queryIndex));\n\t}\n\n\t@Override\n\tpublic int getNumIdenticals() {\n\t\tif (identicals == -1) {\n\t\t\tidenticals = 0;\n\t\t\tfor (int i = 1; i <= getLength(); i++) {\n\t\t\t\tif (getCompoundInQueryAt(i).equalsIgnoreCase(getCompoundInTargetAt(i))) {\n\t\t\t\t\tidenticals++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetQuery().clearCache();\n\t\t\tgetTarget().clearCache();\n\t\t}\n\t\treturn identicals;\n\t}\n\n\t@Override\n\tpublic int getNumSimilars() {\n\t\tif (similars == -1) {\n\t\t\tsimilars = 0;\n\t\t\tfor (int i = 1; i <= getLength(); i++) {\n\n\t\t\t\tC c1 = getCompoundInQueryAt(i);\n\t\t\t\tC c2 = getCompoundInTargetAt(i);\n\n\t\t\t\tif ( c1 instanceof AminoAcidCompound && c2 instanceof AminoAcidCompound) {\n\t\t\t\t\tshort value = matrix.getValue((AminoAcidCompound)c1, (AminoAcidCompound)c2);\n\t\t\t\t\tif ( value > 0)\n\t\t\t\t\t\tsimilars++;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (getCompoundSet().compoundsEquivalent(c1,c2)) {\n\t\t\t\t\t\tsimilars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetQuery().clearCache();\n\t\t\tgetTarget().clearCache();\n\t\t}\n\t\treturn similars;\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getQuery() {\n\t\treturn getAlignedSequence(1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getTarget() {\n\t\treturn getAlignedSequence(2);\n\t}\n\n\t@Override\n\tpublic double getPercentageOfIdentity() {\n\t\tdouble seqid = getNumIdenticals();\n\t\treturn seqid / getLength();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.SequencePair;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.util.List;\n\n/**\n * Implements a data structure for the results of pairwise sequence alignment.\n *\n * @author Mark Chapman\n * @author Paolo Pavan\n * @param <S>\n *            each element of the alignment {@link Profile} is of type S\n * @param <C>\n *            each element of an {@link AlignedSequence} is a {@link Compound}\n *            of type C\n */\npublic class SimpleSequencePair<S extends Sequence<C>, C extends Compound>\n\t\textends SimpleProfile<S, C> implements SequencePair<S, C> {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate int identicals = -1, similars = -1;\n\n\t/**\n\t * Creates a pair profile for the given already aligned sequences.\n\t *\n\t * @param query\n\t *            the first sequence of the pair\n\t * @param target\n\t *            the second sequence of the pair\n\t * @throws IllegalArgumentException\n\t *             if sequences differ in size\n\t */\n\tpublic SimpleSequencePair(AlignedSequence<S, C> query,\n\t\t\tAlignedSequence<S, C> target) {\n\t\tsuper(query, target);\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences with a global alignment.\n\t *\n\t * @param query\n\t *            the first sequence of the pair\n\t * @param target\n\t *            the second sequence of the pair\n\t * @param sx\n\t *            lists whether the query sequence aligns a {@link Compound} or\n\t *            gap at each index of the alignment\n\t * @param sy\n\t *            lists whether the target sequence aligns a {@link Compound} or\n\t *            gap at each index of the alignment\n\t * @throws IllegalArgumentException\n\t *             if alignments differ in size or given sequences do not fit in\n\t *             alignments\n\t */\n\tpublic SimpleSequencePair(S query, S target, List<Step> sx, List<Step> sy) {\n\t\tthis(query, target, sx, 0, 0, sy, 0, 0);\n\t}\n\n\t/**\n\t * Creates a pair profile for the given sequences with a local alignment.\n\t *\n\t * @param query\n\t *            the first sequence of the pair\n\t * @param target\n\t *            the second sequence of the pair\n\t * @param sx\n\t *            lists whether the query sequence aligns a {@link Compound} or\n\t *            gap at each index of the alignment\n\t * @param xb\n\t *            number of {@link Compound}s skipped in the query sequence\n\t *            before the aligned region\n\t * @param xa\n\t *            number of {@link Compound}s skipped in the query sequence\n\t *            after the aligned region\n\t * @param sy\n\t *            lists whether the target sequence aligns a {@link Compound} or\n\t *            gap at each index of the alignment\n\t * @param yb\n\t *            number of {@link Compound}s skipped in the target sequence\n\t *            before the aligned region\n\t * @param ya\n\t *            number of {@link Compound}s skipped in the target sequence\n\t *            after the aligned region\n\t * @throws IllegalArgumentException\n\t *             if alignments differ in size or given sequences do not fit in\n\t *             alignments\n\t */\n\tpublic SimpleSequencePair(S query, S target, List<Step> sx, int xb, int xa,\n\t\t\tList<Step> sy, int yb, int ya) {\n\t\tsuper(query, target, sx, xb, xa, sy, yb, ya);\n\t}\n\n\t@Override\n\tpublic C getCompoundInQueryAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(1).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic C getCompoundInTargetAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(2).getCompoundAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInQueryAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(1).getSequenceIndexAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInQueryForTargetAt(int targetIndex) {\n\t\treturn getAlignedSequence(1).getSequenceIndexAt(\n\t\t\t\tgetAlignedSequence(2).getAlignmentIndexAt(targetIndex));\n\t}\n\n\t@Override\n\tpublic int getIndexInTargetAt(int alignmentIndex) {\n\t\treturn getAlignedSequence(2).getSequenceIndexAt(alignmentIndex);\n\t}\n\n\t@Override\n\tpublic int getIndexInTargetForQueryAt(int queryIndex) {\n\t\treturn getAlignedSequence(2).getSequenceIndexAt(\n\t\t\t\tgetAlignedSequence(1).getAlignmentIndexAt(queryIndex));\n\t}\n\n\t@Override\n\tpublic int getNumIdenticals() {\n\t\tif (identicals == -1) {\n\t\t\tidenticals = 0;\n\t\t\tfor (int i = 1; i <= getLength(); i++) {\n\t\t\t\tif (getCompoundInQueryAt(i).equalsIgnoreCase(\n\t\t\t\t\t\tgetCompoundInTargetAt(i))) {\n\t\t\t\t\tidenticals++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetQuery().clearCache();\n\t\t\tgetTarget().clearCache();\n\t\t}\n\t\treturn identicals;\n\t}\n\n\t@Override\n\tpublic int getNumSimilars() {\n\t\tif (similars == -1) {\n\t\t\tsimilars = 0;\n\t\t\tfor (int i = 1; i <= getLength(); i++) {\n\n\t\t\t\tC c1 = getCompoundInQueryAt(i);\n\t\t\t\tC c2 = getCompoundInTargetAt(i);\n\n\t\t\t\tif (c1 instanceof AminoAcidCompound\n\t\t\t\t\t\t&& c2 instanceof AminoAcidCompound) {\n\t\t\t\t\tshort value = matrix.getValue((AminoAcidCompound) c1,\n\t\t\t\t\t\t\t(AminoAcidCompound) c2);\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\tsimilars++;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (getCompoundSet().compoundsEquivalent(c1, c2)) {\n\t\t\t\t\t\tsimilars++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetQuery().clearCache();\n\t\t\tgetTarget().clearCache();\n\t\t}\n\t\treturn similars;\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getQuery() {\n\t\treturn getAlignedSequence(1);\n\t}\n\n\t@Override\n\tpublic AlignedSequence<S, C> getTarget() {\n\t\treturn getAlignedSequence(2);\n\t}\n\n\t@Override\n\tpublic double getPercentageOfIdentity() {\n\t\tdouble seqid = getNumIdenticals();\n\t\tdouble length = getLength()\n\t\t\t\t- getAlignedSequence(1).getNumGapPositions()\n\t\t\t\t- getAlignedSequence(2).getNumGapPositions();\n\t\treturn seqid / length;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.SequencePair;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class SimpleSequencePairTest {\n\n\tprivate ProteinSequence query, target;\n\tprivate SequencePair<ProteinSequence, AminoAcidCompound> global, local;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tquery = new ProteinSequence(\"ARND\");\n\t\ttarget = new ProteinSequence(\"RDG\");\n\t\tglobal = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), Arrays.asList(new Step[] {\n\t\t\t\tStep.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n\t\tlocal = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n\t\t\t\tStep.GAP, Step.COMPOUND}), 0, 1);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundInQueryAt() {\n\t\tassertEquals(global.getCompoundInQueryAt(1).getShortName(), \"A\");\n\t\tassertEquals(global.getCompoundInQueryAt(2).getShortName(), \"R\");\n\t\tassertEquals(global.getCompoundInQueryAt(3).getShortName(), \"N\");\n\t\tassertEquals(global.getCompoundInQueryAt(4).getShortName(), \"D\");\n\t\tassertEquals(global.getCompoundInQueryAt(5).getShortName(), \"-\");\n\t\tassertEquals(local.getCompoundInQueryAt(1).getShortName(), \"R\");\n\t\tassertEquals(local.getCompoundInQueryAt(2).getShortName(), \"N\");\n\t\tassertEquals(local.getCompoundInQueryAt(3).getShortName(), \"D\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds() {\n\t\tglobal.getCompoundInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds2() {\n\t\tglobal.getCompoundInQueryAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds3() {\n\t\tlocal.getCompoundInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds4() {\n\t\tlocal.getCompoundInQueryAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundInTargetAt() {\n\t\tassertEquals(global.getCompoundInTargetAt(1).getShortName(), \"-\");\n\t\tassertEquals(global.getCompoundInTargetAt(2).getShortName(), \"R\");\n\t\tassertEquals(global.getCompoundInTargetAt(3).getShortName(), \"-\");\n\t\tassertEquals(global.getCompoundInTargetAt(4).getShortName(), \"D\");\n\t\tassertEquals(global.getCompoundInTargetAt(5).getShortName(), \"G\");\n\t\tassertEquals(local.getCompoundInTargetAt(1).getShortName(), \"R\");\n\t\tassertEquals(local.getCompoundInTargetAt(2).getShortName(), \"-\");\n\t\tassertEquals(local.getCompoundInTargetAt(3).getShortName(), \"D\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds() {\n\t\tglobal.getCompoundInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds2() {\n\t\tglobal.getCompoundInTargetAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds3() {\n\t\tlocal.getCompoundInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds4() {\n\t\tlocal.getCompoundInTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInQueryAt() {\n\t\tassertEquals(global.getIndexInQueryAt(1), 1);\n\t\tassertEquals(global.getIndexInQueryAt(2), 2);\n\t\tassertEquals(global.getIndexInQueryAt(3), 3);\n\t\tassertEquals(global.getIndexInQueryAt(4), 4);\n\t\tassertEquals(global.getIndexInQueryAt(5), 4);\n\t\tassertEquals(local.getIndexInQueryAt(1), 2);\n\t\tassertEquals(local.getIndexInQueryAt(2), 3);\n\t\tassertEquals(local.getIndexInQueryAt(3), 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds() {\n\t\tglobal.getIndexInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds2() {\n\t\tglobal.getIndexInQueryAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds3() {\n\t\tlocal.getIndexInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds4() {\n\t\tlocal.getIndexInQueryAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInQueryForTargetAt() {\n\t\tassertEquals(global.getIndexInQueryForTargetAt(1), 2);\n\t\tassertEquals(global.getIndexInQueryForTargetAt(2), 4);\n\t\tassertEquals(global.getIndexInQueryForTargetAt(3), 4);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(1), 2);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(2), 4);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(3), 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds() {\n\t\tglobal.getIndexInQueryForTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds2() {\n\t\tglobal.getIndexInQueryForTargetAt(4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds3() {\n\t\tlocal.getIndexInQueryForTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds4() {\n\t\tlocal.getIndexInQueryForTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInTargetAt() {\n\t\tassertEquals(global.getIndexInTargetAt(1), 1);\n\t\tassertEquals(global.getIndexInTargetAt(2), 1);\n\t\tassertEquals(global.getIndexInTargetAt(3), 1);\n\t\tassertEquals(global.getIndexInTargetAt(4), 2);\n\t\tassertEquals(global.getIndexInTargetAt(5), 3);\n\t\tassertEquals(local.getIndexInTargetAt(1), 1);\n\t\tassertEquals(local.getIndexInTargetAt(2), 1);\n\t\tassertEquals(local.getIndexInTargetAt(3), 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds() {\n\t\tglobal.getIndexInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds2() {\n\t\tglobal.getIndexInTargetAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds3() {\n\t\tlocal.getIndexInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds4() {\n\t\tlocal.getIndexInTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInTargetForQueryAt() {\n\t\tassertEquals(global.getIndexInTargetForQueryAt(1), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(2), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(3), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(4), 2);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(1), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(2), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(3), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(4), 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds() {\n\t\tglobal.getIndexInTargetForQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds2() {\n\t\tglobal.getIndexInTargetForQueryAt(5);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds3() {\n\t\tlocal.getIndexInTargetForQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds4() {\n\t\tlocal.getIndexInTargetForQueryAt(5);\n\t}\n\n\t@Test\n\tpublic void testGetNumIdenticals() {\n\t\tassertEquals(global.getNumIdenticals(), 2);\n\t\tassertEquals(local.getNumIdenticals(), 2);\n\t}\n\t\n\t@Test\n\tpublic void testGetPercentageOfIdentity() {\n\t\tassertEquals(global.getPercentageOfIdentity(), 0.4, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(), 0.66, 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetNumSimilars() {\n\t\tassertEquals(global.getNumSimilars(), 2);\n\t\tassertEquals(local.getNumSimilars(), 2);\n\t}\n\n\t@Test\n\tpublic void testGetQuery() {\n\t\tassertEquals(global.getQuery().getOriginalSequence(), query);\n\t\tassertEquals(local.getQuery().getOriginalSequence(), query);\n\t}\n\n\t@Test\n\tpublic void testGetTarget() {\n\t\tassertEquals(global.getTarget().getOriginalSequence(), target);\n\t\tassertEquals(local.getTarget().getOriginalSequence(), target);\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.alignment.template.SequencePair;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class SimpleSequencePairTest {\n\n\tprivate ProteinSequence query, target;\n\tprivate SequencePair<ProteinSequence, AminoAcidCompound> global, local;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tquery = new ProteinSequence(\"ARND\");\n\t\ttarget = new ProteinSequence(\"RDG\");\n\t\tglobal = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), Arrays.asList(new Step[] {\n\t\t\t\tStep.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n\t\tlocal = new SimpleSequencePair<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0, Arrays.asList(new Step[] { Step.COMPOUND,\n\t\t\t\tStep.GAP, Step.COMPOUND}), 0, 1);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundInQueryAt() {\n\t\tassertEquals(global.getCompoundInQueryAt(1).getShortName(), \"A\");\n\t\tassertEquals(global.getCompoundInQueryAt(2).getShortName(), \"R\");\n\t\tassertEquals(global.getCompoundInQueryAt(3).getShortName(), \"N\");\n\t\tassertEquals(global.getCompoundInQueryAt(4).getShortName(), \"D\");\n\t\tassertEquals(global.getCompoundInQueryAt(5).getShortName(), \"-\");\n\t\tassertEquals(local.getCompoundInQueryAt(1).getShortName(), \"R\");\n\t\tassertEquals(local.getCompoundInQueryAt(2).getShortName(), \"N\");\n\t\tassertEquals(local.getCompoundInQueryAt(3).getShortName(), \"D\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds() {\n\t\tglobal.getCompoundInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds2() {\n\t\tglobal.getCompoundInQueryAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds3() {\n\t\tlocal.getCompoundInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInQueryAtOutOfBounds4() {\n\t\tlocal.getCompoundInQueryAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetCompoundInTargetAt() {\n\t\tassertEquals(global.getCompoundInTargetAt(1).getShortName(), \"-\");\n\t\tassertEquals(global.getCompoundInTargetAt(2).getShortName(), \"R\");\n\t\tassertEquals(global.getCompoundInTargetAt(3).getShortName(), \"-\");\n\t\tassertEquals(global.getCompoundInTargetAt(4).getShortName(), \"D\");\n\t\tassertEquals(global.getCompoundInTargetAt(5).getShortName(), \"G\");\n\t\tassertEquals(local.getCompoundInTargetAt(1).getShortName(), \"R\");\n\t\tassertEquals(local.getCompoundInTargetAt(2).getShortName(), \"-\");\n\t\tassertEquals(local.getCompoundInTargetAt(3).getShortName(), \"D\");\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds() {\n\t\tglobal.getCompoundInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds2() {\n\t\tglobal.getCompoundInTargetAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds3() {\n\t\tlocal.getCompoundInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetCompoundInTargetAtOutOfBounds4() {\n\t\tlocal.getCompoundInTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInQueryAt() {\n\t\tassertEquals(global.getIndexInQueryAt(1), 1);\n\t\tassertEquals(global.getIndexInQueryAt(2), 2);\n\t\tassertEquals(global.getIndexInQueryAt(3), 3);\n\t\tassertEquals(global.getIndexInQueryAt(4), 4);\n\t\tassertEquals(global.getIndexInQueryAt(5), 4);\n\t\tassertEquals(local.getIndexInQueryAt(1), 2);\n\t\tassertEquals(local.getIndexInQueryAt(2), 3);\n\t\tassertEquals(local.getIndexInQueryAt(3), 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds() {\n\t\tglobal.getIndexInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds2() {\n\t\tglobal.getIndexInQueryAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds3() {\n\t\tlocal.getIndexInQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryAtOutOfBounds4() {\n\t\tlocal.getIndexInQueryAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInQueryForTargetAt() {\n\t\tassertEquals(global.getIndexInQueryForTargetAt(1), 2);\n\t\tassertEquals(global.getIndexInQueryForTargetAt(2), 4);\n\t\tassertEquals(global.getIndexInQueryForTargetAt(3), 4);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(1), 2);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(2), 4);\n\t\tassertEquals(local.getIndexInQueryForTargetAt(3), 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds() {\n\t\tglobal.getIndexInQueryForTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds2() {\n\t\tglobal.getIndexInQueryForTargetAt(4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds3() {\n\t\tlocal.getIndexInQueryForTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInQueryForTargetAtOutOfBounds4() {\n\t\tlocal.getIndexInQueryForTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInTargetAt() {\n\t\tassertEquals(global.getIndexInTargetAt(1), 1);\n\t\tassertEquals(global.getIndexInTargetAt(2), 1);\n\t\tassertEquals(global.getIndexInTargetAt(3), 1);\n\t\tassertEquals(global.getIndexInTargetAt(4), 2);\n\t\tassertEquals(global.getIndexInTargetAt(5), 3);\n\t\tassertEquals(local.getIndexInTargetAt(1), 1);\n\t\tassertEquals(local.getIndexInTargetAt(2), 1);\n\t\tassertEquals(local.getIndexInTargetAt(3), 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds() {\n\t\tglobal.getIndexInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds2() {\n\t\tglobal.getIndexInTargetAt(6);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds3() {\n\t\tlocal.getIndexInTargetAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetAtOutOfBounds4() {\n\t\tlocal.getIndexInTargetAt(4);\n\t}\n\n\t@Test\n\tpublic void testGetIndexInTargetForQueryAt() {\n\t\tassertEquals(global.getIndexInTargetForQueryAt(1), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(2), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(3), 1);\n\t\tassertEquals(global.getIndexInTargetForQueryAt(4), 2);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(1), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(2), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(3), 1);\n\t\tassertEquals(local.getIndexInTargetForQueryAt(4), 2);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds() {\n\t\tglobal.getIndexInTargetForQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds2() {\n\t\tglobal.getIndexInTargetForQueryAt(5);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds3() {\n\t\tlocal.getIndexInTargetForQueryAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetIndexInTargetForQueryAtOutOfBounds4() {\n\t\tlocal.getIndexInTargetForQueryAt(5);\n\t}\n\n\t@Test\n\tpublic void testGetNumIdenticals() {\n\t\tassertEquals(global.getNumIdenticals(), 2);\n\t\tassertEquals(local.getNumIdenticals(), 2);\n\t}\n\t\n\t@Test\n\tpublic void testGetPercentageOfIdentity() {\n\t\tassertEquals(global.getPercentageOfIdentity(), 1.0, 0.01);\n\t\tassertEquals(local.getPercentageOfIdentity(), 1.0, 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetNumSimilars() {\n\t\tassertEquals(global.getNumSimilars(), 2);\n\t\tassertEquals(local.getNumSimilars(), 2);\n\t}\n\n\t@Test\n\tpublic void testGetQuery() {\n\t\tassertEquals(global.getQuery().getOriginalSequence(), query);\n\t\tassertEquals(local.getQuery().getOriginalSequence(), query);\n\t}\n\n\t@Test\n\tpublic void testGetTarget() {\n\t\tassertEquals(global.getTarget().getOriginalSequence(), target);\n\t\tassertEquals(local.getTarget().getOriginalSequence(), target);\n\t}\n\n}\n","commitMessage":"Normalize percentage of identity by the length without gaps #521","test_commitMessage":"Normalize percentage of identity by the length without gaps #521","allZero":false}