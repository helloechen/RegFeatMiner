{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/SequenceTools.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/SequenceToolsTest.java","prod_time":"2021-07-11 04:41:39","test_time":"2021-07-11 04:41:39","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"43fafd0a40a523422c1f8d16d7a2a0b504881a01","test_commitID":"43fafd0a40a523422c1f8d16d7a2a0b504881a01","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\npublic class SequenceTools {\n\n\tprotected static final String NUCLEOTIDE_LETTERS = \"GCTAUXN\";\n\n\t/**\n\t * Cyclically permute the characters in {@code string} <em>forward</em> by {@code n} elements.\n\t * @param string The string to permute\n\t * @param n The number of characters to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t */\n\tpublic static String permuteCyclic(String string, int n) {\n\t\t// single letters are char[]; full names are Character[]\n\t\tCharacter[] permuted = new Character[string.length()];\n\t\tchar[] c = string.toCharArray();\n\t\tCharacter[] charArray = new Character[c.length];\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tcharArray[i] = c[i];\n\t\t}\n\t\tpermuteCyclic(charArray, permuted, n);\n\t\tchar[] p = new char[permuted.length];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = permuted[i];\n\t\t}\n\t\treturn String.valueOf(p);\n\t}\n\n\t/**\n\t * Improved implementation that is generally 10-100x faster, and fixes some edge-case bugs.\n\t * @param string The string to permute\n\t * @param n The number of characters to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t * @return\n\t */\n\tpublic static String permuteCyclic2(String string, int n) {\n\t\tString toMutate = string + string;\n\t\tn = n % string.length();\n\t\tif (n < 0) {\n\t\t\tn = string.length() + n;\n\t\t}\n\t\treturn toMutate.substring(n, n + string.length());\n\t}\n\n\t/**\n\t * Cyclically permute {@code array} <em>forward</em> by {@code n} elements.\n\t * @param array The original result; will not be changed\n\t * @param fill The permuted result will be filled into this array\n\t * @param n The number of elements to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t */\n\tpublic static <T> void permuteCyclic(T[] array, T[] fill, int n) {\n\t\tif (array.length != fill.length) throw new IllegalArgumentException(\"Lengths do not match\");\n\t\tif (n < 0) n = array.length + n;\n\t\twhile (n > array.length) {\n\t\t\tn -= array.length;\n\t\t}\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i + n < array.length) {\n\t\t\t\tfill[i] = array[i + n];\n\t\t\t} else {\n\t\t\t\tfill[i] = array[i - array.length + n];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int percentNucleotideSequence(String sequence)\n\t{\n\t\t\tif (sequence == null || sequence.length() == 0) return 0;\n\n\t\t\tint l = sequence.length();\n\t\t\tint n =0;\n\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t{\n\t\t\t\t\tif (NUCLEOTIDE_LETTERS.indexOf(sequence.charAt(i)) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tn++;\n\t\t\t}\n\t\t\treturn (100 * n) / l;\n\t}\n\n\tpublic static boolean isNucleotideSequence(String sequence)\n\t{\n\t\t\tif (sequence == null || sequence.length() == 0) return false;\n\n\t\t\tint l = sequence.length();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t{\n\t\t\t\t\tif (NUCLEOTIDE_LETTERS.indexOf(sequence.charAt(i)) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t}\n\n\tpublic Sequence<?> getSequenceFromString(String sequence) throws CompoundNotFoundException {\n\n\n\t\tif( isNucleotideSequence(sequence)) {\n\t\t\treturn  new DNASequence(sequence);\n\t\t} else {\n\t\t\treturn new ProteinSequence(sequence);\n\t\t}\n\n\t}\n\n\t/** A method to check whether an array of sequences contains at least two sequences having an equal length.\n\t *\n\t * @param sequences the array of {@link org.biojava.nbio.core.sequence.ProteinSequence} sequences\n\t * @return true if any two sequences are of an equal length\n\t */\n\tpublic static boolean equalLengthSequences(ProteinSequence[] sequences) {\n\n\t\tfor (int i=0; i<sequences.length-1; i++) {\n\t\t\tif (sequences[i]==null)\n\t\t\t\tcontinue;\n\t\t\tfor (int j=i+1; j<sequences.length; j++) {\n\t\t\t\tif (sequences[j]==null)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sequences[i].getLength() == sequences[j].getLength())\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\npublic class SequenceTools {\n\n\tprotected static final String NUCLEOTIDE_LETTERS = \"GCTAUXN\";\n\n\t/**\n\t * Cyclically permute the characters in {@code string} <em>forward</em> by {@code n} elements.\n\t * @param string The string to permute\n\t * @param n The number of characters to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t */\n\tpublic static String permuteCyclic(String string, int n) {\n\t\t// single letters are char[]; full names are Character[]\n\t\tCharacter[] permuted = new Character[string.length()];\n\t\tchar[] c = string.toCharArray();\n\t\tCharacter[] charArray = new Character[c.length];\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tcharArray[i] = c[i];\n\t\t}\n\t\tpermuteCyclic(charArray, permuted, n);\n\t\tchar[] p = new char[permuted.length];\n\t\tfor (int i = 0; i < p.length; i++) {\n\t\t\tp[i] = permuted[i];\n\t\t}\n\t\treturn String.valueOf(p);\n\t}\n\n\t/**\n\t * Improved implementation that is generally 10-100x faster, and fixes some edge-case bugs.\n\t * @param string The string to permute\n\t * @param n The number of characters to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t * @return\n\t */\n\tpublic static String permuteCyclic2(String string, int n) {\n\t\tString toMutate = string + string;\n\t\tn = n % string.length();\n\t\tif (n < 0) {\n\t\t\tn = string.length() + n;\n\t\t}\n\t\treturn toMutate.substring(n, n + string.length());\n\t}\n\n\t/**\n\t * Cyclically permute {@code array} <em>forward</em> by {@code n} elements.\n\t * @param array The original result; will not be changed\n\t * @param fill The permuted result will be filled into this array\n\t * @param n The number of elements to permute by; can be positive or negative; values greater than the length of the array are acceptable\n\t */\n\tpublic static <T> void permuteCyclic(T[] array, T[] fill, int n) {\n\t\tif (array.length != fill.length) throw new IllegalArgumentException(\"Lengths do not match\");\n\t\tif (n < 0) n = array.length + n;\n\t\twhile (n > array.length) {\n\t\t\tn -= array.length;\n\t\t}\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i + n < array.length) {\n\t\t\t\tfill[i] = array[i + n];\n\t\t\t} else {\n\t\t\t\tfill[i] = array[i - array.length + n];\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int percentNucleotideSequence(String sequence)\n\t{\n\t\t\tif (sequence == null || sequence.length() == 0) return 0;\n\n\t\t\tint l = sequence.length();\n\t\t\tint n =0;\n\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t{\n\t\t\t\t\tif (NUCLEOTIDE_LETTERS.indexOf(sequence.charAt(i)) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tn++;\n\t\t\t}\n\t\t\treturn (100 * n) / l;\n\t}\n\n\tpublic static boolean isNucleotideSequence(String sequence)\n\t{\n\t\t\tif (sequence == null || sequence.length() == 0) return false;\n\n\t\t\tint l = sequence.length();\n\t\t\tfor (int i = 0; i < l; i++)\n\t\t\t{\n\t\t\t\t\tif (NUCLEOTIDE_LETTERS.indexOf(sequence.charAt(i)) < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t}\n\n\t/**\n\t * Attempts to parse String as a DNA sequence first.<br/>\n\t * If this fails it tries to  parse as a ProteinSequence.\n\t * <br/>\n\t * This method does not attempt to create an RNASequence.\n\t * <p>\n\t * Also, a sequence such as 'ATCGTA' which is both a\n\t * peptide sequence and a DNA sequence, will always be returned \n\t * as a DNA sequence.\n\t * </p>\n\t * <p>\n\t * An empty string argument returns a ProteinSequence of length 0.\n\t * A null argument throws a {@link NullPointerException}\n\t * @param sequence\n\t * @return Either a DNASequence or a ProteinSequence\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic Sequence<?> getSequenceFromString(String sequence) throws CompoundNotFoundException {\n\n\n\t\tif( isNucleotideSequence(sequence)) {\n\t\t\treturn  new DNASequence(sequence);\n\t\t} else {\n\t\t\treturn new ProteinSequence(sequence);\n\n\t\t}\n\n\t}\n\n\t/** A method to check whether an array of sequences contains at least two sequences having an equal length.\n\t *\n\t * @param sequences the array of {@link org.biojava.nbio.core.sequence.ProteinSequence} sequences\n\t * @return true if any two sequences are of an equal length\n\t */\n\tpublic static boolean equalLengthSequences(ProteinSequence[] sequences) {\n\n\t\tfor (int i=0; i<sequences.length-1; i++) {\n\t\t\tif (sequences[i]==null)\n\t\t\t\tcontinue;\n\t\t\tfor (int j=i+1; j<sequences.length; j++) {\n\t\t\t\tif (sequences[j]==null)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (sequences[i].getLength() == sequences[j].getLength())\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.jupiter.api.Assertions.assertAll;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Random;\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\nclass SequenceToolsTest {\n\n\tString randomDNA(int n) {\n\t\tString[] nucs = new String[] { \"A\", \"T\", \"C\", \"G\" };\n\t\tRandom r = new Random();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsb.append(nucs[r.nextInt(4)]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Nested\n\tclass PermuteCyclic {\n\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,1,TCGTA\", \"ATCGT,-1,TATCG\", \"ATCGT,0,ATCGT\", \"ATCGT,25,ATCGT\",\"12345,1,23451\" })\n\t\tvoid permuteCyclicBasic(String original, int n, String expected) {\n\t\t\tassertEquals(expected, SequenceTools.permuteCyclic(original, n));\n\t\t}\n\t\t\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,CGTAT\", \"ATCGT,CGTAT\" })\n\t\t@Disabled(\"fails with current implementation\")\n\t\tvoid permuteCycleIntMaxMin(String original, String expected) {\n\t\t\tassertAll(\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic(original, Integer.MAX_VALUE)),\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic(original, Integer.MIN_VALUE))\n\t\t\t\t);\n\t\t}\n\t\t\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,CGTAT\", \"ATCGT,CGTAT\" })\n\t\t@DisplayName(\"Edge case fixed\")\n\t\tvoid permuteCycleIntMaxMin2(String original, String expected) {\n\t\t\tassertAll(\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic2(original, Integer.MAX_VALUE)),\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic2(original, Integer.MIN_VALUE))\n\t\t\t\t);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid permuteCyclicPerformance() {\n\t\t\tString dna = randomDNA(10_000_000);\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tString rotated = SequenceTools.permuteCyclic(dna, 5_000_000);\n\t\t\tlong end = System.currentTimeMillis();\n\t\t\tSystem.err.println(end-start);\n\t\t\t\n\t\t\tlong start2 = System.currentTimeMillis();\n\t\t\tString rotated2 = SequenceTools.permuteCyclic2(dna, 5_000_000);\n\t\t\tlong end2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(end2-start2);\n\t\t\tassertTrue((end-start)/(end2-start2) > 5);\n\t\t}\n\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertAll;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Random;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.junit.jupiter.params.provider.EmptySource;\nimport org.junit.jupiter.params.provider.NullAndEmptySource;\nimport org.junit.jupiter.params.provider.NullSource;\n\nclass SequenceToolsTest {\n\n\tString randomDNA(int n) {\n\t\tString[] nucs = new String[] { \"A\", \"T\", \"C\", \"G\" };\n\t\tRandom r = new Random();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsb.append(nucs[r.nextInt(4)]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t@Nested\n\tclass PermuteCyclic {\n\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,1,TCGTA\", \"ATCGT,-1,TATCG\", \"ATCGT,0,ATCGT\", \"ATCGT,25,ATCGT\",\"12345,1,23451\" })\n\t\tvoid permuteCyclicBasic(String original, int n, String expected) {\n\t\t\tassertEquals(expected, SequenceTools.permuteCyclic(original, n));\n\t\t}\n\t\t\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,CGTAT\", \"ATCGT,CGTAT\" })\n\t\t@Disabled(\"fails with current implementation\")\n\t\tvoid permuteCycleIntMaxMin(String original, String expected) {\n\t\t\tassertAll(\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic(original, Integer.MAX_VALUE)),\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic(original, Integer.MIN_VALUE))\n\t\t\t\t);\n\t\t}\n\t\t\n\t\t@ParameterizedTest\n\t\t@CsvSource(value = { \"ATCGT,CGTAT\", \"ATCGT,CGTAT\" })\n\t\t@DisplayName(\"Edge case fixed\")\n\t\tvoid permuteCycleIntMaxMin2(String original, String expected) {\n\t\t\tassertAll(\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic2(original, Integer.MAX_VALUE)),\n\t\t\t\t\t()->assertEquals(expected, SequenceTools.permuteCyclic2(original, Integer.MIN_VALUE))\n\t\t\t\t);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid permuteCyclicPerformance() {\n\t\t\tString dna = randomDNA(10_000_000);\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tString rotated = SequenceTools.permuteCyclic(dna, 5_000_000);\n\t\t\tlong end = System.currentTimeMillis();\n\t\t\tSystem.err.println(end-start);\n\t\t\t\n\t\t\tlong start2 = System.currentTimeMillis();\n\t\t\tString rotated2 = SequenceTools.permuteCyclic2(dna, 5_000_000);\n\t\t\tlong end2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(end2-start2);\n\t\t\tassertTrue((end-start)/(end2-start2) > 5);\n\t\t}\n\t}\n\n\t@Nested\n\tclass PercentNucleotideContent {\n\n\t\t@ParameterizedTest\n\t\t@NullAndEmptySource\n\t\t@DisplayName(\"percent nucleotide sequence returns 0 for null \"+\n\t\t \"or empty string\")\n\t\tvoid nucleotideContentInvalidValues(String empty){\n\t\t\tassertEquals(0, SequenceTools.percentNucleotideSequence(empty));\n\t\t}\n\n\t\t@Test\n\t\tvoid nucleotideContentTest(){\n\t\t\tassertEquals(100, SequenceTools.percentNucleotideSequence(\"ATCGCAA\"));\n\t\t\tassertEquals(100, SequenceTools.percentNucleotideSequence(\"UUACG\"));\n\t\t\tassertEquals(100, SequenceTools.percentNucleotideSequence(randomDNA(1_000_000)));\n\t\t\tassertEquals(50, SequenceTools.percentNucleotideSequence(\"123CCG\"));\n\t\t\tassertEquals(66, SequenceTools.percentNucleotideSequence(\"12TTAC\"));\t\t\t\tassertEquals(0, SequenceTools.percentNucleotideSequence(\"  HH\"));\n\t\t\tassertEquals(0, SequenceTools.percentNucleotideSequence(\"actg\"));\n\t\t\t}\n\n\t\t@Test\n\t\tvoid isNucleotideSequence () {\n\t\t\tassertTrue(SequenceTools.isNucleotideSequence(\"AACGAA\"));\n\t\t\tassertFalse(SequenceTools.isNucleotideSequence(\"aacgaa\"));\n\t\t\tassertFalse(SequenceTools.isNucleotideSequence(\"  HH\"));\n\t\t}\n\n\t\t@ParameterizedTest\n\t\t@NullAndEmptySource\n\t\t@DisplayName(\"isNucleotide is false for null \"+\n\t\t\t \"or empty string\")\n\t\tvoid isnucleotideInvalidValues(String empty){\n\t\t\tassertFalse(SequenceTools.isNucleotideSequence(empty));\n\t\t}\n\t}\n\t@Nested\n\t@DisplayName(\"SequenceFromString\")\n\tclass SequenceFromString{\n\t\tSequenceTools tools = new SequenceTools();\n\n\t\t@Test\n\t\tvoid acceptsUpperCaseDNA() throws CompoundNotFoundException  {\n\t\t\tSequence<?>nuc = tools.getSequenceFromString(\"ATCG\");\n\t\t\tassertEquals(4, nuc.getLength());\n\t\t}\n\n\t\t@Test\n\t\tvoid acceptsLowerCaseDNA() throws CompoundNotFoundException  {\n\t\t\tSequence<?>nuc = tools.getSequenceFromString(\"atcg\");\n\t\t\tassertEquals(4, nuc.getLength());\n\t\t}\n\n\t\t@Test\n\t\tvoid rejectsRNA()throws CompoundNotFoundException {\n\t\t\tassertThrows(CompoundNotFoundException.class,\n\t\t\t\t ()->tools.getSequenceFromString(\"AUCG\"));\n\t\t}\n\n\t\t@Test\n\t\tvoid acceptsSingleLetterProtein()throws CompoundNotFoundException {\n\t\t\tSequence<?> protein = tools.getSequenceFromString(\"HYDESS\");\n\t\t\tassertEquals(6, protein.getLength());\n\t\t}\n\n\t\t@Test\n\t\tvoid interpets3LetterAACodeAsSingleLetter()throws CompoundNotFoundException {\n\t\t\tSequence<?> protein = tools.getSequenceFromString(\"AlaGlySer\");\n\t\t\tassertEquals(9, protein.getLength());\n\t\t}\n\n\t\t@EmptySource\n\t\t@ParameterizedTest\n\t\t@DisplayName(\"empty string return 0-length protein sequence\")\n\t\tvoid emptyString(String empty) throws CompoundNotFoundException{\n\t\t\tSequence<?> protein = tools.getSequenceFromString(empty);\n\t\t\tassertEquals(0, protein.getLength());\n\t\t\tassertTrue(protein instanceof ProteinSequence);\n\t\t}\n\n\t\t@NullSource\n\t\t@ParameterizedTest\n\t\t@DisplayName(\"null string throws NPE\")\n\t\tvoid nullString(String nullStr) throws CompoundNotFoundException{\n\t\t\tassertThrows(NullPointerException.class,\n\t\t\t ()-> tools.getSequenceFromString(nullStr));\n\t\t}\n\t}\n}\n","commitMessage":"add tests for other SequenceToolsMethods\n","test_commitMessage":"add tests for other SequenceToolsMethods\n","allZero":true}