{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/cif/CifFileConsumerImpl.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/io/cif/CifFileConsumerImplTest.java","prod_time":"2019-05-02 09:47:42","test_time":"2019-05-02 09:47:42","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":10,"add_classname_line":0,"add_condition_line":0,"add_field_line":4,"add_import_line":5,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":1,"del_annotation_line":0,"del_call_line":19,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"5868d90c6f5c59f00a4643ce2bf3e91adc6e9434","test_commitID":"5868d90c6f5c59f00a4643ce2bf3e91adc6e9434","isfound":"found test change","originPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.*;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.model.DatabasePdbrevRecord;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.biojava.nbio.structure.xtal.SymoplibParser;\nimport org.rcsb.cif.model.FloatColumn;\nimport org.rcsb.cif.model.IntColumn;\nimport org.rcsb.cif.model.StrColumn;\nimport org.rcsb.cif.model.generated.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix4d;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n// TODO detach the impl from the redundant mmCIF impl\n\n/**\n * An implementation of a CifFileConsumer for BioJava. Will process the information provided by a CifFile instance and\n * use it to build up a {@link Structure} object. The implementation is for the most part really close to that in\n * {@link org.biojava.nbio.structure.io.mmcif.SimpleMMcifConsumer} and associated classes. The main difference is that\n * all internally used model classes are generated from the MMCIF schema and a standardized interface to CifFile data is\n * provided. This allows to readily parse files in CIF format as well as binary CIF (BCIF) format.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileConsumerImpl implements CifFileConsumer<Structure> {\n    private static final Logger logger = LoggerFactory.getLogger(CifFileConsumerImpl.class);\n    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n\n    private Structure structure;\n    private Chain currentChain;\n    private Group currentGroup;\n    private List<List<Chain>> allModels;\n    private List<Chain> currentModel;\n    private PDBHeader pdbHeader;\n    private String currentNmrModelNumber;\n    private List<Chain> entityChains;\n\n    private Entity entity;\n    private EntityPoly entityPoly;\n    private EntitySrcGen entitySrcGen;\n    private EntitySrcNat entitySrcNat;\n    private PdbxEntitySrcSyn entitySrcSyn;\n    private List<Chain> seqResChains;\n    private PdbxStructAssembly structAssembly;\n    private PdbxStructAssemblyGen structAssemblyGen;\n    private StructAsym structAsym;\n    private StructConn structConn;\n    private StructNcsOper structNcsOper;\n    private PdbxStructOperList structOpers;\n    private StructRef structRef;\n    private StructRefSeqDif structRefSeqDif;\n    private StructSiteGen structSiteGen;\n\n    private Map<String, String> asymId2entityId;\n    private Map<String, String> asymId2authorId;\n    private Matrix4d parsedScaleMatrix;\n\n    private FileParsingParameters params;\n\n    public CifFileConsumerImpl(FileParsingParameters params) {\n        this.params = params;\n    }\n\n    @Override\n    public void prepare() {\n        this.structure = new StructureImpl();\n        this.pdbHeader = new PDBHeader();\n        structure.setPDBHeader(pdbHeader);\n\n        this.allModels = new ArrayList<>();\n        this.currentModel = new ArrayList<>();\n\n        this.seqResChains  = new ArrayList<>();\n        this.asymId2entityId = new HashMap<>();\n        this.asymId2authorId = new HashMap<>();\n\n        this.entityChains = new ArrayList<>();\n    }\n\n    @Override\n    public void consumeAtomSite(AtomSite atomSite) {\n        if (params.isHeaderOnly()) {\n            return;\n        }\n\n        StrColumn labelAsymId = atomSite.getLabelAsymId();\n        StrColumn authAsymId = atomSite.getAuthAsymId();\n\n        StrColumn groupPDB = atomSite.getGroupPDB();\n        IntColumn authSeqId = atomSite.getAuthSeqId();\n\n        StrColumn labelCompId = atomSite.getLabelCompId();\n\n        IntColumn id = atomSite.getId();\n        StrColumn labelAtomId = atomSite.getLabelAtomId();\n\n        FloatColumn cartnX = atomSite.getCartnX();\n        FloatColumn cartnY = atomSite.getCartnY();\n        FloatColumn cartnZ = atomSite.getCartnZ();\n\n        FloatColumn occupancy = atomSite.getOccupancy();\n        FloatColumn bIsoOrEquiv = atomSite.getBIsoOrEquiv();\n\n        StrColumn labelAltId = atomSite.getLabelAltId();\n        StrColumn typeSymbol = atomSite.getTypeSymbol();\n\n        StrColumn pdbxPDBInsCode = atomSite.getPdbxPDBInsCode();\n        IntColumn labelSeqId = atomSite.getLabelSeqId();\n        IntColumn pdbx_pdb_model_num = atomSite.getPdbxPDBModelNum();\n\n        for (int atomIndex = 0; atomIndex < atomSite.getRowCount(); atomIndex++) {\n            boolean startOfNewChain = false;\n            Character oneLetterCode = StructureTools.get1LetterCodeAmino(labelCompId.get(atomIndex));\n\n            boolean isHetAtmInFile = false;\n            if (!\"ATOM\".equals(groupPDB.get(atomIndex))) {\n                if (oneLetterCode != null && oneLetterCode.equals(StructureTools.UNKNOWN_GROUP_LABEL)) {\n                    oneLetterCode = null;\n                }\n\n                isHetAtmInFile = true;\n            }\n\n            String insCodeString = pdbxPDBInsCode.get(atomIndex);\n            Character insCode = null;\n            if (insCodeString != null && !insCodeString.isEmpty() && !\"?\".equals(insCodeString)) {\n                insCode = insCodeString.charAt(0);\n            }\n\n            // non polymer chains (ligands and small molecules) will have a label_seq_id set to '.'\n            long seqId = labelSeqId.get(atomIndex);\n\n            String nmrModelNumber = pdbx_pdb_model_num.getStringData(atomIndex);\n\n            if (currentNmrModelNumber == null) {\n                currentNmrModelNumber = nmrModelNumber;\n            }\n            if (!currentNmrModelNumber.equals(nmrModelNumber)) {\n                currentNmrModelNumber = nmrModelNumber;\n\n                if (currentChain != null) {\n                    currentChain.addGroup(currentGroup);\n                    currentGroup.trimToSize();\n                }\n\n                allModels.add(currentModel);\n                currentModel = new ArrayList<>();\n                currentChain = null;\n                currentGroup = null;\n            }\n\n            String asymId = labelAsymId.get(atomIndex);\n            String authId = authAsymId.get(atomIndex);\n            if (currentChain == null) {\n                currentChain = new ChainImpl();\n                currentChain.setName(authId);\n                currentChain.setId(asymId);\n                currentModel.add(currentChain);\n                startOfNewChain = true;\n            }\n\n            if (!asymId.equals(currentChain.getId())) {\n                startOfNewChain = true;\n\n                currentChain.addGroup(currentGroup);\n\n                Optional<Chain> testChain = currentModel.stream()\n                        .filter(chain -> chain.getId().equals(asymId))\n                        .findFirst();\n\n                if (testChain.isPresent()) {\n                    currentChain = testChain.get();\n                } else {\n                    currentChain = new ChainImpl();\n                    currentChain.setName(authId);\n                    currentChain.setId(asymId);\n                }\n\n                if (!currentModel.contains(currentChain)) {\n                    currentModel.add(currentChain);\n                }\n            }\n\n            ResidueNumber residueNumber = new ResidueNumber(authId, authSeqId.get(atomIndex), insCode);\n\n            String recordName = groupPDB.get(atomIndex);\n            String compId = labelCompId.get(atomIndex);\n            if (currentGroup == null) {\n                currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                currentGroup.setResidueNumber(residueNumber);\n                currentGroup.setPDBName(compId);\n                currentGroup.setHetAtomInFile(isHetAtmInFile);\n            }\n\n            Group altGroup = null;\n            String altLocation = labelAltId.get(atomIndex);\n\n            if (startOfNewChain) {\n                currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                currentGroup.setResidueNumber(residueNumber);\n                currentGroup.setPDBName(compId);\n                currentGroup.setHetAtomInFile(isHetAtmInFile);\n            } else {\n                if (!residueNumber.equals(currentGroup.getResidueNumber())) {\n                    currentChain.addGroup(currentGroup);\n                    currentGroup.trimToSize();\n                    currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                    currentGroup.setPDBName(compId);\n                    currentGroup.setResidueNumber(residueNumber);\n                    currentGroup.setHetAtomInFile(isHetAtmInFile);\n                } else {\n                    if (altLocation != null && !altLocation.isEmpty() && !altLocation.equals(\".\")) {\n                        altGroup = getAltLocGroup(recordName, altLocation.charAt(0), oneLetterCode, compId, seqId);\n                        if (altGroup.getChain() == null) {\n                            altGroup.setChain(currentChain);\n                        }\n                    }\n                }\n            }\n\n            if (params.isParseCAOnly()) {\n                if (!labelAtomId.get(atomIndex).equals(StructureTools.CA_ATOM_NAME) && \"C\".equals(typeSymbol.get(atomIndex))) {\n                    continue;\n                }\n            }\n\n            Atom atom = new AtomImpl();\n\n            atom.setPDBserial(id.get(atomIndex));\n            atom.setName(labelAtomId.get(atomIndex));\n\n            atom.setX(cartnX.get(atomIndex));\n            atom.setY(cartnY.get(atomIndex));\n            atom.setZ(cartnZ.get(atomIndex));\n\n            atom.setOccupancy((float) occupancy.get(atomIndex));\n            atom.setTempFactor((float) bIsoOrEquiv.get(atomIndex));\n\n            if (altLocation == null || altLocation.isEmpty() || altLocation.equals(\".\")) {\n                atom.setAltLoc(' ');\n            } else {\n                atom.setAltLoc(altLocation.charAt(0));\n            }\n\n            String ts = typeSymbol.get(atomIndex);\n            try {\n                Element element = Element.valueOfIgnoreCase(ts);\n                atom.setElement(element);\n            }  catch (IllegalArgumentException e) {\n                logger.info(\"Element {} was not recognised as a BioJava-known element, the element will be \" +\n                        \"represented as the generic element {}\", typeSymbol, Element.R.name());\n                atom.setElement(Element.R);\n            }\n\n            if (altGroup != null) {\n                altGroup.addAtom(atom);\n            } else {\n                currentGroup.addAtom(atom);\n            }\n\n            String atomName = atom.getName();\n            if (!currentGroup.hasAtom(atomName)) {\n                if (currentGroup.getPDBName().equals(atom.getGroup().getPDBName())) {\n                    if (!StructureTools.hasNonDeuteratedEquiv(atom, currentGroup)) {\n                        currentGroup.addAtom(atom);\n                    }\n                }\n            }\n        }\n    }\n\n    private Group getAltLocGroup(String recordName, Character altLoc, Character oneLetterCode, String threeLetterCode,\n                                 long seqId) {\n        List<Atom> atoms = currentGroup.getAtoms();\n        if (atoms.size() > 0) {\n            if (atoms.get(0).getAltLoc().equals(altLoc)) {\n                return currentGroup;\n            }\n        }\n\n        List<Group> altLocs = currentGroup.getAltLocs();\n        for (Group altLocGroup : altLocs) {\n            atoms = altLocGroup.getAtoms();\n            if (atoms.size() > 0) {\n                for (Atom a1 : atoms) {\n                    if (a1.getAltLoc().equals(altLoc)) {\n                        return altLocGroup;\n                    }\n                }\n            }\n        }\n\n        if (threeLetterCode.equals(currentGroup.getPDBName())) {\n            if (currentGroup.getAtoms().isEmpty()) {\n                return currentGroup;\n            }\n\n            Group altLocGroup = (Group) currentGroup.clone();\n            altLocGroup.setAtoms(new ArrayList<>());\n            altLocGroup.getAltLocs().clear();\n            currentGroup.addAltLoc(altLocGroup);\n            return altLocGroup;\n        }\n\n        Group altLocGroup = createGroup(recordName, oneLetterCode, threeLetterCode, seqId);\n        altLocGroup.setPDBName(threeLetterCode);\n        altLocGroup.setResidueNumber(currentGroup.getResidueNumber());\n        currentGroup.addAltLoc(altLocGroup);\n        return altLocGroup;\n    }\n\n    private Group createGroup(String record, Character oneLetterCode, String threeLetterCode, long seqId) {\n        Group group = ChemCompGroupFactory.getGroupFromChemCompDictionary(threeLetterCode);\n        if (group != null && !group.getChemComp().isEmpty()) {\n            if (group instanceof AminoAcidImpl) {\n                AminoAcidImpl aminoAcid = (AminoAcidImpl) group;\n                aminoAcid.setId(seqId);\n            } else if (group instanceof NucleotideImpl) {\n                NucleotideImpl nucleotide = (NucleotideImpl) group;\n                nucleotide.setId(seqId);\n            } else if (group instanceof HetatomImpl) {\n                HetatomImpl hetatom = (HetatomImpl) group;\n                hetatom.setId(seqId);\n            }\n            return group;\n        }\n\n        if (\"ATOM\".equals(record)) {\n            if (StructureTools.isNucleotide(threeLetterCode)) {\n                NucleotideImpl nucleotide = new NucleotideImpl();\n                group = nucleotide;\n                nucleotide.setId(seqId);\n            } else if (oneLetterCode == null || oneLetterCode == StructureTools.UNKNOWN_GROUP_LABEL) {\n                HetatomImpl hetatom = new HetatomImpl();\n                group = hetatom;\n                hetatom.setId(seqId);\n            } else {\n                AminoAcidImpl aminoAcid = new AminoAcidImpl();\n                group = aminoAcid;\n                aminoAcid.setAminoType(oneLetterCode);\n                aminoAcid.setId(seqId);\n            }\n        } else {\n            if (StructureTools.isNucleotide(threeLetterCode)) {\n                NucleotideImpl nucleotide = new NucleotideImpl();\n                group = nucleotide;\n                nucleotide.setId(seqId);\n            } else if (oneLetterCode != null) {\n                AminoAcidImpl aminoAcid = new AminoAcidImpl();\n                group = aminoAcid;\n                aminoAcid.setAminoType(oneLetterCode);\n                aminoAcid.setId(seqId);\n            } else {\n                HetatomImpl hetatom = new HetatomImpl();\n                hetatom.setId(seqId);\n                group = hetatom;\n            }\n        }\n        return group;\n    }\n\n    @Override\n    public void consumeAtomSites(AtomSites atomSites) {\n        // no atom sites present\n        if (!atomSites.isDefined() || atomSites.getRowCount() == 0) {\n            return;\n        }\n\n        try {\n            parsedScaleMatrix = new Matrix4d(\n                    atomSites.getFractTransfMatrix11().get(),\n                    atomSites.getFractTransfMatrix12().get(),\n                    atomSites.getFractTransfMatrix13().get(),\n                    atomSites.getFractTransfVector1().get(),\n\n                    atomSites.getFractTransfMatrix21().get(),\n                    atomSites.getFractTransfMatrix22().get(),\n                    atomSites.getFractTransfMatrix23().get(),\n                    atomSites.getFractTransfVector2().get(),\n\n                    atomSites.getFractTransfMatrix31().get(),\n                    atomSites.getFractTransfMatrix32().get(),\n                    atomSites.getFractTransfMatrix33().get(),\n                    atomSites.getFractTransfVector3().get(),\n\n                    0,\n                    0,\n                    0,\n                    1\n            );\n        } catch (NumberFormatException e) {\n            logger.warn(\"Some values in _atom_sites.fract_transf_matrix or _atom_sites.fract_transf_vector could not \" +\n                    \"be parsed as numbers. Can't check whether coordinate frame convention is correct! Error: {}\",\n                    e.getMessage());\n            structure.getPDBHeader().getCrystallographicInfo().setNonStandardCoordFrameConvention(false);\n        }\n    }\n\n    @Override\n    public void consumeAuditAuthor(AuditAuthor auditAuthor) {\n        for (int rowIndex = 0; rowIndex < auditAuthor.getRowCount(); rowIndex++) {\n            String name = auditAuthor.getName().get(rowIndex);\n\n            StringBuilder last = new StringBuilder();\n            StringBuilder initials = new StringBuilder();\n            boolean afterComma = false;\n            for (char c : name.toCharArray()) {\n                if (c == ' ') {\n                    continue;\n                }\n                if (c == ',') {\n                    afterComma = true;\n                    continue;\n                }\n\n                if (afterComma) {\n                    initials.append(c);\n                } else {\n                    last.append(c);\n                }\n            }\n\n            StringBuilder newaa = new StringBuilder();\n            newaa.append(initials);\n            newaa.append(last);\n\n            String auth = pdbHeader.getAuthors();\n            if (auth == null) {\n                pdbHeader.setAuthors(newaa.toString());\n            } else {\n                auth += \",\" + newaa.toString();\n                pdbHeader.setAuthors(auth);\n            }\n        }\n    }\n\n    @Override\n    public void consumeCell(Cell cell) {\n        if (!cell.isDefined() || cell.getRowCount() == 0) {\n            return;\n        }\n\n        try {\n            float a = (float) cell.getLengthA().get();\n            float b = (float) cell.getLengthB().get();\n            float c = (float) cell.getLengthC().get();\n            float alpha = (float) cell.getAngleAlpha().get();\n            float beta = (float) cell.getAngleBeta().get();\n            float gamma = (float) cell.getAngleGamma().get();\n\n            CrystalCell crystalCell = new CrystalCell();\n            crystalCell.setA(a);\n            crystalCell.setB(b);\n            crystalCell.setC(c);\n            crystalCell.setAlpha(alpha);\n            crystalCell.setBeta(beta);\n            crystalCell.setGamma(gamma);\n\n            if (!crystalCell.isCellReasonable()) {\n                // If the entry describes a structure determined by a technique other than X-ray crystallography,\n                // cell is (sometimes!) a = b = c = 1.0, alpha = beta = gamma = 90 degrees\n                // if so we don't add and CrystalCell will be null\n                logger.debug(\"The crystal cell read from file does not have reasonable dimensions (at least one \" +\n                        \"dimension is below {}), discarding it.\", CrystalCell.MIN_VALID_CELL_SIZE);\n                return;\n            }\n\n            structure.getPDBHeader()\n                    .getCrystallographicInfo()\n                    .setCrystalCell(crystalCell);\n\n        } catch (NumberFormatException e){\n            structure.getPDBHeader()\n                    .getCrystallographicInfo()\n                    .setCrystalCell(null);\n            logger.info(\"could not parse some cell parameters ({}), ignoring _cell\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void consumeChemComp(ChemComp chemComp) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumeChemCompBond(ChemCompBond chemCompBond) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumeDatabasePDBremark(DatabasePDBRemark databasePDBremark) {\n        for (int rowIndex = 0; rowIndex < databasePDBremark.getRowCount(); rowIndex++) {\n            int id = databasePDBremark.getId().get(rowIndex);\n            if (id == 2) {\n                String line = databasePDBremark.getText().get(rowIndex);\n                int i = line.indexOf(\"ANGSTROM\");\n\n                if (i > 5) {\n                    // line contains ANGSTROM info...\n                    String resolution = line.substring(i - 5, i).trim();\n                    // convert string to float\n                    try {\n                        float res = Float.parseFloat(resolution);\n                        pdbHeader.setResolution(res);\n                    } catch (NumberFormatException e) {\n                        logger.info(\"could not parse resolution from line and ignoring it {}\", line);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void consumeDatabasePDBrev(DatabasePDBRev databasePDBrev) {\n        logger.debug(\"got a database revision:\" + databasePDBrev);\n\n        for (int rowIndex = 0; rowIndex < databasePDBrev.getRowCount(); rowIndex++) {\n            if (databasePDBrev.getNum().get(rowIndex) == 1) {\n                String dateOriginal = databasePDBrev.getDateOriginal().get(rowIndex);\n                try {\n                    Date dep = DATE_FORMAT.parse(dateOriginal);\n                    pdbHeader.setDepDate(dep);\n                } catch (ParseException e){\n                    logger.warn(\"Could not parse date string '{}', deposition date will be unavailable\",\n                            dateOriginal);\n                }\n\n                String date = databasePDBrev.getDate().get(rowIndex);\n                try {\n                    Date rel = DATE_FORMAT.parse(date);\n                    pdbHeader.setRelDate(rel);\n                } catch (ParseException e){\n                    logger.warn(\"Could not parse date string '{}', modification date will be unavailable\", date);\n                }\n            } else {\n                String dbrev = databasePDBrev.getDate().get(rowIndex);\n                try {\n                    Date mod = DATE_FORMAT.parse(dbrev);\n                    pdbHeader.setModDate(mod);\n                } catch (ParseException e){\n                    logger.warn(\"Could not parse date string '{}', modification date will be unavailable\", dbrev);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void consumeDatabasePDBrevRecord(DatabasePDBRevRecord databasePDBrevRecord) {\n        List<DatabasePdbrevRecord> revRecords = pdbHeader.getRevisionRecords();\n        if (revRecords == null) {\n            revRecords = new ArrayList<>();\n            pdbHeader.setRevisionRecords(revRecords);\n        }\n\n        revRecords.addAll(convert(databasePDBrevRecord));\n    }\n\n    private List<DatabasePdbrevRecord> convert(DatabasePDBRevRecord databasePDBrevRecord) {\n        List<DatabasePdbrevRecord> revRecords = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < databasePDBrevRecord.getRowCount(); rowIndex++) {\n            DatabasePdbrevRecord revRecord = new DatabasePdbrevRecord();\n            revRecord.setDetails(databasePDBrevRecord.getDetails().get(rowIndex));\n            revRecord.setRev_num(databasePDBrevRecord.getRevNum().getStringData(rowIndex));\n            revRecord.setType(databasePDBrevRecord.getType().get(rowIndex));\n            revRecords.add(revRecord);\n        }\n        return revRecords;\n    }\n\n    @Override\n    public void consumeEntity(Entity entity) {\n        this.entity = entity;\n    }\n\n    @Override\n    public void consumeEntityPoly(EntityPoly entityPoly) {\n        this.entityPoly = entityPoly;\n    }\n\n    @Override\n    public void consumeEntitySrcGen(EntitySrcGen entitySrcGen) {\n        this.entitySrcGen = entitySrcGen;\n    }\n\n    @Override\n    public void consumeEntitySrcNat(EntitySrcNat entitySrcNat) {\n        this.entitySrcNat = entitySrcNat;\n    }\n\n    @Override\n    public void consumeEntitySrcSyn(PdbxEntitySrcSyn entitySrcSyn) {\n        this.entitySrcSyn = entitySrcSyn;\n    }\n\n    @Override\n    public void consumeEntityPolySeq(EntityPolySeq entityPolySeq) {\n        for (int rowIndex = 0; rowIndex < entityPolySeq.getRowCount(); rowIndex++) {\n            Chain entityChain = getEntityChain(entityPolySeq.getEntityId().get(rowIndex));\n\n            // first we check through the chemcomp provider, if it fails we do some heuristics to guess the type of group\n            // TODO some of this code is analogous to getNewGroup() and we should try to unify them - JD 2016-03-08\n\n            Group g = ChemCompGroupFactory.getGroupFromChemCompDictionary(entityPolySeq.getMonId().get(rowIndex));\n            //int seqId = Integer.parseInt(entityPolySeq.getNum());\n            if (g != null && !g.getChemComp().isEmpty()) {\n                if (g instanceof AminoAcidImpl) {\n                    AminoAcidImpl aa = (AminoAcidImpl) g;\n                    aa.setRecordType(AminoAcid.SEQRESRECORD);\n                }\n            } else {\n                if (entityPolySeq.getMonId().get(rowIndex).length() == 3 &&\n                        StructureTools.get1LetterCodeAmino(entityPolySeq.getMonId().get(rowIndex)) != null) {\n                    AminoAcidImpl a = new AminoAcidImpl();\n                    a.setRecordType(AminoAcid.SEQRESRECORD);\n                    Character code1 = StructureTools.get1LetterCodeAmino(entityPolySeq.getMonId().get(rowIndex));\n                    a.setAminoType(code1);\n                    g = a;\n\n                } else if (StructureTools.isNucleotide(entityPolySeq.getMonId().get(rowIndex))) {\n                    // the group is actually a nucleotide group...\n                    g = new NucleotideImpl();\n                } else {\n                    logger.debug(\"Residue {} {} is not a standard aminoacid or nucleotide, will create a het group \" +\n                            \"for it\", entityPolySeq.getNum().get(rowIndex), entityPolySeq.getMonId().get(rowIndex));\n                    g = new HetatomImpl();\n                }\n            }\n            // at this stage we don't know about author residue numbers (insertion codes)\n            // we abuse now the ResidueNumber field setting the internal residue numbers (label_seq_id, strictly\n            // sequential and follow the seqres sequence 1 to n)\n            // later the actual ResidueNumbers (author residue numbers) have to be corrected in alignSeqRes()\n            g.setResidueNumber(ResidueNumber.fromString(entityPolySeq.getNum().getStringData(rowIndex)));\n            g.setPDBName(entityPolySeq.getMonId().get(rowIndex));\n            entityChain.addGroup(g);\n        }\n    }\n\n    private Chain getEntityChain(String entityId) {\n        for (Chain chain : entityChains) {\n            if (chain.getId().equals(entityId)) {\n                return chain;\n            }\n        }\n\n        // does not exist yet, so create...\n        Chain chain = new ChainImpl();\n        chain.setId(entityId);\n        entityChains.add(chain);\n\n        return chain;\n    }\n\n    @Override\n    public void consumeExptl(Exptl exptl) {\n        for (int rowIndex = 0; rowIndex < exptl.getRowCount(); rowIndex++) {\n            pdbHeader.setExperimentalTechnique(exptl.getMethod().get(rowIndex));\n        }\n    }\n\n    @Override\n    public void consumePdbxAuditRevisionHistory(PdbxAuditRevisionHistory pdbxAuditRevisionHistory) {\n        for (int rowIndex = 0; rowIndex < pdbxAuditRevisionHistory.getRowCount(); rowIndex++) {\n            // first entry in revision history is the release date\n            if (pdbxAuditRevisionHistory.getOrdinal().get(rowIndex) == 1) {\n                String release = pdbxAuditRevisionHistory.getRevisionDate().get(rowIndex);\n                try {\n                    Date releaseDate = DATE_FORMAT.parse(release);\n                    pdbHeader.setRelDate(releaseDate);\n                } catch (ParseException e) {\n                    logger.warn(\"Could not parse date string '{}', release date will be unavailable\", release);\n                }\n            } else {\n                // all other dates are revision dates;\n                // since this method may be called multiple times,\n                // the last revision date will \"stick\"\n                String revision = pdbxAuditRevisionHistory.getRevisionDate().get(rowIndex);\n                try {\n                    Date revisionDate = DATE_FORMAT.parse(revision);\n                    pdbHeader.setModDate(revisionDate);\n                } catch (ParseException e) {\n                    logger.warn(\"Could not parse date string '{}', revision date will be unavailable\", revision);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void consumePdbxChemCompIdentifier(PdbxChemCompIdentifier pdbxChemCompIdentifier) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumePdbxDatabaseStatus(PdbxDatabaseStatus pdbxDatabaseStatus) {\n        for (int rowIndex = 0; rowIndex < pdbxDatabaseStatus.getRowCount(); rowIndex++) {\n            // the deposition date field is only available in mmCIF 5.0\n            StrColumn recvdInitialDepositionDate = pdbxDatabaseStatus.getRecvdInitialDepositionDate();\n            if (recvdInitialDepositionDate.isDefined()) {\n                String deposition = recvdInitialDepositionDate.get(rowIndex);\n\n                try {\n                    Date depositionDate = DATE_FORMAT.parse(deposition);\n                    pdbHeader.setDepDate(depositionDate);\n                } catch (ParseException e) {\n                    logger.warn(\"Could not parse date string '{}', deposition date will be unavailable\", deposition);\n                }\n            }\n        }\n    }\n\n    @Override\n    public void consumePdbxEntityDescriptor(PdbxEntityDescriptor pdbxEntityDescriptor) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxMolecule(PdbxMolecule pdbxMolecule) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxMoleculeFeatures(PdbxMoleculeFeatures pdbxMoleculeFeatures) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxNonpolyScheme(PdbxNonpolyScheme pdbxNonpolyScheme) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityLink(PdbxReferenceEntityLink pdbxReferenceEntityLink) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityList(PdbxReferenceEntityList pdbxReferenceEntityList) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityPolyLink(PdbxReferenceEntityPolyLink pdbxReferenceEntityPolyLink) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxStructAssembly(PdbxStructAssembly pdbxStructAssembly) {\n        this.structAssembly = pdbxStructAssembly;\n    }\n\n    @Override\n    public void consumePdbxStructAssemblyGen(PdbxStructAssemblyGen pdbxStructAssemblyGen) {\n        this.structAssemblyGen = pdbxStructAssemblyGen;\n    }\n\n    @Override\n    public void consumePdbxStructModResidue(PdbxStructModResidue pdbxStructModResidue) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxStructOperList(PdbxStructOperList pdbxStructOperList) {\n        this.structOpers = pdbxStructOperList;\n    }\n\n    @Override\n    public void consumeRefine(Refine refine) {\n        for (int rowIndex = 0; rowIndex < refine.getRowCount(); rowIndex++) {\n            // RESOLUTION\n            // in very rare cases (for instance hybrid methods x-ray + neutron diffraction, e.g. 3ins, 4n9m)\n            // there are 2 resolution values, one for each method\n            // we take the last one found so that behaviour is like in PDB file parsing\n            double lsDResHigh = refine.getLsDResHigh().get(rowIndex);\n            if (pdbHeader.getResolution() != PDBHeader.DEFAULT_RESOLUTION) {\n                logger.warn(\"More than 1 resolution value present, will use last one {} and discard previous {}\",\n                        lsDResHigh, String.format(\"%4.2f\",pdbHeader.getResolution()));\n            }\n            pdbHeader.setResolution((float) lsDResHigh);\n\n            FloatColumn lsRFactorRFree = refine.getLsRFactorRFree();\n            // RFREE\n            if (pdbHeader.getRfree() != PDBHeader.DEFAULT_RFREE) {\n                logger.warn(\"More than 1 Rfree value present, will use last one {} and discard previous {}\",\n                        lsRFactorRFree, String.format(\"%4.2f\",pdbHeader.getRfree()));\n            }\n            if (lsRFactorRFree.isDefined()) {\n                pdbHeader.setRfree((float) lsRFactorRFree.get(rowIndex));\n            } else {\n                // some entries like 2ifo haven't got this field at all\n                logger.info(\"_refine.ls_R_factor_R_free not present, not parsing Rfree value\");\n            }\n\n            // RWORK\n            FloatColumn lsRFactorRWork = refine.getLsRFactorRWork();\n            if(pdbHeader.getRwork() != PDBHeader.DEFAULT_RFREE) {\n                logger.warn(\"More than 1 R work value present, will use last one {} and discard previous {} \",\n                        lsRFactorRWork, String.format(\"%4.2f\",pdbHeader.getRwork()));\n            }\n            if (lsRFactorRWork.isDefined()) {\n                pdbHeader.setRwork((float) lsRFactorRWork.get(rowIndex));\n            } else {\n                logger.info(\"_refine.ls_R_factor_R_work not present, not parsing R-work value\");\n            }\n        }\n    }\n\n    @Override\n    public void consumeStruct(Struct struct) {\n        if (struct.isDefined() && struct.getTitle().isDefined()) {\n            pdbHeader.setTitle(struct.getTitle().get());\n        }\n\n        if (struct.isDefined() && struct.getEntryId().isDefined()) {\n            pdbHeader.setIdCode(struct.getEntryId().get());\n            structure.setPDBCode(struct.getEntryId().get());\n        }\n    }\n\n    @Override\n    public void consumeStructAsym(StructAsym structAsym) {\n        this.structAsym = structAsym;\n    }\n\n    @Override\n    public void consumeStructConf(StructConf structConf) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructConn(StructConn structConn) {\n        this.structConn = structConn;\n    }\n\n    @Override\n    public void consumeStructConnType(StructConnType structConnType) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructKeywords(StructKeywords structKeywords) {\n        StrColumn pdbxKeywords = structKeywords.getPdbxKeywords();\n        // TODO what is the correct format for these?\n        pdbHeader.setDescription(pdbxKeywords.values().collect(Collectors.joining(\", \")));\n        pdbHeader.setClassification(pdbxKeywords.values().collect(Collectors.joining(\", \")));\n    }\n\n    @Override\n    public void consumeStructNcsOper(StructNcsOper structNcsOper) {\n        this.structNcsOper = structNcsOper;\n    }\n\n    @Override\n    public void consumeStructRef(StructRef structRef) {\n        this.structRef = structRef;\n    }\n\n    @Override\n    public void consumeStructRefSeq(StructRefSeq structRefSeq) {\n        for (int rowIndex = 0; rowIndex < structRefSeq.getRowCount(); rowIndex++) {\n            String refId = structRefSeq.getRefId().get(rowIndex);\n\n            DBRef dbRef = new DBRef();\n\n            dbRef.setIdCode(structRefSeq.getPdbxPDBIdCode().get(rowIndex));\n            dbRef.setDbAccession(structRefSeq.getPdbxDbAccession().get(rowIndex));\n            dbRef.setDbIdCode(structRefSeq.getPdbxDbAccession().get(rowIndex));\n            dbRef.setChainName(structRefSeq.getPdbxStrandId().get(rowIndex));\n\n            OptionalInt structRefRowIndex = IntStream.range(0, structRef.getRowCount())\n                    .filter(i -> structRef.getId().get(i).equals(refId))\n                    .findFirst();\n\n            if (structRefRowIndex.isPresent()) {\n                dbRef.setDatabase(structRef.getDbName().get(structRefRowIndex.getAsInt()));\n                dbRef.setDbIdCode(structRef.getDbCode().get(structRefRowIndex.getAsInt()));\n            } else {\n                logger.info(\"could not find StructRef `{} for StructRefSeq {}\", refId, rowIndex);\n            }\n\n            int seqBegin;\n            int seqEnd;\n\n            try {\n                seqBegin = Integer.parseInt(structRefSeq.getPdbxAuthSeqAlignBeg().get(rowIndex));\n                seqEnd = Integer.parseInt(structRefSeq.getPdbxAuthSeqAlignEnd().get(rowIndex));\n            } catch (NumberFormatException e) {\n                // this happens in a few entries, annotation error? e.g. 6eoj\n                logger.warn(\"Couldn't parse pdbx_auth_seq_align_beg/end in _struct_ref_seq. Will not store dbref \" +\n                        \"alignment info for accession {}. Error: {}\", dbRef.getDbAccession(), e.getMessage());\n                return;\n            }\n\n            char beginInsCode = ' ';\n            String pdbxSeqAlignBegInsCode = structRefSeq.getPdbxSeqAlignBegInsCode().get(rowIndex);\n            if (pdbxSeqAlignBegInsCode.length() > 0) {\n                beginInsCode = pdbxSeqAlignBegInsCode.charAt(0);\n            }\n\n            char endInsCode = ' ';\n            String pdbxSeqAlignEndInsCode = structRefSeq.getPdbxSeqAlignEndInsCode().get(rowIndex);\n            if (pdbxSeqAlignEndInsCode.length() > 0) {\n                endInsCode = pdbxSeqAlignEndInsCode.charAt(0);\n            }\n\n            if (beginInsCode == '?') {\n                beginInsCode = ' ';\n            }\n            if (endInsCode == '?') {\n                endInsCode = ' ';\n            }\n\n            dbRef.setSeqBegin(seqBegin);\n            dbRef.setInsertBegin(beginInsCode);\n            dbRef.setSeqEnd(seqEnd);\n            dbRef.setInsertEnd(endInsCode);\n\n            int dbSeqBegin = structRefSeq.getDbAlignBeg().get(rowIndex);\n            int dbSeqEnd = structRefSeq.getDbAlignEnd().get(rowIndex);\n\n            char dbBeginInsCode = ' ';\n            StrColumn pdbxDbAlignBegInsCodeCol = structRefSeq.getPdbxDbAlignBegInsCode();\n            if (pdbxDbAlignBegInsCodeCol.isDefined()) {\n                String pdbxDbAlignBegInsCode = pdbxDbAlignBegInsCodeCol.get(rowIndex);\n                if (pdbxDbAlignBegInsCode.length() > 0) {\n                    dbBeginInsCode = pdbxDbAlignBegInsCode.charAt(0);\n                }\n            }\n\n            char dbEndInsCode = ' ';\n            StrColumn pdbxDbAlignEndInsCodeCol = structRefSeq.getPdbxDbAlignEndInsCode();\n            if (pdbxDbAlignEndInsCodeCol.isDefined()) {\n                String pdbxDbAlignEndInsCode = pdbxDbAlignEndInsCodeCol.get(rowIndex);\n                if (pdbxDbAlignEndInsCode.length() > 0) {\n                    dbEndInsCode = pdbxDbAlignEndInsCode.charAt(0);\n                }\n            }\n\n            if (dbBeginInsCode == '?') {\n                dbBeginInsCode = ' ';\n            }\n            if (dbEndInsCode == '?') {\n                dbEndInsCode = ' ';\n            }\n\n            dbRef.setDbSeqBegin(dbSeqBegin);\n            dbRef.setIdbnsBegin(dbBeginInsCode);\n            dbRef.setDbSeqEnd(dbSeqEnd);\n            dbRef.setIdbnsEnd(dbEndInsCode);\n\n            List<DBRef> dbrefs = structure.getDBRefs();\n            if (dbrefs == null) {\n                dbrefs = new ArrayList<>();\n            }\n            dbrefs.add(dbRef);\n\n            logger.debug(dbRef.toPDB());\n\n            structure.setDBRefs(dbrefs);\n        }\n    }\n\n    @Override\n    public void consumeStructRefSeqDif(StructRefSeqDif structRefSeqDif) {\n        this.structRefSeqDif = structRefSeqDif;\n    }\n\n    @Override\n    public void consumeStructSheetRange(StructSheetRange structSheetRange) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructSite(StructSite structSite) {\n        if (params.isHeaderOnly()) {\n            return;\n        }\n\n        List<Site> sites = structure.getSites();\n        if (sites == null) {\n            sites = new ArrayList<>();\n        }\n\n        for (int rowIndex = 0; rowIndex < structSite.getRowCount(); rowIndex++) {\n            Site site = null;\n            for (Site asite : sites) {\n                if (asite.getSiteID().equals(structSite.getId().get(rowIndex))) {\n                    site = asite; // prevent duplicate siteIds\n                }\n            }\n\n            boolean addSite = false;\n            if (site == null) {\n                site = new Site();\n                addSite = true;\n            }\n\n            site.setSiteID(structSite.getId().get(rowIndex));\n            site.setDescription(structSite.getDetails().get(rowIndex));\n            site.setEvCode(structSite.getPdbxEvidenceCode().get(rowIndex));\n\n            if (addSite) {\n                sites.add(site);\n            }\n        }\n\n        structure.setSites(sites);\n    }\n\n    @Override\n    public void consumeStructSiteGen(StructSiteGen structSiteGen) {\n        this.structSiteGen = structSiteGen;\n    }\n\n    @Override\n    public void consumeSymmetry(Symmetry symmetry) {\n        for (int rowIndex = 0; rowIndex < symmetry.getRowCount(); rowIndex++) {\n            String spaceGroupString = symmetry.getSpaceGroupNameH_M().get(rowIndex);\n            SpaceGroup spaceGroup = SymoplibParser.getSpaceGroup(spaceGroupString);\n            if (spaceGroup == null) {\n                logger.warn(\"Space group '{}' not recognised as a standard space group\", spaceGroupString);\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setNonStandardSg(true);\n            } else {\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setSpaceGroup(spaceGroup);\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setNonStandardSg(false);\n            }\n        }\n    }\n\n    @Override\n    public void finish() {\n        if (currentChain != null) {\n            currentChain.addGroup(currentGroup);\n\n            Optional<Chain> testChain = currentModel.stream()\n                    .filter(chain -> chain.getId().equals(currentChain.getId()))\n                    .findFirst();\n\n            if (!testChain.isPresent()) {\n                currentModel.add(currentChain);\n            }\n        } else if (!params.isHeaderOnly()) {\n            logger.warn(\"current chain is null at end of document.\");\n        }\n\n        allModels.add(currentModel);\n\n        initMaps();\n\n        for (int rowIndex = 0; rowIndex < structAsym.getRowCount(); rowIndex++) {\n            String id = structAsym.getId().get(rowIndex);\n            String entityId = structAsym.getEntityId().get(rowIndex);\n            logger.debug(\"Entity {} matches asym_id: {}\", entityId, id);\n\n            Chain chain = getEntityChain(entityId);\n            Chain seqRes = (Chain) chain.clone();\n            // to solve issue #160 (e.g. 3u7t)\n            seqRes = removeSeqResHeterogeneity(seqRes);\n            seqRes.setId(id);\n            seqRes.setName(asymId2authorId.getOrDefault(id, id));\n\n            EntityType type = EntityType.entityTypeFromString(getEntityType(entityId));\n            if (type == null || type == EntityType.POLYMER) {\n                seqResChains.add(seqRes);\n            }\n\n            logger.debug(\" seqres: {} {}<\", id, seqRes);\n            addEntity(rowIndex, entityId, getEntityDescription(entityId), getEntityType(entityId));\n        }\n\n        if (!structAsym.isDefined() || structAsym.getRowCount() == 0) {\n            logger.warn(\"No _struct_asym category in file, no SEQRES groups will be added.\");\n        }\n\n        // entities\n        // In addEntities above we created the entities if they were present in the file\n        // Now we need to make sure that they are linked to chains and also that if they are not present in the file we\n        // need to add them now\n        linkEntities();\n\n        // now that we know the entities, we can add all chains to structure so that they are stored\n        // properly as polymer/nonpolymer/water chains inside structure\n        allModels.forEach(structure::addModel);\n\n        // Only align if requested (default) and not when headerOnly mode with no Atoms.\n        // Otherwise, we store the empty SeqRes Groups unchanged in the right chains.\n        if (params.isAlignSeqRes() && !params.isHeaderOnly()){\n            logger.debug(\"Parsing mode align_seqres, will parse SEQRES and align to ATOM sequence\");\n            alignSeqRes();\n        } else {\n            logger.debug(\"Parsing mode unalign_seqres, will parse SEQRES but not align it to ATOM sequence\");\n            SeqRes2AtomAligner.storeUnAlignedSeqRes(structure, seqResChains, params.isHeaderOnly());\n        }\n\n        // Now make sure all altlocgroups have all the atoms in all the groups\n        StructureTools.cleanUpAltLocs(structure);\n\n        // NOTE bonds and charges can only be done at this point that the chain id mapping is properly sorted out\n        if (!params.isHeaderOnly()) {\n            if (params.shouldCreateAtomBonds()) {\n                addBonds();\n            }\n\n            if (params.shouldCreateAtomCharges()) {\n                addCharges();\n            }\n        }\n\n        if (!params.isHeaderOnly()) {\n            addSites();\n        }\n\n        // set the oligomeric state info in the header...\n        if (params.isParseBioAssembly()) {\n            // the more detailed mapping of chains to rotation operations happens in StructureIO...\n\n            Map<Integer, BioAssemblyInfo> bioAssemblies = new LinkedHashMap<>();\n            List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> structAssemblies = convert(structAssembly);\n            List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> structAssemblyGens = convert(structAssemblyGen);\n\n            for (org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly pdbxStructAssembly : structAssemblies) {\n                List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> pdbxStructAssemblyGens = structAssemblyGens.stream()\n                        .filter(sag -> sag.getAssembly_id().equals(pdbxStructAssembly.getId()))\n                        .collect(Collectors.toList());\n\n                BiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n                // these are the transformations that need to be applied to our model\n                List<BiologicalAssemblyTransformation> transformations = builder.getBioUnitTransformationList(pdbxStructAssembly,\n                        pdbxStructAssemblyGens, convert(structOpers));\n\n                int bioAssemblyId = -1;\n                try {\n                    bioAssemblyId = Integer.parseInt(pdbxStructAssembly.getId());\n                } catch (NumberFormatException e) {\n                    logger.info(\"Could not parse a numerical bio assembly id from '{}'\", pdbxStructAssembly.getId());\n                }\n\n                // if bioassembly id is not numerical we throw it away\n                // this happens usually for viral capsid entries, like 1ei7\n                // see issue #230 in github\n                if (bioAssemblyId != -1) {\n                    int mmSize = 0;\n                    // note that the transforms contain asym ids of both polymers and non-polymers\n                    // For the mmsize, we are only interested in the polymers\n                    for (BiologicalAssemblyTransformation transf : transformations) {\n                        Chain c = structure.getChain(transf.getChainId());\n                        if (c == null) {\n                            logger.info(\"Could not find asym id {} specified in struct_assembly_gen\", transf.getChainId());\n                            continue;\n                        }\n                        if (c.getEntityType() == EntityType.POLYMER &&\n                                // for entries like 4kro, sugars are annotated as polymers but we\n                                // don't want them in the macromolecularSize count\n                                !c.getEntityInfo().getDescription().contains(\"SUGAR\")) {\n                            mmSize++;\n                        }\n                    }\n\n                    BioAssemblyInfo bioAssembly = new BioAssemblyInfo();\n                    bioAssembly.setId(bioAssemblyId);\n                    bioAssembly.setMacromolecularSize(mmSize);\n                    bioAssembly.setTransforms(transformations);\n                    bioAssemblies.put(bioAssemblyId, bioAssembly);\n                }\n\n            }\n            structure.getPDBHeader()\n                    .setBioAssemblies(bioAssemblies);\n        }\n\n        setStructNcsOps();\n        setCrystallographicInfoMetadata();\n\n        Map<String,List<SeqMisMatch>> misMatchMap = new HashMap<>();\n        for (int rowIndex = 0; rowIndex < structRefSeqDif.getRowCount(); rowIndex++) {\n            SeqMisMatch seqMisMatch = new SeqMisMatchImpl();\n            seqMisMatch.setDetails(structRefSeqDif.getDetails().get(rowIndex));\n\n            String insCode = structRefSeqDif.getPdbxPdbInsCode().get(rowIndex);\n                if (insCode != null && insCode.equals(\"?\")) {\n                insCode = null;\n            }\n            seqMisMatch.setInsCode(insCode);\n            seqMisMatch.setOrigGroup(structRefSeqDif.getDbMonId().get(rowIndex));\n            seqMisMatch.setPdbGroup(structRefSeqDif.getMonId().get(rowIndex));\n            seqMisMatch.setPdbResNum(structRefSeqDif.getPdbxAuthSeqNum().get(rowIndex));\n            seqMisMatch.setUniProtId(structRefSeqDif.getPdbxSeqDbAccessionCode().get(rowIndex));\n            seqMisMatch.setSeqNum(structRefSeqDif.getSeqNum().get(rowIndex));\n\n            String strandId = structRefSeqDif.getPdbxPdbStrandId().get(rowIndex);\n            List<SeqMisMatch> seqMisMatches = misMatchMap.computeIfAbsent(strandId, k -> new ArrayList<>());\n            seqMisMatches.add(seqMisMatch);\n        }\n\n        for (String chainId : misMatchMap.keySet()){\n            Chain chain = structure.getPolyChainByPDB(chainId);\n            if (chain == null) {\n                logger.warn(\"Could not set mismatches for chain with author id {}\", chainId);\n                continue;\n            }\n\n            chain.setSeqMisMatches(misMatchMap.get(chainId));\n        }\n    }\n\n    private String getEntityType(String entityId) {\n        return IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .mapToObj(i -> entity.getType().get(i))\n                .findFirst()\n                .orElseThrow(() -> new NoSuchElementException(\"could not find entity with id \" + entityId));\n    }\n\n    private String getEntityDescription(String entityId) {\n        return IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .mapToObj(i -> entity.getPdbxDescription().get(i))\n                .findFirst()\n                .orElseThrow(() -> new NoSuchElementException(\"could not find entity with id \" + entityId));\n    }\n\n    private void addEntity(int asymRowIndex, String entityId, String pdbxDescription, String type) {\n        int eId = 0;\n        try {\n            eId = Integer.parseInt(entityId);\n        } catch (NumberFormatException e) {\n            logger.warn(\"Could not parse mol_id from string {}. Will use 0 for creating Entity\", entityId);\n        }\n        \n        int entityRowIndex = IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .findFirst()\n                .orElse(-1);\n        \n        EntityInfo entityInfo = structure.getEntityById(eId);\n        \n        if (entityInfo == null) {\n            entityInfo = new EntityInfo();\n            entityInfo.setMolId(eId);\n            // we only add the compound if a polymeric one (to match what the PDB parser does)\n            if (entityRowIndex != -1) {\n                entityInfo.setDescription(pdbxDescription);\n\n                EntityType eType = EntityType.entityTypeFromString(type);\n                if (eType != null) {\n                    entityInfo.setType(eType);\n                } else {\n                    logger.warn(\"Type '{}' is not recognised as a valid entity type for entity {}\", type, eId);\n                }\n                addAncilliaryEntityData(asymRowIndex, entityInfo);\n                structure.addEntityInfo(entityInfo);\n                logger.debug(\"Adding Entity with entity id {} from _entity, with name: {}\", eId, \n                        entityInfo.getDescription());\n            }\n        }\n    }\n\n    private void addAncilliaryEntityData(int asymRowIndex, EntityInfo entityInfo) {\n        // Loop through each of the entity types and add the corresponding data\n        // We're assuming if data is duplicated between sources it is consistent\n        // This is a potentially huge assumption...\n\n        for (int rowIndex = 0; rowIndex < entitySrcGen.getRowCount(); rowIndex++) {\n            if (entitySrcGen.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcGen(rowIndex, entityInfo);\n        }\n\n        for (int rowIndex = 0; rowIndex < entitySrcNat.getRowCount(); rowIndex++) {\n            if (entitySrcNat.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcNat(rowIndex, entityInfo);\n        }\n\n        for (int rowIndex = 0; rowIndex < entitySrcSyn.getRowCount(); rowIndex++) {\n            if (entitySrcSyn.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcSyn(rowIndex, entityInfo);\n        }\n    }\n\n    private void addInformationFromEntitySrcSyn(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setOrganismCommon(entitySrcSyn.getOrganismCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcSyn.getOrganismScientific().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcSyn.getNcbiTaxonomyId().get(rowIndex));\n    }\n\n    private void addInformationFromEntitySrcNat(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setAtcc(entitySrcNat.getPdbxAtcc().get(rowIndex));\n        entityInfo.setCell(entitySrcNat.getPdbxCell().get(rowIndex));\n        entityInfo.setOrganismCommon(entitySrcNat.getCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcNat.getPdbxOrganismScientific().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcNat.getPdbxNcbiTaxonomyId().get(rowIndex));\n    }\n\n    private void addInformationFromEntitySrcGen(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setAtcc(entitySrcGen.getPdbxGeneSrcAtcc().get(rowIndex));\n        entityInfo.setCell(entitySrcGen.getPdbxGeneSrcCell().get(rowIndex));\n        entityInfo.setOrganismCommon(entitySrcGen.getGeneSrcCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcGen.getPdbxGeneSrcScientificName().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcGen.getPdbxGeneSrcNcbiTaxonomyId().get(rowIndex));\n        entityInfo.setExpressionSystemTaxId(entitySrcGen.getPdbxHostOrgNcbiTaxonomyId().get(rowIndex));\n        entityInfo.setExpressionSystem(entitySrcGen.getPdbxHostOrgScientificName().get(rowIndex));\n    }\n\n    private void setStructNcsOps() {\n        List<Matrix4d> ncsOperators = new ArrayList<>();\n\n        for (int rowIndex = 0; rowIndex < structNcsOper.getRowCount(); rowIndex++) {\n            if (!\"generate\".equals(structNcsOper.getCode().get(rowIndex))) {\n                continue;\n            }\n\n            try {\n                Matrix4d operator = new Matrix4d();\n\n                operator.setElement(0, 0, structNcsOper.getMatrix11().get(rowIndex));\n                operator.setElement(0, 1, structNcsOper.getMatrix12().get(rowIndex));\n                operator.setElement(0, 2, structNcsOper.getMatrix13().get(rowIndex));\n\n                operator.setElement(1, 0, structNcsOper.getMatrix21().get(rowIndex));\n                operator.setElement(1, 1, structNcsOper.getMatrix22().get(rowIndex));\n                operator.setElement(1, 2, structNcsOper.getMatrix23().get(rowIndex));\n\n                operator.setElement(2, 0, structNcsOper.getMatrix31().get(rowIndex));\n                operator.setElement(2, 1, structNcsOper.getMatrix32().get(rowIndex));\n                operator.setElement(2, 2, structNcsOper.getMatrix33().get(rowIndex));\n\n                operator.setElement(3, 0, 0);\n                operator.setElement(3, 1, 0);\n                operator.setElement(3, 2, 0);\n                operator.setElement(3, 3, 1);\n\n                ncsOperators.add(operator);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Error parsing doubles in NCS operator list, skipping operator {}\", rowIndex + 1);\n            }\n        }\n\n        if (ncsOperators.size() > 0) {\n            structure.getCrystallographicInfo()\n                    .setNcsOperators(ncsOperators.toArray(new Matrix4d[0]));\n        }\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList> convert(PdbxStructOperList structOpers) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structOpers.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList pdbxStructOperList =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList();\n\n            pdbxStructOperList.setId(structOpers.getId().get(rowIndex));\n            pdbxStructOperList.setName(structOpers.getName().get(rowIndex));\n            pdbxStructOperList.setSymmetry_operation(structOpers.getSymmetryOperation().get(rowIndex));\n            pdbxStructOperList.setType(structOpers.getType().get(rowIndex));\n\n            pdbxStructOperList.setMatrix11(String.valueOf(structOpers.getMatrix11().get(rowIndex)));\n            pdbxStructOperList.setMatrix12(String.valueOf(structOpers.getMatrix12().get(rowIndex)));\n            pdbxStructOperList.setMatrix13(String.valueOf(structOpers.getMatrix13().get(rowIndex)));\n            pdbxStructOperList.setMatrix21(String.valueOf(structOpers.getMatrix21().get(rowIndex)));\n            pdbxStructOperList.setMatrix22(String.valueOf(structOpers.getMatrix22().get(rowIndex)));\n            pdbxStructOperList.setMatrix23(String.valueOf(structOpers.getMatrix23().get(rowIndex)));\n            pdbxStructOperList.setMatrix31(String.valueOf(structOpers.getMatrix31().get(rowIndex)));\n            pdbxStructOperList.setMatrix32(String.valueOf(structOpers.getMatrix32().get(rowIndex)));\n            pdbxStructOperList.setMatrix33(String.valueOf(structOpers.getMatrix33().get(rowIndex)));\n\n            pdbxStructOperList.setVector1(String.valueOf(structOpers.getVector1().get(rowIndex)));\n            pdbxStructOperList.setVector2(String.valueOf(structOpers.getVector2().get(rowIndex)));\n            pdbxStructOperList.setVector3(String.valueOf(structOpers.getVector3().get(rowIndex)));\n\n            re.add(pdbxStructOperList);\n        }\n        return re;\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> convert(PdbxStructAssemblyGen structAssemblyGen) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structAssemblyGen.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen pdbxStructAssemblyGen =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen();\n\n            pdbxStructAssemblyGen.setAssembly_id(structAssemblyGen.getAssemblyId().get(rowIndex));\n            pdbxStructAssemblyGen.setAsym_id_list(structAssemblyGen.getAsymIdList().get(rowIndex));\n            pdbxStructAssemblyGen.setOper_expression(structAssemblyGen.getOperExpression().get(rowIndex));\n\n            re.add(pdbxStructAssemblyGen);\n        }\n        return re;\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> convert(PdbxStructAssembly structAssembly) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structAssembly.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly pdbxStructAssembly =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly();\n\n            pdbxStructAssembly.setDetails(structAssembly.getDetails().get(rowIndex));\n            pdbxStructAssembly.setId(structAssembly.getId().get(rowIndex));\n            pdbxStructAssembly.setMethod_details(structAssembly.getMethodDetails().get(rowIndex));\n            pdbxStructAssembly.setOligomeric_count(structAssembly.getOligomericCount().getStringData(rowIndex));\n            pdbxStructAssembly.setOligomeric_details(structAssembly.getOligomericDetails().get(rowIndex));\n\n            re.add(pdbxStructAssembly);\n        }\n        return re;\n    }\n\n    private void setCrystallographicInfoMetadata() {\n        if (parsedScaleMatrix != null) {\n            PDBCrystallographicInfo crystalInfo = structure.getCrystallographicInfo();\n            boolean nonStd = false;\n            if (crystalInfo.getCrystalCell() != null && !crystalInfo.getCrystalCell().checkScaleMatrix(parsedScaleMatrix)) {\n                nonStd = true;\n            }\n\n            crystalInfo.setNonStandardCoordFrameConvention(nonStd);\n        }\n    }\n\n    private void addSites() {\n        List<Site> sites = structure.getSites();\n        if (sites == null) sites = new ArrayList<>();\n\n        for (int rowIndex = 0; rowIndex < structSiteGen.getRowCount(); rowIndex++) {\n            // For each StructSiteGen, find the residues involved, if they exist then\n            String site_id = structSiteGen.getSiteId().get(rowIndex); // multiple could be in same site.\n            if (site_id == null) {\n                site_id = \"\";\n            }\n            String comp_id = structSiteGen.getLabelCompId().get(rowIndex);  // PDBName\n\n            // Assumption: the author chain ID and residue number for the site is consistent with the original\n            // author chain id and residue numbers.\n\n            String asymId = structSiteGen.getLabelAsymId().get(rowIndex); // chain name\n            String authId = structSiteGen.getAuthAsymId().get(rowIndex); // chain Id\n            String auth_seq_id = structSiteGen.getAuthSeqId().get(rowIndex); // Res num\n\n            String insCode = structSiteGen.getPdbxAuthInsCode().get(rowIndex);\n            if (insCode != null && insCode.equals(\"?\")) {\n                insCode = null;\n            }\n\n            // Look for asymID = chainID and seqID = seq_ID.  Check that comp_id matches the resname.\n            Group g = null;\n            try {\n                Chain chain = structure.getChain(asymId);\n\n                if (null != chain) {\n                    try {\n                        Character insChar = null;\n                        if (null != insCode && insCode.length() > 0) {\n                            insChar = insCode.charAt(0);\n                        }\n                        g = chain.getGroupByPDB(new ResidueNumber(null, Integer.parseInt(auth_seq_id), insChar));\n                    } catch (NumberFormatException e) {\n                        logger.warn(\"Could not lookup residue : {}{}\", authId, auth_seq_id);\n                    }\n                }\n            } catch (StructureException e) {\n                logger.warn(\"Problem finding residue in site entry {} - {}\",\n                        structSiteGen.getSiteId().get(rowIndex), e.getMessage(), e.getMessage());\n            }\n\n            if (g != null) {\n                // 2. find the site_id, if not existing, create anew.\n                Site site = null;\n                for (Site asite : sites) {\n                    if (site_id.equals(asite.getSiteID())) {\n                        site = asite;\n                    }\n                }\n\n                boolean addSite = false;\n\n                // 3. add this residue to the site.\n                if (site == null) {\n                    addSite = true;\n                    site = new Site();\n                    site.setSiteID(site_id);\n                }\n\n                List<Group> groups = site.getGroups();\n                if (groups == null) {\n                    groups = new ArrayList<>();\n                }\n\n                // Check the self-consistency of the residue reference from auth_seq_id and chain_id\n                if (!comp_id.equals(g.getPDBName())) {\n                    logger.warn(\"comp_id doesn't match the residue at {} {} - skipping\", authId, auth_seq_id);\n                } else {\n                    groups.add(g);\n                    site.setGroups(groups);\n                }\n                if (addSite) {\n                    sites.add(site);\n                }\n            }\n        }\n        structure.setSites(sites);\n    }\n\n    private void addCharges() {\n        ChargeAdder.addCharges(structure);\n    }\n\n    /**\n     * The method will return a new reference to a Chain with any consecutive groups\n     * having same residue numbers removed.\n     * This is necessary to solve the microheterogeneity issue in entries like 3u7t (see github issue #160)\n     */\n    private static Chain removeSeqResHeterogeneity(Chain c) {\n        Chain trimmedChain = new ChainImpl();\n        ResidueNumber lastResNum = null;\n\n        for (Group g : c.getAtomGroups()) {\n            // note we have to deep copy this, otherwise they stay linked and would get altered in addGroup(g)\n            ResidueNumber currentResNum = new ResidueNumber(\n                    g.getResidueNumber().getChainName(),\n                    g.getResidueNumber().getSeqNum(),\n                    g.getResidueNumber().getInsCode());\n\n            if (lastResNum == null || !lastResNum.equals(currentResNum)) {\n                trimmedChain.addGroup(g);\n            } else {\n                logger.debug(\"Removing seqres group because it seems to be repeated in entity_poly_seq, most likely \" +\n                        \"has hetero='y': {}\", g);\n            }\n            lastResNum = currentResNum;\n\n        }\n        return trimmedChain;\n    }\n\n    private void addBonds() {\n        BondMaker maker = new BondMaker(structure, params);\n        maker.makeBonds();\n        maker.formBondsFromStructConn(convert(structConn));\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.StructConn> convert(StructConn structConn) {\n        return IntStream.range(0, structConn.getRowCount())\n                .mapToObj(rowIndex -> {\n                    org.biojava.nbio.structure.io.mmcif.model.StructConn sc =\n                            new org.biojava.nbio.structure.io.mmcif.model.StructConn();\n\n                    sc.setPdbx_ptnr1_PDB_ins_code(structConn.getPdbxPtnr1PDBInsCode().get(rowIndex));\n                    sc.setPdbx_ptnr2_PDB_ins_code(structConn.getPdbxPtnr2PDBInsCode().get(rowIndex));\n                    sc.setPtnr1_auth_seq_id(structConn.getPtnr1AuthSeqId().getStringData(rowIndex));\n                    sc.setPtnr2_auth_seq_id(structConn.getPtnr2AuthSeqId().getStringData(rowIndex));\n                    sc.setPtnr1_label_comp_id(structConn.getPtnr1LabelCompId().get(rowIndex));\n                    sc.setPtnr2_label_comp_id(structConn.getPtnr2LabelCompId().get(rowIndex));\n                    sc.setPtnr1_label_atom_id(structConn.getPtnr1LabelAtomId().get(rowIndex));\n                    sc.setPtnr2_label_atom_id(structConn.getPtnr2LabelAtomId().get(rowIndex));\n                    sc.setPdbx_ptnr1_label_alt_id(structConn.getPdbxPtnr1LabelAltId().get(rowIndex));\n                    sc.setPdbx_ptnr2_label_alt_id(structConn.getPdbxPtnr2LabelAltId().get(rowIndex));\n                    sc.setPtnr1_symmetry(structConn.getPtnr1Symmetry().get(rowIndex));\n                    sc.setPtnr2_symmetry(structConn.getPtnr2Symmetry().get(rowIndex));\n                    sc.setConn_type_id(structConn.getConnTypeId().get(rowIndex));\n\n                    return sc;\n                })\n                .collect(Collectors.toList());\n    }\n\n    private void alignSeqRes() {\n        logger.debug(\"Parsing mode align_seqres, will align to ATOM to SEQRES sequence\");\n\n        // fix SEQRES residue numbering for all models\n\n        for (int model = 0; model < structure.nrModels(); model++) {\n            List<Chain> atomList   = structure.getModel(model);\n\n            for (Chain seqResChain : seqResChains){\n\n                // this extracts the matching atom chain from atomList\n                Chain atomChain = SeqRes2AtomAligner.getMatchingAtomRes(seqResChain, atomList, true);\n\n                if (atomChain == null) {\n                    // most likely there's no observed residues at all for the seqres chain: can't map\n                    // e.g. 3zyb: chains with asym_id L,M,N,O,P have no observed residues\n                    logger.info(\"Could not map SEQRES chain with asym_id={} to any ATOM chain. Most likely there's \" +\n                            \"no observed residues in the chain.\", seqResChain.getId());\n                    continue;\n                }\n\n                //map the atoms to the seqres...\n\n                // we need to first clone the seqres so that they stay independent for different models\n                List<Group> seqResGroups = new ArrayList<>();\n                for (int i = 0; i < seqResChain.getAtomGroups().size(); i++) {\n                    seqResGroups.add((Group)seqResChain.getAtomGroups().get(i).clone());\n                }\n\n                for (int seqResPos = 0 ; seqResPos < seqResGroups.size(); seqResPos++) {\n                    Group seqresG = seqResGroups.get(seqResPos);\n                    boolean found = false;\n                    for (Group atomG : atomChain.getAtomGroups()) {\n\n                        int internalNr = getInternalNr(atomG);\n\n                        if (seqresG.getResidueNumber().getSeqNum() == internalNr) {\n                            seqResGroups.set(seqResPos, atomG);\n                            found = true;\n                            break;\n                        }\n                    }\n\n                    if (!found)\n                        // so far the residue number has tracked internal numbering.\n                        // however there are no atom records, as such this can't be a PDB residue number...\n                        seqresG.setResidueNumber(null);\n                }\n                atomChain.setSeqResGroups(seqResGroups);\n            }\n        }\n    }\n\n    private int getInternalNr(Group atomG) {\n        if (atomG.getType().equals(GroupType.AMINOACID)) {\n            AminoAcidImpl aa = (AminoAcidImpl) atomG;\n            return (int) aa.getId();\n        } else if (atomG.getType().equals(GroupType.NUCLEOTIDE)) {\n            NucleotideImpl nu = (NucleotideImpl) atomG;\n            return (int) nu.getId();\n        } else {\n            HetatomImpl he = (HetatomImpl) atomG;\n            return (int) he.getId();\n        }\n    }\n\n    private void linkEntities() {\n        for (List<Chain> allModel : allModels) {\n            for (Chain chain : allModel) {\n                //logger.info(\"linking entities for \" + chain.getId() + \" \"  + chain.getName());\n                String entityId = asymId2entityId.get(chain.getId());\n\n                if (entityId == null) {\n                    // this can happen for instance if the cif file didn't have _struct_asym category at all\n                    // and thus we have no asymId2entityId mapping at all\n                    logger.info(\"No entity id could be found for chain {}\", chain.getId());\n                    continue;\n                }\n\n                int eId = Integer.parseInt(entityId);\n\n                // Entities are not added for non-polymeric entities, if a chain is non-polymeric its entity won't be found.\n                // TODO: add all entities and unique compounds and add methods to directly get polymer or non-polymer\n                // asyms (chains).  Either create a unique StructureImpl or modify existing for a better representation of the\n                // mmCIF internal data structures but is compatible with Structure interface.\n                // Some examples of PDB entries with this kind of problem:\n                //   - 2uub: asym_id X, chainName Z, entity_id 24: fully non-polymeric but still with its own chainName\n                //   - 3o6j: asym_id K, chainName Z, entity_id 6 : a single water molecule\n                //   - 1dz9: asym_id K, chainName K, entity_id 6 : a potassium ion alone\n\n                EntityInfo entityInfo = structure.getEntityById(eId);\n                if (entityInfo == null) {\n                    // Supports the case where the only chain members were from non-polymeric entity that is missing.\n                    // Solved by creating a new Compound(entity) to which this chain will belong.\n                    logger.info(\"Could not find an Entity for entity_id {}, for chain id {}, creating a new Entity.\",\n                            eId, chain.getId());\n                    entityInfo = new EntityInfo();\n                    entityInfo.setMolId(eId);\n                    entityInfo.addChain(chain);\n                    if (chain.isWaterOnly()) {\n                        entityInfo.setType(EntityType.WATER);\n                    } else {\n                        entityInfo.setType(EntityType.NONPOLYMER);\n                    }\n                    chain.setEntityInfo(entityInfo);\n                    structure.addEntityInfo(entityInfo);\n                } else {\n                    logger.debug(\"Adding chain with chain id {} (auth id {}) to Entity with entity_id {}\",\n                            chain.getId(), chain.getName(), eId);\n                    entityInfo.addChain(chain);\n                    chain.setEntityInfo(entityInfo);\n                }\n\n            }\n\n        }\n\n        // if no entity information was present in file we then go and find the entities heuristically with EntityFinder\n        List<EntityInfo> entityInfos = structure.getEntityInfos();\n        if (entityInfos == null || entityInfos.isEmpty()) {\n            List<List<Chain>> polyModels = new ArrayList<>();\n            List<List<Chain>> nonPolyModels = new ArrayList<>();\n            List<List<Chain>> waterModels = new ArrayList<>();\n\n            for (List<Chain> model : allModels) {\n                List<Chain> polyChains = new ArrayList<>();\n                List<Chain> nonPolyChains = new ArrayList<>();\n                List<Chain> waterChains = new ArrayList<>();\n\n                polyModels.add(polyChains);\n                nonPolyModels.add(nonPolyChains);\n                waterModels.add(waterChains);\n\n                for (Chain chain : model) {\n                    // we only have entities for polymeric chains, all others are ignored for assigning entities\n                    if (chain.isWaterOnly()) {\n                        waterChains.add(chain);\n                    } else if (chain.isPureNonPolymer()) {\n                        nonPolyChains.add(chain);\n                    } else {\n                        polyChains.add(chain);\n                    }\n                }\n            }\n\n            entityInfos = EntityFinder.findPolyEntities(polyModels);\n            EntityFinder.createPurelyNonPolyEntities(nonPolyModels, waterModels, entityInfos);\n\n            structure.setEntityInfos(entityInfos);\n        }\n\n        // final sanity check: it can happen that from the annotated entities some are not linked to any chains\n        // e.g. 3s26: a sugar entity does not have any chains associated to it (it seems to be happening with many sugar compounds)\n        // we simply log it, this can sign some other problems if the entities are used down the line\n        for (EntityInfo e : entityInfos) {\n            if (e.getChains().isEmpty()) {\n                logger.info(\"Entity {} '{}' has no chains associated to it\",\n                        e.getMolId() < 0 ? \"with no entity id\" : e.getMolId(), e.getDescription());\n            }\n        }\n    }\n\n    private void initMaps() {\n        if (structAsym == null || !structAsym.isDefined() || structAsym.getRowCount() == 0) {\n            logger.info(\"No _struct_asym category found in file. No asym id to entity_id mapping will be available\");\n            return;\n        }\n\n        Map<String, List<String>> entityId2asymId = new HashMap<>();\n        for (int rowIndex = 0; rowIndex < structAsym.getRowCount(); rowIndex++) {\n            String id = structAsym.getId().get(rowIndex);\n            String entityId = structAsym.getEntityId().get(rowIndex);\n\n            logger.debug(\"Entity {} matches asym_id: {}\", entityId, id);\n\n            asymId2entityId.put(id, entityId);\n\n            if (entityId2asymId.containsKey(entityId)) {\n                List<String> asymIds = entityId2asymId.get(entityId);\n                asymIds.add(id);\n            } else {\n                List<String> asymIds = new ArrayList<>();\n                asymIds.add(id);\n                entityId2asymId.put(entityId, asymIds);\n            }\n        }\n\n        if (entityPoly == null || !entityPoly.isDefined() || entityPoly.getRowCount() == 0) {\n            logger.info(\"No _entity_poly category found in file. No asym id to author id mapping will be available \" +\n                    \"for header only parsing\");\n            return;\n        }\n\n        for (int rowIndex = 0; rowIndex < entityPoly.getRowCount(); rowIndex++) {\n            if (!entityPoly.getPdbxStrandId().isDefined()) {\n                logger.info(\"_entity_poly.pdbx_strand_id is null for entity {}. Won't be able to map asym ids to \" +\n                        \"author ids for this entity.\", entityPoly.getEntityId().get(rowIndex));\n                break;\n            }\n\n            String[] chainNames = entityPoly.getPdbxStrandId().get(rowIndex).split(\",\");\n            List<String> asymIds = entityId2asymId.get(entityPoly.getEntityId().get(rowIndex));\n            if (chainNames.length != asymIds.size()) {\n                logger.warn(\"The list of asym ids (from _struct_asym) and the list of author ids (from _entity_poly) \" +\n                        \"for entity {} have different lengths! Can't provide a mapping from asym ids to author chain \" +\n                        \"ids\", entityPoly.getEntityId().get(rowIndex));\n                break;\n            }\n\n            for (int i = 0; i < chainNames.length; i++) {\n                asymId2authorId.put(asymIds.get(i), chainNames[i]);\n            }\n        }\n    }\n\n    @Override\n    public Structure getContainer() {\n        return structure;\n    }\n}\n","changedPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.*;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.model.DatabasePdbrevRecord;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.biojava.nbio.structure.xtal.SymoplibParser;\nimport org.rcsb.cif.model.FloatColumn;\nimport org.rcsb.cif.model.IntColumn;\nimport org.rcsb.cif.model.StrColumn;\nimport org.rcsb.cif.model.generated.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix4d;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeFormatterBuilder;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n// TODO detach the impl from the redundant mmCIF impl\n\n/**\n * An implementation of a CifFileConsumer for BioJava. Will process the information provided by a CifFile instance and\n * use it to build up a {@link Structure} object. The implementation is for the most part really close to that in\n * {@link org.biojava.nbio.structure.io.mmcif.SimpleMMcifConsumer} and associated classes. The main difference is that\n * all internally used model classes are generated from the MMCIF schema and a standardized interface to CifFile data is\n * provided. This allows to readily parse files in CIF format as well as binary CIF (BCIF) format.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileConsumerImpl implements CifFileConsumer<Structure> {\n    private static final Logger logger = LoggerFactory.getLogger(CifFileConsumerImpl.class);\n    private static final DateTimeFormatter DATE_FORMAT = new DateTimeFormatterBuilder()\n            .parseCaseInsensitive()\n            .appendPattern(\"yyyy-MM-dd\")\n            .toFormatter(Locale.US);\n\n    private Structure structure;\n    private Chain currentChain;\n    private Group currentGroup;\n    private List<List<Chain>> allModels;\n    private List<Chain> currentModel;\n    private PDBHeader pdbHeader;\n    private String currentNmrModelNumber;\n    private List<Chain> entityChains;\n\n    private Entity entity;\n    private EntityPoly entityPoly;\n    private EntitySrcGen entitySrcGen;\n    private EntitySrcNat entitySrcNat;\n    private PdbxEntitySrcSyn entitySrcSyn;\n    private List<Chain> seqResChains;\n    private PdbxStructAssembly structAssembly;\n    private PdbxStructAssemblyGen structAssemblyGen;\n    private StructAsym structAsym;\n    private StructConn structConn;\n    private StructNcsOper structNcsOper;\n    private PdbxStructOperList structOpers;\n    private StructRef structRef;\n    private StructRefSeqDif structRefSeqDif;\n    private StructSiteGen structSiteGen;\n\n    private Map<String, String> asymId2entityId;\n    private Map<String, String> asymId2authorId;\n    private Matrix4d parsedScaleMatrix;\n\n    private FileParsingParameters params;\n\n    public CifFileConsumerImpl(FileParsingParameters params) {\n        this.params = params;\n    }\n\n    @Override\n    public void prepare() {\n        this.structure = new StructureImpl();\n        this.pdbHeader = new PDBHeader();\n        structure.setPDBHeader(pdbHeader);\n\n        this.allModels = new ArrayList<>();\n        this.currentModel = new ArrayList<>();\n\n        this.seqResChains  = new ArrayList<>();\n        this.asymId2entityId = new HashMap<>();\n        this.asymId2authorId = new HashMap<>();\n\n        this.entityChains = new ArrayList<>();\n    }\n\n    @Override\n    public void consumeAtomSite(AtomSite atomSite) {\n        if (params.isHeaderOnly()) {\n            return;\n        }\n\n        StrColumn labelAsymId = atomSite.getLabelAsymId();\n        StrColumn authAsymId = atomSite.getAuthAsymId();\n\n        StrColumn groupPDB = atomSite.getGroupPDB();\n        IntColumn authSeqId = atomSite.getAuthSeqId();\n\n        StrColumn labelCompId = atomSite.getLabelCompId();\n\n        IntColumn id = atomSite.getId();\n        StrColumn labelAtomId = atomSite.getLabelAtomId();\n\n        FloatColumn cartnX = atomSite.getCartnX();\n        FloatColumn cartnY = atomSite.getCartnY();\n        FloatColumn cartnZ = atomSite.getCartnZ();\n\n        FloatColumn occupancy = atomSite.getOccupancy();\n        FloatColumn bIsoOrEquiv = atomSite.getBIsoOrEquiv();\n\n        StrColumn labelAltId = atomSite.getLabelAltId();\n        StrColumn typeSymbol = atomSite.getTypeSymbol();\n\n        StrColumn pdbxPDBInsCode = atomSite.getPdbxPDBInsCode();\n        IntColumn labelSeqId = atomSite.getLabelSeqId();\n        IntColumn pdbx_pdb_model_num = atomSite.getPdbxPDBModelNum();\n\n        for (int atomIndex = 0; atomIndex < atomSite.getRowCount(); atomIndex++) {\n            boolean startOfNewChain = false;\n            Character oneLetterCode = StructureTools.get1LetterCodeAmino(labelCompId.get(atomIndex));\n\n            boolean isHetAtmInFile = false;\n            if (!\"ATOM\".equals(groupPDB.get(atomIndex))) {\n                if (oneLetterCode != null && oneLetterCode.equals(StructureTools.UNKNOWN_GROUP_LABEL)) {\n                    oneLetterCode = null;\n                }\n\n                isHetAtmInFile = true;\n            }\n\n            String insCodeString = pdbxPDBInsCode.get(atomIndex);\n            Character insCode = null;\n            if (insCodeString != null && !insCodeString.isEmpty() && !\"?\".equals(insCodeString)) {\n                insCode = insCodeString.charAt(0);\n            }\n\n            // non polymer chains (ligands and small molecules) will have a label_seq_id set to '.'\n            long seqId = labelSeqId.get(atomIndex);\n\n            String nmrModelNumber = pdbx_pdb_model_num.getStringData(atomIndex);\n\n            if (currentNmrModelNumber == null) {\n                currentNmrModelNumber = nmrModelNumber;\n            }\n            if (!currentNmrModelNumber.equals(nmrModelNumber)) {\n                currentNmrModelNumber = nmrModelNumber;\n\n                if (currentChain != null) {\n                    currentChain.addGroup(currentGroup);\n                    currentGroup.trimToSize();\n                }\n\n                allModels.add(currentModel);\n                currentModel = new ArrayList<>();\n                currentChain = null;\n                currentGroup = null;\n            }\n\n            String asymId = labelAsymId.get(atomIndex);\n            String authId = authAsymId.get(atomIndex);\n            if (currentChain == null) {\n                currentChain = new ChainImpl();\n                currentChain.setName(authId);\n                currentChain.setId(asymId);\n                currentModel.add(currentChain);\n                startOfNewChain = true;\n            }\n\n            if (!asymId.equals(currentChain.getId())) {\n                startOfNewChain = true;\n\n                currentChain.addGroup(currentGroup);\n\n                Optional<Chain> testChain = currentModel.stream()\n                        .filter(chain -> chain.getId().equals(asymId))\n                        .findFirst();\n\n                if (testChain.isPresent()) {\n                    currentChain = testChain.get();\n                } else {\n                    currentChain = new ChainImpl();\n                    currentChain.setName(authId);\n                    currentChain.setId(asymId);\n                }\n\n                if (!currentModel.contains(currentChain)) {\n                    currentModel.add(currentChain);\n                }\n            }\n\n            ResidueNumber residueNumber = new ResidueNumber(authId, authSeqId.get(atomIndex), insCode);\n\n            String recordName = groupPDB.get(atomIndex);\n            String compId = labelCompId.get(atomIndex);\n            if (currentGroup == null) {\n                currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                currentGroup.setResidueNumber(residueNumber);\n                currentGroup.setPDBName(compId);\n                currentGroup.setHetAtomInFile(isHetAtmInFile);\n            }\n\n            Group altGroup = null;\n            String altLocation = labelAltId.get(atomIndex);\n\n            if (startOfNewChain) {\n                currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                currentGroup.setResidueNumber(residueNumber);\n                currentGroup.setPDBName(compId);\n                currentGroup.setHetAtomInFile(isHetAtmInFile);\n            } else {\n                if (!residueNumber.equals(currentGroup.getResidueNumber())) {\n                    currentChain.addGroup(currentGroup);\n                    currentGroup.trimToSize();\n                    currentGroup = createGroup(recordName, oneLetterCode, compId, seqId);\n                    currentGroup.setPDBName(compId);\n                    currentGroup.setResidueNumber(residueNumber);\n                    currentGroup.setHetAtomInFile(isHetAtmInFile);\n                } else {\n                    if (altLocation != null && !altLocation.isEmpty() && !altLocation.equals(\".\")) {\n                        altGroup = getAltLocGroup(recordName, altLocation.charAt(0), oneLetterCode, compId, seqId);\n                        if (altGroup.getChain() == null) {\n                            altGroup.setChain(currentChain);\n                        }\n                    }\n                }\n            }\n\n            if (params.isParseCAOnly()) {\n                if (!labelAtomId.get(atomIndex).equals(StructureTools.CA_ATOM_NAME) && \"C\".equals(typeSymbol.get(atomIndex))) {\n                    continue;\n                }\n            }\n\n            Atom atom = new AtomImpl();\n\n            atom.setPDBserial(id.get(atomIndex));\n            atom.setName(labelAtomId.get(atomIndex));\n\n            atom.setX(cartnX.get(atomIndex));\n            atom.setY(cartnY.get(atomIndex));\n            atom.setZ(cartnZ.get(atomIndex));\n\n            atom.setOccupancy((float) occupancy.get(atomIndex));\n            atom.setTempFactor((float) bIsoOrEquiv.get(atomIndex));\n\n            if (altLocation == null || altLocation.isEmpty() || altLocation.equals(\".\")) {\n                atom.setAltLoc(' ');\n            } else {\n                atom.setAltLoc(altLocation.charAt(0));\n            }\n\n            String ts = typeSymbol.get(atomIndex);\n            try {\n                Element element = Element.valueOfIgnoreCase(ts);\n                atom.setElement(element);\n            }  catch (IllegalArgumentException e) {\n                logger.info(\"Element {} was not recognised as a BioJava-known element, the element will be \" +\n                        \"represented as the generic element {}\", typeSymbol, Element.R.name());\n                atom.setElement(Element.R);\n            }\n\n            if (altGroup != null) {\n                altGroup.addAtom(atom);\n            } else {\n                currentGroup.addAtom(atom);\n            }\n\n            String atomName = atom.getName();\n            if (!currentGroup.hasAtom(atomName)) {\n                if (currentGroup.getPDBName().equals(atom.getGroup().getPDBName())) {\n                    if (!StructureTools.hasNonDeuteratedEquiv(atom, currentGroup)) {\n                        currentGroup.addAtom(atom);\n                    }\n                }\n            }\n        }\n    }\n\n    private Group getAltLocGroup(String recordName, Character altLoc, Character oneLetterCode, String threeLetterCode,\n                                 long seqId) {\n        List<Atom> atoms = currentGroup.getAtoms();\n        if (atoms.size() > 0) {\n            if (atoms.get(0).getAltLoc().equals(altLoc)) {\n                return currentGroup;\n            }\n        }\n\n        List<Group> altLocs = currentGroup.getAltLocs();\n        for (Group altLocGroup : altLocs) {\n            atoms = altLocGroup.getAtoms();\n            if (atoms.size() > 0) {\n                for (Atom a1 : atoms) {\n                    if (a1.getAltLoc().equals(altLoc)) {\n                        return altLocGroup;\n                    }\n                }\n            }\n        }\n\n        if (threeLetterCode.equals(currentGroup.getPDBName())) {\n            if (currentGroup.getAtoms().isEmpty()) {\n                return currentGroup;\n            }\n\n            Group altLocGroup = (Group) currentGroup.clone();\n            altLocGroup.setAtoms(new ArrayList<>());\n            altLocGroup.getAltLocs().clear();\n            currentGroup.addAltLoc(altLocGroup);\n            return altLocGroup;\n        }\n\n        Group altLocGroup = createGroup(recordName, oneLetterCode, threeLetterCode, seqId);\n        altLocGroup.setPDBName(threeLetterCode);\n        altLocGroup.setResidueNumber(currentGroup.getResidueNumber());\n        currentGroup.addAltLoc(altLocGroup);\n        return altLocGroup;\n    }\n\n    private Group createGroup(String record, Character oneLetterCode, String threeLetterCode, long seqId) {\n        Group group = ChemCompGroupFactory.getGroupFromChemCompDictionary(threeLetterCode);\n        if (group != null && !group.getChemComp().isEmpty()) {\n            if (group instanceof AminoAcidImpl) {\n                AminoAcidImpl aminoAcid = (AminoAcidImpl) group;\n                aminoAcid.setId(seqId);\n            } else if (group instanceof NucleotideImpl) {\n                NucleotideImpl nucleotide = (NucleotideImpl) group;\n                nucleotide.setId(seqId);\n            } else if (group instanceof HetatomImpl) {\n                HetatomImpl hetatom = (HetatomImpl) group;\n                hetatom.setId(seqId);\n            }\n            return group;\n        }\n\n        if (\"ATOM\".equals(record)) {\n            if (StructureTools.isNucleotide(threeLetterCode)) {\n                NucleotideImpl nucleotide = new NucleotideImpl();\n                group = nucleotide;\n                nucleotide.setId(seqId);\n            } else if (oneLetterCode == null || oneLetterCode == StructureTools.UNKNOWN_GROUP_LABEL) {\n                HetatomImpl hetatom = new HetatomImpl();\n                group = hetatom;\n                hetatom.setId(seqId);\n            } else {\n                AminoAcidImpl aminoAcid = new AminoAcidImpl();\n                group = aminoAcid;\n                aminoAcid.setAminoType(oneLetterCode);\n                aminoAcid.setId(seqId);\n            }\n        } else {\n            if (StructureTools.isNucleotide(threeLetterCode)) {\n                NucleotideImpl nucleotide = new NucleotideImpl();\n                group = nucleotide;\n                nucleotide.setId(seqId);\n            } else if (oneLetterCode != null) {\n                AminoAcidImpl aminoAcid = new AminoAcidImpl();\n                group = aminoAcid;\n                aminoAcid.setAminoType(oneLetterCode);\n                aminoAcid.setId(seqId);\n            } else {\n                HetatomImpl hetatom = new HetatomImpl();\n                hetatom.setId(seqId);\n                group = hetatom;\n            }\n        }\n        return group;\n    }\n\n    @Override\n    public void consumeAtomSites(AtomSites atomSites) {\n        // no atom sites present\n        if (!atomSites.isDefined() || atomSites.getRowCount() == 0) {\n            return;\n        }\n\n        try {\n            parsedScaleMatrix = new Matrix4d(\n                    atomSites.getFractTransfMatrix11().get(),\n                    atomSites.getFractTransfMatrix12().get(),\n                    atomSites.getFractTransfMatrix13().get(),\n                    atomSites.getFractTransfVector1().get(),\n\n                    atomSites.getFractTransfMatrix21().get(),\n                    atomSites.getFractTransfMatrix22().get(),\n                    atomSites.getFractTransfMatrix23().get(),\n                    atomSites.getFractTransfVector2().get(),\n\n                    atomSites.getFractTransfMatrix31().get(),\n                    atomSites.getFractTransfMatrix32().get(),\n                    atomSites.getFractTransfMatrix33().get(),\n                    atomSites.getFractTransfVector3().get(),\n\n                    0,\n                    0,\n                    0,\n                    1\n            );\n        } catch (NumberFormatException e) {\n            logger.warn(\"Some values in _atom_sites.fract_transf_matrix or _atom_sites.fract_transf_vector could not \" +\n                    \"be parsed as numbers. Can't check whether coordinate frame convention is correct! Error: {}\",\n                    e.getMessage());\n            structure.getPDBHeader().getCrystallographicInfo().setNonStandardCoordFrameConvention(false);\n        }\n    }\n\n    @Override\n    public void consumeAuditAuthor(AuditAuthor auditAuthor) {\n        for (int rowIndex = 0; rowIndex < auditAuthor.getRowCount(); rowIndex++) {\n            String name = auditAuthor.getName().get(rowIndex);\n\n            StringBuilder last = new StringBuilder();\n            StringBuilder initials = new StringBuilder();\n            boolean afterComma = false;\n            for (char c : name.toCharArray()) {\n                if (c == ' ') {\n                    continue;\n                }\n                if (c == ',') {\n                    afterComma = true;\n                    continue;\n                }\n\n                if (afterComma) {\n                    initials.append(c);\n                } else {\n                    last.append(c);\n                }\n            }\n\n            StringBuilder newaa = new StringBuilder();\n            newaa.append(initials);\n            newaa.append(last);\n\n            String auth = pdbHeader.getAuthors();\n            if (auth == null) {\n                pdbHeader.setAuthors(newaa.toString());\n            } else {\n                auth += \",\" + newaa.toString();\n                pdbHeader.setAuthors(auth);\n            }\n        }\n    }\n\n    @Override\n    public void consumeCell(Cell cell) {\n        if (!cell.isDefined() || cell.getRowCount() == 0) {\n            return;\n        }\n\n        try {\n            float a = (float) cell.getLengthA().get();\n            float b = (float) cell.getLengthB().get();\n            float c = (float) cell.getLengthC().get();\n            float alpha = (float) cell.getAngleAlpha().get();\n            float beta = (float) cell.getAngleBeta().get();\n            float gamma = (float) cell.getAngleGamma().get();\n\n            CrystalCell crystalCell = new CrystalCell();\n            crystalCell.setA(a);\n            crystalCell.setB(b);\n            crystalCell.setC(c);\n            crystalCell.setAlpha(alpha);\n            crystalCell.setBeta(beta);\n            crystalCell.setGamma(gamma);\n\n            if (!crystalCell.isCellReasonable()) {\n                // If the entry describes a structure determined by a technique other than X-ray crystallography,\n                // cell is (sometimes!) a = b = c = 1.0, alpha = beta = gamma = 90 degrees\n                // if so we don't add and CrystalCell will be null\n                logger.debug(\"The crystal cell read from file does not have reasonable dimensions (at least one \" +\n                        \"dimension is below {}), discarding it.\", CrystalCell.MIN_VALID_CELL_SIZE);\n                return;\n            }\n\n            structure.getPDBHeader()\n                    .getCrystallographicInfo()\n                    .setCrystalCell(crystalCell);\n\n        } catch (NumberFormatException e){\n            structure.getPDBHeader()\n                    .getCrystallographicInfo()\n                    .setCrystalCell(null);\n            logger.info(\"could not parse some cell parameters ({}), ignoring _cell\", e.getMessage());\n        }\n    }\n\n    @Override\n    public void consumeChemComp(ChemComp chemComp) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumeChemCompBond(ChemCompBond chemCompBond) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumeDatabasePDBremark(DatabasePDBRemark databasePDBremark) {\n        for (int rowIndex = 0; rowIndex < databasePDBremark.getRowCount(); rowIndex++) {\n            int id = databasePDBremark.getId().get(rowIndex);\n            if (id == 2) {\n                String line = databasePDBremark.getText().get(rowIndex);\n                int i = line.indexOf(\"ANGSTROM\");\n\n                if (i > 5) {\n                    // line contains ANGSTROM info...\n                    String resolution = line.substring(i - 5, i).trim();\n                    // convert string to float\n                    try {\n                        float res = Float.parseFloat(resolution);\n                        pdbHeader.setResolution(res);\n                    } catch (NumberFormatException e) {\n                        logger.info(\"could not parse resolution from line and ignoring it {}\", line);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    private Date convert(LocalDate localDate) {\n        return Date.from(localDate.atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());\n    }\n\n    @Override\n    public void consumeDatabasePDBrev(DatabasePDBRev databasePDBrev) {\n        logger.debug(\"got a database revision:\" + databasePDBrev);\n\n        for (int rowIndex = 0; rowIndex < databasePDBrev.getRowCount(); rowIndex++) {\n            if (databasePDBrev.getNum().get(rowIndex) == 1) {\n                String dateOriginal = databasePDBrev.getDateOriginal().get(rowIndex);\n                pdbHeader.setDepDate(convert(LocalDate.parse(dateOriginal, DATE_FORMAT)));\n\n                String date = databasePDBrev.getDate().get(rowIndex);\n                pdbHeader.setRelDate(convert(LocalDate.parse(date, DATE_FORMAT)));\n            } else {\n                String dbrev = databasePDBrev.getDate().get(rowIndex);\n                pdbHeader.setModDate(convert(LocalDate.parse(dbrev, DATE_FORMAT)));\n            }\n        }\n    }\n\n    @Override\n    public void consumeDatabasePDBrevRecord(DatabasePDBRevRecord databasePDBrevRecord) {\n        List<DatabasePdbrevRecord> revRecords = pdbHeader.getRevisionRecords();\n        if (revRecords == null) {\n            revRecords = new ArrayList<>();\n            pdbHeader.setRevisionRecords(revRecords);\n        }\n\n        revRecords.addAll(convert(databasePDBrevRecord));\n    }\n\n    private List<DatabasePdbrevRecord> convert(DatabasePDBRevRecord databasePDBrevRecord) {\n        List<DatabasePdbrevRecord> revRecords = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < databasePDBrevRecord.getRowCount(); rowIndex++) {\n            DatabasePdbrevRecord revRecord = new DatabasePdbrevRecord();\n            revRecord.setDetails(databasePDBrevRecord.getDetails().get(rowIndex));\n            revRecord.setRev_num(databasePDBrevRecord.getRevNum().getStringData(rowIndex));\n            revRecord.setType(databasePDBrevRecord.getType().get(rowIndex));\n            revRecords.add(revRecord);\n        }\n        return revRecords;\n    }\n\n    @Override\n    public void consumeEntity(Entity entity) {\n        this.entity = entity;\n    }\n\n    @Override\n    public void consumeEntityPoly(EntityPoly entityPoly) {\n        this.entityPoly = entityPoly;\n    }\n\n    @Override\n    public void consumeEntitySrcGen(EntitySrcGen entitySrcGen) {\n        this.entitySrcGen = entitySrcGen;\n    }\n\n    @Override\n    public void consumeEntitySrcNat(EntitySrcNat entitySrcNat) {\n        this.entitySrcNat = entitySrcNat;\n    }\n\n    @Override\n    public void consumeEntitySrcSyn(PdbxEntitySrcSyn entitySrcSyn) {\n        this.entitySrcSyn = entitySrcSyn;\n    }\n\n    @Override\n    public void consumeEntityPolySeq(EntityPolySeq entityPolySeq) {\n        for (int rowIndex = 0; rowIndex < entityPolySeq.getRowCount(); rowIndex++) {\n            Chain entityChain = getEntityChain(entityPolySeq.getEntityId().get(rowIndex));\n\n            // first we check through the chemcomp provider, if it fails we do some heuristics to guess the type of group\n            // TODO some of this code is analogous to getNewGroup() and we should try to unify them - JD 2016-03-08\n\n            Group g = ChemCompGroupFactory.getGroupFromChemCompDictionary(entityPolySeq.getMonId().get(rowIndex));\n            //int seqId = Integer.parseInt(entityPolySeq.getNum());\n            if (g != null && !g.getChemComp().isEmpty()) {\n                if (g instanceof AminoAcidImpl) {\n                    AminoAcidImpl aa = (AminoAcidImpl) g;\n                    aa.setRecordType(AminoAcid.SEQRESRECORD);\n                }\n            } else {\n                if (entityPolySeq.getMonId().get(rowIndex).length() == 3 &&\n                        StructureTools.get1LetterCodeAmino(entityPolySeq.getMonId().get(rowIndex)) != null) {\n                    AminoAcidImpl a = new AminoAcidImpl();\n                    a.setRecordType(AminoAcid.SEQRESRECORD);\n                    Character code1 = StructureTools.get1LetterCodeAmino(entityPolySeq.getMonId().get(rowIndex));\n                    a.setAminoType(code1);\n                    g = a;\n\n                } else if (StructureTools.isNucleotide(entityPolySeq.getMonId().get(rowIndex))) {\n                    // the group is actually a nucleotide group...\n                    g = new NucleotideImpl();\n                } else {\n                    logger.debug(\"Residue {} {} is not a standard aminoacid or nucleotide, will create a het group \" +\n                            \"for it\", entityPolySeq.getNum().get(rowIndex), entityPolySeq.getMonId().get(rowIndex));\n                    g = new HetatomImpl();\n                }\n            }\n            // at this stage we don't know about author residue numbers (insertion codes)\n            // we abuse now the ResidueNumber field setting the internal residue numbers (label_seq_id, strictly\n            // sequential and follow the seqres sequence 1 to n)\n            // later the actual ResidueNumbers (author residue numbers) have to be corrected in alignSeqRes()\n            g.setResidueNumber(ResidueNumber.fromString(entityPolySeq.getNum().getStringData(rowIndex)));\n            g.setPDBName(entityPolySeq.getMonId().get(rowIndex));\n            entityChain.addGroup(g);\n        }\n    }\n\n    private Chain getEntityChain(String entityId) {\n        for (Chain chain : entityChains) {\n            if (chain.getId().equals(entityId)) {\n                return chain;\n            }\n        }\n\n        // does not exist yet, so create...\n        Chain chain = new ChainImpl();\n        chain.setId(entityId);\n        entityChains.add(chain);\n\n        return chain;\n    }\n\n    @Override\n    public void consumeExptl(Exptl exptl) {\n        for (int rowIndex = 0; rowIndex < exptl.getRowCount(); rowIndex++) {\n            pdbHeader.setExperimentalTechnique(exptl.getMethod().get(rowIndex));\n        }\n    }\n\n    @Override\n    public void consumePdbxAuditRevisionHistory(PdbxAuditRevisionHistory pdbxAuditRevisionHistory) {\n        for (int rowIndex = 0; rowIndex < pdbxAuditRevisionHistory.getRowCount(); rowIndex++) {\n            // first entry in revision history is the release date\n            if (pdbxAuditRevisionHistory.getOrdinal().get(rowIndex) == 1) {\n                String release = pdbxAuditRevisionHistory.getRevisionDate().get(rowIndex);\n                pdbHeader.setRelDate(convert(LocalDate.parse(release, DATE_FORMAT)));\n            } else {\n                // all other dates are revision dates;\n                // since this method may be called multiple times,\n                // the last revision date will \"stick\"\n                String revision = pdbxAuditRevisionHistory.getRevisionDate().get(rowIndex);\n                pdbHeader.setModDate(convert(LocalDate.parse(revision, DATE_FORMAT)));\n            }\n        }\n    }\n\n    @Override\n    public void consumePdbxChemCompIdentifier(PdbxChemCompIdentifier pdbxChemCompIdentifier) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumePdbxDatabaseStatus(PdbxDatabaseStatus pdbxDatabaseStatus) {\n        for (int rowIndex = 0; rowIndex < pdbxDatabaseStatus.getRowCount(); rowIndex++) {\n            // the deposition date field is only available in mmCIF 5.0\n            StrColumn recvdInitialDepositionDate = pdbxDatabaseStatus.getRecvdInitialDepositionDate();\n            if (recvdInitialDepositionDate.isDefined()) {\n                String deposition = recvdInitialDepositionDate.get(rowIndex);\n                pdbHeader.setDepDate(convert(LocalDate.parse(deposition, DATE_FORMAT)));\n            }\n        }\n    }\n\n    @Override\n    public void consumePdbxEntityDescriptor(PdbxEntityDescriptor pdbxEntityDescriptor) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxMolecule(PdbxMolecule pdbxMolecule) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxMoleculeFeatures(PdbxMoleculeFeatures pdbxMoleculeFeatures) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxNonpolyScheme(PdbxNonpolyScheme pdbxNonpolyScheme) {\n        // TODO not impled in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityLink(PdbxReferenceEntityLink pdbxReferenceEntityLink) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityList(PdbxReferenceEntityList pdbxReferenceEntityList) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxReferenceEntityPolyLink(PdbxReferenceEntityPolyLink pdbxReferenceEntityPolyLink) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxStructAssembly(PdbxStructAssembly pdbxStructAssembly) {\n        this.structAssembly = pdbxStructAssembly;\n    }\n\n    @Override\n    public void consumePdbxStructAssemblyGen(PdbxStructAssemblyGen pdbxStructAssemblyGen) {\n        this.structAssemblyGen = pdbxStructAssemblyGen;\n    }\n\n    @Override\n    public void consumePdbxStructModResidue(PdbxStructModResidue pdbxStructModResidue) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumePdbxStructOperList(PdbxStructOperList pdbxStructOperList) {\n        this.structOpers = pdbxStructOperList;\n    }\n\n    @Override\n    public void consumeRefine(Refine refine) {\n        for (int rowIndex = 0; rowIndex < refine.getRowCount(); rowIndex++) {\n            // RESOLUTION\n            // in very rare cases (for instance hybrid methods x-ray + neutron diffraction, e.g. 3ins, 4n9m)\n            // there are 2 resolution values, one for each method\n            // we take the last one found so that behaviour is like in PDB file parsing\n            double lsDResHigh = refine.getLsDResHigh().get(rowIndex);\n            // TODO this could use a check to keep reasonable values - 1.5 may be overwritten by 0.0\n            if (pdbHeader.getResolution() != PDBHeader.DEFAULT_RESOLUTION) {\n                logger.warn(\"More than 1 resolution value present, will use last one {} and discard previous {}\",\n                        lsDResHigh, String.format(\"%4.2f\",pdbHeader.getResolution()));\n            }\n            pdbHeader.setResolution((float) lsDResHigh);\n\n            FloatColumn lsRFactorRFree = refine.getLsRFactorRFree();\n            // RFREE\n            if (pdbHeader.getRfree() != PDBHeader.DEFAULT_RFREE) {\n                logger.warn(\"More than 1 Rfree value present, will use last one {} and discard previous {}\",\n                        lsRFactorRFree, String.format(\"%4.2f\",pdbHeader.getRfree()));\n            }\n            if (lsRFactorRFree.isDefined()) {\n                pdbHeader.setRfree((float) lsRFactorRFree.get(rowIndex));\n            } else {\n                // some entries like 2ifo haven't got this field at all\n                logger.info(\"_refine.ls_R_factor_R_free not present, not parsing Rfree value\");\n            }\n\n            // RWORK\n            FloatColumn lsRFactorRWork = refine.getLsRFactorRWork();\n            if(pdbHeader.getRwork() != PDBHeader.DEFAULT_RFREE) {\n                logger.warn(\"More than 1 R work value present, will use last one {} and discard previous {} \",\n                        lsRFactorRWork, String.format(\"%4.2f\",pdbHeader.getRwork()));\n            }\n            if (lsRFactorRWork.isDefined()) {\n                pdbHeader.setRwork((float) lsRFactorRWork.get(rowIndex));\n            } else {\n                logger.info(\"_refine.ls_R_factor_R_work not present, not parsing R-work value\");\n            }\n        }\n    }\n\n    @Override\n    public void consumeStruct(Struct struct) {\n        if (struct.isDefined() && struct.getTitle().isDefined()) {\n            pdbHeader.setTitle(struct.getTitle().get());\n        }\n\n        if (struct.isDefined() && struct.getEntryId().isDefined()) {\n            pdbHeader.setIdCode(struct.getEntryId().get());\n            structure.setPDBCode(struct.getEntryId().get());\n        }\n    }\n\n    @Override\n    public void consumeStructAsym(StructAsym structAsym) {\n        this.structAsym = structAsym;\n    }\n\n    @Override\n    public void consumeStructConf(StructConf structConf) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructConn(StructConn structConn) {\n        this.structConn = structConn;\n    }\n\n    @Override\n    public void consumeStructConnType(StructConnType structConnType) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructKeywords(StructKeywords structKeywords) {\n        StrColumn pdbxKeywords = structKeywords.getPdbxKeywords();\n        // TODO what is the correct format for these?\n        pdbHeader.setDescription(pdbxKeywords.values().collect(Collectors.joining(\", \")));\n        pdbHeader.setClassification(pdbxKeywords.values().collect(Collectors.joining(\", \")));\n    }\n\n    @Override\n    public void consumeStructNcsOper(StructNcsOper structNcsOper) {\n        this.structNcsOper = structNcsOper;\n    }\n\n    @Override\n    public void consumeStructRef(StructRef structRef) {\n        this.structRef = structRef;\n    }\n\n    @Override\n    public void consumeStructRefSeq(StructRefSeq structRefSeq) {\n        for (int rowIndex = 0; rowIndex < structRefSeq.getRowCount(); rowIndex++) {\n            String refId = structRefSeq.getRefId().get(rowIndex);\n\n            DBRef dbRef = new DBRef();\n\n            dbRef.setIdCode(structRefSeq.getPdbxPDBIdCode().get(rowIndex));\n            dbRef.setDbAccession(structRefSeq.getPdbxDbAccession().get(rowIndex));\n            dbRef.setDbIdCode(structRefSeq.getPdbxDbAccession().get(rowIndex));\n            dbRef.setChainName(structRefSeq.getPdbxStrandId().get(rowIndex));\n\n            OptionalInt structRefRowIndex = IntStream.range(0, structRef.getRowCount())\n                    .filter(i -> structRef.getId().get(i).equals(refId))\n                    .findFirst();\n\n            if (structRefRowIndex.isPresent()) {\n                dbRef.setDatabase(structRef.getDbName().get(structRefRowIndex.getAsInt()));\n                dbRef.setDbIdCode(structRef.getDbCode().get(structRefRowIndex.getAsInt()));\n            } else {\n                logger.info(\"could not find StructRef `{} for StructRefSeq {}\", refId, rowIndex);\n            }\n\n            int seqBegin;\n            int seqEnd;\n\n            try {\n                seqBegin = Integer.parseInt(structRefSeq.getPdbxAuthSeqAlignBeg().get(rowIndex));\n                seqEnd = Integer.parseInt(structRefSeq.getPdbxAuthSeqAlignEnd().get(rowIndex));\n            } catch (NumberFormatException e) {\n                // this happens in a few entries, annotation error? e.g. 6eoj\n                logger.warn(\"Couldn't parse pdbx_auth_seq_align_beg/end in _struct_ref_seq. Will not store dbref \" +\n                        \"alignment info for accession {}. Error: {}\", dbRef.getDbAccession(), e.getMessage());\n                return;\n            }\n\n            char beginInsCode = ' ';\n            String pdbxSeqAlignBegInsCode = structRefSeq.getPdbxSeqAlignBegInsCode().get(rowIndex);\n            if (pdbxSeqAlignBegInsCode.length() > 0) {\n                beginInsCode = pdbxSeqAlignBegInsCode.charAt(0);\n            }\n\n            char endInsCode = ' ';\n            String pdbxSeqAlignEndInsCode = structRefSeq.getPdbxSeqAlignEndInsCode().get(rowIndex);\n            if (pdbxSeqAlignEndInsCode.length() > 0) {\n                endInsCode = pdbxSeqAlignEndInsCode.charAt(0);\n            }\n\n            if (beginInsCode == '?') {\n                beginInsCode = ' ';\n            }\n            if (endInsCode == '?') {\n                endInsCode = ' ';\n            }\n\n            dbRef.setSeqBegin(seqBegin);\n            dbRef.setInsertBegin(beginInsCode);\n            dbRef.setSeqEnd(seqEnd);\n            dbRef.setInsertEnd(endInsCode);\n\n            int dbSeqBegin = structRefSeq.getDbAlignBeg().get(rowIndex);\n            int dbSeqEnd = structRefSeq.getDbAlignEnd().get(rowIndex);\n\n            char dbBeginInsCode = ' ';\n            StrColumn pdbxDbAlignBegInsCodeCol = structRefSeq.getPdbxDbAlignBegInsCode();\n            if (pdbxDbAlignBegInsCodeCol.isDefined()) {\n                String pdbxDbAlignBegInsCode = pdbxDbAlignBegInsCodeCol.get(rowIndex);\n                if (pdbxDbAlignBegInsCode.length() > 0) {\n                    dbBeginInsCode = pdbxDbAlignBegInsCode.charAt(0);\n                }\n            }\n\n            char dbEndInsCode = ' ';\n            StrColumn pdbxDbAlignEndInsCodeCol = structRefSeq.getPdbxDbAlignEndInsCode();\n            if (pdbxDbAlignEndInsCodeCol.isDefined()) {\n                String pdbxDbAlignEndInsCode = pdbxDbAlignEndInsCodeCol.get(rowIndex);\n                if (pdbxDbAlignEndInsCode.length() > 0) {\n                    dbEndInsCode = pdbxDbAlignEndInsCode.charAt(0);\n                }\n            }\n\n            if (dbBeginInsCode == '?') {\n                dbBeginInsCode = ' ';\n            }\n            if (dbEndInsCode == '?') {\n                dbEndInsCode = ' ';\n            }\n\n            dbRef.setDbSeqBegin(dbSeqBegin);\n            dbRef.setIdbnsBegin(dbBeginInsCode);\n            dbRef.setDbSeqEnd(dbSeqEnd);\n            dbRef.setIdbnsEnd(dbEndInsCode);\n\n            List<DBRef> dbrefs = structure.getDBRefs();\n            if (dbrefs == null) {\n                dbrefs = new ArrayList<>();\n            }\n            dbrefs.add(dbRef);\n\n            logger.debug(dbRef.toPDB());\n\n            structure.setDBRefs(dbrefs);\n        }\n    }\n\n    @Override\n    public void consumeStructRefSeqDif(StructRefSeqDif structRefSeqDif) {\n        this.structRefSeqDif = structRefSeqDif;\n    }\n\n    @Override\n    public void consumeStructSheetRange(StructSheetRange structSheetRange) {\n        // TODO not considered in ref\n    }\n\n    @Override\n    public void consumeStructSite(StructSite structSite) {\n        if (params.isHeaderOnly()) {\n            return;\n        }\n\n        List<Site> sites = structure.getSites();\n        if (sites == null) {\n            sites = new ArrayList<>();\n        }\n\n        for (int rowIndex = 0; rowIndex < structSite.getRowCount(); rowIndex++) {\n            Site site = null;\n            for (Site asite : sites) {\n                if (asite.getSiteID().equals(structSite.getId().get(rowIndex))) {\n                    site = asite; // prevent duplicate siteIds\n                }\n            }\n\n            boolean addSite = false;\n            if (site == null) {\n                site = new Site();\n                addSite = true;\n            }\n\n            site.setSiteID(structSite.getId().get(rowIndex));\n            site.setDescription(structSite.getDetails().get(rowIndex));\n            site.setEvCode(structSite.getPdbxEvidenceCode().get(rowIndex));\n\n            if (addSite) {\n                sites.add(site);\n            }\n        }\n\n        structure.setSites(sites);\n    }\n\n    @Override\n    public void consumeStructSiteGen(StructSiteGen structSiteGen) {\n        this.structSiteGen = structSiteGen;\n    }\n\n    @Override\n    public void consumeSymmetry(Symmetry symmetry) {\n        for (int rowIndex = 0; rowIndex < symmetry.getRowCount(); rowIndex++) {\n            String spaceGroupString = symmetry.getSpaceGroupNameH_M().get(rowIndex);\n            SpaceGroup spaceGroup = SymoplibParser.getSpaceGroup(spaceGroupString);\n            if (spaceGroup == null) {\n                logger.warn(\"Space group '{}' not recognised as a standard space group\", spaceGroupString);\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setNonStandardSg(true);\n            } else {\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setSpaceGroup(spaceGroup);\n                structure.getPDBHeader()\n                        .getCrystallographicInfo()\n                        .setNonStandardSg(false);\n            }\n        }\n    }\n\n    @Override\n    public void finish() {\n        if (currentChain != null) {\n            currentChain.addGroup(currentGroup);\n\n            Optional<Chain> testChain = currentModel.stream()\n                    .filter(chain -> chain.getId().equals(currentChain.getId()))\n                    .findFirst();\n\n            if (!testChain.isPresent()) {\n                currentModel.add(currentChain);\n            }\n        } else if (!params.isHeaderOnly()) {\n            logger.warn(\"current chain is null at end of document.\");\n        }\n\n        allModels.add(currentModel);\n\n        initMaps();\n\n        for (int rowIndex = 0; rowIndex < structAsym.getRowCount(); rowIndex++) {\n            String id = structAsym.getId().get(rowIndex);\n            String entityId = structAsym.getEntityId().get(rowIndex);\n            logger.debug(\"Entity {} matches asym_id: {}\", entityId, id);\n\n            Chain chain = getEntityChain(entityId);\n            Chain seqRes = (Chain) chain.clone();\n            // to solve issue #160 (e.g. 3u7t)\n            seqRes = removeSeqResHeterogeneity(seqRes);\n            seqRes.setId(id);\n            seqRes.setName(asymId2authorId.getOrDefault(id, id));\n\n            EntityType type = EntityType.entityTypeFromString(getEntityType(entityId));\n            if (type == null || type == EntityType.POLYMER) {\n                seqResChains.add(seqRes);\n            }\n\n            logger.debug(\" seqres: {} {}<\", id, seqRes);\n            addEntity(rowIndex, entityId, getEntityDescription(entityId), getEntityType(entityId));\n        }\n\n        if (!structAsym.isDefined() || structAsym.getRowCount() == 0) {\n            logger.warn(\"No _struct_asym category in file, no SEQRES groups will be added.\");\n        }\n\n        // entities\n        // In addEntities above we created the entities if they were present in the file\n        // Now we need to make sure that they are linked to chains and also that if they are not present in the file we\n        // need to add them now\n        linkEntities();\n\n        // now that we know the entities, we can add all chains to structure so that they are stored\n        // properly as polymer/nonpolymer/water chains inside structure\n        allModels.forEach(structure::addModel);\n\n        // Only align if requested (default) and not when headerOnly mode with no Atoms.\n        // Otherwise, we store the empty SeqRes Groups unchanged in the right chains.\n        if (params.isAlignSeqRes() && !params.isHeaderOnly()){\n            logger.debug(\"Parsing mode align_seqres, will parse SEQRES and align to ATOM sequence\");\n            alignSeqRes();\n        } else {\n            logger.debug(\"Parsing mode unalign_seqres, will parse SEQRES but not align it to ATOM sequence\");\n            SeqRes2AtomAligner.storeUnAlignedSeqRes(structure, seqResChains, params.isHeaderOnly());\n        }\n\n        // Now make sure all altlocgroups have all the atoms in all the groups\n        StructureTools.cleanUpAltLocs(structure);\n\n        // NOTE bonds and charges can only be done at this point that the chain id mapping is properly sorted out\n        if (!params.isHeaderOnly()) {\n            if (params.shouldCreateAtomBonds()) {\n                addBonds();\n            }\n\n            if (params.shouldCreateAtomCharges()) {\n                addCharges();\n            }\n        }\n\n        if (!params.isHeaderOnly()) {\n            addSites();\n        }\n\n        // set the oligomeric state info in the header...\n        if (params.isParseBioAssembly()) {\n            // the more detailed mapping of chains to rotation operations happens in StructureIO...\n\n            Map<Integer, BioAssemblyInfo> bioAssemblies = new LinkedHashMap<>();\n            List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> structAssemblies = convert(structAssembly);\n            List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> structAssemblyGens = convert(structAssemblyGen);\n\n            for (org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly pdbxStructAssembly : structAssemblies) {\n                List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> pdbxStructAssemblyGens = structAssemblyGens.stream()\n                        .filter(sag -> sag.getAssembly_id().equals(pdbxStructAssembly.getId()))\n                        .collect(Collectors.toList());\n\n                BiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n                // these are the transformations that need to be applied to our model\n                List<BiologicalAssemblyTransformation> transformations = builder.getBioUnitTransformationList(pdbxStructAssembly,\n                        pdbxStructAssemblyGens, convert(structOpers));\n\n                int bioAssemblyId = -1;\n                try {\n                    bioAssemblyId = Integer.parseInt(pdbxStructAssembly.getId());\n                } catch (NumberFormatException e) {\n                    logger.info(\"Could not parse a numerical bio assembly id from '{}'\", pdbxStructAssembly.getId());\n                }\n\n                // if bioassembly id is not numerical we throw it away\n                // this happens usually for viral capsid entries, like 1ei7\n                // see issue #230 in github\n                if (bioAssemblyId != -1) {\n                    int mmSize = 0;\n                    // note that the transforms contain asym ids of both polymers and non-polymers\n                    // For the mmsize, we are only interested in the polymers\n                    for (BiologicalAssemblyTransformation transf : transformations) {\n                        Chain c = structure.getChain(transf.getChainId());\n                        if (c == null) {\n                            logger.info(\"Could not find asym id {} specified in struct_assembly_gen\", transf.getChainId());\n                            continue;\n                        }\n                        if (c.getEntityType() == EntityType.POLYMER &&\n                                // for entries like 4kro, sugars are annotated as polymers but we\n                                // don't want them in the macromolecularSize count\n                                !c.getEntityInfo().getDescription().contains(\"SUGAR\")) {\n                            mmSize++;\n                        }\n                    }\n\n                    BioAssemblyInfo bioAssembly = new BioAssemblyInfo();\n                    bioAssembly.setId(bioAssemblyId);\n                    bioAssembly.setMacromolecularSize(mmSize);\n                    bioAssembly.setTransforms(transformations);\n                    bioAssemblies.put(bioAssemblyId, bioAssembly);\n                }\n\n            }\n            structure.getPDBHeader()\n                    .setBioAssemblies(bioAssemblies);\n        }\n\n        setStructNcsOps();\n        setCrystallographicInfoMetadata();\n\n        Map<String,List<SeqMisMatch>> misMatchMap = new HashMap<>();\n        for (int rowIndex = 0; rowIndex < structRefSeqDif.getRowCount(); rowIndex++) {\n            SeqMisMatch seqMisMatch = new SeqMisMatchImpl();\n            seqMisMatch.setDetails(structRefSeqDif.getDetails().get(rowIndex));\n\n            String insCode = structRefSeqDif.getPdbxPdbInsCode().get(rowIndex);\n                if (insCode != null && insCode.equals(\"?\")) {\n                insCode = null;\n            }\n            seqMisMatch.setInsCode(insCode);\n            seqMisMatch.setOrigGroup(structRefSeqDif.getDbMonId().get(rowIndex));\n            seqMisMatch.setPdbGroup(structRefSeqDif.getMonId().get(rowIndex));\n            seqMisMatch.setPdbResNum(structRefSeqDif.getPdbxAuthSeqNum().get(rowIndex));\n            seqMisMatch.setUniProtId(structRefSeqDif.getPdbxSeqDbAccessionCode().get(rowIndex));\n            seqMisMatch.setSeqNum(structRefSeqDif.getSeqNum().get(rowIndex));\n\n            String strandId = structRefSeqDif.getPdbxPdbStrandId().get(rowIndex);\n            List<SeqMisMatch> seqMisMatches = misMatchMap.computeIfAbsent(strandId, k -> new ArrayList<>());\n            seqMisMatches.add(seqMisMatch);\n        }\n\n        for (String chainId : misMatchMap.keySet()){\n            Chain chain = structure.getPolyChainByPDB(chainId);\n            if (chain == null) {\n                logger.warn(\"Could not set mismatches for chain with author id {}\", chainId);\n                continue;\n            }\n\n            chain.setSeqMisMatches(misMatchMap.get(chainId));\n        }\n    }\n\n    private String getEntityType(String entityId) {\n        return IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .mapToObj(i -> entity.getType().get(i))\n                .findFirst()\n                .orElseThrow(() -> new NoSuchElementException(\"could not find entity with id \" + entityId));\n    }\n\n    private String getEntityDescription(String entityId) {\n        return IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .mapToObj(i -> entity.getPdbxDescription().get(i))\n                .findFirst()\n                .orElseThrow(() -> new NoSuchElementException(\"could not find entity with id \" + entityId));\n    }\n\n    private void addEntity(int asymRowIndex, String entityId, String pdbxDescription, String type) {\n        int eId = 0;\n        try {\n            eId = Integer.parseInt(entityId);\n        } catch (NumberFormatException e) {\n            logger.warn(\"Could not parse mol_id from string {}. Will use 0 for creating Entity\", entityId);\n        }\n        \n        int entityRowIndex = IntStream.range(0, entity.getRowCount())\n                .filter(i -> entity.getId().get(i).equals(entityId))\n                .findFirst()\n                .orElse(-1);\n        \n        EntityInfo entityInfo = structure.getEntityById(eId);\n        \n        if (entityInfo == null) {\n            entityInfo = new EntityInfo();\n            entityInfo.setMolId(eId);\n            // we only add the compound if a polymeric one (to match what the PDB parser does)\n            if (entityRowIndex != -1) {\n                entityInfo.setDescription(pdbxDescription);\n\n                EntityType eType = EntityType.entityTypeFromString(type);\n                if (eType != null) {\n                    entityInfo.setType(eType);\n                } else {\n                    logger.warn(\"Type '{}' is not recognised as a valid entity type for entity {}\", type, eId);\n                }\n                addAncilliaryEntityData(asymRowIndex, entityInfo);\n                structure.addEntityInfo(entityInfo);\n                logger.debug(\"Adding Entity with entity id {} from _entity, with name: {}\", eId, \n                        entityInfo.getDescription());\n            }\n        }\n    }\n\n    private void addAncilliaryEntityData(int asymRowIndex, EntityInfo entityInfo) {\n        // Loop through each of the entity types and add the corresponding data\n        // We're assuming if data is duplicated between sources it is consistent\n        // This is a potentially huge assumption...\n\n        for (int rowIndex = 0; rowIndex < entitySrcGen.getRowCount(); rowIndex++) {\n            if (entitySrcGen.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcGen(rowIndex, entityInfo);\n        }\n\n        for (int rowIndex = 0; rowIndex < entitySrcNat.getRowCount(); rowIndex++) {\n            if (entitySrcNat.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcNat(rowIndex, entityInfo);\n        }\n\n        for (int rowIndex = 0; rowIndex < entitySrcSyn.getRowCount(); rowIndex++) {\n            if (entitySrcSyn.getEntityId().get(rowIndex).equals(structAsym.getEntityId().get(asymRowIndex))) {\n                continue;\n            }\n\n            addInformationFromEntitySrcSyn(rowIndex, entityInfo);\n        }\n    }\n\n    private void addInformationFromEntitySrcSyn(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setOrganismCommon(entitySrcSyn.getOrganismCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcSyn.getOrganismScientific().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcSyn.getNcbiTaxonomyId().get(rowIndex));\n    }\n\n    private void addInformationFromEntitySrcNat(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setAtcc(entitySrcNat.getPdbxAtcc().get(rowIndex));\n        entityInfo.setCell(entitySrcNat.getPdbxCell().get(rowIndex));\n        entityInfo.setOrganismCommon(entitySrcNat.getCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcNat.getPdbxOrganismScientific().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcNat.getPdbxNcbiTaxonomyId().get(rowIndex));\n    }\n\n    private void addInformationFromEntitySrcGen(int rowIndex, EntityInfo entityInfo) {\n        entityInfo.setAtcc(entitySrcGen.getPdbxGeneSrcAtcc().get(rowIndex));\n        entityInfo.setCell(entitySrcGen.getPdbxGeneSrcCell().get(rowIndex));\n        entityInfo.setOrganismCommon(entitySrcGen.getGeneSrcCommonName().get(rowIndex));\n        entityInfo.setOrganismScientific(entitySrcGen.getPdbxGeneSrcScientificName().get(rowIndex));\n        entityInfo.setOrganismTaxId(entitySrcGen.getPdbxGeneSrcNcbiTaxonomyId().get(rowIndex));\n        entityInfo.setExpressionSystemTaxId(entitySrcGen.getPdbxHostOrgNcbiTaxonomyId().get(rowIndex));\n        entityInfo.setExpressionSystem(entitySrcGen.getPdbxHostOrgScientificName().get(rowIndex));\n    }\n\n    private void setStructNcsOps() {\n        List<Matrix4d> ncsOperators = new ArrayList<>();\n\n        for (int rowIndex = 0; rowIndex < structNcsOper.getRowCount(); rowIndex++) {\n            if (!\"generate\".equals(structNcsOper.getCode().get(rowIndex))) {\n                continue;\n            }\n\n            try {\n                Matrix4d operator = new Matrix4d();\n\n                operator.setElement(0, 0, structNcsOper.getMatrix11().get(rowIndex));\n                operator.setElement(0, 1, structNcsOper.getMatrix12().get(rowIndex));\n                operator.setElement(0, 2, structNcsOper.getMatrix13().get(rowIndex));\n\n                operator.setElement(1, 0, structNcsOper.getMatrix21().get(rowIndex));\n                operator.setElement(1, 1, structNcsOper.getMatrix22().get(rowIndex));\n                operator.setElement(1, 2, structNcsOper.getMatrix23().get(rowIndex));\n\n                operator.setElement(2, 0, structNcsOper.getMatrix31().get(rowIndex));\n                operator.setElement(2, 1, structNcsOper.getMatrix32().get(rowIndex));\n                operator.setElement(2, 2, structNcsOper.getMatrix33().get(rowIndex));\n\n                operator.setElement(3, 0, 0);\n                operator.setElement(3, 1, 0);\n                operator.setElement(3, 2, 0);\n                operator.setElement(3, 3, 1);\n\n                ncsOperators.add(operator);\n            } catch (NumberFormatException e) {\n                logger.warn(\"Error parsing doubles in NCS operator list, skipping operator {}\", rowIndex + 1);\n            }\n        }\n\n        if (ncsOperators.size() > 0) {\n            structure.getCrystallographicInfo()\n                    .setNcsOperators(ncsOperators.toArray(new Matrix4d[0]));\n        }\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList> convert(PdbxStructOperList structOpers) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structOpers.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList pdbxStructOperList =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructOperList();\n\n            pdbxStructOperList.setId(structOpers.getId().get(rowIndex));\n            pdbxStructOperList.setName(structOpers.getName().get(rowIndex));\n            pdbxStructOperList.setSymmetry_operation(structOpers.getSymmetryOperation().get(rowIndex));\n            pdbxStructOperList.setType(structOpers.getType().get(rowIndex));\n\n            pdbxStructOperList.setMatrix11(String.valueOf(structOpers.getMatrix11().get(rowIndex)));\n            pdbxStructOperList.setMatrix12(String.valueOf(structOpers.getMatrix12().get(rowIndex)));\n            pdbxStructOperList.setMatrix13(String.valueOf(structOpers.getMatrix13().get(rowIndex)));\n            pdbxStructOperList.setMatrix21(String.valueOf(structOpers.getMatrix21().get(rowIndex)));\n            pdbxStructOperList.setMatrix22(String.valueOf(structOpers.getMatrix22().get(rowIndex)));\n            pdbxStructOperList.setMatrix23(String.valueOf(structOpers.getMatrix23().get(rowIndex)));\n            pdbxStructOperList.setMatrix31(String.valueOf(structOpers.getMatrix31().get(rowIndex)));\n            pdbxStructOperList.setMatrix32(String.valueOf(structOpers.getMatrix32().get(rowIndex)));\n            pdbxStructOperList.setMatrix33(String.valueOf(structOpers.getMatrix33().get(rowIndex)));\n\n            pdbxStructOperList.setVector1(String.valueOf(structOpers.getVector1().get(rowIndex)));\n            pdbxStructOperList.setVector2(String.valueOf(structOpers.getVector2().get(rowIndex)));\n            pdbxStructOperList.setVector3(String.valueOf(structOpers.getVector3().get(rowIndex)));\n\n            re.add(pdbxStructOperList);\n        }\n        return re;\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> convert(PdbxStructAssemblyGen structAssemblyGen) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structAssemblyGen.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen pdbxStructAssemblyGen =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssemblyGen();\n\n            pdbxStructAssemblyGen.setAssembly_id(structAssemblyGen.getAssemblyId().get(rowIndex));\n            pdbxStructAssemblyGen.setAsym_id_list(structAssemblyGen.getAsymIdList().get(rowIndex));\n            pdbxStructAssemblyGen.setOper_expression(structAssemblyGen.getOperExpression().get(rowIndex));\n\n            re.add(pdbxStructAssemblyGen);\n        }\n        return re;\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> convert(PdbxStructAssembly structAssembly) {\n        List<org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly> re = new ArrayList<>();\n        for (int rowIndex = 0; rowIndex < structAssembly.getRowCount(); rowIndex++) {\n            org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly pdbxStructAssembly =\n                    new org.biojava.nbio.structure.io.mmcif.model.PdbxStructAssembly();\n\n            pdbxStructAssembly.setDetails(structAssembly.getDetails().get(rowIndex));\n            pdbxStructAssembly.setId(structAssembly.getId().get(rowIndex));\n            pdbxStructAssembly.setMethod_details(structAssembly.getMethodDetails().get(rowIndex));\n            pdbxStructAssembly.setOligomeric_count(structAssembly.getOligomericCount().getStringData(rowIndex));\n            pdbxStructAssembly.setOligomeric_details(structAssembly.getOligomericDetails().get(rowIndex));\n\n            re.add(pdbxStructAssembly);\n        }\n        return re;\n    }\n\n    private void setCrystallographicInfoMetadata() {\n        if (parsedScaleMatrix != null) {\n            PDBCrystallographicInfo crystalInfo = structure.getCrystallographicInfo();\n            boolean nonStd = false;\n            if (crystalInfo.getCrystalCell() != null && !crystalInfo.getCrystalCell().checkScaleMatrix(parsedScaleMatrix)) {\n                nonStd = true;\n            }\n\n            crystalInfo.setNonStandardCoordFrameConvention(nonStd);\n        }\n    }\n\n    private void addSites() {\n        List<Site> sites = structure.getSites();\n        if (sites == null) sites = new ArrayList<>();\n\n        for (int rowIndex = 0; rowIndex < structSiteGen.getRowCount(); rowIndex++) {\n            // For each StructSiteGen, find the residues involved, if they exist then\n            String site_id = structSiteGen.getSiteId().get(rowIndex); // multiple could be in same site.\n            if (site_id == null) {\n                site_id = \"\";\n            }\n            String comp_id = structSiteGen.getLabelCompId().get(rowIndex);  // PDBName\n\n            // Assumption: the author chain ID and residue number for the site is consistent with the original\n            // author chain id and residue numbers.\n\n            String asymId = structSiteGen.getLabelAsymId().get(rowIndex); // chain name\n            String authId = structSiteGen.getAuthAsymId().get(rowIndex); // chain Id\n            String auth_seq_id = structSiteGen.getAuthSeqId().get(rowIndex); // Res num\n\n            String insCode = structSiteGen.getPdbxAuthInsCode().get(rowIndex);\n            if (insCode != null && insCode.equals(\"?\")) {\n                insCode = null;\n            }\n\n            // Look for asymID = chainID and seqID = seq_ID.  Check that comp_id matches the resname.\n            Group g = null;\n            try {\n                Chain chain = structure.getChain(asymId);\n\n                if (null != chain) {\n                    try {\n                        Character insChar = null;\n                        if (null != insCode && insCode.length() > 0) {\n                            insChar = insCode.charAt(0);\n                        }\n                        g = chain.getGroupByPDB(new ResidueNumber(null, Integer.parseInt(auth_seq_id), insChar));\n                    } catch (NumberFormatException e) {\n                        logger.warn(\"Could not lookup residue : {}{}\", authId, auth_seq_id);\n                    }\n                }\n            } catch (StructureException e) {\n                logger.warn(\"Problem finding residue in site entry {} - {}\",\n                        structSiteGen.getSiteId().get(rowIndex), e.getMessage(), e.getMessage());\n            }\n\n            if (g != null) {\n                // 2. find the site_id, if not existing, create anew.\n                Site site = null;\n                for (Site asite : sites) {\n                    if (site_id.equals(asite.getSiteID())) {\n                        site = asite;\n                    }\n                }\n\n                boolean addSite = false;\n\n                // 3. add this residue to the site.\n                if (site == null) {\n                    addSite = true;\n                    site = new Site();\n                    site.setSiteID(site_id);\n                }\n\n                List<Group> groups = site.getGroups();\n                if (groups == null) {\n                    groups = new ArrayList<>();\n                }\n\n                // Check the self-consistency of the residue reference from auth_seq_id and chain_id\n                if (!comp_id.equals(g.getPDBName())) {\n                    logger.warn(\"comp_id doesn't match the residue at {} {} - skipping\", authId, auth_seq_id);\n                } else {\n                    groups.add(g);\n                    site.setGroups(groups);\n                }\n                if (addSite) {\n                    sites.add(site);\n                }\n            }\n        }\n        structure.setSites(sites);\n    }\n\n    private void addCharges() {\n        ChargeAdder.addCharges(structure);\n    }\n\n    /**\n     * The method will return a new reference to a Chain with any consecutive groups\n     * having same residue numbers removed.\n     * This is necessary to solve the microheterogeneity issue in entries like 3u7t (see github issue #160)\n     */\n    private static Chain removeSeqResHeterogeneity(Chain c) {\n        Chain trimmedChain = new ChainImpl();\n        ResidueNumber lastResNum = null;\n\n        for (Group g : c.getAtomGroups()) {\n            // note we have to deep copy this, otherwise they stay linked and would get altered in addGroup(g)\n            ResidueNumber currentResNum = new ResidueNumber(\n                    g.getResidueNumber().getChainName(),\n                    g.getResidueNumber().getSeqNum(),\n                    g.getResidueNumber().getInsCode());\n\n            if (lastResNum == null || !lastResNum.equals(currentResNum)) {\n                trimmedChain.addGroup(g);\n            } else {\n                logger.debug(\"Removing seqres group because it seems to be repeated in entity_poly_seq, most likely \" +\n                        \"has hetero='y': {}\", g);\n            }\n            lastResNum = currentResNum;\n\n        }\n        return trimmedChain;\n    }\n\n    private void addBonds() {\n        BondMaker maker = new BondMaker(structure, params);\n        maker.makeBonds();\n        maker.formBondsFromStructConn(convert(structConn));\n    }\n\n    private List<org.biojava.nbio.structure.io.mmcif.model.StructConn> convert(StructConn structConn) {\n        return IntStream.range(0, structConn.getRowCount())\n                .mapToObj(rowIndex -> {\n                    org.biojava.nbio.structure.io.mmcif.model.StructConn sc =\n                            new org.biojava.nbio.structure.io.mmcif.model.StructConn();\n\n                    sc.setPdbx_ptnr1_PDB_ins_code(structConn.getPdbxPtnr1PDBInsCode().get(rowIndex));\n                    sc.setPdbx_ptnr2_PDB_ins_code(structConn.getPdbxPtnr2PDBInsCode().get(rowIndex));\n                    sc.setPtnr1_auth_seq_id(structConn.getPtnr1AuthSeqId().getStringData(rowIndex));\n                    sc.setPtnr2_auth_seq_id(structConn.getPtnr2AuthSeqId().getStringData(rowIndex));\n                    sc.setPtnr1_label_comp_id(structConn.getPtnr1LabelCompId().get(rowIndex));\n                    sc.setPtnr2_label_comp_id(structConn.getPtnr2LabelCompId().get(rowIndex));\n                    sc.setPtnr1_label_atom_id(structConn.getPtnr1LabelAtomId().get(rowIndex));\n                    sc.setPtnr2_label_atom_id(structConn.getPtnr2LabelAtomId().get(rowIndex));\n                    sc.setPdbx_ptnr1_label_alt_id(structConn.getPdbxPtnr1LabelAltId().get(rowIndex));\n                    sc.setPdbx_ptnr2_label_alt_id(structConn.getPdbxPtnr2LabelAltId().get(rowIndex));\n                    sc.setPtnr1_symmetry(structConn.getPtnr1Symmetry().get(rowIndex));\n                    sc.setPtnr2_symmetry(structConn.getPtnr2Symmetry().get(rowIndex));\n                    sc.setConn_type_id(structConn.getConnTypeId().get(rowIndex));\n\n                    return sc;\n                })\n                .collect(Collectors.toList());\n    }\n\n    private void alignSeqRes() {\n        logger.debug(\"Parsing mode align_seqres, will align to ATOM to SEQRES sequence\");\n\n        // fix SEQRES residue numbering for all models\n\n        for (int model = 0; model < structure.nrModels(); model++) {\n            List<Chain> atomList   = structure.getModel(model);\n\n            for (Chain seqResChain : seqResChains){\n\n                // this extracts the matching atom chain from atomList\n                Chain atomChain = SeqRes2AtomAligner.getMatchingAtomRes(seqResChain, atomList, true);\n\n                if (atomChain == null) {\n                    // most likely there's no observed residues at all for the seqres chain: can't map\n                    // e.g. 3zyb: chains with asym_id L,M,N,O,P have no observed residues\n                    logger.info(\"Could not map SEQRES chain with asym_id={} to any ATOM chain. Most likely there's \" +\n                            \"no observed residues in the chain.\", seqResChain.getId());\n                    continue;\n                }\n\n                //map the atoms to the seqres...\n\n                // we need to first clone the seqres so that they stay independent for different models\n                List<Group> seqResGroups = new ArrayList<>();\n                for (int i = 0; i < seqResChain.getAtomGroups().size(); i++) {\n                    seqResGroups.add((Group)seqResChain.getAtomGroups().get(i).clone());\n                }\n\n                for (int seqResPos = 0 ; seqResPos < seqResGroups.size(); seqResPos++) {\n                    Group seqresG = seqResGroups.get(seqResPos);\n                    boolean found = false;\n                    for (Group atomG : atomChain.getAtomGroups()) {\n\n                        int internalNr = getInternalNr(atomG);\n\n                        if (seqresG.getResidueNumber().getSeqNum() == internalNr) {\n                            seqResGroups.set(seqResPos, atomG);\n                            found = true;\n                            break;\n                        }\n                    }\n\n                    if (!found)\n                        // so far the residue number has tracked internal numbering.\n                        // however there are no atom records, as such this can't be a PDB residue number...\n                        seqresG.setResidueNumber(null);\n                }\n                atomChain.setSeqResGroups(seqResGroups);\n            }\n        }\n    }\n\n    private int getInternalNr(Group atomG) {\n        if (atomG.getType().equals(GroupType.AMINOACID)) {\n            AminoAcidImpl aa = (AminoAcidImpl) atomG;\n            return (int) aa.getId();\n        } else if (atomG.getType().equals(GroupType.NUCLEOTIDE)) {\n            NucleotideImpl nu = (NucleotideImpl) atomG;\n            return (int) nu.getId();\n        } else {\n            HetatomImpl he = (HetatomImpl) atomG;\n            return (int) he.getId();\n        }\n    }\n\n    private void linkEntities() {\n        for (List<Chain> allModel : allModels) {\n            for (Chain chain : allModel) {\n                //logger.info(\"linking entities for \" + chain.getId() + \" \"  + chain.getName());\n                String entityId = asymId2entityId.get(chain.getId());\n\n                if (entityId == null) {\n                    // this can happen for instance if the cif file didn't have _struct_asym category at all\n                    // and thus we have no asymId2entityId mapping at all\n                    logger.info(\"No entity id could be found for chain {}\", chain.getId());\n                    continue;\n                }\n\n                int eId = Integer.parseInt(entityId);\n\n                // Entities are not added for non-polymeric entities, if a chain is non-polymeric its entity won't be found.\n                // TODO: add all entities and unique compounds and add methods to directly get polymer or non-polymer\n                // asyms (chains).  Either create a unique StructureImpl or modify existing for a better representation of the\n                // mmCIF internal data structures but is compatible with Structure interface.\n                // Some examples of PDB entries with this kind of problem:\n                //   - 2uub: asym_id X, chainName Z, entity_id 24: fully non-polymeric but still with its own chainName\n                //   - 3o6j: asym_id K, chainName Z, entity_id 6 : a single water molecule\n                //   - 1dz9: asym_id K, chainName K, entity_id 6 : a potassium ion alone\n\n                EntityInfo entityInfo = structure.getEntityById(eId);\n                if (entityInfo == null) {\n                    // Supports the case where the only chain members were from non-polymeric entity that is missing.\n                    // Solved by creating a new Compound(entity) to which this chain will belong.\n                    logger.info(\"Could not find an Entity for entity_id {}, for chain id {}, creating a new Entity.\",\n                            eId, chain.getId());\n                    entityInfo = new EntityInfo();\n                    entityInfo.setMolId(eId);\n                    entityInfo.addChain(chain);\n                    if (chain.isWaterOnly()) {\n                        entityInfo.setType(EntityType.WATER);\n                    } else {\n                        entityInfo.setType(EntityType.NONPOLYMER);\n                    }\n                    chain.setEntityInfo(entityInfo);\n                    structure.addEntityInfo(entityInfo);\n                } else {\n                    logger.debug(\"Adding chain with chain id {} (auth id {}) to Entity with entity_id {}\",\n                            chain.getId(), chain.getName(), eId);\n                    entityInfo.addChain(chain);\n                    chain.setEntityInfo(entityInfo);\n                }\n\n            }\n\n        }\n\n        // if no entity information was present in file we then go and find the entities heuristically with EntityFinder\n        List<EntityInfo> entityInfos = structure.getEntityInfos();\n        if (entityInfos == null || entityInfos.isEmpty()) {\n            List<List<Chain>> polyModels = new ArrayList<>();\n            List<List<Chain>> nonPolyModels = new ArrayList<>();\n            List<List<Chain>> waterModels = new ArrayList<>();\n\n            for (List<Chain> model : allModels) {\n                List<Chain> polyChains = new ArrayList<>();\n                List<Chain> nonPolyChains = new ArrayList<>();\n                List<Chain> waterChains = new ArrayList<>();\n\n                polyModels.add(polyChains);\n                nonPolyModels.add(nonPolyChains);\n                waterModels.add(waterChains);\n\n                for (Chain chain : model) {\n                    // we only have entities for polymeric chains, all others are ignored for assigning entities\n                    if (chain.isWaterOnly()) {\n                        waterChains.add(chain);\n                    } else if (chain.isPureNonPolymer()) {\n                        nonPolyChains.add(chain);\n                    } else {\n                        polyChains.add(chain);\n                    }\n                }\n            }\n\n            entityInfos = EntityFinder.findPolyEntities(polyModels);\n            EntityFinder.createPurelyNonPolyEntities(nonPolyModels, waterModels, entityInfos);\n\n            structure.setEntityInfos(entityInfos);\n        }\n\n        // final sanity check: it can happen that from the annotated entities some are not linked to any chains\n        // e.g. 3s26: a sugar entity does not have any chains associated to it (it seems to be happening with many sugar compounds)\n        // we simply log it, this can sign some other problems if the entities are used down the line\n        for (EntityInfo e : entityInfos) {\n            if (e.getChains().isEmpty()) {\n                logger.info(\"Entity {} '{}' has no chains associated to it\",\n                        e.getMolId() < 0 ? \"with no entity id\" : e.getMolId(), e.getDescription());\n            }\n        }\n    }\n\n    private void initMaps() {\n        if (structAsym == null || !structAsym.isDefined() || structAsym.getRowCount() == 0) {\n            logger.info(\"No _struct_asym category found in file. No asym id to entity_id mapping will be available\");\n            return;\n        }\n\n        Map<String, List<String>> entityId2asymId = new HashMap<>();\n        for (int rowIndex = 0; rowIndex < structAsym.getRowCount(); rowIndex++) {\n            String id = structAsym.getId().get(rowIndex);\n            String entityId = structAsym.getEntityId().get(rowIndex);\n\n            logger.debug(\"Entity {} matches asym_id: {}\", entityId, id);\n\n            asymId2entityId.put(id, entityId);\n\n            if (entityId2asymId.containsKey(entityId)) {\n                List<String> asymIds = entityId2asymId.get(entityId);\n                asymIds.add(id);\n            } else {\n                List<String> asymIds = new ArrayList<>();\n                asymIds.add(id);\n                entityId2asymId.put(entityId, asymIds);\n            }\n        }\n\n        if (entityPoly == null || !entityPoly.isDefined() || entityPoly.getRowCount() == 0) {\n            logger.info(\"No _entity_poly category found in file. No asym id to author id mapping will be available \" +\n                    \"for header only parsing\");\n            return;\n        }\n\n        for (int rowIndex = 0; rowIndex < entityPoly.getRowCount(); rowIndex++) {\n            if (!entityPoly.getPdbxStrandId().isDefined()) {\n                logger.info(\"_entity_poly.pdbx_strand_id is null for entity {}. Won't be able to map asym ids to \" +\n                        \"author ids for this entity.\", entityPoly.getEntityId().get(rowIndex));\n                break;\n            }\n\n            String[] chainNames = entityPoly.getPdbxStrandId().get(rowIndex).split(\",\");\n            List<String> asymIds = entityId2asymId.get(entityPoly.getEntityId().get(rowIndex));\n            if (chainNames.length != asymIds.size()) {\n                logger.warn(\"The list of asym ids (from _struct_asym) and the list of author ids (from _entity_poly) \" +\n                        \"for entity {} have different lengths! Can't provide a mapping from asym ids to author chain \" +\n                        \"ids\", entityPoly.getEntityId().get(rowIndex));\n                break;\n            }\n\n            for (int i = 0; i < chainNames.length; i++) {\n                asymId2authorId.put(asymIds.get(i), chainNames[i]);\n            }\n        }\n    }\n\n    @Override\n    public Structure getContainer() {\n        return structure;\n    }\n}\n","originTest":"package org.biojava.nbio.structure.test.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.*;\nimport org.biojava.nbio.structure.io.cif.CifFileConverter;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.rcsb.cif.CifReader;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Stream;\nimport java.util.zip.GZIPInputStream;\n\nimport static org.junit.Assert.*;\n\npublic class CifFileConsumerImplTest {\n    /**\n     * java.lang.NumberFormatException: multiple points have been thrown.\n     */\n    @Test\n    @Ignore(\"ignored for now as Bcif file source may change - currently using local files\")\n    public void testNumberFormat() {\n        Stream.of(\"1z4s\", \"4hec\", \"1dzw\", \"2y28\").forEach(pdbId -> {\n            System.out.println(pdbId);\n            Structure cif = loadLocalCif(pdbId);\n            assertNumberFormat(cif);\n            Structure bcif = loadLocalBcif(pdbId);\n            assertNumberFormat(bcif);\n        });\n    }\n\n    private Structure loadLocalCif(String pdbId) {\n        try {\n            String middle = pdbId.substring(1, 3);\n            return CifFileConverter.convert(CifReader.readText(new GZIPInputStream(Files.newInputStream(Paths.get(\"/var/pdb/\" + middle + \"/\" + pdbId + \".cif.gz\")))));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private Structure loadLocalBcif(String pdbId) {\n        try {\n            String middle = pdbId.substring(1, 3);\n            return CifFileConverter.convert(CifReader.readBinary(Files.newInputStream(Paths.get(\"/var/bcif/\" + middle + \"/\" + pdbId + \".bcif\"))));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private void assertNumberFormat(Structure structure) {\n        PDBHeader header = structure.getPDBHeader();\n        assertNotNull(header);\n        Date relDate = header.getRelDate();\n        assertNotNull(relDate);\n        Date modDate = header.getModDate();\n        assertNotNull(modDate);\n    }\n\n    @Test\n    @Ignore(\"ignore long-running test, do run to track performance\")\n    public void parseEntireArchive() throws IOException {\n        AtomicInteger counter = new AtomicInteger(0);\n        AtomicInteger failed = new AtomicInteger(0);\n        long start = System.nanoTime();\n        int chunkSize = 250;\n\n        Files.walk(Paths.get(\n                // change to your own paths\n//                \"/var/pdb/\" // cif\n                \"/var/bcif/\" // bcif\n        ))\n                .parallel()\n                .filter(path -> !Files.isDirectory(path))\n                .forEach(path -> {\n                    int count = counter.incrementAndGet();\n                    if (count % chunkSize == 0) {\n                        long end_chunk = System.nanoTime();\n                        System.out.println(\"[\" + count + \"] @ \" + (((end_chunk - start) /\n                                1_000 / count) + \" s per structure\"));\n                    }\n\n                    try {\n                        // the work is to obtain the CifFile instance and convert into a BioJava structure\n//                        CifFileConverter.convert(CifReader.readText(Files.newInputStream(path))); // cif\n                        CifFileConverter.convert(CifReader.readBinary(Files.newInputStream(path))); // bcif\n                    } catch (Exception e) {\n                        System.err.println(\"failed for \" + path.toFile().getAbsolutePath());\n                        e.printStackTrace();\n                        failed.incrementAndGet();\n                    }\n                });\n\n        long end = System.nanoTime();\n        System.out.println((end - start) / 1_000_000_000 + \" s\");\n        System.out.println(\"failed for \" + failed.intValue() + \" structures\");\n    }\n\n    private static boolean headerOnly;\n    private static boolean binary;\n\n    @Test\n    public void testLoad() throws IOException {\n        headerOnly = false;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadHeaderOnly() throws IOException {\n        headerOnly = true;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadBinary() throws IOException {\n        headerOnly = false;\n        binary = true;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadHeaderOnlyBinary() throws IOException {\n        headerOnly = true;\n        binary = true;\n        doTestLoad();\n    }\n\n    private void doTestLoad() throws IOException {\n        // test a simple protein\n        comparePDB2cif(\"5pti\",\"A\");\n\n        // test a protein with modified residues\n        comparePDB2cif(\"1a4w\",\"L\");\n        comparePDB2cif(\"1a4w\",\"H\");\n        comparePDB2cif(\"1a4w\",\"I\");\n\n        //non-standard encoded amino acid\n        comparePDB2cif(\"1fdo\",\"A\");\n\n        // test a DNA binding protein\n        comparePDB2cif(\"1j59\",\"A\");\n        comparePDB2cif(\"1j59\",\"E\");\n\n        // test a NMR protein\n        comparePDB2cif(\"2kc9\",\"A\");\n    }\n\n    private void comparePDB2cif(String id, String chainId) throws IOException {\n        String fileName = binary ? \"/\" + id + \".bcif\" : \"/\" + id + \".cif\";\n        System.out.println(fileName);\n        InputStream inStream = getClass().getResourceAsStream(fileName);\n        assertNotNull(\"Could not find file \" + fileName + \". Config problem?\" , inStream);\n\n        LocalPDBDirectory reader = binary ? new BcifFileReader() : new CifFileReader();\n\n        FileParsingParameters params = new FileParsingParameters();\n        params.setHeaderOnly(headerOnly);\n        reader.setFileParsingParameters(params);\n\n        Structure cifStructure = reader.getStructure(inStream);\n        assertNotNull(cifStructure);\n\n        // load the PDB file via the PDB parser\n        Structure pdbStructure;\n        InputStream pinStream = this.getClass().getResourceAsStream(\"/\" + id + \".pdb\");\n        assertNotNull(inStream);\n\n        PDBFileParser pdbParser = new PDBFileParser();\n        pdbParser.setFileParsingParameters(params);\n\n        pdbStructure = pdbParser.parsePDBFile(pinStream);\n\n        assertNotNull(pdbStructure);\n\n        // check NMR data\n        assertEquals(id + \": the isNMR flag is not the same!\",\n                pdbStructure.isNmr(),\n                cifStructure.isNmr());\n\n        if ( pdbStructure.isNmr()){\n            assertEquals(id + \": the nr of NMR models is not the same!\",\n                    pdbStructure.nrModels(),\n                    pdbStructure.nrModels());\n            checkNMR(pdbStructure);\n            checkNMR(cifStructure);\n        }\n\n        Chain a_pdb = pdbStructure.getPolyChainByPDB(chainId);\n        Chain a_cif = cifStructure.getPolyChainByPDB(chainId);\n\n        String pdb_SEQseq = a_pdb.getSeqResSequence();\n        String cif_SEQseq = a_cif.getSeqResSequence();\n\n        assertEquals(id + \": the SEQRES sequences don't match!\",\n                pdb_SEQseq,\n                cif_SEQseq);\n\n        assertEquals(id + \":  The nr of ATOM groups does not match!\",\n                a_pdb.getAtomGroups(GroupType.AMINOACID).size(),\n                a_cif.getAtomGroups(GroupType.AMINOACID).size());\n\n        // actually this check not necessarily works, since there can be waters in PDB that we don;t deal with yet in cif...\n        for (int i = 0 ; i < a_pdb.getAtomGroups(GroupType.AMINOACID).size(); i++){\n            Group gp = a_pdb.getAtomGroups(GroupType.AMINOACID).get(i);\n            List<Group> cifGroups = a_cif.getAtomGroups(GroupType.AMINOACID);\n            Group gc = cifGroups.get(i);\n            checkGroups(gp, gc);\n        }\n\n        String pdb_seq = a_pdb.getAtomSequence();\n        String cif_seq = a_cif.getAtomSequence();\n\n        assertEquals(\"the sequences obtained from PDB and mmCif don't match!\", pdb_seq, cif_seq);\n\n        List<DBRef> pdb_dbrefs= pdbStructure.getDBRefs();\n        List<DBRef> cif_dbrefs= cifStructure.getDBRefs();\n\n        assertEquals(\"nr of DBrefs found does not match!\", pdb_dbrefs.size(), cif_dbrefs.size());\n\n        DBRef p = pdb_dbrefs.get(0);\n        DBRef c = cif_dbrefs.get(0);\n\n        String pdb_dbref = p.toPDB();\n        String cif_dbref = c.toPDB();\n        assertEquals(\"DBRef is not equal\", pdb_dbref, cif_dbref);\n\n        PDBHeader h1 = pdbStructure.getPDBHeader();\n        PDBHeader h2 = cifStructure.getPDBHeader();\n\n        if (!h1.toPDB().toUpperCase().equals(h2.toPDB().toUpperCase())) {\n            System.err.println(h1.toPDB());\n            System.err.println(h2.toPDB());\n            assertEquals(h1.toPDB(), h2.toPDB());\n        }\n        assertEquals(\"the PDBHeader.toPDB representation is not equivalent\",\n                h1.toPDB().toUpperCase(),\n                h2.toPDB().toUpperCase());\n    }\n\n    private void checkGroups(Group g1, Group g2){\n        String pdbId1 = g1.getChain().getStructure().getPDBCode();\n        String pdbId2 = g1.getChain().getStructure().getPDBCode();\n        assertEquals(pdbId1, pdbId2);\n\n        assertEquals(g1.getType(), g2.getType());\n        assertEquals(g1.getResidueNumber().getSeqNum(), g2.getResidueNumber().getSeqNum());\n        assertEquals(g1.getResidueNumber().getInsCode(), g2.getResidueNumber().getInsCode());\n        assertEquals(g1.getPDBName(), g2.getPDBName());\n        assertEquals(g1.has3D(), g2.has3D());\n\n        assertEquals(g1.hasAltLoc(), g2.hasAltLoc());\n        assertEquals(pdbId1 + \":\" + g1 + \" - \" + pdbId2 + \":\"+ g2, g1.getAltLocs().size(), g2.getAltLocs().size());\n        assertEquals(pdbId1 + \":\" + g1 + \" - \" + pdbId2 + \":\"+ g2, g1.getAtoms().size(), g2.getAtoms().size());\n\n        if (g1.has3D()){\n            Atom a1 = g1.getAtom(0);\n            Atom a2 = g2.getAtom(0);\n            if ( a1 == null)\n                fail(\"could not get atom for group \" + g1);\n            if (a2 == null)\n                fail(\"could not get atom for group \" + g2);\n            assertEquals(a1.getX(),a2.getX(), 0.0001);\n            assertEquals(a1.getOccupancy(), a2.getOccupancy(), 0.0001);\n            assertEquals(a1.getTempFactor(), a2.getTempFactor(), 0.0001);\n            assertEquals(a1.getName(), a2.getName());\n        }\n    }\n\n    private void checkNMR(Structure s){\n        assertTrue(s.isNmr());\n        int models = s.nrModels();\n        assertTrue(models > 0);\n        List<Chain> model0 = s.getModel(0);\n\n        // compare with all others\n        for (int i = 1 ; i < models; i++){\n            List<Chain> modelX = s.getModel(i);\n            assertEquals(model0.size(),modelX.size());\n\n            // compare lengths:\n            for (int j=0 ; j< model0.size(); j++){\n                Chain c1 = model0.get(j);\n                Chain cx = modelX.get(j);\n                assertEquals(c1.getAtomLength(), cx.getAtomLength());\n                assertEquals(c1.getAtomSequence(), cx.getAtomSequence());\n                assertEquals(c1.getAtomGroups(GroupType.AMINOACID).size(), cx.getAtomGroups(GroupType.AMINOACID).size());\n                assertEquals(c1.getAtomGroups(GroupType.NUCLEOTIDE).size(), cx.getAtomGroups(GroupType.NUCLEOTIDE).size());\n                assertEquals(c1.getAtomGroups(GroupType.HETATM).size(), cx.getAtomGroups(GroupType.HETATM).size());\n            }\n        }\n    }\n}","changedTest":"package org.biojava.nbio.structure.test.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.*;\nimport org.biojava.nbio.structure.io.cif.CifFileConverter;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.rcsb.cif.CifReader;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPInputStream;\n\nimport static org.junit.Assert.*;\n\npublic class CifFileConsumerImplTest {\n    @Test\n    @Ignore(\"ignored for now as Bcif file source may change - currently using local files\")\n    public void testFailingEntries() {\n        Pattern.compile(\", \").splitAsStream(\"4he8, 1z4u, 4fp1, 1blc, 4cit, 2y2y, 4exq, 2n0f, 2d9o, 2v16, 1kqv, \" +\n                \"1bwo, 2k2g, 1qhd, 5mhj, 2dn3, 5pq8, 5cay, 6ms1, 2vhu, 2gi0, 3swe, 3daz, 5yel, 2pxp, 4uis, 3cs1, 3in5,\" +\n                \" 1sl3, 4hjc, 3hj2, 5kpi, 1gyq, 1yq8, 4yqz, 1ox3, 2pls, 1vne, 4q02, 1dtt, 1jau, 5h3b, 5sxk, 4el7, 5q7w,\" +\n                \" 4zuz, 1n6i, 1dhg, 3dhe, 2gpo, 5if7, 5ld8, 1jhz, 4fr3, 1r6u, 3hdl, 5fse, 1iho, 1t10, 2oc6, 3czx, 3b3o,\" +\n                \" 5i6w, 2ecv, 4l2x, 441d, 2i0x, 1xq4, 3tbb, 4mmz, 1qew, 6i16, 1t8d, 5w7r, 6gm1, 1s7u, 2qp3, 1cf3, 4myb,\" +\n                \" 1omh, 1zog, 2b68, 1nqb, 1t7k\")\n                .parallel()\n                .forEach(pdbId -> {\n                    System.out.println(pdbId);\n                    Structure cif = loadLocalCif(pdbId);\n                    assertNumberFormat(cif);\n                    Structure bcif = loadLocalBcif(pdbId);\n                    assertNumberFormat(bcif);\n                });\n    }\n\n    private Structure loadLocalCif(String pdbId) {\n        try {\n            String middle = pdbId.substring(1, 3);\n            return CifFileConverter.convert(CifReader.readText(new GZIPInputStream(Files.newInputStream(Paths.get(\"/var/pdb/\" + middle + \"/\" + pdbId + \".cif.gz\")))));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private Structure loadLocalBcif(String pdbId) {\n        try {\n            String middle = pdbId.substring(1, 3);\n            return CifFileConverter.convert(CifReader.readBinary(Files.newInputStream(Paths.get(\"/var/bcif/\" + middle + \"/\" + pdbId + \".bcif\"))));\n        } catch (IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    private void assertNumberFormat(Structure structure) {\n        PDBHeader header = structure.getPDBHeader();\n        assertNotNull(header);\n        Date relDate = header.getRelDate();\n        assertNotNull(relDate);\n        Date modDate = header.getModDate();\n        assertNotNull(modDate);\n    }\n\n    /**\n     * Performance diary;\n     *\n     * 05/01/19 - ciftools v0.3.0, parallel, bcif, non-gzipped, 12 worker threads\n     * 918 s for 151079 structures, 6073 s per structure, failed for 0 entries\n     *\n     * @throws IOException propagated\n     */\n    @Test\n    @Ignore(\"ignore long-running test, do run to track performance\")\n    public void parseEntireArchive() throws IOException {\n        AtomicInteger counter = new AtomicInteger(0);\n        long start = System.nanoTime();\n        int chunkSize = 250;\n        List<String> failed = Collections.synchronizedList(new ArrayList<>());\n\n        Files.walk(Paths.get(\n                // change to your own paths\n//                \"/var/pdb/\" // cif\n                \"/var/bcif/\" // bcif\n        ))\n                .parallel()\n                .filter(path -> !Files.isDirectory(path))\n                .forEach(path -> {\n                    int count = counter.incrementAndGet();\n                    if (count % chunkSize == 0) {\n                        long end_chunk = System.nanoTime();\n                        System.out.println(\"[\" + count + \"] @ \" + (((end_chunk - start) /\n                                1_000 / count) + \" s per structure\"));\n                    }\n\n                    try {\n                        // the work is to obtain the CifFile instance and convert into a BioJava structure\n//                        CifFileConverter.convert(CifReader.readText(Files.newInputStream(path))); // cif\n                        CifFileConverter.convert(CifReader.readBinary(Files.newInputStream(path))); // bcif\n                    } catch (Exception e) {\n                        System.err.println(\"failed for \" + path.toFile().getAbsolutePath());\n                        e.printStackTrace();\n                        failed.add(path.toFile().getName().split(\"\\\\.\")[0]);\n                    }\n                });\n\n        long end = System.nanoTime();\n        System.out.println((end - start) / 1_000_000_000 + \" s\");\n        System.out.println(\"failed for \" + failed.size() + \" structures\");\n        System.out.println(\"failed ids: \" + failed);\n    }\n\n    private static boolean headerOnly;\n    private static boolean binary;\n\n    @Test\n    public void testLoad() throws IOException {\n        headerOnly = false;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadHeaderOnly() throws IOException {\n        headerOnly = true;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadBinary() throws IOException {\n        headerOnly = false;\n        binary = true;\n        doTestLoad();\n    }\n\n    @Test\n    public void testLoadHeaderOnlyBinary() throws IOException {\n        headerOnly = true;\n        binary = true;\n        doTestLoad();\n    }\n\n    private void doTestLoad() throws IOException {\n        // test a simple protein\n        comparePDB2cif(\"5pti\",\"A\");\n\n        // test a protein with modified residues\n        comparePDB2cif(\"1a4w\",\"L\");\n        comparePDB2cif(\"1a4w\",\"H\");\n        comparePDB2cif(\"1a4w\",\"I\");\n\n        //non-standard encoded amino acid\n        comparePDB2cif(\"1fdo\",\"A\");\n\n        // test a DNA binding protein\n        comparePDB2cif(\"1j59\",\"A\");\n        comparePDB2cif(\"1j59\",\"E\");\n\n        // test a NMR protein\n        comparePDB2cif(\"2kc9\",\"A\");\n    }\n\n    private void comparePDB2cif(String id, String chainId) throws IOException {\n        String fileName = binary ? \"/\" + id + \".bcif\" : \"/\" + id + \".cif\";\n        System.out.println(fileName);\n        InputStream inStream = getClass().getResourceAsStream(fileName);\n        assertNotNull(\"Could not find file \" + fileName + \". Config problem?\" , inStream);\n\n        LocalPDBDirectory reader = binary ? new BcifFileReader() : new CifFileReader();\n\n        FileParsingParameters params = new FileParsingParameters();\n        params.setHeaderOnly(headerOnly);\n        reader.setFileParsingParameters(params);\n\n        Structure cifStructure = reader.getStructure(inStream);\n        assertNotNull(cifStructure);\n\n        // load the PDB file via the PDB parser\n        Structure pdbStructure;\n        InputStream pinStream = this.getClass().getResourceAsStream(\"/\" + id + \".pdb\");\n        assertNotNull(inStream);\n\n        PDBFileParser pdbParser = new PDBFileParser();\n        pdbParser.setFileParsingParameters(params);\n\n        pdbStructure = pdbParser.parsePDBFile(pinStream);\n\n        assertNotNull(pdbStructure);\n\n        // check NMR data\n        assertEquals(id + \": the isNMR flag is not the same!\",\n                pdbStructure.isNmr(),\n                cifStructure.isNmr());\n\n        if ( pdbStructure.isNmr()){\n            assertEquals(id + \": the nr of NMR models is not the same!\",\n                    pdbStructure.nrModels(),\n                    pdbStructure.nrModels());\n            checkNMR(pdbStructure);\n            checkNMR(cifStructure);\n        }\n\n        Chain a_pdb = pdbStructure.getPolyChainByPDB(chainId);\n        Chain a_cif = cifStructure.getPolyChainByPDB(chainId);\n\n        String pdb_SEQseq = a_pdb.getSeqResSequence();\n        String cif_SEQseq = a_cif.getSeqResSequence();\n\n        assertEquals(id + \": the SEQRES sequences don't match!\",\n                pdb_SEQseq,\n                cif_SEQseq);\n\n        assertEquals(id + \":  The nr of ATOM groups does not match!\",\n                a_pdb.getAtomGroups(GroupType.AMINOACID).size(),\n                a_cif.getAtomGroups(GroupType.AMINOACID).size());\n\n        // actually this check not necessarily works, since there can be waters in PDB that we don;t deal with yet in cif...\n        for (int i = 0 ; i < a_pdb.getAtomGroups(GroupType.AMINOACID).size(); i++){\n            Group gp = a_pdb.getAtomGroups(GroupType.AMINOACID).get(i);\n            List<Group> cifGroups = a_cif.getAtomGroups(GroupType.AMINOACID);\n            Group gc = cifGroups.get(i);\n            checkGroups(gp, gc);\n        }\n\n        String pdb_seq = a_pdb.getAtomSequence();\n        String cif_seq = a_cif.getAtomSequence();\n\n        assertEquals(\"the sequences obtained from PDB and mmCif don't match!\", pdb_seq, cif_seq);\n\n        List<DBRef> pdb_dbrefs= pdbStructure.getDBRefs();\n        List<DBRef> cif_dbrefs= cifStructure.getDBRefs();\n\n        assertEquals(\"nr of DBrefs found does not match!\", pdb_dbrefs.size(), cif_dbrefs.size());\n\n        DBRef p = pdb_dbrefs.get(0);\n        DBRef c = cif_dbrefs.get(0);\n\n        String pdb_dbref = p.toPDB();\n        String cif_dbref = c.toPDB();\n        assertEquals(\"DBRef is not equal\", pdb_dbref, cif_dbref);\n\n        PDBHeader h1 = pdbStructure.getPDBHeader();\n        PDBHeader h2 = cifStructure.getPDBHeader();\n\n        if (!h1.toPDB().toUpperCase().equals(h2.toPDB().toUpperCase())) {\n            System.err.println(h1.toPDB());\n            System.err.println(h2.toPDB());\n            assertEquals(h1.toPDB(), h2.toPDB());\n        }\n        assertEquals(\"the PDBHeader.toPDB representation is not equivalent\",\n                h1.toPDB().toUpperCase(),\n                h2.toPDB().toUpperCase());\n    }\n\n    private void checkGroups(Group g1, Group g2){\n        String pdbId1 = g1.getChain().getStructure().getPDBCode();\n        String pdbId2 = g1.getChain().getStructure().getPDBCode();\n        assertEquals(pdbId1, pdbId2);\n\n        assertEquals(g1.getType(), g2.getType());\n        assertEquals(g1.getResidueNumber().getSeqNum(), g2.getResidueNumber().getSeqNum());\n        assertEquals(g1.getResidueNumber().getInsCode(), g2.getResidueNumber().getInsCode());\n        assertEquals(g1.getPDBName(), g2.getPDBName());\n        assertEquals(g1.has3D(), g2.has3D());\n\n        assertEquals(g1.hasAltLoc(), g2.hasAltLoc());\n        assertEquals(pdbId1 + \":\" + g1 + \" - \" + pdbId2 + \":\"+ g2, g1.getAltLocs().size(), g2.getAltLocs().size());\n        assertEquals(pdbId1 + \":\" + g1 + \" - \" + pdbId2 + \":\"+ g2, g1.getAtoms().size(), g2.getAtoms().size());\n\n        if (g1.has3D()){\n            Atom a1 = g1.getAtom(0);\n            Atom a2 = g2.getAtom(0);\n            if ( a1 == null)\n                fail(\"could not get atom for group \" + g1);\n            if (a2 == null)\n                fail(\"could not get atom for group \" + g2);\n            assertEquals(a1.getX(),a2.getX(), 0.0001);\n            assertEquals(a1.getOccupancy(), a2.getOccupancy(), 0.0001);\n            assertEquals(a1.getTempFactor(), a2.getTempFactor(), 0.0001);\n            assertEquals(a1.getName(), a2.getName());\n        }\n    }\n\n    private void checkNMR(Structure s){\n        assertTrue(s.isNmr());\n        int models = s.nrModels();\n        assertTrue(models > 0);\n        List<Chain> model0 = s.getModel(0);\n\n        // compare with all others\n        for (int i = 1 ; i < models; i++){\n            List<Chain> modelX = s.getModel(i);\n            assertEquals(model0.size(),modelX.size());\n\n            // compare lengths:\n            for (int j=0 ; j< model0.size(); j++){\n                Chain c1 = model0.get(j);\n                Chain cx = modelX.get(j);\n                assertEquals(c1.getAtomLength(), cx.getAtomLength());\n                assertEquals(c1.getAtomSequence(), cx.getAtomSequence());\n                assertEquals(c1.getAtomGroups(GroupType.AMINOACID).size(), cx.getAtomGroups(GroupType.AMINOACID).size());\n                assertEquals(c1.getAtomGroups(GroupType.NUCLEOTIDE).size(), cx.getAtomGroups(GroupType.NUCLEOTIDE).size());\n                assertEquals(c1.getAtomGroups(GroupType.HETATM).size(), cx.getAtomGroups(GroupType.HETATM).size());\n            }\n        }\n    }\n}","commitMessage":"replaces SimpleDateFormat with mature implementation\n\n- solves Exceptions in binary parsing + speed-up (?)\n- Exception were parsing exceptions from the prominent Date class when executing in parallel. Not possible to reproduce, but omitted by changing to robust, thread-safe number parsing class.\n","test_commitMessage":"replaces SimpleDateFormat with mature implementation\n\n- solves Exceptions in binary parsing + speed-up (?)\n- Exception were parsing exceptions from the prominent Date class when executing in parallel. Not possible to reproduce, but omitted by changing to robust, thread-safe number parsing class.\n","allZero":false}