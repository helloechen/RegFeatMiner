{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/SecStrucPred.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestSecStrucPred.java","prod_time":"2015-10-12 15:55:00","test_time":"2015-10-12 15:55:00","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":4,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":5,"del_annotation_line":0,"del_call_line":11,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":1,"label":"POSITIVE","prod_commitID":"4b14b6f41d426f6a2810ad244c0be829c9f9047c","test_commitID":"4b14b6f41d426f6a2810ad244c0be829c9f9047c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n * @since 1.5\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** \n * Calculate and assign the secondary structure (SS) to the \n * Groups of a Structure object. This object also stores the result\n * of the prediction.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>. \n * Some parts are also taken from: T.E.Creighton, Proteins - \n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n * \n * @author Andreas Prlic\n * @author Aleix Lafita\n * \n */\npublic class SecStrucPred {\n\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(SecStrucPred.class);\n\n\t/** the minimal distance between two residues */\n\tpublic static final double MINDIST = 0.5;\n\n\t/** the minimal distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static final int CA_MIN_DIST = 9;\n\n\t/** Minimal H-bond energy in cal/mol */\n\tpublic static final int HBONDLOWENERGY  = -9900;\n\n\t/** higher limit for H-bond energy */\n\tpublic static final double HBONDHIGHENERGY = -500.0;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t *      f  *  q1 *   q2  *  scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\tpublic static final double Q = -27888.0;\n\n\tprivate SecStrucGroup[] groups;\n\tprivate List<Ladder> ladders;\n\n\tpublic SecStrucPred(){\n\t\tladders = new ArrayList<Ladder>();\n\t}\n\n\t/** \n\t * Predicts the secondary structure of this Structure object,\n\t * using a DSSP implementation.\n\t *\n\t * @param s Structure to predict the SS\n\t * @param assign sets the SS information to the Groups of s\n\t * @return a List of SS annotation objects\n\t */\n\tpublic List<SecStrucState> predict(Structure s, boolean assign) \n\t\t\tthrows StructureException {\n\n\t\tgroups = initGroupArray(s);\n\n\t\tif (groups.length < 5) {\n\t\t\t// not enough groups to do anything\n\t\t\tthrow new StructureException(\"Not enough backbone groups in the\"\n\t\t\t\t\t+ \" Structure to calculate the secondary structure (\"\n\t\t\t\t\t+ groups.length+\" given, minimum 5)\" );\n\t\t}\n\n\t\tcalculateHAtoms();\n\t\tcalculateHBonds();\n\t\tcalculateDihedralAngles();\n\n\t\tcalculateTurns();\n\t\tbuildHelices();\n\t\t\n\t\tdetectBends();\n\t\tdetectStrands();\n\t\t\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\tfor (SecStrucGroup sg : groups){\n\t\t\tSecStrucState ss = (SecStrucState) \n\t\t\t\t\tsg.getProperty(Group.SEC_STRUC);\n\t\t\t//Add to return list and assign to original if flag is true\n\t\t\tsecstruc.add(ss);\n\t\t\tif (assign) sg.getOriginal().setProperty(Group.SEC_STRUC, ss);\n\t\t}\n\t\treturn secstruc;\t\n\t}\n\n\tprivate void detectStrands() {\n\n\t\tfor (int i =1 ; i < groups.length -1 ;i++){\n\t\t\ttestBridge(i);\n\t\t}\n\n\t\t// detect beta bulges\n\t\tconnectLadders();\n\n\t\t// and store results for Sheets and Strands\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void updateSheets() {\n\t\t\n\t\tlogger.debug(\" got \" +ladders.size() + \"  ladders!\");\n\t\t\n\t\tfor (Ladder ladder : ladders){\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor (int lcount = ladder.from; lcount <= ladder.to; lcount++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getType();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getType();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t\ttestSetExtendedSecStrucState(l2count);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( !stype.isHelixType() && \n\t\t\t\t\t\t\t( !stype.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'\n\n\t\t\tif (ladder.connectedTo == 0) continue;\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif (ladder.btype.equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor (int lcount = ladder.from; lcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate void testSetExtendedSecStrucState(int lcount) {\n\t\t\n\t\tSecStrucState state = getSecStrucState(lcount);\n\t\tSecStrucType stype = state.getType();\n\t\tif (!stype.isHelixType()){\n\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor (int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size() ; j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif (hasBulge(l1,l2) ) {\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\tlogger.debug(\"Bulge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\t\t\n\t\tboolean bulge = ( (l1.btype.equals(l2.btype) ) &&\n\t\t\t\t( l2.from - l1.to < 6) &&\n\t\t\t\t( l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0) );\n\n\t\tif (!bulge) return bulge;\n\n\t\tswitch(l1.btype){\n\t\tcase parallel:\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase antiparallel:\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3))\n\t\t\t\t\t);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn bulge;\n\t}\n\n\tprivate void registerBridge(int i, int j, BridgeType btype) {\n\t\t\n\t\tif (i > j) {\n\t\t\tlogger.warn(\"Trying to connect ladder where i > j\");\n\t\t\treturn;\n\t\t}\n\n\t\tboolean found = false;\n\t\tfor (Ladder ladder : ladders){\n\t\t\tif (shouldExtendLadder(ladder, i, j, btype)) {\n\t\t\t\tfound = true;\n\t\t\t\tladder.to++; //we go forward in this direction\n\t\t\t\tswitch(btype){\n\t\t\t\tcase parallel:\n\t\t\t\t\tladder.lto++; //increment second strand\n\t\t\t\t\tbreak;\n\t\t\t\tcase antiparallel:\n\t\t\t\t\tladder.lfrom--; //decrement second strand\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found){\n\t\t\t// create new ladder with a single bridge\n\t\t\tLadder l = new Ladder();\n\t\t\tl.from = i;\n\t\t\tl.to = i;\n\t\t\tl.lfrom = j;\n\t\t\tl.lto = j;\n\t\t\tl.btype = btype;\n\t\t\tladders.add(l);\n\t\t}\n\n\t}\n\n\tprivate boolean shouldExtendLadder(Ladder ladder, int start, \n\t\t\tint end, BridgeType btype) {\n\n\t\treturn ( (btype.equals(ladder.btype) ) &&\n\t\t\t\t( start  == ladder.to +1) &&\n\t\t\t\t(\n\t\t\t\t\t\t(( end == ladder.lto + 1) &&\n\t\t\t\t\t\t\t\t( btype.equals(BridgeType.parallel) )) ||\n\t\t\t\t\t\t\t\t(( end == ladder.lfrom - 1 ) &&\n\t\t\t\t\t\t\t\t\t\t(btype.equals(BridgeType.parallel)))\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t) );\n\t\t//TODO suspicious that antiparallel is not used...\n\t}\n\n\tprivate void testBridge(int i) {\n\t\t\n\t\tint j = i + 3; //sum 3 for the non-overlapping condition\n\t\t\n\t\tfor (int foundNrBridges = 0; foundNrBridges < 2\n\t\t\t\t&& (j < groups.length-1); j++){\n\n\t\t\tBridgeType btype = null;\n\n\t\t\tif ((isBonded(i-1, j) && isBonded(j, i+1) ) ||\n\t\t\t\t\t(isBonded(j-1, i) && isBonded(i, j+1)) ) {\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ((isBonded(i, j) && isBonded(j, i)) ||\n\t\t\t\t\t(isBonded(i-1,j+1) && (isBonded(j-1, i+1)))) {\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tfoundNrBridges++;\n\t\t\t\tregisterBridge(i, j, btype);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void detectBends() {\n\n\t\tfor (int i = 2 ; i < groups.length -2 ;i++){\n\n\t\t\t//Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i + 2 )\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle = Calc.angle(caminus2, caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i); \n\n\t\t\tstate.setKappa((float) angle);\n\n\t\t\t//Angles = 360 should be discarded\n\t\t\tif (angle > 70.0 && angle < 359.9) {\n\t\t\t\tif (state.getType().equals(SecStrucType.coil)) {\n\t\t\t\t\tstate.setType(SecStrucType.bend);\n\t\t\t\t}\n\t\t\t\tstate.setBend(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles() throws StructureException {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState) \n\t\t\t\t\ta.getProperty(Group.SEC_STRUC);\n\t\t\tSecStrucState state2 = (SecStrucState) \n\t\t\t\t\tb.getProperty(Group.SEC_STRUC);\n\t\t\t\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\t\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     \"\n\t\t\t\t+ \"N-H-->O    O-->H-N    N-H-->O    O-->H-N    \"\n\t\t\t\t+ \"TCO  KAPPA ALPHA  PHI    PSI    \"\n\t\t\t\t+ \"X-CA   Y-CA   Z-CA \");\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tbuf.append(nl);\n\t\t\tSecStrucState ss = \n\t\t\t\t\t(SecStrucState) groups[i].getProperty(Group.SEC_STRUC);\n\t\t\tbuf.append(ss.printDSSPline(i));\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\t\n\t\tif (!(o instanceof SecStrucPred)) return false;\n\t\telse {\n\t\t\tSecStrucPred ss = (SecStrucPred) o;\n\t\t\tif (groups.length != ss.groups.length) return false;\n\t\t\t\n\t\t\tfor (int g=0; g<groups.length; g++){\n\t\t\t\tSecStrucInfo g1 = getSecStrucState(g);\n\t\t\t\tSecStrucInfo g2 = ss.getSecStrucState(g);\n\t\t\t\tif (!g1.equals(g2)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t\n\t\tfor ( Chain c : s.getChains()){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\t\t\t\t\n\t\t\t\t//We can also calc secstruc if it is a modified amino acid\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\t\t\t\t\t\n\t\t\t\t\tSecStrucState state = new SecStrucState(sg, \n\t\t\t\t\t\t\tSecStrucInfo.BIOJAVA_ASSIGNMENT, \n\t\t\t\t\t\t\tSecStrucType.coil);\n\t\t\t\t\t\n\t\t\t\t\tsg.setProperty(Group.SEC_STRUC, state);\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/** \n\t * Calculate the coordinates of the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location.\n\t */\n\tprivate void calculateHAtoms() throws StructureException {\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( !b.hasAtom(\"H\") ) {\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(), b.getN());\n\t\t\t\tb.setH(H);\n\t\t\t\t//First residue skipped, unable to calc H for it TODO\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \n\t * Calculate the HBonds between different groups.\n\t * see Creighton page 147 f\n\t */\n\tprivate void calculateHBonds() throws StructureException {\n\n\t\tif (groups.length < 5) return;\n\n\t\tfor (int i=0 ; i < groups.length ; i++){\n\n\t\t\tSecStrucGroup one = groups[i];\n\n\t\t\tfor (int j=i+1 ; j<groups.length ; j++){\n\n\t\t\t\tSecStrucGroup two = groups[j];\n\n\t\t\t\t//if distance too big - for sure no HBonds - sppedup\n\t\t\t\tdouble dist = Calc.getDistance(one.getCA(),two.getCA());\n\t\t\t\tif (dist >= CA_MIN_DIST) continue;\n\n\t\t\t\tcheckAddHBond(i,j);\n\n\t\t\t\t//\"backwards\" hbonds are not allowed\n\t\t\t\tif (j!=(i+1)) checkAddHBond(j,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\t\t\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\t\tif (!one.hasAtom(\"H\")) {\n\t\t\tlogger.debug(\"Residue \"+one.getResidueNumber()+\" has no H\");\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\t\t\n\t\tdouble energy = 0;\n\t\t\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\tlogger.warn(\"Energy calculation failed\", e);\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug(\"Energy between positions (\"+i+\",\"+j+\"): \"+energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/**\n\t * Calculate HBond energy of two groups in cal/mol\n\t * see Creighton page 147 f\n\t * <p>\n\t * Jeffrey, George A., An introduction to hydrogen bonding, \n\t * Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t * Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t */\n\tprivate static double calculateHBondEnergy(SecStrucGroup one, \n\t\t\tSecStrucGroup two) throws StructureException {\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber() + \n\t\t\t\t\" \" + one.getPDBName() + \" \" +two.getResidueNumber()+ \n\t\t\t\t\" \" + two.getPDBName() + String.format(\" O (\"+\n\t\t\t\tO.getPDBserial()+\")..N (\"+ N.getPDBserial()+\n\t\t\t\t\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \", \n\t\t\t\tdno,dho,dhc,dnc,dno));\n\n\t\t//there seems to be a contact!\n\t\tif ( (dno < MINDIST) || (dhc < MINDIST) || \n\t\t\t\t(dnc < MINDIST) || (dno < MINDIST)) {\n\t\t\treturn HBONDLOWENERGY;\n\t\t}\n\n\t\tdouble e1 = Q / dho - Q / dhc;\n\t\tdouble e2 = Q / dnc - Q / dno;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",\n\t\t\t\tN.getPDBserial(),O.getPDBserial(), (float) dno, energy));\n\t\t\n\t\t//Avoid too strong energy\n\t\tif (energy > HBONDLOWENERGY) return energy;\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * Calculate distance between two atoms with high precision.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t * @throws StructureException\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static BigDecimal getPreciseDistance(Atom a, Atom b)\n\t\t\tthrows StructureException {\n\t\t\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\t\t\n\t\tBigSqrt sqrt = new BigSqrt();\n\t\tBigDecimal d = new BigDecimal(s);\n\t\tBigDecimal dist = sqrt.sqrt(d);\n\n\t\treturn dist ;\n\t}\n\n\t/**\n\t * Store Hbonds in amino acids.\n\t * DSSP allows two HBonds per aminoacids to allow bifurcated bonds.\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tGroup one = groups[i];\n\t\tGroup two = groups[j];\n\n\t\tif (one.getPDBName().equals(\"PRO\")) {\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucState stateOne = (SecStrucState) \n\t\t\t\tone.getProperty(Group.SEC_STRUC);\n\t\tSecStrucState stateTwo = (SecStrucState) \n\t\t\t\ttwo.getProperty(Group.SEC_STRUC);\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\tif (energy < acc1e) {\n\t\t\tlogger.debug(energy +\"<\"+acc1e);\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\tlogger.debug(energy +\"<\"+acc2e) ;\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\t\t// and now the other side of the bond ..\n\n\t\tif (energy <  don1e) {\n\t\t\tlogger.debug(energy +\"<\"+don1e);\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\t\t\tlogger.debug(energy +\"<\"+don2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\t\t}\n\t}\n\n\t/** \n\t * Detect helical turn patterns.\n\t */\n\tprivate void calculateTurns(){\n\n\t\tfor (int i = 0 ; i< groups.length; i++){\n\t\t\tfor (int turn = 3; turn <= 5 ; turn++) {\n\t\t\t\t\n\t\t\t\tif (i+turn >= groups.length) continue;\n\n\t\t\t\tif (isBonded(i+turn, i)) {\n\t\t\t\t\tlogger.debug(\"is bondend \" + (i+turn) + i);\n\t\t\t\t\tfor (int j=i;j<i+turn+1;j++){\n\t\t\t\t\t\tlogger.debug(\"turn at i:\"+i+\" j:\"+j+\" turn\"+turn);\n\t\t\t\t\t\tSecStrucGroup group = groups[j];\n\t\t\t\t\t\tSecStrucState state = (SecStrucState) \n\t\t\t\t\t\t\t\tgroup.getProperty(Group.SEC_STRUC);\n\t\t\t\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\t\t\tturns[turn-3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \n\t * Test if two groups are forming an H-Bond.\n\t * DSSP defines H-Bonds if the energy < -500 cal/mol\n\t * \n\t * @param one group one\n\t * @param two group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tGroup one = groups[i];\n\t\t//Group two = groups[j];\n\n\t\tSecStrucState stateOne = (SecStrucState)\n\t\t\t\tone.getProperty(Group.SEC_STRUC);\n\t\t//SecStrucState stateTwo = two.getProperty(Group.SEC_STRUC);\n\n\t\tdouble acc1e    = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e    = stateOne.getAccept2().getEnergy();\n\n\t\tint partnerAcc1 = stateOne.getAccept1().getPartner();\n\t\tint partnerAcc2 = stateOne.getAccept2().getPartner();\n\n\t\tif (\t( ( partnerAcc1 == j ) && (acc1e < HBONDHIGHENERGY) )\n\t\t\t\t||\n\t\t\t\t( ( partnerAcc2 == j ) && (acc2e < HBONDHIGHENERGY) )\n\t\t\t\t) {\n\t\t\tlogger.debug(\"*** H-bond between \" + i + \" \" + j);\n\t\t\treturn true ;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * @link http://openbioinformatics.blogspot.com/\n\t * \t\t2009/08/how-to-calculate-h-atoms-for-nitrogens.html\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException {\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c, Atom o, Atom n) \n\t\t\tthrows StructureException {\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tprivate void buildHelices(){\n\n\t\t//Alpha-helix (i+4), 3-10-helix (i+3), Pi-helix (i+5)\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\t}\n\n\tprivate void checkSetTurns() {\n\t\tfor (int i =0 ; i < groups.length -3 ;i++){\n\n\t\t\tGroup g = groups[i];\n\n\t\t\tSecStrucState state = (SecStrucState) \n\t\t\t\t\tg.getProperty(Group.SEC_STRUC);\n\n\t\t\tSecStrucType type = state.getType();\n\n\t\t\tif ( type.isHelixType() ) continue;\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\n\t\t\tfor ( int t = 0 ; t < 3 ; t ++){\n\t\t\t\tif ( turns[t]) {\n\n\t\t\t\t\tfor ( int l = i+1 ; l < i+t+3; l++) {\n\t\t\t\t\t\tlogger.debug(\"turn: \" + i + \" \" + type);\n\t\t\t\t\t\tif ( l >= groups.length) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSecStrucType typel = getSecStrucType(l);\n\t\t\t\t\t\tif ( typel.equals(SecStrucType.coil))\n\t\t\t\t\t\t\tsetSecStrucType(l, SecStrucType.turn);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkSetHelix(int prange, SecStrucType type){\n\n\t\tint range = prange - 3;\n\t\tlogger.debug(\"set helix \" + type + \" \" + prange + \" \" + range);\n\t\t\n\t\tfor (int i =1 ; i < groups.length -range -1 ;i++){\n\n\t\t\tGroup g = groups[i];\n\t\t\tSecStrucState state = (SecStrucState) \n\t\t\t\t\tg.getProperty(Group.SEC_STRUC);\n\n\t\t\tGroup prevG = groups[i-1];\n\t\t\t\n\t\t\tSecStrucState prevState = (SecStrucState) \n\t\t\t\t\tprevG.getProperty(Group.SEC_STRUC);\n\n\t\t\tGroup nextG = groups[i+1];\n\t\t\tSecStrucState nextState = (SecStrucState) \n\t\t\t\t\tnextG.getProperty(Group.SEC_STRUC);\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tboolean[] pturns = prevState.getTurn();\n\t\t\tboolean[] nturns = nextState.getTurn();\n\n\t\t\t// DSSP sets helices one amino acid too short....\n\n\t\t\tif (turns[range] && pturns[range] && nturns[range]) {\n\n\t\t\t\t//Check if no secstruc assigned\n\t\t\t\tboolean empty = true;\n\n\t\t\t\tfor (int curr=i; curr <= i+range; curr++){\n\t\t\t\t\tlogger.debug(\"   \" +i+ \" range: \" + prange + \" \" + range);\n\t\t\t\t\t\n\t\t\t\t\tSecStrucType cstate = getSecStrucType(curr);\n\t\t\t\t\tif (cstate.isHelixType()){\n\t\t\t\t\t\tempty = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// none is assigned yet, set to helix type\n\t\t\t\tif (empty) {\n\n\t\t\t\t\tfor (int curr =i; curr <= i+range ;curr++){\n\t\t\t\t\t\tsetSecStrucType(curr, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setSecStrucType(int pos, SecStrucType type){\n\n\t\tGroup g = groups[pos];\n\t\tSecStrucState s = (SecStrucState) g.getProperty(Group.SEC_STRUC);\n\t\ts.setType(type);\n\t}\n\n\tprivate SecStrucType getSecStrucType(int pos){\n\n\t\tSecStrucState s = getSecStrucState(pos);\n\t\treturn s.getType();\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(Group.SEC_STRUC);\n\t\treturn state;\n\t}\n\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n * @since 1.5\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** \n * Calculate and assign the secondary structure (SS) to the \n * Groups of a Structure object. This object also stores the result\n * of the prediction.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>. \n * Some parts are also taken from: T.E.Creighton, Proteins - \n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n * \n * @author Andreas Prlic\n * @author Aleix Lafita\n * \n */\npublic class SecStrucPred {\n\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(SecStrucPred.class);\n\n\t/** the minimal distance between two residues */\n\tpublic static final double MINDIST = 0.5;\n\n\t/** the minimal distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static final int CA_MIN_DIST = 9;\n\n\t/** Minimal H-bond energy in cal/mol */\n\tpublic static final int HBONDLOWENERGY  = -9900;\n\n\t/** higher limit for H-bond energy */\n\tpublic static final double HBONDHIGHENERGY = -500.0;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t *      f  *  q1 *   q2  *  scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\tpublic static final double Q = -27888.0;\n\n\tprivate SecStrucGroup[] groups;\n\tprivate List<Ladder> ladders;\n\n\tpublic SecStrucPred(){\n\t\tladders = new ArrayList<Ladder>();\n\t}\n\n\t/** \n\t * Predicts the secondary structure of this Structure object,\n\t * using a DSSP implementation.\n\t *\n\t * @param s Structure to predict the SS\n\t * @param assign sets the SS information to the Groups of s\n\t * @return a List of SS annotation objects\n\t */\n\tpublic List<SecStrucState> predict(Structure s, boolean assign) \n\t\t\tthrows StructureException {\n\n\t\tgroups = initGroupArray(s);\n\n\t\tif (groups.length < 5) {\n\t\t\t// not enough groups to do anything\n\t\t\tthrow new StructureException(\"Not enough backbone groups in the\"\n\t\t\t\t\t+ \" Structure to calculate the secondary structure (\"\n\t\t\t\t\t+ groups.length+\" given, minimum 5)\" );\n\t\t}\n\n\t\tcalculateHAtoms();\n\t\tcalculateHBonds();\n\t\tcalculateDihedralAngles();\n\n\t\tcalculateTurns();\n\t\tbuildHelices();\n\t\t\n\t\tdetectBends();\n\t\tdetectStrands();\n\t\t\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\tfor (SecStrucGroup sg : groups){\n\t\t\tSecStrucState ss = (SecStrucState) \n\t\t\t\t\tsg.getProperty(Group.SEC_STRUC);\n\t\t\t//Add to return list and assign to original if flag is true\n\t\t\tsecstruc.add(ss);\n\t\t\tif (assign) sg.getOriginal().setProperty(Group.SEC_STRUC, ss);\n\t\t}\n\t\treturn secstruc;\t\n\t}\n\n\tprivate void detectStrands() {\n\n\t\tfor (int i =1 ; i < groups.length -1 ;i++){\n\t\t\ttestBridge(i);\n\t\t}\n\n\t\t// detect beta bulges\n\t\tconnectLadders();\n\n\t\t// and store results for Sheets and Strands\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void updateSheets() {\n\t\t\n\t\tlogger.debug(\" got \" +ladders.size() + \"  ladders!\");\n\t\t\n\t\tfor (Ladder ladder : ladders){\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor (int lcount = ladder.from; lcount <= ladder.to; lcount++) {\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getType();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getType();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t\ttestSetExtendedSecStrucState(l2count);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( !stype.isHelixType() && \n\t\t\t\t\t\t\t( !stype.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended)))\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'\n\n\t\t\tif (ladder.connectedTo == 0) continue;\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif (ladder.btype.equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor (int lcount = ladder.from; lcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate void testSetExtendedSecStrucState(int lcount) {\n\t\t\n\t\tSecStrucState state = getSecStrucState(lcount);\n\t\tSecStrucType stype = state.getType();\n\t\tif (!stype.isHelixType()){\n\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor (int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size() ; j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif (hasBulge(l1,l2) ) {\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\tlogger.debug(\"Bulge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\t\t\n\t\tboolean bulge = ( (l1.btype.equals(l2.btype) ) &&\n\t\t\t\t( l2.from - l1.to < 6) &&\n\t\t\t\t( l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0) );\n\n\t\tif (!bulge) return bulge;\n\n\t\tswitch(l1.btype){\n\t\tcase parallel:\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\t\t\t\n\t\t\tbreak;\n\t\t\t\n\t\tcase antiparallel:\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3))\n\t\t\t\t\t);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn bulge;\n\t}\n\n\tprivate void registerBridge(int i, int j, BridgeType btype) {\n\t\t\n\t\tif (i > j) {\n\t\t\tlogger.warn(\"Trying to connect ladder where i > j\");\n\t\t\treturn;\n\t\t}\n\n\t\tboolean found = false;\n\t\tfor (Ladder ladder : ladders){\n\t\t\tif (shouldExtendLadder(ladder, i, j, btype)) {\n\t\t\t\tfound = true;\n\t\t\t\tladder.to++; //we go forward in this direction\n\t\t\t\tswitch(btype){\n\t\t\t\tcase parallel:\n\t\t\t\t\tladder.lto++; //increment second strand\n\t\t\t\t\tbreak;\n\t\t\t\tcase antiparallel:\n\t\t\t\t\tladder.lfrom--; //decrement second strand\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found){\n\t\t\t// create new ladder with a single bridge\n\t\t\tLadder l = new Ladder();\n\t\t\tl.from = i;\n\t\t\tl.to = i;\n\t\t\tl.lfrom = j;\n\t\t\tl.lto = j;\n\t\t\tl.btype = btype;\n\t\t\tladders.add(l);\n\t\t}\n\n\t}\n\n\t/**\n\t * Conditions to extend a ladder with a given beta Bridge:\n\t * <li>The bridge and ladder are of the same type.\n\t * <li>The smallest bridge residue is sequential to the first\n\t * \t\tstrand ladder.\n\t * <li>The second bridge residue is either sequential (parallel)\n\t * \t\tor previous (antiparallel) to the second strand of the ladder\n\t * </li>\n\t * @param ladder the ladder candidate to extend\n\t * @param i index of the first bridge residue\n\t * @param j index of the second bridge residue\n\t * @param btype type of beta bridge\n\t * @return true if the bridge (i,j) extends the ladder\n\t */\n\tprivate boolean shouldExtendLadder(Ladder ladder, int i, \n\t\t\tint j, BridgeType btype) {\n\n\t\t//Only extend if they are of the same type\n\t\tboolean sameType = btype.equals(ladder.btype);\n\t\tif (!sameType) return false;\n\t\t\n\t\t//Only extend if residue i is sequential to ladder strand\n\t\tboolean sequential = (i == ladder.to+1);\n\t\tif (!sequential) return false;\n\t\t\n\t\tswitch(btype){\n\t\tcase parallel:\n\t\t\t//Residue j should be sequential to second strand\n\t\t\tif (j == ladder.lto+1) return true;\n\t\t\tbreak;\n\t\tcase antiparallel:\n\t\t\t//Residue j should be previous to second strand\n\t\t\tif (j == ladder.lfrom-1) return true;\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void testBridge(int i) {\n\t\t\n\t\tint j = i + 3; //sum 3 for the non-overlapping condition\n\t\t\n\t\tfor (int foundNrBridges = 0; foundNrBridges < 2\n\t\t\t\t&& (j < groups.length-1); j++){\n\n\t\t\tBridgeType btype = null;\n\n\t\t\tif ((isBonded(i-1, j) && isBonded(j, i+1) ) ||\n\t\t\t\t\t(isBonded(j-1, i) && isBonded(i, j+1)) ) {\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ((isBonded(i, j) && isBonded(j, i)) ||\n\t\t\t\t\t(isBonded(i-1,j+1) && (isBonded(j-1, i+1)))) {\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tfoundNrBridges++;\n\t\t\t\tregisterBridge(i, j, btype);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void detectBends() {\n\n\t\tfor (int i = 2 ; i < groups.length -2 ;i++){\n\n\t\t\t//Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i + 2 )\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle = Calc.angle(caminus2, caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i); \n\n\t\t\tstate.setKappa((float) angle);\n\n\t\t\t//Angles = 360 should be discarded\n\t\t\tif (angle > 70.0 && angle < 359.9) {\n\t\t\t\tif (state.getType().equals(SecStrucType.coil)) {\n\t\t\t\t\tstate.setType(SecStrucType.bend);\n\t\t\t\t}\n\t\t\t\tstate.setBend(true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles() throws StructureException {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState) \n\t\t\t\t\ta.getProperty(Group.SEC_STRUC);\n\t\t\tSecStrucState state2 = (SecStrucState) \n\t\t\t\t\tb.getProperty(Group.SEC_STRUC);\n\t\t\t\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\t\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\t\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     \"\n\t\t\t\t+ \"N-H-->O    O-->H-N    N-H-->O    O-->H-N    \"\n\t\t\t\t+ \"TCO  KAPPA ALPHA  PHI    PSI    \"\n\t\t\t\t+ \"X-CA   Y-CA   Z-CA \");\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tbuf.append(nl);\n\t\t\tSecStrucState ss = getSecStrucState(i);\n\t\t\tbuf.append(ss.printDSSPline(i));\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\t\n\t@Override\n\tpublic boolean equals(Object o){\n\t\t\n\t\tif (!(o instanceof SecStrucPred)) return false;\n\t\telse {\n\t\t\tSecStrucPred ss = (SecStrucPred) o;\n\t\t\tif (groups.length != ss.groups.length) return false;\n\t\t\t\n\t\t\tfor (int g=0; g<groups.length; g++){\n\t\t\t\tSecStrucInfo g1 = getSecStrucState(g);\n\t\t\t\tSecStrucInfo g2 = ss.getSecStrucState(g);\n\t\t\t\tif (!g1.equals(g2)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t\n\t\tfor ( Chain c : s.getChains()){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\t\t\t\t\n\t\t\t\t//We can also calc secstruc if it is a modified amino acid\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\t\t\t\t\t\n\t\t\t\t\tSecStrucState state = new SecStrucState(sg, \n\t\t\t\t\t\t\tSecStrucInfo.BIOJAVA_ASSIGNMENT, \n\t\t\t\t\t\t\tSecStrucType.coil);\n\t\t\t\t\t\n\t\t\t\t\tsg.setProperty(Group.SEC_STRUC, state);\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/** \n\t * Calculate the coordinates of the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location.\n\t */\n\tprivate void calculateHAtoms() throws StructureException {\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( !b.hasAtom(\"H\") ) {\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(), b.getN());\n\t\t\t\tb.setH(H);\n\t\t\t\t//First residue skipped, unable to calc H for it TODO\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \n\t * Calculate the HBonds between different groups.\n\t * see Creighton page 147 f\n\t */\n\tprivate void calculateHBonds() throws StructureException {\n\n\t\tif (groups.length < 5) return;\n\n\t\tfor (int i=0 ; i < groups.length ; i++){\n\n\t\t\tSecStrucGroup one = groups[i];\n\n\t\t\tfor (int j=i+1 ; j<groups.length ; j++){\n\n\t\t\t\tSecStrucGroup two = groups[j];\n\t\t\t\t//TODO use contacts package to speed up n^2 distance\n\t\t\t\t//if distance too big - for sure no HBonds - sppedup\n\t\t\t\tdouble dist = Calc.getDistance(one.getCA(),two.getCA());\n\t\t\t\tif (dist >= CA_MIN_DIST) continue;\n\n\t\t\t\tcheckAddHBond(i,j);\n\n\t\t\t\t//\"backwards\" hbonds are not allowed\n\t\t\t\tif (j!=(i+1)) checkAddHBond(j,i);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\t\t\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\t\tif (!one.hasAtom(\"H\")) {\n\t\t\tlogger.debug(\"Residue \"+one.getResidueNumber()+\" has no H\");\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\t\t\n\t\tdouble energy = 0;\n\t\t\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\tlogger.warn(\"Energy calculation failed\", e);\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug(\"Energy between positions (\"+i+\",\"+j+\"): \"+energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/**\n\t * Calculate HBond energy of two groups in cal/mol\n\t * see Creighton page 147 f\n\t * <p>\n\t * Jeffrey, George A., An introduction to hydrogen bonding, \n\t * Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t * Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t */\n\tprivate static double calculateHBondEnergy(SecStrucGroup one, \n\t\t\tSecStrucGroup two) throws StructureException {\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber() + \n\t\t\t\t\" \" + one.getPDBName() + \" \" +two.getResidueNumber()+ \n\t\t\t\t\" \" + two.getPDBName() + String.format(\" O (\"+\n\t\t\t\tO.getPDBserial()+\")..N (\"+ N.getPDBserial()+\n\t\t\t\t\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \", \n\t\t\t\tdno,dho,dhc,dnc,dno));\n\n\t\t//there seems to be a contact!\n\t\tif ( (dno < MINDIST) || (dhc < MINDIST) || \n\t\t\t\t(dnc < MINDIST) || (dno < MINDIST)) {\n\t\t\treturn HBONDLOWENERGY;\n\t\t}\n\n\t\tdouble e1 = Q / dho - Q / dhc;\n\t\tdouble e2 = Q / dnc - Q / dno;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",\n\t\t\t\tN.getPDBserial(),O.getPDBserial(), (float) dno, energy));\n\t\t\n\t\t//Avoid too strong energy\n\t\tif (energy > HBONDLOWENERGY) return energy;\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * Calculate distance between two atoms with high precision.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t * @throws StructureException\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static BigDecimal getPreciseDistance(Atom a, Atom b)\n\t\t\tthrows StructureException {\n\t\t\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\t\t\n\t\tBigSqrt sqrt = new BigSqrt();\n\t\tBigDecimal d = new BigDecimal(s);\n\t\tBigDecimal dist = sqrt.sqrt(d);\n\n\t\treturn dist ;\n\t}\n\n\t/**\n\t * Store Hbonds in amino acids.\n\t * DSSP allows two HBonds per aminoacids to allow bifurcated bonds.\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tGroup one = groups[i];\n\t\tGroup two = groups[j];\n\n\t\tif (one.getPDBName().equals(\"PRO\")) {\n\t\t\tlogger.debug(\"Ignore: PRO \" + one.getResidueNumber());\n\t\t\treturn;\n\t\t}\n\n\t\tSecStrucState stateOne = (SecStrucState) \n\t\t\t\tone.getProperty(Group.SEC_STRUC);\n\t\tSecStrucState stateTwo = (SecStrucState) \n\t\t\t\ttwo.getProperty(Group.SEC_STRUC);\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\tif (energy < acc1e) {\n\t\t\tlogger.debug(energy +\"<\"+acc1e);\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\tlogger.debug(energy +\"<\"+acc2e) ;\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\t\t// and now the other side of the bond ..\n\n\t\tif (energy <  don1e) {\n\t\t\tlogger.debug(energy +\"<\"+don1e);\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\t\t\tlogger.debug(energy +\"<\"+don2e);\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\t\t}\n\t}\n\n\t/** \n\t * Detect helical turn patterns.\n\t */\n\tprivate void calculateTurns(){\n\n\t\tfor (int i = 0 ; i< groups.length; i++){\n\t\t\tfor (int turn = 3; turn <= 5 ; turn++) {\n\t\t\t\t\n\t\t\t\tif (i+turn >= groups.length) continue;\n\n\t\t\t\tif (isBonded(i+turn, i)) {\n\t\t\t\t\tlogger.debug(\"is bondend \" + (i+turn) + i);\n\t\t\t\t\tfor (int j=i;j<i+turn+1;j++){\n\t\t\t\t\t\tlogger.debug(\"turn at i:\"+i+\" j:\"+j+\" turn\"+turn);\n\t\t\t\t\t\t\n\t\t\t\t\t\tSecStrucState state = getSecStrucState(j);\n\t\t\t\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\t\t\tturns[turn-3] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** \n\t * Test if two groups are forming an H-Bond.\n\t * DSSP defines H-Bonds if the energy < -500 cal/mol\n\t * \n\t * @param one group one\n\t * @param two group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tSecStrucState stateOne = getSecStrucState(i);\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tint partnerAcc1 = stateOne.getAccept1().getPartner();\n\t\tint partnerAcc2 = stateOne.getAccept2().getPartner();\n\n\t\tif (\t( ( partnerAcc1 == j ) && (acc1e < HBONDHIGHENERGY) )\n\t\t\t\t||\n\t\t\t\t( ( partnerAcc2 == j ) && (acc2e < HBONDHIGHENERGY) )\n\t\t\t\t) {\n\t\t\tlogger.debug(\"*** H-bond between \" + i + \" \" + j);\n\t\t\treturn true;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * @link http://openbioinformatics.blogspot.com/\n\t * \t\t2009/08/how-to-calculate-h-atoms-for-nitrogens.html\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException {\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c, Atom o, Atom n) \n\t\t\tthrows StructureException {\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tprivate void buildHelices(){\n\n\t\t//Alpha-helix (i+4), 3-10-helix (i+3), Pi-helix (i+5)\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\t}\n\n\tprivate void checkSetTurns() {\n\t\tfor (int i =0 ; i < groups.length -3 ;i++){\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tSecStrucType type = state.getType();\n\n\t\t\t//TODO use ordering of the SS types instead\n\t\t\tif (type.isHelixType()) continue;\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\n\t\t\tfor ( int t = 0 ; t < 3 ; t ++){\n\t\t\t\tif ( turns[t]) {\n\n\t\t\t\t\tfor ( int l = i+1 ; l < i+t+3; l++) {\n\t\t\t\t\t\tlogger.debug(\"turn: \" + i + \" \" + type);\n\t\t\t\t\t\tif ( l >= groups.length) break;\n\t\t\t\t\t\t\n\t\t\t\t\t\tSecStrucType typel = getSecStrucType(l);\n\t\t\t\t\t\tif ( typel.equals(SecStrucType.coil))\n\t\t\t\t\t\t\tsetSecStrucType(l, SecStrucType.turn);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkSetHelix(int prange, SecStrucType type){\n\n\t\tint range = prange - 3;\n\t\tlogger.debug(\"set helix \" + type + \" \" + prange + \" \" + range);\n\t\t\n\t\tfor (int i =1 ; i < groups.length -range -1 ;i++){\n\n\t\t\tSecStrucState state = getSecStrucState(i);\n\t\t\tSecStrucState prevState = getSecStrucState(i-1);\n\t\t\tSecStrucState nextState = getSecStrucState(i+1);\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tboolean[] pturns = prevState.getTurn();\n\t\t\tboolean[] nturns = nextState.getTurn();\n\n\t\t\t//DSSP sets helices one amino acid too short....\n\t\t\t//TODO review\n\n\t\t\tif (turns[range] && pturns[range] && nturns[range]) {\n\n\t\t\t\t//Check if no secstruc assigned\n\t\t\t\tboolean empty = true;\n\n\t\t\t\tfor (int curr=i; curr <= i+range; curr++){\n\t\t\t\t\tlogger.debug(\"   \" +i+ \" range: \" + prange + \" \" + range);\n\t\t\t\t\t\n\t\t\t\t\tSecStrucType cstate = getSecStrucType(curr);\n\t\t\t\t\tif (cstate.isHelixType()){\n\t\t\t\t\t\tempty = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// none is assigned yet, set to helix type\n\t\t\t\tif (empty) {\n\t\t\t\t\tfor (int curr =i; curr <= i+range ;curr++){\n\t\t\t\t\t\tsetSecStrucType(curr, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setSecStrucType(int pos, SecStrucType type){\n\n\t\tSecStrucState s = getSecStrucState(pos);\n\t\ts.setType(type);\n\t}\n\n\tprivate SecStrucType getSecStrucType(int pos){\n\t\t\n\t\tSecStrucState s = getSecStrucState(pos);\n\t\treturn s.getType();\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\t//TODO consider using a List of SecStrucState to avoid this method\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(Group.SEC_STRUC);\n\t\treturn state;\n\t}\n\n}","originTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of the DSSP implementation in BioJava\n * for the prediction of secondary structure in a Structure object.\n * \n * EXAMPLES:\n * \t\t\tBig structures: 4v7r, 4V60 (use mmCif parser)\n * \t\t\tHelical: 4hhb, 4lup\n * \t\t\tMixed small: 5pti\n * \t\t\tFirst sheet: 1ze3, 3k19\n * \t\t\tInsertion code: 1how\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSecStrucPred {\n\n\t@Test\n\tpublic void testSecStrucPred() throws StructureException, IOException {\n\t\t\n\t\t//List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"5pti\", \"4hhb\", \"1ze3\", \"1how\");\n\t\t\n\t\tfor (String name : names) {\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\t\t\n\t\t\tStructure s = cache.getStructure(name);\n\t\t\t\n\t\t\t//Predict with BioJava the SS\n\t\t\tSecStrucPred sec = new SecStrucPred();\n\t\t\tList<SecStrucState> biojava = sec.predict(s, false);\n\t\t\t\n\t\t\t//Download the original DSSP implementation output\n\t\t\tList<SecStrucState> dssp = DSSPParser.fetch(name, s, false);\n\t\t\t\n\t\t\tassertTrue(\"SS assignment lengths do not match\",\n\t\t\t\t\tbiojava.size()==dssp.size());\n\t\t\t\n\t\t\tfor (int i=0; i<dssp.size(); i++){\n\t\t\t\tassertEquals(\"SS assignment position \"+i+\" does not match\", \n\t\t\t\t\t\tbiojava.get(i), dssp.get(i));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\t\n}\n","changedTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of the DSSP implementation in BioJava\n * for the prediction of secondary structure in a Structure object.\n * \n * EXAMPLES:\n * \t\t\tBig structures: 4v7r, 4V60 (use mmCif parser)\n * \t\t\tHelical: 4hhb, 4lup\n * \t\t\tMixed small: 5pti\n * \t\t\tFirst sheet: 1ze3, 3k19\n * \t\t\tInsertion code: 1how\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSecStrucPred {\n\n\t@Test\n\tpublic void testSecStrucPred() throws StructureException, IOException {\n\t\t\n\t\t//List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"1ze3\", \"4hhb\", \"5pti\", \"1how\");\n\t\t\n\t\tfor (String name : names) {\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\t\t\n\t\t\tStructure s = cache.getStructure(name);\n\t\t\t\n\t\t\t//Predict with BioJava the SS\n\t\t\tSecStrucPred sec = new SecStrucPred();\n\t\t\tList<SecStrucState> biojava = sec.predict(s, false);\n\t\t\tSystem.out.println(sec);\n\t\t\t\n\t\t\t//Download the original DSSP implementation output\n\t\t\tList<SecStrucState> dssp = DSSPParser.fetch(name, s, false);\n\t\t\t\n\t\t\tassertTrue(\"SS assignment lengths do not match\",\n\t\t\t\t\tbiojava.size()==dssp.size());\n\t\t\t\n\t\t\tfor (int i=0; i<dssp.size(); i++){\n\t\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\", \n\t\t\t\t\t\tbiojava.get(i), dssp.get(i));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\t\n}\n","commitMessage":"Fix bug extending ladders in SecStrucPred","test_commitMessage":"Fix bug extending ladders in SecStrucPred","allZero":false}