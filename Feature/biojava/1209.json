{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleAlignedSequence.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleAlignedSequenceTest.java","prod_time":"2010-06-17 07:28:54","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"b62bc0b948700d9c626246708ace67dfbc84e932","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\nimport org.biojava3.core.sequence.template.SequenceView;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<C extends Compound> implements AlignedSequence<C> {\n\n    private static final String gap = \"-\";\n\n    // always stored\n    private Sequence<C> original;\n    private int length, numBefore, numAfter;\n    private Location location;\n\n    // cached (lazily initialized)\n    private int numGaps = -1;\n    private int[] alignmentFromSequence, sequenceFromAlignment;\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(Sequence<C> original, List<Step> steps) {\n        this(original, steps, 0, 0);\n    }\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(Sequence<C> original, List<Step> steps, int numBefore, int numAfter) {\n        this.original = original;\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    // methods for AlignedSequence\n\n    @Override\n    public int getAlignmentIndexAt(int sequenceIndex) {\n        if (alignmentFromSequence == null) {\n            setAlignmentFromSequence();\n        }\n        return alignmentFromSequence[sequenceIndex - 1];\n    }\n\n    @Override\n    public int getEnd() {\n        return location.getEnd();\n    }\n\n    @Override\n    public Location getLocationInAlignment() {\n        return location;\n    }\n\n    @Override\n    public int getNumGaps() {\n        if (numGaps == -1) {\n            setNumGaps();\n        }\n        return numGaps;\n    }\n\n    @Override\n    public Sequence<C> getOriginalSequence() {\n        return original;\n    }\n\n    @Override\n    public int getOverlapCount() {\n        // TODO handle circular alignments\n        return 1;\n    }\n\n    @Override\n    public int getSequenceIndexAt(int alignmentIndex) {\n        if (sequenceFromAlignment == null) {\n            setSequenceFromAlignment();\n        }\n        return sequenceFromAlignment[alignmentIndex - 1];\n    }\n\n    @Override\n    public int getStart() {\n        return location.getStart();\n    }\n\n    @Override\n    public boolean isCircular() {\n        return location.isCircular();\n    }\n\n    // methods for Sequence\n\n    @Override\n    public int countCompounds(C... compounds) {\n        int count = 0;\n        List<C> search = Arrays.asList(compounds);\n        for (C compound : getAsList()) {\n            if (search.contains(compound)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return original.getAccession();\n    }\n\n    @Override\n    public List<C> getAsList() {\n        List<C> compounds = new ArrayList<C>();\n        for (int i = 1; i <= length; i++) {\n            compounds.add(getCompoundAt(i));\n        }\n        return compounds;\n    }\n\n    @Override\n    public C getCompoundAt(int alignmentIndex) {\n        return isGap(alignmentIndex) ? getCompoundSet().getCompoundForString(gap) :\n                original.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return original.getCompoundSet();\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return getSequenceAsString(1, length, Strand.UNDEFINED);\n    }\n\n    @Override\n    public String getSequenceAsString(Integer start, Integer end, Strand strand) {\n        StringBuilder s = new StringBuilder();\n        for (C compound : getAsList().subList(start - 1, end)) {\n            s.append(compound == null ? gap : getCompoundSet().getStringForCompound(compound));\n        }\n        return s.toString();\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(Integer start, Integer end) {\n        // TODO SequenceView<C> getSubSequence(Integer start, Integer end)\n        return null;\n    }\n\n    // method for Iterable\n\n    @Override\n    public Iterator<C> iterator() {\n        return getAsList().iterator();\n    }\n\n    /**\n     * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n     */\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    // helper methods\n\n    // determines if this sequence has a gap at a particular alignment location\n    private boolean isGap(int alignmentIndex) {\n        for (Location sublocation : location) {\n            if (sublocation.getStart() <= alignmentIndex && alignmentIndex <= sublocation.getEnd()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // initializes alignmentFromSequence\n    private void setAlignmentFromSequence() {\n        alignmentFromSequence = new int[original.getLength()];\n        int s = 1, a = 1;\n        for (int i = 0; i < numBefore; i++, s++) {\n            alignmentFromSequence[s - 1] = a;\n        }\n        for (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n            while (a <= length && isGap(a)) {\n                a++;\n            }\n            alignmentFromSequence[s - 1] = a;\n        }\n        a--;\n        for (int i = 0; i < numAfter; i++, s++) {\n            alignmentFromSequence[s - 1] = a;\n        }\n    }\n\n    // initializes location\n    private void setLocation(List<Step> steps) {\n        List<Location> sublocations = new ArrayList<Location>();\n        int step = 0, i = numBefore+numAfter, iMax = original.getLength();\n        while (step < length && steps.get(step) == Step.GAP) {\n            step++;\n        }\n        while (step < length && i < iMax) {\n            int start = step + 1;\n            while (step < length && steps.get(step) == Step.COMPOUND && i < iMax) {\n                step++;\n                i++;\n            }\n            sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n            while (step < length && steps.get(step) == Step.GAP) {\n                step++;\n            }\n        }\n        int start = sublocations.get(0).getStart(), end = sublocations.get(sublocations.size() - 1).getEnd();\n        location = (sublocations.size() > 1) ? new SimpleLocation(start, end, Strand.UNDEFINED, sublocations) :\n                new SimpleLocation(start, end, Strand.UNDEFINED);\n\n        if (step != length || i != iMax) {\n            throw new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n        }\n    }\n\n    // initializes the number of gaps\n    private void setNumGaps() {\n        numGaps = 0;\n        C cGap = getCompoundSet().getCompoundForString(gap);\n        boolean inGap = false;\n        for (C compound : getAsList()) {\n            if (compound == null || compound.equalsIgnoreCase(cGap)) {\n                if (!inGap) {\n                    numGaps++;\n                    inGap = true;\n                }\n            } else {\n                inGap = false;\n            }\n        }\n    }\n\n    // initializes sequenceFromAlignment\n    private void setSequenceFromAlignment() {\n        sequenceFromAlignment = new int[length];\n        int a = 1, s = numBefore + 1;\n        for (int i = 0; i < getStart(); i++, a++) {\n            sequenceFromAlignment[a - 1] = s;\n        }\n        for (; a <= length; a++) {\n            if (s < getEnd() && !isGap(a)) {\n                s++;\n            }\n            sequenceFromAlignment[a - 1] = s;\n        }\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\nimport org.biojava3.core.sequence.template.SequenceView;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<C extends Compound> implements AlignedSequence<C> {\n\n    private static final String gap = \"-\";\n\n    // always stored\n    private Sequence<C> original;\n    private int length, numBefore, numAfter;\n    private Location location;\n\n    // cached (lazily initialized)\n    private int numGaps = -1;\n    private int[] alignmentFromSequence, sequenceFromAlignment;\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(Sequence<C> original, List<Step> steps) {\n        this(original, steps, 0, 0);\n    }\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(Sequence<C> original, List<Step> steps, int numBefore, int numAfter) {\n        this.original = original;\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    // methods for AlignedSequence\n\n    @Override\n    public int getAlignmentIndexAt(int sequenceIndex) {\n        if (alignmentFromSequence == null) {\n            setAlignmentFromSequence();\n        }\n        return alignmentFromSequence[sequenceIndex - 1];\n    }\n\n    @Override\n    public int getEnd() {\n        return location.getEnd();\n    }\n\n    @Override\n    public Location getLocationInAlignment() {\n        return location;\n    }\n\n    @Override\n    public int getNumGaps() {\n        if (numGaps == -1) {\n            setNumGaps();\n        }\n        return numGaps;\n    }\n\n    @Override\n    public Sequence<C> getOriginalSequence() {\n        return original;\n    }\n\n    @Override\n    public int getOverlapCount() {\n        // TODO handle circular alignments\n        return 1;\n    }\n\n    @Override\n    public int getSequenceIndexAt(int alignmentIndex) {\n        if (sequenceFromAlignment == null) {\n            setSequenceFromAlignment();\n        }\n        return sequenceFromAlignment[alignmentIndex - 1];\n    }\n\n    @Override\n    public int getStart() {\n        return location.getStart();\n    }\n\n    @Override\n    public boolean isCircular() {\n        return location.isCircular();\n    }\n\n    // methods for Sequence\n\n    @Override\n    public int countCompounds(C... compounds) {\n        int count = 0;\n        List<C> search = Arrays.asList(compounds);\n        for (C compound : getAsList()) {\n            if (search.contains(compound)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return original.getAccession();\n    }\n\n    @Override\n    public List<C> getAsList() {\n        List<C> compounds = new ArrayList<C>();\n        for (int i = 1; i <= length; i++) {\n            compounds.add(getCompoundAt(i));\n        }\n        return compounds;\n    }\n\n    @Override\n    public C getCompoundAt(int alignmentIndex) {\n        return alignmentIndex >= 1 && alignmentIndex <= length && isGap(alignmentIndex) ?\n                getCompoundSet().getCompoundForString(gap) :\n                original.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return original.getCompoundSet();\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return getSequenceAsString(1, length, Strand.UNDEFINED);\n    }\n\n    @Override\n    public String getSequenceAsString(Integer start, Integer end, Strand strand) {\n        StringBuilder s = new StringBuilder();\n        for (C compound : getAsList().subList(start - 1, end)) {\n            s.append(compound == null ? gap : getCompoundSet().getStringForCompound(compound));\n        }\n        return s.toString();\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(Integer start, Integer end) {\n        // TODO SequenceView<C> getSubSequence(Integer start, Integer end)\n        return null;\n    }\n\n    // method for Iterable\n\n    @Override\n    public Iterator<C> iterator() {\n        return getAsList().iterator();\n    }\n\n    /**\n     * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n     */\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    // helper methods\n\n    // determines if this sequence has a gap at a particular alignment location\n    private boolean isGap(int alignmentIndex) {\n        for (Location sublocation : location) {\n            if (sublocation.getStart() <= alignmentIndex && alignmentIndex <= sublocation.getEnd()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // initializes alignmentFromSequence\n    private void setAlignmentFromSequence() {\n        alignmentFromSequence = new int[original.getLength()];\n        int s = 1, a = 1;\n        for (int i = 0; i < numBefore; i++, s++) {\n            alignmentFromSequence[s - 1] = a;\n        }\n        for (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n            while (a <= length && isGap(a)) {\n                a++;\n            }\n            alignmentFromSequence[s - 1] = a;\n        }\n        a--;\n        for (int i = 0; i < numAfter; i++, s++) {\n            alignmentFromSequence[s - 1] = a;\n        }\n    }\n\n    // initializes location\n    private void setLocation(List<Step> steps) {\n        List<Location> sublocations = new ArrayList<Location>();\n        int step = 0, i = numBefore+numAfter, iMax = original.getLength();\n        while (step < length && steps.get(step) == Step.GAP) {\n            step++;\n        }\n        while (step < length && i < iMax) {\n            int start = step + 1;\n            while (step < length && steps.get(step) == Step.COMPOUND && i < iMax) {\n                step++;\n                i++;\n            }\n            sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n            while (step < length && steps.get(step) == Step.GAP) {\n                step++;\n            }\n        }\n        int start = sublocations.get(0).getStart(), end = sublocations.get(sublocations.size() - 1).getEnd();\n        location = (sublocations.size() > 1) ? new SimpleLocation(start, end, Strand.UNDEFINED, sublocations) :\n                new SimpleLocation(start, end, Strand.UNDEFINED);\n\n        if (step != length || i != iMax) {\n            throw new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n        }\n    }\n\n    // initializes the number of gaps\n    private void setNumGaps() {\n        numGaps = 0;\n        C cGap = getCompoundSet().getCompoundForString(gap);\n        boolean inGap = false;\n        for (C compound : getAsList()) {\n            if (compound == null || compound.equalsIgnoreCase(cGap)) {\n                if (!inGap) {\n                    numGaps++;\n                    inGap = true;\n                }\n            } else {\n                inGap = false;\n            }\n        }\n    }\n\n    // initializes sequenceFromAlignment\n    private void setSequenceFromAlignment() {\n        sequenceFromAlignment = new int[length];\n        int a = 1, s = numBefore + 1;\n        for (int i = 0; i < getStart(); i++, a++) {\n            sequenceFromAlignment[a - 1] = s;\n        }\n        for (; a <= length; a++) {\n            if (s < getEnd() && !isGap(a)) {\n                s++;\n            }\n            sequenceFromAlignment[a - 1] = s;\n        }\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class SimpleAlignedSequenceTest {\n\n    private ProteinSequence go, lo;\n    private AlignedSequence<AminoAcidCompound> global, local;\n    private AminoAcidCompoundSet cs;\n\n    @Before\n    public void setup() {\n        go = new ProteinSequence(\"ARND\");\n        lo = new ProteinSequence(\"CEQGHILKM\");\n        global = new SimpleAlignedSequence<AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP, Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n        local = new SimpleAlignedSequence<AminoAcidCompound>(lo, Arrays.asList(new Step[] {Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}), 1, 3);\n        cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLocal() {\n        new SimpleAlignedSequence<AminoAcidCompound>(lo, Arrays.asList(new Step[] {Step.COMPOUND, Step.COMPOUND,\n                Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLong() {\n        new SimpleAlignedSequence<AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP, Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceShort() {\n        new SimpleAlignedSequence<AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP, Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test\n    public void testGetAlignmentIndexAt() {\n        assertEquals(global.getAlignmentIndexAt(1), 2);\n        assertEquals(global.getAlignmentIndexAt(2), 3);\n        assertEquals(global.getAlignmentIndexAt(3), 5);\n        assertEquals(global.getAlignmentIndexAt(4), 6);\n        assertEquals(local.getAlignmentIndexAt(1), 1);\n        assertEquals(local.getAlignmentIndexAt(2), 1);\n        assertEquals(local.getAlignmentIndexAt(3), 2);\n        assertEquals(local.getAlignmentIndexAt(4), 5);\n        assertEquals(local.getAlignmentIndexAt(5), 7);\n        assertEquals(local.getAlignmentIndexAt(6), 8);\n        assertEquals(local.getAlignmentIndexAt(7), 8);\n        assertEquals(local.getAlignmentIndexAt(8), 8);\n        assertEquals(local.getAlignmentIndexAt(9), 8);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds() {\n        global.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds2() {\n        global.getAlignmentIndexAt(5);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds3() {\n        local.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds4() {\n        local.getAlignmentIndexAt(10);\n    }\n\n    @Test\n    public void testGetEnd() {\n        assertEquals(global.getEnd(), 6);\n        assertEquals(local.getEnd(), 8);\n    }\n\n    @Test\n    public void testGetLocationInAlignment() {\n        assertEquals(global.getLocationInAlignment(), new SimpleLocation(2, 6, Strand.UNDEFINED, Arrays.asList(\n                new Location[] {new SimpleLocation(2, 3, Strand.UNDEFINED),\n                new SimpleLocation(5, 6, Strand.UNDEFINED)})));\n        assertEquals(local.getLocationInAlignment(), new SimpleLocation(1, 8, Strand.UNDEFINED, Arrays.asList(\n                new Location[] {new SimpleLocation(1, 2, Strand.UNDEFINED), new SimpleLocation(5, 5, Strand.UNDEFINED),\n                new SimpleLocation(7, 8, Strand.UNDEFINED)})));\n    }\n\n    @Test\n    public void testGetNumGaps() {\n        assertEquals(global.getNumGaps(), 3);\n        assertEquals(local.getNumGaps(), 2);\n    }\n\n    @Test\n    public void testGetOriginalSequence() {\n        assertEquals(global.getOriginalSequence(), go);\n        assertEquals(local.getOriginalSequence(), lo);\n    }\n\n    @Test\n    public void testGetOverlapCount() {\n        assertEquals(global.getOverlapCount(), 1);\n        assertEquals(local.getOverlapCount(), 1);\n    }\n\n    @Test\n    public void testGetSequenceIndexAt() {\n        assertEquals(global.getSequenceIndexAt(1), 1);\n        assertEquals(global.getSequenceIndexAt(2), 1);\n        assertEquals(global.getSequenceIndexAt(3), 2);\n        assertEquals(global.getSequenceIndexAt(4), 2);\n        assertEquals(global.getSequenceIndexAt(5), 3);\n        assertEquals(global.getSequenceIndexAt(6), 4);\n        assertEquals(global.getSequenceIndexAt(7), 4);\n        assertEquals(local.getSequenceIndexAt(1), 2);\n        assertEquals(local.getSequenceIndexAt(2), 3);\n        assertEquals(local.getSequenceIndexAt(3), 3);\n        assertEquals(local.getSequenceIndexAt(4), 3);\n        assertEquals(local.getSequenceIndexAt(5), 4);\n        assertEquals(local.getSequenceIndexAt(6), 4);\n        assertEquals(local.getSequenceIndexAt(7), 5);\n        assertEquals(local.getSequenceIndexAt(8), 6);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds() {\n        global.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds2() {\n        global.getSequenceIndexAt(8);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds3() {\n        local.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds4() {\n        local.getSequenceIndexAt(9);\n    }\n\n    @Test\n    public void testGetStart() {\n        assertEquals(global.getStart(), 2);\n        assertEquals(local.getStart(), 1);\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(global.isCircular());\n        assertFalse(local.isCircular());\n    }\n\n    @Test\n    public void testCountCompounds() {\n        assertEquals(global.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 1);\n    }\n\n    @Test\n    public void testGetAccession() {\n        assertNull(global.getAccession());\n        assertNull(local.getAccession());\n    }\n\n    @Test\n    public void testGetAsList() {\n        assertArrayEquals(global.getAsList().toArray(new AminoAcidCompound[7]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"R\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\"),\n            cs.getCompoundForString(\"-\")});\n        assertArrayEquals(local.getAsList().toArray(new AminoAcidCompound[8]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"Q\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"H\"), cs.getCompoundForString(\"I\")});\n    }\n\n    @Test\n    public void testGetCompoundAt() {\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(2), cs.getCompoundForString(\"A\"));\n        assertEquals(global.getCompoundAt(3), cs.getCompoundForString(\"R\"));\n        assertEquals(global.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(5), cs.getCompoundForString(\"N\"));\n        assertEquals(global.getCompoundAt(6), cs.getCompoundForString(\"D\"));\n        assertEquals(global.getCompoundAt(7), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(1), cs.getCompoundForString(\"E\"));\n        assertEquals(local.getCompoundAt(2), cs.getCompoundForString(\"Q\"));\n        assertEquals(local.getCompoundAt(3), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(5), cs.getCompoundForString(\"G\"));\n        assertEquals(local.getCompoundAt(6), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(7), cs.getCompoundForString(\"H\"));\n        assertEquals(local.getCompoundAt(8), cs.getCompoundForString(\"I\"));\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(global.getCompoundSet(), cs);\n        assertEquals(local.getCompoundSet(), cs);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 3);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 7);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 6);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(global.getLength(), 7);\n        assertEquals(local.getLength(), 8);\n    }\n\n    @Test\n    public void testGetSequenceAsString() {\n        assertEquals(global.getSequenceAsString(), \"-AR-ND-\");\n        assertEquals(local.getSequenceAsString(), \"EQ--G-HI\");\n    }\n\n    @Test\n    public void testGetSequenceAsStringIntegerIntegerStrand() {\n        assertEquals(global.getSequenceAsString(2, 5, Strand.UNDEFINED), \"AR-N\");\n        assertEquals(local.getSequenceAsString(2, 6, Strand.UNDEFINED), \"Q--G-\");\n    }\n\n    @Ignore // TODO SimpleAlignedSequence.getSubSequence(Integer, Integer)\n    @Test\n    public void testGetSubSequence() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIterator() {\n        for (AminoAcidCompound c : global) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(global.toString(), \"-AR-ND-\");\n        assertEquals(local.toString(), \"EQ--G-HI\");\n    }\n\n}\n","changedTest":"","commitMessage":"tests\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7968 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}