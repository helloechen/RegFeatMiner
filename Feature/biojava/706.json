{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/quaternary/QsAlign.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/quaternary/TestQsAlign.java","prod_time":"2016-07-23 00:19:00","test_time":"2016-07-25 21:29:13","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"1768642335ee6a91c7087784d4dfae555801226e","test_commitID":"d6d6b405b0a564f637ca69f37343d5ce2097e5d1","isfound":"found test change","originPro":"package org.biojava.nbio.structure.align.quaternary;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClusterer;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.cluster.SubunitExtractor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Quaternary Structure Alignment (QS-Align). The algorithm takes as input two\n * protein structures at the quaternary structure level (multiple interacting\n * chains) and calculates the equivalent cross chains and the optimal\n * superposition of the complexes, together with alignment quality scores.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class QsAlign {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(QsAlign.class);\n\n\tpublic static QsAlignResult align(Structure s1, Structure s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\t\treturn align(SubunitExtractor.extractSubunits(s1, cParams),\n\t\t\t\tSubunitExtractor.extractSubunits(s2, cParams), cParams, aParams);\n\t}\n\n\tpublic static QsAlignResult align(List<Subunit> s1, List<Subunit> s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\n\t\tQsAlignResult result = new QsAlignResult(s1, s2);\n\n\t\t// SETP 1: cluster each group of subunits O(N^2*L^2) - intra\n\t\tList<SubunitCluster> c1 = SubunitClusterer.cluster(s1, cParams);\n\t\tList<SubunitCluster> c2 = SubunitClusterer.cluster(s2, cParams);\n\n\t\t// STEP 2: match each subunit cluster between groups O(N^2*L^2) - inter\n\t\tMap<Integer, Integer> clusterMap = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < c1.size(); i++) {\n\t\t\tfor (int j = 0; j < c2.size(); j++) {\n\n\t\t\t\tif (clusterMap.keySet().contains(i))\n\t\t\t\t\tbreak;\n\t\t\t\tif (clusterMap.values().contains(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswitch (cParams.getClustererMethod()) {\n\n\t\t\t\tcase IDENTITY:\n\t\t\t\t\tif (c1.get(i).mergeIdentical(c2.get(j)))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEQUENCE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (c1.get(i).mergeSequence(c2.get(j),\n\t\t\t\t\t\t\t\tcParams.getSequenceIdentityThreshold(),\n\t\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\tlogger.warn(\"Could compare by Sequence. {}\",\n\t\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // case STRUCTURE:\n\t\t\t\t\tif (c1.get(i).mergeStructure(c2.get(j),\n\t\t\t\t\t\t\tcParams.getRmsdThreshold(),\n\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: Align the assemblies for each cluster match O(L^2+N^2)\n\t\tfor (int globalKey : clusterMap.keySet()) {\n\n\t\t\t// Obtain the clusters\n\t\t\tSubunitCluster clust1 = c1.get(globalKey);\n\t\t\tSubunitCluster clust2 = c2.get(clusterMap.get(globalKey));\n\n\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\tint index1 = 0;\n\t\t\tint index2 = clust1.size() - clust2.size();\n\n\t\t\tAtom[] atoms1 = clust1.getAlignedAtomsSubunit(index1);\n\t\t\tAtom[] atoms2 = clust1.getAlignedAtomsSubunit(index2);\n\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(atoms1, atoms2);\n\t\t\tMatrix4d trans = svd.getTransformation();\n\n\t\t\t// Map the subunits of each cluster to their spatial equivalents\n\t\t\tMap<Integer, Map<Integer, Integer>> clustSubunitMap = new HashMap<Integer, Map<Integer, Integer>>();\n\n\t\t\tfor (int key : clusterMap.keySet()) {\n\n\t\t\t\t// Obtain the clusters\n\t\t\t\tclust1 = c1.get(key);\n\t\t\t\tclust2 = c2.get(clusterMap.get(key));\n\n\t\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\t\tindex1 = 0;\n\t\t\t\tindex2 = clust1.size() - clust2.size();\n\n\t\t\t\t// Map the subunits of the cluster to their spatial equivalents\n\t\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\n\t\t\t\tfor (int i = 0; i < index2; i++) {\n\t\t\t\t\tfor (int j = index2; j < clust1.size(); j++) {\n\n\t\t\t\t\t\tif (subunitMap.keySet().contains(i))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (subunitMap.values().contains(j))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// Obtain centroids and transform the second\n\t\t\t\t\t\tAtom centr1 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(i));\n\t\t\t\t\t\tAtom centr2 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(j));\n\t\t\t\t\t\tCalc.transform(centr2, trans);\n\n\t\t\t\t\t\tif (Calc.getDistance(centr1, centr2) < aParams\n\t\t\t\t\t\t\t\t.getdCutoff())\n\t\t\t\t\t\t\tsubunitMap.put(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclustSubunitMap.put(key, subunitMap);\n\t\t\t}\n\n\t\t\t// Unfold the nested map into subunit map and alignment\n\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\t\t\tList<Integer> alignRes1 = new ArrayList<Integer>();\n\t\t\tList<Integer> alignRes2 = new ArrayList<Integer>();\n\t\t\tList<Atom> atomArray1 = new ArrayList<Atom>();\n\t\t\tList<Atom> atomArray2 = new ArrayList<Atom>();\n\n\t\t\tfor (int key : clustSubunitMap.keySet()) {\n\n\t\t\t\t// Obtain the cluster and the alignment in it\n\t\t\t\tSubunitCluster cluster = c1.get(key);\n\t\t\t\tList<List<Integer>> clusterEqrs = cluster\n\t\t\t\t\t\t.getMultipleAlignment().getBlock(0).getAlignRes();\n\n\t\t\t\tfor (Entry<Integer, Integer> pair : clustSubunitMap.get(key)\n\t\t\t\t\t\t.entrySet()) {\n\n\t\t\t\t\tint i = pair.getKey();\n\t\t\t\t\tint j = pair.getValue();\n\n\t\t\t\t\t// Obtain the indices of the original Subunit Lists\n\t\t\t\t\tint orig1 = s1.indexOf(cluster.getSubunits().get(i));\n\t\t\t\t\tint orig2 = s2.indexOf(cluster.getSubunits().get(j));\n\n\t\t\t\t\t// Append rescaled aligned residue indices\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(i))\n\t\t\t\t\t\talignRes1.add(eqr + atomArray1.size());\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(j))\n\t\t\t\t\t\talignRes2.add(eqr + atomArray2.size());\n\n\t\t\t\t\t// Apend atoms to the arrays\n\t\t\t\t\tatomArray1.addAll(Arrays.asList(s1.get(orig1)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\t\t\t\t\tatomArray2.addAll(Arrays.asList(s2.get(orig2)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\n\t\t\t\t\tsubunitMap.put(orig1, orig2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Evaluate the goodness of the match with an alignment object\n\t\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\t\tArrays.asList(new Atom[][] {\n\t\t\t\t\t\t\tatomArray1.toArray(new Atom[atomArray1.size()]),\n\t\t\t\t\t\t\tatomArray2.toArray(new Atom[atomArray2.size()]) }));\n\n\t\t\t// Fill in the alignment information\n\t\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\t\tBlock b = new BlockImpl(bs);\n\t\t\tList<List<Integer>> alignRes = new ArrayList<List<Integer>>(2);\n\t\t\talignRes.add(alignRes1);\n\t\t\talignRes.add(alignRes2);\n\t\t\tb.setAlignRes(alignRes);\n\n\t\t\t// Fill in the transformation matrices\n\t\t\tnew ReferenceSuperimposer().superimpose(msa);\n\n\t\t\t// Calculate some scores\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// If it is the best match found so far store it\n\t\t\tif (subunitMap.size() > result.getSubunitMap().size()) {\n\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\tresult.setAlignment(msa);\n\t\t\t} else if (subunitMap.size() == result.getSubunitMap().size()) {\n\t\t\t\tif (result.getAlignment() == null) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t} else if (msa.getScore(MultipleAlignmentScorer.RMSD) < result\n\t\t\t\t\t\t.getRmsd()) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.align.quaternary;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClusterer;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.cluster.SubunitExtractor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Quaternary Structure Alignment (QS-Align). The algorithm takes as input two\n * protein structures at the quaternary structure level (multiple interacting\n * chains) and calculates the equivalent cross chains and the optimal\n * superposition of the complexes, together with alignment quality scores.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class QsAlign {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(QsAlign.class);\n\n\tpublic static QsAlignResult align(Structure s1, Structure s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\t\treturn align(\n\t\t\t\tSubunitExtractor.extractSubunits(s1,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()),\n\t\t\t\tSubunitExtractor.extractSubunits(s2,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()), cParams, aParams);\n\t}\n\n\tpublic static QsAlignResult align(List<Subunit> s1, List<Subunit> s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\n\t\tQsAlignResult result = new QsAlignResult(s1, s2);\n\n\t\t// SETP 1: cluster each group of subunits O(N^2*L^2) - intra\n\t\tList<SubunitCluster> c1 = SubunitClusterer.cluster(s1, cParams);\n\t\tList<SubunitCluster> c2 = SubunitClusterer.cluster(s2, cParams);\n\n\t\t// STEP 2: match each subunit cluster between groups O(N^2*L^2) - inter\n\t\tMap<Integer, Integer> clusterMap = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < c1.size(); i++) {\n\t\t\tfor (int j = 0; j < c2.size(); j++) {\n\n\t\t\t\tif (clusterMap.keySet().contains(i))\n\t\t\t\t\tbreak;\n\t\t\t\tif (clusterMap.values().contains(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswitch (cParams.getClustererMethod()) {\n\n\t\t\t\tcase IDENTITY:\n\t\t\t\t\tif (c1.get(i).mergeIdentical(c2.get(j)))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEQUENCE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (c1.get(i).mergeSequence(c2.get(j),\n\t\t\t\t\t\t\t\tcParams.getSequenceIdentityThreshold(),\n\t\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\tlogger.warn(\"Could compare by Sequence. {}\",\n\t\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // case STRUCTURE:\n\t\t\t\t\tif (c1.get(i).mergeStructure(c2.get(j),\n\t\t\t\t\t\t\tcParams.getRmsdThreshold(),\n\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: Align the assemblies for each cluster match O(L^2+N^2)\n\t\tfor (int globalKey : clusterMap.keySet()) {\n\n\t\t\t// Obtain the clusters\n\t\t\tSubunitCluster clust1 = c1.get(globalKey);\n\t\t\tSubunitCluster clust2 = c2.get(clusterMap.get(globalKey));\n\n\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\tint index1 = 0;\n\t\t\tint index2 = clust1.size() - clust2.size();\n\n\t\t\tAtom[] atoms1 = clust1.getAlignedAtomsSubunit(index1);\n\t\t\tAtom[] atoms2 = clust1.getAlignedAtomsSubunit(index2);\n\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(atoms1, atoms2);\n\t\t\tMatrix4d trans = svd.getTransformation();\n\n\t\t\t// Map the subunits of each cluster to their spatial equivalents\n\t\t\tMap<Integer, Map<Integer, Integer>> clustSubunitMap = new HashMap<Integer, Map<Integer, Integer>>();\n\n\t\t\tfor (int key : clusterMap.keySet()) {\n\n\t\t\t\t// Obtain the clusters\n\t\t\t\tclust1 = c1.get(key);\n\t\t\t\tclust2 = c2.get(clusterMap.get(key));\n\n\t\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\t\tindex1 = 0;\n\t\t\t\tindex2 = clust1.size() - clust2.size();\n\n\t\t\t\t// Map the subunits of the cluster to their spatial equivalents\n\t\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\n\t\t\t\tfor (int i = 0; i < index2; i++) {\n\t\t\t\t\tfor (int j = index2; j < clust1.size(); j++) {\n\n\t\t\t\t\t\tif (subunitMap.keySet().contains(i))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (subunitMap.values().contains(j))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// Obtain centroids and transform the second\n\t\t\t\t\t\tAtom centr1 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(i));\n\t\t\t\t\t\tAtom centr2 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(j));\n\t\t\t\t\t\tCalc.transform(centr2, trans);\n\n\t\t\t\t\t\tif (Calc.getDistance(centr1, centr2) < aParams\n\t\t\t\t\t\t\t\t.getdCutoff())\n\t\t\t\t\t\t\tsubunitMap.put(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclustSubunitMap.put(key, subunitMap);\n\t\t\t}\n\n\t\t\t// Unfold the nested map into subunit map and alignment\n\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\t\t\tList<Integer> alignRes1 = new ArrayList<Integer>();\n\t\t\tList<Integer> alignRes2 = new ArrayList<Integer>();\n\t\t\tList<Atom> atomArray1 = new ArrayList<Atom>();\n\t\t\tList<Atom> atomArray2 = new ArrayList<Atom>();\n\n\t\t\tfor (int key : clustSubunitMap.keySet()) {\n\n\t\t\t\t// Obtain the cluster and the alignment in it\n\t\t\t\tSubunitCluster cluster = c1.get(key);\n\t\t\t\tList<List<Integer>> clusterEqrs = cluster\n\t\t\t\t\t\t.getMultipleAlignment().getBlock(0).getAlignRes();\n\n\t\t\t\tfor (Entry<Integer, Integer> pair : clustSubunitMap.get(key)\n\t\t\t\t\t\t.entrySet()) {\n\n\t\t\t\t\tint i = pair.getKey();\n\t\t\t\t\tint j = pair.getValue();\n\n\t\t\t\t\t// Obtain the indices of the original Subunit Lists\n\t\t\t\t\tint orig1 = s1.indexOf(cluster.getSubunits().get(i));\n\t\t\t\t\tint orig2 = s2.indexOf(cluster.getSubunits().get(j));\n\n\t\t\t\t\t// Append rescaled aligned residue indices\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(i))\n\t\t\t\t\t\talignRes1.add(eqr + atomArray1.size());\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(j))\n\t\t\t\t\t\talignRes2.add(eqr + atomArray2.size());\n\n\t\t\t\t\t// Apend atoms to the arrays\n\t\t\t\t\tatomArray1.addAll(Arrays.asList(s1.get(orig1)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\t\t\t\t\tatomArray2.addAll(Arrays.asList(s2.get(orig2)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\n\t\t\t\t\tsubunitMap.put(orig1, orig2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Evaluate the goodness of the match with an alignment object\n\t\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\t\tArrays.asList(new Atom[][] {\n\t\t\t\t\t\t\tatomArray1.toArray(new Atom[atomArray1.size()]),\n\t\t\t\t\t\t\tatomArray2.toArray(new Atom[atomArray2.size()]) }));\n\n\t\t\t// Fill in the alignment information\n\t\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\t\tBlock b = new BlockImpl(bs);\n\t\t\tList<List<Integer>> alignRes = new ArrayList<List<Integer>>(2);\n\t\t\talignRes.add(alignRes1);\n\t\t\talignRes.add(alignRes2);\n\t\t\tb.setAlignRes(alignRes);\n\n\t\t\t// Fill in the transformation matrices\n\t\t\tnew ReferenceSuperimposer().superimpose(msa);\n\n\t\t\t// Calculate some scores\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// If it is the best match found so far store it\n\t\t\tif (subunitMap.size() > result.getSubunitMap().size()) {\n\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\tresult.setAlignment(msa);\n\t\t\t} else if (subunitMap.size() == result.getSubunitMap().size()) {\n\t\t\t\tif (result.getAlignment() == null) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t} else if (msa.getScore(MultipleAlignmentScorer.RMSD) < result\n\t\t\t\t\t\t.getRmsd()) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.align.quaternary;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.junit.Test;\n\n/**\n * Test the correctness of the {@link QsAlign} algorithm with some examples of\n * different levels of quaternary structure similarity.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestQsAlign {\n\n\t/**\n\t * Identity: test hemoglobin against itself.\n\t */\n\t@Test\n\tpublic void testIdentity() throws StructureException, IOException {\n\n\t}\n\n\t/**\n\t * Proliferating cell nuclear antigens (1PLR, 3HI8) are structurally\n\t * equivalent C3 homotrimers.\n\t */\n\t@Test\n\tpublic void testHomoEquivalent() throws StructureException, IOException {\n\n\t}\n\n\t/**\n\t * Phycocyanins (2VML, 2BV8) are equivalent D3 heterododecamers with A6B6\n\t * stoichiometry.\n\t */\n\t@Test\n\tpublic void testHeteroEquivalent() throws StructureException, IOException {\n\n\t}\n\n\t/**\n\t * Cytochrome bc1 complexes (1BCC, 1KB9) have some equivalent Chains and\n\t * some unmatched.\n\t */\n\t@Test\n\tpublic void testHeteroPartialComplete() throws StructureException,\n\t\t\tIOException {\n\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.structure.align.quaternary;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.junit.Test;\n\n/**\n * Test the correctness of the {@link QsAlign} algorithm with some examples of\n * different levels of quaternary structure similarity.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestQsAlign {\n\n\t/**\n\t * Identity: test hemoglobin (4HHB) against itself.\n\t */\n\t@Test\n\tpublic void testIdentity() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = s1;\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 4);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertEquals(result.getAlignedSubunits1(), result.getAlignedSubunits2());\n\t\tassertEquals(result.getRmsd(), 0.0, 0.01);\n\n\t}\n\t\n\t/**\n\t * Different: test two completely different proteins (4HHB, 3IFV).\n\t */\n\t@Test\n\tpublic void testDifferent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = StructureIO.getStructure(\"3ifv\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 0);\n\t\tassertEquals(result.getRelation(), QsRelation.DIFFERENT);\n\n\t}\n\n\t/**\n\t * Proliferating cell nuclear antigens (3IFV, 3HI8) are structurally\n\t * equivalent C3 homotrimers.\n\t */\n\t@Test\n\tpublic void testHomoEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"3ifv\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:3hi8:1\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 3);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Phycocyanins (2VML, 2BV8) are equivalent D3 heterododecamers with A6B6\n\t * stoichiometry.\n\t */\n\t@Test\n\tpublic void testHeteroEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"2vml\");\n\t\tStructure s2 = StructureIO.getStructure(\"2bv8\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 12);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n\t/**\n\t * Hydratases (2B3M dimer, 1Q6W hexamer). The C2 dimer is\n\t * triplicated into a D3 assembly.\n\t */\n\t@Test\n\tpublic void testPartialComplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"BIO:2b3m:1\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:1Q6W:7\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 3);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_COMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Cytochrome bc1 complexes (1BCC, 1KB9) have some equivalent Chains and\n\t * some unmatched.\n\t */\n\t@Test\n\tpublic void testPartialIncomplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"1bcc\");\n\t\tStructure s2 = StructureIO.getStructure(\"1kb9\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 8);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_INCOMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n}\n","commitMessage":"Fix compilation errors and tests for QuatSymmetry 1","test_commitMessage":"Implement test for QsAlign algorithm","allZero":false}