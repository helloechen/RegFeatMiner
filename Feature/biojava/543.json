{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/search/io/blast/BlastXMLParser.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/search/io/blast/BlastXMLParserTest.java","prod_time":"2016-03-10 01:48:26","test_time":"","type":"","proType":"EDIT","add_annotation_line":3,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"d29b8f3fd257de376200ec264aa198bd67632379","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\n\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPathException;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.XMLHelper;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\n\n/**\n * Re-designed by Paolo Pavan on the footprint of:\n * org.biojava.nbio.genome.query.BlastXMLQuery by Scooter Willis <willishf at gmail dot com>\n *\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n *\n * @author Paolo Pavan\n */\npublic class BlastXMLParser implements ResultFactory {\n\tprivate static final org.slf4j.Logger logger = LoggerFactory.getLogger(Hsp.class);\n\tDocument blastDoc = null;\n\tprivate File targetFile;\n\tprivate List<Sequence> queryReferences, databaseReferences;\n\tprivate Map<String,Sequence> queryReferencesMap, databaseReferencesMap;\n\n\tpublic BlastXMLParser() {\n\n\t}\n\tpublic void setFile(File f){\n\t\ttargetFile = f;\n\t}\n\n\tprivate void readFile(String blastFile) throws IOException, ParseException{\n\t\tlogger.info(\"Start reading \" + blastFile);\n\t\ttry {\n\t\t\tblastDoc = XMLHelper.loadXML(blastFile);\n\t\t} catch (SAXException ex) {\n\t\t\tlogger.error(\"A parsing error has occurred while reading XML blast file\");\n\t\t\tthrow new ParseException(ex.getMessage(),0);\n\t\t} catch (ParserConfigurationException ex) {\n\t\t\tlogger.error(\"Internal XML parser non properly configured\");\n\t\t\tthrow new ParseException(ex.getMessage(),0);\n\t\t}\n\t\tlogger.info(\"Read finished\");\n\t}\n\n\tpublic List<Result> createObjects(double maxEScore) throws IOException, ParseException {\n\t\tif (targetFile == null) throw new IllegalStateException(\"File to be parsed not specified.\");\n\n\t\t// getAbsolutePath throws SecurityException\n\t\treadFile(targetFile.getAbsolutePath());\n\t\t// create mappings between sequences and blast id\n\t\tmapIds();\n\n\t\tArrayList<Result> resultsCollection;\n\t\tArrayList<Hit> hitsCollection;\n\t\tArrayList<Hsp> hspsCollection;\n\n\t\ttry {\n\t\t\t// select top level elements\n\t\t\tString program = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_program\").getTextContent();\n\t\t\tString version = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_version\").getTextContent();\n\t\t\tString reference = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_reference\").getTextContent();\n\t\t\tString dbFile = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_db\").getTextContent();\n\n\t\t\tlogger.info(\"Query for hits in \"+ targetFile);\n\t\t\tArrayList<Element> IterationsList = XMLHelper.selectElements(blastDoc.getDocumentElement(), \"BlastOutput_iterations/Iteration[Iteration_hits]\");\n\t\t\tlogger.info(IterationsList.size() + \" results\");\n\n\t\t\tresultsCollection = new ArrayList<Result>();\n\t\t\tfor (Element element : IterationsList) {\n\t\t\t\tBlastResultBuilder resultBuilder = new BlastResultBuilder();\n\t\t\t\t// will add BlastOutput* key sections in the result object\n\t\t\t\tresultBuilder\n\t\t\t\t\t.setProgram(program)\n\t\t\t\t\t.setVersion(version)\n\t\t\t\t\t.setReference(reference)\n\t\t\t\t\t.setDbFile(dbFile);\n\n\t\t\t\t// Iteration* section keys:\n\t\t\t\tresultBuilder\n\t\t\t\t\t.setIterationNumber(new Integer(XMLHelper.selectSingleElement(element,\"Iteration_iter-num\").getTextContent()))\n\t\t\t\t\t.setQueryID(XMLHelper.selectSingleElement(element,\"Iteration_query-ID\").getTextContent())\n\t\t\t\t\t.setQueryDef(XMLHelper.selectSingleElement(element, \"Iteration_query-def\").getTextContent())\n\t\t\t\t\t.setQueryLength(new Integer(XMLHelper.selectSingleElement(element,\"Iteration_query-len\").getTextContent()));\n\n\t\t\t\tif (queryReferences != null) resultBuilder.setQuerySequence(queryReferencesMap.get(\n\t\t\t\t\t\tXMLHelper.selectSingleElement(element,\"Iteration_query-ID\").getTextContent()\n\t\t\t\t));\n\n\n\n\t\t\t\tElement iterationHitsElement = XMLHelper.selectSingleElement(element, \"Iteration_hits\");\n\t\t\t\tArrayList<Element> hitList = XMLHelper.selectElements(iterationHitsElement, \"Hit\");\n\n\t\t\t\thitsCollection = new ArrayList<Hit>();\n\t\t\t\tfor (Element hitElement : hitList) {\n\t\t\t\t\tBlastHitBuilder blastHitBuilder = new BlastHitBuilder();\n\t\t\t\t\tblastHitBuilder\n\t\t\t\t\t\t.setHitNum(new Integer(XMLHelper.selectSingleElement(hitElement, \"Hit_num\").getTextContent()))\n\t\t\t\t\t\t.setHitId(XMLHelper.selectSingleElement(hitElement, \"Hit_id\").getTextContent())\n\t\t\t\t\t\t.setHitDef(XMLHelper.selectSingleElement(hitElement, \"Hit_def\").getTextContent())\n\t\t\t\t\t\t.setHitAccession(XMLHelper.selectSingleElement(hitElement, \"Hit_accession\").getTextContent())\n\t\t\t\t\t\t.setHitLen(new Integer(XMLHelper.selectSingleElement(hitElement, \"Hit_len\").getTextContent()));\n\n\t\t\t\t\tif (databaseReferences != null) blastHitBuilder.setHitSequence(databaseReferencesMap.get(\n\t\t\t\t\t\tXMLHelper.selectSingleElement(hitElement, \"Hit_id\").getTextContent()\n\t\t\t\t\t));\n\n\t\t\t\t\tElement hithspsElement = XMLHelper.selectSingleElement(hitElement, \"Hit_hsps\");\n\t\t\t\t\tArrayList<Element> hspList = XMLHelper.selectElements(hithspsElement, \"Hsp\");\n\n\t\t\t\t\thspsCollection = new ArrayList<Hsp>();\n\t\t\t\t\tfor (Element hspElement : hspList) {\n\t\t\t\t\t\tDouble evalue = new Double(XMLHelper.selectSingleElement(hspElement, \"Hsp_evalue\").getTextContent());\n\n\t\t\t\t\t\t// add the new hsp only if it pass the specified threshold. It can save lot of memory and some parsing time\n\t\t\t\t\t\tif (evalue <= maxEScore) {\n\t\t\t\t\t\t\tBlastHspBuilder blastHspBuilder = new BlastHspBuilder();\n\t\t\t\t\t\t\tblastHspBuilder\n\t\t\t\t\t\t\t\t.setHspNum(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_num\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspBitScore(new Double(XMLHelper.selectSingleElement(hspElement, \"Hsp_bit-score\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspScore(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_score\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspEvalue(evalue)\n\t\t\t\t\t\t\t\t.setHspQueryFrom(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-from\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQueryTo(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-to\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitFrom(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-from\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitTo(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-to\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQueryFrame(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-frame\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitFrame(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-frame\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspIdentity(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_identity\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspPositive(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_positive\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspGaps(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_gaps\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspAlignLen(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_align-len\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQseq(XMLHelper.selectSingleElement(hspElement, \"Hsp_qseq\").getTextContent())\n\t\t\t\t\t\t\t\t.setHspHseq(XMLHelper.selectSingleElement(hspElement, \"Hsp_hseq\").getTextContent())\n\t\t\t\t\t\t\t\t.setHspIdentityString(XMLHelper.selectSingleElement(hspElement, \"Hsp_midline\").getTextContent());\n\n\t\t\t\t\t\t\thspsCollection.add(blastHspBuilder.createBlastHsp());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// finally set the computed hsp collection and create Hit object\n\t\t\t\t\tblastHitBuilder.setHsps(hspsCollection);\n\t\t\t\t\thitsCollection.add(blastHitBuilder.createBlastHit());\n\t\t\t\t}\n\t\t\t\t// finally set the computed Hit collection to the result\n\t\t\t\tresultBuilder.setHits(hitsCollection);\n\t\t\t\tresultsCollection.add(resultBuilder.createBlastResult());\n\t\t\t}\n\t\t} catch (XPathException e) {\n\t\t\tthrow new ParseException(e.getMessage(),0);\n\t\t}\n\t\tlogger.info(\"Parsing of \"+targetFile+\" finished.\");\n\n\t\treturn resultsCollection;\n\t}\n\n\tpublic List<String> getFileExtensions(){\n\t\tArrayList<String> extensions = new ArrayList<String>(1);\n\t\textensions.add(\"blastxml\");\n\t\treturn extensions;\n\t}\n\n\t@Override\n\tpublic void setQueryReferences(List<Sequence> sequences) {\n\t\tqueryReferences = sequences;\n\t}\n\n\t@Override\n\tpublic void setDatabaseReferences(List<Sequence> sequences) {\n\t\tdatabaseReferences = sequences;\n\t}\n\n\t/**\n\t * fill the map association between sequences an a unique id\n\t */\n\tprivate void mapIds() {\n\t\tif (queryReferences != null) {\n\t\t\tqueryReferencesMap = new HashMap<String,Sequence>(queryReferences.size());\n\t\t\tfor (int counter=0; counter < queryReferences.size() ; counter ++){\n\t\t\t\tString id = \"Query_\"+(counter+1);\n\t\t\t\tqueryReferencesMap.put(id, queryReferences.get(counter));\n\t\t\t}\n\t\t}\n\n\t\tif (databaseReferences != null) {\n\t\t\tdatabaseReferencesMap = new HashMap<String,Sequence>(databaseReferences.size());\n\t\t\tfor (int counter=0; counter < databaseReferences.size() ; counter ++){\n\t\t\t\t// this is strange: while Query_id are 1 based, Hit (database) id are 0 based\n\t\t\t\tString id = \"gnl|BL_ORD_ID|\"+(counter);\n\t\t\t\tdatabaseReferencesMap.put(id, databaseReferences.get(counter));\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void storeObjects(List<Result> results) throws IOException, ParseException {\n\t\tthrow new UnsupportedOperationException(\"This parser does not support writing yet.\");\n\t}\n}\n\n\nclass BlastHsp extends org.biojava.nbio.core.search.io.Hsp {\n\tpublic BlastHsp(int hspNum, double hspBitScore, int hspScore, double hspEvalue, int hspQueryFrom, int hspQueryTo, int hspHitFrom, int hspHitTo, int hspQueryFrame, int hspHitFrame, int hspIdentity, int hspPositive, int hspGaps, int hspAlignLen, String hspQseq, String hspHseq, String hspIdentityString, Double percentageIdentity, Integer mismatchCount) {\n\t\tsuper(hspNum, hspBitScore, hspScore, hspEvalue, hspQueryFrom, hspQueryTo, hspHitFrom, hspHitTo, hspQueryFrame, hspHitFrame, hspIdentity, hspPositive, hspGaps, hspAlignLen, hspQseq, hspHseq, hspIdentityString, percentageIdentity, mismatchCount);\n\t}\n\n}\n\nclass BlastHit extends org.biojava.nbio.core.search.io.Hit {\n\tpublic BlastHit(int hitNum, String hitId, String hitDef, String hitAccession, int hitLen, List<Hsp> hitHsps, Sequence hitSequence) {\n\t\tsuper(hitNum, hitId, hitDef, hitAccession, hitLen, hitHsps, hitSequence);\n\t}\n\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\n\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPathException;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.XMLHelper;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\n\n/**\n * Re-designed by Paolo Pavan on the footprint of:\n * org.biojava.nbio.genome.query.BlastXMLQuery by Scooter Willis <willishf at gmail dot com>\n *\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n *\n * @author Paolo Pavan\n */\npublic class BlastXMLParser implements ResultFactory {\n\tprivate static final org.slf4j.Logger logger = LoggerFactory.getLogger(Hsp.class);\n\tDocument blastDoc = null;\n\tprivate File targetFile;\n\tprivate List<Sequence> queryReferences, databaseReferences;\n\tprivate Map<String,Sequence> queryReferencesMap, databaseReferencesMap;\n\n\tpublic BlastXMLParser() {\n\n\t}\n\t@Override\n\tpublic void setFile(File f){\n\t\ttargetFile = f;\n\t}\n\n\tprivate void readFile(String blastFile) throws IOException, ParseException{\n\t\tlogger.info(\"Start reading \" + blastFile);\n\t\ttry {\n\t\t\tblastDoc = XMLHelper.loadXML(blastFile);\n\t\t} catch (SAXException ex) {\n\t\t\tlogger.error(\"A parsing error has occurred while reading XML blast file\");\n\t\t\tthrow new ParseException(ex.getMessage(),0);\n\t\t} catch (ParserConfigurationException ex) {\n\t\t\tlogger.error(\"Internal XML parser non properly configured\");\n\t\t\tthrow new ParseException(ex.getMessage(),0);\n\t\t}\n\t\tlogger.info(\"Read finished\");\n\t}\n\n\t@Override\n\tpublic List<Result> createObjects(double maxEScore) throws IOException, ParseException {\n\t\tif (targetFile == null) throw new IllegalStateException(\"File to be parsed not specified.\");\n\n\t\t// getAbsolutePath throws SecurityException\n\t\treadFile(targetFile.getAbsolutePath());\n\t\t// create mappings between sequences and blast id\n\t\tmapIds();\n\n\t\tArrayList<Result> resultsCollection;\n\t\tArrayList<Hit> hitsCollection;\n\t\tArrayList<Hsp> hspsCollection;\n\n\t\ttry {\n\t\t\t// select top level elements\n\t\t\tString program = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_program\").getTextContent();\n\t\t\tString version = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_version\").getTextContent();\n\t\t\tString reference = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_reference\").getTextContent();\n\t\t\tString dbFile = XMLHelper.selectSingleElement(blastDoc.getDocumentElement(),\"BlastOutput_db\").getTextContent();\n\n\t\t\tlogger.info(\"Query for hits in \"+ targetFile);\n\t\t\tArrayList<Element> IterationsList = XMLHelper.selectElements(blastDoc.getDocumentElement(), \"BlastOutput_iterations/Iteration[Iteration_hits]\");\n\t\t\tlogger.info(IterationsList.size() + \" results\");\n\n\t\t\tresultsCollection = new ArrayList<Result>();\n\t\t\tfor (Element element : IterationsList) {\n\t\t\t\tBlastResultBuilder resultBuilder = new BlastResultBuilder();\n\t\t\t\t// will add BlastOutput* key sections in the result object\n\t\t\t\tresultBuilder\n\t\t\t\t\t.setProgram(program)\n\t\t\t\t\t.setVersion(version)\n\t\t\t\t\t.setReference(reference)\n\t\t\t\t\t.setDbFile(dbFile);\n\n\t\t\t\t// Iteration* section keys:\n\t\t\t\tresultBuilder\n\t\t\t\t\t.setIterationNumber(new Integer(XMLHelper.selectSingleElement(element,\"Iteration_iter-num\").getTextContent()))\n\t\t\t\t\t.setQueryID(XMLHelper.selectSingleElement(element,\"Iteration_query-ID\").getTextContent())\n\t\t\t\t\t.setQueryDef(XMLHelper.selectSingleElement(element, \"Iteration_query-def\").getTextContent())\n\t\t\t\t\t.setQueryLength(new Integer(XMLHelper.selectSingleElement(element,\"Iteration_query-len\").getTextContent()));\n\n\t\t\t\tif (queryReferences != null) resultBuilder.setQuerySequence(queryReferencesMap.get(\n\t\t\t\t\t\tXMLHelper.selectSingleElement(element,\"Iteration_query-ID\").getTextContent()\n\t\t\t\t));\n\n\n\n\t\t\t\tElement iterationHitsElement = XMLHelper.selectSingleElement(element, \"Iteration_hits\");\n\t\t\t\tArrayList<Element> hitList = XMLHelper.selectElements(iterationHitsElement, \"Hit\");\n\n\t\t\t\thitsCollection = new ArrayList<Hit>();\n\t\t\t\tfor (Element hitElement : hitList) {\n\t\t\t\t\tBlastHitBuilder blastHitBuilder = new BlastHitBuilder();\n\t\t\t\t\tblastHitBuilder\n\t\t\t\t\t\t.setHitNum(new Integer(XMLHelper.selectSingleElement(hitElement, \"Hit_num\").getTextContent()))\n\t\t\t\t\t\t.setHitId(XMLHelper.selectSingleElement(hitElement, \"Hit_id\").getTextContent())\n\t\t\t\t\t\t.setHitDef(XMLHelper.selectSingleElement(hitElement, \"Hit_def\").getTextContent())\n\t\t\t\t\t\t.setHitAccession(XMLHelper.selectSingleElement(hitElement, \"Hit_accession\").getTextContent())\n\t\t\t\t\t\t.setHitLen(new Integer(XMLHelper.selectSingleElement(hitElement, \"Hit_len\").getTextContent()));\n\n\t\t\t\t\tif (databaseReferences != null) blastHitBuilder.setHitSequence(databaseReferencesMap.get(\n\t\t\t\t\t\tXMLHelper.selectSingleElement(hitElement, \"Hit_id\").getTextContent()\n\t\t\t\t\t));\n\n\t\t\t\t\tElement hithspsElement = XMLHelper.selectSingleElement(hitElement, \"Hit_hsps\");\n\t\t\t\t\tArrayList<Element> hspList = XMLHelper.selectElements(hithspsElement, \"Hsp\");\n\n\t\t\t\t\thspsCollection = new ArrayList<Hsp>();\n\t\t\t\t\tfor (Element hspElement : hspList) {\n\t\t\t\t\t\tDouble evalue = new Double(XMLHelper.selectSingleElement(hspElement, \"Hsp_evalue\").getTextContent());\n\n\t\t\t\t\t\t// add the new hsp only if it pass the specified threshold. It can save lot of memory and some parsing time\n\t\t\t\t\t\tif (evalue <= maxEScore) {\n\t\t\t\t\t\t\tBlastHspBuilder blastHspBuilder = new BlastHspBuilder();\n\t\t\t\t\t\t\tblastHspBuilder\n\t\t\t\t\t\t\t\t.setHspNum(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_num\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspBitScore(new Double(XMLHelper.selectSingleElement(hspElement, \"Hsp_bit-score\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspScore(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_score\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspEvalue(evalue)\n\t\t\t\t\t\t\t\t.setHspQueryFrom(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-from\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQueryTo(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-to\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitFrom(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-from\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitTo(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-to\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQueryFrame(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_query-frame\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspHitFrame(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_hit-frame\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspIdentity(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_identity\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspPositive(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_positive\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspGaps(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_gaps\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspAlignLen(new Integer(XMLHelper.selectSingleElement(hspElement, \"Hsp_align-len\").getTextContent()))\n\t\t\t\t\t\t\t\t.setHspQseq(XMLHelper.selectSingleElement(hspElement, \"Hsp_qseq\").getTextContent())\n\t\t\t\t\t\t\t\t.setHspHseq(XMLHelper.selectSingleElement(hspElement, \"Hsp_hseq\").getTextContent())\n\t\t\t\t\t\t\t\t.setHspIdentityString(XMLHelper.selectSingleElement(hspElement, \"Hsp_midline\").getTextContent());\n\n\t\t\t\t\t\t\thspsCollection.add(blastHspBuilder.createBlastHsp());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// finally set the computed hsp collection and create Hit object\n\t\t\t\t\tblastHitBuilder.setHsps(hspsCollection);\n\t\t\t\t\thitsCollection.add(blastHitBuilder.createBlastHit());\n\t\t\t\t}\n\t\t\t\t// finally set the computed Hit collection to the result\n\t\t\t\tresultBuilder.setHits(hitsCollection);\n\t\t\t\tresultsCollection.add(resultBuilder.createBlastResult());\n\t\t\t}\n\t\t} catch (XPathException e) {\n\t\t\tthrow new ParseException(e.getMessage(),0);\n\t\t}\n\t\tlogger.info(\"Parsing of \"+targetFile+\" finished.\");\n\n\t\treturn resultsCollection;\n\t}\n\n\t@Override\n\tpublic List<String> getFileExtensions(){\n\t\tArrayList<String> extensions = new ArrayList<String>(1);\n\t\textensions.add(\"blastxml\");\n\t\treturn extensions;\n\t}\n\n\t@Override\n\tpublic void setQueryReferences(List<Sequence> sequences) {\n\t\tqueryReferences = sequences;\n\t}\n\n\t@Override\n\tpublic void setDatabaseReferences(List<Sequence> sequences) {\n\t\tdatabaseReferences = sequences;\n\t}\n\n\t/**\n\t * fill the map association between sequences an a unique id\n\t */\n\tprivate void mapIds() {\n\t\tif (queryReferences != null) {\n\t\t\tqueryReferencesMap = new HashMap<String,Sequence>(queryReferences.size());\n\t\t\tfor (int counter=0; counter < queryReferences.size() ; counter ++){\n\t\t\t\tString id = \"Query_\"+(counter+1);\n\t\t\t\tqueryReferencesMap.put(id, queryReferences.get(counter));\n\t\t\t}\n\t\t}\n\n\t\tif (databaseReferences != null) {\n\t\t\tdatabaseReferencesMap = new HashMap<String,Sequence>(databaseReferences.size());\n\t\t\tfor (int counter=0; counter < databaseReferences.size() ; counter ++){\n\t\t\t\t// this is strange: while Query_id are 1 based, Hit (database) id are 0 based\n\t\t\t\tString id = \"gnl|BL_ORD_ID|\"+(counter);\n\t\t\t\tdatabaseReferencesMap.put(id, databaseReferences.get(counter));\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void storeObjects(List<Result> results) throws IOException, ParseException {\n\t\tthrow new UnsupportedOperationException(\"This parser does not support writing yet.\");\n\t}\n}\n\n\nclass BlastHsp extends org.biojava.nbio.core.search.io.Hsp {\n\tpublic BlastHsp(int hspNum, double hspBitScore, int hspScore, double hspEvalue, int hspQueryFrom, int hspQueryTo, int hspHitFrom, int hspHitTo, int hspQueryFrame, int hspHitFrame, int hspIdentity, int hspPositive, int hspGaps, int hspAlignLen, String hspQseq, String hspHseq, String hspIdentityString, Double percentageIdentity, Integer mismatchCount) {\n\t\tsuper(hspNum, hspBitScore, hspScore, hspEvalue, hspQueryFrom, hspQueryTo, hspHitFrom, hspHitTo, hspQueryFrame, hspHitFrame, hspIdentity, hspPositive, hspGaps, hspAlignLen, hspQseq, hspHseq, hspIdentityString, percentageIdentity, mismatchCount);\n\t}\n\n}\n\nclass BlastHit extends org.biojava.nbio.core.search.io.Hit {\n\tpublic BlastHit(int hitNum, String hitId, String hitDef, String hitAccession, int hitLen, List<Hsp> hitHsps, Sequence hitSequence) {\n\t\tsuper(hitNum, hitId, hitDef, hitAccession, hitLen, hitHsps, hitSequence);\n\t}\n\n}","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.junit.Ignore;\n\n/**\n *\n * @author Paolo Pavan\n */\npublic class BlastXMLParserTest {\n\n\tpublic BlastXMLParserTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of setFile method, of class BlastXMLParser.\n\t */\n\t@Test\n\tpublic void testSetFile() {\n\t\tSystem.out.println(\"setFile\");\n\t\tFile f = null;\n\t\tBlastXMLParser instance = new BlastXMLParser();\n\t\tinstance.setFile(f);\n\t}\n\n\tprotected  File getFileForResource(String resource){\n\t\tURL resourceURL = this.getClass().getResource(resource);\n\t\tString filepath = resourceURL.getFile();\n\t\tfilepath = filepath.replaceAll(\"%20\",\" \");\n\n\t\tFile file = new File(filepath);\n\n\t\treturn file;\n\t}\n\n\t/**\n\t * Test of createObjects method, of class BlastXMLParser.\n\t */\n\t@Test\n\tpublic void testCreateObjects() throws Exception {\n\t\tSystem.out.println(\"createObjects\");\n\n\t\tString resource = \"/org/biojava/nbio/core/search/io/blast/small-blastreport.blastxml\";\n\n\n\t\tFile file = getFileForResource(resource);\n\n\t\tBlastXMLParser instance = new BlastXMLParser();\n\t\tinstance.setFile(file);\n\n\t\t//instance.setQueryReferences(null);\n\t\t//instance.setDatabaseReferences(null);\n\t\tList<Result> result = instance.createObjects(1e-10);\n\n\t\t// test with random manual selected results\n\t\tBlastHsp hsp1hit1res1 = new BlastHspBuilder()\n\t\t\t\t.setHspNum(1)\n\t\t\t\t.setHspBitScore(2894.82)\n\t\t\t\t.setHspScore(1567)\n\t\t\t\t.setHspEvalue(0)\n\t\t\t\t.setHspQueryFrom(1)\n\t\t\t\t.setHspQueryTo(1567)\n\t\t\t\t.setHspHitFrom(616309)\n\t\t\t\t.setHspHitTo(617875)\n\t\t\t\t.setHspQueryFrame(1)\n\t\t\t\t.setHspHitFrame(1)\n\t\t\t\t.setHspIdentity(1567)\n\t\t\t\t.setHspPositive(1567)\n\t\t\t\t.setHspGaps(0)\n\t\t\t\t.setHspAlignLen(1567)\n\t\t\t\t.setHspQseq(\"TTAAATTGAGAGTTTGATCCTGGCTCAGGATGAACGCTGGTGGCGTGCCTAATACATGCAAGTCGTACGCTAGCCGCTGAATTGATCCTTCGGGTGAAGTGAGGCAATGACTAGAGTGGCGAACTGGTGAGTAACACGTAAGAAACCTGCCCTTTAGTGGGGGATAACATTTGGAAACAGATGCTAATACCGCGTAACAACAAATCACACATGTGATCTGTTTGAAAGGTCCTTTTGGATCGCTAGAGGATGGTCTTGCGGCGTATTAGCTTGTTGGTAGGGTAGAAGCCTACCAAGGCAATGATGCGTAGCCGAGTTGAGAGACTGGCCGGCCACATTGGGACTGAGACACTGCCCAAACTCCTACGGGAGGCTGCAGTAGGGAATTTTCCGCAATGCACGAAAGTGTGACGGAGCGACGCCGCGTGTGTGATGAAGGCTTTCGGGTCGTAAAGCACTGTTGTAAGGGAAGAATAACTGAATTCAGAGAAAGTTTTCAGCTTGACGGTACCTTACCAGAAAGGGATGGCTAAATACGTGCCAGCAGCCGCGGTAATACGTATGTCCCGAGCGTTATCCGGATTTATTGGGCGTAAAGCGAGCGCAGACGGTTTATTAAGTCTGATGTGAAATCCCGAGGCCCAACCTCGGAACTGCATTGGAAACTGATTTACTTGAGTGCGATAGAGGCAAGTGGAACTCCATGTGTAGCGGTGAAATGCGTAGATATGTGGAAGAACACCAGTGGCGAAAGCGGCTTGCTAGATCGTAACTGACGTTGAGGCTCGAAAGTATGGGTAGCAAACGGGATTAGATACCCCGGTAGTCCATACCGTAAACGATGGGTGCTAGTTGTTAAGAGGTTTCCGCCTCCTAGTGACGTAGCAAACGCATTAAGCACCCCGCCTGAGGAGTACGGCCGCAAGGCTAAAACTTAAAGGAATTGACGGGGACCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGAAGATACGCGAAAAACCTTACCAGGTCTTGACATACCAATGATCGCTTTTGTAATGAAAGCTTTTCTTCGGAACATTGGATACAGGTGGTGCATGGTCGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTTATTAGTTGCCAGCATTTAGTTGGGCACTCTAATGAGACTGCCGGTGATAAACCGGAGGAAGGTGGGGACGACGTCAGATCATCATGCCCCTTATGACCTGGGCAACACACGTGCTACAATGGGAAGTACAACGAGTCGCAAACCGGCGACGGTAAGCTAATCTCTTAAAACTTCTCTCAGTTCGGACTGGAGTCTGCAACTCGACTCCACGAAGGCGGAATCGCTAGTAATCGCGAATCAGCATGTCGCGGTGAATACGTTCCCGGGTCTTGTACACACCGCCCGTCAAATCATGGGAGTCGGAAGTACCCAAAGTCGCTTGGCTAACTTTTAGAGGCCGGTGCCTAAGGTAAAATCGATGACTGGGATTAAGTCGTAACAAGGTAGCCGTAGGAGAACCTGCGGCTGGATCACCTCCTTTCT\")\n\t\t\t\t.setHspHseq(\"TTAAATTGAGAGTTTGATCCTGGCTCAGGATGAACGCTGGTGGCGTGCCTAATACATGCAAGTCGTACGCTAGCCGCTGAATTGATCCTTCGGGTGAAGTGAGGCAATGACTAGAGTGGCGAACTGGTGAGTAACACGTAAGAAACCTGCCCTTTAGTGGGGGATAACATTTGGAAACAGATGCTAATACCGCGTAACAACAAATCACACATGTGATCTGTTTGAAAGGTCCTTTTGGATCGCTAGAGGATGGTCTTGCGGCGTATTAGCTTGTTGGTAGGGTAGAAGCCTACCAAGGCAATGATGCGTAGCCGAGTTGAGAGACTGGCCGGCCACATTGGGACTGAGACACTGCCCAAACTCCTACGGGAGGCTGCAGTAGGGAATTTTCCGCAATGCACGAAAGTGTGACGGAGCGACGCCGCGTGTGTGATGAAGGCTTTCGGGTCGTAAAGCACTGTTGTAAGGGAAGAATAACTGAATTCAGAGAAAGTTTTCAGCTTGACGGTACCTTACCAGAAAGGGATGGCTAAATACGTGCCAGCAGCCGCGGTAATACGTATGTCCCGAGCGTTATCCGGATTTATTGGGCGTAAAGCGAGCGCAGACGGTTTATTAAGTCTGATGTGAAATCCCGAGGCCCAACCTCGGAACTGCATTGGAAACTGATTTACTTGAGTGCGATAGAGGCAAGTGGAACTCCATGTGTAGCGGTGAAATGCGTAGATATGTGGAAGAACACCAGTGGCGAAAGCGGCTTGCTAGATCGTAACTGACGTTGAGGCTCGAAAGTATGGGTAGCAAACGGGATTAGATACCCCGGTAGTCCATACCGTAAACGATGGGTGCTAGTTGTTAAGAGGTTTCCGCCTCCTAGTGACGTAGCAAACGCATTAAGCACCCCGCCTGAGGAGTACGGCCGCAAGGCTAAAACTTAAAGGAATTGACGGGGACCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGAAGATACGCGAAAAACCTTACCAGGTCTTGACATACCAATGATCGCTTTTGTAATGAAAGCTTTTCTTCGGAACATTGGATACAGGTGGTGCATGGTCGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTTATTAGTTGCCAGCATTTAGTTGGGCACTCTAATGAGACTGCCGGTGATAAACCGGAGGAAGGTGGGGACGACGTCAGATCATCATGCCCCTTATGACCTGGGCAACACACGTGCTACAATGGGAAGTACAACGAGTCGCAAACCGGCGACGGTAAGCTAATCTCTTAAAACTTCTCTCAGTTCGGACTGGAGTCTGCAACTCGACTCCACGAAGGCGGAATCGCTAGTAATCGCGAATCAGCATGTCGCGGTGAATACGTTCCCGGGTCTTGTACACACCGCCCGTCAAATCATGGGAGTCGGAAGTACCCAAAGTCGCTTGGCTAACTTTTAGAGGCCGGTGCCTAAGGTAAAATCGATGACTGGGATTAAGTCGTAACAAGGTAGCCGTAGGAGAACCTGCGGCTGGATCACCTCCTTTCT\")\n\t\t\t\t.setHspIdentityString(\"|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\")\n\t\t\t\t.createBlastHsp();\n\t\tList<Hsp> hsplist = new ArrayList<Hsp>();\n\t\thsplist.add(hsp1hit1res1);\n\t\thsplist.add(hsp1hit1res1);\n\n\t\tBlastHit hit1res1 = new BlastHitBuilder()\n\t\t\t\t.setHitNum(1)\n\t\t\t\t.setHitId(\"gnl|BL_ORD_ID|2006\")\n\t\t\t\t.setHitDef(\"CP000411 Oenococcus oeni PSU-1, complete genome\")\n\t\t\t\t.setHitAccession(\"0\")\n\t\t\t\t.setHitLen(1780517)\n\t\t\t\t.setHsps(hsplist)\n\t\t\t\t.createBlastHit();\n\n\t\tList<Hit> hitlist = new ArrayList<Hit>();\n\t\thitlist.add(hit1res1);\n\n\t\tBlastResult res1 = new BlastResultBuilder()\n\t\t\t\t.setProgram(\"blastn\")\n\t\t\t\t.setVersion(\"BLASTN 2.2.29+\")\n\t\t\t\t.setReference(\"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), &quot;A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\")\n\t\t\t\t.setQueryID(\"Query_1\")\n\t\t\t\t.setQueryDef(\"CP000411_-_16S_rRNA Oenococcus oeni PSU-1, complete genome\")\n\t\t\t\t.setQueryLength(1567)\n\t\t\t\t.createBlastResult();\n\n\t\tResult expRes1 = result.get(0);\n\t\tHit expHit1res1 = expRes1.iterator().next();\n\t\tHsp expHsp1hit1res1 = expHit1res1.iterator().next();\n\n\t\t// result not testable without all hits and hsp\n\t\t//assertEquals(expRes1, res1);\n\n\t\t// hit test\n\t\tassertEquals(expHit1res1, hit1res1);\n\n\t\t// hsp test\n\t\tassertEquals(expHsp1hit1res1, hsp1hit1res1);\n\t}\n\n\t/**\n\t * Test of getFileExtensions method, of class BlastXMLParser.\n\t */\n\t@Test\n\tpublic void testGetFileExtensions() {\n\t\tSystem.out.println(\"getFileExtensions\");\n\t\tBlastXMLParser instance = new BlastXMLParser();\n\t\tList<String> result = instance.getFileExtensions();\n\t\tassertTrue(result.contains(\"blastxml\"));\n\t}\n\n\t/**\n\t * Test of setQueryReferences method, of class BlastXMLParser.\n\t */\n\t@Test\n\t@Ignore public void testSetQueryReferences() {\n\t\tSystem.out.println(\"setQueryReferences\");\n\t\tList<org.biojava.nbio.core.sequence.template.Sequence> sequences = null;\n\t\tBlastXMLParser instance = new BlastXMLParser();\n\t\tinstance.setQueryReferences(sequences);\n\t\t// TODO review the generated test code and remove the default call to fail.\n\t\tfail(\"The test case is a prototype.\");\n\t}\n\n\t/**\n\t * Test of setDatabaseReferences method, of class BlastXMLParser.\n\t */\n\t@Test\n\t@Ignore public void testSetDatabaseReferences() {\n\t\tSystem.out.println(\"setDatabaseReferences\");\n\t\tList<org.biojava.nbio.core.sequence.template.Sequence> sequences = null;\n\t\tBlastXMLParser instance = new BlastXMLParser();\n\t\tinstance.setDatabaseReferences(sequences);\n\t\t// TODO review the generated test code and remove the default call to fail.\n\t\tfail(\"The test case is a prototype.\");\n\t}\n\n\t/**\n\t * Test of storeObjects method, of class BlastXMLParser.\n\t */\n\t@Test\n\tpublic void testStoreObjects() throws Exception {\n\t\t// not implemented yet\n\t}\n}\n","changedTest":"","commitMessage":"Automatically adding missing @Override","test_commitMessage":"","allZero":false}