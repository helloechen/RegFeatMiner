{"repository":"biojava","prod_path":"alignment/src/main/java/org/biojava/bio/alignment/NeedlemanWunsch.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/NeedlemanWunschTest.java","prod_time":"2010-11-23 02:12:46","test_time":"","type":"","proType":"DELETE","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":1,"del_call_line":111,"del_classname_line":1,"del_condition_line":41,"del_field_line":7,"del_import_line":8,"del_packageid_line":1,"del_parameter_line":13,"del_return_line":14,"label":"NEGATIVE","prod_commitID":"668d72f359f6c7df777ae5f88021b3ebf3d5c41c","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.alignment;\n\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.SimpleAnnotation;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.impl.SimpleGappedSequence;\nimport org.biojava.bio.seq.impl.SimpleSequence;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * Needleman and Wunsch defined the problem of global sequence alignments, from\n * the first till the last symbol of a sequence. This class is able to perform\n * such global sequence comparisons efficiently by dynamic programming. If\n * inserts and deletes are equally expensive and as expensive as the extension\n * of a gap, the alignment method of this class does not use affine gap\n * penalties. Otherwise it does. Those costs need four times as much memory,\n * which has significant effects on the run time, if the computer needs to swap.\n * \n * @author Andreas Dr&auml;ger\n * @author Gero Greiner\n * @author Mark Schreiber\n * @since 1.5\n */\n\npublic class NeedlemanWunsch extends AlignmentAlgorithm {\n\n\t/**\n\t * This just computes the minimum of three integer values.\n\t * \n\t * @param x\n\t * @param y\n\t * @param z\n\t * @return Gives the minimum of three integers\n\t */\n\tprotected static int min(int x, int y, int z) {\n\t\tif ((x < y) && (x < z))\n\t\t\treturn x;\n\t\tif (y < z)\n\t\t\treturn y;\n\t\treturn z;\n\t}\n\n\t/**\n\t * Prints a String representation of the CostMatrix for the given Alignment\n\t * on the screen. This can be used to get a better understanding of the\n\t * algorithm. There is no other purpose. This method also works for all\n\t * extensions of this class with all kinds of matrices.\n\t * \n\t * @param CostMatrix\n\t *            The matrix that contains all expenses for swapping symbols.\n\t * @param queryChar\n\t *            a character representation of the query sequence (\n\t *            <code>mySequence.seqString().toCharArray()</code>).\n\t * @param targetChar\n\t *            a character representation of the target sequence.\n\t * @return a String representation of the matrix.\n\t */\n\tpublic static String printCostMatrix(int[][] CostMatrix, char[] queryChar,\n\t\t\tchar[] targetChar) {\n\t\tint line, col;\n\t\tStringBuilder output = new StringBuilder();\n\t\toutput.append('\\t');\n\t\tString ls = System.getProperty(\"line.separator\");\n\n\t\tfor (col = 0; col <= targetChar.length; col++)\n\t\t\tif (col == 0) {\n\t\t\t\toutput.append('[');\n\t\t\t\toutput.append(col);\n\t\t\t\toutput.append(\"]\\t\");\n\t\t\t} else {\n\t\t\t\toutput.append('[');\n\t\t\t\toutput.append(targetChar[col - 1]);\n\t\t\t\toutput.append(\"]\\t\");\n\t\t\t}\n\t\tfor (line = 0; line <= queryChar.length; line++) {\n\t\t\tif (line == 0) {\n\t\t\t\toutput.append(ls);\n\t\t\t\toutput.append('[');\n\t\t\t\toutput.append(line);\n\t\t\t\toutput.append(\"]\\t\");\n\t\t\t} else {\n\t\t\t\toutput.append(ls);\n\t\t\t\toutput.append('[');\n\t\t\t\toutput.append(queryChar[line - 1]);\n\t\t\t\toutput.append(\"]\\t\");\n\t\t\t}\n\t\t\tfor (col = 0; col <= targetChar.length; col++) {\n\t\t\t\toutput.append(CostMatrix[line][col]);\n\t\t\t\toutput.append('\\t');\n\t\t\t}\n\t\t}\n\t\toutput.append(ls);\n\t\toutput.append(\"delta[Edit] = \");\n\t\toutput.append(CostMatrix[line - 1][col - 1]);\n\t\toutput.append(ls);\n\t\treturn output.toString();\n\t}\n\n\t/**\n\t * A matrix with the size length(sequence1) times length(sequence2)\n\t */\n\tprotected int[][] CostMatrix;\n\n\t/**\n\t * Expenses for deletes.\n\t */\n\tprivate short delete;\n\n\t/**\n\t * Expenses for the extension of a gap.\n\t */\n\tprivate short gapExt;\n\n\t/**\n\t * Expenses for inserts.\n\t */\n\tprivate short insert;\n\n\t/**\n\t * Expenses for matches.\n\t */\n\tprivate short match;\n\n\t/**\n\t * Expenses for replaces.\n\t */\n\tprivate short replace;\n\n\t/**\n\t * A matrix with the size length(alphabet) times length(alphabet)\n\t */\n\tprotected SubstitutionMatrix subMatrix;\n\n\t/**\n\t * Constructs a new Object with the given parameters based on the\n\t * Needleman-Wunsch algorithm The alphabet of sequences to be aligned will\n\t * be taken from the given substitution matrix.\n\t * \n\t * @param match\n\t *            This gives the costs for a match operation. It is only used,\n\t *            if there is no entry for a certain match of two symbols in the\n\t *            substitution matrix (default value).\n\t * @param replace\n\t *            This is like the match parameter just the default, if there is\n\t *            no entry in the substitution matrix object.\n\t * @param insert\n\t *            The costs of a single insert operation.\n\t * @param delete\n\t *            The expenses of a single delete operation.\n\t * @param gapExtend\n\t *            The expenses of an extension of a existing gap (that is a\n\t *            previous insert or delete. If the costs for insert and delete\n\t *            are equal and also equal to gapExtend, no affine gap penalties\n\t *            will be used, which saves a significant amount of memory.\n\t * @param subMat\n\t *            The substitution matrix object which gives the costs for\n\t *            matches and replaces.\n\t */\n\tpublic NeedlemanWunsch(short match, short replace, short insert,\n\t\t\tshort delete, short gapExtend, SubstitutionMatrix subMat) {\n\t\tthis.subMatrix = subMat;\n\t\tthis.insert = insert;\n\t\tthis.delete = delete;\n\t\tthis.gapExt = gapExtend;\n\t\tthis.match = match;\n\t\tthis.replace = replace;\n\t}\n\n\t/**\n\t * Returns the current expenses of a single delete operation.\n\t * \n\t * @return delete\n\t */\n\tpublic short getDelete() {\n\t\treturn delete;\n\t}\n\n\t/**\n\t * This gives the edit distance according to the given parameters of this\n\t * certain object. It returns just the last element of the internal cost\n\t * matrix (left side down). So if you extend this class, you can just do the\n\t * following:\n\t * <code>int myDistanceValue = foo; this.CostMatrix = new int[1][1]; this.CostMatrix[0][0] = myDistanceValue;</code>\n\t * \n\t * @return returns the edit_distance computed with the given parameters.\n\t */\n\tpublic int getEditDistance() {\n\t\treturn CostMatrix[CostMatrix.length - 1][CostMatrix[CostMatrix.length - 1].length - 1];\n\t}\n\n\t/**\n\t * Returns the current expenses of any extension of a gap operation.\n\t * \n\t * @return gapExt\n\t */\n\tpublic short getGapExt() {\n\t\treturn gapExt;\n\t}\n\n\t/**\n\t * Returns the current expenses of a single insert operation.\n\t * \n\t * @return insert\n\t */\n\tpublic short getInsert() {\n\t\treturn insert;\n\t}\n\n\t/**\n\t * Returns the current expenses of a single match operation.\n\t * \n\t * @return match\n\t */\n\tpublic short getMatch() {\n\t\treturn match;\n\t}\n\n\t/**\n\t * Returns the current expenses of a single replace operation.\n\t * \n\t * @return replace\n\t */\n\tpublic short getReplace() {\n\t\treturn replace;\n\t}\n\n\t/**\n\t * This method computes the scores for the substitution of the i-th symbol\n\t * of query by the j-th symbol of subject.\n\t * \n\t * @param query\n\t *            The query sequence\n\t * @param subject\n\t *            The target sequence\n\t * @param i\n\t *            The position of the symbol under consideration within the\n\t *            query sequence (starting from one)\n\t * @param j\n\t *            The position of the symbol under consideration within the\n\t *            target sequence\n\t * @return The score for the given substitution.\n\t */\n\tprivate int matchReplace(Sequence query, Sequence subject, int i, int j) {\n\t\ttry {\n\t\t\treturn subMatrix.getValueAt(query.symbolAt(i), subject.symbolAt(j));\n\t\t} catch (Exception exc) {\n\t\t\tif (query.symbolAt(i).getMatches().contains(subject.symbolAt(j))\n\t\t\t\t\t|| subject.symbolAt(j).getMatches().contains(\n\t\t\t\t\t\t\tquery.symbolAt(i)))\n\t\t\t\treturn -match;\n\t\t\treturn -replace;\n\t\t}\n\t}\n\n\t/**\n\t * Global pairwise sequence alignment of two BioJava-Sequence objects\n\t * according to the Needleman-Wunsch-algorithm.\n\t * \n\t * @see org.biojava.bio.alignment.AlignmentAlgorithm#pairwiseAlignment(org.biojava.bio.symbol.SymbolList,\n\t *      org.biojava.bio.symbol.SymbolList)\n\t */\n\t@Override\n\tpublic AlignmentPair pairwiseAlignment(SymbolList query, SymbolList subject)\n\t\t\tthrows BioException {\n\t\tSequence squery = null;\n\t\tSequence ssubject = null;\n\n\t\tif (query instanceof Sequence) {\n\t\t\tsquery = (Sequence) query;\n\t\t} else {\n\t\t\t// make it a sequence\n\t\t\tsquery = new SimpleSequence(query, \"\", \"query\",\n\t\t\t\t\tnew SimpleAnnotation());\n\t\t}\n\t\tif (subject instanceof Sequence) {\n\t\t\tssubject = (Sequence) subject;\n\t\t} else {\n\t\t\t// make it a sequence\n\t\t\tssubject = new SimpleSequence(subject, \"\", \"subject\",\n\t\t\t\t\tnew SimpleAnnotation());\n\t\t}\n\n\t\tSymbolTokenization st = null;\n\t\tst = subMatrix.getAlphabet().getTokenization(\"default\");\n\n\t\tif (squery.getAlphabet().equals(ssubject.getAlphabet())\n\t\t\t\t&& squery.getAlphabet().equals(subMatrix.getAlphabet())) {\n\n\t\t\tStringBuffer[] align = { new StringBuffer(), new StringBuffer() };\n\n\t\t\tlong time = System.currentTimeMillis();\n\t\t\tint i, j;\n\t\t\tthis.CostMatrix = new int[squery.length() + 1][ssubject.length() + 1];\n\n\t\t\t/*\n\t\t\t * Variables for the traceback\n\t\t\t */\n\n\t\t\tStringBuffer path = new StringBuffer();\n\n\t\t\t// construct the matrix:\n\t\t\tCostMatrix[0][0] = 0;\n\n\t\t\t/*\n\t\t\t * If we want to have affine gap penalties, we have to initialise\n\t\t\t * additional matrices: If this is not necessary, we won't do that\n\t\t\t * (because it's expensive).\n\t\t\t */\n\t\t\tif ((gapExt != delete) || (gapExt != insert)) {\n\n\t\t\t\tint[][] E = new int[squery.length() + 1][ssubject.length() + 1]; // Inserts\n\t\t\t\tint[][] F = new int[squery.length() + 1][ssubject.length() + 1]; // Deletes\n\n\t\t\t\tE[0][0] = F[0][0] = Integer.MAX_VALUE; // Double.MAX_VALUE;\n\t\t\t\tfor (i = 1; i <= squery.length(); i++) {\n\t\t\t\t\t// CostMatrix[i][0] = CostMatrix[i-1][0] + delete;\n\t\t\t\t\tE[i][0] = Integer.MAX_VALUE; // Double.POSITIVE_INFINITY;\n\t\t\t\t\tCostMatrix[i][0] = F[i][0] = delete + i * gapExt;\n\t\t\t\t}\n\t\t\t\tfor (j = 1; j <= ssubject.length(); j++) {\n\t\t\t\t\t// CostMatrix[0][j] = CostMatrix[0][j - 1] + insert;\n\t\t\t\t\tF[0][j] = Integer.MAX_VALUE; // Double.POSITIVE_INFINITY;\n\t\t\t\t\tCostMatrix[0][j] = E[0][j] = insert + j * gapExt;\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i <= squery.length(); i++)\n\t\t\t\t\tfor (j = 1; j <= ssubject.length(); j++) {\n\t\t\t\t\t\tE[i][j] = Math.min(E[i][j - 1], CostMatrix[i][j - 1]\n\t\t\t\t\t\t\t\t+ insert)\n\t\t\t\t\t\t\t\t+ gapExt;\n\t\t\t\t\t\tF[i][j] = Math.min(F[i - 1][j], CostMatrix[i - 1][j]\n\t\t\t\t\t\t\t\t+ delete)\n\t\t\t\t\t\t\t\t+ gapExt;\n\t\t\t\t\t\tCostMatrix[i][j] = min(E[i][j], F[i][j],\n\t\t\t\t\t\t\t\tCostMatrix[i - 1][j - 1]\n\t\t\t\t\t\t\t\t\t\t- matchReplace(squery, ssubject, i, j));\n\t\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Traceback for affine gap penalties.\n\t\t\t\t */\n\n\t\t\t\tboolean[] gap_extend = { false, false };\n\t\t\t\tj = this.CostMatrix[CostMatrix.length - 1].length - 1;\n\n\t\t\t\tfor (i = this.CostMatrix.length - 1; i > 0;) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// only Insert.\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\talign[0].insert(0, '-');\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// only Delete.\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, '-');\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// Match/Replace\n\t\t\t\t\t\t} else if ((CostMatrix[i][j] == CostMatrix[i - 1][j - 1]\n\t\t\t\t\t\t\t\t- matchReplace(squery, ssubject, i, j))\n\t\t\t\t\t\t\t\t&& !(gap_extend[0] || gap_extend[1])) {\n\t\t\t\t\t\t\tif (squery.symbolAt(i) == ssubject.symbolAt(j))\n\t\t\t\t\t\t\t\tpath.insert(0, '|');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tpath.insert(0, ' ');\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\n\t\t\t\t\t\t\t// Insert || finish gap if extended gap is\n\t\t\t\t\t\t\t// opened\n\t\t\t\t\t\t} else if (CostMatrix[i][j] == E[i][j] || gap_extend[0]) {\n\t\t\t\t\t\t\t// check if gap has been extended or freshly\n\t\t\t\t\t\t\t// opened\n\t\t\t\t\t\t\tgap_extend[0] = (E[i][j] != CostMatrix[i][j - 1]\n\t\t\t\t\t\t\t\t\t+ insert + gapExt);\n\n\t\t\t\t\t\t\talign[0].insert(0, '-');\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// Delete || finish gap if extended gap is\n\t\t\t\t\t\t\t// opened\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check if gap has been extended or freshly\n\t\t\t\t\t\t\t// opened\n\t\t\t\t\t\t\tgap_extend[1] = (F[i][j] != CostMatrix[i - 1][j]\n\t\t\t\t\t\t\t\t\t+ delete + gapExt);\n\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, '-');\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (j > 0);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * No affine gap penalties, constant gap penalties, which is\n\t\t\t\t * much faster and needs less memory.\n\t\t\t\t */\n\n\t\t\t} else {\n\n\t\t\t\tfor (i = 1; i <= squery.length(); i++)\n\t\t\t\t\tCostMatrix[i][0] = CostMatrix[i - 1][0] + delete;\n\t\t\t\tfor (j = 1; j <= ssubject.length(); j++)\n\t\t\t\t\tCostMatrix[0][j] = CostMatrix[0][j - 1] + insert;\n\t\t\t\tfor (i = 1; i <= squery.length(); i++)\n\t\t\t\t\tfor (j = 1; j <= ssubject.length(); j++) {\n\t\t\t\t\t\tCostMatrix[i][j] = min(CostMatrix[i - 1][j] + delete,\n\t\t\t\t\t\t\t\tCostMatrix[i][j - 1] + insert,\n\t\t\t\t\t\t\t\tCostMatrix[i - 1][j - 1]\n\t\t\t\t\t\t\t\t\t\t- matchReplace(squery, ssubject, i, j));\n\t\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Traceback for constant gap penalties.\n\t\t\t\t */\n\t\t\t\tj = this.CostMatrix[CostMatrix.length - 1].length - 1;\n\n\t\t\t\t// System.out.println(printCostMatrix(CostMatrix,\n\t\t\t\t// query.seqString().toCharArray(),\n\t\t\t\t// subject.seqString().toCharArray()));\n\n\t\t\t\tfor (i = this.CostMatrix.length - 1; i > 0;) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\t// only Insert.\n\t\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t\talign[0].insert(0, '-');\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// only Delete.\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, '-');\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// Match/Replace\n\t\t\t\t\t\t} else if (CostMatrix[i][j] == CostMatrix[i - 1][j - 1]\n\t\t\t\t\t\t\t\t- matchReplace(squery, ssubject, i, j)) {\n\n\t\t\t\t\t\t\tif (squery.symbolAt(i) == ssubject.symbolAt(j))\n\t\t\t\t\t\t\t\tpath.insert(0, '|');\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tpath.insert(0, ' ');\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\n\t\t\t\t\t\t\t// Insert\n\t\t\t\t\t\t} else if (CostMatrix[i][j] == CostMatrix[i][j - 1]\n\t\t\t\t\t\t\t\t+ insert) {\n\t\t\t\t\t\t\talign[0].insert(0, '-');\n\t\t\t\t\t\t\talign[1].insert(0, st.tokenizeSymbol(ssubject\n\t\t\t\t\t\t\t\t\t.symbolAt(j--)));\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\n\t\t\t\t\t\t\t// Delete\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\talign[0].insert(0, st.tokenizeSymbol(squery\n\t\t\t\t\t\t\t\t\t.symbolAt(i--)));\n\t\t\t\t\t\t\talign[1].insert(0, '-');\n\t\t\t\t\t\t\tpath.insert(0, ' ');\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (j > 0);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * From here both cases are equal again.\n\t\t\t */\n\t\t\tsquery = new SimpleGappedSequence(new SimpleSequence(\n\t\t\t\t\tnew SimpleSymbolList(squery.getAlphabet().getTokenization(\n\t\t\t\t\t\t\t\"token\"), align[0].toString()), squery.getURN(),\n\t\t\t\t\tsquery.getName(), squery.getAnnotation()));\n\t\t\tssubject = new SimpleGappedSequence(new SimpleSequence(\n\t\t\t\t\tnew SimpleSymbolList(ssubject.getAlphabet()\n\t\t\t\t\t\t\t.getTokenization(\"token\"), align[1].toString()),\n\t\t\t\t\tssubject.getURN(), ssubject.getName(), ssubject\n\t\t\t\t\t\t\t.getAnnotation()));\n\t\t\tAlignmentPair pairalign = new AlignmentPair(squery, ssubject, 1,\n\t\t\t\t\tsquery.length(), 1, ssubject.length(), subMatrix);\n\t\t\tpairalign.setComputationTime(System.currentTimeMillis() - time);\n\t\t\tpairalign.setScore((-1) * getEditDistance());\n\t\t\treturn pairalign;\n\t\t} else {\n\t\t\tthrow new BioException(\n\t\t\t\t\t\"Alphabet missmatch occured: sequences with different alphabet cannot be aligned.\");\n\t\t}\n\t}\n\n\t/**\n\t * Sets the penalty for a delete operation to the specified value.\n\t * \n\t * @param del\n\t *            costs for a single deletion operation\n\t */\n\tpublic void setDelete(short del) {\n\t\tthis.delete = del;\n\t}\n\n\t/**\n\t * Sets the penalty for an extension of any gap (insert or delete) to the\n\t * specified value.\n\t * \n\t * @param ge\n\t *            costs for any gap extension\n\t */\n\tpublic void setGapExt(short ge) {\n\t\tthis.gapExt = ge;\n\t}\n\n\t/**\n\t * Sets the penalty for an insert operation to the specified value.\n\t * \n\t * @param ins\n\t *            costs for a single insert operation\n\t */\n\tpublic void setInsert(short ins) {\n\t\tthis.insert = ins;\n\t}\n\n\t/**\n\t * Sets the penalty for a match operation to the specified value.\n\t * \n\t * @param ma\n\t *            costs for a single match operation\n\t */\n\tpublic void setMatch(short ma) {\n\t\tthis.match = ma;\n\t}\n\n\t/**\n\t * Sets the penalty for a replace operation to the specified value.\n\t * \n\t * @param rep\n\t *            costs for a single replace operation\n\t */\n\tpublic void setReplace(short rep) {\n\t\tthis.replace = rep;\n\t}\n\n\t/**\n\t * Sets the substitution matrix to be used to the specified one. Afterwards\n\t * it is only possible to align sequences of the alphabet of this\n\t * substitution matrix.\n\t * \n\t * @param matrix\n\t *            an instance of a substitution matrix.\n\t */\n\tpublic void setSubstitutionMatrix(SubstitutionMatrix matrix) {\n\t\tthis.subMatrix = matrix;\n\t}\n\n}\n","changedPro":"","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 17, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class NeedlemanWunschTest {\n\n    private ProteinSequence query, target;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private NeedlemanWunsch<ProteinSequence, AminoAcidCompound> alignment, self;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        gaps = new SimpleGapPenalty((short) 10, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        alignment = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, target, gaps, blosum62);\n        self = new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>(query, query, gaps, blosum62);\n    }\n\n    @Test\n    public void testNeedlemanWunsch() {\n        NeedlemanWunsch<ProteinSequence, AminoAcidCompound> nw =\n                new NeedlemanWunsch<ProteinSequence, AminoAcidCompound>();\n        nw.setQuery(query);\n        nw.setTarget(target);\n        nw.setGapPenalty(gaps);\n        nw.setSubstitutionMatrix(blosum62);\n        assertEquals(nw.getScore(), alignment.getScore());\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(alignment.getQuery(), query);\n        assertEquals(self.getQuery(), query);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(alignment.getTarget(), target);\n        assertEquals(self.getTarget(), query);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(alignment.getGapPenalty(), gaps);\n        assertEquals(self.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(alignment.getSubstitutionMatrix(), blosum62);\n        assertEquals(self.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(alignment.isStoringScoreMatrix());\n        assertFalse(self.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        short[][][] scores = alignment.getScoreMatrix();\n        assertEquals(scores[2][1][0], -6);\n        scores = self.getScoreMatrix();\n        assertEquals(scores[3][4][2], 4);\n    }\n\n    @Test\n    public void testGetScoreMatrixAsString() {\n        assertEquals(alignment.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"        R   D   G%n\" +\n                \"    0  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -\\u221E  -1 -13 -12%n\" +\n                \"R  -\\u221E  -6  -3 -14%n\" +\n                \"N  -\\u221E -12  -5  -3%n\" +\n                \"D  -\\u221E -15  -6  -6%n\" +\n                \"%nDeletion%n\" +\n                \"        R   D   G%n\" +\n                \"  -10  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A -11  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"R -12 -12 -24 -23%n\" +\n                \"N -13 -13 -14 -24%n\" +\n                \"D -14 -14 -15 -14%n\" +\n                \"%nInsertion%n\" +\n                \"        R   D   G%n\" +\n                \"  -10 -11 -12 -13%n\" +\n                \"A  -\\u221E  -\\u221E -12 -13%n\" +\n                \"R  -\\u221E  -\\u221E -17 -14%n\" +\n                \"N  -\\u221E  -\\u221E -23 -16%n\" +\n                \"D  -\\u221E  -\\u221E -26 -17%n\"));\n        assertEquals(self.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"        A   R   N   D%n\" +\n                \"    0  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -\\u221E   4 -12 -14 -15%n\" +\n                \"R  -\\u221E -12   9  -7 -10%n\" +\n                \"N  -\\u221E -14  -7  15  -1%n\" +\n                \"D  -\\u221E -15 -10  -1  21%n\" +\n                \"%nDeletion%n\" +\n                \"        A   R   N   D%n\" +\n                \"  -10  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A -11  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"R -12  -7 -23 -25 -26%n\" +\n                \"N -13  -8  -2 -18 -21%n\" +\n                \"D -14  -9  -3   4 -12%n\" +\n                \"%nInsertion%n\" +\n                \"        A   R   N   D%n\" +\n                \"  -10 -11 -12 -13 -14%n\" +\n                \"A  -\\u221E  -\\u221E  -7  -8  -9%n\" +\n                \"R  -\\u221E  -\\u221E -23  -2  -3%n\" +\n                \"N  -\\u221E  -\\u221E -25 -18   4%n\" +\n                \"D  -\\u221E  -\\u221E -26 -21 -12%n\"));\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(alignment.getComputationTime() > 0);\n        assertTrue(self.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(alignment.getProfile().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getProfile().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n    @Test\n    public void testGetMaxScore() {\n        assertEquals(alignment.getMaxScore(), 21);\n        assertEquals(self.getMaxScore(), 21);\n    }\n\n    @Test\n    public void testGetMinScore() {\n        assertEquals(alignment.getMinScore(), -27);\n        assertEquals(self.getMinScore(), -28);\n    }\n\n    @Test\n    public void testGetScore() {\n        assertEquals(alignment.getScore(), -6);\n        assertEquals(self.getScore(), 21);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(alignment.getPair().toString(), String.format(\"ARND%n-RDG%n\"));\n        assertEquals(self.getPair().toString(), String.format(\"ARND%nARND%n\"));\n    }\n\n}\n","changedTest":"","commitMessage":"moving to legacy project\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8455 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}