{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/client/StructureName.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/client/TestStructureName.java","prod_time":"2016-03-08 21:19:31","test_time":"2016-03-08 21:19:31","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":40,"add_classname_line":0,"add_condition_line":20,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":7,"add_return_line":22,"del_annotation_line":0,"del_call_line":24,"del_classname_line":0,"del_condition_line":15,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"POSITIVE","prod_commitID":"6b3bdb0980322cc5f55d26c08e3dff90e8832e00","test_commitID":"6b3bdb0980322cc5f55d26c08e3dff90e8832e00","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.client;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.BioAssemblyIdentifier;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.URLIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPDomain;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** \n * A utility class that makes working with names of structures, domains and ranges easier.\n * \n * Accepts a wide range of identifier formats, including {@link ScopDomain},\n * {@link CathDomain}, PDP domains, and {@link SubstructureIdentifier} residue\n * ranges.\n * \n * Where possible, data is extracted from the input string. Otherwise, range \n * information may be loaded from one of the factory classes:\n * {@link CathFactory},{@link ScopFactory}, etc.\n * \n * @see #getName the name. e.g. 4hhb, 4hhb.A, d4hhba_, PDP:4HHBAa etc.\n */\n\npublic class StructureName implements Comparable<StructureName>, Serializable, StructureIdentifier {\n\tprivate static final long serialVersionUID = 4021229518711762957L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureName.class);\n\n\tprotected String name;\n\tprotected String pdbId;\n\tprotected String chainId;\n\n\tprivate static final Pattern cathPattern = Pattern.compile(\"^(?:CATH:)?([0-9][a-z0-9]{3})(\\\\w)([0-9]{2})$\",Pattern.CASE_INSENSITIVE);\n\t// ds046__ is a special case with no PDB entry\n\tprivate static final Pattern scopPattern = Pattern.compile(\"^(?:SCOP:)?d([0-9][a-z0-9]{3}|s046)(\\\\w|\\\\.)(\\\\w)$\",Pattern.CASE_INSENSITIVE);\n\t// ECOD chains and domains can't be automatically distinguished. Ex: e3j9zS13 is chain 'S1', e1wz2B14 is chain 'B'\n\tprivate static final Pattern ecodPattern = Pattern.compile(\"^(?:ECOD:)?e([0-9][a-z0-9]{3})(?:\\\\w|\\\\.)\\\\w+$\",Pattern.CASE_INSENSITIVE);\n\t\n\t// Names are automatically used as prefixes\n\tpublic enum Source {\n\t\tPDB,\n\t\tSCOP,\n\t\tPDP,\n\t\tCATH,\n\t\tURL,\n\t\tFILE,\n\t\tECOD,\n\t\tBIO,\n\t};\n\n\tprivate Source mySource = null; \n\n\t// cache for getBaseIdentifier() method\n\tprivate StructureIdentifier base = null;\n\t\n\t/**\n\t * Create a new StructureName from the given identifier, which may be a \n\t * domain name, a substructure identifier, etc.\n\t * <p>\n\t * The source and PDB-Id are extracted at compile time, but fully\n\t * interpreting the ID, which may require additional parsing or remote\n\t * calls, is done lazily.\n\t * <p>\n\t * The following sources are supported. Any may be prefixed by the source\n\t * name followed by a colon (e.g. PDB:4HHB). In this case, that source will be used\n\t * unequivocally. If no source is specified, StructureName will make a\n\t * (usually reliable) guess as to which source was intended.\n\t * <ul>\n\t * <li><b>PDB</b>PDB identifier, optionally followed by chain and/or residue\n\t *     ranges. Internally represented by a {@link SubstructureIdentifier};\n\t *     see that class for the full format specification.\n\t *     Examples: 4hhb, 4hhb.A, 4hhb.A:1-50.\n\t * <li><b>SCOP</b> SCOP domain (or SCOPe, depending on the\n\t *     {@link ScopFactory#getSCOP()} version). Example: d1h6w.2\n\t * <li><b>PDP</b> Protein Domain Parser domain. PDP domains are not guessed,\n\t *     making the PDP: prefix obligatory. Example: PDP:4HHBAa\n\t * <li><b>CATH</b> Cath domains. Example: 1qvrC03\n\t * <li><b>URL</b> Arbitrary URLs. Most common protocols are handled,\n\t *     including http://, ftp://, and file://. Some parsing information can\n\t *     be passed as custom query parameters. Example:\n\t *     http://www.rcsb.org/pdb/files/1B8G.pdb.gz\n\t * <li><b>FILE</b> A file path. Supports relative paths and expands ~ to\n\t *     the user's home directory. Only existing files will be automatically\n\t *     detected; to refer to a potentially not-yet existing file, prepend\n\t *     the prefix. Example: ~/custom_protein.pdb\n\t * <li><b>ECOD</b> ECOD domain. Example: e1lyw.1\n\t * <li><b>BIO</b> Biological assembly. These are not guessed, making\n\t *     the BIO: prefix obligatory. Example: BIO:2ehz:1\n\t * </ul>\n\t * @param name An identifier string\n\t * @throws IllegalArgumentException if the name has a recognizable source but is semantically invalid\n\t */\n\tpublic StructureName(String name){\n\t\tthis.name = name;\n\n\t\tinit();//sets pdbId and mySource\n\t}\n\n\n\t/**\n\t * Tries to determine the source and pdbId without fully realizing the identifier,\n\t * which could require I/O depending on the source\n\t * @throws IllegalArgumentException if the source is recognizable but invalid\n\t */\n\tprivate void init(){\n\t\t// First try identifying a prefix\n\t\tString[] prefix = name.split(\":\", 2);\n\t\tmySource = null;\n\t\tif(prefix.length > 1) {\n\t\t\t// Match Source prefixes\n\t\t\ttry {\n\t\t\t\tmySource = Source.valueOf(prefix[0].toUpperCase());\n\t\t\t} catch( IllegalArgumentException e) {\n\t\t\t\t// not a known prefix; revert to guessing\n\t\t\t\tmySource = null;\n\t\t\t}\n\t\t}\n\t\t// SCOP domain\n\t\tif( mySource == Source.SCOP || mySource == null) {\n\t\t\tMatcher matcher = scopPattern.matcher(name);\n\t\t\tif ( matcher.matches() ) {\n\t\t\t\tmySource = Source.SCOP;\n\t\t\t\tpdbId = matcher.group(1);\n\t\t\t\tchainId = matcher.group(2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// PDP\n\t\tif( mySource == Source.PDP ) { // prefix is required\n\t\t\tMatcher matcher = PDPDomain.PDP_NAME_PATTERN.matcher(name);\n\t\t\tif(! matcher.matches() ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Malformed PDP domain name\");\n\t\t\t}\n\t\t\tpdbId = matcher.group(1);\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn;\n\t\t}\n\t\t// CATH\n\t\tif( mySource == Source.CATH || mySource == null) {\n\t\t\tMatcher matcher = cathPattern.matcher(name);\n\t\t\tif ( matcher.matches() ){\n\t\t\t\tmySource = Source.CATH;\n\t\t\t\tpdbId = matcher.group(1);\n\t\t\t\tchainId = matcher.group(2);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// ECOD\n\t\tif( mySource == Source.ECOD || mySource == null) {\n\n\t\t\tMatcher matcher = ecodPattern.matcher(name);\n\t\t\tif ( matcher.matches() ){\n\t\t\t\tmySource = Source.ECOD;\n\t\t\t\tpdbId = matcher.group(1);\n\t\t\t\tchainId = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t// BIO\n\t\tif( mySource == Source.BIO ) { // prefix is required\n\t\t\tMatcher matcher = BioAssemblyIdentifier.BIO_NAME_PATTERN.matcher(name);\n\t\t\tif(! matcher.matches() ) {\n\t\t\t\tthrow new IllegalArgumentException(\"Malformed BIO domain name\");\n\t\t\t}\n\t\t\tpdbId = matcher.group(1);\n\t\t\treturn;\n\t\t}\n\n\t\t// URL\n\t\tif( mySource == Source.URL || mySource == Source.FILE || mySource == null) {\n\t\t\t// Note that file: is a valid scheme and prefix, so need to check if it's a valid URL\n\t\t\tString urlStr;\n\t\t\tif( mySource == Source.URL) {\n\t\t\t\turlStr = prefix[1]; // Strip URL: prefix\n\t\t\t} else {\n\t\t\t\turlStr = name;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tURL url = new URL(urlStr);\n\t\t\t\tmySource = Source.URL;\n\t\t\t\tString path = url.getPath();\n\t\t\t\tpdbId = URLIdentifier.guessPDBID( path.substring(path.lastIndexOf('/')+1) );\n\t\t\t\tchainId = null;\n\t\t\t\treturn;\n\t\t\t} catch(MalformedURLException e) {}\n\t\t}\n\t\t// File\n\t\tif( mySource == Source.FILE || mySource == null) {\n\t\t\tString suffix = mySource == null ? name : prefix[1];\n\t\t\tFile file = new File(FileDownloadUtils.expandUserHome(suffix));\n\t\t\tif( file.canRead() && !file.isDirectory() ) {\n\t\t\t\t// an attempt to mitigate issue #398. It doesn't fix it but it catches the most common case of passing a pdb id and finding a file in working dir matching it\n\t\t\t\tif (suffix.matches(\"\\\\d\\\\w\\\\w\\\\w\")) {\n\t\t\t\t\t// the plain pdb id case, this is unlikely to be what the user wants: let's let it through but warn about it\n\t\t\t\t\tlogger.warn(\"Provided 4-letter structure name '{}' matches \"\n\t\t\t\t\t\t\t+ \"file name in directory {}. Will read structure \"\n\t\t\t\t\t\t\t+ \"data from file {} and not consider the name as a \"\n\t\t\t\t\t\t\t+ \"structure identifier. If this is not what you \"\n\t\t\t\t\t\t\t+ \"want, use 'FILE:{}'\",\n\t\t\t\t\t\t\tname, file.getAbsoluteFile().getParent(),\n\t\t\t\t\t\t\tfile.getAbsolutePath(), name);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.info(\"Provided structure name '{}' matches \"\n\t\t\t\t\t\t\t+ \"file name in directory {}. Will read structure \"\n\t\t\t\t\t\t\t+ \"data from file {}.\",\n\t\t\t\t\t\t\tname, file.getAbsoluteFile().getParent(),\n\t\t\t\t\t\t\tfile.getAbsolutePath());\n\t\t\t\t}\n\t\t\t\tmySource = Source.FILE;\n\t\t\t\tpdbId = null;\n\t\t\t\tchainId = null;\n\t\t\t\treturn;\n\n\t\t\t}\n\t\t}\n\n\t\t// Default to PDB\n\t\tif( mySource == Source.PDB || mySource == null) {\n\t\t\tString suffix = mySource == null ? name : prefix[1];\n\t\t\tmySource = Source.PDB;\n\t\t\tSubstructureIdentifier si = new SubstructureIdentifier(suffix);\n\t\t\tbase = si; // Safe to realize immediately\n\n\t\t\tpdbId = si.getPdbId();\n\t\t\t// Set chainId if unique\n\t\t\tSet<String> chains = getChainIds(si);\n\t\t\tif(chains.size() == 1) {\n\t\t\t\tthis.chainId = chains.iterator().next();\n\t\t\t} else if(chains.size() > 1) {\n\t\t\t\tthis.chainId = \".\";\n\t\t\t} else {\n\t\t\t\tthis.chainId = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static Set<String> getChainIds(SubstructureIdentifier si) {\n\t\tSet<String> chains = new TreeSet<String>();\n\t\tList<ResidueRange> ranges = si.getResidueRanges();\n\t\tfor(ResidueRange range : ranges) {\n\t\t\tString chain = range.getChainId();\n\t\t\tif(chain != null) {\n\t\t\t\tchains.add(chain);\n\t\t\t}\n\t\t}\n\t\treturn chains;\n\t}\n\n\t/**\n\t * Get the PDB ID for this name, if any.\n\t * \n\t * Equivalent to {@link SubstructureIdentifier#getPdbId()\n\t * toCanonical().getPdbId()}\n\t * @return The upper-case PDB Name, or null if not applicable\n\t * @throws StructureException Wraps errors which occur when converting to canonical form\n\t */\n\tpublic String getPdbId() throws StructureException {\n\t\tif( pdbId == null) {\n\t\t\tpdbId = toCanonical().getPdbId();\n\t\t}\n\t\treturn pdbId.toUpperCase();\n\t}\n\n\t/**\n\t * Gets the chain ID, for structures where it is unique and well-defined.\n\t * May return '.' for multi-chain ranges, '_' for wildcard chains, or\n\t * null if the information is unavailable.\n\t * \n\t * <p>This method should only be used casually. For precise chainIds, it\n\t * is better to use {@link #toCanonical()} and iterate through the\n\t * residue ranges.\n\t * @return\n\t */\n\tpublic String getChainId() {\n\t\treturn chainId;\n\t}\n\t/**\n\t * \n\t * @return the identifier string\n\t * @deprecated use {@link #getIdentifier()}\n\t */\n\t@Deprecated\n\tpublic String getName(){\n\n\t\treturn getIdentifier();\n\t}\n\n\t/**\n\t * Get the original form of the identifier\n\t */\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString(){\n\n\t\treturn name;\n\t}\n\n\n\tpublic boolean isScopName() {\n\t\treturn mySource == Source.SCOP;\n\t}\n\n\tpublic boolean isPDPDomain(){\n\t\treturn mySource == Source.PDP;\n\t}\n\n\tpublic boolean isCathID(){\n\t\treturn mySource == Source.CATH;\n\t}\n\n\tpublic boolean isPdbId(){\n\t\treturn mySource == Source.PDB;\n\t}\n\n\tpublic boolean isURL() {\n\t\treturn mySource == Source.URL;\n\t}\n\n\tpublic boolean isFile() {\n\t\treturn mySource == Source.FILE;\n\t}\n\t\n\tpublic boolean isEcodDomain() {\n\t\treturn mySource == Source.ECOD;\n\t}\n\t\n\tpublic boolean isBioAssembly() {\n\t\treturn mySource == Source.BIO;\n\t}\n\t\n\tpublic Source getSource() {\n\t\treturn mySource;\n\t}\n\n\t/**\n\t * StructureName wraps another StructureIdentifier. The type of the base\n\t * identifier depends on the {@link #getSource() source}. Most StructureName\n\t * methods deligate to the base identifier.\n\t *\n\t * <p>It is possible that future versions of StructureName might change the\n\t * return type. Except for some specialized uses, it is probably better\n\t * to create the correct type of identifier directly, rather than creating\n\t * a StructureName and casting the result of this method.\n\t * @return A Str\n\t * @throws StructureException Wraps exceptions that may be thrown by\n\t *  individual implementations. For example, a SCOP identifier may require\n\t *  that the domain definitions be available for download.\n\t */\n\tpublic StructureIdentifier getBaseIdentifier() throws StructureException {\n\t\tif( base == null ) {\n\n\t\t\tswitch(mySource) {\n\t\t\tcase CATH:\n\t\t\t\tbase = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tcase ECOD:\n\t\t\t\ttry {\n\t\t\t\t\tbase = EcodFactory.getEcodDatabase().getDomainsById(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to get ECOD domain \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCOP:\n\t\t\t\t// Fuzzy matching of the domain name to the current default factory\n\t\t\t\tbase = guessScopDomain(getIdentifier(),ScopFactory.getSCOP());\n\t\t\t\tif(base == null) {\n\t\t\t\t\t// Guessing didn't work, so just use the PDBID and Chain from name\n\t\t\t\t\t// Guess that '_' means 'whole structure'\n\t\t\t\t\tif (chainId.equals(\"_\")) {\n\t\t\t\t\t\tbase = new SubstructureIdentifier(pdbId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase = new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));\n\t\t\t\t\t}\n\t\t\t\t\tlogger.error(\"Unable to find {}, so using {}\",name,base);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FILE:\n\t\t\t\ttry {\n\t\t\t\t\tbase = new URLIdentifier(new File(FileDownloadUtils.expandUserHome(name)).toURI().toURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t// Should never happen\n\t\t\t\t\tthrow new StructureException(\"Unable to get URL for file: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URL:\n\t\t\t\ttry {\n\t\t\t\t\tbase = new URLIdentifier(name);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new StructureException(\"Invalid URL: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDP:\n\t\t\t\ttry {\n\t\t\t\t\tPDPProvider provider = new RemotePDPProvider(false);\n\t\t\t\t\tbase = provider.getPDPDomain(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to fetch PDP domain \"+name, e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIO:\n\t\t\t\tbase = new BioAssemblyIdentifier(name);\n\t\t\tcase PDB:\n\t\t\t\tbase = new SubstructureIdentifier(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"Unimplemented source: \"+mySource);\n\t\t\t}\n\t\t}\n\t\treturn base;\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException {\n\t\treturn getBaseIdentifier().toCanonical();\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn getBaseIdentifier().reduce(input);\n\t}\n\t\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\t\t\tIOException {\n\t\treturn getBaseIdentifier().loadStructure(cache);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tStructureName other = (StructureName) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Orders identifiers lexicographically by PDB ID and then full Identifier\n\t */\n\t@Override\n\tpublic int compareTo(StructureName o) {\n\t\tif ( this.equals(o))\n\t\t\treturn 0;\n\n\t\tString pdb1 = null;\n\t\tString pdb2 = null;\n\t\ttry {\n\t\t\tpdb1 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\t\ttry {\n\t\t\tpdb2 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\n\t\tint comp = 0;\n\n\t\t// Sort those with PDBIDs before those without\n\t\tif( pdb1 == null ) {\n\t\t\tif( pdb2 != null) {\n\t\t\t\treturn 1; // this > o\n\t\t\t}\n\t\t\t// both null\n\t\t} else if( pdb2 == null){\n\t\t\treturn -1; // this < o\n\t\t} else {\n\t\t\t// neither null\n\t\t\tcomp = pdb1.compareTo(pdb2);\n\t\t}\n\t\tif( comp != 0 ) {\n\t\t\treturn comp;\n\t\t}\n\n\t\t// break tie with full identifiers\n\t\tpdb1 = this.getIdentifier();\n\t\tpdb2 = o.getIdentifier();\n\n\t\t// Throws NPE for nulls\n\t\treturn pdb1.compareTo(pdb2);\n\t}\n\t\n\t/**\n\t * <p>\n\t * Guess a scop domain. If an exact match is found, return that.\n\t * \n\t * <p>\n\t * Otherwise, return the first scop domain found for the specified protein such that\n\t * <ul>\n\t * <li>The chains match, or one of the chains is '_' or '.'.\n\t * <li>The domains match, or one of the domains is '_'.\n\t * </ul>\n\t * \n\t * In some cases there may be several valid matches. In this case a warning\n\t * will be logged.\n\t * \n\t * @param name SCOP domain name, or a guess thereof\n\t * @param scopDB SCOP domain provider\n\t * @return The best match for name among the domains of scopDB, or null if none match.\n\t */\n\tpublic static ScopDomain guessScopDomain(String name, ScopDatabase scopDB) {\n\t\tList<ScopDomain> matches = new LinkedList<ScopDomain>();\n\n\t\t// Try exact match first\n\t\tScopDomain domain = scopDB.getDomainByScopID(name);\n\t\tif (domain != null) {\n\t\t\treturn domain;\n\t\t}\n\n\t\t// Didn't work. Guess it!\n\t\tlogger.warn(\"Warning, could not find SCOP domain: \" + name);\n\n\t\tMatcher scopMatch = scopPattern.matcher(name);\n\t\tif (scopMatch.matches()) {\n\t\t\tString pdbID = scopMatch.group(1);\n\t\t\tString chainID = scopMatch.group(2);\n\t\t\tString domainID = scopMatch.group(3);\n\n\t\t\tfor (ScopDomain potentialSCOP : scopDB.getDomainsForPDB(pdbID)) {\n\t\t\t\tMatcher potMatch = scopPattern.matcher(potentialSCOP.getScopId());\n\t\t\t\tif (potMatch.matches()) {\n\t\t\t\t\tif (chainID.equals(potMatch.group(2)) || chainID.equals(\"_\") || chainID.equals(\".\")\n\t\t\t\t\t\t\t|| potMatch.group(2).equals(\"_\") || potMatch.group(2).equals(\".\")) {\n\t\t\t\t\t\tif (domainID.equals(potMatch.group(3)) || domainID.equals(\"_\") || potMatch.group(3).equals(\"_\")) {\n\t\t\t\t\t\t\t// Match, or near match\n\t\t\t\t\t\t\tmatches.add(potentialSCOP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tIterator<ScopDomain> match = matches.iterator();\n\t\tif (match.hasNext()) {\n\t\t\tScopDomain bestMatch = match.next();\n\t\t\tif(logger.isWarnEnabled()) {\n\t\t\t\tStringBuilder warnMsg = new StringBuilder();\n\t\t\t\twarnMsg.append(\"Trying domain \" + bestMatch.getScopId() + \".\");\n\t\t\t\tif (match.hasNext()) {\n\t\t\t\t\twarnMsg.append(\" Other possibilities: \");\n\t\t\t\t\twhile (match.hasNext()) {\n\t\t\t\t\t\twarnMsg.append(match.next().getScopId() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twarnMsg.append(System.getProperty(\"line.separator\"));\n\t\t\t\tlogger.warn(warnMsg.toString());\n\t\t\t}\n\t\t\treturn bestMatch;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t\n\t\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.client;\n\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.BioAssemblyIdentifier;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.URLIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPDomain;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** \n * A utility class that makes working with names of structures, domains and ranges easier.\n * \n * Accepts a wide range of identifier formats, including {@link ScopDomain},\n * {@link CathDomain}, PDP domains, and {@link SubstructureIdentifier} residue\n * ranges.\n * \n * Where possible, data is extracted from the input string. Otherwise, range \n * information may be loaded from one of the factory classes:\n * {@link CathFactory},{@link ScopFactory}, etc.\n * \n * @see #getName the name. e.g. 4hhb, 4hhb.A, d4hhba_, PDP:4HHBAa etc.\n */\n\npublic class StructureName implements Comparable<StructureName>, Serializable, StructureIdentifier {\n\tprivate static final long serialVersionUID = 4021229518711762957L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureName.class);\n\n\tprotected String name;\n\tprotected String pdbId;\n\tprotected String chainId;\n\n\tprivate static final Pattern cathPattern = Pattern.compile(\"^(?:CATH:)?([0-9][a-z0-9]{3})(\\\\w)([0-9]{2})$\",Pattern.CASE_INSENSITIVE);\n\t// ds046__ is a special case with no PDB entry\n\tprivate static final Pattern scopPattern = Pattern.compile(\"^(?:SCOP:)?d([0-9][a-z0-9]{3}|s046)(\\\\w|\\\\.)(\\\\w)$\",Pattern.CASE_INSENSITIVE);\n\t// ECOD chains and domains can't be automatically distinguished. Ex: e3j9zS13 is chain 'S1', e1wz2B14 is chain 'B'\n\tprivate static final Pattern ecodPattern = Pattern.compile(\"^(?:ECOD:)?e([0-9][a-z0-9]{3})(?:\\\\w|\\\\.)\\\\w+$\",Pattern.CASE_INSENSITIVE);\n\n\t// Names are automatically used as prefixes\n\tpublic enum Source {\n\t\tPDB,\n\t\tSCOP,\n\t\tPDP,\n\t\tCATH,\n\t\tURL,\n\t\tFILE,\n\t\tECOD,\n\t\tBIO,\n\t};\n\n\tprivate Source mySource = null; \n\n\t// cache for getBaseIdentifier() method\n\tprivate StructureIdentifier base = null;\n\n\t/**\n\t * Create a new StructureName from the given identifier, which may be a \n\t * domain name, a substructure identifier, etc.\n\t * <p>\n\t * The source and PDB-Id are extracted at compile time, but fully\n\t * interpreting the ID, which may require additional parsing or remote\n\t * calls, is done lazily.\n\t * <p>\n\t * The following sources are supported. Any may be prefixed by the source\n\t * name followed by a colon (e.g. PDB:4HHB). In this case, that source will be used\n\t * unequivocally. If no source is specified, StructureName will make a\n\t * (usually reliable) guess as to which source was intended.\n\t * <ul>\n\t * <li><b>PDB</b>PDB identifier, optionally followed by chain and/or residue\n\t *     ranges. Internally represented by a {@link SubstructureIdentifier};\n\t *     see that class for the full format specification.\n\t *     Examples: 4hhb, 4hhb.A, 4hhb.A:1-50.\n\t * <li><b>SCOP</b> SCOP domain (or SCOPe, depending on the\n\t *     {@link ScopFactory#getSCOP()} version). Example: d1h6w.2\n\t * <li><b>PDP</b> Protein Domain Parser domain. PDP domains are not guessed,\n\t *     making the PDP: prefix obligatory. Example: PDP:4HHBAa\n\t * <li><b>CATH</b> Cath domains. Example: 1qvrC03\n\t * <li><b>URL</b> Arbitrary URLs. Most common protocols are handled,\n\t *     including http://, ftp://, and file://. Some parsing information can\n\t *     be passed as custom query parameters. Example:\n\t *     http://www.rcsb.org/pdb/files/1B8G.pdb.gz\n\t * <li><b>FILE</b> A file path. Supports relative paths and expands ~ to\n\t *     the user's home directory. Only existing files will be automatically\n\t *     detected; to refer to a potentially not-yet existing file, prepend\n\t *     the prefix. Internally represented as a {@link URLIdentifier}\n\t *     after path expansion. Example: ~/custom_protein.pdb\n\t * <li><b>ECOD</b> ECOD domain. Example: e1lyw.1\n\t * <li><b>BIO</b> Biological assembly. These are not guessed, making\n\t *     the BIO: prefix obligatory. Example: BIO:2ehz:1\n\t * </ul>\n\t * @param name An identifier string\n\t * @throws IllegalArgumentException if the name has a recognizable source but is semantically invalid\n\t */\n\tpublic StructureName(String name){\n\t\tthis.name = name;\n\n\t\tinit();//sets pdbId and mySource\n\t}\n\n\n\t/**\n\t * Tries to determine the source and pdbId without fully realizing the identifier,\n\t * which could require I/O depending on the source\n\t * @throws IllegalArgumentException if the source is recognizable but invalid\n\t */\n\tprivate void init(){\n\n\t\t// First try identifying a prefix\n\t\tString[] prefix = name.split(\":\", 2);\n\t\tmySource = null;\n\t\tif(prefix.length > 1) {\n\t\t\t// Match Source prefixes\n\t\t\tString suffix = prefix[1];\n\t\t\ttry {\n\t\t\t\tmySource = Source.valueOf(prefix[0].toUpperCase());\n\t\t\t} catch( IllegalArgumentException e ) {\n\t\t\t\t// unrecognized prefix; fall back on guessing\n\t\t\t\tmySource = null;\n\t\t\t}\n\t\t\tif(mySource != null) {\n\t\t\t\tswitch( mySource) {\n\t\t\t\tcase SCOP:\n\t\t\t\t\tif( ! initFromScop(suffix) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed SCOP domain name:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase PDP:\n\t\t\t\t\tif( ! initFromPDP(name) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed PDP domain name:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase CATH:\n\t\t\t\t\tif( ! initFromCATH(suffix) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed CATH domain name:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase BIO:\n\t\t\t\t\tif( ! initFromBIO(name) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed BIO name:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase ECOD:\n\t\t\t\t\tif( ! initFromECOD(suffix) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed ECOD domain name:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase PDB:\n\t\t\t\t\tif( ! initFromPDB(suffix) )\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed PDB specification:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tcase FILE:\n\t\t\t\t\t// Treat file:/ prefixes as URLs\n\t\t\t\t\tif( ! suffix.startsWith(\"/\")) {\n\t\t\t\t\t\t// Otherwise, treat as file\n\t\t\t\t\t\tinitFromFile();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// fall through to URL case\n\t\t\t\tcase URL:\n\t\t\t\t\tif( ! initFromURL(name))\n\t\t\t\t\t\tthrow new IllegalArgumentException(\"Malformed URL specification:\"+suffix);\n\t\t\t\t\treturn;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalStateException(\"Unimplemented Source \"+mySource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// No known prefix, so revert to guessing\n\n\t\t// First guess regex-based identifiers\n\t\t// SCOP domain\n\t\tif( initFromScop(name) )\n\t\t\treturn;\n\t\t// CATH\n\t\tif( initFromCATH(name) )\n\t\t\treturn;\n\t\t// ECOD\n\t\tif( initFromECOD(name) )\n\t\t\treturn;\n\t\t// Never guess BIO or PDP\n\n\t\t// URL\n\t\tif( initFromURL(name) )\n\t\t\treturn;\n\n\t\t// Guess FILE based on file existence\n\t\tFile file = new File(FileDownloadUtils.expandUserHome(name));\n\t\tif( file.canRead() && !file.isDirectory() ) {\n\t\t\t// an attempt to mitigate issue #398. It doesn't fix it but it catches the most common case of passing a pdb id and finding a file in working dir matching it\n\t\t\tif (name.matches(\"\\\\d\\\\w\\\\w\\\\w\")) {\n\t\t\t\t// the plain pdb id case, this is unlikely to be what the user wants: let's let it through but warn about it\n\t\t\t\tlogger.warn(\"Provided 4-letter structure name '{}' matches \"\n\t\t\t\t\t\t+ \"file name in directory {}. Will read structure \"\n\t\t\t\t\t\t+ \"data from file {} and not consider the name as a \"\n\t\t\t\t\t\t+ \"structure identifier. If this is not what you \"\n\t\t\t\t\t\t+ \"want, use 'FILE:{}'\",\n\t\t\t\t\t\tname, file.getAbsoluteFile().getParent(),\n\t\t\t\t\t\tfile.getAbsolutePath(), name);\n\t\t\t} else {\n\t\t\t\tlogger.info(\"Provided structure name '{}' matches \"\n\t\t\t\t\t\t+ \"file name in directory {}. Will read structure \"\n\t\t\t\t\t\t+ \"data from file {}.\",\n\t\t\t\t\t\tname, file.getAbsoluteFile().getParent(),\n\t\t\t\t\t\tfile.getAbsolutePath());\n\t\t\t}\n\n\t\t\tinitFromFile();\n\t\t\treturn;\n\t\t}\n\n\t\t// Default to PDB\n\t\tinitFromPDB( name );\n\t}\n\n\tprivate boolean initFromScop(String name) {\n\t\tMatcher matcher = scopPattern.matcher(name);\n\t\tif ( matcher.matches() ) {\n\t\t\tmySource = Source.SCOP;\n\t\t\tpdbId = matcher.group(1).toUpperCase();\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate boolean initFromPDP(String name) {\n\t\tMatcher matcher = PDPDomain.PDP_NAME_PATTERN.matcher(name);\n\t\tif( matcher.matches() ) {\n\t\t\tpdbId = matcher.group(1).toUpperCase();\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate boolean initFromCATH(String name) {\n\t\tMatcher matcher = cathPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.CATH;\n\t\t\tpdbId = matcher.group(1).toUpperCase();\n\t\t\tchainId = matcher.group(2);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate boolean initFromECOD(String name) {\n\t\tMatcher matcher = ecodPattern.matcher(name);\n\t\tif ( matcher.matches() ){\n\t\t\tmySource = Source.ECOD;\n\t\t\tpdbId = matcher.group(1).toUpperCase();\n\t\t\tchainId = null;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate boolean initFromBIO(String name) {\n\t\tMatcher matcher = BioAssemblyIdentifier.BIO_NAME_PATTERN.matcher(name);\n\t\tif( matcher.matches() ) {\n\t\t\tpdbId = matcher.group(1).toUpperCase();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tprivate boolean initFromPDB(String suffix) {\n\t\tmySource = Source.PDB;\n\t\tSubstructureIdentifier si = new SubstructureIdentifier(suffix);\n\t\tbase = si; // Safe to realize immediately\n\n\t\tpdbId = si.getPdbId();\n\t\t// Set chainId if unique\n\t\tSet<String> chains = getChainIds(si);\n\t\tif(chains.size() == 1) {\n\t\t\tthis.chainId = chains.iterator().next();\n\t\t} else if(chains.size() > 1) {\n\t\t\tthis.chainId = \".\";\n\t\t} else {\n\t\t\tthis.chainId = null;\n\t\t}\n\t\treturn true;\n\t}\n\tprivate boolean initFromURL(String suffix) {\n\t\ttry {\n\t\t\tURL url = new URL(suffix);\n\t\t\tString path = url.getPath();\n\t\t\tmySource = Source.URL;\n\t\t\tpdbId = URLIdentifier.guessPDBID( path.substring(path.lastIndexOf('/')+1) );\n\t\t\tchainId = null; // Don't bother checking query params here\n\t\t\treturn true;\n\t\t} catch(MalformedURLException e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate boolean initFromFile() {\n\t\tmySource = Source.FILE;\n\t\tpdbId = null;\n\t\tchainId = null;\n\t\treturn true;\n\t}\n\n\tprivate static Set<String> getChainIds(SubstructureIdentifier si) {\n\t\tSet<String> chains = new TreeSet<String>();\n\t\tList<ResidueRange> ranges = si.getResidueRanges();\n\t\tfor(ResidueRange range : ranges) {\n\t\t\tString chain = range.getChainId();\n\t\t\tif(chain != null) {\n\t\t\t\tchains.add(chain);\n\t\t\t}\n\t\t}\n\t\treturn chains;\n\t}\n\n\t/**\n\t * Get the PDB ID for this name, if any.\n\t * \n\t * Equivalent to {@link SubstructureIdentifier#getPdbId()\n\t * toCanonical().getPdbId()}\n\t * @return The upper-case PDB Name, or null if not applicable\n\t * @throws StructureException Wraps errors which occur when converting to canonical form\n\t */\n\tpublic String getPdbId() throws StructureException {\n\t\tif( pdbId == null) {\n\t\t\tpdbId = toCanonical().getPdbId();\n\t\t}\n\t\treturn pdbId;\n\t}\n\n\t/**\n\t * Gets the chain ID, for structures where it is unique and well-defined.\n\t * May return '.' for multi-chain ranges, '_' for wildcard chains, or\n\t * null if the information is unavailable.\n\t * \n\t * <p>This method should only be used casually. For precise chainIds, it\n\t * is better to use {@link #toCanonical()} and iterate through the\n\t * residue ranges.\n\t * @return\n\t */\n\tpublic String getChainId() {\n\t\treturn chainId;\n\t}\n\t/**\n\t * \n\t * @return the identifier string\n\t * @deprecated use {@link #getIdentifier()}\n\t */\n\t@Deprecated\n\tpublic String getName(){\n\n\t\treturn getIdentifier();\n\t}\n\n\t/**\n\t * Get the original form of the identifier\n\t */\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString(){\n\n\t\treturn name;\n\t}\n\n\n\tpublic boolean isScopName() {\n\t\treturn mySource == Source.SCOP;\n\t}\n\n\tpublic boolean isPDPDomain(){\n\t\treturn mySource == Source.PDP;\n\t}\n\n\tpublic boolean isCathID(){\n\t\treturn mySource == Source.CATH;\n\t}\n\n\tpublic boolean isPdbId(){\n\t\treturn mySource == Source.PDB;\n\t}\n\n\tpublic boolean isURL() {\n\t\treturn mySource == Source.URL;\n\t}\n\n\t/**\n\t * Indicates that the identifier was determined to correspond to a file.\n\t * Note that some file identifiers may also be valid URLs; in that case,\n\t * the URL source is preferred.\n\t * @return\n\t */\n\tpublic boolean isFile() {\n\t\treturn mySource == Source.FILE;\n\t}\n\n\tpublic boolean isEcodDomain() {\n\t\treturn mySource == Source.ECOD;\n\t}\n\n\tpublic boolean isBioAssembly() {\n\t\treturn mySource == Source.BIO;\n\t}\n\n\tpublic Source getSource() {\n\t\treturn mySource;\n\t}\n\n\t/**\n\t * StructureName wraps another StructureIdentifier. The type of the base\n\t * identifier depends on the {@link #getSource() source}. Most StructureName\n\t * methods deligate to the base identifier.\n\t *\n\t * <p>It is possible that future versions of StructureName might change the\n\t * return type. Except for some specialized uses, it is probably better\n\t * to create the correct type of identifier directly, rather than creating\n\t * a StructureName and casting the result of this method.\n\t * @return A Str\n\t * @throws StructureException Wraps exceptions that may be thrown by\n\t *  individual implementations. For example, a SCOP identifier may require\n\t *  that the domain definitions be available for download.\n\t */\n\tpublic StructureIdentifier getBaseIdentifier() throws StructureException {\n\t\tif( base == null ) {\n\n\t\t\tswitch(mySource) {\n\t\t\tcase CATH:\n\t\t\t\tbase = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tcase ECOD:\n\t\t\t\ttry {\n\t\t\t\t\tbase = EcodFactory.getEcodDatabase().getDomainsById(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to get ECOD domain \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase SCOP:\n\t\t\t\t// Fuzzy matching of the domain name to the current default factory\n\t\t\t\tbase = guessScopDomain(getIdentifier(),ScopFactory.getSCOP());\n\t\t\t\tif(base == null) {\n\t\t\t\t\t// Guessing didn't work, so just use the PDBID and Chain from name\n\t\t\t\t\t// Guess that '_' means 'whole structure'\n\t\t\t\t\tif (chainId.equals(\"_\")) {\n\t\t\t\t\t\tbase = new SubstructureIdentifier(pdbId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase = new SubstructureIdentifier(pdbId,ResidueRange.parseMultiple(chainId));\n\t\t\t\t\t}\n\t\t\t\t\tlogger.error(\"Unable to find {}, so using {}\",name,base);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FILE:\n\t\t\t\ttry {\n\t\t\t\t\tString[] prefix = name.split(\":\", 2);\n\t\t\t\t\tString filename;\n\t\t\t\t\tif(prefix.length > 1) {\n\t\t\t\t\t\tfilename = prefix[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfilename = name;\n\t\t\t\t\t}\n\t\t\t\t\tfilename = FileDownloadUtils.expandUserHome(filename);\n\t\t\t\t\tbase = new URLIdentifier(new File(filename).toURI().toURL());\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\t// Should never happen\n\t\t\t\t\tthrow new StructureException(\"Unable to get URL for file: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase URL:\n\t\t\t\ttry {\n\t\t\t\t\tbase = new URLIdentifier(name);\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\tthrow new StructureException(\"Invalid URL: \"+name,e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PDP:\n\t\t\t\ttry {\n\t\t\t\t\tPDPProvider provider = new RemotePDPProvider(false);\n\t\t\t\t\tbase = provider.getPDPDomain(name);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new StructureException(\"Unable to fetch PDP domain \"+name, e);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase BIO:\n\t\t\t\tbase = new BioAssemblyIdentifier(name);\n\t\t\tcase PDB:\n\t\t\t\tbase = new SubstructureIdentifier(getIdentifier());\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"Unimplemented source: \"+mySource);\n\t\t\t}\n\t\t}\n\t\treturn base;\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException {\n\t\treturn getBaseIdentifier().toCanonical();\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn getBaseIdentifier().reduce(input);\n\t}\n\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\tIOException {\n\t\treturn getBaseIdentifier().loadStructure(cache);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tStructureName other = (StructureName) obj;\n\t\tif (name == null) {\n\t\t\tif (other.name != null)\n\t\t\t\treturn false;\n\t\t} else if (!name.equals(other.name))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Orders identifiers lexicographically by PDB ID and then full Identifier\n\t */\n\t@Override\n\tpublic int compareTo(StructureName o) {\n\t\tif ( this.equals(o))\n\t\t\treturn 0;\n\n\t\tString pdb1 = null;\n\t\tString pdb2 = null;\n\t\ttry {\n\t\t\tpdb1 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\t\ttry {\n\t\t\tpdb2 = this.getPdbId();\n\t\t} catch (StructureException e) {}\n\n\t\tint comp = 0;\n\n\t\t// Sort those with PDBIDs before those without\n\t\tif( pdb1 == null ) {\n\t\t\tif( pdb2 != null) {\n\t\t\t\treturn 1; // this > o\n\t\t\t}\n\t\t\t// both null\n\t\t} else if( pdb2 == null){\n\t\t\treturn -1; // this < o\n\t\t} else {\n\t\t\t// neither null\n\t\t\tcomp = pdb1.compareTo(pdb2);\n\t\t}\n\t\tif( comp != 0 ) {\n\t\t\treturn comp;\n\t\t}\n\n\t\t// break tie with full identifiers\n\t\tpdb1 = this.getIdentifier();\n\t\tpdb2 = o.getIdentifier();\n\n\t\t// Throws NPE for nulls\n\t\treturn pdb1.compareTo(pdb2);\n\t}\n\n\t/**\n\t * <p>\n\t * Guess a scop domain. If an exact match is found, return that.\n\t * \n\t * <p>\n\t * Otherwise, return the first scop domain found for the specified protein such that\n\t * <ul>\n\t * <li>The chains match, or one of the chains is '_' or '.'.\n\t * <li>The domains match, or one of the domains is '_'.\n\t * </ul>\n\t * \n\t * In some cases there may be several valid matches. In this case a warning\n\t * will be logged.\n\t * \n\t * @param name SCOP domain name, or a guess thereof\n\t * @param scopDB SCOP domain provider\n\t * @return The best match for name among the domains of scopDB, or null if none match.\n\t */\n\tpublic static ScopDomain guessScopDomain(String name, ScopDatabase scopDB) {\n\t\tList<ScopDomain> matches = new LinkedList<ScopDomain>();\n\n\t\t// Try exact match first\n\t\tScopDomain domain = scopDB.getDomainByScopID(name);\n\t\tif (domain != null) {\n\t\t\treturn domain;\n\t\t}\n\n\t\t// Didn't work. Guess it!\n\t\tlogger.warn(\"Warning, could not find SCOP domain: \" + name);\n\n\t\tMatcher scopMatch = scopPattern.matcher(name);\n\t\tif (scopMatch.matches()) {\n\t\t\tString pdbID = scopMatch.group(1);\n\t\t\tString chainID = scopMatch.group(2);\n\t\t\tString domainID = scopMatch.group(3);\n\n\t\t\tfor (ScopDomain potentialSCOP : scopDB.getDomainsForPDB(pdbID)) {\n\t\t\t\tMatcher potMatch = scopPattern.matcher(potentialSCOP.getScopId());\n\t\t\t\tif (potMatch.matches()) {\n\t\t\t\t\tif (chainID.equals(potMatch.group(2)) || chainID.equals(\"_\") || chainID.equals(\".\")\n\t\t\t\t\t\t\t|| potMatch.group(2).equals(\"_\") || potMatch.group(2).equals(\".\")) {\n\t\t\t\t\t\tif (domainID.equals(potMatch.group(3)) || domainID.equals(\"_\") || potMatch.group(3).equals(\"_\")) {\n\t\t\t\t\t\t\t// Match, or near match\n\t\t\t\t\t\t\tmatches.add(potentialSCOP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tIterator<ScopDomain> match = matches.iterator();\n\t\tif (match.hasNext()) {\n\t\t\tScopDomain bestMatch = match.next();\n\t\t\tif(logger.isWarnEnabled()) {\n\t\t\t\tStringBuilder warnMsg = new StringBuilder();\n\t\t\t\twarnMsg.append(\"Trying domain \" + bestMatch.getScopId() + \".\");\n\t\t\t\tif (match.hasNext()) {\n\t\t\t\t\twarnMsg.append(\" Other possibilities: \");\n\t\t\t\t\twhile (match.hasNext()) {\n\t\t\t\t\t\twarnMsg.append(match.next().getScopId() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twarnMsg.append(System.getProperty(\"line.separator\"));\n\t\t\t\tlogger.warn(warnMsg.toString());\n\t\t\t}\n\t\t\treturn bestMatch;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\n\n}\n","originTest":"package org.biojava.nbio.structure.align.client;\n\nimport static org.junit.Assert.*;\nimport static org.biojava.nbio.structure.align.client.StructureName.Source.*;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.junit.Test;\n\npublic class TestStructureName {\n\n\t@Test\n\tpublic void testMultiCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"4V4F.AL\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\t\t\n\t\tstr = \"4v4f.AL\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\tstr = \"4v4f.al\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"al\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\tstr = \"4v4f.ABCD\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCD\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\t// More than 4 characters should work too. In principle there's no limit in mmCIF, though the PDB is \n\t\t// restricting chain ids to 4 chars \n\t\tstr = \"4v4f.ABCDEFGHIJ\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCDEFGHIJ\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\n\t}\n\t\n\t@Test\n\tpublic void testSingleCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"1SMT.A\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"A\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\t\t\n\t\tstr = \"1SMT.a\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"a\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\n\t\t\n\t}\n\n\t@Test\n\tpublic void testFiles() throws IOException {\n\t\tFile f = new File(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(f.exists());\n\t\tassertNull(f.getParentFile());\n\t\tStructureName sn = new StructureName(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(sn.isFile());\n\t\tassertTrue(sn.isPdbId());\n\t}\n\t/**\n\t * Test explicit prefixes\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testPrefixes() throws StructureException {\n\t\tStructureName sn;\n\t\t\n\t\t// Basic case\n\t\tsn = new StructureName(\"PDB:4hhb\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\tsn = new StructureName(\"PDB:4hhb.A:1-50\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// Invalid strings work too, they just don't load\n\t\tsn = new StructureName(\"PDB:x\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"X\",sn.getPdbId());\n\t\t// SCOP\n\t\tsn = new StructureName(\"SCOP:d2gs2a_\");\n\t\tassertTrue(sn.isScopName());\n\t\tassertTrue(sn.getSource() == SCOP);\n\t\tassertEquals(\"2GS2\",sn.getPdbId());\n\t\t// CATH\n\t\tsn = new StructureName(\"CATH:1qvrC03\");\n\t\tassertTrue(sn.isCathID());\n\t\tassertTrue(sn.getSource() == CATH);\n\t\tassertEquals(\"1QVR\",sn.getPdbId());\n\t\t// PDP\n\t\tsn = new StructureName(\"PDP:4HHBAa\");\n\t\tassertTrue(sn.isPDPDomain());\n\t\tassertTrue(sn.getSource() == PDP);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// URL\n\t\tsn = new StructureName(\"URL:http://www.rcsb.org/pdb/files/1B8G.pdb.gz\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"1B8G\",sn.getPdbId());\n\t\tsn = new StructureName(\"URL:file:///4hhb.pdb\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n//\t\t// File\n//\t\tsn = new StructureName(\"FILE:~/4hhb.pdb\");\n//\t\tassertTrue(sn.isFile());\n//\t\tassertTrue(sn.getSource() == FILE);\n//\t\tassertEquals(\"4HHB\",sn.getPdbId());\n//\t\t// files are slightly different from URLs\n//\t\tsn = new StructureName(\"file:/4hhb.pdb\");\n//\t\tassertTrue(sn.isFile());\n//\t\tassertTrue(sn.getSource() == FILE);\n//\t\tassertEquals(\"4HHB\",sn.getPdbId());\n//\t\t// files are slightly different from URLs\n//\t\tsn = new StructureName(\"file:/4hhb_other.pdb\");\n//\t\tassertTrue(sn.isFile());\n//\t\tassertTrue(sn.getSource() == FILE);\n//\t\tassertEquals(\"4hhb_other\",sn.getPdbId());\n\n\t\t// ECOD\n\t\tsn = new StructureName(\"e1lyw.1\");\n\t\tassertTrue(sn.isEcodDomain());\n\t\tassertTrue(sn.getSource() == ECOD);\n\t\tassertEquals(\"1LYW\",sn.getPdbId());\n\t\t// BIO\n\t\tsn = new StructureName(\"BIO:2ehz:1\");\n\t\tassertTrue(sn.isBioAssembly());\n\t\tassertTrue(sn.getSource() == BIO);\n\t\tassertEquals(\"2EHZ\",sn.getPdbId());\n\t\t\n\t\t// Invalid prefix\n\t\tsn = new StructureName(\"XXX:2ehz\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"XXX:2EHZ\",sn.getPdbId());\n\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.structure.align.client;\n\nimport static org.biojava.nbio.structure.align.client.StructureName.Source.*;\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class TestStructureName {\n\n\t@Test\n\tpublic void testMultiCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"4V4F.AL\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\t\t\n\t\tstr = \"4v4f.AL\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"AL\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\tstr = \"4v4f.al\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"al\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\tstr = \"4v4f.ABCD\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCD\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\t\t\n\t\t// More than 4 characters should work too. In principle there's no limit in mmCIF, though the PDB is \n\t\t// restricting chain ids to 4 chars \n\t\tstr = \"4v4f.ABCDEFGHIJ\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"ABCDEFGHIJ\", sn.getChainId());\n\t\tassertEquals(\"4V4F\", sn.getPdbId());\n\n\n\t}\n\t\n\t@Test\n\tpublic void testSingleCharChainIds() throws StructureException {\n\t\t\n\t\tString str = \"1SMT.A\";\n\t\t\n\t\tStructureName sn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"A\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\t\t\n\t\tstr = \"1SMT.a\";\n\t\tsn = new StructureName(str);\n\t\t\n\t\tassertEquals(\"a\", sn.getChainId());\n\t\tassertEquals(\"1SMT\", sn.getPdbId());\n\n\t\t\n\t}\n\n\t@Test\n\tpublic void testFiles() throws IOException {\n\t\tFile f = new File(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(f.exists());\n\t\tassertNull(f.getParentFile());\n\t\tStructureName sn = new StructureName(\"hopefully_this_doesnt_exist_nalkjas3\");\n\t\tassertFalse(sn.isFile());\n\t\tassertTrue(sn.isPdbId());\n\t}\n\t/**\n\t * Test explicit prefixes\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testPrefixes() throws StructureException {\n\t\tStructureName sn;\n\t\t\n\t\t// Basic case\n\t\tsn = new StructureName(\"PDB:4hhb\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\tsn = new StructureName(\"PDB:4hhb.A:1-50\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// Invalid strings work too, they just don't load\n\t\tsn = new StructureName(\"PDB:x\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"x\",sn.getPdbId());\n\t\t// SCOP\n\t\tsn = new StructureName(\"SCOP:d2gs2a_\");\n\t\tassertTrue(sn.isScopName());\n\t\tassertTrue(sn.getSource() == SCOP);\n\t\tassertEquals(\"2GS2\",sn.getPdbId());\n\t\t// CATH\n\t\tsn = new StructureName(\"CATH:1qvrC03\");\n\t\tassertTrue(sn.isCathID());\n\t\tassertTrue(sn.getSource() == CATH);\n\t\tassertEquals(\"1QVR\",sn.getPdbId());\n\t\t// PDP\n\t\tsn = new StructureName(\"PDP:4HHBAa\");\n\t\tassertTrue(sn.isPDPDomain());\n\t\tassertTrue(sn.getSource() == PDP);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// URL\n\t\tsn = new StructureName(\"URL:http://www.rcsb.org/pdb/files/1B8G.pdb.gz\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"1B8G\",sn.getPdbId());\n\t\tsn = new StructureName(\"URL:file:///4hhb.pdb\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// File: expand home directory (invalid URL)\n\t\tsn = new StructureName(\"FILE:~/4hhb.pdb\");\n\t\tassertTrue(sn.isFile());\n\t\tassertTrue(sn.getSource() == FILE);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// Relative file (invalid URL)\n\t\tsn = new StructureName(\"file:4hhb.pdb\");\n\t\tassertTrue(sn.isFile());\n\t\tassertTrue(sn.getSource() == FILE);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// Absolute paths are valid URLs\n\t\tsn = new StructureName(\"file:/4hhb_other.pdb\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\n\t\t// ECOD\n\t\tsn = new StructureName(\"e1lyw.1\");\n\t\tassertTrue(sn.isEcodDomain());\n\t\tassertTrue(sn.getSource() == ECOD);\n\t\tassertEquals(\"1LYW\",sn.getPdbId());\n\t\t// BIO\n\t\tsn = new StructureName(\"BIO:2ehz:1\");\n\t\tassertTrue(sn.isBioAssembly());\n\t\tassertTrue(sn.getSource() == BIO);\n\t\tassertEquals(\"2EHZ\",sn.getPdbId());\n\t\t\n\t\t// Invalid prefix\n\t\tsn = new StructureName(\"XXX:2ehz\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"XXX:2ehz\",sn.getPdbId());\n\n\t}\n\t/**\n\t * Test without prefixes\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testGuesses() throws StructureException {\n\t\tStructureName sn;\n\t\t\n\t\t// Basic case\n\t\tsn = new StructureName(\"4hhb\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\tsn = new StructureName(\"4hhb.A:1-50\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\t\t// Invalid strings work too, they just don't load\n\t\tsn = new StructureName(\"x\");\n\t\tassertTrue(sn.isPdbId());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"x\",sn.getPdbId());\n\t\t// SCOP\n\t\tsn = new StructureName(\"d2gs2a_\");\n\t\tassertTrue(sn.isScopName());\n\t\tassertTrue(sn.getSource() == SCOP);\n\t\tassertEquals(\"2GS2\",sn.getPdbId());\n\t\t// CATH\n\t\tsn = new StructureName(\"1qvrC03\");\n\t\tassertTrue(sn.isCathID());\n\t\tassertTrue(sn.getSource() == CATH);\n\t\tassertEquals(\"1QVR\",sn.getPdbId());\n\t\t// PDP is not guessed\n\t\tsn = new StructureName(\"4HHBAa\");\n\t\tassertFalse(sn.isPDPDomain());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"4HHBAa\",sn.getPdbId());\n\t\t// URL\n\t\tsn = new StructureName(\"http://www.rcsb.org/pdb/files/1B8G.pdb.gz\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"1B8G\",sn.getPdbId());\n\t\tsn = new StructureName(\"file:///4hhb.pdb\");\n\t\tassertTrue(sn.isURL());\n\t\tassertTrue(sn.getSource() == URL);\n\t\tassertEquals(\"4HHB\",sn.getPdbId());\n\n\n\t\t// Files are hard to test, since they rely on existing files\n\t\t// You can run these tests locally after updating the hard-coded paths\n\t\t//sn = new StructureName(\"~/pdb/4hhb.pdb\");\n\t\t//assertTrue(sn.isFile());\n\t\t//assertTrue(sn.getSource() == FILE);\n\t\t//assertEquals(\"4HHB\",sn.getPdbId());\n\t\t//sn = new StructureName(\"/Users/blivens/pdb/4hhb.pdb\");\n\t\t//assertTrue(sn.isFile());\n\t\t//assertTrue(sn.getSource() == FILE);\n\t\t//assertEquals(\"4HHB\",sn.getPdbId());\n\t\t//sn = new StructureName(\"~/pdb/1f9m-1.pdb\");\n\t\t//assertTrue(sn.isFile());\n\t\t//assertTrue(sn.getSource() == FILE);\n\t\t//assertEquals(\"1F9M\",sn.getPdbId());\n\n\t\t// ECOD\n\t\tsn = new StructureName(\"e1lyw.1\");\n\t\tassertTrue(sn.isEcodDomain());\n\t\tassertTrue(sn.getSource() == ECOD);\n\t\tassertEquals(\"1LYW\",sn.getPdbId());\n\t\t// BIO is not guessed\n\t\tsn = new StructureName(\"2ehz:1\");\n\t\tassertFalse(sn.isBioAssembly());\n\t\tassertTrue(sn.getSource() == PDB);\n\t\tassertEquals(\"2ehz:1\",sn.getPdbId());\n\n\t}\n\t\n\t// Not really a test, but rather documenting Java's URL behavior\n\t@Ignore\n\t@Test\n\tpublic void testURLs() throws MalformedURLException {\n\t\tURL url;\n\t\t\n\t\t// Tilde doesn't get expanded\n\t\turl = new URL(\"file://~/1abc.pdb\");\n\t\tassertEquals(\"/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"~\",url.getHost());\n\t\turl = new URL(\"file:///~/1abc.pdb\");\n\t\tassertEquals(\"/~/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"\",url.getHost());\n\t\t\n\t\t// Supports omitting the initial slashes\n\t\turl = new URL(\"file:~/1abc.pdb\");\n\t\tassertEquals(\"~/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"\",url.getHost());\n\t\t\n\t\t// proper case. Three slashes gives empty host\n\t\turl = new URL(\"file:///1abc.pdb\");\n\t\tassertEquals(\"/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"\",url.getHost());\n\t\t\n\t\t// Two slashes triggers host\n\t\turl = new URL(\"file://1abc.pdb\");\n\t\tassertEquals(\"\", url.getPath());\n\t\tassertEquals(\"1abc.pdb\",url.getHost());\n\n\t\t// One slash treated like zero slashes\n\t\turl = new URL(\"file:/1abc.pdb\");\n\t\tassertEquals(\"/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"\",url.getHost());\n\t\tassertEquals(\"file\",url.getProtocol());\n\n\t\t// Surprise! url: prefix already works\n\t\turl = new URL(\"url:file://localhost/1abc.pdb\");\n\t\tassertEquals(\"/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"localhost\",url.getHost());\n\t\tassertEquals(\"file\",url.getProtocol());\n\t\turl = new URL(\"URL:file://localhost/1abc.pdb\");\n\t\tassertEquals(\"/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"localhost\",url.getHost());\n\t\tassertEquals(\"file\",url.getProtocol());\n\n\t\t// But doubling the file prefix doesn't. Is that OK?\n\t\turl = new URL(\"file:file://localhost/1abc.pdb\");\n\t\tassertEquals(\"file://localhost/1abc.pdb\", url.getPath());\n\t\tassertEquals(\"\",url.getHost());\n\t\tassertEquals(\"file\",url.getProtocol());\n\n\t}\n\n}\n","commitMessage":"Honor prefixes for StructureNames\n\nAll sources support a prefix to force parsing. For instance, FILE:1abc\nwill be parsed as a filename, despite looking like a PDB entry.\n\nOne possible exception is identifiers of the form file:/absolute/path,\nwhich are interpreted as URLs rather than FILEs (with equivalent results).\nHowever, relative paths and paths containing home directories are not\nvalid URLs so the source will be set unambiguously as FILE.\n\nThis commit also contains some misc bug fixes, identified by a\nmuch more comprehensive test suite:\n- getPdbId() returns upper-case results for valid 4-letter identifiers\n- clarify order of guessing\n- Documentation improvements\n","test_commitMessage":"Honor prefixes for StructureNames\n\nAll sources support a prefix to force parsing. For instance, FILE:1abc\nwill be parsed as a filename, despite looking like a PDB entry.\n\nOne possible exception is identifiers of the form file:/absolute/path,\nwhich are interpreted as URLs rather than FILEs (with equivalent results).\nHowever, relative paths and paths containing home directories are not\nvalid URLs so the source will be set unambiguously as FILE.\n\nThis commit also contains some misc bug fixes, identified by a\nmuch more comprehensive test suite:\n- getPdbId() returns upper-case results for valid 4-letter identifiers\n- clarify order of guessing\n- Documentation improvements\n","allZero":false}