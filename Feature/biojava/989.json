{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/StringManipulationHelper.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/StringManipulationHelperTest.java","prod_time":"2021-07-24 00:32:55","test_time":"2021-07-24 00:32:55","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"POSITIVE","prod_commitID":"f1a293839bccca35e989a4932d8a9eade879ca2d","test_commitID":"f1a293839bccca35e989a4932d8a9eade879ca2d","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Sep 14, 2011\n * Author: Amr AL-Hossary\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentType;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A utility class for common {@link String} manipulation tasks.\n * All functions are static methods.\n *\n * @author Amr AL-Hossary\n */\npublic class StringManipulationHelper  {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(StringManipulationHelper.class);\n\n\t/**\n\t * we are using Unix endline here, since this is used for testing XML and it\n\t * is part of the XML recommendations: <a href\n\t * =\"http://www.w3.org/TR/REC-xml/#sec-line-ends\"\n\t * >http://www.w3.org/TR/REC-xml/#sec-line-ends</a>\n\t */\n\tprivate static final String UNIX_NEWLINE = \"\\n\";\n\n\tprivate StringManipulationHelper() {\n\t\t// to prevent instantiation\n\t}\n\n\t/**\n\t * Converts an InputStream of text to a String, closing the stream\n\t * before returning.\n\t * <ul>\n\t * <li> Newlines are converted to Unix newlines (\\n)\n\t * <li> Default charset encoding is used to read the stream.\n\t * <li> Any IOException reading the stream is 'squashed' and not made\n\t *   available to caller\n\t * <li> An additional newline is appended at the end of the string.\n\t * <ul>\n\t * @author andreas\n\t * @param stream\n\t * @return a possibly empty but non-null String\n\t */\n\tpublic static String convertStreamToString(InputStream stream) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString line = null;\n\t\ttry {\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t    sb.append(line).append(UNIX_NEWLINE);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// logger.error(\"Exception: \", e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Compares two strings in a case-sensitive manner for equality, line by line, ignoring any difference\n\t * of end line delimiters contained within the 2 Strings.\n\t * <br/>\n\t * This method should\n\t * be used if and only if two Strings are considered identical when all nodes\n\t * are identical including their relative order. Generally useful when\n\t * asserting identity of <b>automatically regenerated</b> XML or PDB.\n\t *\n\t * @param expected\n\t * @param actual\n\t */\n\tpublic static boolean equalsToIgnoreEndline(String expected, String actual) {\n\t\tif (expected == null && actual == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (expected != null ^ actual != null) {\n\t\t\treturn false;\n\t\t}\n\t\tScanner scanner1 = new Scanner(expected);\n\t\tScanner scanner2 = new Scanner(actual);\n\t\tString line1, line2;\n\t\twhile (scanner1.hasNextLine()) {\n\t\t\tline1 = scanner1.nextLine();\n\t\t\tif(scanner2.hasNextLine()) {\n\t\t\t\tline2 = scanner2.nextLine();\n\t\t\t\tif (! line1.equals(line2)) {\n\t\t\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (scanner2.hasNextLine()) {\n\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\treturn false;\n\t\t}\n\n\t\tcloseScanners(scanner1, scanner2);\n\t\treturn true;\n\t}\n\n\tprivate static void closeScanners(Scanner s1, Scanner s2) {\n\t\ts1.close();\n\t\ts2.close();\n\t}\n\n\t/**\n\t * This method is not implemented or used, never returns true\n\t * and should probably be removed.\n\t * @param expected\n\t * @param actual\n\t * @return\n\t * @throws UnsupportedOperationException in most cases\n\t */\n\tpublic static boolean equalsToXml(String expected, String actual) {\n\t\tDocument expectedDocument=null;\n\t\tDocument actualDocument=null;\n\t\ttry {\n\t\t\tDocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\t\t\texpectedDocument = documentBuilder.parse(new ByteArrayInputStream(expected.getBytes()));\n\t\t\tactualDocument = documentBuilder.parse(new ByteArrayInputStream(actual.getBytes()));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t} catch (SAXException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t}\n\t\tfinal DocumentType doctype1 = expectedDocument.getDoctype();\n\t\tfinal DocumentType doctype2 = actualDocument.getDoctype();\n\t\tif (doctype1==null ^ doctype2 == null) {\n\t\t\treturn false;\n\t\t}else if (doctype1!= null /*&& doctype2 != null*/) {\n\t\t\tNamedNodeMap expectedNotations = doctype1.getNotations();\n\t\t\tNamedNodeMap actualNotations = doctype2.getNotations();\n\t\t\tif (expectedNotations.getLength() == actualNotations.getLength()) {\n\t\t\t\tfor (int i = 0; i < expectedNotations.getLength(); i++) {\n\t\t\t\t\tNode node= expectedNotations.item(i);\n\t\t\t\t\tnode.isEqualNode(null);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new UnsupportedOperationException(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Adds padding to left of supplied string\n\t * @param s The String to pad\n\t * @param n an integer >= 1\n\t * @return The left-padded string. \n\t * @throws IllegalArgumentException if n <= 0\n\t */\n\tpublic static String padLeft(String s, int n) {\n\t\tvalidatePadding(n);\n\t    return String.format(\"%1$\" + n + \"s\", s);\n\t}\n\n\t/**\n\t * Adds padding to right of supplied string\n\t * @param s The String to pad\n\t * @param n an integer >= 1\n\t * @return The right-padded string. \n\t * @throws IllegalArgumentException if n <= 0\n\t */\n\tpublic static String padRight(String s, int n) {\n\t\tvalidatePadding(n);\n\t    return String.format(\"%1$-\" + n + \"s\", s);\n\t}\n\n\tprivate static void validatePadding(int n) {\n\t\tif (n <=0 ) {\n\t\t\tthrow new IllegalArgumentException(\"padding must be >= 1\");\n\t\t}\n\t}\n\n\t/**\n\t * Joins Strings together with a delimiter to a single\n\t * @param s An {@link Iterable} of Strings\n\t * @param delimiter\n\t * @return\n\t */\n\tpublic static String join(Iterable<String> s, String delimiter) {\n\t    if (s == null) return \"\";\n\t    Iterator<String> iter = s.iterator();\n\t\tif(!iter.hasNext()){\n\t\t\treturn \"\";\n\t\t}\n\t    StringBuilder builder = new StringBuilder(iter.next());\n\t    while( iter.hasNext() ){\n\t\t    builder.append(delimiter).append(iter.next());\n\t    }\n\t    return builder.toString();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Sep 14, 2011\n * Author: Amr AL-Hossary\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentType;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A utility class for common {@link String} manipulation tasks.\n * All functions are static methods.\n *\n * @author Amr AL-Hossary\n */\npublic class StringManipulationHelper  {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(StringManipulationHelper.class);\n\n\t/**\n\t * we are using Unix endline here, since this is used for testing XML and it\n\t * is part of the XML recommendations: <a href\n\t * =\"http://www.w3.org/TR/REC-xml/#sec-line-ends\"\n\t * >http://www.w3.org/TR/REC-xml/#sec-line-ends</a>\n\t */\n\tprivate static final String UNIX_NEWLINE = \"\\n\";\n\n\tprivate StringManipulationHelper() {\n\t\t// to prevent instantiation\n\t}\n\n\t/**\n\t * Converts an InputStream of text to a String, closing the stream\n\t * before returning.\n\t * <ul>\n\t * <li> Newlines are converted to Unix newlines (\\n)\n\t * <li> Default charset encoding is used to read the stream.\n\t * <li> Any IOException reading the stream is 'squashed' and not made\n\t *   available to caller\n\t * <li> An additional newline is appended at the end of the string.\n\t * <ul>\n\t * @author andreas\n\t * @param stream\n\t * @return a possibly empty but non-null String\n\t */\n\tpublic static String convertStreamToString(InputStream stream) {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tString line = null;\n\t\ttry {\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t    sb.append(line).append(UNIX_NEWLINE);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\t// logger.error(\"Exception: \", e);\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tstream.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Compares two strings in a case-sensitive manner for equality, line by line, ignoring any difference\n\t * of end line delimiters contained within the 2 Strings.\n\t * <br/>\n\t * This method should\n\t * be used if and only if two Strings are considered identical when all nodes\n\t * are identical including their relative order. Generally useful when\n\t * asserting identity of <b>automatically regenerated</b> XML or PDB.\n\t *\n\t * @param expected\n\t * @param actual\n\t */\n\tpublic static boolean equalsToIgnoreEndline(String expected, String actual) {\n\t\tif (expected == null && actual == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (expected != null ^ actual != null) {\n\t\t\treturn false;\n\t\t}\n\t\tScanner scanner1 = new Scanner(expected);\n\t\tScanner scanner2 = new Scanner(actual);\n\t\tString line1, line2;\n\t\twhile (scanner1.hasNextLine()) {\n\t\t\tline1 = scanner1.nextLine();\n\t\t\tif(scanner2.hasNextLine()) {\n\t\t\t\tline2 = scanner2.nextLine();\n\t\t\t\tif (! line1.equals(line2)) {\n\t\t\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (scanner2.hasNextLine()) {\n\t\t\tcloseScanners(scanner1, scanner2);\n\t\t\treturn false;\n\t\t}\n\n\t\tcloseScanners(scanner1, scanner2);\n\t\treturn true;\n\t}\n\n\tprivate static void closeScanners(Scanner s1, Scanner s2) {\n\t\ts1.close();\n\t\ts2.close();\n\t}\n\n\t/**\n\t * This method is not implemented or used, never returns true\n\t * and should probably be removed.\n\t * @param expected\n\t * @param actual\n\t * @return\n\t * @throws UnsupportedOperationException in most cases\n\t */\n\tpublic static boolean equalsToXml(String expected, String actual) {\n\t\tDocument expectedDocument=null;\n\t\tDocument actualDocument=null;\n\t\ttry {\n\t\t\tDocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n\t\t\tDocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\t\t\texpectedDocument = documentBuilder.parse(new ByteArrayInputStream(expected.getBytes()));\n\t\t\tactualDocument = documentBuilder.parse(new ByteArrayInputStream(actual.getBytes()));\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t} catch (SAXException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"Exception: \", e);\n\t\t\tthrow new RuntimeException(\"Couldn't Parse XML\", e);\n\t\t}\n\t\tfinal DocumentType doctype1 = expectedDocument.getDoctype();\n\t\tfinal DocumentType doctype2 = actualDocument.getDoctype();\n\t\tif (doctype1==null ^ doctype2 == null) {\n\t\t\treturn false;\n\t\t}else if (doctype1!= null /*&& doctype2 != null*/) {\n\t\t\tNamedNodeMap expectedNotations = doctype1.getNotations();\n\t\t\tNamedNodeMap actualNotations = doctype2.getNotations();\n\t\t\tif (expectedNotations.getLength() == actualNotations.getLength()) {\n\t\t\t\tfor (int i = 0; i < expectedNotations.getLength(); i++) {\n\t\t\t\t\tNode node= expectedNotations.item(i);\n\t\t\t\t\tnode.isEqualNode(null);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new UnsupportedOperationException(\"not yet implemented\");\n\t}\n\n\t/**\n\t * Adds padding to left of supplied string\n\t * @param s The String to pad\n\t * @param n an integer >= 1\n\t * @return The left-padded string. \n\t * @throws IllegalArgumentException if n <= 0\n\t */\n\tpublic static String padLeft(String s, int n) {\n\t\tvalidatePadding(n);\n\t    return String.format(\"%1$\" + n + \"s\", s);\n\t}\n\n\t/**\n\t * Adds padding to right of supplied string\n\t * @param s The String to pad\n\t * @param n an integer >= 1\n\t * @return The right-padded string. \n\t * @throws IllegalArgumentException if n <= 0\n\t */\n\tpublic static String padRight(String s, int n) {\n\t\tvalidatePadding(n);\n\t    return String.format(\"%1$-\" + n + \"s\", s);\n\t}\n\n\tprivate static void validatePadding(int n) {\n\t\tif (n <=0 ) {\n\t\t\tthrow new IllegalArgumentException(\"padding must be >= 1\");\n\t\t}\n\t}\n\n\t/**\n\t * Joins Strings together with a delimiter to a single\n\t * @param s An {@link Iterable} of Strings\n\t * @param delimiter\n\t * @return\n\t */\n\tpublic static String join(Collection<String> s, String delimiter) {\n\t    if (s == null) return \"\";\n\t    Iterator<String> iter = s.iterator();\n\t\tif(!iter.hasNext()){\n\t\t\treturn \"\";\n\t\t}\n\t    StringBuilder builder = new StringBuilder(iter.next());\n\t    while( iter.hasNext() ){\n\t\t    builder.append(delimiter).append(iter.next());\n\t    }\n\t    return builder.toString();\n\t}\n\n}\n","originTest":"package org.biojava.nbio.core.util;\nimport static org.biojava.nbio.core.util.StringManipulationHelper.equalsToIgnoreEndline;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nclass StringManipulationHelperTest {\n\n    @Nested\n    class PaddingTest {\n\t    @Test\n        void padLeft() {\n            assertEquals(\"     \",\n            StringManipulationHelper.padLeft(\"\",5));\n            assertEquals(\"   xx\",\n                StringManipulationHelper.padLeft(\"xx\",5));\n            assertEquals(\"xxxxxx\", StringManipulationHelper.padLeft(\"xxxxxx\",5));\n        }\n\n        @Test\n        void padRight() {\n            assertEquals(\"     \",\n            StringManipulationHelper.padRight(\"\",5));\n            assertEquals(\"xx   \",\n                StringManipulationHelper.padRight(\"xx\",5));\n            assertEquals(\"xxxxxx\", StringManipulationHelper.padRight(\"xxxxxx\",5));\n        }\n\n        @ParameterizedTest\n        @ValueSource(ints = {0,-1,-2})\n        @DisplayName(\"invalid padding arguments throw IAE\")\n        void padInvalidValues(int invalidPadding) {\n            assertThrows(IllegalArgumentException.class, \n              ()->StringManipulationHelper.padLeft(\n               \"anystring\",invalidPadding));\n            assertThrows(IllegalArgumentException.class, \n               ()->StringManipulationHelper.padRight(\n                \"anystring\",invalidPadding));\n        }\n    \n   }\n   @Nested\n   class InputStreamToString {\n\n        @Test\n        void basicString(){\n           String singleLine = \"hello\";\n           ByteArrayInputStream bais = new ByteArrayInputStream(singleLine.getBytes());\n           assertEquals(\"hello\\n\", StringManipulationHelper.convertStreamToString(bais));\n        }\n\n        @ParameterizedTest\n        @DisplayName(\"Newlines are converted to Unix newlines\")\n        @ValueSource(strings={\"line1\\r\\nline2\", \"line1\\nline2\", \"line1\\rline2\"})\n        void multiLineConvertedToUnixNewLine(String multiline){\n           ByteArrayInputStream bais = new ByteArrayInputStream(multiline.getBytes());\n           assertEquals(\"line1\\nline2\\n\", StringManipulationHelper.convertStreamToString(bais));\n        }\n\n        @Test\n        void streamIsClosedAfterCompletion() throws IOException{\n            // this is a stream that will throw IOException\n            // if called after closing\n            InputStream is = InputStream.nullInputStream();\n            StringManipulationHelper.convertStreamToString(is);\n            // attempt to read again after closing\n            assertThrows(IOException.class, ()->is.read());\n        }\n\n        @Test\n        void emptyStreamGeneratesEmptyString() {\n            assertEquals(\"\", StringManipulationHelper.convertStreamToString(\n                new ByteArrayInputStream(new byte [0])));\n        }\n    }\n\n    @Nested\n    class equalsToIgnoreEndline{\n        @Test\n        void emptyOrNullStringsAreEqual() {\n            assertTrue(equalsToIgnoreEndline(\"\",\"\"));\n            assertTrue(equalsToIgnoreEndline(null, null));\n        }\n\n        @Test\n        void emptyVsNullStringsAreNotEqual() {\n            assertFalse(equalsToIgnoreEndline(null,\"\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different line terminators are equal\")\n        void differentLineTerminatorsAreEqual() {\n            assertTrue(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\r\\ncd\\r\\nef\"));\n            assertTrue(equalsToIgnoreEndline(\"ab\\r\\ncd\\nef\",\"ab\\rcd\\ref\"));\n        }\n\n        @Test\n        @DisplayName(\"comparison is case-sensitive\")\n        void caseSensitive() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\nCD\\nef\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different lengths are  unequal\")\n        void s2LongerThanS1() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\ncd\\nef\\nextra-line\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different lengths are  unequal\")\n        void s1LongerThanS2() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\\nextra\",\"ab\\ncd\\nef\"));\n        }\n    }\n    @Nested\n    class JoinString{   \n        List<String> empty = new ArrayList<>();\n        List<String> items =  new ArrayList<>();\n        void populateItems() {\n            items.add(\"a\");\n            items.add(\"b\");\n            items.add(\"c\");\n        }\n        @Test\n        void join() {\n\n            assertEquals(\"\", StringManipulationHelper.join(empty,\",\"));\n            items.add(\"a\");\n            assertEquals(\"a\", StringManipulationHelper.join(items,\",\"));\n            items.add(\"b\");\n            items.add(\"c\");\n            assertEquals(\"a,b,c\", StringManipulationHelper.join(items,\",\"));\n            assertEquals(\"abc\", StringManipulationHelper.join(items,\"\"));\n        }\n        @Test\n        void delimiterCanBeAnyLength(){\n            populateItems();\n            assertEquals(\"a---b---c\", StringManipulationHelper.join(items,\"---\"));\n            \n        }\n    }\n\n    @Nested\n    class EqualsToXml {\n\n        String docType =\"<!DOCTYPE \" +\n        \"ex  [ <!ENTITY foo \\\"foo\\\"> <!ENTITY bar\"+\n        \" \\\"bar\\\">]> <ex/>\";\n        @Test\n        void isNotImplemented() {\n            assertThrows(UnsupportedOperationException.class, \n            ()->StringManipulationHelper.equalsToXml(docType, docType));\n        }\n    }\n}","changedTest":"package org.biojava.nbio.core.util;\nimport static org.biojava.nbio.core.util.StringManipulationHelper.equalsToIgnoreEndline;\nimport static org.junit.Assert.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nclass StringManipulationHelperTest {\n\n    @Nested\n    class PaddingTest {\n\t    @Test\n        void padLeft() {\n            assertEquals(\"     \",\n            StringManipulationHelper.padLeft(\"\",5));\n            assertEquals(\"   xx\",\n                StringManipulationHelper.padLeft(\"xx\",5));\n            assertEquals(\"xxxxxx\", StringManipulationHelper.padLeft(\"xxxxxx\",5));\n        }\n\n        @Test\n        void padRight() {\n            assertEquals(\"     \",\n            StringManipulationHelper.padRight(\"\",5));\n            assertEquals(\"xx   \",\n                StringManipulationHelper.padRight(\"xx\",5));\n            assertEquals(\"xxxxxx\", StringManipulationHelper.padRight(\"xxxxxx\",5));\n        }\n\n        @ParameterizedTest\n        @ValueSource(ints = {0,-1,-2})\n        @DisplayName(\"invalid padding arguments throw IAE\")\n        void padInvalidValues(int invalidPadding) {\n            assertThrows(IllegalArgumentException.class, \n              ()->StringManipulationHelper.padLeft(\n               \"anystring\",invalidPadding));\n            assertThrows(IllegalArgumentException.class, \n               ()->StringManipulationHelper.padRight(\n                \"anystring\",invalidPadding));\n        }\n    \n   }\n   @Nested\n   class InputStreamToString {\n\n        @Test\n        void basicString(){\n           String singleLine = \"hello\";\n           ByteArrayInputStream bais = new ByteArrayInputStream(singleLine.getBytes());\n           assertEquals(\"hello\\n\", StringManipulationHelper.convertStreamToString(bais));\n        }\n\n        @ParameterizedTest\n        @DisplayName(\"Newlines are converted to Unix newlines\")\n        @ValueSource(strings={\"line1\\r\\nline2\", \"line1\\nline2\", \"line1\\rline2\"})\n        void multiLineConvertedToUnixNewLine(String multiline){\n           ByteArrayInputStream bais = new ByteArrayInputStream(multiline.getBytes());\n           assertEquals(\"line1\\nline2\\n\", StringManipulationHelper.convertStreamToString(bais));\n        }\n        // in java11 there is a NullInputStream for this\n        class InputStreamTss extends InputStream {\n        \tboolean closed = false;\n\t\t\t@Override\n\t\t\tpublic int read() throws IOException {\n\t\t\t\tif (closed) {\n\t\t\t\t\tthrow  new IOException();\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpublic void close() throws IOException {\n\t\t\t\tclosed = true;\n\t\t\t}\n        \t\n        }\n        \n\n        @Test\n        void streamIsClosedAfterCompletion() throws IOException{\n            // this is a stream that will throw IOException\n            // if called after closing\n            InputStream is =  new InputStreamTss();\n\n            StringManipulationHelper.convertStreamToString(is);\n            // attempt to read again after closing\n            assertThrows(IOException.class, ()->is.read());\n        }\n\n        @Test\n        void emptyStreamGeneratesEmptyString() {\n            assertEquals(\"\", StringManipulationHelper.convertStreamToString(\n                new ByteArrayInputStream(new byte [0])));\n        }\n    }\n\n    @Nested\n    class equalsToIgnoreEndline{\n        @Test\n        void emptyOrNullStringsAreEqual() {\n            assertTrue(equalsToIgnoreEndline(\"\",\"\"));\n            assertTrue(equalsToIgnoreEndline(null, null));\n        }\n\n        @Test\n        void emptyVsNullStringsAreNotEqual() {\n            assertFalse(equalsToIgnoreEndline(null,\"\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different line terminators are equal\")\n        void differentLineTerminatorsAreEqual() {\n            assertTrue(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\r\\ncd\\r\\nef\"));\n            assertTrue(equalsToIgnoreEndline(\"ab\\r\\ncd\\nef\",\"ab\\rcd\\ref\"));\n        }\n\n        @Test\n        @DisplayName(\"comparison is case-sensitive\")\n        void caseSensitive() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\nCD\\nef\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different lengths are  unequal\")\n        void s2LongerThanS1() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\",\"ab\\ncd\\nef\\nextra-line\"));\n        }\n\n        @Test\n        @DisplayName(\"multiline strings with different lengths are  unequal\")\n        void s1LongerThanS2() {\n            assertFalse(equalsToIgnoreEndline(\"ab\\ncd\\nef\\nextra\",\"ab\\ncd\\nef\"));\n        }\n    }\n    @Nested\n    class JoinString{   \n        List<String> empty = new ArrayList<>();\n        List<String> items =  new ArrayList<>();\n        void populateItems() {\n            items.add(\"a\");\n            items.add(\"b\");\n            items.add(\"c\");\n        }\n        @Test\n        void join() {\n\n            assertEquals(\"\", StringManipulationHelper.join(empty,\",\"));\n            assertEquals(\"\", StringManipulationHelper.join(null,\",\"));\n            items.add(\"a\");\n            assertEquals(\"a\", StringManipulationHelper.join(items,\",\"));\n            items.add(\"b\");\n            items.add(\"c\");\n            assertEquals(\"a,b,c\", StringManipulationHelper.join(items,\",\"));\n            assertEquals(\"abc\", StringManipulationHelper.join(items,\"\"));\n        }\n        @Test\n        void delimiterCanBeAnyLength(){\n            populateItems();\n            assertEquals(\"a---b---c\", StringManipulationHelper.join(items,\"---\"));      \n        }\n    }\n\n    @Nested\n    class EqualsToXml {\n\n        String docType =\"<!DOCTYPE \" +\n        \"ex  [ <!ENTITY foo \\\"foo\\\"> <!ENTITY bar\"+\n        \" \\\"bar\\\">]> <ex/>\";\n        @Test\n        void isNotImplemented() {\n            assertThrows(UnsupportedOperationException.class, \n            ()->StringManipulationHelper.equalsToXml(docType, docType));\n        }\n    }\n}","commitMessage":"fix input stream test for java8\n","test_commitMessage":"fix input stream test for java8\n","allZero":false}