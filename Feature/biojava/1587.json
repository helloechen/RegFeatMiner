{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/ResidueRange.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/ResidueRangeTest.java","prod_time":"2013-07-12 06:56:51","test_time":"2013-07-12 06:56:51","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"778d4a268ff1dbc165cfed45e0da84dd1d7325f8","test_commitID":"778d4a268ff1dbc165cfed45e0da84dd1d7325f8","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A chain, a start residue, and an end residue. May also store a length value. Because of insertion codes, this length\n * is not necessarily {@code end − start}.\n * \n * @author dmyerstu\n * @see ResidueNumber\n */\npublic class ResidueRange {\n\n\tprivate final String chain;\n\tprivate final ResidueNumber end;\n\tprivate final Integer length;\n\tprivate final ResidueNumber start;\n\n\tpublic static final String RANGE_REGEX = \"^([a-zA-Z])+[\\\\._:](?:(-?\\\\d+[a-zA-Z]?)-(-?\\\\d+[a-zA-Z]?))?$\";\n\n\t/**\n\t * Calculates the combined number of residues of the ResidueRanges in {@code rrs},\n\t * <em>given that each ResidueRange has a length calculated</em>. The value, if calculated,\n\t * <em>will include any alignment gaps</em>.\n\t * \n\t * @param rrs\n\t *            A list of ResidueRanges\n\t * @return The combined length\n\t * @throws IllegalArgumentException\n\t *             If the {@link #getLength() length} of one or more ResidueRange is null\n\t * @see #getLength()\n\t */\n\tpublic static int calcLength(List<ResidueRange> rrs) {\n\t\tint l = 0;\n\t\tfor (ResidueRange rr : rrs) {\n\t\t\tif (rr.getLength() == null) throw new IllegalArgumentException(\n\t\t\t\t\t\"At least one ResidueRange does not have a length.\");\n\t\t\tl += rr.getLength();\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end or chain.start-end. For example: <code>A.5-100</code> or <code>A_5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}\n\t */\n\tpublic static ResidueRange parse(String s) {\n\t\tResidueNumber start = null, end = null;\n\t\tString chain = null;\n\t\tPattern pattern = Pattern.compile(RANGE_REGEX);\n\t\tMatcher matcher = pattern.matcher(s);\n\t\tmatcher.find();\n\t\tif (matcher.matches()) {\n\t\t\ttry {\n\t\t\t\tchain = matcher.group(1);\n\t\t\t\tif (matcher.group(2) != null) {\n\t\t\t\t\tstart = ResidueNumber.fromString(matcher.group(2));\n\t\t\t\t\tend = ResidueNumber.fromString(matcher.group(3));\n\t\t\t\t\tstart.setChainId(chain);\n\t\t\t\t\tend.setChainId(chain);\n\t\t\t\t}\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range \" + s + \" was not valid\", e);\n\t\t\t}\n\t\t}\n\t\treturn new ResidueRange(chain, start, end, null);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static ResidueRange parse(String s, AtomPositionMap map) {\n\t\tResidueRange rr = parse(s);\n\t\tif (rr.getStart() == null) { // whole chain\n\t\t\tString chain = rr.getChainId();\n\t\t\trr = new ResidueRange(chain, map.getFirst(chain), map.getLast(chain), null);\n\t\t}\n\t\tint length = map.calcLength(rr.getStart(), rr.getEnd());\n\t\treturn new ResidueRange(rr.getChainId(), rr.getStart(), rr.getEnd(), length);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s, AtomPositionMap map) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part, map));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(char chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis(String.valueOf(chain), start, end, length);\n\t}\n\n\tpublic ResidueRange(String chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.length = length;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain == null) {\n\t\t\tif (other.chain != null) return false;\n\t\t} else if (!chain.equals(other.chain)) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the chain Id as a char.\n\t * @deprecated Use {@link #getChainId()} instead, which does not require that chain Ids have a length of 1\n\t * @throws IllegalArgumentException If the chain Id contains more than 1 character\n\t */\n\t@Deprecated\n\tpublic char getChain() {\n\t\tif (chain.length() > 1) throw new IllegalArgumentException(\"Can't return full chain Id \" + chain);\n\t\treturn chain.charAt(0);\n\t}\n\n\tpublic String getChainId() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\t/**\n\t * @return The number of residues in this ResidueRange, including any alignment gaps. This value will be null if and\n\t *         only if this ResidueRange was created with a null length.\n\t */\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (chain == null ? 0 : chain.hashCode());\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n\t/**\n\t * @return True if and only if {@code residueNumber} is within this ResidueRange\n\t */\n\tpublic boolean contains(ResidueNumber residueNumber, AtomPositionMap map) {\n\t\tint pos = map.getPosition(residueNumber);\n\t\tint startPos = map.getPosition(start);\n\t\tint endPos = map.getPosition(end);\n\t\treturn pos >= startPos && pos <= endPos;\n\t}\n\n\t/**\n\t * Returns the ResidueNumber that is at position {@code positionInRange} in <em>this</em> ResidueRange.\n\t * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n\t */\n\tpublic ResidueNumber getResidue(int positionInRange, AtomPositionMap map) {\n\t\tint i = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : map.getNavMap().entrySet()) {\n\t\t\tif (i == positionInRange) return entry.getKey();\n\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic Iterator<ResidueNumber> iterator(final AtomPositionMap map) {\n\t\t// get the length without the side effect of setting it\n\t\tint theLength = 0;\n\t\tif (length == null) {\n\t\t\ttheLength = map.calcLength(start, end);\n\t\t} else {\n\t\t\ttheLength = this.length;\n\t\t}\n\t\tfinal int length = theLength;\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate ResidueNumber[] residueNumbers = new ResidueNumber[map.getNavMap().size()];\n\t\t\tprivate int i = -1;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn i < length;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (i == -1) {\n\t\t\t\t\tresidueNumbers = new ResidueNumber[map.getNavMap().size()];\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tfor (Map.Entry<ResidueNumber,Integer> entry : map.getNavMap().entrySet()) {\n\t\t\t\t\t\tresidueNumbers[j] = entry.getKey();\n\t\t\t\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tResidueNumber rn = residueNumbers[i];\n\t\t\t\t// let's assume we're not going to use this anymore\n\t\t\t\t// destroy array to free memory\n\t\t\t\t// we can always reconstruct\n\t\t\t\tif (i > length) {\n\t\t\t\t\tresidueNumbers = null;\n\t\t\t\t\ti = -1;\n\t\t\t\t}\n\t\t\t\treturn rn;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\t// do nothing since ResidueRange is not modifiable\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(final AtomPositionMap map, final ResidueRange... rrs) {\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate int r = 0;\n\t\t\tprivate Iterator<ResidueNumber> internal;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (r == rrs.length - 1) {\n\t\t\t\t\tinit();\n\t\t\t\t\treturn internal.hasNext();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprivate void init() {\n\t\t\t\tif (internal == null) {\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (rrs.length == 0) throw new NoSuchElementException();\n\t\t\t\tinit();\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tif (!internal.hasNext()) {\n\t\t\t\t\tr++;\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t\treturn internal.next();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\t// do nothing since ResidueRange is not modifiable\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(AtomPositionMap map, List<ResidueRange> rrs) {\n\t\tResidueRange[] ranges = new ResidueRange[rrs.size()];\n\t\tfor (int i = 0; i < rrs.size(); i++) {\n\t\t\tranges[i] = rrs.get(i);\n\t\t}\n\t\treturn multiIterator(map, ranges);\n\t}\n\n\tpublic static List<ResidueRange> parseMultiple(List<String> ranges) {\n\t\tList<ResidueRange> rrs = new ArrayList<ResidueRange>(ranges.size());\n\t\tfor (String range : ranges) {\n\t\t\trrs.add(ResidueRange.parse(range));\n\t\t}\n\t\treturn rrs;\n\t}\n\n\t/**\n\t * Determines whether a String is of a recognizable range format\n\t */\n\tpublic static boolean looksLikeRange(String s) {\n\t\tPattern pattern = Pattern.compile(RANGE_REGEX);\n\t\tMatcher matcher = pattern.matcher(s);\n\t\tmatcher.find();\n\t\treturn matcher.matches();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A chain, a start residue, and an end residue. May also store a length value. Because of insertion codes, this length\n * is not necessarily {@code end − start}.\n * \n * @author dmyerstu\n * @see ResidueNumber\n */\npublic class ResidueRange {\n\n\tprivate final String chain;\n\tprivate final ResidueNumber end;\n\tprivate final Integer length;\n\tprivate final ResidueNumber start;\n\n\tpublic static final String RANGE_REGEX = \"^([a-zA-Z])+[_:](?:(-?\\\\d+[a-zA-Z]?)-(-?\\\\d+[a-zA-Z]?))?$\";\n\n\t/**\n\t * Calculates the combined number of residues of the ResidueRanges in {@code rrs},\n\t * <em>given that each ResidueRange has a length calculated</em>. The value, if calculated,\n\t * <em>will include any alignment gaps</em>.\n\t * \n\t * @param rrs\n\t *            A list of ResidueRanges\n\t * @return The combined length\n\t * @throws IllegalArgumentException\n\t *             If the {@link #getLength() length} of one or more ResidueRange is null\n\t * @see #getLength()\n\t */\n\tpublic static int calcLength(List<ResidueRange> rrs) {\n\t\tint l = 0;\n\t\tfor (ResidueRange rr : rrs) {\n\t\t\tif (rr.getLength() == null) throw new IllegalArgumentException(\n\t\t\t\t\t\"At least one ResidueRange does not have a length.\");\n\t\t\tl += rr.getLength();\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end or chain.start-end. For example: <code>A.5-100</code> or <code>A_5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}\n\t */\n\tpublic static ResidueRange parse(String s) {\n\t\tResidueNumber start = null, end = null;\n\t\tString chain = null;\n\t\tPattern pattern = Pattern.compile(RANGE_REGEX);\n\t\tMatcher matcher = pattern.matcher(s);\n\t\tmatcher.find();\n\t\tif (matcher.matches()) {\n\t\t\ttry {\n\t\t\t\tchain = matcher.group(1);\n\t\t\t\tif (matcher.group(2) != null) {\n\t\t\t\t\tstart = ResidueNumber.fromString(matcher.group(2));\n\t\t\t\t\tend = ResidueNumber.fromString(matcher.group(3));\n\t\t\t\t\tstart.setChainId(chain);\n\t\t\t\t\tend.setChainId(chain);\n\t\t\t\t}\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range \" + s + \" was not valid\", e);\n\t\t\t}\n\t\t}\n\t\treturn new ResidueRange(chain, start, end, null);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static ResidueRange parse(String s, AtomPositionMap map) {\n\t\tResidueRange rr = parse(s);\n\t\tif (rr.getStart() == null) { // whole chain\n\t\t\tString chain = rr.getChainId();\n\t\t\trr = new ResidueRange(chain, map.getFirst(chain), map.getLast(chain), null);\n\t\t}\n\t\tint length = map.calcLength(rr.getStart(), rr.getEnd());\n\t\treturn new ResidueRange(rr.getChainId(), rr.getStart(), rr.getEnd(), length);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s, AtomPositionMap map) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part, map));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(char chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis(String.valueOf(chain), start, end, length);\n\t}\n\n\tpublic ResidueRange(String chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.length = length;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain == null) {\n\t\t\tif (other.chain != null) return false;\n\t\t} else if (!chain.equals(other.chain)) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the chain Id as a char.\n\t * @deprecated Use {@link #getChainId()} instead, which does not require that chain Ids have a length of 1\n\t * @throws IllegalArgumentException If the chain Id contains more than 1 character\n\t */\n\t@Deprecated\n\tpublic char getChain() {\n\t\tif (chain.length() > 1) throw new IllegalArgumentException(\"Can't return full chain Id \" + chain);\n\t\treturn chain.charAt(0);\n\t}\n\n\tpublic String getChainId() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\t/**\n\t * @return The number of residues in this ResidueRange, including any alignment gaps. This value will be null if and\n\t *         only if this ResidueRange was created with a null length.\n\t */\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (chain == null ? 0 : chain.hashCode());\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n\t/**\n\t * @return True if and only if {@code residueNumber} is within this ResidueRange\n\t */\n\tpublic boolean contains(ResidueNumber residueNumber, AtomPositionMap map) {\n\t\tint pos = map.getPosition(residueNumber);\n\t\tint startPos = map.getPosition(start);\n\t\tint endPos = map.getPosition(end);\n\t\treturn pos >= startPos && pos <= endPos;\n\t}\n\n\t/**\n\t * Returns the ResidueNumber that is at position {@code positionInRange} in <em>this</em> ResidueRange.\n\t * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n\t */\n\tpublic ResidueNumber getResidue(int positionInRange, AtomPositionMap map) {\n\t\tint i = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : map.getNavMap().entrySet()) {\n\t\t\tif (i == positionInRange) return entry.getKey();\n\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic Iterator<ResidueNumber> iterator(final AtomPositionMap map) {\n\t\t// get the length without the side effect of setting it\n\t\tint theLength = 0;\n\t\tif (length == null) {\n\t\t\ttheLength = map.calcLength(start, end);\n\t\t} else {\n\t\t\ttheLength = this.length;\n\t\t}\n\t\tfinal int length = theLength;\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate ResidueNumber[] residueNumbers = new ResidueNumber[map.getNavMap().size()];\n\t\t\tprivate int i = -1;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn i < length;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (i == -1) {\n\t\t\t\t\tresidueNumbers = new ResidueNumber[map.getNavMap().size()];\n\t\t\t\t\tint j = 0;\n\t\t\t\t\tfor (Map.Entry<ResidueNumber,Integer> entry : map.getNavMap().entrySet()) {\n\t\t\t\t\t\tresidueNumbers[j] = entry.getKey();\n\t\t\t\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tResidueNumber rn = residueNumbers[i];\n\t\t\t\t// let's assume we're not going to use this anymore\n\t\t\t\t// destroy array to free memory\n\t\t\t\t// we can always reconstruct\n\t\t\t\tif (i > length) {\n\t\t\t\t\tresidueNumbers = null;\n\t\t\t\t\ti = -1;\n\t\t\t\t}\n\t\t\t\treturn rn;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\t// do nothing since ResidueRange is not modifiable\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(final AtomPositionMap map, final ResidueRange... rrs) {\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate int r = 0;\n\t\t\tprivate Iterator<ResidueNumber> internal;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (r == rrs.length - 1) {\n\t\t\t\t\tinit();\n\t\t\t\t\treturn internal.hasNext();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprivate void init() {\n\t\t\t\tif (internal == null) {\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (rrs.length == 0) throw new NoSuchElementException();\n\t\t\t\tinit();\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tif (!internal.hasNext()) {\n\t\t\t\t\tr++;\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t\treturn internal.next();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\t// do nothing since ResidueRange is not modifiable\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(AtomPositionMap map, List<ResidueRange> rrs) {\n\t\tResidueRange[] ranges = new ResidueRange[rrs.size()];\n\t\tfor (int i = 0; i < rrs.size(); i++) {\n\t\t\tranges[i] = rrs.get(i);\n\t\t}\n\t\treturn multiIterator(map, ranges);\n\t}\n\n\tpublic static List<ResidueRange> parseMultiple(List<String> ranges) {\n\t\tList<ResidueRange> rrs = new ArrayList<ResidueRange>(ranges.size());\n\t\tfor (String range : ranges) {\n\t\t\trrs.add(ResidueRange.parse(range));\n\t\t}\n\t\treturn rrs;\n\t}\n\n\t/**\n\t * Determines whether a String is of a recognizable range format\n\t */\n\tpublic static boolean looksLikeRange(String s) {\n\t\tPattern pattern = Pattern.compile(RANGE_REGEX);\n\t\tMatcher matcher = pattern.matcher(s);\n\t\tmatcher.find();\n\t\treturn matcher.matches();\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NavigableMap;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * A unit test for {@link ResidueRange}.\n * @author dmyerstu\n *\n */\npublic class ResidueRangeTest {\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache();\n\t\tcache.setFetchFileEvenIfObsolete(true);\n\t}\n\n\t@Test\n\tpublic void testWholeChainBasic() {\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRange.parse(range);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertNull(\"Start residue should be null\", rr.getStart());\n\t\tassertNull(\"End residue should be null\", rr.getEnd());\n\t}\n\n\t@Test\n\tpublic void testWholeChainWithMap() throws IOException, StructureException {\n\t\tString pdbId = \"1cph\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRange.parse(range, map);\n\t\tResidueNumber start = new ResidueNumber(\"B\", 1, null);\n\t\tResidueNumber end = new ResidueNumber(\"B\", 30, null);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertEquals(\"Wrong start\", start, rr.getStart());\n\t\tassertEquals(\"Wrong end\", end, rr.getEnd());\n\t}\n\t\n\t/**\n\t * Tests creating ResidueRanges and calculating their lengths.\n\t */\n\t@Test\n\tpublic void testBasic() {\n\t\tString[] ids = new String[] {\"1w0p\", \"3qq3\", \"3chc\", \"2ei7\"}; // more: , \"2qbr\"\n\t\tString[] chains = new String[] {\"A\", \"B\", \"A\", \"L\"};\n\t\tResidueNumber[] starts = new ResidueNumber[] {new ResidueNumber(\"A\", 5, ' '), new ResidueNumber(\"B\", 10, 's'), new ResidueNumber(\"A\", 15, 'm'), new ResidueNumber(\"L\", 44, ' ')};\n\t\tResidueNumber[] ends = new ResidueNumber[] {new ResidueNumber(\"A\", 117, ' '), new ResidueNumber(\"B\", 200, 's'), new ResidueNumber(\"A\", 464, 'q'), new ResidueNumber(\"L\", 254, 't')};\n\t\tInteger[] lengths = new Integer[] {117-5, 200-10, 111, null};\n\t\tint totalLength = 0;\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>(ids.length);\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tResidueRange rr = new ResidueRange(chains[i], starts[i], ends[i], lengths[i]);\n\t\t\tassertEquals(\"The chain is incorrect\", chains[i], rr.getChainId());\n\t\t\tassertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n\t\t\tassertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n\t\t\tassertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n\t\t\tranges.add(rr);\n\t\t\tif (lengths[i] != null) {\n\t\t\t\ttotalLength += lengths[i];\n\t\t\t\tassertEquals(\"Total length is wrong\", totalLength, ResidueRange.calcLength(ranges));\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tResidueRange.calcLength(ranges); // should fail\n\t\t\t\t\tfail(\"Lengths should be undefined\");\n\t\t\t\t} catch (IllegalArgumentException e) {}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testIterator() throws IOException, StructureException {\n\t\tString pdbId = \"2eke\";\n\t\tString[] expected = new String[] {\"C_1023\", \"C_1024\", \"C_1025\", \"C_1026\", \"C_1027\", \"C_1028\", \"C_1029\", \"C_1030\", \"C_1031\", \"C_1032\", \"C_1033\", \"C_1034\", \"C_1035\", \"C_1036\", \"C_1037\", \"C_1038\", \"C_1039\", \"C_1040\", \"C_1041\", \"C_1042\", \"C_1043\", \"C_1044\", \"C_1045\", \"C_1046\", \"C_1047\", \"C_1048\", \"C_1049\", \"C_1050\", \"C_1051\", \"C_1052\", \"C_1053\", \"C_1054\", \"C_1055\", \"C_1056\", \"C_1057\", \"C_1058\", \"C_1059\", \"C_1060\", \"C_1061\", \"C_1062\", \"C_1063\"};\n\t\tResidueRange rr = ResidueRange.parse(\"C_1023-1063\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = rr.iterator(map);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMultiIterator() throws IOException, StructureException {\n\t\tString pdbId = \"1qdm\";\n\t\tString[] expected = new String[] {\"A_3S\", \"A_4S\", \"A_5S\", \"A_6S\", \"A_7S\", \"A_8S\", \"A_9S\", \"A_10S\", \"A_11S\", \"A_12S\", \"A_13S\", \"A_14S\", \"A_15S\", \"A_16S\", \"A_17S\", \"A_18S\", \"A_19S\", \"A_20S\", \"A_21S\", \"A_22S\", \"A_23S\", \"A_24S\", \"A_25S\", \"A_26S\", \"A_27S\", \"A_28S\", \"A_29S\", \"A_30S\", \"A_31S\", \"A_32S\", \"A_33S\", \"A_34S\", \"A_35S\", \"A_36S\", \"A_37S\", \"A_65S\", \"A_66S\", \"A_67S\", \"A_68S\", \"A_69S\", \"A_70S\", \"A_71S\", \"A_72S\", \"A_73S\", \"A_74S\", \"A_75S\", \"A_76S\", \"A_77S\", \"A_78S\", \"A_79S\", \"A_80S\", \"A_81S\", \"A_82S\", \"A_83S\", \"A_84S\", \"A_85S\", \"A_86S\", \"A_87S\", \"A_88S\", \"A_89S\", \"A_90S\", \"A_91S\", \"A_92S\", \"A_93S\", \"A_94S\", \"A_95S\", \"A_96S\", \"A_97S\", \"A_98S\", \"A_99S\"};\n\t\tList<ResidueRange> rrs = ResidueRange.parseMultiple(\"A_3S-37S,A_65S-99S\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = ResidueRange.multiIterator(map, rrs);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String)}.\n\t */\n\t@Test\n\tpublic void testParseAndEqual() {\n\n\t\tString pdbId1 = \"2eke\";\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(null, list1.get(0).getLength());\n\t\tassertEquals(null, list1.get(1).getLength());\n\n\t\tString pdbId = \"1qdm\";\n\t\tString string2 = \"A_3S-37S,A_65S-99S\";\n\t\tList<ResidueRange> list2 = ResidueRange.parseMultiple(string2);\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 3, 'S'), new ResidueNumber(\"A\", 37, 'S'), null), list2.get(0));\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 65, 'S'), new ResidueNumber(\"A\", 99, 'S'), null), list2.get(1));\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String, NavigableMap)}.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testParseAndEqualWithLengths() throws IOException, StructureException {\n\n\t\tAtomPositionMap map;\n\t\t\n\t\tString pdbId1 = \"2eke\";\n\t\tmap = new AtomPositionMap(cache.getAtoms(pdbId1));\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(1063-1023, list1.get(0).getLength().intValue()); // no insertion codes\n\t\tassertEquals(1084-1064, list1.get(1).getLength().intValue());\n\n\t\tlist1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\t\n\t}\n\t\n\t@Test\n\tpublic void testLooksLikeRange() {\n\t\tString[] yes = new String[] {\"A_\", \"A:\", \"A.\", \"ABC:\", \"abc:\", \"A_5-100\", \"A_5-100S\", \"A_5S-100\", \"A_5S-100S\", \"A_-5-100\", \"A_-5--100\", \"A_-5S--100S\", \"ABC:-5--200S\"};\n\t\tfor (String s : yes) {\n\t\t\tassertTrue(s + \" was not considered a valid range format\", ResidueRange.looksLikeRange(s));\n\t\t}\n\t\tString[] no = new String[] {\"A\", \"A1\", \"A_1\", \"A_1-\", \"A_1S-\", \"A_1-100-\", \"A_-10-1000_\", \"\", \"3A:1-100\"};\n\t\tfor (String s : no) {\n\t\t\tassertFalse(s + \" was considered a valid range format\", ResidueRange.looksLikeRange(s));\n\t\t}\n\t}\n\t\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport static org.junit.Assert.*;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NavigableMap;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * A unit test for {@link ResidueRange}.\n * @author dmyerstu\n *\n */\npublic class ResidueRangeTest {\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache();\n\t\tcache.setFetchFileEvenIfObsolete(true);\n\t}\n\n\t@Test\n\tpublic void testWholeChainBasic() {\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRange.parse(range);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertNull(\"Start residue should be null\", rr.getStart());\n\t\tassertNull(\"End residue should be null\", rr.getEnd());\n\t}\n\n\t@Test\n\tpublic void testWholeChainWithMap() throws IOException, StructureException {\n\t\tString pdbId = \"1cph\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRange.parse(range, map);\n\t\tResidueNumber start = new ResidueNumber(\"B\", 1, null);\n\t\tResidueNumber end = new ResidueNumber(\"B\", 30, null);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertEquals(\"Wrong start\", start, rr.getStart());\n\t\tassertEquals(\"Wrong end\", end, rr.getEnd());\n\t}\n\t\n\t/**\n\t * Tests creating ResidueRanges and calculating their lengths.\n\t */\n\t@Test\n\tpublic void testBasic() {\n\t\tString[] ids = new String[] {\"1w0p\", \"3qq3\", \"3chc\", \"2ei7\"}; // more: , \"2qbr\"\n\t\tString[] chains = new String[] {\"A\", \"B\", \"A\", \"L\"};\n\t\tResidueNumber[] starts = new ResidueNumber[] {new ResidueNumber(\"A\", 5, ' '), new ResidueNumber(\"B\", 10, 's'), new ResidueNumber(\"A\", 15, 'm'), new ResidueNumber(\"L\", 44, ' ')};\n\t\tResidueNumber[] ends = new ResidueNumber[] {new ResidueNumber(\"A\", 117, ' '), new ResidueNumber(\"B\", 200, 's'), new ResidueNumber(\"A\", 464, 'q'), new ResidueNumber(\"L\", 254, 't')};\n\t\tInteger[] lengths = new Integer[] {117-5, 200-10, 111, null};\n\t\tint totalLength = 0;\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>(ids.length);\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tResidueRange rr = new ResidueRange(chains[i], starts[i], ends[i], lengths[i]);\n\t\t\tassertEquals(\"The chain is incorrect\", chains[i], rr.getChainId());\n\t\t\tassertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n\t\t\tassertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n\t\t\tassertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n\t\t\tranges.add(rr);\n\t\t\tif (lengths[i] != null) {\n\t\t\t\ttotalLength += lengths[i];\n\t\t\t\tassertEquals(\"Total length is wrong\", totalLength, ResidueRange.calcLength(ranges));\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tResidueRange.calcLength(ranges); // should fail\n\t\t\t\t\tfail(\"Lengths should be undefined\");\n\t\t\t\t} catch (IllegalArgumentException e) {}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testIterator() throws IOException, StructureException {\n\t\tString pdbId = \"2eke\";\n\t\tString[] expected = new String[] {\"C_1023\", \"C_1024\", \"C_1025\", \"C_1026\", \"C_1027\", \"C_1028\", \"C_1029\", \"C_1030\", \"C_1031\", \"C_1032\", \"C_1033\", \"C_1034\", \"C_1035\", \"C_1036\", \"C_1037\", \"C_1038\", \"C_1039\", \"C_1040\", \"C_1041\", \"C_1042\", \"C_1043\", \"C_1044\", \"C_1045\", \"C_1046\", \"C_1047\", \"C_1048\", \"C_1049\", \"C_1050\", \"C_1051\", \"C_1052\", \"C_1053\", \"C_1054\", \"C_1055\", \"C_1056\", \"C_1057\", \"C_1058\", \"C_1059\", \"C_1060\", \"C_1061\", \"C_1062\", \"C_1063\"};\n\t\tResidueRange rr = ResidueRange.parse(\"C_1023-1063\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = rr.iterator(map);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testMultiIterator() throws IOException, StructureException {\n\t\tString pdbId = \"1qdm\";\n\t\tString[] expected = new String[] {\"A_3S\", \"A_4S\", \"A_5S\", \"A_6S\", \"A_7S\", \"A_8S\", \"A_9S\", \"A_10S\", \"A_11S\", \"A_12S\", \"A_13S\", \"A_14S\", \"A_15S\", \"A_16S\", \"A_17S\", \"A_18S\", \"A_19S\", \"A_20S\", \"A_21S\", \"A_22S\", \"A_23S\", \"A_24S\", \"A_25S\", \"A_26S\", \"A_27S\", \"A_28S\", \"A_29S\", \"A_30S\", \"A_31S\", \"A_32S\", \"A_33S\", \"A_34S\", \"A_35S\", \"A_36S\", \"A_37S\", \"A_65S\", \"A_66S\", \"A_67S\", \"A_68S\", \"A_69S\", \"A_70S\", \"A_71S\", \"A_72S\", \"A_73S\", \"A_74S\", \"A_75S\", \"A_76S\", \"A_77S\", \"A_78S\", \"A_79S\", \"A_80S\", \"A_81S\", \"A_82S\", \"A_83S\", \"A_84S\", \"A_85S\", \"A_86S\", \"A_87S\", \"A_88S\", \"A_89S\", \"A_90S\", \"A_91S\", \"A_92S\", \"A_93S\", \"A_94S\", \"A_95S\", \"A_96S\", \"A_97S\", \"A_98S\", \"A_99S\"};\n\t\tList<ResidueRange> rrs = ResidueRange.parseMultiple(\"A_3S-37S,A_65S-99S\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = ResidueRange.multiIterator(map, rrs);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String)}.\n\t */\n\t@Test\n\tpublic void testParseAndEqual() {\n\n\t\tString pdbId1 = \"2eke\";\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(null, list1.get(0).getLength());\n\t\tassertEquals(null, list1.get(1).getLength());\n\n\t\tString pdbId = \"1qdm\";\n\t\tString string2 = \"A_3S-37S,A_65S-99S\";\n\t\tList<ResidueRange> list2 = ResidueRange.parseMultiple(string2);\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 3, 'S'), new ResidueNumber(\"A\", 37, 'S'), null), list2.get(0));\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 65, 'S'), new ResidueNumber(\"A\", 99, 'S'), null), list2.get(1));\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String, NavigableMap)}.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testParseAndEqualWithLengths() throws IOException, StructureException {\n\n\t\tAtomPositionMap map;\n\t\t\n\t\tString pdbId1 = \"2eke\";\n\t\tmap = new AtomPositionMap(cache.getAtoms(pdbId1));\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(1063-1023, list1.get(0).getLength().intValue()); // no insertion codes\n\t\tassertEquals(1084-1064, list1.get(1).getLength().intValue());\n\n\t\tlist1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\t\n\t}\n\t\n\t@Test\n\tpublic void testLooksLikeRange() {\n\t\tString[] yes = new String[] {\"A_\", \"A:\", \"ABC:\", \"abc:\", \"A_5-100\", \"A_5-100S\", \"A_5S-100\", \"A_5S-100S\", \"A_-5-100\", \"A_-5--100\", \"A_-5S--100S\", \"ABC:-5--200S\"};\n\t\tfor (String s : yes) {\n\t\t\tassertTrue(s + \" was not considered a valid range format\", ResidueRange.looksLikeRange(s));\n\t\t}\n\t\tString[] no = new String[] {\"A\", \"A1\", \"A_1\", \"A_1-\", \"A_1S-\", \"A_1-100-\", \"A_-10-1000_\", \"\", \"3A:1-100\"};\n\t\tfor (String s : no) {\n\t\t\tassertFalse(s + \" was considered a valid range format\", ResidueRange.looksLikeRange(s));\n\t\t}\n\t}\n\t\n}\n","commitMessage":"Don't allow a period (.) as a range specifier. Really we should reserve\nperiods as chain specifiers, and allow either _ or : as range\nspecifiers.","test_commitMessage":"Don't allow a period (.) as a range specifier. Really we should reserve\nperiods as chain specifiers, and allow either _ or : as range\nspecifiers.","allZero":false}