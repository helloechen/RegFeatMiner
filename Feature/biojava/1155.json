{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/util/MultipleAlignmentTools.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/util/TestMultipleAlignmentTools.java","prod_time":"2024-08-30 21:40:00","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":7,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":1,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"57a487df1836052fa618182e91c8d3e83aa14c21","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.MultipleSequenceAlignment;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.phylo.DistanceMatrixCalculator;\nimport org.biojava.nbio.phylo.TreeConstructor;\nimport org.biojava.nbio.phylo.TreeConstructorType;\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\n\n/**\n * Utility functions for working with {@link MultipleAlignment}.\n * <p>\n * Supported functions:\n * <ul>\n * <li>Obtain the alignment as sequence strings\n * <li>Map from sequence alignment position to structure Atom\n * <li>Map from sequence alignment position to Block number\n * <li>Transform the aligned Atoms of a MultipleAlignment\n * <li>Get all the core alignment positions of the alignment\n * <li>Calculate the average residue distance of all aligned positions\n * <li>Sort Blocks in a MultipleAlignment by a specified row\n * <li>Convert a MultipleAlignment to a MultipleSequenceAlignment\n * </ul>\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentTools {\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This\n\t * method creates a sequence alignment where aligned residues are in\n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @param mapSeqToStruct\n\t *            provides a link from the sequence alignment position to the\n\t *            structure alignment position. Specially designed for the GUI.\n\t *            Has to be initialized previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(\n\t\t\tMultipleAlignment alignment, final List<Integer> mapSeqToStruct) {\n\n\t\t// Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<>();\n\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\talnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t// Initialize helper variables in constucting the sequence alignment\n\t\tList<SortedSet<Integer>> freePool = new ArrayList<>();\n\t\tList<SortedSet<Integer>> blockStarts = new ArrayList<>();\n\t\tList<List<Integer>> aligned = new ArrayList<>();\n\n\t\t// Generate freePool residues from the ones not aligned\n\t\tfor (int i = 0; i < alignment.size(); i++) {\n\t\t\tList<Integer> residues = new ArrayList<>();\n\t\t\tfreePool.add(new TreeSet<Integer>());\n\t\t\tblockStarts.add(new TreeSet<Integer>());\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()) {\n\t\t\t\tfor (Block b : bs.getBlocks()) {\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (int l = 0; l < b.length(); l++) {\n\t\t\t\t\t\tInteger residue = b.getAlignRes().get(i).get(l);\n\t\t\t\t\t\tif (residue != null) {\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t\tblockStarts.get(i).add(residue);\n\t\t\t\t\t\t\tresidues.add(residue);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\taligned.add(residues);\n\t\t}\n\t\t// Add any residue not aligned to the free pool for every structure\n\t\tfor (int i = 0; i < alignment.size(); i++) {\n\t\t\tfor (int k = 0; k < atoms.get(i).length; k++) {\n\t\t\t\tif (!aligned.get(i).contains(k))\n\t\t\t\t\tfreePool.get(i).add(k);\n\t\t\t}\n\t\t}\n\n\t\tfor (int b = 0; b < alignment.getBlocks().size(); b++) {\n\t\t\tif (b != 0) {\n\t\t\t\t// Add a gap to all structures to separate visually the Blocks\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\t\t\talnSequences.set(str, alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); // means unaligned position\n\t\t\t}\n\t\t\t// Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t// Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos = 0; pos < alignment.getBlocks().get(b).length(); pos++) {\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true; // true if consecutive with the previous\n\t\t\t\twhile (gaps) {\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t// Loop through all the structures\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t// If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1) {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = StructureTools\n\t\t\t\t\t\t\t\t\t\t.get1LetterCode(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tint nextPos = previousPos[str] + 1;\n\t\t\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\t\t\tif (freePool.get(str).contains(nextPos)) {\n\t\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = Character\n\t\t\t\t\t\t\t\t\t\t\t.toLowerCase(aa);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\t} else if (nextPos == residue) {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = StructureTools\n\t\t\t\t\t\t\t\t\t\t.get1LetterCode(group);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// This means non-consecutive\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}// End all structure analysis\n\n\t\t\t\t\tif (gaps) {\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t// It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str] + 1];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t\talnSequences\n\t\t\t\t\t\t\t\t\t\t.set(str,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.get(str)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.concat(String.valueOf(Character\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.toLowerCase(aa))) );\n\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Insert a gap otherwise\n\t\t\t\t\t\t\t\talnSequences.set(str, alnSequences.get(str)\n\t\t\t\t\t\t\t\t\t\t.concat(\"-\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned position\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add provisional and update the indices\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])));\n\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tif (alignment.getBlocks().get(b).getAlignRes()\n\t\t\t\t\t\t\t\t\t\t.get(str).get(pos) == null) {\n\t\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpreviousPos[str] = alignment.getBlocks()\n\t\t\t\t\t\t\t\t\t\t\t.get(b).getAlignRes().get(str)\n\t\t\t\t\t\t\t\t\t\t\t.get(pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos); // alignment index\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // All positions in the Block considered so far\n\n\t\t\t// Calculate the index of the next Block for every structure\n\t\t\tint[] blockEnds = new int[alignment.size()];\n\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\tfor (int res : blockStarts.get(str)) {\n\t\t\t\t\tif (previousPos[str] > res)\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\telse {\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the unaligned residues in between Blocks (lowercase)\n\t\t\tboolean allGaps = false; // true means no more residues to add\n\t\t\twhile (!allGaps) {\n\t\t\t\tallGaps = true;\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\tif (previousPos[str] + 1 < blockEnds[str]) {\n\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str] + 1];\n\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\tchar letter = StructureTools.get1LetterCode(group);\n\n\t\t\t\t\t\tprovisionalChar[str] = Character.toLowerCase(letter);\n\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\tallGaps = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t}\n\t\t\t\tif (!allGaps) {\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])) );\n\t\t\t\t\t}\n\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This\n\t * method creates a sequence alignment where aligned residues are in\n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(MultipleAlignment msa) {\n\t\treturn getSequenceAlignment(msa, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an\n\t * alignment. This method creates a sequence alignment where all residues\n\t * are in uppercase and a residue alone with gaps in all the other\n\t * structures represents unaligned residues. Because of this latter\n\t * constraint only the residues within the Blocks are represented, for a\n\t * more compact alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps between blocks are omitted, while gaps within blocks are\n\t * represented by '-'. Separation between different Blocks is indicated by a\n\t * gap in all positions, meaning that there is something unaligned\n\t * inbetween.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @param mapSeqToStruct\n\t *            provides a link from the sequence alignment position to the\n\t *            structure alignment position. Specially designed for the GUI.\n\t *            Has to be initialized previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t// Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<>();\n\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\talnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t// Loop through all the alignment Blocks in the order given\n\t\tfor (int b = 0; b < alignment.getBlocks().size(); b++) {\n\t\t\tif (b != 0) {\n\t\t\t\t// Add a gap to all structures to separate Blocks\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\t\t\talnSequences.set(str, alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); // means unaligned position\n\t\t\t}\n\n\t\t\t// Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t// Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos = 0; pos < alignment.getBlocks().get(b).length(); pos++) {\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;\n\t\t\t\twhile (gaps) {\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t// Loop through all the structures\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t// If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1) {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse if (previousPos[str] + 1 == residue) {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}// End all structures analysis\n\n\t\t\t\t\tif (gaps) {\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t// It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tfor (int s2 = 0; s2 < alignment.size(); s2++) {\n\t\t\t\t\t\t\t\t\tif (str == s2) {\n\t\t\t\t\t\t\t\t\t\tint next = previousPos[str] + 1;\n\t\t\t\t\t\t\t\t\t\tAtom a = atoms.get(s2)[next];\n\t\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\t\tchar aa = StructureTools\n\t\t\t\t\t\t\t\t\t\t\t\t.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\t\t\t\ts2,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences.get(s2).concat(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString.valueOf(aa)) );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences.get(s2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.concat(\"-\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned\n\t\t\t\t\t\t\t\tpreviousPos[str] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Append the provisional and update the indices\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])) );\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tpreviousPos[str] = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an\n\t * alignment. This method creates a sequence alignment where all residues\n\t * are in uppercase and a residue alone with gaps in all the other\n\t * structures represents unaligned residues. Because of this latter\n\t * constraint only the residues within the Blocks are represented, for a\n\t * more compact alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps between blocks are omitted, while gaps within blocks are\n\t * represented by '-'. Separation between different Blocks is indicated by a\n\t * gap in all positions, meaning that there is something unaligned\n\t * inbetween.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(MultipleAlignment ma) {\n\t\treturn getBlockSequenceAlignment(ma, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Returns the Atom of the specified structure that is aligned in the\n\t * sequence alignment position specified.\n\t *\n\t * @param multAln\n\t *            the MultipleAlignment object from where the sequence alignment\n\t *            has been generated\n\t * @param mapSeqToStruct\n\t *            the mapping between sequence and structure generated with the\n\t *            sequence alignment\n\t * @param str\n\t *            the structure index of the alignment (row)\n\t * @param sequencePos\n\t *            the sequence alignment position (column)\n\t * @return Atom the atom in that position or null if there is a gap\n\t */\n\tpublic static Atom getAtomForSequencePosition(MultipleAlignment msa,\n\t\t\tList<Integer> mapSeqToStruct, int str, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\n\t\t// Check if the position selected is an aligned position\n\t\tif (seqPos == -1)\n\t\t\treturn null;\n\t\telse {\n\t\t\tAtom a = null;\n\t\t\t// Calculate the corresponding structure position\n\t\t\tint sum = 0;\n\t\t\tfor (Block b : msa.getBlocks()) {\n\t\t\t\tif (sum + b.length() <= seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (Integer p : b.getAlignRes().get(str)) {\n\t\t\t\t\t\tif (sum == seqPos) {\n\t\t\t\t\t\t\tif (p != null) {\n\t\t\t\t\t\t\t\ta = msa.getAtomArrays().get(str)[p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the block number of a specified position in the sequence\n\t * alignment, given the mapping from structure to function.\n\t *\n\t * @param multAln\n\t *            the MultipleAlignment object from where the sequence alignment\n\t *            has been generated.\n\t * @param mapSeqToStruct\n\t *            the mapping between sequence and structure generated with the\n\t *            sequence alignment\n\t * @param sequencePos\n\t *            the position in the sequence alignment (column)\n\t * @return int the block index, or -1 if the position is not aligned\n\t */\n\tpublic static int getBlockForSequencePosition(MultipleAlignment multAln,\n\t\t\tList<Integer> mapSeqToStruct, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\t\t// Check if the position selected is an aligned position\n\t\tif (seqPos == -1)\n\t\t\treturn -1;\n\t\telse {\n\t\t\t// Calculate the corresponding block (by iterating all Blocks)\n\t\t\tint sum = 0;\n\t\t\tint block = 0;\n\t\t\tfor (Block b : multAln.getBlocks()) {\n\t\t\t\tif (sum + b.length() <= seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tblock++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn block;\n\t\t}\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from\n\t * each residue to all other residues aligned with it.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return Matrix containing all average residue distances\n\t */\n\tpublic static Matrix getAverageResidueDistances(MultipleAlignment msa) {\n\t\tList<Atom[]> transformed = transformAtoms(msa);\n\t\treturn getAverageResidueDistances(transformed);\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from\n\t * each residue to all other residues aligned with it.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            List of Atom arrays containing only the aligned atoms of each\n\t *            structure, or null if there is a gap.\n\t * @return Matrix containing all average residue distances. Entry -1 means\n\t *         there is a gap in the position.\n\t */\n\tpublic static Matrix getAverageResidueDistances(List<Atom[]> transformed) {\n\n\t\tint size = transformed.size();\n\t\tint length = transformed.get(0).length;\n\t\tMatrix resDist = new Matrix(size, length, -1);\n\n\t\t// Calculate the average residue distances\n\t\tfor (int r1 = 0; r1 < size; r1++) {\n\t\t\tfor (int c = 0; c < transformed.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif (refAtom == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (int r2 = r1 + 1; r2 < size; r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\n\t\t\t\t\t\tif (resDist.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r1, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r1, c, resDist.get(r1, c) + distance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (resDist.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r2, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r2, c, resDist.get(r2, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int c = 0; c < length; c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (resDist.get(r, c) != -1)\n\t\t\t\t\tnonNullRes++;\n\t\t\t}\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (resDist.get(r, c) != -1) {\n\t\t\t\t\tresDist.set(r, c, resDist.get(r, c) / nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resDist;\n\t}\n\n\t/**\n\t * Transforms atoms according to the superposition stored in the alignment.\n\t * <p>\n\t * For each structure in the alignment, returns an atom for each\n\t * representative atom in the aligned columns, omitting unaligned residues\n\t * (i.e. an array of length <tt>alignment.length()</tt> ).\n\t * <p>\n\t * All blocks are concatenated together, so Atoms may not appear in the same\n\t * order as in their parent structure. If the alignment blocks contain null\n\t * residues (gaps), then the returned array will also contain null Atoms in\n\t * the same positions.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return List of Atom arrays of only the aligned atoms of every structure\n\t *         (null Atom if a gap position)\n\t */\n\tpublic static List<Atom[]> transformAtoms(MultipleAlignment alignment) {\n\t\tif (alignment.getEnsemble() == null) {\n\t\t\tthrow new NullPointerException(\"No ensemble set for this alignment\");\n\t\t}\n\n\t\tList<Atom[]> atomArrays = alignment.getAtomArrays();\n\t\tList<Atom[]> transformed = new ArrayList<>(atomArrays.size());\n\n\t\t// Loop through structures\n\t\tfor (int i = 0; i < atomArrays.size(); i++) {\n\n\t\t\tMatrix4d transform = null;\n\t\t\tAtom[] curr = atomArrays.get(i); // all CA atoms from structure\n\n\t\t\t// Concatenated list of all blocks for this structure\n\t\t\tAtom[] transformedAtoms = new Atom[alignment.length()];\n\t\t\tint transformedAtomsLength = 0;\n\n\t\t\t// Each blockset gets transformed independently\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()) {\n\n\t\t\t\tAtom[] blocksetAtoms = new Atom[bs.length()];\n\t\t\t\tint blockPos = 0;\n\n\t\t\t\tfor (Block blk : bs.getBlocks()) {\n\t\t\t\t\tif (blk.size() != atomArrays.size()) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\t\t\"Mismatched block size. Expected %d \"\n\t\t\t\t\t\t\t\t\t\t+ \"structures, found %d.\",\n\t\t\t\t\t\t\t\tatomArrays.size(), blk.size()));\n\t\t\t\t\t}\n\t\t\t\t\t// Extract aligned atoms\n\t\t\t\t\tfor (int j = 0; j < blk.length(); j++) {\n\t\t\t\t\t\tInteger alignedPos = blk.getAlignRes().get(i).get(j);\n\t\t\t\t\t\tif (alignedPos != null) {\n\t\t\t\t\t\t\tblocksetAtoms[blockPos] = (Atom) curr[alignedPos]\n\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblockPos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Transform according to the blockset or alignment matrix\n\t\t\t\tMatrix4d blockTrans = null;\n\t\t\t\tif (bs.getTransformations() != null)\n\t\t\t\t\tblockTrans = bs.getTransformations().get(i);\n\t\t\t\tif (blockTrans == null) {\n\t\t\t\t\tblockTrans = transform;\n\t\t\t\t}\n\n\t\t\t\tfor (Atom a : blocksetAtoms) {\n\t\t\t\t\tif (a != null)\n\t\t\t\t\t\tCalc.transform(a, blockTrans);\n\t\t\t\t\ttransformedAtoms[transformedAtomsLength] = a;\n\t\t\t\t\ttransformedAtomsLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (transformedAtomsLength == alignment.length());\n\n\t\t\ttransformed.add(transformedAtoms);\n\t\t}\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Calculate a List of alignment indicies that correspond to the core of a\n\t * Block, which means that all structures have a residue in that position.\n\t *\n\t * @param block\n\t *            alignment Block\n\t * @return List of positions in the core of the alignment\n\t */\n\tpublic static List<Integer> getCorePositions(Block block) {\n\n\t\tList<Integer> corePositions = new ArrayList<>();\n\n\t\tfor (int col = 0; col < block.length(); col++) {\n\t\t\tboolean core = true;\n\t\t\tfor (int str = 0; str < block.size(); str++) {\n\t\t\t\tif (block.getAlignRes().get(str).get(col) == null) {\n\t\t\t\t\tcore = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (core)\n\t\t\t\tcorePositions.add(col);\n\t\t}\n\t\treturn corePositions;\n\t}\n\n\t/**\n\t * Sort blocks so that the specified row is in sequential order. The sort\n\t * happens in place.\n\t *\n\t * @param blocks\n\t *            List of blocks\n\t * @param sortedIndex\n\t *            Index of the row to be sorted\n\t */\n\tpublic static void sortBlocks(List<Block> blocks, final int sortedIndex) {\n\t\tCollections.sort(blocks, new Comparator<Block>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Block o1, Block o2) {\n\t\t\t\t// Compare the first non-null residue of each block\n\t\t\t\tList<Integer> alignres1 = o1.getAlignRes().get(sortedIndex);\n\t\t\t\tList<Integer> alignres2 = o2.getAlignRes().get(sortedIndex);\n\t\t\t\tInteger res1 = null;\n\t\t\t\tInteger res2 = null;\n\t\t\t\tfor (Integer r : alignres1) {\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\tres1 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Integer r : alignres2) {\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\tres2 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn res1.compareTo(res2);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Convert a MultipleAlignment into a MultipleSequenceAlignment of AminoAcid\n\t * residues. This method is only valid for protein structure alignments.\n\t *\n\t * @param msta\n\t *            Multiple Structure Alignment\n\t * @return MultipleSequenceAlignment of protein sequences\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> toProteinMSA(\n\t\t\tMultipleAlignment msta) throws CompoundNotFoundException {\n\n\t\t// Check that the alignment is of protein structures\n\t\tGroup g = msta.getAtomArrays().get(0)[0].getGroup();\n\t\tif (!(g instanceof AminoAcid)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot convert to multiple sequence alignment: \"\n\t\t\t\t\t\t\t+ \"the structures aligned are not proteins\");\n\t\t}\n\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = new MultipleSequenceAlignment<>();\n\n\t\tMap<String, Integer> uniqueID = new HashMap<>();\n\t\tList<String> seqs = getSequenceAlignment(msta);\n\t\tfor (int i = 0; i < msta.size(); i++) {\n\t\t\t// Make sure the identifiers are unique (required by AccessionID)\n\t\t\tString id = msta.getStructureIdentifier(i).toString();\n\t\t\tif (uniqueID.containsKey(id)) {\n\t\t\t\tuniqueID.put(id, uniqueID.get(id) + 1);\n\t\t\t\tid += \"_\" + uniqueID.get(id);\n\t\t\t} else\n\t\t\t\tuniqueID.put(id, 1);\n\n\t\t\tAccessionID acc = new AccessionID(id);\n\t\t\tProteinSequence pseq = new ProteinSequence(seqs.get(i));\n\t\t\tpseq.setAccession(acc);\n\t\t\tmsa.addAlignedSequence(pseq);\n\t\t}\n\t\treturn msa;\n\t}\n\n\tpublic static Structure toMultimodelStructure(MultipleAlignment multAln, List<Atom[]> transformedAtoms) throws StructureException {\n\t\tPDBHeader header = new PDBHeader();\n\t\tString title = multAln.getEnsemble().getAlgorithmName() + \" V.\"\n\t\t\t\t+ multAln.getEnsemble().getVersion() + \" : \";\n\n\t\tfor (StructureIdentifier name : multAln.getEnsemble()\n\t\t\t\t.getStructureIdentifiers()) {\n\t\t\ttitle += name.getIdentifier() + \" \";\n\t\t}\n\t\tStructure artificial = getAlignedStructure(transformedAtoms);\n\n\t\tartificial.setPDBHeader(header);\n\t\theader.setTitle(title);\n\t\treturn artificial;\n\t}\n\n\t/**\n\t * Get an artificial Structure containing a different model for every\n\t * input structure, so that the alignment result can be viewed in Jmol.\n\t * The Atoms have to be rotated beforehand.\n\t *\n\t * @param atomArrays an array of Atoms for every aligned structure\n\t * @return a structure object containing a set of models,\n\t * \t\t\tone for each input array of Atoms.\n\t * @throws StructureException\n\t */\n\tpublic static final Structure getAlignedStructure(List<Atom[]> atomArrays)\n\t\t\tthrows StructureException {\n\n\t\tStructure s = new StructureImpl();\n\t\tfor (int i=0; i<atomArrays.size(); i++){\n\t\t\tList<Chain> model = AlignmentTools.getAlignedModel(atomArrays.get(i));\n\t\t\ts.addModel(model);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Calculate the RMSD matrix of a MultipleAlignment, that is, entry (i,j) of\n\t * the matrix contains the RMSD between structures i and j.\n\t *\n\t * @param msa\n\t *            Multiple Structure Alignment\n\t * @return Matrix of RMSD with size the number of structures squared\n\t */\n\tpublic static Matrix getRMSDMatrix(MultipleAlignment msa) {\n\n\t\tMatrix rmsdMat = new Matrix(msa.size(), msa.size());\n\t\tList<Atom[]> superposed = transformAtoms(msa);\n\n\t\tfor (int i = 0; i < msa.size(); i++) {\n\t\t\tfor (int j = i; j < msa.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\trmsdMat.set(i, j, 0.0);\n\t\t\t\tList<Atom[]> compared = new ArrayList<>();\n\t\t\t\tcompared.add(superposed.get(i));\n\t\t\t\tcompared.add(superposed.get(j));\n\t\t\t\tdouble rmsd = MultipleAlignmentScorer.getRMSD(compared);\n\t\t\t\trmsdMat.set(i, j, rmsd);\n\t\t\t\trmsdMat.set(j, i, rmsd);\n\t\t\t}\n\t\t}\n\t\treturn rmsdMat;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using Kimura\n\t * distances and the Neighbor Joining algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static Phylogeny getKimuraTree(MultipleAlignment msta)\n\t\t\tthrows CompoundNotFoundException, IOException {\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools\n\t\t\t\t.toProteinMSA(msta);\n\t\tBasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.kimuraDistance(msa);\n\t\tPhylogeny tree = TreeConstructor.distanceTree(distmat,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"Kimura Tree\");\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using\n\t * dissimilarity scores (DS), based in SDM Substitution Matrix (ideal for\n\t * distantly related proteins, structure-derived) and the Neighbor Joining\n\t * algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static Phylogeny getHSDMTree(MultipleAlignment msta)\n\t\t\tthrows CompoundNotFoundException, IOException {\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools\n\t\t\t\t.toProteinMSA(msta);\n\t\tBasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.dissimilarityScore(msa, SubstitutionMatrixHelper.getAminoAcidSubstitutionMatrix(\"PRLA000102\"));\n\t\tPhylogeny tree = TreeConstructor.distanceTree(distmat,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"HSDM Tree\");\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using RMSD\n\t * distances and the Neighbor Joining algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static Phylogeny getStructuralTree(MultipleAlignment msta) {\n\t\tdouble[][] rmsdMat = MultipleAlignmentTools.getRMSDMatrix(msta)\n\t\t\t\t.getArray();\n\t\tBasicSymmetricalDistanceMatrix rmsdDist = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.structuralDistance(rmsdMat, 1, 5, 0.4);\n\t\t// Set the identifiers of the matrix\n\t\tMap<String, Integer> alreadySeen = new HashMap<>();\n\t\tfor (int i = 0; i < msta.size(); i++) {\n\t\t\t// Make sure the identifiers are unique\n\t\t\tString id = msta.getStructureIdentifier(i).toString();\n\t\t\tif (alreadySeen.containsKey(id)) {\n\t\t\t\talreadySeen.put(id, alreadySeen.get(id) + 1);\n\t\t\t\tid += \"_\" + alreadySeen.get(id);\n\t\t\t} else\n\t\t\t\talreadySeen.put(id, 1);\n\t\t\trmsdDist.setIdentifier(i, id);\n\t\t}\n\t\tPhylogeny tree = TreeConstructor.distanceTree(rmsdDist,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"Structural Tree\");\n\t\treturn tree;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.MultipleSequenceAlignment;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.phylo.DistanceMatrixCalculator;\nimport org.biojava.nbio.phylo.TreeConstructor;\nimport org.biojava.nbio.phylo.TreeConstructorType;\nimport org.biojava.nbio.structure.AminoAcid;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\n\n/**\n * Utility functions for working with {@link MultipleAlignment}.\n * <p>\n * Supported functions:\n * <ul>\n * <li>Obtain the alignment as sequence strings\n * <li>Map from sequence alignment position to structure Atom\n * <li>Map from sequence alignment position to Block number\n * <li>Transform the aligned Atoms of a MultipleAlignment\n * <li>Get all the core alignment positions of the alignment\n * <li>Calculate the average residue distance of all aligned positions\n * <li>Sort Blocks in a MultipleAlignment by a specified row\n * <li>Convert a MultipleAlignment to a MultipleSequenceAlignment\n * </ul>\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentTools {\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This\n\t * method creates a sequence alignment where aligned residues are in\n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @param mapSeqToStruct\n\t *            provides a link from the sequence alignment position to the\n\t *            structure alignment position. Specially designed for the GUI.\n\t *            Has to be initialized previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(\n\t\t\tMultipleAlignment alignment, final List<Integer> mapSeqToStruct) {\n\n\t\t// Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<>();\n\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\talnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t// Initialize helper variables in constucting the sequence alignment\n\t\tList<SortedSet<Integer>> freePool = new ArrayList<>();\n\t\tList<SortedSet<Integer>> blockStarts = new ArrayList<>();\n\t\tList<List<Integer>> aligned = new ArrayList<>();\n\n\t\t// Generate freePool residues from the ones not aligned\n\t\tfor (int i = 0; i < alignment.size(); i++) {\n\t\t\tList<Integer> residues = new ArrayList<>();\n\t\t\tfreePool.add(new TreeSet<Integer>());\n\t\t\tblockStarts.add(new TreeSet<Integer>());\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()) {\n\t\t\t\tfor (Block b : bs.getBlocks()) {\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (int l = 0; l < b.length(); l++) {\n\t\t\t\t\t\tInteger residue = b.getAlignRes().get(i).get(l);\n\t\t\t\t\t\tif (residue != null) {\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t\tblockStarts.get(i).add(residue);\n\t\t\t\t\t\t\tresidues.add(residue);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\taligned.add(residues);\n\t\t}\n\t\t// Add any residue not aligned to the free pool for every structure\n\t\tfor (int i = 0; i < alignment.size(); i++) {\n\t\t\tfor (int k = 0; k < atoms.get(i).length; k++) {\n\t\t\t\tif (!aligned.get(i).contains(k))\n\t\t\t\t\tfreePool.get(i).add(k);\n\t\t\t}\n\t\t}\n\n\t\tfor (int b = 0; b < alignment.getBlocks().size(); b++) {\n\t\t\tif (b != 0) {\n\t\t\t\t// Add a gap to all structures to separate visually the Blocks\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\t\t\talnSequences.set(str, alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); // means unaligned position\n\t\t\t}\n\t\t\t// Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t// Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos = 0; pos < alignment.getBlocks().get(b).length(); pos++) {\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true; // true if consecutive with the previous\n\t\t\t\twhile (gaps) {\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t// Loop through all the structures\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t// If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1) {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = StructureTools\n\t\t\t\t\t\t\t\t\t\t.get1LetterCode(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tint nextPos = previousPos[str] + 1;\n\t\t\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\t\t\tif (freePool.get(str).contains(nextPos)) {\n\t\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = Character\n\t\t\t\t\t\t\t\t\t\t\t.toLowerCase(aa);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\t} else if (nextPos == residue) {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = StructureTools\n\t\t\t\t\t\t\t\t\t\t.get1LetterCode(group);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// This means non-consecutive\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}// End all structure analysis\n\n\t\t\t\t\tif (gaps) {\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t// It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str] + 1];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t\talnSequences\n\t\t\t\t\t\t\t\t\t\t.set(str,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.get(str)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.concat(String.valueOf(Character\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.toLowerCase(aa))) );\n\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Insert a gap otherwise\n\t\t\t\t\t\t\t\talnSequences.set(str, alnSequences.get(str)\n\t\t\t\t\t\t\t\t\t\t.concat(\"-\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned position\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add provisional and update the indices\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])));\n\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tif (alignment.getBlocks().get(b).getAlignRes()\n\t\t\t\t\t\t\t\t\t\t.get(str).get(pos) == null) {\n\t\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tpreviousPos[str] = alignment.getBlocks()\n\t\t\t\t\t\t\t\t\t\t\t.get(b).getAlignRes().get(str)\n\t\t\t\t\t\t\t\t\t\t\t.get(pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos); // alignment index\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // All positions in the Block considered so far\n\n\t\t\t// Calculate the index of the next Block for every structure\n\t\t\tint[] blockEnds = new int[alignment.size()];\n\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\tfor (int res : blockStarts.get(str)) {\n\t\t\t\t\tif (previousPos[str] > res)\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\telse {\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add the unaligned residues in between Blocks (lowercase)\n\t\t\tboolean allGaps = false; // true means no more residues to add\n\t\t\twhile (!allGaps) {\n\t\t\t\tallGaps = true;\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\tif (previousPos[str] + 1 < blockEnds[str]) {\n\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str] + 1];\n\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\tchar letter = StructureTools.get1LetterCode(group);\n\n\t\t\t\t\t\tprovisionalChar[str] = Character.toLowerCase(letter);\n\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\tallGaps = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t}\n\t\t\t\tif (!allGaps) {\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])) );\n\t\t\t\t\t}\n\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This\n\t * method creates a sequence alignment where aligned residues are in\n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(MultipleAlignment msa) {\n\t\treturn getSequenceAlignment(msa, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an\n\t * alignment. This method creates a sequence alignment where all residues\n\t * are in uppercase and a residue alone with gaps in all the other\n\t * structures represents unaligned residues. Because of this latter\n\t * constraint only the residues within the Blocks are represented, for a\n\t * more compact alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps between blocks are omitted, while gaps within blocks are\n\t * represented by '-'. Separation between different Blocks is indicated by a\n\t * gap in all positions, meaning that there is something unaligned\n\t * inbetween.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @param mapSeqToStruct\n\t *            provides a link from the sequence alignment position to the\n\t *            structure alignment position. Specially designed for the GUI.\n\t *            Has to be initialized previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t// Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<>();\n\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\talnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t// Loop through all the alignment Blocks in the order given\n\t\tfor (int b = 0; b < alignment.getBlocks().size(); b++) {\n\t\t\tif (b != 0) {\n\t\t\t\t// Add a gap to all structures to separate Blocks\n\t\t\t\tfor (int str = 0; str < alignment.size(); str++)\n\t\t\t\t\talnSequences.set(str, alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); // means unaligned position\n\t\t\t}\n\n\t\t\t// Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t// Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos = 0; pos < alignment.getBlocks().get(b).length(); pos++) {\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;\n\t\t\t\twhile (gaps) {\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t// Loop through all the structures\n\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t// If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1) {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\t\t\tprovisionalChar[str] = '-';\n\t\t\t\t\t\t\telse if (previousPos[str] + 1 == residue) {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}// End all structures analysis\n\n\t\t\t\t\tif (gaps) {\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t// It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tfor (int s2 = 0; s2 < alignment.size(); s2++) {\n\t\t\t\t\t\t\t\t\tif (str == s2) {\n\t\t\t\t\t\t\t\t\t\tint next = previousPos[str] + 1;\n\t\t\t\t\t\t\t\t\t\tAtom a = atoms.get(s2)[next];\n\t\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\t\tchar aa = StructureTools\n\t\t\t\t\t\t\t\t\t\t\t\t.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\t\t\t\ts2,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences.get(s2).concat(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tString.valueOf(aa)) );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,\n\t\t\t\t\t\t\t\t\t\t\t\talnSequences.get(s2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.concat(\"-\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapSeqToStruct.add(-1); // unaligned\n\t\t\t\t\t\t\t\tpreviousPos[str] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // Append the provisional and update the indices\n\t\t\t\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\t\t\t\talnSequences.set(\n\t\t\t\t\t\t\t\t\tstr,\n\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\n\t\t\t\t\t\t\t\t\t\t\tString.valueOf(provisionalChar[str])) );\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tpreviousPos[str] = alignment.getBlocks().get(b)\n\t\t\t\t\t\t\t\t\t\t.getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an\n\t * alignment. This method creates a sequence alignment where all residues\n\t * are in uppercase and a residue alone with gaps in all the other\n\t * structures represents unaligned residues. Because of this latter\n\t * constraint only the residues within the Blocks are represented, for a\n\t * more compact alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by\n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n\t * sequential. Gaps between blocks are omitted, while gaps within blocks are\n\t * represented by '-'. Separation between different Blocks is indicated by a\n\t * gap in all positions, meaning that there is something unaligned\n\t * inbetween.\n\t *\n\t * @param alignment\n\t *            input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *         for each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(MultipleAlignment ma) {\n\t\treturn getBlockSequenceAlignment(ma, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Returns the Atom of the specified structure that is aligned in the\n\t * sequence alignment position specified.\n\t *\n\t * @param multAln\n\t *            the MultipleAlignment object from where the sequence alignment\n\t *            has been generated\n\t * @param mapSeqToStruct\n\t *            the mapping between sequence and structure generated with the\n\t *            sequence alignment\n\t * @param str\n\t *            the structure index of the alignment (row)\n\t * @param sequencePos\n\t *            the sequence alignment position (column)\n\t * @return Atom the atom in that position or null if there is a gap\n\t */\n\tpublic static Atom getAtomForSequencePosition(MultipleAlignment msa,\n\t\t\tList<Integer> mapSeqToStruct, int str, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\n\t\t// Check if the position selected is an aligned position\n\t\tif (seqPos == -1)\n\t\t\treturn null;\n\t\telse {\n\t\t\tAtom a = null;\n\t\t\t// Calculate the corresponding structure position\n\t\t\tint sum = 0;\n\t\t\tfor (Block b : msa.getBlocks()) {\n\t\t\t\tif (sum + b.length() <= seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (Integer p : b.getAlignRes().get(str)) {\n\t\t\t\t\t\tif (sum == seqPos) {\n\t\t\t\t\t\t\tif (p != null) {\n\t\t\t\t\t\t\t\ta = msa.getAtomArrays().get(str)[p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the block number of a specified position in the sequence\n\t * alignment, given the mapping from structure to function.\n\t *\n\t * @param multAln\n\t *            the MultipleAlignment object from where the sequence alignment\n\t *            has been generated.\n\t * @param mapSeqToStruct\n\t *            the mapping between sequence and structure generated with the\n\t *            sequence alignment\n\t * @param sequencePos\n\t *            the position in the sequence alignment (column)\n\t * @return int the block index, or -1 if the position is not aligned\n\t */\n\tpublic static int getBlockForSequencePosition(MultipleAlignment multAln,\n\t\t\tList<Integer> mapSeqToStruct, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\t\t// Check if the position selected is an aligned position\n\t\tif (seqPos == -1)\n\t\t\treturn -1;\n\t\telse {\n\t\t\t// Calculate the corresponding block (by iterating all Blocks)\n\t\t\tint sum = 0;\n\t\t\tint block = 0;\n\t\t\tfor (Block b : multAln.getBlocks()) {\n\t\t\t\tif (sum + b.length() <= seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tblock++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn block;\n\t\t}\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from\n\t * each residue to all other residues aligned with it.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return Matrix containing all average residue distances\n\t */\n\tpublic static Matrix getAverageResidueDistances(MultipleAlignment msa) {\n\t\tList<Atom[]> transformed = transformAtoms(msa);\n\t\treturn getAverageResidueDistances(transformed);\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from\n\t * each residue to all other residues aligned with it.\n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n\t * length.\n\t *\n\t * @param transformed\n\t *            List of Atom arrays containing only the aligned atoms of each\n\t *            structure, or null if there is a gap.\n\t * @return Matrix containing all average residue distances. Entry -1 means\n\t *         there is a gap in the position.\n\t */\n\tpublic static Matrix getAverageResidueDistances(List<Atom[]> transformed) {\n\n\t\tint size = transformed.size();\n\t\tint length = transformed.get(0).length;\n\t\tMatrix resDist = new Matrix(size, length, -1);\n\n\t\t// Calculate the average residue distances\n\t\tfor (int r1 = 0; r1 < size; r1++) {\n\t\t\tfor (int c = 0; c < transformed.get(r1).length; c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif (refAtom == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfor (int r2 = r1 + 1; r2 < size; r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif (atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\n\t\t\t\t\t\tif (resDist.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r1, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r1, c, resDist.get(r1, c) + distance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (resDist.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r2, c, 1 + distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r2, c, resDist.get(r2, c) + distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int c = 0; c < length; c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (resDist.get(r, c) != -1)\n\t\t\t\t\tnonNullRes++;\n\t\t\t}\n\t\t\tfor (int r = 0; r < size; r++) {\n\t\t\t\tif (resDist.get(r, c) != -1) {\n\t\t\t\t\tresDist.set(r, c, resDist.get(r, c) / nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resDist;\n\t}\n\n\t/**\n\t * Transforms atoms according to the superposition stored in the alignment.\n\t * <p>\n\t * For each structure in the alignment, returns an atom for each\n\t * representative atom in the aligned columns, omitting unaligned residues\n\t * (i.e. an array of length <tt>alignment.length()</tt> ).\n\t * <p>\n\t * All blocks are concatenated together, so Atoms may not appear in the same\n\t * order as in their parent structure. If the alignment blocks contain null\n\t * residues (gaps), then the returned array will also contain null Atoms in\n\t * the same positions.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return List of Atom arrays of only the aligned atoms of every structure\n\t *         (null Atom if a gap position)\n\t */\n\tpublic static List<Atom[]> transformAtoms(MultipleAlignment alignment) {\n\t\tif (alignment.getEnsemble() == null) {\n\t\t\tthrow new NullPointerException(\"No ensemble set for this alignment\");\n\t\t}\n\n\t\tList<Atom[]> atomArrays = alignment.getAtomArrays();\n\t\tList<Atom[]> transformed = new ArrayList<>(atomArrays.size());\n\n\t\t// Loop through structures\n\t\tfor (int i = 0; i < atomArrays.size(); i++) {\n\n\t\t\tMatrix4d transform = null;\n\t\t\tAtom[] curr = atomArrays.get(i); // all CA atoms from structure\n\n\t\t\t// Concatenated list of all blocks for this structure\n\t\t\tAtom[] transformedAtoms = new Atom[alignment.length()];\n\t\t\tint transformedAtomsLength = 0;\n\n\t\t\t// Each blockset gets transformed independently\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()) {\n\n\t\t\t\tAtom[] blocksetAtoms = new Atom[bs.length()];\n\t\t\t\tint blockPos = 0;\n\n\t\t\t\tfor (Block blk : bs.getBlocks()) {\n\t\t\t\t\tif (blk.size() != atomArrays.size()) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\t\t\"Mismatched block size. Expected %d \"\n\t\t\t\t\t\t\t\t\t\t+ \"structures, found %d.\",\n\t\t\t\t\t\t\t\tatomArrays.size(), blk.size()));\n\t\t\t\t\t}\n\t\t\t\t\t// Extract aligned atoms\n\t\t\t\t\tfor (int j = 0; j < blk.length(); j++) {\n\t\t\t\t\t\tInteger alignedPos = blk.getAlignRes().get(i).get(j);\n\t\t\t\t\t\tif (alignedPos != null) {\n\t\t\t\t\t\t\tblocksetAtoms[blockPos] = (Atom) curr[alignedPos]\n\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblockPos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Transform according to the blockset or alignment matrix\n\t\t\t\tMatrix4d blockTrans = null;\n\t\t\t\tif (bs.getTransformations() != null)\n\t\t\t\t\tblockTrans = bs.getTransformations().get(i);\n\t\t\t\tif (blockTrans == null) {\n\t\t\t\t\tblockTrans = transform;\n\t\t\t\t}\n\n\t\t\t\tfor (Atom a : blocksetAtoms) {\n\t\t\t\t\tif (a != null)\n\t\t\t\t\t\tCalc.transform(a, blockTrans);\n\t\t\t\t\ttransformedAtoms[transformedAtomsLength] = a;\n\t\t\t\t\ttransformedAtomsLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert (transformedAtomsLength == alignment.length());\n\n\t\t\ttransformed.add(transformedAtoms);\n\t\t}\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Calculate a List of alignment indicies that correspond to the core of a\n\t * Block, which means that all structures have a residue in that position.\n\t *\n\t * @param block\n\t *            alignment Block\n\t * @return List of positions in the core of the alignment\n\t */\n\tpublic static List<Integer> getCorePositions(Block block) {\n\n\t\tList<Integer> corePositions = new ArrayList<>();\n\n\t\tfor (int col = 0; col < block.length(); col++) {\n\t\t\tboolean core = true;\n\t\t\tfor (int str = 0; str < block.size(); str++) {\n\t\t\t\tif (block.getAlignRes().get(str).get(col) == null) {\n\t\t\t\t\tcore = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (core)\n\t\t\t\tcorePositions.add(col);\n\t\t}\n\t\treturn corePositions;\n\t}\n\n\t/**\n\t * Sort blocks so that the specified row is in sequential order. The sort\n\t * happens in place.\n\t *\n\t * @param blocks\n\t *            List of blocks\n\t * @param sortedIndex\n\t *            Index of the row to be sorted\n\t */\n\tpublic static void sortBlocks(List<Block> blocks, final int sortedIndex) {\n\t\tCollections.sort(blocks, new Comparator<Block>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Block o1, Block o2) {\n\t\t\t\t// Compare the first non-null residue of each block\n\t\t\t\tList<Integer> alignres1 = o1.getAlignRes().get(sortedIndex);\n\t\t\t\tList<Integer> alignres2 = o2.getAlignRes().get(sortedIndex);\n\t\t\t\tInteger res1 = null;\n\t\t\t\tInteger res2 = null;\n\t\t\t\tfor (Integer r : alignres1) {\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\tres1 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Integer r : alignres2) {\n\t\t\t\t\tif (r != null) {\n\t\t\t\t\t\tres2 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn res1.compareTo(res2);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Convert a MultipleAlignment into a MultipleSequenceAlignment of AminoAcid\n\t * residues. This method is only valid for protein structure alignments.\n\t *\n\t * @param msta\n\t *            Multiple Structure Alignment\n\t * @return MultipleSequenceAlignment of protein sequences\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> toProteinMSA(\n\t\t\tMultipleAlignment msta) throws CompoundNotFoundException {\n\n\t\t// Check that the alignment is of protein structures\n\t\tGroup g = msta.getAtomArrays().get(0)[0].getGroup();\n\t\tif (!(g instanceof AminoAcid)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Cannot convert to multiple sequence alignment: \"\n\t\t\t\t\t\t\t+ \"the structures aligned are not proteins\");\n\t\t}\n\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = new MultipleSequenceAlignment<>();\n\n\t\tMap<String, Integer> uniqueID = new HashMap<>();\n\t\tList<String> seqs = getSequenceAlignment(msta);\n\t\tfor (int i = 0; i < msta.size(); i++) {\n\t\t\t// Make sure the identifiers are unique (required by AccessionID)\n\t\t\tString id = msta.getStructureIdentifier(i).toString();\n\t\t\tif (uniqueID.containsKey(id)) {\n\t\t\t\tuniqueID.put(id, uniqueID.get(id) + 1);\n\t\t\t\tid += \"_\" + uniqueID.get(id);\n\t\t\t} else\n\t\t\t\tuniqueID.put(id, 1);\n\n\t\t\tAccessionID acc = new AccessionID(id);\n\t\t\tProteinSequence pseq = new ProteinSequence(seqs.get(i));\n\t\t\tpseq.setAccession(acc);\n\t\t\tmsa.addAlignedSequence(pseq);\n\t\t}\n\t\treturn msa;\n\t}\n\n\tpublic static Structure toMultimodelStructure(MultipleAlignment multAln, List<Atom[]> transformedAtoms) throws StructureException {\n\t\tPDBHeader header = new PDBHeader();\n\t\tString title = multAln.getEnsemble().getAlgorithmName() + \" V.\"\n\t\t\t\t+ multAln.getEnsemble().getVersion() + \" : \";\n\n\t\tfor (StructureIdentifier name : multAln.getEnsemble()\n\t\t\t\t.getStructureIdentifiers()) {\n\t\t\ttitle += name.getIdentifier() + \" \";\n\t\t}\n\t\tStructure artificial = getAlignedStructure(transformedAtoms);\n\n\t\tartificial.setPDBHeader(header);\n\t\theader.setTitle(title);\n\t\treturn artificial;\n\t}\n\n\t/**\n\t * Get an artificial Structure containing a different model for every\n\t * input structure, so that the alignment result can be viewed in Jmol.\n\t * The Atoms have to be rotated beforehand.\n\t *\n\t * @param atomArrays an array of Atoms for every aligned structure\n\t * @return a structure object containing a set of models,\n\t * \t\t\tone for each input array of Atoms.\n\t * @throws StructureException\n\t */\n\tpublic static final Structure getAlignedStructure(List<Atom[]> atomArrays)\n\t\t\tthrows StructureException {\n\n\t\tStructure s = new StructureImpl();\n\t\tfor (int i=0; i<atomArrays.size(); i++){\n\t\t\tList<Chain> model = AlignmentTools.getAlignedModel(atomArrays.get(i));\n\t\t\ts.addModel(model);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Calculate the RMSD matrix of a MultipleAlignment, that is, entry (i,j) of\n\t * the matrix contains the RMSD between structures i and j.\n\t *\n\t * @param msa\n\t *            Multiple Structure Alignment\n\t * @return Matrix of RMSD with size the number of structures squared\n\t */\n\tpublic static Matrix getRMSDMatrix(MultipleAlignment msa) {\n\n\t\tMatrix rmsdMat = new Matrix(msa.size(), msa.size());\n\t\tList<Atom[]> superposed = transformAtoms(msa);\n\n\t\tfor (int i = 0; i < msa.size(); i++) {\n\t\t\tfor (int j = i; j < msa.size(); j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\trmsdMat.set(i, j, 0.0);\n\t\t\t\tList<Atom[]> compared = new ArrayList<>();\n\t\t\t\tcompared.add(superposed.get(i));\n\t\t\t\tcompared.add(superposed.get(j));\n\t\t\t\tdouble rmsd = MultipleAlignmentScorer.getRMSD(compared);\n\t\t\t\trmsdMat.set(i, j, rmsd);\n\t\t\t\trmsdMat.set(j, i, rmsd);\n\t\t\t}\n\t\t}\n\t\treturn rmsdMat;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using Kimura\n\t * distances and the Neighbor Joining algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static Phylogeny getKimuraTree(MultipleAlignment msta)\n\t\t\tthrows CompoundNotFoundException, IOException {\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools\n\t\t\t\t.toProteinMSA(msta);\n\t\tBasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.kimuraDistance(msa);\n\t\tPhylogeny tree = TreeConstructor.distanceTree(distmat,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"Kimura Tree\");\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using\n\t * dissimilarity scores (DS), based in SDM Substitution Matrix (ideal for\n\t * distantly related proteins, structure-derived) and the Neighbor Joining\n\t * algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t * @throws IOException\n\t */\n\tpublic static Phylogeny getHSDMTree(MultipleAlignment msta)\n\t\t\tthrows CompoundNotFoundException, IOException {\n\t\tMultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools\n\t\t\t\t.toProteinMSA(msta);\n\t\tBasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.dissimilarityScore(msa, SubstitutionMatrixHelper.getAminoAcidSubstitutionMatrix(\"PRLA000102\"));\n\t\tPhylogeny tree = TreeConstructor.distanceTree(distmat,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"HSDM Tree\");\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Calculate a phylogenetic tree of the MultipleAlignment using RMSD\n\t * distances and the Neighbor Joining algorithm from forester.\n\t *\n\t * @param msta\n\t *            MultipleAlignment of protein structures\n\t * @return Phylogeny phylogenetic tree\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static Phylogeny getStructuralTree(MultipleAlignment msta) {\n\t\tdouble[][] rmsdMat = MultipleAlignmentTools.getRMSDMatrix(msta)\n\t\t\t\t.getArray();\n\t\tBasicSymmetricalDistanceMatrix rmsdDist = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator\n\t\t\t\t.structuralDistance(rmsdMat, 1, 5, 0.4);\n\t\t// Set the identifiers of the matrix\n\t\tMap<String, Integer> alreadySeen = new HashMap<>();\n\t\tfor (int i = 0; i < msta.size(); i++) {\n\t\t\t// Make sure the identifiers are unique\n\t\t\tString id = msta.getStructureIdentifier(i).toString();\n\t\t\tif (alreadySeen.containsKey(id)) {\n\t\t\t\talreadySeen.put(id, alreadySeen.get(id) + 1);\n\t\t\t\tid += \"_\" + alreadySeen.get(id);\n\t\t\t} else\n\t\t\t\talreadySeen.put(id, 1);\n\t\t\trmsdDist.setIdentifier(i, id);\n\t\t}\n\t\tPhylogeny tree = TreeConstructor.distanceTree(rmsdDist,\n\t\t\t\tTreeConstructorType.NJ);\n\t\ttree.setName(\"Structural Tree\");\n\t\treturn tree;\n\t}\n\n\t/**\n\t * Convert an MSA into a matrix of equivalent residues.\n\t *\n\t * This concatenates all blocks, meaning that the indices might not be\n\t * sequential.\n\t *\n\t * Indices should be consistent with `msa.getAtomArrays()`.\n\t * @param msa Multiple alignment\n\t * @param coreOnly Include only core (ungapped) columns. Otherwise gaps are\n\t *        represented with null.\n\t * @return\n\t */\n\tpublic static List<List<Integer>> getEquivalentResidues(MultipleAlignment msa, boolean coreOnly) {\n\t\tList<List<Integer>> eqr = new ArrayList<>();\n\t\tfor (int str = 0; str < msa.size(); str++) {\n\t\t\teqr.add(new ArrayList<>());\n\t\t}\n\n\t\tfor(Block block: msa.getBlocks()) {\n\t\t\tList<List<Integer>> aln = block.getAlignRes();\n\t\t\tfor (int col = 0; col < block.length(); col++) {\n\t\t\t\t// skip non-core columns\n\t\t\t\tif(coreOnly) {\n\t\t\t\t\tboolean core = true;\n\t\t\t\t\tfor (int str = 0; str < block.size(); str++) {\n\t\t\t\t\t\tif (aln.get(str).get(col) == null) {\n\t\t\t\t\t\t\tcore = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!core) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// add column to eqr\n\t\t\t\tfor (int str = 0; str < block.size(); str++) {\n\t\t\t\t\teqr.get(str).add(aln.get(str).get(col));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn eqr;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.junit.Test;\n\n/**\n *\n * @author Spencer Bliven\n *\n */\npublic class TestMultipleAlignmentTools {\n\n\t/**\n\t * Override the toString method to give shorter output for errors\n\t * @author blivens\n\t *\n\t */\n\tpublic static class NamedBlock extends BlockImpl {\n\t\tprivate static final long serialVersionUID = 5060618718423340848L;\n\t\tprivate String name;\n\t\tpublic NamedBlock(String name, BlockSet bs) {\n\t\t\tsuper(bs);\n\t\t\tthis.name = name;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Block[%s]\", name);\n\t\t}\n\t}\n\n\n\t@Test\n\tpublic void testSortBlocks() {\n\n\t\t// Sample alignment with blocks out of order\n\n\t\t// Row0: Already sorted\n\t\t// Row1: Unsorted\n\t\t// Row2: Test nulls at start\n\t\t// Row3: Test all nulls\n\t\t// Row4: Test overlapping ranges\n\t\t// Row5: Test only fist element used\n\t\tMultipleAlignment align = new MultipleAlignmentImpl();\n\t\tBlockSet bs = new BlockSetImpl(align);\n\n\t\tBlock one = new NamedBlock(\"1\",bs);\n\t\tone.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( null, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22)\n\t\t\t\t));\n\t\tBlock two = new NamedBlock(\"2\",bs);\n\t\ttwo.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, null, 12),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, 11, 12)\n\t\t\t\t));\n\t\tBlock three = new NamedBlock(\"3\",bs);\n\t\tthree.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, null),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 20, 41, 42)\n\t\t\t\t));\n\t\tBlock four = new NamedBlock(\"4\",bs);\n\t\tfour.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( null, 31, 32),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 30, 51, 52),\n\t\t\t\tArrays.asList( 30, 31, 32)\n\t\t\t\t));\n\n\t\tList<Block> blocks;\n\t\tint index;\n\t\tList<Block> expected;\n\n\t\tindex = 0;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(one,two,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 1;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 2;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 3;\n\t\tblocks = align.getBlocks();\n\t\ttry {\n\t\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\t\tfail(\"Row \"+index+\" should throw NPE\");\n\t\t} catch(NullPointerException e) {}\n\n\t\tindex = 4;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 5;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t}\n\n}\n","changedTest":"","commitMessage":"Fix CE-Symm bug relating to short subunits.\n\n[rcsb/symmetry#118](https://github.com/rcsb/symmetry/issues/118)\n\nThe problem was actually downstream from CE-Symm in the QuatSymmDetector\ncode used for assigning a symmetry group. The code was re-aligning\nsubunits using CE. This fails for short alignments of <15 residues\n(two AFP with default settings). Thus no atoms get aligned and an\nexception was thrown whenever an output format required information\nabout the symmetry group.\n\nThis fix re-uses the original CE-Symm alignment for the symmetry group\ndetection. This might change CE-Symm and QuatSymm results for proteins\nwith small subunits or borderline scores. \n\nChanges:\n- New `SubunitClustererMethod.MANUAL` enum value\n- Improve `SymmetryTools.getQuaternarySymmetry`\n","test_commitMessage":"","allZero":false}