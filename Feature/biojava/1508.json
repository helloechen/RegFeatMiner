{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/align/util/AlignmentTools.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/align/util/AlignmentToolsTest.java","prod_time":"2013-03-21 07:59:58","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":13,"add_classname_line":0,"add_condition_line":3,"add_field_line":0,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"af103df6a709c6bdfb945b3ca007f16789297969","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.bio.structure.align.util;\n\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.Map.Entry;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.ce.CECalculator;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLParser;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/**\n * Some utility methods for analyzing and manipulating AFPChains.\n * \n * @author Spencer Bliven\n *\n */\npublic class AlignmentTools {\n\tpublic static boolean debug = false;\n\n\t/**\n\t * Checks that the alignment given by afpChain is sequential. This means\n\t * that the residue indices of both proteins increase monotonically as\n\t * a function of the alignment position (ie both proteins are sorted).\n\t * \n\t * This will return false for circularly permuted alignments or other\n\t * non-topological alignments. It will also return false for cases where\n\t * the alignment itself is sequential but it is not stored in the afpChain\n\t * in a sorted manner.\n\t * \n\t * Since algorithms which create non-sequential alignments split the\n\t * alignment into multiple blocks, some computational time can be saved\n\t * by only checking block boundaries for sequentiality. Setting\n\t * <tt>checkWithinBlocks</tt> to <tt>true</tt> makes this function slower,\n\t * but detects AFPChains with non-sequential blocks.\n\t * \n\t * Note that this method should give the same results as\n\t * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n\t * relies on the StructureAlignment algorithm correctly setting this\n\t * parameter, which is sadly not always the case.\n\t * \n\t * @param afpChain An alignment\n\t * @param checkWithinBlocks Indicates whether individual blocks should be\n\t * \tchecked for sequentiality\n\t * @return True if the alignment is sequential.\n\t */\n\tpublic static boolean isSequentialAlignment(AFPChain afpChain, boolean checkWithinBlocks) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] alnLen = afpChain.getOptLen();\n\t\tint blocks = afpChain.getBlockNum();\n\t\t\n\t\tif(blocks < 1) return true; //trivial case\n\t\tif ( alnLen[0] < 1) return true;\n\t\t\n\t\t// Check that blocks are sequential\n\t\tif(checkWithinBlocks) {\n\t\t\tfor(int block = 0; block<blocks; block++) {\n\t\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\t\t\t\t\n\t\t\t\tint prevRes1 = optAln[block][0][0];\n\t\t\t\tint prevRes2 = optAln[block][1][0];\n\t\t\t\t\n\t\t\t\tfor(int pos = 1; pos<alnLen[block]; pos++) {\n\t\t\t\t\tint currRes1 = optAln[block][0][pos];\n\t\t\t\t\tint currRes2 = optAln[block][1][pos];\n\t\t\t\t\t\n\t\t\t\t\tif(currRes1 < prevRes1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(currRes2 < prevRes2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprevRes1 = currRes1;\n\t\t\t\t\tprevRes2 = currRes2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that blocks are sequential\n\t\tint prevRes1 = optAln[0][0][alnLen[0]-1];\n\t\tint prevRes2 = optAln[0][1][alnLen[0]-1];\n\t\t\n\t\tfor(int block = 1; block<blocks;block++) {\n\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\n\t\t\tif(optAln[block][0][0]<prevRes1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(optAln[block][1][0]<prevRes2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprevRes1 = optAln[block][0][alnLen[block]-1];\n\t\t\tprevRes2 = optAln[block][1][alnLen[block]-1];\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Creates a Map specifying the alignment as a mapping between residue indices\n\t * of protein 1 and residue indices of protein 2.\n\t * \n\t * <p>For example,<pre>\n\t * 1234\n\t * 5678</pre>\n\t * becomes<pre>\n\t * 1->5\n\t * 2->6\n\t * 3->7\n\t * 4->8</pre>\n\t * \n\t * @param afpChain An alignment\n\t * @return A mapping from aligned residues of protein 1 to their partners in protein 2.\n\t * @throws StructureException If afpChain is not one-to-one\n\t */\n\tpublic static Map<Integer, Integer> alignmentAsMap(AFPChain afpChain) throws StructureException {\n\t\tMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tfor(int block = 0; block < afpChain.getBlockNum(); block++) {\n\t\t\tfor(int pos = 0; pos < optLen[block]; pos++) {\n\t\t\t\tint res1 = optAln[block][0][pos];\n\t\t\t\tint res2 = optAln[block][1][pos];\n\t\t\t\tif(map.containsKey(res1)) {\n\t\t\t\t\tthrow new StructureException(String.format(\"Residue %d aligned to both %d and %d.\", res1,map.get(res1),res2));\n\t\t\t\t}\n\t\t\t\tmap.put(res1,res2);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\t\n\t/**\n\t * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n\t * this returns a function f^k(x)=f(f(...f(x)...)).\n\t * \n\t * @param <T>\n\t * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n\t * @param k The number of times to apply the alignment\n\t * @return A new alignment. If the input function is not automorphic\n\t *  (one-to-one), then some inputs may map to null, indicating that the\n\t *  function is undefined for that input.\n\t */\n\tpublic static <T> Map<T,T> applyAlignment(Map<T, T> alignmentMap, int k) {\n\t\treturn applyAlignment(alignmentMap, new IdentityMap<T>(), k);\n\t}\n\t\n\t/**\n\t * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n\t * this returns a function f^k(x)=f(f(...f(x)...)).\n\t * \n\t * To allow for functions with different domains and codomains, the identity\n\t * function allows converting back in a reasonable way. For instance, if \n\t * alignmentMap represented an alignment between two proteins with different\n\t * numbering schemes, the identity function could calculate the offset\n\t * between residue numbers, eg I(x) = x-offset.\n\t * \n\t * When an identity function is provided, the returned function calculates\n\t * f^k(x) = f(I( f(I( ... f(x) ... )) )).\n\t * \n\t * @param <S>\n\t * @param <T>\n\t * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n\t * @param identity An identity-like function providing the isomorphism between\n\t *  the codomain of alignmentMap (of type <T>) and the domain (type <S>).\n\t * @param k The number of times to apply the alignment\n\t * @return A new alignment. If the input function is not automorphic\n\t *  (one-to-one), then some inputs may map to null, indicating that the\n\t *  function is undefined for that input.\n\t */\n\tpublic static <S,T> Map<S,T> applyAlignment(Map<S, T> alignmentMap, Map<T,S> identity, int k) {\n\t\t\n\t\t// This implementation simply applies the map k times.\n\t\t// If k were large, it would be more efficient to do this recursively,\n\t\t// (eg f^4 = (f^2)^2) but k will usually be small.\n\t\t\n\t\tif(k<0) throw new IllegalArgumentException(\"k must be positive\");\n\t\tif(k==1) {\n\t\t\treturn new HashMap<S,T>(alignmentMap); \n\t\t}\n\t\t// Convert to lists to establish a fixed order\n\t\tList<S> preimage = new ArrayList<S>(alignmentMap.keySet()); // currently unmodified\n\t\tList<S> image = new ArrayList<S>(preimage);\n\t\t\n\t\tfor(int n=1;n<k;n++) {\n\t\t\tint deltasSq = 0;\n\t\t\tint numDeltas = 0;\n\t\t\t// apply alignment\n\t\t\tfor(int i=0;i<image.size();i++) {\n\t\t\t\tS pre = image.get(i);\n\t\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\t\timage.set(i, post);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t\tMap<S, T> imageMap = new HashMap<S,T>(alignmentMap.size());\n\t\t\n\t\t//TODO handle nulls consistently.\n\t\t// assure that all the residues in the domain are valid keys\n\t\t/*\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\timageMap.put(post, null);\n\t\t}\n\t\t*/\n\t\t// now populate with actual values\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\t\n\t\t\t// image is currently f^k-1(x), so take the final step\n\t\t\tS preK1 = image.get(i);\n\t\t\tT postK = (preK1==null?null: alignmentMap.get(preK1));\n\t\t\timageMap.put(pre,postK);\n\t\t\t\n\t\t}\n\t\treturn imageMap;\n\t}\n\t\n\t/**\n\t * Helper for {@link #getSymmetryOrder(Map, Map, int, float)} with a true\n\t * identity function (X->X).\n\t * \n\t * <p>This method should only be used in cases where the two proteins\n\t * aligned have identical numbering, as for self-alignments. See\n\t * {@link #getSymmetryOrder(AFPChain, int, float)} for a way to guess\n\t * the sequential correspondence between two proteins.\n\t * \n\t * @param alignment\n\t * @param maxSymmetry\n\t * @param minimumMetricChange\n\t * @return\n\t */\n\tpublic static int getSymmetryOrder(Map<Integer, Integer> alignment,\n\t\t\tfinal int maxSymmetry, final float minimumMetricChange) {\n\t\treturn getSymmetryOrder(alignment, new IdentityMap<Integer>(), maxSymmetry, minimumMetricChange);\n\t}\n\t/**\n\t * Tries to detect symmetry in an alignment.\n\t * \n     * <p>Conceptually, an alignment is a function f:A->B between two sets of\n     * integers. The function may have simple topology (meaning that if two\n     * elements of A are close, then their images in B will also be close), or\n     * may have more complex topology (such as a circular permutation). This\n     * function checks <i>alignment</i> against a reference function\n     * <i>identity</i>, which should have simple topology. It then tries to \n     * determine the symmetry order of <i>alignment</i> relative to\n     * <i>identity</i>, up to a maximum order of <i>maxSymmetry</i>.\n     * \n\t * \n\t * <p><strong>Details</strong><br/>\n\t * Considers the offset (in number of residues) which a residue moves\n\t * after undergoing <i>n</i> alternating transforms by alignment and\n\t * identity. If <i>n</i> corresponds to the intrinsic order of the alignment,\n\t * this will be small. This algorithm tries increasing values of <i>n</i>\n\t * and looks for abrupt decreases in the root mean squared offset.\n\t * If none are found at <i>n</i><=maxSymmetry, the alignment is reported as\n\t * non-symmetric.\n\t * \n\t * @param alignment The alignment to test for symmetry\n\t * @param identity An alignment with simple topology which approximates\n\t *  the sequential relationship between the two proteins. Should map in the\n\t *  reverse direction from alignment.\n\t * @param maxSymmetry Maximum symmetry to consider. High values increase\n\t *  the calculation time and can lead to overfitting. \n\t * @param minimumMetricChange Percent decrease in root mean squared offsets\n\t *  in order to declare symmetry. 0.4f seems to work well for CeSymm.\n\t * @return The order of symmetry of alignment, or 1 if no order <= \n\t *  maxSymmetry is found.\n\t *  \n\t * @see IdentityMap For a simple identity function\n\t */\n\tpublic static int getSymmetryOrder(Map<Integer, Integer> alignment, Map<Integer,Integer> identity,\n\t\t\tfinal int maxSymmetry, final float minimumMetricChange) {\n\t\tList<Integer> preimage = new ArrayList<Integer>(alignment.keySet()); // currently unmodified\n\t\tList<Integer> image = new ArrayList<Integer>(preimage);\n\t\t\t\t\n\t\tint bestSymmetry = 1;\n\t\tdouble bestMetric = Double.POSITIVE_INFINITY; //lower is better\n\t\tboolean foundSymmetry = false;\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.println(\"Symm\\tPos\\tDelta\");\n\t\t}\n\t\t\n\t\tfor(int n=1;n<=maxSymmetry;n++) {\n\t\t\tint deltasSq = 0;\n\t\t\tint numDeltas = 0;\n\t\t\t// apply alignment\n\t\t\tfor(int i=0;i<image.size();i++) {\n\t\t\t\tInteger pre = image.get(i);\n\t\t\t\tInteger intermediate = (pre==null?null: alignment.get(pre));\n\t\t\t\tInteger post = (intermediate==null?null: identity.get(intermediate));\n\t\t\t\timage.set(i, post);\n\t\t\t\t\n\t\t\t\tif(post != null) {\n\t\t\t\t\tint delta = post-preimage.get(i);\n\t\t\t\t\t\n\t\t\t\t\tdeltasSq += delta*delta;\n\t\t\t\t\tnumDeltas++;\n\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"%d\\t%d\\t%d\\n\",n,preimage.get(i),delta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Metrics: RMS compensates for the trend of smaller numDeltas with higher order\n\t\t\t// Not normalizing by numDeltas favors smaller orders\n\t\t\t\n\t\t\tdouble metric = Math.sqrt((double)deltasSq/numDeltas); // root mean squared distance\n\t\t\t//double metric = Math.sqrt((double)deltasSq); // root squared distance\n\t\t\t\n\t\t\t//System.out.format(\"%d\\t%f\\n\",n,metric);\n\t\t\t\n\t\t\tif(!foundSymmetry && metric < bestMetric * minimumMetricChange) {\n\t\t\t\t// n = 1 is never the best symmetry\n\t\t\t\tif(bestMetric < Double.POSITIVE_INFINITY) {\n\t\t\t\t\tfoundSymmetry = true;\n\t\t\t\t}\n\t\t\t\tbestSymmetry = n;\n\t\t\t\tbestMetric = metric;\n\t\t\t}\n\t\t\t\n\t\t\t// When debugging need to loop over everything. Unneeded in production\n\t\t\tif(!debug && foundSymmetry) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(foundSymmetry) {\n\t\t\treturn bestSymmetry;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\n\t/**\n\t * Guesses the order of symmetry in an alignment\n\t * \n\t * <p>Uses {@link #getSymmetryOrder(Map alignment, Map identity, int, float)}\n\t * to determine the the symmetry order. For the identity alignment, sorts\n\t * the aligned residues of each protein sequentially, then defines the ith\n\t * residues of each protein to be equivalent.\n\t */\n\tpublic static int getSymmetryOrder(AFPChain afpChain, int maxSymmetry, float minimumMetricChange) throws StructureException {\n\t\t// alignment comes from the afpChain alignment\n\t\tMap<Integer,Integer> alignment = AlignmentTools.alignmentAsMap(afpChain);\n\n\t\t// Now construct identity to map aligned residues in sequential order\n\t\tMap<Integer, Integer> identity = guessSequentialAlignment(alignment, true);\n\t\t\n\t\t\n\t\treturn AlignmentTools.getSymmetryOrder(alignment,\n\t\t\t\tidentity,\n\t\t\t\tmaxSymmetry, minimumMetricChange);\n\t}\n\n\t/**\n\t * Takes a potentially non-sequential alignment and guesses a sequential\n\t * version of it. Residues from each structure are sorted sequentially and\n\t * then compared directly.\n\t * \n\t * <p>The results of this method are consistent with what one might expect\n\t * from an identity function, and are therefore useful with\n\t * {@link #getSymmetryOrder(Map, Map identity, int, float)}.\n\t * <ul>\n\t *  <li>Perfect self-alignments will have the same pre-image and image,\n\t *      so will map X->X</li>\n\t *  <li>Gaps and alignment errors will cause errors in the resulting map,\n\t *      but only locally. Errors do not propagate through the whole \n\t *      alignment.</li>\n\t * </ul>\n\t * \n\t * <h4>Example:</h4>\n\t * A non sequential alignment, represented schematically as\n\t * <pre>\n\t * 12456789\n\t * 78912345</pre>\n\t * would result in a map\n\t * <pre>\n\t * 12456789\n\t * 12345789</pre>\n\t * @param afpChain The non-sequential input alignment\n\t * @param inverseAlignment If false, map from structure1 to structure2. If\n\t *  true, generate the inverse of that map.\n\t * @return A mapping from sequential residues of one protein to those of the other\n\t * @throws IllegalArgumentException if the input alignment is not one-to-one.\n\t */\n\tpublic static Map<Integer, Integer> guessSequentialAlignment(\n\t\t\tMap<Integer,Integer> alignment, boolean inverseAlignment) {\n\t\tMap<Integer,Integer> identity = new HashMap<Integer,Integer>();\n\t\t\n\t\tSortedSet<Integer> aligned1 = new TreeSet<Integer>();\n\t\tSortedSet<Integer> aligned2 = new TreeSet<Integer>();\n\t\t\n\t\tfor(Entry<Integer,Integer> pair : alignment.entrySet()) {\n\t\t\taligned1.add(pair.getKey());\n\t\t\tif( !aligned2.add(pair.getValue()) )\n\t\t\t\tthrow new IllegalArgumentException(\"Alignment is not one-to-one for residue \"+pair.getValue()+\" of the second structure.\");\n\t\t}\n\t\t\n\t\tIterator<Integer> it1 = aligned1.iterator();\n\t\tIterator<Integer> it2 = aligned2.iterator();\n\t\twhile(it1.hasNext()) {\n\t\t\tif(inverseAlignment) { // 2->1\n\t\t\t\tidentity.put(it2.next(),it1.next());\n\t\t\t} else { // 1->2\n\t\t\t\tidentity.put(it1.next(),it2.next());\n\t\t\t}\n\t\t}\n\t\treturn identity;\n\t}\n\t\n\t/**\n\t * Retrieves the optimum alignment from an AFPChain and returns it as a\n\t * java collection. The result is indexed in the same way as \n\t * {@link AFPChain#getOptAln()}, but has the correct size().\n\t * <pre>\n\t * List<List<List<Integer>>> aln = getOptAlnAsList(AFPChain afpChain);\n\t * aln.get(blockNum).get(structureNum={0,1}).get(pos)</pre>\n\t * \n\t * @param afpChain\n\t * @return\n\t */\n\tpublic static List<List<List<Integer>>> getOptAlnAsList(AFPChain afpChain) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tList<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum());\n\t\tfor(int blockNum=0;blockNum<afpChain.getBlockNum();blockNum++) {\n\t\t\t//TODO could improve speed an memory by wrapping the arrays with\n\t\t\t// an unmodifiable list, similar to Arrays.asList(...) but with the\n\t\t\t// correct size parameter.\n\t\t\tList<Integer> align1 = new ArrayList<Integer>(optLen[blockNum]);\n\t\t\tList<Integer> align2 = new ArrayList<Integer>(optLen[blockNum]);\n\t\t\tfor(int pos=0;pos<optLen[blockNum];pos++) {\n\t\t\t\talign1.add(optAln[blockNum][0][pos]);\n\t\t\t\talign2.add(optAln[blockNum][1][pos]);\n\t\t\t}\n\t\t\tList<List<Integer>> block = new ArrayList<List<Integer>>(2);\n\t\t\tblock.add(align1);\n\t\t\tblock.add(align2);\n\t\t\tblocks.add(block);\n\t\t}\n\t\t\n\t\treturn blocks;\n\t}\n\n\n\n\t/**\n\t * A Map<K,V> can be viewed as a function from K to V. This class represents\n\t * the identity function. Getting a value results in the value itself.\n\t * \n\t * <p>The class is a bit inconsistent when representing its contents. On\n\t * the one hand, containsKey(key) is true for all objects. However, \n\t * attempting to iterate through the values returns an empty set.\n\t * \n\t * @author Spencer Bliven\n\t *\n\t * @param <K>\n\t * @param <V>\n\t */\n\tpublic static class IdentityMap<K> extends AbstractMap<K,K> {\n\t\tpublic IdentityMap() {}\n\n\t\t/**\n\t\t * @param key\n\t\t * @return the key\n\t\t * @throws ClassCastException if key is not of type K\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic K get(Object key) {\n\t\t\treturn (K)key;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Always returns the empty set\n\t\t */\n\t\t@Override\n\t\tpublic Set<java.util.Map.Entry<K, K>> entrySet() {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean containsKey(Object key) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Fundimentally, an alignment is just a list of aligned residues in each\n\t * protein. This method converts two lists of ResidueNumbers into an\n\t * AFPChain.\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param aligned1 A list of aligned residues from the first protein\n\t * @param aligned2 A list of aligned residues from the second protein.\n\t *  Must be the same length as aligned1.\n\t * @return An AFPChain representing the alignment. Many properties may be\n\t *  null or another default.\n\t * @throws IllegalArgumentException if aligned1 and aligned2 have different\n\t *  lengths\n\t */\n\tpublic static AFPChain createAFPChain(Atom[] ca1, Atom[] ca2,\n\t\t\tResidueNumber[] aligned1, ResidueNumber[] aligned2 ) {\n\t\t//input validation\n\t\tint alnLen = aligned1.length;\n\t\tif(alnLen != aligned2.length) {\n\t\t\tthrow new IllegalArgumentException(\"Alignment lengths are not equal\");\n\t\t}\n\t\t\n\t\tAFPChain a = new AFPChain();\n\t\ta.setName1(ca1[0].getGroup().getChain().getParent().getName());\n\t\ta.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t\n\t\ta.setBlockNum(1);\n\t\ta.setCa1Length(ca1.length);\n\t\ta.setCa2Length(ca2.length);\n\t\t\n\t\ta.setOptLength(alnLen);\n\t\ta.setOptLen(new int[] {alnLen});\n\t\t\n\n\t\tMatrix[] ms = new Matrix[a.getBlockNum()];\n\t\ta.setBlockRotationMatrix(ms);\n\t\tAtom[] blockShiftVector = new Atom[a.getBlockNum()];\n\t\ta.setBlockShiftVector(blockShiftVector);\n\t\t// TODO run superimposer (not required for display)\n\t\t// TODO more properties\n\n\t\t\n\t\tString[][][] pdbAln = new String[1][2][alnLen];\n\t\tfor(int i=0;i<alnLen;i++) {\n\t\t\tpdbAln[0][0][i] = aligned1[i].getChainId()+\":\"+aligned1[i].toString();\n\t\t\tpdbAln[0][1][i] = aligned2[i].getChainId()+\":\"+aligned2[i].toString();\n\t\t}\n\t\t\n\t\ta.setPdbAln(pdbAln);\n\t\t\n\t\t// convert pdbAln to optAln, and fill in some other basic parameters\n\t\tAFPChainXMLParser.rebuildAFPChain(a, ca1, ca2);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * After the alignment changes (optAln, optLen, blockNum, at a minimum),\n\t * many other properties which depend on the superposition will be invalid.\n\t * \n\t * This method re-runs a rigid superposition over the whole alignment\n\t * and repopulates the required properties, including RMSD (TotalRMSD) and\n\t * TM-Score.\n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @throws StructureException\n\t * @see {@link CECalculator#calc_rmsd(Atom[], Atom[], int, boolean, boolean)}\n\t *  contains much of the same code, but stores results in a CECalculator\n\t *  instance rather than an AFPChain \n\t */\n\tpublic static void updateSuperposition(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws StructureException {\n\t\t\n\t\t// Create arrays of aligned atoms\n\t\tint optLength = afpChain.getOptLength();\n\t\tint alnPos = 0;\n\t\tAtom[] aln1 = new Atom[optLength];\n\t\tAtom[] aln2 = new Atom[optLength];\n\t\t\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\t\tfor(int blk=0;blk<blockNum;blk++) {\n\t\t\tfor(int pos=0;pos<optLen[blk];pos++) {\n\t\t\t\tint res1 = optAln[blk][0][pos];\n\t\t\t\tint res2 = optAln[blk][1][pos];\n\t\t\t\taln1[alnPos] = ca1[res1];\n\t\t\t\taln2[alnPos] = ca2[res2];\n\t\t\t\talnPos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Superimpose\n\t\tSVDSuperimposer svd = new SVDSuperimposer(aln1, aln2);\n\t\t\n\t\tMatrix matrix = svd.getRotation();\n\t\tAtom shift = svd.getTranslation();\n\t\t\n\t\t// Apply transformation to ca2\n\t\tfor(Atom a : ca2) {\n\t\t\tCalc.rotate(a.getGroup(), matrix);\n\t\t\tCalc.shift(a.getGroup(), shift);\n\t\t}\n\t\t\n\t\tdouble rmsd = svd.getRMS(ca1, ca2);\n\t\tdouble tm = svd.getTMScore(aln1, aln2, ca1.length, ca2.length);\n\n\t\t// Store new transformation back to AFPChain\n\t\t//TODO convolve current superposition with previous transformation?\n\t\tafpChain.setTotalRmsdOpt(rmsd);\n\t\tafpChain.setOptRmsd(null);\n\t\tafpChain.setBlockRmsd(null);\n\t}\n}\n","changedPro":"package org.biojava.bio.structure.align.util;\n\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.Map.Entry;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.ce.CECalculator;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLParser;\nimport org.biojava.bio.structure.jama.Matrix;\n\n/**\n * Some utility methods for analyzing and manipulating AFPChains.\n * \n * @author Spencer Bliven\n *\n */\npublic class AlignmentTools {\n\tpublic static boolean debug = false;\n\n\t/**\n\t * Checks that the alignment given by afpChain is sequential. This means\n\t * that the residue indices of both proteins increase monotonically as\n\t * a function of the alignment position (ie both proteins are sorted).\n\t * \n\t * This will return false for circularly permuted alignments or other\n\t * non-topological alignments. It will also return false for cases where\n\t * the alignment itself is sequential but it is not stored in the afpChain\n\t * in a sorted manner.\n\t * \n\t * Since algorithms which create non-sequential alignments split the\n\t * alignment into multiple blocks, some computational time can be saved\n\t * by only checking block boundaries for sequentiality. Setting\n\t * <tt>checkWithinBlocks</tt> to <tt>true</tt> makes this function slower,\n\t * but detects AFPChains with non-sequential blocks.\n\t * \n\t * Note that this method should give the same results as\n\t * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n\t * relies on the StructureAlignment algorithm correctly setting this\n\t * parameter, which is sadly not always the case.\n\t * \n\t * @param afpChain An alignment\n\t * @param checkWithinBlocks Indicates whether individual blocks should be\n\t * \tchecked for sequentiality\n\t * @return True if the alignment is sequential.\n\t */\n\tpublic static boolean isSequentialAlignment(AFPChain afpChain, boolean checkWithinBlocks) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] alnLen = afpChain.getOptLen();\n\t\tint blocks = afpChain.getBlockNum();\n\t\t\n\t\tif(blocks < 1) return true; //trivial case\n\t\tif ( alnLen[0] < 1) return true;\n\t\t\n\t\t// Check that blocks are sequential\n\t\tif(checkWithinBlocks) {\n\t\t\tfor(int block = 0; block<blocks; block++) {\n\t\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\t\t\t\t\n\t\t\t\tint prevRes1 = optAln[block][0][0];\n\t\t\t\tint prevRes2 = optAln[block][1][0];\n\t\t\t\t\n\t\t\t\tfor(int pos = 1; pos<alnLen[block]; pos++) {\n\t\t\t\t\tint currRes1 = optAln[block][0][pos];\n\t\t\t\t\tint currRes2 = optAln[block][1][pos];\n\t\t\t\t\t\n\t\t\t\t\tif(currRes1 < prevRes1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(currRes2 < prevRes2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprevRes1 = currRes1;\n\t\t\t\t\tprevRes2 = currRes2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that blocks are sequential\n\t\tint prevRes1 = optAln[0][0][alnLen[0]-1];\n\t\tint prevRes2 = optAln[0][1][alnLen[0]-1];\n\t\t\n\t\tfor(int block = 1; block<blocks;block++) {\n\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\n\t\t\tif(optAln[block][0][0]<prevRes1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(optAln[block][1][0]<prevRes2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprevRes1 = optAln[block][0][alnLen[block]-1];\n\t\t\tprevRes2 = optAln[block][1][alnLen[block]-1];\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Creates a Map specifying the alignment as a mapping between residue indices\n\t * of protein 1 and residue indices of protein 2.\n\t * \n\t * <p>For example,<pre>\n\t * 1234\n\t * 5678</pre>\n\t * becomes<pre>\n\t * 1->5\n\t * 2->6\n\t * 3->7\n\t * 4->8</pre>\n\t * \n\t * @param afpChain An alignment\n\t * @return A mapping from aligned residues of protein 1 to their partners in protein 2.\n\t * @throws StructureException If afpChain is not one-to-one\n\t */\n\tpublic static Map<Integer, Integer> alignmentAsMap(AFPChain afpChain) throws StructureException {\n\t\tMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tfor(int block = 0; block < afpChain.getBlockNum(); block++) {\n\t\t\tfor(int pos = 0; pos < optLen[block]; pos++) {\n\t\t\t\tint res1 = optAln[block][0][pos];\n\t\t\t\tint res2 = optAln[block][1][pos];\n\t\t\t\tif(map.containsKey(res1)) {\n\t\t\t\t\tthrow new StructureException(String.format(\"Residue %d aligned to both %d and %d.\", res1,map.get(res1),res2));\n\t\t\t\t}\n\t\t\t\tmap.put(res1,res2);\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\t\n\t/**\n\t * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n\t * this returns a function f^k(x)=f(f(...f(x)...)).\n\t * \n\t * @param <T>\n\t * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n\t * @param k The number of times to apply the alignment\n\t * @return A new alignment. If the input function is not automorphic\n\t *  (one-to-one), then some inputs may map to null, indicating that the\n\t *  function is undefined for that input.\n\t */\n\tpublic static <T> Map<T,T> applyAlignment(Map<T, T> alignmentMap, int k) {\n\t\treturn applyAlignment(alignmentMap, new IdentityMap<T>(), k);\n\t}\n\t\n\t/**\n\t * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n\t * this returns a function f^k(x)=f(f(...f(x)...)).\n\t * \n\t * To allow for functions with different domains and codomains, the identity\n\t * function allows converting back in a reasonable way. For instance, if \n\t * alignmentMap represented an alignment between two proteins with different\n\t * numbering schemes, the identity function could calculate the offset\n\t * between residue numbers, eg I(x) = x-offset.\n\t * \n\t * When an identity function is provided, the returned function calculates\n\t * f^k(x) = f(I( f(I( ... f(x) ... )) )).\n\t * \n\t * @param <S>\n\t * @param <T>\n\t * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n\t * @param identity An identity-like function providing the isomorphism between\n\t *  the codomain of alignmentMap (of type <T>) and the domain (type <S>).\n\t * @param k The number of times to apply the alignment\n\t * @return A new alignment. If the input function is not automorphic\n\t *  (one-to-one), then some inputs may map to null, indicating that the\n\t *  function is undefined for that input.\n\t */\n\tpublic static <S,T> Map<S,T> applyAlignment(Map<S, T> alignmentMap, Map<T,S> identity, int k) {\n\t\t\n\t\t// This implementation simply applies the map k times.\n\t\t// If k were large, it would be more efficient to do this recursively,\n\t\t// (eg f^4 = (f^2)^2) but k will usually be small.\n\t\t\n\t\tif(k<0) throw new IllegalArgumentException(\"k must be positive\");\n\t\tif(k==1) {\n\t\t\treturn new HashMap<S,T>(alignmentMap); \n\t\t}\n\t\t// Convert to lists to establish a fixed order\n\t\tList<S> preimage = new ArrayList<S>(alignmentMap.keySet()); // currently unmodified\n\t\tList<S> image = new ArrayList<S>(preimage);\n\t\t\n\t\tfor(int n=1;n<k;n++) {\n\t\t\tint deltasSq = 0;\n\t\t\tint numDeltas = 0;\n\t\t\t// apply alignment\n\t\t\tfor(int i=0;i<image.size();i++) {\n\t\t\t\tS pre = image.get(i);\n\t\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\t\timage.set(i, post);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\n\t\tMap<S, T> imageMap = new HashMap<S,T>(alignmentMap.size());\n\t\t\n\t\t//TODO handle nulls consistently.\n\t\t// assure that all the residues in the domain are valid keys\n\t\t/*\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\timageMap.put(post, null);\n\t\t}\n\t\t*/\n\t\t// now populate with actual values\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\t\n\t\t\t// image is currently f^k-1(x), so take the final step\n\t\t\tS preK1 = image.get(i);\n\t\t\tT postK = (preK1==null?null: alignmentMap.get(preK1));\n\t\t\timageMap.put(pre,postK);\n\t\t\t\n\t\t}\n\t\treturn imageMap;\n\t}\n\t\n\t/**\n\t * Helper for {@link #getSymmetryOrder(Map, Map, int, float)} with a true\n\t * identity function (X->X).\n\t * \n\t * <p>This method should only be used in cases where the two proteins\n\t * aligned have identical numbering, as for self-alignments. See\n\t * {@link #getSymmetryOrder(AFPChain, int, float)} for a way to guess\n\t * the sequential correspondence between two proteins.\n\t * \n\t * @param alignment\n\t * @param maxSymmetry\n\t * @param minimumMetricChange\n\t * @return\n\t */\n\tpublic static int getSymmetryOrder(Map<Integer, Integer> alignment,\n\t\t\tfinal int maxSymmetry, final float minimumMetricChange) {\n\t\treturn getSymmetryOrder(alignment, new IdentityMap<Integer>(), maxSymmetry, minimumMetricChange);\n\t}\n\t/**\n\t * Tries to detect symmetry in an alignment.\n\t * \n     * <p>Conceptually, an alignment is a function f:A->B between two sets of\n     * integers. The function may have simple topology (meaning that if two\n     * elements of A are close, then their images in B will also be close), or\n     * may have more complex topology (such as a circular permutation). This\n     * function checks <i>alignment</i> against a reference function\n     * <i>identity</i>, which should have simple topology. It then tries to \n     * determine the symmetry order of <i>alignment</i> relative to\n     * <i>identity</i>, up to a maximum order of <i>maxSymmetry</i>.\n     * \n\t * \n\t * <p><strong>Details</strong><br/>\n\t * Considers the offset (in number of residues) which a residue moves\n\t * after undergoing <i>n</i> alternating transforms by alignment and\n\t * identity. If <i>n</i> corresponds to the intrinsic order of the alignment,\n\t * this will be small. This algorithm tries increasing values of <i>n</i>\n\t * and looks for abrupt decreases in the root mean squared offset.\n\t * If none are found at <i>n</i><=maxSymmetry, the alignment is reported as\n\t * non-symmetric.\n\t * \n\t * @param alignment The alignment to test for symmetry\n\t * @param identity An alignment with simple topology which approximates\n\t *  the sequential relationship between the two proteins. Should map in the\n\t *  reverse direction from alignment.\n\t * @param maxSymmetry Maximum symmetry to consider. High values increase\n\t *  the calculation time and can lead to overfitting. \n\t * @param minimumMetricChange Percent decrease in root mean squared offsets\n\t *  in order to declare symmetry. 0.4f seems to work well for CeSymm.\n\t * @return The order of symmetry of alignment, or 1 if no order <= \n\t *  maxSymmetry is found.\n\t *  \n\t * @see IdentityMap For a simple identity function\n\t */\n\tpublic static int getSymmetryOrder(Map<Integer, Integer> alignment, Map<Integer,Integer> identity,\n\t\t\tfinal int maxSymmetry, final float minimumMetricChange) {\n\t\tList<Integer> preimage = new ArrayList<Integer>(alignment.keySet()); // currently unmodified\n\t\tList<Integer> image = new ArrayList<Integer>(preimage);\n\t\t\t\t\n\t\tint bestSymmetry = 1;\n\t\tdouble bestMetric = Double.POSITIVE_INFINITY; //lower is better\n\t\tboolean foundSymmetry = false;\n\t\t\n\t\tif(debug) {\n\t\t\tSystem.out.println(\"Symm\\tPos\\tDelta\");\n\t\t}\n\t\t\n\t\tfor(int n=1;n<=maxSymmetry;n++) {\n\t\t\tint deltasSq = 0;\n\t\t\tint numDeltas = 0;\n\t\t\t// apply alignment\n\t\t\tfor(int i=0;i<image.size();i++) {\n\t\t\t\tInteger pre = image.get(i);\n\t\t\t\tInteger intermediate = (pre==null?null: alignment.get(pre));\n\t\t\t\tInteger post = (intermediate==null?null: identity.get(intermediate));\n\t\t\t\timage.set(i, post);\n\t\t\t\t\n\t\t\t\tif(post != null) {\n\t\t\t\t\tint delta = post-preimage.get(i);\n\t\t\t\t\t\n\t\t\t\t\tdeltasSq += delta*delta;\n\t\t\t\t\tnumDeltas++;\n\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"%d\\t%d\\t%d\\n\",n,preimage.get(i),delta);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Metrics: RMS compensates for the trend of smaller numDeltas with higher order\n\t\t\t// Not normalizing by numDeltas favors smaller orders\n\t\t\t\n\t\t\tdouble metric = Math.sqrt((double)deltasSq/numDeltas); // root mean squared distance\n\t\t\t//double metric = Math.sqrt((double)deltasSq); // root squared distance\n\t\t\t\n\t\t\t//System.out.format(\"%d\\t%f\\n\",n,metric);\n\t\t\t\n\t\t\tif(!foundSymmetry && metric < bestMetric * minimumMetricChange) {\n\t\t\t\t// n = 1 is never the best symmetry\n\t\t\t\tif(bestMetric < Double.POSITIVE_INFINITY) {\n\t\t\t\t\tfoundSymmetry = true;\n\t\t\t\t}\n\t\t\t\tbestSymmetry = n;\n\t\t\t\tbestMetric = metric;\n\t\t\t}\n\t\t\t\n\t\t\t// When debugging need to loop over everything. Unneeded in production\n\t\t\tif(!debug && foundSymmetry) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(foundSymmetry) {\n\t\t\treturn bestSymmetry;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\n\t/**\n\t * Guesses the order of symmetry in an alignment\n\t * \n\t * <p>Uses {@link #getSymmetryOrder(Map alignment, Map identity, int, float)}\n\t * to determine the the symmetry order. For the identity alignment, sorts\n\t * the aligned residues of each protein sequentially, then defines the ith\n\t * residues of each protein to be equivalent.\n\t */\n\tpublic static int getSymmetryOrder(AFPChain afpChain, int maxSymmetry, float minimumMetricChange) throws StructureException {\n\t\t// alignment comes from the afpChain alignment\n\t\tMap<Integer,Integer> alignment = AlignmentTools.alignmentAsMap(afpChain);\n\n\t\t// Now construct identity to map aligned residues in sequential order\n\t\tMap<Integer, Integer> identity = guessSequentialAlignment(alignment, true);\n\t\t\n\t\t\n\t\treturn AlignmentTools.getSymmetryOrder(alignment,\n\t\t\t\tidentity,\n\t\t\t\tmaxSymmetry, minimumMetricChange);\n\t}\n\n\t/**\n\t * Takes a potentially non-sequential alignment and guesses a sequential\n\t * version of it. Residues from each structure are sorted sequentially and\n\t * then compared directly.\n\t * \n\t * <p>The results of this method are consistent with what one might expect\n\t * from an identity function, and are therefore useful with\n\t * {@link #getSymmetryOrder(Map, Map identity, int, float)}.\n\t * <ul>\n\t *  <li>Perfect self-alignments will have the same pre-image and image,\n\t *      so will map X->X</li>\n\t *  <li>Gaps and alignment errors will cause errors in the resulting map,\n\t *      but only locally. Errors do not propagate through the whole \n\t *      alignment.</li>\n\t * </ul>\n\t * \n\t * <h4>Example:</h4>\n\t * A non sequential alignment, represented schematically as\n\t * <pre>\n\t * 12456789\n\t * 78912345</pre>\n\t * would result in a map\n\t * <pre>\n\t * 12456789\n\t * 12345789</pre>\n\t * @param afpChain The non-sequential input alignment\n\t * @param inverseAlignment If false, map from structure1 to structure2. If\n\t *  true, generate the inverse of that map.\n\t * @return A mapping from sequential residues of one protein to those of the other\n\t * @throws IllegalArgumentException if the input alignment is not one-to-one.\n\t */\n\tpublic static Map<Integer, Integer> guessSequentialAlignment(\n\t\t\tMap<Integer,Integer> alignment, boolean inverseAlignment) {\n\t\tMap<Integer,Integer> identity = new HashMap<Integer,Integer>();\n\t\t\n\t\tSortedSet<Integer> aligned1 = new TreeSet<Integer>();\n\t\tSortedSet<Integer> aligned2 = new TreeSet<Integer>();\n\t\t\n\t\tfor(Entry<Integer,Integer> pair : alignment.entrySet()) {\n\t\t\taligned1.add(pair.getKey());\n\t\t\tif( !aligned2.add(pair.getValue()) )\n\t\t\t\tthrow new IllegalArgumentException(\"Alignment is not one-to-one for residue \"+pair.getValue()+\" of the second structure.\");\n\t\t}\n\t\t\n\t\tIterator<Integer> it1 = aligned1.iterator();\n\t\tIterator<Integer> it2 = aligned2.iterator();\n\t\twhile(it1.hasNext()) {\n\t\t\tif(inverseAlignment) { // 2->1\n\t\t\t\tidentity.put(it2.next(),it1.next());\n\t\t\t} else { // 1->2\n\t\t\t\tidentity.put(it1.next(),it2.next());\n\t\t\t}\n\t\t}\n\t\treturn identity;\n\t}\n\t\n\t/**\n\t * Retrieves the optimum alignment from an AFPChain and returns it as a\n\t * java collection. The result is indexed in the same way as \n\t * {@link AFPChain#getOptAln()}, but has the correct size().\n\t * <pre>\n\t * List<List<List<Integer>>> aln = getOptAlnAsList(AFPChain afpChain);\n\t * aln.get(blockNum).get(structureNum={0,1}).get(pos)</pre>\n\t * \n\t * @param afpChain\n\t * @return\n\t */\n\tpublic static List<List<List<Integer>>> getOptAlnAsList(AFPChain afpChain) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tList<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum());\n\t\tfor(int blockNum=0;blockNum<afpChain.getBlockNum();blockNum++) {\n\t\t\t//TODO could improve speed an memory by wrapping the arrays with\n\t\t\t// an unmodifiable list, similar to Arrays.asList(...) but with the\n\t\t\t// correct size parameter.\n\t\t\tList<Integer> align1 = new ArrayList<Integer>(optLen[blockNum]);\n\t\t\tList<Integer> align2 = new ArrayList<Integer>(optLen[blockNum]);\n\t\t\tfor(int pos=0;pos<optLen[blockNum];pos++) {\n\t\t\t\talign1.add(optAln[blockNum][0][pos]);\n\t\t\t\talign2.add(optAln[blockNum][1][pos]);\n\t\t\t}\n\t\t\tList<List<Integer>> block = new ArrayList<List<Integer>>(2);\n\t\t\tblock.add(align1);\n\t\t\tblock.add(align2);\n\t\t\tblocks.add(block);\n\t\t}\n\t\t\n\t\treturn blocks;\n\t}\n\n\n\n\t/**\n\t * A Map<K,V> can be viewed as a function from K to V. This class represents\n\t * the identity function. Getting a value results in the value itself.\n\t * \n\t * <p>The class is a bit inconsistent when representing its contents. On\n\t * the one hand, containsKey(key) is true for all objects. However, \n\t * attempting to iterate through the values returns an empty set.\n\t * \n\t * @author Spencer Bliven\n\t *\n\t * @param <K>\n\t * @param <V>\n\t */\n\tpublic static class IdentityMap<K> extends AbstractMap<K,K> {\n\t\tpublic IdentityMap() {}\n\n\t\t/**\n\t\t * @param key\n\t\t * @return the key\n\t\t * @throws ClassCastException if key is not of type K\n\t\t */\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tpublic K get(Object key) {\n\t\t\treturn (K)key;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Always returns the empty set\n\t\t */\n\t\t@Override\n\t\tpublic Set<java.util.Map.Entry<K, K>> entrySet() {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean containsKey(Object key) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Fundimentally, an alignment is just a list of aligned residues in each\n\t * protein. This method converts two lists of ResidueNumbers into an\n\t * AFPChain.\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2 CA atoms of the second protein\n\t * @param aligned1 A list of aligned residues from the first protein\n\t * @param aligned2 A list of aligned residues from the second protein.\n\t *  Must be the same length as aligned1.\n\t * @return An AFPChain representing the alignment. Many properties may be\n\t *  null or another default.\n\t * @throws IllegalArgumentException if aligned1 and aligned2 have different\n\t *  lengths\n\t */\n\tpublic static AFPChain createAFPChain(Atom[] ca1, Atom[] ca2,\n\t\t\tResidueNumber[] aligned1, ResidueNumber[] aligned2 ) {\n\t\t//input validation\n\t\tint alnLen = aligned1.length;\n\t\tif(alnLen != aligned2.length) {\n\t\t\tthrow new IllegalArgumentException(\"Alignment lengths are not equal\");\n\t\t}\n\t\t\n\t\tAFPChain a = new AFPChain();\n\t\ta.setName1(ca1[0].getGroup().getChain().getParent().getName());\n\t\ta.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t\n\t\ta.setBlockNum(1);\n\t\ta.setCa1Length(ca1.length);\n\t\ta.setCa2Length(ca2.length);\n\t\t\n\t\ta.setOptLength(alnLen);\n\t\ta.setOptLen(new int[] {alnLen});\n\t\t\n\n\t\tMatrix[] ms = new Matrix[a.getBlockNum()];\n\t\ta.setBlockRotationMatrix(ms);\n\t\tAtom[] blockShiftVector = new Atom[a.getBlockNum()];\n\t\ta.setBlockShiftVector(blockShiftVector);\n\t\t// TODO run superimposer (not required for display)\n\t\t// TODO more properties\n\n\t\t\n\t\tString[][][] pdbAln = new String[1][2][alnLen];\n\t\tfor(int i=0;i<alnLen;i++) {\n\t\t\tpdbAln[0][0][i] = aligned1[i].getChainId()+\":\"+aligned1[i].toString();\n\t\t\tpdbAln[0][1][i] = aligned2[i].getChainId()+\":\"+aligned2[i].toString();\n\t\t}\n\t\t\n\t\ta.setPdbAln(pdbAln);\n\t\t\n\t\t// convert pdbAln to optAln, and fill in some other basic parameters\n\t\tAFPChainXMLParser.rebuildAFPChain(a, ca1, ca2);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * After the alignment changes (optAln, optLen, blockNum, at a minimum),\n\t * many other properties which depend on the superposition will be invalid.\n\t * \n\t * This method re-runs a rigid superposition over the whole alignment\n\t * and repopulates the required properties, including RMSD (TotalRMSD) and\n\t * TM-Score.\n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2 Second set of ca atoms. Will be modified based on the superposition\n\t * @throws StructureException\n\t * @see {@link CECalculator#calc_rmsd(Atom[], Atom[], int, boolean, boolean)}\n\t *  contains much of the same code, but stores results in a CECalculator\n\t *  instance rather than an AFPChain \n\t */\n\tpublic static void updateSuperposition(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws StructureException {\n\t\t\n\t\t// Create arrays of aligned atoms\n\t\tint optLength = afpChain.getOptLength();\n\t\tint alnPos = 0;\n\t\tAtom[] aln1 = new Atom[optLength];\n\t\tAtom[] aln2 = new Atom[optLength];\n\t\t\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\t\tfor(int blk=0;blk<blockNum;blk++) {\n\t\t\tfor(int pos=0;pos<optLen[blk];pos++) {\n\t\t\t\tint res1 = optAln[blk][0][pos];\n\t\t\t\tint res2 = optAln[blk][1][pos];\n\t\t\t\taln1[alnPos] = ca1[res1];\n\t\t\t\taln2[alnPos] = ca2[res2];\n\t\t\t\talnPos++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Superimpose\n\t\tSVDSuperimposer svd = new SVDSuperimposer(aln1, aln2);\n\t\t\n\t\tMatrix matrix = svd.getRotation();\n\t\tAtom shift = svd.getTranslation();\n\t\t\n\t\t// Apply transformation to ca2\n\t\tif(ca2.length>0 && ca2[0].getGroup() != null &&\n\t\t\t\tca2[0].getGroup().getChain() != null &&\n\t\t\t\tca2[0].getGroup().getChain().getParent() != null) {\n\t\t\t// Assume that ca2 comes from a single structure for efficiency\n\t\t\tStructure struct = ca2[0].getGroup().getChain().getParent();\n\t\t\tCalc.rotate(struct, matrix);\n\t\t\tCalc.shift(struct, shift);\n\t\t} else {\n\t\t\t// No underlying structure, so do groups individually\n\t\t\tfor(Atom a : ca2) {\n\t\t\t\tCalc.rotate(a.getGroup(), matrix);\n\t\t\t\tCalc.shift(a.getGroup(), shift);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble rms = SVDSuperimposer.getRMS(ca1, ca2);\n\t\tdouble tm = SVDSuperimposer.getTMScore(aln1, aln2, ca1.length, ca2.length);\n\n\t\t// Store new transformation back to AFPChain\n\t\t//TODO convolve current superposition with previous transformation?\n\t\tafpChain.setTotalRmsdOpt(Math.sqrt(rms));\n\t\tafpChain.setTMScore(tm);\n\t\tdouble[] dummy = new double[blockNum];\n\t\tArrays.fill(dummy, -1.);\n\t\tafpChain.setOptRmsd(dummy);\n\t\tafpChain.setBlockRmsd(dummy);\n\t}\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure.align.util;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.StructureAlignment;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeCPMain;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\n\nimport junit.framework.TestCase;\n\npublic class AlignmentToolsTest extends TestCase {\n\t\n\tpublic void testIsSequential() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tString name1, name2;\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain;\n\t\tStructureAlignment ce;\n\t\t\n\t\t\n\t\t// CP case\n\t\tname1=\"1QDM.A\"; // swaposin\n\t\tname2=\"1NKL\"; // saposin\n\t\t\n\t\tca1=cache.getAtoms(name1);\n\t\tca2=cache.getAtoms(name2);\n\t\t\n\t\tce = StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\t\tafpChain = ce.align(ca1,ca2);\n\t\t\n\t\tassertFalse(\"CeCPMain should give non-sequential alignments (between blocks).\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\t\tassertFalse(\"CeCPMain should give non-sequential alignments (within blocks).\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\n\t\t// linear case\t\t\n\t\tce = StructureAlignmentFactory.getAlgorithm(CeMain.algorithmName);\n\t\tafpChain = ce.align(ca1,ca2);\n\t\t\n\t\tassertTrue(\"CeMain should give sequential alignments (within blocks).\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\t\tassertTrue(\"CeMain should give sequential alignments (between blocks).\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\n\t\t// now change the block interior a bit\n\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint tmp;\n\t\ttmp = optAln[0][0][2];\n\t\toptAln[0][0][2] = optAln[0][0][1];\n\t\toptAln[0][0][1] = tmp;\n\t\ttmp = optAln[0][1][2];\n\t\toptAln[0][1][2] = optAln[0][1][1];\n\t\toptAln[0][1][1] = tmp;\n\t\t\n\t\tassertTrue(\"Modifying block interior shouldn't effect block sequence.\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\t\tassertFalse(\"Modifying block interior should be not sequential.\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\n\t}\n\t\n\tpublic void testGetSymmetryOrderForMaps() {\n\t\tint order;\n\t\tfinal int maxSymmetry = 8;\n\t\tfinal float minimumMetricChange = .5f;// be liberal, since we have small alignments\n\t\t\n\t\t// noisy C3 alignment\n\t\tMap<Integer,Integer> alignment1 = new HashMap<Integer,Integer>();\n\t\talignment1.put(1, 5);\n\t\talignment1.put(2, 6);\n\t\talignment1.put(4, 7);\n\t\talignment1.put(6, 9);\n\t\talignment1.put(7, 11);\n\t\talignment1.put(9, 2);\n\t\talignment1.put(10, 3);\n\t\talignment1.put(11, 4);\n\n\t\tMap<Integer,Integer> identity = new AlignmentTools.IdentityMap<Integer>();\n\t\t\n\t\torder = AlignmentTools.getSymmetryOrder(alignment1, identity, maxSymmetry, minimumMetricChange);\n\t\tassertEquals(\"Wrong order for alignment 1\",3,order);\n\t\t\n\t\t// sequential alignment. Should be order 1, but we report this as \"no symmetry\"\n\t\t//TODO Change default return value in getSymmetry\n\t\tMap<Integer,Integer> alignment2 = new HashMap<Integer,Integer>();\n\t\tfor(int i=1;i<10;i++) {\n\t\t\talignment2.put(i, i+1);\n\t\t}\n\t\t\n\t\torder = AlignmentTools.getSymmetryOrder(alignment2, identity, maxSymmetry, minimumMetricChange);\n\t\tassertEquals(\"Wrong order for alignment 2\",1,order);\n\t\t\n\t\t// now try to get symmetry order with an imperfect identity\n\t\tMap<Integer,Integer> alignment3 = new HashMap<Integer,Integer>();\n\t\talignment3.put(1, 15);\n\t\talignment3.put(2, 16);\n\t\talignment3.put(4, 17);\n\t\talignment3.put(6, 19);\n\t\talignment3.put(7, 21);\n\t\talignment3.put(9, 12);\n\t\talignment3.put(10, 13);\n\t\talignment3.put(11, 14);\n\t\t\n\t\tMap<Integer,Integer> identityMinus10 = new HashMap<Integer,Integer>();\n\t\tfor(int i=1;i<=11;i++) {\n\t\t\tidentityMinus10.put(i+10, i);\n\t\t}\n\t\t\n\t\t\n\t\torder = AlignmentTools.getSymmetryOrder(alignment3, identityMinus10, maxSymmetry, minimumMetricChange);\n\t\tassertEquals(\"Wrong order for alignment 3 with I(x)=x-10\",3,order);\n\t\t\n\t\t/* These tests don't work because there are no paths longer than maxSymmetry, so they hit 0 error (NaN metric change)\n\t\t//Stringent minimumMetric values cause it to miss the alignment\n\t\torder = AlignmentTools.getSymmetryOrder(alignment3, identityMinus10, maxSymmetry, .001f);\n\t\tassertEquals(\"Wrong order for alignment 1 with I(x)=x+1 & minMetric=.01\",1,order);\n\n\t\torder = AlignmentTools.getSymmetryOrder(alignment1, identity, maxSymmetry, .001f);\n\t\tassertEquals(\"Wrong order for alignment 1 & minMetric=.01\",1,order);\n\t\t*/\n\t}\n\t\n\tpublic void testGuessSequentialAlignment() {\n\t\t// noisy C3 alignment\n\t\tMap<Integer,Integer> alignment1 = new HashMap<Integer,Integer>();\n\t\talignment1.put(1, 5);\n\t\talignment1.put(2, 6);\n\t\talignment1.put(4, 7);\n\t\talignment1.put(6, 9);\n\t\talignment1.put(7, 11);\n\t\talignment1.put(9, 2);\n\t\talignment1.put(10, 3);\n\t\talignment1.put(11, 4);\n\t\t\n\t\t// Sequential version of the alignment\n\t\tMap<Integer,Integer> sequentialForward = new HashMap<Integer,Integer>();\n\t\tsequentialForward.put(1, 2);\n\t\tsequentialForward.put(2, 3);\n\t\tsequentialForward.put(4, 4);\n\t\tsequentialForward.put(6, 5);\n\t\tsequentialForward.put(7, 6);\n\t\tsequentialForward.put(9, 7);\n\t\tsequentialForward.put(10, 9);\n\t\tsequentialForward.put(11, 11);\n\t\t\n\t\t// inverse of sequentialForward\n\t\tMap<Integer,Integer> sequentialBackward = new HashMap<Integer,Integer>();\n\t\tsequentialBackward.put(2, 1);\n\t\tsequentialBackward.put(3, 2);\n\t\tsequentialBackward.put(4, 4);\n\t\tsequentialBackward.put(5, 6);\n\t\tsequentialBackward.put(6, 7);\n\t\tsequentialBackward.put(7, 9);\n\t\tsequentialBackward.put(9, 10);\n\t\tsequentialBackward.put(11, 11);\n\t\t\n\t\n\t\tMap<Integer,Integer> result;\n\t\t\n\t\tresult = AlignmentTools.guessSequentialAlignment(alignment1, false);\n\t\tassertEquals(\"Wrong forward alignment\",sequentialForward,result);\n\t\n\t\tresult = AlignmentTools.guessSequentialAlignment(alignment1, true);\n\t\tassertEquals(\"Wrong backward alignment\",sequentialBackward,result);\n\t}\n\t\n\t \n\tpublic void testGetSymmetryOrderWithCECP() throws IOException, StructureException {\n\t\t\n\t\tString name1,name2;\n\t\tint trueOrder;\n\t\t\n\t\t// Two highly-symmetric circularly permuted proteins (swaposin)\n\t\tname1 = \"1QDM.A\";\n\t\tname2 = \"1NKL\";\n\t\ttrueOrder = 2;\n\t\t\n//\t\t// Non-symmetric\n//\t\tname1 = \"1NLS.A\";\n//\t\tname2 = \"1RIN.A\";\n//\t\ttrueOrder = 1;\n//\t\t\n//\t\t// non-symmetric\n//\t\tname1 = \"1ATG.A\";\n//\t\tname2 = \"2B4L.A\";\n//\t\ttrueOrder = 1;\n//\t\t\n//\t\tname1 = \"1TIM.A\";\n//\t\tname2 = \"1CDG\";\n//\t\ttrueOrder = 1;\n//\t\t\n//\t\tname1 = \"1a22.A\";\n//\t\tname2 = \"2ffx.J\";\n\t\t\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\tAtom[] ca2 = cache.getAtoms(name2);\n\t\t\n\t\tStructureAlignment cecp = StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\t\tlong startAlignmentTime = System.currentTimeMillis();\n\t\tAFPChain afpChain = cecp.align(ca1, ca2);\n\t\tlong alignmentTime = System.currentTimeMillis() - startAlignmentTime;\n\t\t\n\t\tfinal int maxSymmetry = 8;\n\t\tfinal float minimumMetricChange = .4f;\n\t\t\n\t\tlong startSymmetryOrderTime = System.currentTimeMillis();\n\t\tint order = AlignmentTools.getSymmetryOrder(afpChain, maxSymmetry, minimumMetricChange);\n\t\tlong symmetryOrderTime = System.currentTimeMillis() - startSymmetryOrderTime;\n\t\t\n\t\t//System.out.println(\"Len1\\tLen2\\tAlignT\\tOrderT\\tOrder\");\n\t\t//System.out.format(\"%d\\t%d\\t%f\\t%f\\t%d\", ca1.length,ca2.length,\n\t\t//\t\talignmentTime/1000.,symmetryOrderTime/1000.,order);\n\t\t//System.out.println();\n\n\t\tassertEquals(\"Wrong order found for \"+name1+\" vs \"+name2,trueOrder,order);\n\t}\n\t\n\tpublic void testApplyAlignment() {\n\t\t// noisy C3 alignment\n\t\tMap<Integer,Integer> alignment1 = new HashMap<Integer,Integer>();\n\t\talignment1.put(1, 5);\n\t\talignment1.put(2, 6);\n\t\talignment1.put(4, 7);\n\t\talignment1.put(6, 9);\n\t\talignment1.put(7, 11);\n\t\talignment1.put(9, 2);\n\t\talignment1.put(10, 3);\n\t\talignment1.put(11, 4);\n\n\t\tMap<Integer,Integer> image1 = new HashMap<Integer,Integer>();\n\t\timage1.put(1, null);\n\t\timage1.put(2, 9);\n\t\timage1.put(4, 11);\n\t\timage1.put(6, 2);\n\t\timage1.put(7, 4);\n\t\timage1.put(9, 6);\n\t\timage1.put(10, null);\n\t\timage1.put(11, 7);\n\t\t//image1.put(5, null);\n\t\t//image1.put(3, null);\n\t\t//TODO handle nulls consistently. Either include all of them, or none.\n\t\t\n\t\tMap<Integer,Integer> result1 = AlignmentTools.applyAlignment(alignment1,2);\n\t\tassertEquals(\"Alignment1 incorrectly applied\",image1,result1);\n\t}\n\t\n\tpublic void testApplyAlignmentNonIdentical() {\n\t\t// noisy C3 alignment\n\t\tMap<Integer,Integer> alignment1 = new HashMap<Integer,Integer>();\n\t\talignment1.put(1, 15);\n\t\talignment1.put(2, 16);\n\t\talignment1.put(4, 17);\n\t\talignment1.put(6, 19);\n\t\talignment1.put(7, 21);\n\t\talignment1.put(9, 12);\n\t\talignment1.put(10, 13);\n\t\talignment1.put(11, 14);\n\n\t\tMap<Integer,Integer> image1 = new HashMap<Integer,Integer>();\n\t\timage1.put(1, null);\n\t\timage1.put(2, 19);\n\t\timage1.put(4, 21);\n\t\timage1.put(6, 12);\n\t\timage1.put(7, 14);\n\t\timage1.put(9, 16);\n\t\timage1.put(10, null);\n\t\timage1.put(11, 17);\n\t\t//image1.put(5, null);\n\t\t//image1.put(3, null);\n\t\t\n\t\tMap<Integer,Integer> identity1 = new HashMap<Integer, Integer>();\n\t\tfor(int i=1;i<12;i++) {\n\t\t\tidentity1.put(i+10,i);\n\t\t}\n\t\tMap<Integer,Integer> result1 = AlignmentTools.applyAlignment(alignment1,identity1,2);\n\t\tassertEquals(\"Alignment1 incorrectly applied with identity x->x-10\",image1,result1);\n\t}\n}\n","changedTest":"","commitMessage":"Minor bug fixes in AlignmentTools (rmsd calculation) \n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@10100 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}