{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/URLIdentifier.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestURLIdentifier.java","prod_time":"2021-04-14 09:20:04","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"93b053933c14c75e21d3488f37e3a5eae253a561","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.cif.CifStructureConverter;\nimport org.biojava.nbio.structure.io.StructureFiletype;\nimport org.biojava.nbio.structure.io.mmtf.MmtfActions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Represents a structure loaded from a URL (including a file URL)\n *\n * A few custom query parameters are supported:\n *\n * <ul>\n * <li><tt>format=[pdb|cif]</tt> Specify the file format (will otherwise be\n *     guessed from the extension)\n * <li><tt>pdbId=[String]</tt> Specify the PDB ID (also guessed from the filename)\n * <li><tt>chainID=[String]</tt> A single chain from the structure\n * <li><tt>residues=[String]</tt> Residue ranges, in a form understood by\n *     {@link SubstructureIdentifier}\n * </ul>\n * @author Spencer Bliven\n *\n */\npublic class URLIdentifier implements StructureIdentifier {\n\tprivate static final long serialVersionUID = -5161230822868926035L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(URLIdentifier.class);\n\n\t// Used for guessing the PDB ID from the filename\n\tprivate static final Pattern PDBID_REGEX = Pattern.compile(\"^([0-9][a-z0-9]{3})([._-]|\\\\s).*\", Pattern.CASE_INSENSITIVE);\n\n\t/** URL parameter specifying the file format (PDB or CIF) */\n\tpublic static final String FORMAT_PARAM = \"format\";\n\t/** URL parameter specifying the PDB ID */\n\tpublic static final String PDBID_PARAM = \"pdbid\";\n\t/** URL parameter specifying a single chain to include; overridden by residues */\n\n\t//TODO: should this get renamed to chainname or asymid?\n\tpublic static final String CHAINID_PARAM = \"chainid\";\n\t/**\n\t * URL parameter specifying residue ranges to include, e.g. <tt>residues=A:1-70</tt>\n\t * @see SubstructureIdentifier\n\t */\n\tpublic static final String RESIDUES_PARAM = \"residues\";\n\n\tfinal private URL url;\n\tpublic URLIdentifier(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic URLIdentifier(String url) throws MalformedURLException {\n\t\tthis(new URL(url));\n\t}\n\n\tpublic URL getURL() {\n\t\treturn url;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn url.toString();\n\t}\n\n\t/**\n\t * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n\t */\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() {\n\t\tString pdbId = null;\n\t\tList<ResidueRange> ranges = Collections.emptyList();\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(PDBID_PARAM)) {\n\t\t\t\tpdbId = params.get(PDBID_PARAM);\n\t\t\t}\n\t\t\tif (params.containsKey(RESIDUES_PARAM)) {\n\t\t\t\tranges = ResidueRange.parseMultiple(params.get(RESIDUES_PARAM));\n\t\t\t} else if (params.containsKey(CHAINID_PARAM)) {\n\t\t\t\tranges = Collections.singletonList(new ResidueRange(params.get(CHAINID_PARAM), (ResidueNumber) null, (ResidueNumber) null));\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\t\tif (pdbId == null) {\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = guessPDBID(path.substring(path.lastIndexOf(\"/\") + 1));\n\t\t}\n\t\treturn new SubstructureIdentifier(pdbId, ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t/**\n\t * Load the structure from the URL\n\t * @return null\n\t */\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException, IOException {\n\t\tStructureFiletype format = StructureFiletype.UNKNOWN;\n\n\t\t// Use user-specified format\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(FORMAT_PARAM)) {\n\t\t\t\tString formatStr = params.get(FORMAT_PARAM);\n\t\t\t\tformat = StructureIO.guessFiletype(\".\" + formatStr);\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\n\t\t// Guess format from extension\n\t\tif (format == StructureFiletype.UNKNOWN) {\n\t\t\tformat = StructureIO.guessFiletype(url.getPath());\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase CIF: case BCIF:\n\t\t\t\treturn CifStructureConverter.fromURL(url);\n\t\t\tcase MMTF:\n\t\t\t\treturn MmtfActions.readFromInputStream(url.openStream());\n\t\t\tdefault: case PDB:\n\t\t\t\t// pdb file based parsing\n\t\t\t\tPDBFileReader reader = new PDBFileReader(cache.getPath());\n\t\t\t\treader.setFetchBehavior(cache.getFetchBehavior());\n\t\t\t\treader.setObsoleteBehavior(cache.getObsoleteBehavior());\n\t\t\t\treader.setFileParsingParameters(cache.getFileParsingParams());\n\t\t\t\treturn reader.getStructure(url);\n\t\t}\n\t}\n\n\t/**\n\t * Recognizes PDB IDs that occur at the beginning of name followed by some\n\t * delimiter.\n\t * @param name Input filename\n\t * @return A 4-character id-like string, or null if none is found\n\t */\n\tpublic static String guessPDBID(String name) {\n\t\tMatcher match = PDBID_REGEX.matcher(name);\n\t\tif (match.matches()) {\n\t\t\treturn match.group(1).toUpperCase();\n\t\t} else {\n\t\t\t// Give up if doesn't match\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parses URL parameters into a map. Keys are stored lower-case.\n\t *\n\t * @param url\n\t * @return\n\t * @throws UnsupportedEncodingException\n\t */\n\tprivate static Map<String,String> parseQuery(URL url) throws UnsupportedEncodingException {\n\t\tMap<String,String> params = new LinkedHashMap<>();\n\t\tString query = url.getQuery();\n\t\tif (query == null || query.isEmpty()) {\n\t\t\t// empty query\n\t\t\treturn params;\n\t\t}\n\t\tString[] pairs = url.getQuery().split(\"&\");\n\t\tfor (String pair : pairs) {\n\t\t\tint i = pair.indexOf(\"=\");\n\t\t\tString key = pair;\n\t\t\tif (i > 0) {\n\t\t\t\tkey = URLDecoder.decode(pair.substring(0, i), \"UTF-8\");\n\t\t\t}\n\t\t\tString value = null;\n\t\t\tif(i > 0 && pair.length() > i + 1) {\n\t\t\t\tvalue = URLDecoder.decode(pair.substring(i + 1), \"UTF-8\");\n\t\t\t}\n\t\t\t// note that this uses the last instance if a parameter is specified multiple times\n\t\t\tparams.put(key.toLowerCase(), value);\n\t\t}\n\t\treturn params;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.cif.CifStructureConverter;\nimport org.biojava.nbio.structure.io.StructureFiletype;\nimport org.biojava.nbio.structure.io.mmtf.MmtfActions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Represents a structure loaded from a URL (including a file URL)\n *\n * A few custom query parameters are supported:\n *\n * <ul>\n * <li><tt>format=[pdb|cif]</tt> Specify the file format (will otherwise be\n *     guessed from the extension)\n * <li><tt>pdbId=[String]</tt> Specify the PDB ID (also guessed from the filename)\n * <li><tt>chainID=[String]</tt> A single chain from the structure\n * <li><tt>residues=[String]</tt> Residue ranges, in a form understood by\n *     {@link SubstructureIdentifier}\n * </ul>\n * @author Spencer Bliven\n *\n */\npublic class URLIdentifier implements StructureIdentifier {\n\tprivate static final long serialVersionUID = -5161230822868926035L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(URLIdentifier.class);\n\n\t// Used for guessing the PDB ID from the filename\n\tprivate static final Pattern PDBID_REGEX = Pattern.compile(\"^([0-9][a-z0-9]{3})([._-]|\\\\s).*\", Pattern.CASE_INSENSITIVE);\n\n\t/** URL parameter specifying the file format (PDB or CIF) */\n\tpublic static final String FORMAT_PARAM = \"format\";\n\t/** URL parameter specifying the PDB ID */\n\tpublic static final String PDBID_PARAM = \"pdbid\";\n\t/** URL parameter specifying a single chain to include; overridden by residues */\n\n\t//TODO: should this get renamed to chainname or asymid?\n\tpublic static final String CHAINID_PARAM = \"chainid\";\n\t/**\n\t * URL parameter specifying residue ranges to include, e.g. <tt>residues=A:1-70</tt>\n\t * @see SubstructureIdentifier\n\t */\n\tpublic static final String RESIDUES_PARAM = \"residues\";\n\n\tfinal private URL url;\n\tpublic URLIdentifier(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic URLIdentifier(String url) throws MalformedURLException {\n\t\tthis(new URL(url));\n\t}\n\n\tpublic URL getURL() {\n\t\treturn url;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn url.toString();\n\t}\n\n\t/**\n\t * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n\t */\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() {\n\t\tString pdbId = null;\n\t\tList<ResidueRange> ranges = Collections.emptyList();\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(PDBID_PARAM)) {\n\t\t\t\tpdbId = params.get(PDBID_PARAM);\n\t\t\t}\n\t\t\tif (params.containsKey(RESIDUES_PARAM)) {\n\t\t\t\tranges = ResidueRange.parseMultiple(params.get(RESIDUES_PARAM));\n\t\t\t} else if (params.containsKey(CHAINID_PARAM)) {\n\t\t\t\tranges = Collections.singletonList(new ResidueRange(params.get(CHAINID_PARAM), (ResidueNumber) null, (ResidueNumber) null));\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\t\tif (pdbId == null) {\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = guessPDBID(path.substring(path.lastIndexOf(\"/\") + 1));\n\t\t}\n\t\treturn new SubstructureIdentifier(pdbId, ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t/**\n\t * Load the structure from the URL\n\t * @return null\n\t */\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException, IOException {\n\t\tStructureFiletype format = StructureFiletype.UNKNOWN;\n\n\t\t// Use user-specified format\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(FORMAT_PARAM)) {\n\t\t\t\tString formatStr = params.get(FORMAT_PARAM);\n\t\t\t\tformat = StructureIO.guessFiletype(\".\" + formatStr);\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\n\t\t// Guess format from extension\n\t\tif (format == StructureFiletype.UNKNOWN) {\n\t\t\tformat = StructureIO.guessFiletype(url.getPath());\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase CIF: case BCIF:\n\t\t\t\treturn CifStructureConverter.fromURL(url, cache.getFileParsingParams());\n\t\t\tcase MMTF:\n\t\t\t\treturn MmtfActions.readFromInputStream(url.openStream());\n\t\t\tdefault: case PDB:\n\t\t\t\t// pdb file based parsing\n\t\t\t\tPDBFileReader reader = new PDBFileReader(cache.getPath());\n\t\t\t\treader.setFetchBehavior(cache.getFetchBehavior());\n\t\t\t\treader.setObsoleteBehavior(cache.getObsoleteBehavior());\n\t\t\t\treader.setFileParsingParameters(cache.getFileParsingParams());\n\t\t\t\treturn reader.getStructure(url);\n\t\t}\n\t}\n\n\t/**\n\t * Recognizes PDB IDs that occur at the beginning of name followed by some\n\t * delimiter.\n\t * @param name Input filename\n\t * @return A 4-character id-like string, or null if none is found\n\t */\n\tpublic static String guessPDBID(String name) {\n\t\tMatcher match = PDBID_REGEX.matcher(name);\n\t\tif (match.matches()) {\n\t\t\treturn match.group(1).toUpperCase();\n\t\t} else {\n\t\t\t// Give up if doesn't match\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parses URL parameters into a map. Keys are stored lower-case.\n\t *\n\t * @param url\n\t * @return\n\t * @throws UnsupportedEncodingException\n\t */\n\tprivate static Map<String,String> parseQuery(URL url) throws UnsupportedEncodingException {\n\t\tMap<String,String> params = new LinkedHashMap<>();\n\t\tString query = url.getQuery();\n\t\tif (query == null || query.isEmpty()) {\n\t\t\t// empty query\n\t\t\treturn params;\n\t\t}\n\t\tString[] pairs = url.getQuery().split(\"&\");\n\t\tfor (String pair : pairs) {\n\t\t\tint i = pair.indexOf(\"=\");\n\t\t\tString key = pair;\n\t\t\tif (i > 0) {\n\t\t\t\tkey = URLDecoder.decode(pair.substring(0, i), \"UTF-8\");\n\t\t\t}\n\t\t\tString value = null;\n\t\t\tif(i > 0 && pair.length() > i + 1) {\n\t\t\t\tvalue = URLDecoder.decode(pair.substring(i + 1), \"UTF-8\");\n\t\t\t}\n\t\t\t// note that this uses the last instance if a parameter is specified multiple times\n\t\t\tparams.put(key.toLowerCase(), value);\n\t\t}\n\t\treturn params;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class TestURLIdentifier {\n\tprivate static final Logger logger = LoggerFactory.getLogger(TestURLIdentifier.class);\n\t@Test\n\tpublic void testFileIdentifiers() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\turl = getClass().getResource(\"/2pos.pdb\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"PDB file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t\turl = getClass().getResource(\"/4hhb.cif.gz\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"CIF file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t}\n\n\t@Test\n\tpublic void testURLParameters() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\tString base = getClass().getResource(\"/2pos.pdb\").getPath();\n\n\t\turl = new URL(\"file://\" + base + \"?format=PDB\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\tassertEquals(\"2POS\",id.toCanonical().getPdbId());\n//\t\tassertEquals(\"2POS\",full.getName()); // What should this get set to with identifiers?\n\n\t\turl = new URL(\"file://\" + base + \"?residues=A:1-5\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for residues=A:1-5\",\"2POS.A_1-5\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for residues=A:1-5\", 5, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\turl = new URL(\"file://\" + base + \"?chainId=A\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for chainId=A\",\"2POS.A\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for chainName=A\", 94, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\ttry {\n\t\t\turl = new URL(\"https://files.rcsb.org/download/1B8G.pdb.gz\");\n\t\t\tid = new URLIdentifier(url);\n\n\t\t\tfull = id.loadStructure(cache);\n\t\t\tassertNotNull(full);\n\t\t\tassertEquals(\"1B8G\",id.toCanonical().getPdbId());\n\t\t} catch(UnknownHostException e) {\n\t\t\tlogger.error(\"Unable to connect to rcsb.org\");\n\t\t\t// still pass\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Fixing issue with file parsing params, they weren't passed in Cif reading case\n","test_commitMessage":"","allZero":false}