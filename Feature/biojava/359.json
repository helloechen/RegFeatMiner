{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/MultipleAlignmentWriter.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/MultipleAlignmentWriterTest.java","prod_time":"2015-06-25 18:09:52","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f1ec2e1a3a39e7fd38d7fb2bf38953c8101c2d05","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.structure.align.multiple;\n\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * This class contains functions for the conversion of {@link MultipleAlignment} to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues\n * \n * @author Aleix Lafita\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence alignment String in FASTA format.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\t\t\n\t\t//Get the alignment sequences\n\t\tList<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment);\n\t\t\n\t\tString fasta = \"\";\n\t\tfor (int st=0; st<alignment.size(); st++){\n\t\t\t//Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\"+alignment.getEnsemble().getStructureNames().get(st)+\"\\n\"+\n\t\t\t\t\talnSequences.get(st)+\"\\n\";\n\t\t}\t\n\t\treturn fasta;\n\t}\n\t\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format. Includes summary information\n\t * about the alignment in the top and a multiple sequence alignment at the bottom.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\t\t\n\t\t//Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString()+\"\\n\\n\");\n\t\t\n\t\t//Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment, mapSeqToStruct);\n\t\t\n\t\t//Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos=0; pos<alnSequences.get(0).length(); pos++){\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(alignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) blockNumbers = blockNumbers.concat(\"\"+(blockNr+1));\n\t\t\telse blockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\t\t\n\t\t//Write the Sequence Alignment\n\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\tif (str<9) fatcat.append(\"Chain 0\"+(str+1)+\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\telse fatcat.append(\"Chain \"+(str+1)+\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\tif (str!=alignment.size()-1) fatcat.append(\"          \"+blockNumbers+\"\\n\");\t\t\t\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\t\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of aligned residues.\n\t * Format is one line per residue group, tab delimited:\n\t * <ul><li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)\n\t * </li></ul>\n\t * Example:\n\t * <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>Note that this format loses information about blocks.\n\t * \n\t * @param multAln MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t//Write structure names & PDB codes\n\t\tfor (int str=0; str<multAln.size(); str++){\n\t\t\tresidueGroup.append(\"#Struct\"+(str+1)+\":\\t\");\n\t\t\tresidueGroup.append(multAln.getEnsemble().getStructureNames().get(str));\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t//Whrite header for columns\n\t\tfor (int str=0; str<multAln.size(); str++) residueGroup.append(\"#Num\"+(str+1)+\"\\tChain\"+(str+1)+\"\\tAA\"+(str+1)+\"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\t\t\n\t\t//Write optimally aligned pairs\n\t\tfor(Block b:multAln.getBlocks()) {\n\t\t\tfor(int res=0;res<b.length();res++) {\n\t\t\t\tfor (int str=0; str<multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null){\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getEnsemble().getAtomArrays().get(str)[residue];\n\t\t\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getResidueNumber().toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getChain().getChainID());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\t\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String output.\n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++){\n\t\t\t\n\t\t\tList<Matrix4d> btransforms = alignment.getBlockSets().get(bs).getTransformations();\n\t\t\tif (btransforms == null || btransforms.size() < 1) continue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \" );\n\t\t\t\ttxt.append(bs+1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tString origString = \"ref\";\n\t\t\t\t\n\t\t\t\ttxt.append(String.format(\"     X\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(0,0),btransforms.get(str).getElement(0,1), btransforms.get(str).getElement(0,2), btransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Y\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(1,0),btransforms.get(str).getElement(1,1), btransforms.get(str).getElement(1,2), btransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Z\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(2,0),btransforms.get(str).getElement(2,1), btransforms.get(str).getElement(2,2), btransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n}","changedPro":"package org.biojava.nbio.structure.align.multiple;\n\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\n\n/**\n * This class contains functions for the conversion of {@link MultipleAlignment} to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues\n * \n * @author Aleix Lafita\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence alignment String in FASTA format.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\t\t\n\t\t//Get the alignment sequences\n\t\tList<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment);\n\t\t\n\t\tString fasta = \"\";\n\t\tfor (int st=0; st<alignment.size(); st++){\n\t\t\t//Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\"+alignment.getEnsemble().getStructureNames().get(st)+\"\\n\"+\n\t\t\t\t\talnSequences.get(st)+\"\\n\";\n\t\t}\t\n\t\treturn fasta;\n\t}\n\t\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format. Includes summary information\n\t * about the alignment in the top and a multiple sequence alignment at the bottom.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\t\t\n\t\t//Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString()+\"\\n\\n\");\n\t\t\n\t\t//Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment, mapSeqToStruct);\n\t\t\n\t\t//Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos=0; pos<alnSequences.get(0).length(); pos++){\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(alignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) blockNumbers = blockNumbers.concat(\"\"+(blockNr+1));\n\t\t\telse blockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\t\t\n\t\t//Write the Sequence Alignment\n\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\tif (str<9) fatcat.append(\"Chain 0\"+(str+1)+\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\telse fatcat.append(\"Chain \"+(str+1)+\": \"+alnSequences.get(str)+\"\\n\");\n\t\t\tif (str!=alignment.size()-1) fatcat.append(\"          \"+blockNumbers+\"\\n\");\t\t\t\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\t\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of aligned residues.\n\t * Format is one line per residue group, tab delimited:\n\t * <ul><li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)\n\t * </li></ul>\n\t * Example:\n\t * <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>Note that this format loses information about blocks.\n\t * \n\t * @param multAln MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t//Write structure names & PDB codes\n\t\tfor (int str=0; str<multAln.size(); str++){\n\t\t\tresidueGroup.append(\"#Struct\"+(str+1)+\":\\t\");\n\t\t\tresidueGroup.append(multAln.getEnsemble().getStructureNames().get(str));\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t//Whrite header for columns\n\t\tfor (int str=0; str<multAln.size(); str++) residueGroup.append(\"#Num\"+(str+1)+\"\\tChain\"+(str+1)+\"\\tAA\"+(str+1)+\"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\t\t\n\t\t//Write optimally aligned pairs\n\t\tfor(Block b:multAln.getBlocks()) {\n\t\t\tfor(int res=0;res<b.length();res++) {\n\t\t\t\tfor (int str=0; str<multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null){\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getEnsemble().getAtomArrays().get(str)[residue];\n\t\t\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getResidueNumber().toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getChain().getChainID());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\t\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String output.\n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++){\n\t\t\t\n\t\t\tList<Matrix4d> btransforms = alignment.getBlockSets().get(bs).getTransformations();\n\t\t\tif (btransforms == null || btransforms.size() < 1) continue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \" );\n\t\t\t\ttxt.append(bs+1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\t\t\t\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tString origString = \"ref\";\n\t\t\t\t\n\t\t\t\ttxt.append(String.format(\"     X\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(0,0),btransforms.get(str).getElement(0,1), btransforms.get(str).getElement(0,2), btransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Y\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(1,0),btransforms.get(str).getElement(1,1), btransforms.get(str).getElement(1,2), btransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Z\"+(str+1)+\" = (%9.6f)*X\"+ origString +\" + (%9.6f)*Y\"+ origString +\" + (%9.6f)*Z\"+ origString +\" + (%12.6f)\",btransforms.get(str).getElement(2,0),btransforms.get(str).getElement(2,1), btransforms.get(str).getElement(2,2), btransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n}","originTest":"package org.biojava.nbio.structure.align.multiple;\r\n\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\nimport org.biojava.nbio.structure.Atom;\r\nimport org.biojava.nbio.structure.Structure;\r\nimport org.biojava.nbio.structure.StructureException;\r\nimport org.biojava.nbio.structure.StructureTools;\r\nimport org.biojava.nbio.structure.align.util.AtomCache;\r\nimport org.biojava.nbio.structure.io.PDBFileReader;\r\nimport org.biojava.nbio.structure.io.StructureIOFile;\r\nimport org.junit.Test;\r\n\r\nimport static org.junit.Assert.*;\r\n\r\n/**\r\n * Test the correctness of various Text outputs for {@link MultipleAlignment}s.\r\n * <p>\r\n * Currently tested:\r\n * <ul><li>FASTA\r\n * <li>FatCat format\r\n * <li>Aligned Residues\r\n * </ul>\r\n * \r\n * @author Aleix Lafita\r\n *\r\n */\r\npublic class MultipleAlignmentWriterTest {\r\n\t\r\n\t@Test\r\n\tpublic void testFASTA() throws StructureException, IOException{\r\n\t\t\r\n\t\tMultipleAlignment alignment = generateTestMultipleAlignment();\r\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment);\r\n\t\tSystem.out.println(result);\r\n\t\t\r\n\t\tStringBuffer expected = new StringBuffer();\r\n\t\texpected.append(\">2gox\\n\");\r\n\t\texpected.append(\"---S-tDaErLkhl--IvTpSgAgeq----NmIgMtPt-viAv---HyL-dEt-eqWe\\n\");\r\n\t\texpected.append(\">2gox\\n\");\r\n\t\texpected.append(\"GsrS-tDAeRLkh--LiVTpSGaGEqn---MiGMtPTviA-vh--YlDE-tEqwE-Kf\\n\");\r\n\t\texpected.append(\">2gox\\n\");\r\n\t\texpected.append(\"GS-rsTDaERLkhl-IvTPSgAGEqnmig--MTPtVIavH-Yld-ETEqwEKf-G-LE\\n\");\r\n\t\t\r\n\t\tassertEquals(result,expected.toString());\r\n\t\t\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testFatCat(){\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void testAlignedResidues(){\r\n\t\t\r\n\t}\r\n\t\r\n\tprivate MultipleAlignment generateTestMultipleAlignment() throws StructureException, IOException{\r\n\t\t\r\n\t\t//Obtain the structure atoms\r\n\t\tStructureIOFile reader = new PDBFileReader();\r\n\t\tFile f = new File(\"src/main/resources/2gox.pdb\");\r\n\t\tStructure structure = null;\r\n\t\ttry {\r\n\t\t\tstructure = reader.getStructure(f);\r\n\t\t} catch (IOException e){\r\n\t\t\tAtomCache cache = new AtomCache();\r\n\t\t\tstructure = cache.getStructure(\"2gox\");\r\n\t\t}\r\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>(3);\r\n\t\tfor (int str=0; str<3; str++){\r\n\t\t\tAtom[] atoms = StructureTools.getRepresentativeAtomArray(structure);\r\n\t\t\tatomArrays.add(StructureTools.cloneAtomArray(atoms));\r\n\t\t}\r\n\t\t\r\n\t\t//Generate the MultipleAlignment - 2 blocks with 2 blocksets each\r\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\r\n\t\tmsa.getEnsemble().setStructureNames(Arrays.asList(\"2gox\",\"2gox\",\"2gox\"));\r\n\t\tmsa.getEnsemble().setAtomArrays(atomArrays);\r\n\t\tint[] nextResidue = new int[3];\r\n\t\tfor (int bs=0; bs<2; bs++){\r\n\t\t\tBlockSet blockSet = new BlockSetImpl(msa);\r\n\t\t\t\tfor (int b=0; b<2; b++){\r\n\t\t\t\tList<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\r\n\t\t\t\tfor (int str=0; str<3; str++){\r\n\t\t\t\t\tList<Integer> chain = new ArrayList<Integer>(50);\r\n\t\t\t\t\tfor (int res=0; res<10; res++){\r\n\t\t\t\t\t\t//Introduce gaps and discontinuities to test for all cases\r\n\t\t\t\t\t\tif (nextResidue[str] % (2+str) == str)chain.add(null);\r\n\t\t\t\t\t\telse chain.add(nextResidue[str]);\r\n\t\t\t\t\t\tif (nextResidue[str] % (10) == str) nextResidue[str] ++;\r\n\t\t\t\t\t\tnextResidue[str]++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\talnRes.add(chain);\r\n\t\t\t\t\tnextResidue[str]+=str;  //Spacing between Blocks\r\n\t\t\t\t}\r\n\t\t\t\tBlock block = new BlockImpl(blockSet);\r\n\t\t\t\tblock.setAlignRes(alnRes);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn msa;\r\n\t}\r\n}\r\n","changedTest":"","commitMessage":"Better exception handling, some more logging and removing warnings","test_commitMessage":"","allZero":false}