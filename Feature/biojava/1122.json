{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/TranscriptSequence.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/TranscriptSequenceTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":2,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":2,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.transcription.TranscriptionEngine;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\n\n/**\n * This is the sequence if you want to go from a gene sequence to a protein sequence. Need to start with a\n * ChromosomeSequence then getting a GeneSequence and then a TranscriptSequence\n * @author Scooter Willis\n */\npublic class TranscriptSequence extends DNASequence {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(TranscriptSequence.class);\n\n\tprivate final ArrayList<CDSSequence> cdsSequenceList = new ArrayList<CDSSequence>();\n\tprivate final LinkedHashMap<String, CDSSequence> cdsSequenceHashMap = new LinkedHashMap<String, CDSSequence>();\n\tprivate StartCodonSequence startCodonSequence = null;\n\tprivate StopCodonSequence stopCodonSequence = null;\n\tprivate GeneSequence parentGeneSequence = null;\n\n\t/**\n\t * Use {@code}public TranscriptSequence(GeneSequence parentDNASequence, AccessionID accessionID, int begin, int end){@code}\n\t * that requires an explicit accessionID\n\t * @deprecated\n\t */\n\tpublic TranscriptSequence(GeneSequence parentDNASequence, int begin, int end) {\n\t\tsetCompoundSet(DNACompoundSet.getDNACompoundSet());\n\t\ttry {\n\t\t\tinitSequenceStorage(parentDNASequence.getSequenceAsString());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\tsetParentSequence(parentDNASequence);\n\t\tthis.parentGeneSequence = parentDNASequence;\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t}\n\n\t/**\n\t *\n\t * @param parentDNASequence\n\t * @param accessionID\n\t * @param begin\n\t * @param end inclusive of end\n\t * @throws  IllegalArgumentException if the parentDNASequence is incompatible with DNACompoundSet\n\t */\n\tpublic TranscriptSequence(GeneSequence parentDNASequence, AccessionID accessionID, int begin, int end) {\n\t\tthis(parentDNASequence, begin, end);\n\t\tsetAccession(accessionID);\n\t}\n\n\t\t@Override\n\tpublic int getLength() {\n\t\treturn Math.abs(this.getBioEnd() - this.getBioBegin()) + 1;\n\t}\n\n\t/**\n\t * @return the strand\n\t */\n\tpublic Strand getStrand() {\n\t\treturn parentGeneSequence.getStrand();\n\t}\n\n\t/**\n\t * Remove a CDS or coding sequence from the transcript sequence\n\t * @param accession\n\t * @return\n\t */\n\tpublic CDSSequence removeCDS(String accession) {\n\t\tfor (CDSSequence cdsSequence : cdsSequenceList) {\n\t\t\tif (cdsSequence.getAccession().getID().equals(accession)) {\n\t\t\t\tcdsSequenceList.remove(cdsSequence);\n\t\t\t\tcdsSequenceHashMap.remove(accession);\n\t\t\t\treturn cdsSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the CDS sequences that have been added to the TranscriptSequences\n\t * @return\n\t */\n\tpublic LinkedHashMap<String, CDSSequence> getCDSSequences() {\n\t\treturn cdsSequenceHashMap;\n\t}\n\n\t/**\n\t * Add a Coding Sequence region with phase to the transcript sequence\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @param phase 0,1,2\n\t * @return\n\t */\n\tpublic CDSSequence addCDS(AccessionID accession, int begin, int end, int phase) throws Exception {\n\t\tif (cdsSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accession id \" + accession.getID());\n\t\t}\n\t\tCDSSequence cdsSequence = new CDSSequence(this, begin, end, phase); //sense should be the same as parent\n\t\tcdsSequence.setAccession(accession);\n\t\tcdsSequenceList.add(cdsSequence);\n\t\tCollections.sort(cdsSequenceList, new CDSComparator());\n\t\tcdsSequenceHashMap.put(accession.getID(), cdsSequence);\n\t\treturn cdsSequence;\n\t}\n\n\t/**\n\t * http://www.sequenceontology.org/gff3.shtml\n\t * http://biowiki.org/~yam/bioe131/GFF.ppt\n\t * @return\n\t */\n\t/**\n\t * Return a list of protein sequences based on each CDS sequence\n\t * where the phase shift between two CDS sequences is assigned to the\n\t * CDS sequence that starts the triplet. This can be used to map\n\t * a CDS/exon region of a protein sequence back to the DNA sequence\n\t * If you have a protein sequence and a predicted gene you can take the\n\t * predict CDS protein sequences and align back to the protein sequence.\n\t * If you have errors in mapping the predicted protein CDS regions to\n\t * an the known protein sequence then you can identify possible errors\n\t * in the prediction\n\t *\n\t * @return\n\t */\n\tpublic ArrayList<ProteinSequence> getProteinCDSSequences() {\n\t\tArrayList<ProteinSequence> proteinSequenceList = new ArrayList<ProteinSequence>();\n\t\tfor (int i = 0; i < cdsSequenceList.size(); i++) {\n\t\t\tCDSSequence cdsSequence = cdsSequenceList.get(i);\n\t\t\tString codingSequence = cdsSequence.getCodingSequence();\n\t\t\t//          logger.debug(\"CDS {} {} = {}\", getStrand(), cdsSequence.getPhase(), codingSequence);\n\t\t\tif (this.getStrand() == Strand.NEGATIVE) {\n\t\t\t\tif (cdsSequence.phase == 1) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(1, codingSequence.length());\n\t\t\t\t} else if (cdsSequence.phase == 2) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(2, codingSequence.length());\n\t\t\t\t}\n\t\t\t\tif (i < cdsSequenceList.size() - 1) {\n\t\t\t\t\tCDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n\t\t\t\t\tif (nextCDSSequence.phase == 1) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n\t\t\t\t\t} else if (nextCDSSequence.phase == 2) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cdsSequence.phase == 1) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(1, codingSequence.length());\n\t\t\t\t} else if (cdsSequence.phase == 2) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(2, codingSequence.length());\n\t\t\t\t}\n\t\t\t\tif (i < cdsSequenceList.size() - 1) {\n\t\t\t\t\tCDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n\t\t\t\t\tif (nextCDSSequence.phase == 1) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n\t\t\t\t\t} else if (nextCDSSequence.phase == 2) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//    logger.debug(\"Coding Sequence: {}\", codingSequence);\n\n\t\t\tDNASequence dnaCodingSequence = null;\n\t\t\ttry {\n\t\t\t\tdnaCodingSequence = new DNASequence(codingSequence.toUpperCase());\n\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t// if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n\t\t\t\tlogger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n\t\t\t}\n\t\t\tRNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(TranscriptionEngine.getDefault());\n\t\t\tProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(TranscriptionEngine.getDefault());\n\t\t\tproteinSequence.setAccession(new AccessionID(cdsSequence.getAccession().getID()));\n\t\t\tproteinSequence.setParentDNASequence(cdsSequence, 1, cdsSequence.getLength());\n\t\t\tproteinSequenceList.add(proteinSequence);\n\t\t}\n\t\treturn proteinSequenceList;\n\t}\n\n\t/**\n\t * Get the stitched together CDS sequences then maps to the cDNA\n\t * @return\n\t */\n\tpublic DNASequence getDNACodingSequence() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (CDSSequence cdsSequence : cdsSequenceList) {\n\t\t\tsb.append(cdsSequence.getCodingSequence());\n\t\t}\n\n\t\tDNASequence dnaSequence = null;\n\t\ttry {\n\t\t\tdnaSequence = new DNASequence(sb.toString().toUpperCase());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n\t\t\tlogger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n\t\t}\n\t\tdnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\t\treturn dnaSequence;\n\t}\n\n\t/**\n\t * Get the protein sequence\n\t * @return\n\t */\n\tpublic ProteinSequence getProteinSequence() {\n\t\treturn getProteinSequence(TranscriptionEngine.getDefault());\n\t}\n\n\t/**\n\t * Get the protein sequence with user defined TranscriptEngine\n\t * @param engine\n\t * @return\n\t */\n\tpublic ProteinSequence getProteinSequence(TranscriptionEngine engine) {\n\t\tDNASequence dnaCodingSequence = getDNACodingSequence();\n\t\tRNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(engine);\n\t\tProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(engine);\n\t\tproteinSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\n\t\treturn proteinSequence;\n\t}\n\n\t/**\n\t * @return the startCodonSequence\n\t */\n\tpublic StartCodonSequence getStartCodonSequence() {\n\t\treturn startCodonSequence;\n\t}\n\n\t/**\n\t * Sets the start codon sequence at given begin /  end location. Note that calling this method multiple times\n\t * will replace any existing value.\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t */\n\tpublic void addStartCodonSequence(AccessionID accession, int begin, int end) {\n\t\tthis.startCodonSequence = new StartCodonSequence(this, begin, end);\n\t\tstartCodonSequence.setAccession(accession);\n\t}\n\n\t/**\n\t * @return the stopCodonSequence\n\t */\n\tpublic StopCodonSequence getStopCodonSequence() {\n\t\treturn stopCodonSequence;\n\t}\n\n\t/**\n\t * Sets the stop codon sequence at given begin /  end location. Note that calling this method multiple times\n\t * will replace any existing value.\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t */\n\tpublic void addStopCodonSequence(AccessionID accession, int begin, int end) {\n\t\tthis.stopCodonSequence = new StopCodonSequence(this, begin, end);\n\t\tstopCodonSequence.setAccession(accession);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.transcription.TranscriptionEngine;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\n\n/**\n * This is the sequence if you want to go from a gene sequence to a protein sequence. Need to start with a\n * ChromosomeSequence then getting a GeneSequence and then a TranscriptSequence\n * @author Scooter Willis\n */\npublic class TranscriptSequence extends DNASequence {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(TranscriptSequence.class);\n\n\tprivate final ArrayList<CDSSequence> cdsSequenceList = new ArrayList<>();\n\tprivate final LinkedHashMap<String, CDSSequence> cdsSequenceHashMap = new LinkedHashMap<>();\n\tprivate StartCodonSequence startCodonSequence = null;\n\tprivate StopCodonSequence stopCodonSequence = null;\n\tprivate GeneSequence parentGeneSequence = null;\n\n\t/**\n\t * Use {@code}public TranscriptSequence(GeneSequence parentDNASequence, AccessionID accessionID, int begin, int end){@code}\n\t * that requires an explicit accessionID\n\t * @deprecated\n\t */\n\tpublic TranscriptSequence(GeneSequence parentDNASequence, int begin, int end) {\n\t\tsetCompoundSet(DNACompoundSet.getDNACompoundSet());\n\t\ttry {\n\t\t\tinitSequenceStorage(parentDNASequence.getSequenceAsString());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\tsetParentSequence(parentDNASequence);\n\t\tthis.parentGeneSequence = parentDNASequence;\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t}\n\n\t/**\n\t *\n\t * @param parentDNASequence\n\t * @param accessionID\n\t * @param begin\n\t * @param end inclusive of end\n\t * @throws  IllegalArgumentException if the parentDNASequence is incompatible with DNACompoundSet\n\t */\n\tpublic TranscriptSequence(GeneSequence parentDNASequence, AccessionID accessionID, int begin, int end) {\n\t\tthis(parentDNASequence, begin, end);\n\t\tsetAccession(accessionID);\n\t}\n\n\t\t@Override\n\tpublic int getLength() {\n\t\treturn Math.abs(this.getBioEnd() - this.getBioBegin()) + 1;\n\t}\n\n\t/**\n\t * @return the strand\n\t */\n\tpublic Strand getStrand() {\n\t\treturn parentGeneSequence.getStrand();\n\t}\n\n\t/**\n\t * Remove a CDS or coding sequence from the transcript sequence\n\t * @param accession\n\t * @return\n\t */\n\tpublic CDSSequence removeCDS(String accession) {\n\t\tfor (CDSSequence cdsSequence : cdsSequenceList) {\n\t\t\tif (cdsSequence.getAccession().getID().equals(accession)) {\n\t\t\t\tcdsSequenceList.remove(cdsSequence);\n\t\t\t\tcdsSequenceHashMap.remove(accession);\n\t\t\t\treturn cdsSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the CDS sequences that have been added to the TranscriptSequences\n\t * @return\n\t */\n\tpublic LinkedHashMap<String, CDSSequence> getCDSSequences() {\n\t\treturn cdsSequenceHashMap;\n\t}\n\n\t/**\n\t * Add a Coding Sequence region with phase to the transcript sequence\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @param phase 0,1,2\n\t * @return\n\t */\n\tpublic CDSSequence addCDS(AccessionID accession, int begin, int end, int phase) throws Exception {\n\t\tif (cdsSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accession id \" + accession.getID());\n\t\t}\n\t\tCDSSequence cdsSequence = new CDSSequence(this, begin, end, phase); //sense should be the same as parent\n\t\tcdsSequence.setAccession(accession);\n\t\tcdsSequenceList.add(cdsSequence);\n\t\tCollections.sort(cdsSequenceList, new CDSComparator());\n\t\tcdsSequenceHashMap.put(accession.getID(), cdsSequence);\n\t\treturn cdsSequence;\n\t}\n\n\t/**\n\t * http://www.sequenceontology.org/gff3.shtml\n\t * http://biowiki.org/~yam/bioe131/GFF.ppt\n\t * @return\n\t */\n\t/**\n\t * Return a list of protein sequences based on each CDS sequence\n\t * where the phase shift between two CDS sequences is assigned to the\n\t * CDS sequence that starts the triplet. This can be used to map\n\t * a CDS/exon region of a protein sequence back to the DNA sequence\n\t * If you have a protein sequence and a predicted gene you can take the\n\t * predict CDS protein sequences and align back to the protein sequence.\n\t * If you have errors in mapping the predicted protein CDS regions to\n\t * an the known protein sequence then you can identify possible errors\n\t * in the prediction\n\t *\n\t * @return\n\t */\n\tpublic ArrayList<ProteinSequence> getProteinCDSSequences() {\n\t\tArrayList<ProteinSequence> proteinSequenceList = new ArrayList<>();\n\t\tfor (int i = 0; i < cdsSequenceList.size(); i++) {\n\t\t\tCDSSequence cdsSequence = cdsSequenceList.get(i);\n\t\t\tString codingSequence = cdsSequence.getCodingSequence();\n\t\t\t//          logger.debug(\"CDS {} {} = {}\", getStrand(), cdsSequence.getPhase(), codingSequence);\n\t\t\tif (this.getStrand() == Strand.NEGATIVE) {\n\t\t\t\tif (cdsSequence.phase == 1) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(1, codingSequence.length());\n\t\t\t\t} else if (cdsSequence.phase == 2) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(2, codingSequence.length());\n\t\t\t\t}\n\t\t\t\tif (i < cdsSequenceList.size() - 1) {\n\t\t\t\t\tCDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n\t\t\t\t\tif (nextCDSSequence.phase == 1) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n\t\t\t\t\t} else if (nextCDSSequence.phase == 2) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (cdsSequence.phase == 1) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(1, codingSequence.length());\n\t\t\t\t} else if (cdsSequence.phase == 2) {\n\t\t\t\t\tcodingSequence = codingSequence.substring(2, codingSequence.length());\n\t\t\t\t}\n\t\t\t\tif (i < cdsSequenceList.size() - 1) {\n\t\t\t\t\tCDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n\t\t\t\t\tif (nextCDSSequence.phase == 1) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n\t\t\t\t\t} else if (nextCDSSequence.phase == 2) {\n\t\t\t\t\t\tString nextCodingSequence = nextCDSSequence.getCodingSequence();\n\t\t\t\t\t\tcodingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//    logger.debug(\"Coding Sequence: {}\", codingSequence);\n\n\t\t\tDNASequence dnaCodingSequence = null;\n\t\t\ttry {\n\t\t\t\tdnaCodingSequence = new DNASequence(codingSequence.toUpperCase());\n\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t// if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n\t\t\t\tlogger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n\t\t\t}\n\t\t\tRNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(TranscriptionEngine.getDefault());\n\t\t\tProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(TranscriptionEngine.getDefault());\n\t\t\tproteinSequence.setAccession(new AccessionID(cdsSequence.getAccession().getID()));\n\t\t\tproteinSequence.setParentDNASequence(cdsSequence, 1, cdsSequence.getLength());\n\t\t\tproteinSequenceList.add(proteinSequence);\n\t\t}\n\t\treturn proteinSequenceList;\n\t}\n\n\t/**\n\t * Get the stitched together CDS sequences then maps to the cDNA\n\t * @return\n\t */\n\tpublic DNASequence getDNACodingSequence() {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (CDSSequence cdsSequence : cdsSequenceList) {\n\t\t\tsb.append(cdsSequence.getCodingSequence());\n\t\t}\n\n\t\tDNASequence dnaSequence = null;\n\t\ttry {\n\t\t\tdnaSequence = new DNASequence(sb.toString().toUpperCase());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n\t\t\tlogger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n\t\t}\n\t\tdnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\t\treturn dnaSequence;\n\t}\n\n\t/**\n\t * Get the protein sequence\n\t * @return\n\t */\n\tpublic ProteinSequence getProteinSequence() {\n\t\treturn getProteinSequence(TranscriptionEngine.getDefault());\n\t}\n\n\t/**\n\t * Get the protein sequence with user defined TranscriptEngine\n\t * @param engine\n\t * @return\n\t */\n\tpublic ProteinSequence getProteinSequence(TranscriptionEngine engine) {\n\t\tDNASequence dnaCodingSequence = getDNACodingSequence();\n\t\tRNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(engine);\n\t\tProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(engine);\n\t\tproteinSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\n\t\treturn proteinSequence;\n\t}\n\n\t/**\n\t * @return the startCodonSequence\n\t */\n\tpublic StartCodonSequence getStartCodonSequence() {\n\t\treturn startCodonSequence;\n\t}\n\n\t/**\n\t * Sets the start codon sequence at given begin /  end location. Note that calling this method multiple times\n\t * will replace any existing value.\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t */\n\tpublic void addStartCodonSequence(AccessionID accession, int begin, int end) {\n\t\tthis.startCodonSequence = new StartCodonSequence(this, begin, end);\n\t\tstartCodonSequence.setAccession(accession);\n\t}\n\n\t/**\n\t * @return the stopCodonSequence\n\t */\n\tpublic StopCodonSequence getStopCodonSequence() {\n\t\treturn stopCodonSequence;\n\t}\n\n\t/**\n\t * Sets the stop codon sequence at given begin /  end location. Note that calling this method multiple times\n\t * will replace any existing value.\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t */\n\tpublic void addStopCodonSequence(AccessionID accession, int begin, int end) {\n\t\tthis.stopCodonSequence = new StopCodonSequence(this, begin, end);\n\t\tstopCodonSequence.setAccession(accession);\n\t}\n}\n","originTest":"package org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass TranscriptSequenceTest {\n    GeneSequence anyGeneSequence;\n    GeneSequence anyNegativeGeneSequence;\n    TranscriptSequence transcriptSeq;\n    TranscriptSequence transcriptNegativeSeq;\n\n\n    @BeforeEach\n    void setUp() throws CompoundNotFoundException {\n        anyGeneSequence = SequenceTestUtils.anyGeneSequence();\n        transcriptSeq = new TranscriptSequence(anyGeneSequence, new AccessionID(\"T5\"), 5, 100);\n        anyNegativeGeneSequence = SequenceTestUtils.any3GeneSequence();\n        transcriptNegativeSeq = new TranscriptSequence(anyNegativeGeneSequence, new AccessionID(\"T3\"), 5, 100);\n    }\n\n    @Nested\n    class AfterValidConstruction {\n        @Test\n        void lengthIsTranscriptLength() {\n            assertEquals(96, transcriptSeq.getLength());\n        }\n\n        @Test\n        void strandIsSameAsGene() {\n            assertEquals(anyGeneSequence.getStrand(), transcriptSeq.getStrand());\n            assertEquals(anyNegativeGeneSequence.getStrand(), transcriptNegativeSeq.getStrand());\n        }\n\n        @Test\n        void CDSListIsEmpty() {\n            assertEquals(0, transcriptSeq.getCDSSequences().size());\n        }\n\n        @Test\n        void equals() {\n            assertTrue(transcriptSeq.equals(transcriptSeq));\n        }\n\n        // whether it's -ve or +ve doesn't affect equals?\n        void equalsDoesntDependOnStrand() {\n            assertTrue(transcriptSeq.equals(transcriptNegativeSeq));\n        }\n\n        @Test\n        void hashcode() {\n            assertTrue(transcriptSeq.hashCode() == (transcriptNegativeSeq.hashCode()));\n        }\n    }\n\n    @Test\n    void addCDS() throws Exception {\n        transcriptSeq.addCDS(new AccessionID(\"b\"), 40, 50, 1);\n        assertEquals(1, transcriptSeq.getCDSSequences().size());\n    }\n\n    @Test\n    void getCDNASeqPositiveStrand() throws Exception {\n        String chrSeq = ChromosomeSequenceTest.CHROMOSOME_SEQ;\n        // must set this to avoid NPE when generating sequence\n\n\n        // make 2 CDS that are contiguous. These can be added in any order and are sorted OK\n        CDSSequence s1 = transcriptSeq.addCDS(new AccessionID(\"a\"), 11, 20, 1);\n        assertEquals(chrSeq, s1.getSequenceAsString());\n\n        CDSSequence s2 = transcriptSeq.addCDS(new AccessionID(\"b\"), 1, 10, 1);\n        assertEquals(chrSeq, s2.getSequenceAsString());\n\n        DNASequence cDNA = transcriptSeq.getDNACodingSequence();\n        assertEquals(chrSeq.substring(0, 20), cDNA.getSequenceAsString());\n        assertEquals(20, cDNA.getLength());\n    }\n\n    @Test\n    @Disabled(\"is reversed, not complemented?\")\n    void getCDNASeqNegativeStrand() throws Exception {\n        TranscriptSequence ts = SequenceTestUtils.transcriptFromSequence(\"AAAAACCCCCTTTTGGGGGG\", 3, 10, Strand.NEGATIVE);\n        CDSSequence s2 = ts.addCDS(new AccessionID(\"b\"), 1, 10, 0);\n        // this should be GGGGGTTTTT( ie the reverse complement of the chromosome sequence,\n        // but is just reversed and generates CCCCCAAAAA\n        //assertEquals(\"GGGGGTTTTT\", ts.getDNACodingSequence());\n    }\n\n    @Test\n    void removeCDS() throws Exception {\n        transcriptSeq.addCDS(new AccessionID(\"a\"), 50, 60, 1);\n        assertEquals(1, transcriptSeq.getCDSSequences().size());\n        // throws NPE\n        transcriptSeq.removeCDS(\"a\");\n        assertEquals(0, transcriptSeq.getCDSSequences().size());\n    }\n\n    @Test\n    void addGetStartCodonSequence () {\n        assertNull(transcriptSeq.getStartCodonSequence());\n        transcriptSeq.addStartCodonSequence(new AccessionID(\"cds\"), 40,42);\n        StartCodonSequence scs = transcriptSeq.getStartCodonSequence();\n        assertEquals(3, scs.getLength());\n    }\n\n    @Test\n    void addGetStopCodonSequence () {\n        assertNull(transcriptSeq.getStopCodonSequence());\n        transcriptSeq.addStopCodonSequence(new AccessionID(\"cds\"), 40,42);\n        StopCodonSequence scs = transcriptSeq.getStopCodonSequence();\n        assertEquals(3, scs.getLength());\n    }\n}","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":false}