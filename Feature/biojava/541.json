{"repository":"biojava","prod_path":"biojava-phylo/src/main/java/org/biojava/nbio/phylo/DistanceTreeEvaluator.java","test_path":"biojava-phylo/src/test/java/org/biojava/nbio/phylo/TestDistanceTreeEvaluator.java","prod_time":"2016-03-10 01:48:12","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"2bb02718aa803d1d6bbe82ef36a261c5069d556e","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.biojava.nbio.phylo;\n\nimport org.forester.evoinference.matrix.distance.DistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Check the accuracy of a Distance Tree by least squares error (LSE) of the\n * Tree branch lengths and the original Distance Matrix.\n *\n * @author Scooter Willis\n * @author Aleix Lafita\n *\n */\npublic class DistanceTreeEvaluator {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(DistanceTreeEvaluator.class);\n\n\t/** Prevent instantiation */\n\tprivate DistanceTreeEvaluator() {\n\t}\n\n\t/**\n\t * Evaluate the goodness of fit of a given tree to the original distance\n\t * matrix. The returned value is the coefficient of variation, i.e. the\n\t * square root of the LS error normalized by the mean.\n\t * <p>\n\t * This measure can also give an estimate of the quality of the distance\n\t * matrix, because a bad fit may mean that the distance is non-additive.\n\t *\n\t * @param tree\n\t *            Phylogenetic Distance Tree to evaluate\n\t * @param matrix\n\t *            Distance Matrix with the original distances\n\t * @return the square root of the average tree LS error normalized by the\n\t *         average tree distance (coefficient of variation, CV).\n\t */\n\tpublic static double evaluate(Phylogeny tree, DistanceMatrix matrix) {\n\t\tint numSequences = matrix.getSize();\n\t\tList<PhylogenyNode> externalNodes = tree.getExternalNodes();\n\t\tHashMap<String, PhylogenyNode> externalNodesHashMap = new HashMap<String, PhylogenyNode>();\n\t\tSet<PhylogenyNode> path = new HashSet<PhylogenyNode>();\n\n\t\tfor (PhylogenyNode node : externalNodes) {\n\t\t\texternalNodesHashMap.put(node.getName(), node);\n\t\t}\n\t\tint count = 0;\n\t\tdouble averageMatrixDistance = 0.0;\n\t\tdouble averageTreeDistance = 0.0;\n\t\tdouble averageTreeErrorDistance = 0.0;\n\t\tfor (int row = 0; row < numSequences - 1; row++) {\n\t\t\tString nodeName1 = matrix.getIdentifier(row);\n\t\t\tPhylogenyNode node1 = externalNodesHashMap.get(nodeName1);\n\t\t\tmarkPathToRoot(node1, path);\n\t\t\tfor (int col = row + 1; col < numSequences; col++) {\n\t\t\t\tcount++;\n\t\t\t\tString nodeName2 = matrix.getIdentifier(col);\n\t\t\t\tPhylogenyNode node2 = externalNodesHashMap.get(nodeName2);\n\t\t\t\tdouble distance = matrix.getValue(col, row);\n\t\t\t\taverageMatrixDistance = averageMatrixDistance + distance;\n\t\t\t\tPhylogenyNode commonParent = findCommonParent(node2, path);\n\t\t\t\tif (commonParent != null) {\n\t\t\t\t\tdouble treeDistance = getNodeDistance(commonParent, node1)\n\t\t\t\t\t\t\t+ getNodeDistance(commonParent, node2);\n\n\t\t\t\t\taverageTreeDistance += treeDistance;\n\t\t\t\t\taverageTreeErrorDistance += (distance - treeDistance)\n\t\t\t\t\t\t\t* (distance - treeDistance);\n\t\t\t\t\tlogger.info(\"{} {} Distance: {}Tree: {} difference: {}\",\n\t\t\t\t\t\t\tnodeName1, nodeName2, distance, treeDistance,\n\t\t\t\t\t\t\tMath.abs(distance - treeDistance));\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"Unable to find common parent with {} {}\",\n\t\t\t\t\t\t\tnode1, node2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.clear();\n\t\t}\n\t\taverageMatrixDistance /= count;\n\t\taverageTreeDistance /= count;\n\t\taverageTreeErrorDistance /= count;\n\n\t\tlogger.info(\"Average matrix distance: {}\", averageMatrixDistance);\n\t\tlogger.info(\"Average tree distance: {}\", averageTreeDistance);\n\t\tlogger.info(\"Average LS error: {}\", averageTreeErrorDistance);\n\n\t\treturn Math.sqrt(averageTreeErrorDistance) / averageMatrixDistance;\n\t}\n\n\tprivate static double getNodeDistance(PhylogenyNode parentNode,\n\t\t\tPhylogenyNode childNode) {\n\t\tdouble distance = 0.0;\n\t\twhile (childNode != parentNode) {\n\t\t\tdistance = distance + childNode.getDistanceToParent();\n\t\t\tchildNode = childNode.getParent();\n\t\t}\n\n\t\treturn distance;\n\t}\n\n\tprivate static PhylogenyNode findCommonParent(PhylogenyNode node,\n\t\t\tSet<PhylogenyNode> path) {\n\t\twhile (!path.contains(node)) {\n\t\t\tnode = node.getParent();\n\t\t}\n\t\treturn node;\n\t}\n\n\tprivate static void markPathToRoot(PhylogenyNode node,\n\t\t\tSet<PhylogenyNode> path) {\n\t\tpath.add(node);\n\t\twhile (!node.isRoot()) {\n\t\t\tnode = node.getParent();\n\t\t\tpath.add(node);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.phylo;\n\nimport org.forester.evoinference.matrix.distance.DistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Check the accuracy of a Distance Tree by least squares error (LSE) of the\n * Tree branch lengths and the original Distance Matrix.\n *\n * @author Scooter Willis\n * @author Aleix Lafita\n *\n */\npublic class DistanceTreeEvaluator {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(DistanceTreeEvaluator.class);\n\n\t/** Prevent instantiation */\n\tprivate DistanceTreeEvaluator() {\n\t}\n\n\t/**\n\t * Evaluate the goodness of fit of a given tree to the original distance\n\t * matrix. The returned value is the coefficient of variation, i.e. the\n\t * square root of the LS error normalized by the mean.\n\t * <p>\n\t * This measure can also give an estimate of the quality of the distance\n\t * matrix, because a bad fit may mean that the distance is non-additive.\n\t *\n\t * @param tree\n\t *            Phylogenetic Distance Tree to evaluate\n\t * @param matrix\n\t *            Distance Matrix with the original distances\n\t * @return the square root of the average tree LS error normalized by the\n\t *         average tree distance (coefficient of variation, CV).\n\t */\n\tpublic static double evaluate(Phylogeny tree, DistanceMatrix matrix) {\n\t\tint numSequences = matrix.getSize();\n\t\tList<PhylogenyNode> externalNodes = tree.getExternalNodes();\n\t\tHashMap<String, PhylogenyNode> externalNodesHashMap = new HashMap<String, PhylogenyNode>();\n\t\tSet<PhylogenyNode> path = new HashSet<PhylogenyNode>();\n\n\t\tfor (PhylogenyNode node : externalNodes) {\n\t\t\texternalNodesHashMap.put(node.getName(), node);\n\t\t}\n\t\tint count = 0;\n\t\tdouble averageMatrixDistance = 0.0;\n\t\tdouble averageTreeDistance = 0.0;\n\t\tdouble averageTreeErrorDistance = 0.0;\n\t\tfor (int row = 0; row < numSequences - 1; row++) {\n\t\t\tString nodeName1 = matrix.getIdentifier(row);\n\t\t\tPhylogenyNode node1 = externalNodesHashMap.get(nodeName1);\n\t\t\tmarkPathToRoot(node1, path);\n\t\t\tfor (int col = row + 1; col < numSequences; col++) {\n\t\t\t\tcount++;\n\t\t\t\tString nodeName2 = matrix.getIdentifier(col);\n\t\t\t\tPhylogenyNode node2 = externalNodesHashMap.get(nodeName2);\n\t\t\t\tdouble distance = matrix.getValue(col, row);\n\t\t\t\taverageMatrixDistance = averageMatrixDistance + distance;\n\t\t\t\tPhylogenyNode commonParent = findCommonParent(node2, path);\n\t\t\t\tif (commonParent != null) {\n\t\t\t\t\tdouble treeDistance = getNodeDistance(commonParent, node1)\n\t\t\t\t\t\t\t+ getNodeDistance(commonParent, node2);\n\n\t\t\t\t\taverageTreeDistance += treeDistance;\n\t\t\t\t\taverageTreeErrorDistance += (distance - treeDistance)\n\t\t\t\t\t\t\t* (distance - treeDistance);\n\t\t\t\t\tlogger.info(\"{} {} Distance: {}Tree: {} difference: {}\",\n\t\t\t\t\t\t\tnodeName1, nodeName2, distance, treeDistance,\n\t\t\t\t\t\t\tMath.abs(distance - treeDistance));\n\t\t\t\t} else {\n\t\t\t\t\tlogger.warn(\"Unable to find common parent with {} {}\",\n\t\t\t\t\t\t\tnode1, node2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.clear();\n\t\t}\n\t\taverageMatrixDistance /= count;\n\t\taverageTreeDistance /= count;\n\t\taverageTreeErrorDistance /= count;\n\n\t\tlogger.info(\"Average matrix distance: {}\", averageMatrixDistance);\n\t\tlogger.info(\"Average tree distance: {}\", averageTreeDistance);\n\t\tlogger.info(\"Average LS error: {}\", averageTreeErrorDistance);\n\n\t\treturn Math.sqrt(averageTreeErrorDistance) / averageMatrixDistance;\n\t}\n\n\tprivate static double getNodeDistance(PhylogenyNode parentNode,\n\t\t\tPhylogenyNode childNode) {\n\t\tdouble distance = 0.0;\n\t\twhile (childNode != parentNode) {\n\t\t\tdistance = distance + childNode.getDistanceToParent();\n\t\t\tchildNode = childNode.getParent();\n\t\t}\n\n\t\treturn distance;\n\t}\n\n\tprivate static PhylogenyNode findCommonParent(PhylogenyNode node,\n\t\t\tSet<PhylogenyNode> path) {\n\t\twhile (!path.contains(node)) {\n\t\t\tnode = node.getParent();\n\t\t}\n\t\treturn node;\n\t}\n\n\tprivate static void markPathToRoot(PhylogenyNode node,\n\t\t\tSet<PhylogenyNode> path) {\n\t\tpath.add(node);\n\t\twhile (!node.isRoot()) {\n\t\t\tnode = node.getParent();\n\t\t\tpath.add(node);\n\t\t}\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.phylo;\n\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test for the evaluation of distance trees.\n *\n * @author Aleix Lafita\n *\n */\npublic class TestDistanceTreeEvaluator {\n\n\t@Test\n\tpublic void testErrorFree() throws Exception {\n\n\t\t// Create a perfect additive distance matrix\n\t\tBasicSymmetricalDistanceMatrix DM = new BasicSymmetricalDistanceMatrix(\n\t\t\t\t3);\n\n\t\t// dAB = 0.8, dBC = 0.4, dAC = 0.8\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tchar id = (char) ('A' + i);\n\t\t\tDM.setIdentifier(i, id + \"\");\n\t\t\tfor (int j = i; j < 3; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tDM.setValue(i, j, 0.0);\n\t\t\t\t} else if (i == 0) {\n\t\t\t\t\tDM.setValue(i, j, 0.8);\n\t\t\t\t} else {\n\t\t\t\t\tDM.setValue(i, j, 0.4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Calculate error free tree and get the cv\n\t\tPhylogeny tree = TreeConstructor.distanceTree(\n\t\t\t\tForesterWrapper.cloneDM(DM), TreeConstructorType.NJ);\n\t\tdouble cv = DistanceTreeEvaluator.evaluate(tree, DM);\n\n\t\t// Assert error free\n\t\tassertEquals(0.0, cv, 0.001);\n\t}\n\n\t@Test\n\tpublic void testErrorEstimation() throws Exception {\n\n\t\t// Matrix taken from forester test\n\t\tBasicSymmetricalDistanceMatrix m = new BasicSymmetricalDistanceMatrix(4);\n\t\tm.setIdentifier(0, \"A\");\n\t\tm.setIdentifier(1, \"B\");\n\t\tm.setIdentifier(2, \"C\");\n\t\tm.setIdentifier(3, \"D\");\n\t\tm.setRow(\"0 1 0 1\", 0);\n\t\tm.setRow(\"1 0 0 1\", 1);\n\t\tm.setRow(\"0 0 0 1\", 2);\n\t\tm.setRow(\"1 1 1 0\", 3);\n\n\t\t// Calculate error free tree and get the cv\n\t\tPhylogeny tree = TreeConstructor.distanceTree(\n\t\t\t\tForesterWrapper.cloneDM(m), TreeConstructorType.NJ);\n\t\tdouble cv = DistanceTreeEvaluator.evaluate(tree, m);\n\n\t\t// Assert error is about 30%\n\t\tassertEquals(0.3, cv, 0.05);\n\n\t}\n}\n","changedTest":"","commitMessage":"Removing template messages\n","test_commitMessage":"","allZero":true}