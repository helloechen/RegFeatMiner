{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/Calc.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestCalc.java","prod_time":"2015-07-20 20:45:08","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"NEGATIVE","prod_commitID":"8f2ef0903a0542a1143b39589c317086353ad47c","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 08.05.2004\n *\n */\n\n\npackage org.biojava.nbio.structure ;\n\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\n\n\n/** utility operations on Atoms, AminoAcids, etc.\n * <p>\n * Currently the\n * coordinates of an Atom are stored as an array of size 3\n * (double[3]). It would be more powerful to use Point3D from\n * javax.vecmath.  but unfortunately this is not a part of standard\n * java installations, since it comes with java3d . So to keep things\n * simple at the moment biojava does not depend on java3d.\n * </p>\n * @author Andreas Prlic\n * @since 1.4\n * @version %I% %G%\n */\n\npublic class Calc {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(Calc.class);\n\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\t\n\t */\n\tpublic static final double getDistance(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\n\t\treturn Math.sqrt(s);\n\t}\n\n\n\t/**\n\t * Will calculate the *square* of distances between two atoms. This will be\n\t * faster as it will not perform the final square root to get the actual\n\t * distance. Use this if doing large numbers of distance comparisons - it is\n\t * marginally faster than getDistance().\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t */\n\tpublic static double getDistanceFast(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\treturn x * x  + y * y + z * z;\n\t}\n\n\tpublic static final Atom invert(Atom a) {\n\t\tdouble[] coords = new double[]{0.0,0.0,0.0} ;\n\t\tAtom zero = new AtomImpl();\n\t\tzero.setCoords(coords);\n\t\treturn subtract(zero, a);\n\t}\n\n\n\t/** add two atoms ( a + b).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom add(Atom a, Atom b){\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getX() + b.getX() );\n\t\tc.setY( a.getY() + b.getY() );\n\t\tc.setZ( a.getZ() + b.getZ() );\n\n\t\treturn c ;\n\t}\n\n\n\n\t/** subtract two atoms ( a - b).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return n new Atom object representing the difference\n\n\n\t */\n\tpublic static final Atom subtract(Atom a, Atom b) {\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getX() - b.getX() );\n\t\tc.setY( a.getY() - b.getY() );\n\t\tc.setZ( a.getZ() - b.getZ() );\n\n\t\treturn c ;\n\t}\n\n\t/** Vector product (cross product).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom vectorProduct(Atom a , Atom b){\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getY() * b.getZ() - a.getZ() * b.getY() ) ;\n\t\tc.setY( a.getZ() * b.getX() - a.getX() * b.getZ() ) ;\n\t\tc.setZ( a.getX() * b.getY() - a.getY() * b.getX() ) ;\n\t\treturn c ;\n\n\t}\n\n\t/**\n\t * Scalar product (dot product).\n\t *\n\t * @param a an Atom object\n\t * @param b an Atom object\n\t * @return a double\n\t */\n\tpublic static final double scalarProduct(Atom a, Atom b) {\n\t\treturn a.getX() * b.getX() + a.getY() * b.getY() + a.getZ() * b.getZ();\n\t}\n\n\t/** \n\t * Gets the length of the vector (2-norm)\n\t *\n\t * @param a  an Atom object\n\t * @return Square root of the sum of the squared elements\n\t */\n\tpublic static final double amount(Atom a){\n\t\treturn Math.sqrt(scalarProduct(a,a));\n\t}\n\n\t/** \n\t * Gets the angle between two vectors\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return Angle between a and b in degrees, in range [0,180]. \n\t * If either vector has length 0 then angle is not defined and NaN is returned \n\t */\n\tpublic static final double angle(Atom a, Atom b){\n\n\t\t\n\t\tVector3d va = new Vector3d(a.getCoords());\n\t\tVector3d vb = new Vector3d(b.getCoords());\n\t\t\n\t\treturn Math.toDegrees(va.angle(vb));\n\t\t\n\t}\n\n\t/** \n\t * Returns the unit vector of vector a .\n\t *\n\t * @param a  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom unitVector(Atom a) {\n\t\tdouble amount = amount(a) ;\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = a.getX() / amount ;\n\t\tcoords[1] = a.getY() / amount ;\n\t\tcoords[2] = a.getZ() / amount ;\n\n\t\ta.setCoords(coords);\n\t\treturn a;\n\n\t}\n\n\t/**\n\t * Calculate the torsion angle, i.e. the angle between the normal vectors of the \n\t * two plains a-b-c and b-c-d.\n\t * See http://en.wikipedia.org/wiki/Dihedral_angle\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @param c  an Atom object\n\t * @param d  an Atom object\n\t * @return the torsion angle in degrees, in range +-[0,180]. \n\t * If either first 3 or last 3 atoms are colinear then torsion angle is not defined and NaN is returned\n\t */\n\tpublic static final double torsionAngle(Atom a, Atom b, Atom c, Atom d) {\n\n\t\tAtom ab = subtract(a,b);\n\t\tAtom cb = subtract(c,b);\n\t\tAtom bc = subtract(b,c);\n\t\tAtom dc = subtract(d,c);\n\n\t\tAtom abc = vectorProduct(ab,cb);\n\t\tAtom bcd = vectorProduct(bc,dc);\n\n\t\tdouble angl = angle(abc,bcd) ;\n\n\t\t/* calc the sign: */\n\t\tAtom vecprod = vectorProduct(abc,bcd);\n\t\tdouble val = scalarProduct(cb,vecprod);\n\t\tif (val<0.0) angl = -angl ;\n\n\t\treturn angl;\n\t}\n\n\t/**\n\t * Calculate the phi angle.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return a double\n\t * @throws StructureException if aminoacids not connected or if any of the 4 needed atoms missing\n\t */\n\tpublic static final double getPhi(AminoAcid a, AminoAcid b) throws StructureException {\n\n\t\tif ( ! isConnected(a,b)){\n\t\t\tthrow new StructureException(\"can not calc Phi - AminoAcids are not connected!\") ;\n\t\t}\n\n\t\tAtom a_C  = a.getC();\n\t\tAtom b_N  = b.getN();\n\t\tAtom b_CA = b.getCA();\n\t\tAtom b_C  = b.getC();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (b_CA==null) throw new StructureException(\"Can not calculate Phi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_C,b_N,b_CA,b_C);\n\t}\n\n\t/**\n\t * Calculate the psi angle.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return a double\n\t * @throws StructureException if aminoacids not connected or if any of the 4 needed atoms missing\n\t */\n\tpublic static final double getPsi(AminoAcid a, AminoAcid b) throws StructureException {\n\t\tif ( ! isConnected(a,b)) {\n\t\t\tthrow new StructureException(\"can not calc Psi - AminoAcids are not connected!\") ;\n\t\t}\n\n\t\tAtom a_N   = a.getN();\n\t\tAtom a_CA  = a.getCA();\n\t\tAtom a_C   = a.getC();\n\t\tAtom b_N   = b.getN();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (a_CA==null) throw new StructureException(\"Can not calculate Psi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_N,a_CA,a_C,b_N);\n\n\t}\n\n\t/**\n\t * Test if two amino acids are connected, i.e.\n\t * if the distance from C to N < 2.5 Angstrom.\n\t *\n\t * If one of the AminoAcids has an atom missing, returns false.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return true if ...\n\t */\n\tpublic static final boolean isConnected(AminoAcid a, AminoAcid b) {\n\t\tAtom C = null ;\n\t\tAtom N = null;\n\n\t\tC = a.getC();\n\t\tN = b.getN();\n\n\t\tif ( C == null || N == null)\n\t\t\treturn false;\n\n\t\t// one could also check if the CA atoms are < 4 A...\n\t\tdouble distance = getDistance(C,N);\n\t\treturn distance < 2.5;\n\t}\n\n\n\n\t/** rotate a single atom aroud a rotation matrix.\n\t * matrix must be a 3x3 matrix.\n\t *\n\t * If the matrix is indexed m[row][col], then the matrix will be\n\t * pre-multiplied (y=atom*M)\n\t * @param atom atom to be rotated\n\t * @param m a rotation matrix represented as a double[3][3] array\n\t */\n\tpublic static final void rotate(Atom atom, double[][] m){\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY() ;\n\t\tdouble z = atom.getZ();\n\n\t\tdouble nx = m[0][0] * x + m[0][1] * y +  m[0][2] * z ;\n\t\tdouble ny = m[1][0] * x + m[1][1] * y +  m[1][2] * z ;\n\t\tdouble nz = m[2][0] * x + m[2][1] * y +  m[2][2] * z ;\n\n\n\t\tatom.setX(nx);\n\t\tatom.setY(ny);\n\t\tatom.setZ(nz);\n\t}\n\n\t/** Rotate a structure.\n\t *\n\t * @param structure a Structure object\n\t * @param rotationmatrix an array (3x3) of double representing the rotation matrix. \n\t * @throws StructureException ...\n\t */\n\tpublic static final void rotate(Structure structure, double[][] rotationmatrix)\n\t\t\tthrows StructureException\n\t{\n\t\tif ( rotationmatrix.length != 3 ) {\n\t\t\tthrow new StructureException (\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\tCalc.rotate(atom,rotationmatrix);\n\t\t}\n\t}\n\n\t/** rotate a structure .\n\t *\n\t * @param group a group object\n\t * @param rotationmatrix an array (3x3) of double representing the rotation matrix. \n\t * @throws StructureException ...\n\t */\n\tpublic static final void rotate(Group group, double[][] rotationmatrix) throws StructureException {\n\n\t\tif ( rotationmatrix.length != 3 ) {\n\t\t\tthrow new StructureException (\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next() ;\n\t\t\trotate(atom,rotationmatrix);\n\n\t\t}\n\t}\n\n\t/** Rotate an atom around a Matrix object.\n\t *\n\t * @param atom atom to be rotated\n\t * @param m rotation matrix to be applied to the atom\n\t */\n\tpublic static final void rotate(Atom atom, Matrix m){\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY() ;\n\t\tdouble z = atom.getZ();\n\t\tdouble[][] ad = new double[][]{{x,y,z}};\n\n\t\tMatrix am = new Matrix(ad);\n\t\tMatrix na = am.times(m);\n\n\t\tatom.setX(na.get(0,0));\n\t\tatom.setY(na.get(0,1));\n\t\tatom.setZ(na.get(0,2));\n\n\t}\n\n\t/** Rotate a group object.\n\t *\n\t * @param group  a group to be rotated\n\t * @param m a Matrix object representing the rotation matrix\n\t */\n\tpublic static final void rotate(Group group, Matrix m){\n\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\trotate(atom,m);\n\n\t\t}\n\n\t}\n\n\t/** Rotate a structure object.\n\t *\n\t * @param structure the structure to be rotated\n\t * @param m rotation matrix to be applied \n\t */\n\tpublic static final void rotate(Structure structure, Matrix m){\n\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\trotate(atom,m);\n\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Transform an array of atoms at once.\n\t * @param ca array of Atoms to shift\n\t * @param t transformation Matrix4d\n\t */\n\tpublic static void transform(Atom[] ca, Matrix4d t) {\n\t\tfor (Atom atom : ca) Calc.transform(atom, t);\n\t}\n\n\t/**\n\t * Transforms an atom object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param atom\n\t * @param m\n\t */\n\tpublic static final void transform (Atom atom, Matrix4d m) {\n\n\t\tPoint3d p = new Point3d(atom.getX(),atom.getY(),atom.getZ());\n\t\tm.transform(p);\n\n\t\tatom.setX(p.x);\n\t\tatom.setY(p.y);\n\t\tatom.setZ(p.z);\n\t}\n\n\t/**\n\t * Transforms a group object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param group\n\t * @param m\n\t */\n\tpublic static final void transform (Group group, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttransform(atom,m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a structure object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param structure\n\t * @param m\n\t */\n\tpublic static final void transform (Structure structure, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttransform(atom,m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a chain object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param chain\n\t * @param m\n\t */\n\tpublic static final void transform (Chain chain, Matrix4d m) {\n\n\t\tfor (Group g:chain.getAtomGroups()) {\n\t\t\tfor (Atom atom: g.getAtoms()) {\n\t\t\t\ttransform(atom,m);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates an atom object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param atom\n\t * @param v\n\t */\n\tpublic static final void translate (Atom atom, Vector3d v) {\n\n\t\tatom.setX(atom.getX()+v.x);\n\t\tatom.setY(atom.getY()+v.y);\n\t\tatom.setZ(atom.getZ()+v.z);\n\t}\n\n\t/**\n\t * Translates a group object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param group\n\t * @param v\n\t */\n\tpublic static final void translate (Group group, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttranslate(atom,v);\n\n\t\t}\n\t}\n\t\n\t/**\n\t * Translates a chain object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param chain\n\t * @param v\n\t */\n\tpublic static final void translate (Chain chain, Vector3d v) {\n\n\t\tfor (Group g:chain.getAtomGroups()) {\n\t\t\tfor (Atom atom: g.getAtoms()) {\n\t\t\t\ttranslate(atom,v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates a Structure object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param structure\n\t * @param v\n\t */\n\tpublic static final void translate (Structure structure, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttranslate(atom,v);\n\n\t\t}\n\t}\n\n\t/** calculate structure + Matrix coodinates ... \n\t *\n\t * @param s the structure to operate on\n\t * @param matrix a Matrix object\n\t */\n\tpublic static final void plus(Structure s, Matrix matrix){\n\t\tAtomIterator iter = new AtomIterator(s) ;\n\t\tAtom oldAtom = null;\n\t\tAtom rotOldAtom = null;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next() ;\n\t\t\ttry {\n\t\t\t\tif ( oldAtom != null){\n\t\t\t\t\tlogger.debug(\"before {}\", getDistance(oldAtom,atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\toldAtom = (Atom)atom.clone();\n\n\t\t\tdouble x = atom.getX();\n\t\t\tdouble y = atom.getY() ;\n\t\t\tdouble z = atom.getZ();\n\t\t\tdouble[][] ad = new double[][]{{x,y,z}};\n\n\t\t\tMatrix am = new Matrix(ad);\n\t\t\tMatrix na = am.plus(matrix);\n\n\t\t\tdouble[] coords = new double[3] ;\n\t\t\tcoords[0] = na.get(0,0);\n\t\t\tcoords[1] = na.get(0,1);\n\t\t\tcoords[2] = na.get(0,2);\n\t\t\tatom.setCoords(coords);\n\t\t\ttry {\n\t\t\t\tif ( rotOldAtom != null){\n\t\t\t\t\tlogger.debug(\"after {}\", getDistance(rotOldAtom,atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\trotOldAtom  = (Atom) atom.clone();\n\t\t}\n\n\t}\n\n\n\n\t/** shift a structure with a vector.\n\t *\n\t * @param structure  a Structure object\n\t * @param a          an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Structure structure, Atom a ){\n\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\t\twhile (iter.hasNext() ) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next()  ;\n\n\t\t\tAtom natom = add(atom,a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY() ;\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/** Shift a vector.\n\t *\n\t * @param a vector a\n\t * @param b vector b\n\t */\n\tpublic static final void shift(Atom a, Atom b){\n\n\t\tAtom natom = add(a,b);\n\t\tdouble x = natom.getX();\n\t\tdouble y = natom.getY() ;\n\t\tdouble z = natom.getZ();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t}\n\n\t/** Shift a Group with a vector.\n\t *\n\t * @param group   a group object\n\t * @param a          an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Group group , Atom a ){\n\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\t\twhile (iter.hasNext() ) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next()  ;\n\n\t\t\tAtom natom = add(atom,a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY() ;\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\n\n\t/** Returns the center  of mass of the set of atoms.\n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t */\n\tpublic static final Atom getCentroid(Atom[] atomSet){\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = 0;\n\t\tcoords[1] = 0;\n\t\tcoords[2] = 0 ;\n\n\t\tfor (Atom a : atomSet) {\n\t\t\tcoords[0] += a.getX();\n\t\t\tcoords[1] += a.getY();\n\t\t\tcoords[2] += a.getZ();\n\t\t}\n\n\t\tint n = atomSet.length;\n\t\tcoords[0] = coords[0] / n;\n\t\tcoords[1] = coords[1] / n;\n\t\tcoords[2] = coords[2] / n;\n\n\t\tAtom vec = new AtomImpl();\n\t\tvec.setCoords(coords);\n\t\treturn vec;\n\n\t}\n\n\tpublic static  Atom centerOfMass(Atom[] points) {\n\t\tAtom center = new AtomImpl();\n\n\t\tfloat totalMass = 0.0f;\n\t\tfor (Atom a : points) {\n\t\t\tfloat mass = a.getElement().getAtomicMass();\n\t\t\ttotalMass += mass;\n\t\t\tcenter = scaleAdd(mass, a, center);\n\t\t}\n\n\t\tcenter = scaleEquals(center, 1.0f/totalMass);\n\t\treturn center;\n\t}\n\n\t/**\n\t * Multiply elements of a by s (in place)\n\t * @param a\n\t * @param s\n\t * @return the modified a\n\t */\n\tpublic static Atom scaleEquals(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tx *= s;\n\t\ty *= s;\n\t\tz *= s;\n\n\t\t//Atom b = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Multiply elements of a by s\n\t * @param a\n\t * @param s\n\t * @return A new Atom with s*a\n\t */\n\tpublic static Atom scale(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(x*s);\n\t\tb.setY(y*s);\n\t\tb.setZ(z*s);\n\n\t\treturn b;\n\t}\n\n\n\t/**\n\t * Perform linear transformation s*X+B, and store the result in b\n\t * @param s Amount to scale x\n\t * @param x Input coordinate\n\t * @param b Vector to translate (will be modified)\n\t * @return b, after modification\n\t */\n\tpublic static Atom scaleAdd(double s, Atom x, Atom b){\n\n\t\tdouble xc = s*x.getX() + b.getX();\n\t\tdouble yc = s*x.getY() + b.getY();\n\t\tdouble zc = s*x.getZ() + b.getZ();\n\n\t\t//Atom a = new AtomImpl();\n\t\tb.setX(xc);\n\t\tb.setY(yc);\n\t\tb.setZ(zc);\n\n\t\treturn b;\n\t}\n\n\t/** Returns the Vector that needs to be applied to shift a set of atoms\n\t * to the Centroid.\n\t * @param atomSet array of Atoms  \n\t * @return the vector needed to shift the set of atoms to its geometric center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet){\n\t\tAtom centroid = getCentroid(atomSet);\n\n\t\treturn getCenterVector(atomSet,centroid);\n\n\t}\n\n\t/** Returns the Vector that needs to be applied to shift a set of atoms\n\t * to the Centroid, if the centroid is already known\n\t * @param atomSet array of Atoms  \n\t * @return the vector needed to shift the set of atoms to its geometric center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet, Atom centroid){\n\n\n\t\tdouble[] coords = new double[3];\n\t\tcoords[0] = 0 - centroid.getX();\n\t\tcoords[1] = 0 - centroid.getY();\n\t\tcoords[2] = 0 - centroid.getZ();\n\n\t\tAtom shiftVec = new AtomImpl();\n\t\tshiftVec.setCoords(coords);\n\t\treturn shiftVec;\n\n\t}\n\n\n\t/** Center the atoms at the Centroid. \n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet) throws StructureException {\n\n\t\tAtom centroid = getCentroid(atomSet);\n\t\treturn centerAtoms(atomSet, centroid);\n\t}\n\n\t/** Center the atoms at the Centroid, if the centroid is already know.\n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet, Atom centroid) throws StructureException {\n\n\t\tAtom shiftVector = getCenterVector(atomSet, centroid);\n\n\t\tAtom[] newAtoms = new AtomImpl[atomSet.length];\n\n\t\tfor (int i =0 ; i < atomSet.length; i++){\n\t\t\tAtom a = atomSet[i];\n\t\t\tAtom n = add(a,shiftVector);\n\t\t\tnewAtoms[i] = n ;\n\t\t}\n\t\treturn newAtoms;\n\t}\n\n\n\n\n\t/** creates a virtual C-beta atom. this might be needed when working with GLY\n\t *\n\t * thanks to Peter Lackner for a python template of this method.\n\t * @param amino the amino acid for which a \"virtual\" CB atom should be calculated \n\t * @return a \"virtual\" CB atom\n\t * @throws StructureException\n\t */\n\tpublic static final Atom createVirtualCBAtom(AminoAcid amino)\n\t\t\tthrows StructureException{\n\n\t\tAminoAcid  ala = StandardAminoAcid.getAminoAcid(\"ALA\");\n\t\tAtom aN  = ala.getN();\n\t\tAtom aCA = ala.getCA();\n\t\tAtom aC  = ala.getC();\n\t\tAtom aCB = ala.getCB();\n\n\n\t\tAtom[] arr1 = new Atom[3];\n\t\tarr1[0] = aN;\n\t\tarr1[1] = aCA;\n\t\tarr1[2] = aC;\n\n\t\tAtom[] arr2 = new Atom[3];\n\t\tarr2[0] = amino.getN();\n\t\tarr2[1] = amino.getCA();\n\t\tarr2[2] = amino.getC();\n\n\t\t// ok now we got the two arrays, do a SVD:\n\n\t\tSVDSuperimposer svd = new SVDSuperimposer(arr2,arr1);\n\n\t\tMatrix rotMatrix = svd.getRotation();\n\t\tAtom tranMatrix = svd.getTranslation();\n\n\t\tCalc.rotate(aCB,rotMatrix);\n\n\t\tAtom virtualCB = Calc.add(aCB,tranMatrix);\n\t\tvirtualCB.setName(\"CB\");\n\n\t\treturn virtualCB;\n\t}\n\n\n\t/**\n\t * Gets euler angles for a matrix given in ZYZ convention.\n\t * (as e.g. used by Jmol)\n\t *\n\t * @param m the rotation matrix\n\t * @return the euler values for a rotation around Z, Y, Z in degrees...\n\t */\n\tpublic static final double[] getZYZEuler(Matrix m) {\n\t\tdouble m22 = m.get(2,2);\n\t\tdouble rY = Math.toDegrees(Math.acos(m22));\n\t\tdouble rZ1, rZ2;\n\t\tif (m22 > .999d || m22 < -.999d) {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(1,0),  m.get(1,1)));\n\t\t\trZ2 = 0;\n\t\t} else {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(2,1), -m.get(2,0)));\n\t\t\trZ2 = Math.toDegrees(Math.atan2(m.get(1,2),  m.get(0,2)));\n\t\t}\n\t\treturn new double[] {rZ1,rY,rZ2};\n\t}\n\n\n\t/** Convert a rotation Matrix to Euler angles.\n\t *   This conversion uses conventions as described on page:\n\t *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t *   Coordinate System: right hand\n\t *   Positive angle: right hand\n\t *   Order of euler angles: heading first, then attitude, then bank\n\t *\n\t * @param m the rotation matrix\n\t * @return a array of three doubles containing the three euler angles in radians\n\t */\n\tpublic static final double[] getXYZEuler(Matrix m){\n\t\tdouble heading, attitude, bank;\n\n\t\t// Assuming the angles are in radians.\n\t\tif (m.get(1,0) > 0.998) { // singularity at north pole\n\t\t\theading = Math.atan2(m.get(0,2),m.get(2,2));\n\t\t\tattitude = Math.PI/2;\n\t\t\tbank = 0;\n\n\t\t} else if  (m.get(1,0) < -0.998) { // singularity at south pole\n\t\t\theading = Math.atan2(m.get(0,2),m.get(2,2));\n\t\t\tattitude = -Math.PI/2;\n\t\t\tbank = 0;\n\n\t\t} else {\n\t\t\theading = Math.atan2(-m.get(2,0),m.get(0,0));\n\t\t\tbank = Math.atan2(-m.get(1,2),m.get(1,1));\n\t\t\tattitude = Math.asin(m.get(1,0));\n\t\t}\n\t\treturn new double[] { heading, attitude, bank };\n\t}\n\n\n\n\t/** This conversion uses NASA standard aeroplane conventions as described on page:\n\t *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t *   Coordinate System: right hand\n\t *   Positive angle: right hand\n\t *   Order of euler angles: heading first, then attitude, then bank.\n\t *   matrix row column ordering:\n\t *   [m00 m01 m02]\n\t *   [m10 m11 m12]\n\t *   [m20 m21 m22]\n\t * @param heading in radians\n\t * @param attitude  in radians\n\t * @param bank  in radians\n\t * @return the rotation matrix */\n\tpublic static final  Matrix matrixFromEuler(double heading, double attitude, double bank) {\n\t\t// Assuming the angles are in radians.\n\t\tdouble ch = Math.cos(heading);\n\t\tdouble sh = Math.sin(heading);\n\t\tdouble ca = Math.cos(attitude);\n\t\tdouble sa = Math.sin(attitude);\n\t\tdouble cb = Math.cos(bank);\n\t\tdouble sb = Math.sin(bank);\n\n\t\tMatrix m = new Matrix(3,3);\n\t\tm.set(0,0, ch * ca);\n\t\tm.set(0,1, sh*sb - ch*sa*cb);\n\t\tm.set(0,2, ch*sa*sb + sh*cb);\n\t\tm.set(1,0, sa);\n\t\tm.set(1,1, ca*cb);\n\t\tm.set(1,2, -ca*sb);\n\t\tm.set(2,0, -sh*ca);\n\t\tm.set(2,1, sh*sa*cb + ch*sb);\n\t\tm.set(2,2, -sh*sa*sb + ch*cb);\n\n\t\treturn m;\n\t}\n\n\n\t/**\n\t * Calculates the angle from centerPt to targetPt in degrees.\n\t * The return should range from [0,360), rotating CLOCKWISE, \n\t * 0 and 360 degrees represents NORTH,\n\t * 90 degrees represents EAST, etc...\n\t *\n\t * Assumes all points are in the same coordinate space.  If they are not, \n\t * you will need to call SwingUtilities.convertPointToScreen or equivalent \n\t * on all arguments before passing them  to this function.\n\t *\n\t * @param centerPt   Point we are rotating around.\n\t * @param targetPt   Point we want to calculate the angle to.  \n\t * @return angle in degrees.  This is the angle from centerPt to targetPt.\n\t */\n\tpublic static double calcRotationAngleInDegrees(Atom centerPt, Atom targetPt)\n\t{\n\t\t// calculate the angle theta from the deltaY and deltaX values\n\t\t// (atan2 returns radians values from [-PI,PI])\n\t\t// 0 currently points EAST.  \n\t\t// NOTE: By preserving Y and X param order to atan2,  we are expecting \n\t\t// a CLOCKWISE angle direction.  \n\t\tdouble theta = Math.atan2(targetPt.getY() - centerPt.getY(), targetPt.getX() - centerPt.getX());\n\n\t\t// rotate the theta angle clockwise by 90 degrees \n\t\t// (this makes 0 point NORTH)\n\t\t// NOTE: adding to an angle rotates it clockwise.  \n\t\t// subtracting would rotate it counter-clockwise\n\t\ttheta += Math.PI/2.0;\n\n\t\t// convert from radians to degrees\n\t\t// this will give you an angle from [0->270],[-180,0]\n\t\tdouble angle = Math.toDegrees(theta);\n\n\t\t// convert to positive range [0-360)\n\t\t// since we want to prevent negative angles, adjust them now.\n\t\t// we can assume that atan2 will not return a negative value\n\t\t// greater than one partial rotation\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\n\tpublic static void main(String[] args){\n\t\tAtom a =new AtomImpl();\n\t\ta.setX(0);\n\t\ta.setY(0);\n\t\ta.setZ(0);\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(1);\n\t\tb.setY(1);\n\t\tb.setZ(0);\n\n\t\tlogger.info(\"Angle between atoms: \", calcRotationAngleInDegrees(a, b));\n\t}\n\n\n\tpublic static void rotate(Atom[] ca, Matrix matrix) {\n\t\tfor (Atom atom : ca) Calc.rotate(atom, matrix);\n\t}\n\t\n\t/**\n\t * Shift an array of atoms at once.\n\t * @param ca array of Atoms to shift\n\t * @param b reference Atom vector\n\t */\n\tpublic static void shift(Atom[] ca, Atom b) {\n\t\tfor (Atom atom : ca) Calc.shift(atom, b);\n\t}\n\t\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix\n\t * @param rot 3x3 Rotation matrix\n\t * @param trans 3x1 Translation matrix\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Matrix trans) {\n\t\treturn new Matrix4d( new Matrix3d(rot.getColumnPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getColumnPackedCopy()),\n\t\t\t\t1.0);\n\t}\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix\n\t * @param rot 3x3 Rotation matrix\n\t * @param trans 3x1 Translation matrix\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Atom trans) {\n\t\treturn new Matrix4d( new Matrix3d(rot.getColumnPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getCoords()),\n\t\t\t\t1.0);\n\t}\n}\n\n\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 08.05.2004\n *\n */\n\n\npackage org.biojava.nbio.structure ;\n\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\n\n\n/** utility operations on Atoms, AminoAcids, etc.\n * <p>\n * Currently the\n * coordinates of an Atom are stored as an array of size 3\n * (double[3]). It would be more powerful to use Point3D from\n * javax.vecmath.  but unfortunately this is not a part of standard\n * java installations, since it comes with java3d . So to keep things\n * simple at the moment biojava does not depend on java3d.\n * </p>\n * @author Andreas Prlic\n * @since 1.4\n * @version %I% %G%\n */\n\npublic class Calc {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(Calc.class);\n\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\t\n\t */\n\tpublic static final double getDistance(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\n\t\treturn Math.sqrt(s);\n\t}\n\n\n\t/**\n\t * Will calculate the *square* of distances between two atoms. This will be\n\t * faster as it will not perform the final square root to get the actual\n\t * distance. Use this if doing large numbers of distance comparisons - it is\n\t * marginally faster than getDistance().\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t */\n\tpublic static double getDistanceFast(Atom a, Atom b) {\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\treturn x * x  + y * y + z * z;\n\t}\n\n\tpublic static final Atom invert(Atom a) {\n\t\tdouble[] coords = new double[]{0.0,0.0,0.0} ;\n\t\tAtom zero = new AtomImpl();\n\t\tzero.setCoords(coords);\n\t\treturn subtract(zero, a);\n\t}\n\n\n\t/** add two atoms ( a + b).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom add(Atom a, Atom b){\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getX() + b.getX() );\n\t\tc.setY( a.getY() + b.getY() );\n\t\tc.setZ( a.getZ() + b.getZ() );\n\n\t\treturn c ;\n\t}\n\n\n\n\t/** subtract two atoms ( a - b).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return n new Atom object representing the difference\n\n\n\t */\n\tpublic static final Atom subtract(Atom a, Atom b) {\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getX() - b.getX() );\n\t\tc.setY( a.getY() - b.getY() );\n\t\tc.setZ( a.getZ() - b.getZ() );\n\n\t\treturn c ;\n\t}\n\n\t/** Vector product (cross product).\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom vectorProduct(Atom a , Atom b){\n\n\t\tAtom c = new AtomImpl();\n\t\tc.setX( a.getY() * b.getZ() - a.getZ() * b.getY() ) ;\n\t\tc.setY( a.getZ() * b.getX() - a.getX() * b.getZ() ) ;\n\t\tc.setZ( a.getX() * b.getY() - a.getY() * b.getX() ) ;\n\t\treturn c ;\n\n\t}\n\n\t/**\n\t * Scalar product (dot product).\n\t *\n\t * @param a an Atom object\n\t * @param b an Atom object\n\t * @return a double\n\t */\n\tpublic static final double scalarProduct(Atom a, Atom b) {\n\t\treturn a.getX() * b.getX() + a.getY() * b.getY() + a.getZ() * b.getZ();\n\t}\n\n\t/** \n\t * Gets the length of the vector (2-norm)\n\t *\n\t * @param a  an Atom object\n\t * @return Square root of the sum of the squared elements\n\t */\n\tpublic static final double amount(Atom a){\n\t\treturn Math.sqrt(scalarProduct(a,a));\n\t}\n\n\t/** \n\t * Gets the angle between two vectors\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return Angle between a and b in degrees, in range [0,180]. \n\t * If either vector has length 0 then angle is not defined and NaN is returned \n\t */\n\tpublic static final double angle(Atom a, Atom b){\n\n\t\t\n\t\tVector3d va = new Vector3d(a.getCoords());\n\t\tVector3d vb = new Vector3d(b.getCoords());\n\t\t\n\t\treturn Math.toDegrees(va.angle(vb));\n\t\t\n\t}\n\n\t/** \n\t * Returns the unit vector of vector a .\n\t *\n\t * @param a  an Atom object\n\t * @return an Atom object\n\t */\n\tpublic static final Atom unitVector(Atom a) {\n\t\tdouble amount = amount(a) ;\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = a.getX() / amount ;\n\t\tcoords[1] = a.getY() / amount ;\n\t\tcoords[2] = a.getZ() / amount ;\n\n\t\ta.setCoords(coords);\n\t\treturn a;\n\n\t}\n\n\t/**\n\t * Calculate the torsion angle, i.e. the angle between the normal vectors of the \n\t * two plains a-b-c and b-c-d.\n\t * See http://en.wikipedia.org/wiki/Dihedral_angle\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @param c  an Atom object\n\t * @param d  an Atom object\n\t * @return the torsion angle in degrees, in range +-[0,180]. \n\t * If either first 3 or last 3 atoms are colinear then torsion angle is not defined and NaN is returned\n\t */\n\tpublic static final double torsionAngle(Atom a, Atom b, Atom c, Atom d) {\n\n\t\tAtom ab = subtract(a,b);\n\t\tAtom cb = subtract(c,b);\n\t\tAtom bc = subtract(b,c);\n\t\tAtom dc = subtract(d,c);\n\n\t\tAtom abc = vectorProduct(ab,cb);\n\t\tAtom bcd = vectorProduct(bc,dc);\n\n\t\tdouble angl = angle(abc,bcd) ;\n\n\t\t/* calc the sign: */\n\t\tAtom vecprod = vectorProduct(abc,bcd);\n\t\tdouble val = scalarProduct(cb,vecprod);\n\t\tif (val<0.0) angl = -angl ;\n\n\t\treturn angl;\n\t}\n\n\t/**\n\t * Calculate the phi angle.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return a double\n\t * @throws StructureException if aminoacids not connected or if any of the 4 needed atoms missing\n\t */\n\tpublic static final double getPhi(AminoAcid a, AminoAcid b) throws StructureException {\n\n\t\tif ( ! isConnected(a,b)){\n\t\t\tthrow new StructureException(\"can not calc Phi - AminoAcids are not connected!\") ;\n\t\t}\n\n\t\tAtom a_C  = a.getC();\n\t\tAtom b_N  = b.getN();\n\t\tAtom b_CA = b.getCA();\n\t\tAtom b_C  = b.getC();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (b_CA==null) throw new StructureException(\"Can not calculate Phi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_C,b_N,b_CA,b_C);\n\t}\n\n\t/**\n\t * Calculate the psi angle.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return a double\n\t * @throws StructureException if aminoacids not connected or if any of the 4 needed atoms missing\n\t */\n\tpublic static final double getPsi(AminoAcid a, AminoAcid b) throws StructureException {\n\t\tif ( ! isConnected(a,b)) {\n\t\t\tthrow new StructureException(\"can not calc Psi - AminoAcids are not connected!\") ;\n\t\t}\n\n\t\tAtom a_N   = a.getN();\n\t\tAtom a_CA  = a.getCA();\n\t\tAtom a_C   = a.getC();\n\t\tAtom b_N   = b.getN();\n\n\t\t// C and N were checked in isConnected already\n\t\tif (a_CA==null) throw new StructureException(\"Can not calculate Psi, CA atom is missing\");\n\n\t\treturn torsionAngle(a_N,a_CA,a_C,b_N);\n\n\t}\n\n\t/**\n\t * Test if two amino acids are connected, i.e.\n\t * if the distance from C to N < 2.5 Angstrom.\n\t *\n\t * If one of the AminoAcids has an atom missing, returns false.\n\t *\n\t * @param a  an AminoAcid object\n\t * @param b  an AminoAcid object\n\t * @return true if ...\n\t */\n\tpublic static final boolean isConnected(AminoAcid a, AminoAcid b) {\n\t\tAtom C = null ;\n\t\tAtom N = null;\n\n\t\tC = a.getC();\n\t\tN = b.getN();\n\n\t\tif ( C == null || N == null)\n\t\t\treturn false;\n\n\t\t// one could also check if the CA atoms are < 4 A...\n\t\tdouble distance = getDistance(C,N);\n\t\treturn distance < 2.5;\n\t}\n\n\n\n\t/** rotate a single atom aroud a rotation matrix.\n\t * matrix must be a 3x3 matrix.\n\t *\n\t * If the matrix is indexed m[row][col], then the matrix will be\n\t * pre-multiplied (y=atom*M)\n\t * @param atom atom to be rotated\n\t * @param m a rotation matrix represented as a double[3][3] array\n\t */\n\tpublic static final void rotate(Atom atom, double[][] m){\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY() ;\n\t\tdouble z = atom.getZ();\n\n\t\tdouble nx = m[0][0] * x + m[0][1] * y +  m[0][2] * z ;\n\t\tdouble ny = m[1][0] * x + m[1][1] * y +  m[1][2] * z ;\n\t\tdouble nz = m[2][0] * x + m[2][1] * y +  m[2][2] * z ;\n\n\n\t\tatom.setX(nx);\n\t\tatom.setY(ny);\n\t\tatom.setZ(nz);\n\t}\n\n\t/** Rotate a structure.\n\t *\n\t * @param structure a Structure object\n\t * @param rotationmatrix an array (3x3) of double representing the rotation matrix. \n\t * @throws StructureException ...\n\t */\n\tpublic static final void rotate(Structure structure, double[][] rotationmatrix)\n\t\t\tthrows StructureException\n\t{\n\t\tif ( rotationmatrix.length != 3 ) {\n\t\t\tthrow new StructureException (\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\tCalc.rotate(atom,rotationmatrix);\n\t\t}\n\t}\n\n\t/** rotate a structure .\n\t *\n\t * @param group a group object\n\t * @param rotationmatrix an array (3x3) of double representing the rotation matrix. \n\t * @throws StructureException ...\n\t */\n\tpublic static final void rotate(Group group, double[][] rotationmatrix) throws StructureException {\n\n\t\tif ( rotationmatrix.length != 3 ) {\n\t\t\tthrow new StructureException (\"matrix does not have size 3x3 !\");\n\t\t}\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next() ;\n\t\t\trotate(atom,rotationmatrix);\n\n\t\t}\n\t}\n\n\t/** Rotate an atom around a Matrix object.\n\t *\n\t * @param atom atom to be rotated\n\t * @param m rotation matrix to be applied to the atom\n\t */\n\tpublic static final void rotate(Atom atom, Matrix m){\n\n\t\tdouble x = atom.getX();\n\t\tdouble y = atom.getY() ;\n\t\tdouble z = atom.getZ();\n\t\tdouble[][] ad = new double[][]{{x,y,z}};\n\n\t\tMatrix am = new Matrix(ad);\n\t\tMatrix na = am.times(m);\n\n\t\tatom.setX(na.get(0,0));\n\t\tatom.setY(na.get(0,1));\n\t\tatom.setZ(na.get(0,2));\n\n\t}\n\n\t/** Rotate a group object.\n\t *\n\t * @param group  a group to be rotated\n\t * @param m a Matrix object representing the rotation matrix\n\t */\n\tpublic static final void rotate(Group group, Matrix m){\n\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\trotate(atom,m);\n\n\t\t}\n\n\t}\n\n\t/** Rotate a structure object.\n\t *\n\t * @param structure the structure to be rotated\n\t * @param m rotation matrix to be applied \n\t */\n\tpublic static final void rotate(Structure structure, Matrix m){\n\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\trotate(atom,m);\n\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Transform an array of atoms at once.\n\t * @param ca array of Atoms to shift\n\t * @param t transformation Matrix4d\n\t */\n\tpublic static void transform(Atom[] ca, Matrix4d t) {\n\t\tfor (Atom atom : ca) Calc.transform(atom, t);\n\t}\n\n\t/**\n\t * Transforms an atom object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param atom\n\t * @param m\n\t */\n\tpublic static final void transform (Atom atom, Matrix4d m) {\n\n\t\tPoint3d p = new Point3d(atom.getX(),atom.getY(),atom.getZ());\n\t\tm.transform(p);\n\n\t\tatom.setX(p.x);\n\t\tatom.setY(p.y);\n\t\tatom.setZ(p.z);\n\t}\n\n\t/**\n\t * Transforms a group object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param group\n\t * @param m\n\t */\n\tpublic static final void transform (Group group, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttransform(atom,m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a structure object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param structure\n\t * @param m\n\t */\n\tpublic static final void transform (Structure structure, Matrix4d m) {\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttransform(atom,m);\n\n\t\t}\n\t}\n\n\t/**\n\t * Transforms a chain object, given a Matrix4d (i.e. the vecmath library \n\t * double-precision 4x4 rotation+translation matrix)\n\t * @param chain\n\t * @param m\n\t */\n\tpublic static final void transform (Chain chain, Matrix4d m) {\n\n\t\tfor (Group g:chain.getAtomGroups()) {\n\t\t\tfor (Atom atom: g.getAtoms()) {\n\t\t\t\ttransform(atom,m);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates an atom object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param atom\n\t * @param v\n\t */\n\tpublic static final void translate (Atom atom, Vector3d v) {\n\n\t\tatom.setX(atom.getX()+v.x);\n\t\tatom.setY(atom.getY()+v.y);\n\t\tatom.setZ(atom.getZ()+v.z);\n\t}\n\n\t/**\n\t * Translates a group object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param group\n\t * @param v\n\t */\n\tpublic static final void translate (Group group, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttranslate(atom,v);\n\n\t\t}\n\t}\n\t\n\t/**\n\t * Translates a chain object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param chain\n\t * @param v\n\t */\n\tpublic static final void translate (Chain chain, Vector3d v) {\n\n\t\tfor (Group g:chain.getAtomGroups()) {\n\t\t\tfor (Atom atom: g.getAtoms()) {\n\t\t\t\ttranslate(atom,v);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Translates a Structure object, given a Vector3d (i.e. the vecmath library \n\t * double-precision 3-d vector)\n\t * @param structure\n\t * @param v\n\t */\n\tpublic static final void translate (Structure structure, Vector3d v) {\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = iter.next() ;\n\t\t\ttranslate(atom,v);\n\n\t\t}\n\t}\n\n\t/** calculate structure + Matrix coodinates ... \n\t *\n\t * @param s the structure to operate on\n\t * @param matrix a Matrix object\n\t */\n\tpublic static final void plus(Structure s, Matrix matrix){\n\t\tAtomIterator iter = new AtomIterator(s) ;\n\t\tAtom oldAtom = null;\n\t\tAtom rotOldAtom = null;\n\t\twhile (iter.hasNext()) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next() ;\n\t\t\ttry {\n\t\t\t\tif ( oldAtom != null){\n\t\t\t\t\tlogger.debug(\"before {}\", getDistance(oldAtom,atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\toldAtom = (Atom)atom.clone();\n\n\t\t\tdouble x = atom.getX();\n\t\t\tdouble y = atom.getY() ;\n\t\t\tdouble z = atom.getZ();\n\t\t\tdouble[][] ad = new double[][]{{x,y,z}};\n\n\t\t\tMatrix am = new Matrix(ad);\n\t\t\tMatrix na = am.plus(matrix);\n\n\t\t\tdouble[] coords = new double[3] ;\n\t\t\tcoords[0] = na.get(0,0);\n\t\t\tcoords[1] = na.get(0,1);\n\t\t\tcoords[2] = na.get(0,2);\n\t\t\tatom.setCoords(coords);\n\t\t\ttry {\n\t\t\t\tif ( rotOldAtom != null){\n\t\t\t\t\tlogger.debug(\"after {}\", getDistance(rotOldAtom,atom));\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t\trotOldAtom  = (Atom) atom.clone();\n\t\t}\n\n\t}\n\n\n\n\t/** shift a structure with a vector.\n\t *\n\t * @param structure  a Structure object\n\t * @param a          an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Structure structure, Atom a ){\n\n\t\tAtomIterator iter = new AtomIterator(structure) ;\n\t\twhile (iter.hasNext() ) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next()  ;\n\n\t\t\tAtom natom = add(atom,a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY() ;\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\t/** Shift a vector.\n\t *\n\t * @param a vector a\n\t * @param b vector b\n\t */\n\tpublic static final void shift(Atom a, Atom b){\n\n\t\tAtom natom = add(a,b);\n\t\tdouble x = natom.getX();\n\t\tdouble y = natom.getY() ;\n\t\tdouble z = natom.getZ();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t}\n\n\t/** Shift a Group with a vector.\n\t *\n\t * @param group   a group object\n\t * @param a          an Atom object representing a shift vector\n\t */\n\tpublic static final void shift(Group group , Atom a ){\n\n\t\tAtomIterator iter = new AtomIterator(group) ;\n\t\twhile (iter.hasNext() ) {\n\t\t\tAtom atom = null ;\n\n\t\t\tatom = iter.next()  ;\n\n\t\t\tAtom natom = add(atom,a);\n\t\t\tdouble x = natom.getX();\n\t\t\tdouble y = natom.getY() ;\n\t\t\tdouble z = natom.getZ();\n\t\t\tatom.setX(x);\n\t\t\tatom.setY(y);\n\t\t\tatom.setZ(z);\n\n\t\t}\n\t}\n\n\n\n\t/** Returns the center  of mass of the set of atoms.\n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t */\n\tpublic static final Atom getCentroid(Atom[] atomSet){\n\n\t\tdouble[] coords = new double[3];\n\n\t\tcoords[0] = 0;\n\t\tcoords[1] = 0;\n\t\tcoords[2] = 0 ;\n\n\t\tfor (Atom a : atomSet) {\n\t\t\tcoords[0] += a.getX();\n\t\t\tcoords[1] += a.getY();\n\t\t\tcoords[2] += a.getZ();\n\t\t}\n\n\t\tint n = atomSet.length;\n\t\tcoords[0] = coords[0] / n;\n\t\tcoords[1] = coords[1] / n;\n\t\tcoords[2] = coords[2] / n;\n\n\t\tAtom vec = new AtomImpl();\n\t\tvec.setCoords(coords);\n\t\treturn vec;\n\n\t}\n\n\tpublic static  Atom centerOfMass(Atom[] points) {\n\t\tAtom center = new AtomImpl();\n\n\t\tfloat totalMass = 0.0f;\n\t\tfor (Atom a : points) {\n\t\t\tfloat mass = a.getElement().getAtomicMass();\n\t\t\ttotalMass += mass;\n\t\t\tcenter = scaleAdd(mass, a, center);\n\t\t}\n\n\t\tcenter = scaleEquals(center, 1.0f/totalMass);\n\t\treturn center;\n\t}\n\n\t/**\n\t * Multiply elements of a by s (in place)\n\t * @param a\n\t * @param s\n\t * @return the modified a\n\t */\n\tpublic static Atom scaleEquals(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tx *= s;\n\t\ty *= s;\n\t\tz *= s;\n\n\t\t//Atom b = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Multiply elements of a by s\n\t * @param a\n\t * @param s\n\t * @return A new Atom with s*a\n\t */\n\tpublic static Atom scale(Atom a, double s) {\n\t\tdouble x = a.getX();\n\t\tdouble y = a.getY();\n\t\tdouble z = a.getZ();\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(x*s);\n\t\tb.setY(y*s);\n\t\tb.setZ(z*s);\n\n\t\treturn b;\n\t}\n\n\n\t/**\n\t * Perform linear transformation s*X+B, and store the result in b\n\t * @param s Amount to scale x\n\t * @param x Input coordinate\n\t * @param b Vector to translate (will be modified)\n\t * @return b, after modification\n\t */\n\tpublic static Atom scaleAdd(double s, Atom x, Atom b){\n\n\t\tdouble xc = s*x.getX() + b.getX();\n\t\tdouble yc = s*x.getY() + b.getY();\n\t\tdouble zc = s*x.getZ() + b.getZ();\n\n\t\t//Atom a = new AtomImpl();\n\t\tb.setX(xc);\n\t\tb.setY(yc);\n\t\tb.setZ(zc);\n\n\t\treturn b;\n\t}\n\n\t/** Returns the Vector that needs to be applied to shift a set of atoms\n\t * to the Centroid.\n\t * @param atomSet array of Atoms  \n\t * @return the vector needed to shift the set of atoms to its geometric center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet){\n\t\tAtom centroid = getCentroid(atomSet);\n\n\t\treturn getCenterVector(atomSet,centroid);\n\n\t}\n\n\t/** Returns the Vector that needs to be applied to shift a set of atoms\n\t * to the Centroid, if the centroid is already known\n\t * @param atomSet array of Atoms  \n\t * @return the vector needed to shift the set of atoms to its geometric center\n\t */\n\tpublic static final Atom getCenterVector(Atom[] atomSet, Atom centroid){\n\n\n\t\tdouble[] coords = new double[3];\n\t\tcoords[0] = 0 - centroid.getX();\n\t\tcoords[1] = 0 - centroid.getY();\n\t\tcoords[2] = 0 - centroid.getZ();\n\n\t\tAtom shiftVec = new AtomImpl();\n\t\tshiftVec.setCoords(coords);\n\t\treturn shiftVec;\n\n\t}\n\n\n\t/** Center the atoms at the Centroid. \n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet) throws StructureException {\n\n\t\tAtom centroid = getCentroid(atomSet);\n\t\treturn centerAtoms(atomSet, centroid);\n\t}\n\n\t/** Center the atoms at the Centroid, if the centroid is already know.\n\t * @param atomSet a set of Atoms\n\t * @return an Atom representing the Centroid of the set of atoms\n\t * @throws StructureException\n\t * */\n\tpublic static final Atom[] centerAtoms(Atom[] atomSet, Atom centroid) throws StructureException {\n\n\t\tAtom shiftVector = getCenterVector(atomSet, centroid);\n\n\t\tAtom[] newAtoms = new AtomImpl[atomSet.length];\n\n\t\tfor (int i =0 ; i < atomSet.length; i++){\n\t\t\tAtom a = atomSet[i];\n\t\t\tAtom n = add(a,shiftVector);\n\t\t\tnewAtoms[i] = n ;\n\t\t}\n\t\treturn newAtoms;\n\t}\n\n\n\n\n\t/** creates a virtual C-beta atom. this might be needed when working with GLY\n\t *\n\t * thanks to Peter Lackner for a python template of this method.\n\t * @param amino the amino acid for which a \"virtual\" CB atom should be calculated \n\t * @return a \"virtual\" CB atom\n\t * @throws StructureException\n\t */\n\tpublic static final Atom createVirtualCBAtom(AminoAcid amino)\n\t\t\tthrows StructureException{\n\n\t\tAminoAcid  ala = StandardAminoAcid.getAminoAcid(\"ALA\");\n\t\tAtom aN  = ala.getN();\n\t\tAtom aCA = ala.getCA();\n\t\tAtom aC  = ala.getC();\n\t\tAtom aCB = ala.getCB();\n\n\n\t\tAtom[] arr1 = new Atom[3];\n\t\tarr1[0] = aN;\n\t\tarr1[1] = aCA;\n\t\tarr1[2] = aC;\n\n\t\tAtom[] arr2 = new Atom[3];\n\t\tarr2[0] = amino.getN();\n\t\tarr2[1] = amino.getCA();\n\t\tarr2[2] = amino.getC();\n\n\t\t// ok now we got the two arrays, do a SVD:\n\n\t\tSVDSuperimposer svd = new SVDSuperimposer(arr2,arr1);\n\n\t\tMatrix rotMatrix = svd.getRotation();\n\t\tAtom tranMatrix = svd.getTranslation();\n\n\t\tCalc.rotate(aCB,rotMatrix);\n\n\t\tAtom virtualCB = Calc.add(aCB,tranMatrix);\n\t\tvirtualCB.setName(\"CB\");\n\n\t\treturn virtualCB;\n\t}\n\n\n\t/**\n\t * Gets euler angles for a matrix given in ZYZ convention.\n\t * (as e.g. used by Jmol)\n\t *\n\t * @param m the rotation matrix\n\t * @return the euler values for a rotation around Z, Y, Z in degrees...\n\t */\n\tpublic static final double[] getZYZEuler(Matrix m) {\n\t\tdouble m22 = m.get(2,2);\n\t\tdouble rY = Math.toDegrees(Math.acos(m22));\n\t\tdouble rZ1, rZ2;\n\t\tif (m22 > .999d || m22 < -.999d) {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(1,0),  m.get(1,1)));\n\t\t\trZ2 = 0;\n\t\t} else {\n\t\t\trZ1 = Math.toDegrees(Math.atan2(m.get(2,1), -m.get(2,0)));\n\t\t\trZ2 = Math.toDegrees(Math.atan2(m.get(1,2),  m.get(0,2)));\n\t\t}\n\t\treturn new double[] {rZ1,rY,rZ2};\n\t}\n\n\n\t/** Convert a rotation Matrix to Euler angles.\n\t *   This conversion uses conventions as described on page:\n\t *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t *   Coordinate System: right hand\n\t *   Positive angle: right hand\n\t *   Order of euler angles: heading first, then attitude, then bank\n\t *\n\t * @param m the rotation matrix\n\t * @return a array of three doubles containing the three euler angles in radians\n\t */\n\tpublic static final double[] getXYZEuler(Matrix m){\n\t\tdouble heading, attitude, bank;\n\n\t\t// Assuming the angles are in radians.\n\t\tif (m.get(1,0) > 0.998) { // singularity at north pole\n\t\t\theading = Math.atan2(m.get(0,2),m.get(2,2));\n\t\t\tattitude = Math.PI/2;\n\t\t\tbank = 0;\n\n\t\t} else if  (m.get(1,0) < -0.998) { // singularity at south pole\n\t\t\theading = Math.atan2(m.get(0,2),m.get(2,2));\n\t\t\tattitude = -Math.PI/2;\n\t\t\tbank = 0;\n\n\t\t} else {\n\t\t\theading = Math.atan2(-m.get(2,0),m.get(0,0));\n\t\t\tbank = Math.atan2(-m.get(1,2),m.get(1,1));\n\t\t\tattitude = Math.asin(m.get(1,0));\n\t\t}\n\t\treturn new double[] { heading, attitude, bank };\n\t}\n\n\n\n\t/** This conversion uses NASA standard aeroplane conventions as described on page:\n\t *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n\t *   Coordinate System: right hand\n\t *   Positive angle: right hand\n\t *   Order of euler angles: heading first, then attitude, then bank.\n\t *   matrix row column ordering:\n\t *   [m00 m01 m02]\n\t *   [m10 m11 m12]\n\t *   [m20 m21 m22]\n\t * @param heading in radians\n\t * @param attitude  in radians\n\t * @param bank  in radians\n\t * @return the rotation matrix */\n\tpublic static final  Matrix matrixFromEuler(double heading, double attitude, double bank) {\n\t\t// Assuming the angles are in radians.\n\t\tdouble ch = Math.cos(heading);\n\t\tdouble sh = Math.sin(heading);\n\t\tdouble ca = Math.cos(attitude);\n\t\tdouble sa = Math.sin(attitude);\n\t\tdouble cb = Math.cos(bank);\n\t\tdouble sb = Math.sin(bank);\n\n\t\tMatrix m = new Matrix(3,3);\n\t\tm.set(0,0, ch * ca);\n\t\tm.set(0,1, sh*sb - ch*sa*cb);\n\t\tm.set(0,2, ch*sa*sb + sh*cb);\n\t\tm.set(1,0, sa);\n\t\tm.set(1,1, ca*cb);\n\t\tm.set(1,2, -ca*sb);\n\t\tm.set(2,0, -sh*ca);\n\t\tm.set(2,1, sh*sa*cb + ch*sb);\n\t\tm.set(2,2, -sh*sa*sb + ch*cb);\n\n\t\treturn m;\n\t}\n\n\n\t/**\n\t * Calculates the angle from centerPt to targetPt in degrees.\n\t * The return should range from [0,360), rotating CLOCKWISE, \n\t * 0 and 360 degrees represents NORTH,\n\t * 90 degrees represents EAST, etc...\n\t *\n\t * Assumes all points are in the same coordinate space.  If they are not, \n\t * you will need to call SwingUtilities.convertPointToScreen or equivalent \n\t * on all arguments before passing them  to this function.\n\t *\n\t * @param centerPt   Point we are rotating around.\n\t * @param targetPt   Point we want to calculate the angle to.  \n\t * @return angle in degrees.  This is the angle from centerPt to targetPt.\n\t */\n\tpublic static double calcRotationAngleInDegrees(Atom centerPt, Atom targetPt)\n\t{\n\t\t// calculate the angle theta from the deltaY and deltaX values\n\t\t// (atan2 returns radians values from [-PI,PI])\n\t\t// 0 currently points EAST.  \n\t\t// NOTE: By preserving Y and X param order to atan2,  we are expecting \n\t\t// a CLOCKWISE angle direction.  \n\t\tdouble theta = Math.atan2(targetPt.getY() - centerPt.getY(), targetPt.getX() - centerPt.getX());\n\n\t\t// rotate the theta angle clockwise by 90 degrees \n\t\t// (this makes 0 point NORTH)\n\t\t// NOTE: adding to an angle rotates it clockwise.  \n\t\t// subtracting would rotate it counter-clockwise\n\t\ttheta += Math.PI/2.0;\n\n\t\t// convert from radians to degrees\n\t\t// this will give you an angle from [0->270],[-180,0]\n\t\tdouble angle = Math.toDegrees(theta);\n\n\t\t// convert to positive range [0-360)\n\t\t// since we want to prevent negative angles, adjust them now.\n\t\t// we can assume that atan2 will not return a negative value\n\t\t// greater than one partial rotation\n\t\tif (angle < 0) {\n\t\t\tangle += 360;\n\t\t}\n\n\t\treturn angle;\n\t}\n\n\n\tpublic static void main(String[] args){\n\t\tAtom a =new AtomImpl();\n\t\ta.setX(0);\n\t\ta.setY(0);\n\t\ta.setZ(0);\n\n\t\tAtom b = new AtomImpl();\n\t\tb.setX(1);\n\t\tb.setY(1);\n\t\tb.setZ(0);\n\n\t\tlogger.info(\"Angle between atoms: \", calcRotationAngleInDegrees(a, b));\n\t}\n\n\n\tpublic static void rotate(Atom[] ca, Matrix matrix) {\n\t\tfor (Atom atom : ca) Calc.rotate(atom, matrix);\n\t}\n\t\n\t/**\n\t * Shift an array of atoms at once.\n\t * @param ca array of Atoms to shift\n\t * @param b reference Atom vector\n\t */\n\tpublic static void shift(Atom[] ca, Atom b) {\n\t\tfor (Atom atom : ca) Calc.shift(atom, b);\n\t}\n\t\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix\n\t * @param rot 3x3 Rotation matrix\n\t * @param trans 3x1 Translation matrix\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Matrix trans) {\n\t\treturn new Matrix4d( new Matrix3d(rot.getRowPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getColumnPackedCopy()),\n\t\t\t\t1.0);\n\t}\n\t\n\t/**\n\t * Convert JAMA rotation and translation to a Vecmath transformation matrix\n\t * @param rot 3x3 Rotation matrix\n\t * @param trans 3x1 Translation matrix\n\t * @return 4x4 transformation matrix\n\t */\n\tpublic static Matrix4d getTransformation(Matrix rot, Atom trans) {\n\t\treturn new Matrix4d( new Matrix3d(rot.getRowPackedCopy()),\n\t\t\t\tnew Vector3d(trans.getCoords()),\n\t\t\t\t1.0);\n\t}\n}\n","originTest":"package org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport org.junit.Test;\n\npublic class TestCalc {\n\n\t@Test\n\tpublic void testAngle() {\n\t\tAtom a = getAtom(1,1,1);\n\t\t\n\t\tAtom b = getAtom(2,2,2);\n\t\t\n\t\t// 2 parallel vectors should return 0\n\t\tassertEquals(0.0, Calc.angle(a, b),0.00001);\n\t\t\n\t\t// range should be [0,180]\n\t\tAtom ref = getAtom(1,0,0);\n\t\tAtom a1 = getAtom(1,1,0);\n\t\tAtom a2 = getAtom(0,1,0);\n\t\tAtom a3 = getAtom(-1,1,0);\n\t\tAtom a4 = getAtom(-1,0,0);\n\t\tAtom a5 = getAtom(-1,-1,0);\n\t\tAtom a6 = getAtom(0,-1,0);\n\t\tAtom a7 = getAtom(1,-1,0);\n\t\t\n\t\tassertEquals(180.0,Calc.angle(ref, a4),0.00001);\n\t\t\n\t\tassertTrue(Calc.angle(ref, a1)>=0 && Calc.angle(ref,a1)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a2)>=0 && Calc.angle(ref,a2)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a3)>=0 && Calc.angle(ref,a3)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a4)>=0 && Calc.angle(ref,a4)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a5)>=0 && Calc.angle(ref,a5)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a6)>=0 && Calc.angle(ref,a6)<=180.0);\n\t\tassertTrue(Calc.angle(ref, a7)>=0 && Calc.angle(ref,a7)<=180.0);\n\t\t\n\t\n\t\tAtom c = getAtom(0,0,0);\n\t\tAtom d = getAtom(0,0,0);\n\t\t\n\t\tassertEquals(Double.NaN, Calc.angle(a,c),0.00001);\n\t\tassertEquals(Double.NaN, Calc.angle(c,d),0.00001);\n\t}\n\t\n\t@Test\n\tpublic void testTorsionAngle() {\n\t\tAtom a = getAtom(0,0,0);\n\t\t\n\t\tAtom b = getAtom(1,0,0);\n\t\t\n\t\tAtom c = getAtom(2,0,0);\n\t\t\n\t\tAtom d = getAtom(3,0,0);\n\t\t\n\t\t// all 4 points colinear\n\t\t\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\t\t\n\t\t// first 3 colinear\n\t\td = getAtom(3,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\t\t\n\t\t// second 3 colinear\n\t\td = getAtom(3,0,0);\n\t\ta = getAtom(1,1,0);\n\t\tassertEquals(Double.NaN, Calc.torsionAngle(a, b, c, d),0.00001);\n\t\t\n\t\t// coplanar vectors\n\t\ta = getAtom(0,0,0);\n\t\tb = getAtom(1,0,0);\n\t\tc = getAtom(1, 1, 0);\n\t\td = getAtom(2, 1, 0);\n\t\t\n\t\tassertEquals(180, Calc.torsionAngle(a, b, c, d),0.00001);\n\t\t\n\t\tc = getAtom(-1,-1, 0);\n\t\td = getAtom(-2,-1, 0);\n\t\t\n\t\tassertEquals(0, Calc.torsionAngle(a, b, c, d),0.00001);\n\t}\n\t\n\t\n\t\n\tprivate static Atom getAtom(double x, double y, double z) {\n\t\tAtom a = new AtomImpl();\n\t\ta.setX(x);\n\t\ta.setY(y);\n\t\ta.setZ(z);\n\t\treturn a;\n\t}\n\n\t\n}\n","changedTest":"","commitMessage":"Fix bug in jama to vecmath conversion","test_commitMessage":"","allZero":false}