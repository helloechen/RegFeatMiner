{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/bio/structure/align/ce/CeCPMain.java","test_path":"biojava-structure/src/test/java/org/biojava/bio/structure/align/ce/CeCPMainTest.java","prod_time":"2015-01-30 06:34:57","test_time":"2015-01-30 06:34:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":6,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","test_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPAlignmentDisplay;\nimport org.biojava.bio.structure.align.util.ConfigurationException;\nimport org.biojava.bio.structure.jama.Matrix;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class CeCPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\tpublic static final String algorithmName = \"jCE Circular Permutation\";\n\n\t/**\n\t *  version history:\n\t *  1.5 - Added more parameters to the command line, including -maxOptRMSD\n\t *  1.4 - Added DuplicationHint parameter & default to duplicating the shorter chain\n\t *  1.3 - Short CPs are now discarded\n\t *  1.2 - now supports check AlignmentTools.isSequentialAlignment. XML protocol\n\t *  1.1 - skipped, (trying to avoid confusion with jfatcat in all vs. all comparisons) \n\t *  1.0 - initial release\n\t */\n\tpublic static final String version = \"1.5\";\n\n\tpublic CeCPMain(){\n\t\tsuper();\n\t\tparams = new CECPParameters();\n\t}\n\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn CeCPMain.algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn CeCPMain.version;\n\t}\n\n\tpublic static void main(String[] args) throws ConfigurationException {\n\t\tCeCPUserArgumentProcessor processor = new CeCPUserArgumentProcessor(); //Responsible for creating a CeCPMain instance\n\t\tprocessor.process(args);\n\t}\n\n\n\t/**\n\t * Aligns ca1 and ca2 using a heuristic to check for CPs.\n\t * <p>\n\t * Aligns ca1 against a doubled ca2, then cleans up the alignment.\n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @return the alignment, possibly containing a CP.\n\t * @throws StructureException \n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param) throws StructureException{\n\t\tif ( ! (param instanceof CECPParameters))\n\t\t\tthrow new IllegalArgumentException(\"CE algorithm needs an object of call CeParameters as argument.\");\n\n\t\tCECPParameters cpparams = (CECPParameters) param;\n\t\tthis.params = cpparams;\n\n\t\tboolean duplicateRight;\n\n\t\tswitch( cpparams.getDuplicationHint() ) {\n\t\tcase LEFT:\n\t\t\tduplicateRight = false;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tduplicateRight = true;\n\t\t\tbreak;\n\t\tcase SHORTER:\n\t\t\tduplicateRight = ca1.length >= ca2.length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tduplicateRight = true;\n\t\t}\n\n\n\t\tif( duplicateRight ) {\n\t\t\treturn alignRight(ca1, ca2, cpparams);\n\t\t} else {\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.println(\"Swapping alignment order.\");\n\t\t\t}\n\t\t\tAFPChain afpChain = this.alignRight(ca2, ca1, cpparams);\n\t\t\treturn invertAlignment(afpChain);\n\t\t}\n\t}\n\n\t/**\n\t * Aligns the structures, duplicating ca2 regardless of\n\t * {@link CECPParameters.getDuplicationHint() param.getDuplicationHint}.\n\t * @param ca1\n\t * @param ca2\n\t * @param cpparams\n\t * @return\n\t * @throws StructureException\n\t */\n\tprivate AFPChain alignRight(Atom[] ca1, Atom[] ca2, CECPParameters cpparams)\n\t\t\tthrows StructureException {\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tAtom[] ca2m = StructureTools.duplicateCA2(ca2);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Duplicating ca2 took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\t// Do alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2m,params);\n\n\t\t// since the process of creating ca2m strips the name info away, set it explicitely\n\t\ttry {\n\t\t\tafpChain.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t} catch( Exception e) {}\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Running %dx2*%d alignment took %s ms\\n\",ca1.length,ca2.length,System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\t\tafpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator, cpparams);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Finding CP point took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\treturn afpChain;\n\t}\n\n\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain The finished alignment\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2m A duplicated copy of the second protein\n\t * @param calculator The CECalculator used to create afpChain\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator ) throws StructureException{\n\t\treturn postProcessAlignment(afpChain, ca1, ca2m, calculator, null);\n\t}\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain The finished alignment\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2m A duplicated copy of the second protein\n\t * @param calculator The CECalculator used to create afpChain\n\t * @param param Parameters\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator, CECPParameters param ) throws StructureException{\n\n\t\t// remove bottom half of the matrix\n\t\tMatrix doubledMatrix = afpChain.getDistanceMatrix();\n\n\t\t// the matrix can be null if the alignment is too short.\n\t\tif ( doubledMatrix != null ) { \n\t\t\tassert(doubledMatrix.getRowDimension() == ca1.length);\n\t\t\tassert(doubledMatrix.getColumnDimension() == ca2m.length);\n\n\t\t\tMatrix singleMatrix = doubledMatrix.getMatrix(0, ca1.length-1, 0, (ca2m.length/2)-1);\n\t\t\tassert(singleMatrix.getRowDimension() == ca1.length);\n\t\t\tassert(singleMatrix.getColumnDimension() == (ca2m.length/2));\n\n\t\t\tafpChain.setDistanceMatrix(singleMatrix);\n\t\t}\n\t\t// Check for circular permutations\n\t\tint alignLen = afpChain.getOptLength();\n\t\tif ( alignLen > 0) {\n\t\t\tafpChain = filterDuplicateAFPs(afpChain,calculator,ca1,ca2m,param);\n\t\t}\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Swaps the order of structures in an AFPChain\n\t * @param a\n\t * @return\n\t */\n\tpublic AFPChain invertAlignment(AFPChain a) {\n\t\tString name1 = a.getName1();\n\t\tString name2 = a.getName2();\n\t\ta.setName1(name2);\n\t\ta.setName2(name1);\n\t\t\n\t\tint len1 = a.getCa1Length();\n\t\ta.setCa1Length( a.getCa2Length() );\n\t\ta.setCa2Length( len1 );\n\t\t\n\t\tint beg1 = a.getAlnbeg1();\n\t\ta.setAlnbeg1(a.getAlnbeg2());\n\t\ta.setAlnbeg2(beg1);\n\t\t\n\t\tchar[] alnseq1 = a.getAlnseq1();\n\t\ta.setAlnseq1(a.getAlnseq2());\n\t\ta.setAlnseq2(alnseq1);\n\t\t\n\t\tMatrix distab1 = a.getDisTable1();\n\t\ta.setDisTable1(a.getDisTable2());\n\t\ta.setDisTable2(distab1);\n\t\t\n\t\tint[] focusRes1 = a.getFocusRes1();\n\t\ta.setFocusRes1(a.getFocusRes2());\n\t\ta.setFocusRes2(focusRes1);\n\t\t\n\t\t//What are aftIndex and befIndex used for? How are they indexed?\n\t\t//a.getAfpAftIndex()\n\t\t\n\n\t\tString[][][] pdbAln = a.getPdbAln();\n\t\tif( pdbAln != null) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tString[] paln1 = pdbAln[block][0];\n\t\t\t\tpdbAln[block][0] = pdbAln[block][1];\n\t\t\t\tpdbAln[block][1] = paln1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][][] optAln = a.getOptAln();\n\t\tif( optAln != null ) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tint[] aln1 = optAln[block][0];\n\t\t\t\toptAln[block][0] = optAln[block][1];\n\t\t\t\toptAln[block][1] = aln1;\n\t\t\t}\n\t\t}\n\t\ta.setOptAln(optAln); // triggers invalidate()\n\t\t\n\t\tMatrix distmat = a.getDistanceMatrix();\n\t\tif(distmat != null)\n\t\t\ta.setDistanceMatrix(distmat.transpose());\n\t\t\n\t\t\n\t\t// invert the rotation matrices\n\t\tMatrix[] blockRotMat = a.getBlockRotationMatrix();\n\t\tAtom[] shiftVec = a.getBlockShiftVector();\n\t\tif( blockRotMat != null) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tif(blockRotMat[block] != null) {\n\t\t\t\t\t// if y=x*A+b, then x=y*inv(A)-b*inv(A)\n\t\t\t\t\tblockRotMat[block] = blockRotMat[block].inverse();\n\n\t\t\t\t\tCalc.rotate(shiftVec[block],blockRotMat[block]);\n\t\t\t\t\tshiftVec[block] = Calc.invert(shiftVec[block]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Takes as input an AFPChain where ca2 has been artificially duplicated.\n\t * This raises the possibility that some residues of ca2 will appear in \n\t * multiple AFPs. This method filters out duplicates and makes sure that\n\t * all AFPs are numbered relative to the original ca2.\n\t * \n\t * <p>The current version chooses a CP site such that the length of the\n\t * alignment is maximized.\n\t * \n\t * <p>This method does <i>not</i> update scores to reflect the filtered alignment.\n\t * It <i>does</i> update the RMSD and superposition.\n\t * \n\t * @param afpChain The alignment between ca1 and ca2-ca2. Blindly assumes \n\t *  that ca2 has been duplicated.\n\t * @return A new AFPChain consisting of ca1 to ca2, with each residue in\n\t *  at most 1 AFP.\n\t * @throws StructureException \n\t */\n\tpublic static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc, Atom[] ca1, Atom[] ca2duplicated) throws StructureException {\n\t\treturn filterDuplicateAFPs(afpChain, ceCalc, ca1, ca2duplicated, null);\n\t}\n\tpublic static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc,\n\t\t\tAtom[] ca1, Atom[] ca2duplicated, CECPParameters params) throws StructureException {\t\t\n\t\tAFPChain newAFPChain = new AFPChain(afpChain);\n\n\t\tif(params == null)\n\t\t\tparams = new CECPParameters();\n\t\t\n\t\tfinal int minCPlength = params.getMinCPLength();\n\t\t\n\t\t\n\t\tint ca2len = afpChain.getCa2Length()/2;\n\t\tnewAFPChain.setCa2Length(ca2len);\n\n\t\t// Fix optimal alignment\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tint alignLen = afpChain.getOptLength();\n\t\tif (alignLen < 1) return newAFPChain;\n\t\t\n\t\tassert(afpChain.getBlockNum() == 1); // Assume that CE returns just one block\n\t\t\n\n\t\t// Determine the region where ca2 and ca2' overlap\n\t\t\n\t\t// The bounds of the alignment wrt ca2-ca2'\n\t\tint nStart = optAln[0][1][0]; //alignment N-terminal\n\t\tint cEnd = optAln[0][1][alignLen-1]; // alignment C-terminal \n\t\t// overlap is between nStart and cEnd\n\n\t\t\n\t\tint firstRes = nStart; // start res number after trimming\n\t\tint lastRes = nStart+ca2len;  // last res number after trimming\n\t\tif(nStart >= ca2len || cEnd < ca2len) { // no circular permutation\n\t\t\tfirstRes=nStart;\n\t\t\tlastRes=cEnd;\n\t\t} else {\n\t\t\t// Rule: maximize the length of the alignment\n\t\t\t\n\t\t\tint overlapLength = cEnd+1 - nStart - ca2len;\n\t\t\tif(overlapLength <= 0) {\n\t\t\t\t// no overlap!\n\t\t\t\t\n\t\t\t\tCPRange minCP = calculateMinCP(optAln[0][1], alignLen, ca2len, minCPlength);\n\n\t\t\t\tfirstRes=nStart;\n\t\t\t\tlastRes=cEnd;\n\n\t\t\t\t// Remove short blocks\n\t\t\t\tif(firstRes > minCP.n) {\n\t\t\t\t\tfirstRes = ca2len;\n\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"Discarding n-terminal block as too \" +\n\t\t\t\t\t\t\t\t\"short (%d residues, needs %d)\\n\",\n\t\t\t\t\t\t\t\tminCP.mid, minCPlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(lastRes < minCP.c) {\n\t\t\t\t\tlastRes = ca2len-1;\n\t\t\t\t\t\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"Discarding c-terminal block as too \" +\n\t\t\t\t\t\t\t\t\"short (%d residues, needs %d)\\n\",\n\t\t\t\t\t\t\t\toptLen[0] - minCP.mid, minCPlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// overlap!\n\n\t\t\t\tCutPoint cp = calculateCutPoint(optAln[0][1], nStart, cEnd, \n\t\t\t\t\t\toverlapLength, alignLen, minCPlength, ca2len, firstRes);\n\n\t\t\t\t// Adjust alignment length for trimming\n\t\t\t\t//alignLen -= cp.numResiduesCut; //TODO inaccurate\n\t\t\t\t\n\t\t\t\tfirstRes = cp.firstRes;\n\t\t\t\tlastRes = cp.lastRes;\n\t\t\t\t\n\t\t\t\t//TODO Now have CP site, and could do a NxM alignment for further optimization.\n\t\t\t\t// For now, does not appear to be worth the 50% increase in time\n\n\t\t\t\t//TODO Bug: scores need to be recalculated\n\t\t\t}\n\t\t}\n\n\n\n\t\t// Fix numbering:\n\t\t// First, split up the atoms into left and right blocks\n\t\tList< ResiduePair > left = new ArrayList<ResiduePair>(); // residues from left of duplication\n\t\tList< ResiduePair > right = new ArrayList<ResiduePair>(); // residues from right of duplication\n\n\t\tfor(int i=0;i<optLen[0];i++) {\n\t\t\tif( optAln[0][1][i] >= firstRes && optAln[0][1][i] <= lastRes ) { // not trimmed\n\t\t\t\tif(optAln[0][1][i] < ca2len) { // in first half of ca2\n\t\t\t\t\tleft.add(new ResiduePair(optAln[0][0][i],optAln[0][1][i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tright.add(new ResiduePair(optAln[0][0][i],optAln[0][1][i]-ca2len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//assert(left.size()+right.size() == alignLen);\n\t\talignLen = 0;\n\n\t\t// Now we don't care about left/right, so just call them \"blocks\"\n\t\tList<List<ResiduePair>> blocks = new ArrayList<List<ResiduePair>>(2);\n\t\tif( !left.isEmpty() ) {\n\t\t\tblocks.add(left);\n\t\t\talignLen += left.size();\n\t\t}\n\t\tif( !right.isEmpty()) {\n\t\t\tblocks.add(right);\n\t\t\talignLen += right.size();\n\t\t}\n\t\tleft=null; right = null;\n\n\t\t// Put the blocks back together into arrays for the AFPChain\n\t\tint[][][] newAlign = new int[blocks.size()][][];\n\t\tint[] blockLengths = new int[blocks.size()];\n\t\tfor(int blockNum = 0; blockNum < blocks.size(); blockNum++) {\n\t\t\t//Alignment\n\t\t\tList<ResiduePair> block = blocks.get(blockNum);\n\t\t\tnewAlign[blockNum] = new int[2][block.size()];\n\t\t\tfor(int i=0;i<block.size();i++) {\n\t\t\t\tResiduePair pair = block.get(i);\n\t\t\t\tnewAlign[blockNum][0][i] = pair.a;\n\t\t\t\tnewAlign[blockNum][1][i] = pair.b;\n\t\t\t}\n\n\t\t\t// Block lengths\n\t\t\tblockLengths[blockNum] = block.size();\n\t\t}\n\t\t// Set Alignment\n\t\tnewAFPChain.setOptAln(newAlign);\n\t\tnewAFPChain.setOptLen(blockLengths );\n\t\tnewAFPChain.setOptLength(alignLen);\n\t\tnewAFPChain.setBlockNum(blocks.size());\n\t\tnewAFPChain.setBlockResSize(blockLengths.clone());\n\t\tnewAFPChain.setSequentialAlignment(blocks.size() == 1);\n\n\t\t// TODO make the AFPSet consistent\n\t\t// TODO lots more block properties & old AFP properties \n\n\t\t// Recalculate superposition\n\t\tAtom[] atoms1 = new Atom[alignLen];\n\t\tAtom[] atoms2 = new Atom[alignLen];\n\n\t\tint pos=0;\n\t\tfor(List<ResiduePair> block:blocks ) {\n\t\t\tfor(ResiduePair pair:block) {\n\t\t\t\tatoms1[pos] = ca1[pair.a];\n\t\t\t\t// Clone residue to allow modification\n\t\t\t\tAtom atom2 = ca2duplicated[pair.b];\n\t\t\t\tGroup g = (Group) atom2.getGroup().clone();\n\t\t\t\tatoms2[pos] = g.getAtom( atom2.getName() );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tassert(pos == alignLen);\n\t\t\n\t\t// Sets the rotation matrix in ceCalc to the proper value\n\t\tdouble rmsd = -1;\n\t\tdouble tmScore = 0.;\n\t\tdouble[] blockRMSDs = new double[blocks.size()];\n\t\tMatrix[] blockRotationMatrices = new Matrix[blocks.size()];\n\t\tAtom[] blockShifts = new Atom[blocks.size()];\n\n\t\tif(alignLen>0) {\n\t\t\t// superimpose\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(atoms1, atoms2);\n\n\t\t\tMatrix matrix = svd.getRotation();\n\t\t\tAtom shift = svd.getTranslation();\n\n\t\t\tfor( Atom a : atoms2 ) {\n\t\t\t\tCalc.rotate(a.getGroup(), matrix);\n\t\t\t\tCalc.shift(a, shift);\n\t\t\t}\n\t\t\t\n\t\t\t//and get overall rmsd\n\t\t\trmsd = SVDSuperimposer.getRMS(atoms1, atoms2);\n\t\t\ttmScore = SVDSuperimposer.getTMScore(atoms1, atoms2, ca1.length, ca2len);\n\n\t\t\t// set all block rotations to the overall rotation\n\t\t\t// It's not well documented if this is the expected behavior, but\n\t\t\t// it seems to work.\n\t\t\tblockRotationMatrices[0] = matrix;\n\t\t\tblockShifts[0] = shift;\n\t\t\tblockRMSDs[0] = -1;\n\n\t\t\tfor(int i=1;i<blocks.size();i++) {\n\t\t\t\tblockRMSDs[i] = -1; //TODO Recalculate for the FATCAT text format\n\t\t\t\tblockRotationMatrices[i] = (Matrix) blockRotationMatrices[0].clone();\n\t\t\t\tblockShifts[i] = (Atom) blockShifts[0].clone();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tnewAFPChain.setOptRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRotationMatrix(blockRotationMatrices);\n\t\tnewAFPChain.setBlockShiftVector(blockShifts);\n\t\tnewAFPChain.setTotalRmsdOpt(rmsd);\n\t\tnewAFPChain.setTMScore( tmScore );\n\t\t\n\t\t// Clean up remaining properties using the FatCat helper method\n\t\tAtom[] ca2 = new Atom[ca2len];\n\t\tSystem.arraycopy(ca2duplicated, 0, ca2, 0, ca2len);\n\t\tAFPAlignmentDisplay.getAlign(newAFPChain, ca1, ca2duplicated);\n\n\t\treturn newAFPChain;\n\t}\n\n\tprivate static int[] countCtermResidues(int[] block, int blockLen,\n\t\t\tint cEnd, int overlapLength) {\n\t\tint[] cTermResCount = new int[overlapLength+1]; // # res at or to the right of i within overlap\n\t\tcTermResCount[overlapLength] = 0;\n\t\tint alignPos = blockLen - 1;\n\t\tfor(int i=overlapLength-1;i>=0;i--) { // i starts at the c-term and increases to the left\n\t\t\tif(block[alignPos] == cEnd - overlapLength+1 + i) { // matches the aligned pair\n\t\t\t\t// the c-term contains the -ith overlapping residue\n\t\t\t\tcTermResCount[i] = cTermResCount[i+1]+1;\n\t\t\t\talignPos--;\n\t\t\t} else {\n\t\t\t\tcTermResCount[i] = cTermResCount[i+1];\n\t\t\t}\n\t\t}\n\t\treturn cTermResCount;\n\t}\n\n\tprivate static int[] countNtermResidues(int[] block, int nStart,\n\t\t\tint overlapLength) {\n\t\tint[] nTermResCount = new int[overlapLength+1]; // increases monotonically\n\t\tnTermResCount[0] = 0;\n\t\tint alignPos = 0; // index of the next aligned pair\n\n\t\tfor(int i=1;i<=overlapLength;i++) {\n\t\t\tif(block[alignPos] == nStart + i-1 ) { // matches the aligned pair\n\t\t\t\t// the n-term contains the ith overlapping residue\n\t\t\t\tnTermResCount[i] = nTermResCount[i-1]+1;\n\t\t\t\talignPos++;\n\t\t\t} else {\n\t\t\t\tnTermResCount[i] = nTermResCount[i-1];\n\t\t\t}\n\t\t}\n\t\treturn nTermResCount;\n\t}\n\n\n\t/**\n\t * A light class to store an alignment between two residues.\n\t * @author Spencer Bliven\n\t * @see #filterDuplicateAFPs()\n\t */\n\tprivate static class ResiduePair {\n\t\tpublic int a;\n\t\tpublic int b;\n\t\tpublic ResiduePair(int a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn a+\":\"+b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Tiny wrapper for the disallowed regions of an alignment.\n\t * @see CeCPMain#calculateMinCP(int[], int, int, int)\n\t * @author Spencer Bliven\n\t *\n\t */\n\tprotected static class CPRange {\n\t\t/**\n\t\t * last allowed n-term\n\t\t */\n\t\tpublic int n;\n\t\t/**\n\t\t * midpoint of the alignment\n\t\t */\n\t\tpublic int mid;\n\t\t/**\n\t\t * first allowed c-term\n\t\t */\n\t\tpublic int c;\n\t}\n\t\n\t/**\n\t * Finds the alignment index of the residues minCPlength before and after\n\t * the duplication.\n\t *  \n\t * @param block The permuted block being considered, generally optAln[0][1]\n\t * @param blockLen The length of the block (in case extra memory was allocated in block)\n\t * @param ca2len The length, in residues, of the protein specified by block\n\t * @param minCPlength The minimum number of residues allowed for a CP\n\t * @return a CPRange with the following components:\n\t *  <dl><dt>n</dt><dd>Index into <code>block</code> of the residue such that\n\t *  \t<code>minCPlength</code> residues remain to the end of <code>ca2len</code>,\n\t *  \tor -1 if no residue fits that criterium.</dd>\n\t *  <dt>mid</dt><dd>Index of the first residue higher than <code>ca2len</code>.</dd>\n\t *  <dt>c</dt><dd>Index of <code>minCPlength</code>-th residue after ca2len,\n\t *  \tor ca2len*2 if no residue fits that criterium.</dd>\n\t *  </dl>\n\t */\n\tprotected static CPRange calculateMinCP(int[] block, int blockLen, int ca2len, int minCPlength) {\n\t\tCPRange range = new CPRange();\n\t\t\n\t\t// Find the cut point within the alignment.\n\t\t// Either returns the index i of the alignment such that block[i] == ca2len,\n\t\t// or else returns -i-1 where block[i] is the first element > ca2len.\n\t\tint middle = Arrays.binarySearch(block, ca2len);\n\t\tif(middle < 0) {\n\t\t\tmiddle = -middle -1;\n\t\t}\n\t\t// Middle is now the first res after the duplication\n\t\trange.mid = middle;\n\t\t\n\t\tint minCPntermIndex = middle-minCPlength;\n\t\tif(minCPntermIndex >= 0) {\n\t\t\trange.n = block[minCPntermIndex];\n\t\t} else {\n\t\t\trange.n = -1;\n\t\t}\n\t\t\n\t\tint minCPctermIndex = middle+minCPlength-1;\n\t\tif(minCPctermIndex < blockLen) {\n\t\t\trange.c = block[minCPctermIndex];\n\t\t} else {\n\t\t\trange.c = ca2len*2;\n\t\t}\n\n\t\t// Stub:\n\t\t// Best-case: assume all residues in the termini are aligned\n\t\t//range.n = ca2len - minCPlength; \n\t\t//range.c = ca2len + minCPlength-1;\n\t\t\n\t\treturn range;\n\t}\n\t\n\t\n\tprivate static class CutPoint {\n\t\tpublic int numResiduesCut;\n\t\tpublic int firstRes;\n\t\tpublic int lastRes;\n\t}\n\t\n\tprivate static CutPoint calculateCutPoint(int[] block,int nStart, int cEnd,\n\t\t\tint overlapLength, int alignLen, int minCPlength, int ca2len, int firstRes) {\n\t\t\n\t\t// We require at least minCPlength residues in a block.\n\t\t//TODO calculate these explicitely based on the alignment\n\t\t\n\t\t// The last valid n-term\n\t\tCPRange minCP = calculateMinCP(block, alignLen, ca2len, minCPlength);\n\t\tint minCPnterm = minCP.n;\n\t\t// The first valid c-term\n\t\tint minCPcterm = minCP.c;\n\t\t\n\n\t\t// # res at or to the left of i within the overlap\n\t\tint[] nTermResCount = countNtermResidues(block, nStart,\n\t\t\t\toverlapLength);\n\t\t\n\t\t// Determine the position with the largest sum of lengths\n\t\tint[] cTermResCount = countCtermResidues(block, alignLen,\n\t\t\t\tcEnd, overlapLength);\n\t\t\n\t\t// Alignment length for a cut at the left of the overlap\n\t\tint maxResCount=-1;\n\t\tfor(int i=0;i<=overlapLength;i++) { // i is the position of the CP within the overlap region\n\t\t\t// Calculate number of residues which remain after the CP\n\t\t\tint nRemain,cRemain;\n\t\t\tif(nStart+i <= minCPnterm) {\n\t\t\t\tnRemain = nTermResCount[overlapLength]-nTermResCount[i];\n\t\t\t} else {\n\t\t\t\tnRemain = 0;\n\t\t\t}\n\t\t\tif(cEnd-overlapLength+i >= minCPcterm) {\n\t\t\t\tcRemain = cTermResCount[0] - cTermResCount[i];\n\t\t\t} else {\n\t\t\t\tcRemain = 0;\n\t\t\t}\n\n\t\t\t// Look for the cut point which cuts off the minimum number of res\n\t\t\tif(nRemain + cRemain > maxResCount ) { // '>' biases towards keeping the n-term \n\t\t\t\tmaxResCount = nRemain + cRemain;\n\t\t\t\tfirstRes = nStart+ i;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the number of residues cut within the overlap\n\t\tint numResiduesCut = nTermResCount[overlapLength]+cTermResCount[0]-maxResCount;\n\t\t\n\t\t// Remove short blocks\n\t\tif(firstRes > minCPnterm) {\n\t\t\t// update number of residues cut for those outside the overlap\n\t\t\tnumResiduesCut += 0; //TODO\n\t\t\t\n\t\t\tfirstRes = ca2len;\n\t\t} \n\n\t\tint lastRes = firstRes+ca2len-1;\n\t\tif(lastRes < minCPcterm) {\n\t\t\t// update number of residues cut for those outside the overlap\n\t\t\tnumResiduesCut += 0; //TODO\n\n\t\t\tlastRes = ca2len-1;\n\t\t}\n\t\t\n\n\t\tCutPoint cp = new CutPoint();\n\t\tcp.firstRes=firstRes;\n\t\tcp.numResiduesCut = numResiduesCut;\n\t\tcp.lastRes = lastRes;\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Found a CP at residue %d. Trimming %d aligned residues from %d-%d of block 0 and %d-%d of block 1.\\n\",\n\t\t\t\t\tfirstRes,cp.numResiduesCut,nStart,firstRes-1,firstRes, cEnd-ca2len);\n\t\t}\n\t\t\n\t\treturn cp;\n\t}\n\n\n\t// try showing a GUI\n\t// requires additional dependencies biojava3-structure-gui and JmolApplet\n\t// TODO dmyersturnbull: This should probably be in structure-gui\n\t@SuppressWarnings(\"unused\")\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Mar 9, 2010\n * Author: Spencer Bliven \n *\n */\n\npackage org.biojava.bio.structure.align.ce;\n\n\nimport org.biojava.bio.structure.*;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPAlignmentDisplay;\nimport org.biojava.bio.structure.align.util.ConfigurationException;\nimport org.biojava.bio.structure.jama.Matrix;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/** \n * A wrapper for {@link CeMain} which sets default parameters to be appropriate for finding\n * circular permutations.\n * <p>\n * A circular permutation consists of a single cleavage point and rearrangement \n * between two structures, for example:\n * <pre>\n * ABCDEFG\n * DEFGABC\n * </pre>  \n * @author Spencer Bliven.\n *\n */\npublic class CeCPMain extends CeMain {\n\tprivate static boolean debug = false;\n\n\tpublic static final String algorithmName = \"jCE Circular Permutation\";\n\n\t/**\n\t *  version history:\n\t *  1.5 - Added more parameters to the command line, including -maxOptRMSD\n\t *  1.4 - Added DuplicationHint parameter & default to duplicating the shorter chain\n\t *  1.3 - Short CPs are now discarded\n\t *  1.2 - now supports check AlignmentTools.isSequentialAlignment. XML protocol\n\t *  1.1 - skipped, (trying to avoid confusion with jfatcat in all vs. all comparisons) \n\t *  1.0 - initial release\n\t */\n\tpublic static final String version = \"1.5\";\n\n\tpublic CeCPMain(){\n\t\tsuper();\n\t\tparams = new CECPParameters();\n\t}\n\n\t@Override\n\tpublic String getAlgorithmName() {\n\t\treturn CeCPMain.algorithmName;\n\t}\n\n\t@Override\n\tpublic String getVersion() {\n\t\treturn CeCPMain.version;\n\t}\n\n\tpublic static void main(String[] args) throws ConfigurationException {\n\t\tCeCPUserArgumentProcessor processor = new CeCPUserArgumentProcessor(); //Responsible for creating a CeCPMain instance\n\t\tprocessor.process(args);\n\t}\n\n\n\t/**\n\t * Aligns ca1 and ca2 using a heuristic to check for CPs.\n\t * <p>\n\t * Aligns ca1 against a doubled ca2, then cleans up the alignment.\n\t * @param ca1\n\t * @param ca2\n\t * @param param\n\t * @return the alignment, possibly containing a CP.\n\t * @throws StructureException \n\t */\n\t@Override\n\tpublic AFPChain align(Atom[] ca1, Atom[] ca2, Object param) throws StructureException{\n\t\tif ( ! (param instanceof CECPParameters))\n\t\t\tthrow new IllegalArgumentException(\"CE algorithm needs an object of call CeParameters as argument.\");\n\n\t\tCECPParameters cpparams = (CECPParameters) param;\n\t\tthis.params = cpparams;\n\n\t\tboolean duplicateRight;\n\n\t\tswitch( cpparams.getDuplicationHint() ) {\n\t\tcase LEFT:\n\t\t\tduplicateRight = false;\n\t\t\tbreak;\n\t\tcase RIGHT:\n\t\t\tduplicateRight = true;\n\t\t\tbreak;\n\t\tcase SHORTER:\n\t\t\tduplicateRight = ca1.length >= ca2.length;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tduplicateRight = true;\n\t\t}\n\n\n\t\tif( duplicateRight ) {\n\t\t\treturn alignRight(ca1, ca2, cpparams);\n\t\t} else {\n\t\t\tif(debug) {\n\t\t\t\tSystem.out.println(\"Swapping alignment order.\");\n\t\t\t}\n\t\t\tAFPChain afpChain = this.alignRight(ca2, ca1, cpparams);\n\t\t\treturn invertAlignment(afpChain);\n\t\t}\n\t}\n\n\t/**\n\t * Aligns the structures, duplicating ca2 regardless of\n\t * {@link CECPParameters.getDuplicationHint() param.getDuplicationHint}.\n\t * @param ca1\n\t * @param ca2\n\t * @param cpparams\n\t * @return\n\t * @throws StructureException\n\t */\n\tprivate AFPChain alignRight(Atom[] ca1, Atom[] ca2, CECPParameters cpparams)\n\t\t\tthrows StructureException {\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tAtom[] ca2m = StructureTools.duplicateCA2(ca2);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Duplicating ca2 took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\t// Do alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2m,params);\n\n\t\t// since the process of creating ca2m strips the name info away, set it explicitely\n\t\ttry {\n\t\t\tafpChain.setName2(ca2[0].getGroup().getChain().getParent().getName());\n\t\t} catch( Exception e) {}\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Running %dx2*%d alignment took %s ms\\n\",ca1.length,ca2.length,System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\t\tafpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator, cpparams);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Finding CP point took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\treturn afpChain;\n\t}\n\n\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain The finished alignment\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2m A duplicated copy of the second protein\n\t * @param calculator The CECalculator used to create afpChain\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator ) throws StructureException{\n\t\treturn postProcessAlignment(afpChain, ca1, ca2m, calculator, null);\n\t}\n\n\t/** Circular permutation specific code to be run after the standard CE alignment\n\t * \n\t * @param afpChain The finished alignment\n\t * @param ca1 CA atoms of the first protein\n\t * @param ca2m A duplicated copy of the second protein\n\t * @param calculator The CECalculator used to create afpChain\n\t * @param param Parameters\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain postProcessAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2m,CECalculator calculator, CECPParameters param ) throws StructureException{\n\n\t\t// remove bottom half of the matrix\n\t\tMatrix doubledMatrix = afpChain.getDistanceMatrix();\n\n\t\t// the matrix can be null if the alignment is too short.\n\t\tif ( doubledMatrix != null ) { \n\t\t\tassert(doubledMatrix.getRowDimension() == ca1.length);\n\t\t\tassert(doubledMatrix.getColumnDimension() == ca2m.length);\n\n\t\t\tMatrix singleMatrix = doubledMatrix.getMatrix(0, ca1.length-1, 0, (ca2m.length/2)-1);\n\t\t\tassert(singleMatrix.getRowDimension() == ca1.length);\n\t\t\tassert(singleMatrix.getColumnDimension() == (ca2m.length/2));\n\n\t\t\tafpChain.setDistanceMatrix(singleMatrix);\n\t\t}\n\t\t// Check for circular permutations\n\t\tint alignLen = afpChain.getOptLength();\n\t\tif ( alignLen > 0) {\n\t\t\tafpChain = filterDuplicateAFPs(afpChain,calculator,ca1,ca2m,param);\n\t\t}\n\t\treturn afpChain;\n\t}\n\n\t/**\n\t * Swaps the order of structures in an AFPChain\n\t * @param a\n\t * @return\n\t */\n\tpublic AFPChain invertAlignment(AFPChain a) {\n\t\tString name1 = a.getName1();\n\t\tString name2 = a.getName2();\n\t\ta.setName1(name2);\n\t\ta.setName2(name1);\n\t\t\n\t\tint len1 = a.getCa1Length();\n\t\ta.setCa1Length( a.getCa2Length() );\n\t\ta.setCa2Length( len1 );\n\t\t\n\t\tint beg1 = a.getAlnbeg1();\n\t\ta.setAlnbeg1(a.getAlnbeg2());\n\t\ta.setAlnbeg2(beg1);\n\t\t\n\t\tchar[] alnseq1 = a.getAlnseq1();\n\t\ta.setAlnseq1(a.getAlnseq2());\n\t\ta.setAlnseq2(alnseq1);\n\t\t\n\t\tMatrix distab1 = a.getDisTable1();\n\t\ta.setDisTable1(a.getDisTable2());\n\t\ta.setDisTable2(distab1);\n\t\t\n\t\tint[] focusRes1 = a.getFocusRes1();\n\t\ta.setFocusRes1(a.getFocusRes2());\n\t\ta.setFocusRes2(focusRes1);\n\t\t\n\t\t//What are aftIndex and befIndex used for? How are they indexed?\n\t\t//a.getAfpAftIndex()\n\t\t\n\n\t\tString[][][] pdbAln = a.getPdbAln();\n\t\tif( pdbAln != null) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tString[] paln1 = pdbAln[block][0];\n\t\t\t\tpdbAln[block][0] = pdbAln[block][1];\n\t\t\t\tpdbAln[block][1] = paln1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][][] optAln = a.getOptAln();\n\t\tif( optAln != null ) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tint[] aln1 = optAln[block][0];\n\t\t\t\toptAln[block][0] = optAln[block][1];\n\t\t\t\toptAln[block][1] = aln1;\n\t\t\t}\n\t\t}\n\t\ta.setOptAln(optAln); // triggers invalidate()\n\t\t\n\t\tMatrix distmat = a.getDistanceMatrix();\n\t\tif(distmat != null)\n\t\t\ta.setDistanceMatrix(distmat.transpose());\n\t\t\n\t\t\n\t\t// invert the rotation matrices\n\t\tMatrix[] blockRotMat = a.getBlockRotationMatrix();\n\t\tAtom[] shiftVec = a.getBlockShiftVector();\n\t\tif( blockRotMat != null) {\n\t\t\tfor(int block = 0; block < a.getBlockNum(); block++) {\n\t\t\t\tif(blockRotMat[block] != null) {\n\t\t\t\t\t// if y=x*A+b, then x=y*inv(A)-b*inv(A)\n\t\t\t\t\tblockRotMat[block] = blockRotMat[block].inverse();\n\n\t\t\t\t\tCalc.rotate(shiftVec[block],blockRotMat[block]);\n\t\t\t\t\tshiftVec[block] = Calc.invert(shiftVec[block]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t/**\n\t * Takes as input an AFPChain where ca2 has been artificially duplicated.\n\t * This raises the possibility that some residues of ca2 will appear in \n\t * multiple AFPs. This method filters out duplicates and makes sure that\n\t * all AFPs are numbered relative to the original ca2.\n\t * \n\t * <p>The current version chooses a CP site such that the length of the\n\t * alignment is maximized.\n\t * \n\t * <p>This method does <i>not</i> update scores to reflect the filtered alignment.\n\t * It <i>does</i> update the RMSD and superposition.\n\t * \n\t * @param afpChain The alignment between ca1 and ca2-ca2. Blindly assumes \n\t *  that ca2 has been duplicated.\n\t * @return A new AFPChain consisting of ca1 to ca2, with each residue in\n\t *  at most 1 AFP.\n\t * @throws StructureException \n\t */\n\tpublic static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc, Atom[] ca1, Atom[] ca2duplicated) throws StructureException {\n\t\treturn filterDuplicateAFPs(afpChain, ceCalc, ca1, ca2duplicated, null);\n\t}\n\tpublic static AFPChain filterDuplicateAFPs(AFPChain afpChain, CECalculator ceCalc,\n\t\t\tAtom[] ca1, Atom[] ca2duplicated, CECPParameters params) throws StructureException {\t\t\n\t\tAFPChain newAFPChain = new AFPChain(afpChain);\n\n\t\tif(params == null)\n\t\t\tparams = new CECPParameters();\n\t\t\n\t\tfinal int minCPlength = params.getMinCPLength();\n\t\t\n\t\t\n\t\tint ca2len = afpChain.getCa2Length()/2;\n\t\tnewAFPChain.setCa2Length(ca2len);\n\n\t\t// Fix optimal alignment\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] optLen = afpChain.getOptLen();\n\t\tint alignLen = afpChain.getOptLength();\n\t\tif (alignLen < 1) return newAFPChain;\n\t\t\n\t\tassert(afpChain.getBlockNum() == 1); // Assume that CE returns just one block\n\t\t\n\n\t\t// Determine the region where ca2 and ca2' overlap\n\t\t\n\t\t// The bounds of the alignment wrt ca2-ca2'\n\t\tint nStart = optAln[0][1][0]; //alignment N-terminal\n\t\tint cEnd = optAln[0][1][alignLen-1]; // alignment C-terminal \n\t\t// overlap is between nStart and cEnd\n\n\t\t\n\t\tint firstRes = nStart; // start res number after trimming\n\t\tint lastRes = nStart+ca2len;  // last res number after trimming\n\t\tif(nStart >= ca2len || cEnd < ca2len) { // no circular permutation\n\t\t\tfirstRes=nStart;\n\t\t\tlastRes=cEnd;\n\t\t} else {\n\t\t\t// Rule: maximize the length of the alignment\n\t\t\t\n\t\t\tint overlapLength = cEnd+1 - nStart - ca2len;\n\t\t\tif(overlapLength <= 0) {\n\t\t\t\t// no overlap!\n\t\t\t\t\n\t\t\t\tCPRange minCP = calculateMinCP(optAln[0][1], alignLen, ca2len, minCPlength);\n\n\t\t\t\tfirstRes=nStart;\n\t\t\t\tlastRes=cEnd;\n\n\t\t\t\t// Remove short blocks\n\t\t\t\tif(firstRes > minCP.n) {\n\t\t\t\t\tfirstRes = ca2len;\n\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"Discarding n-terminal block as too \" +\n\t\t\t\t\t\t\t\t\"short (%d residues, needs %d)\\n\",\n\t\t\t\t\t\t\t\tminCP.mid, minCPlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(lastRes < minCP.c) {\n\t\t\t\t\tlastRes = ca2len-1;\n\t\t\t\t\t\n\t\t\t\t\tif(debug) {\n\t\t\t\t\t\tSystem.out.format(\"Discarding c-terminal block as too \" +\n\t\t\t\t\t\t\t\t\"short (%d residues, needs %d)\\n\",\n\t\t\t\t\t\t\t\toptLen[0] - minCP.mid, minCPlength);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// overlap!\n\n\t\t\t\tCutPoint cp = calculateCutPoint(optAln[0][1], nStart, cEnd, \n\t\t\t\t\t\toverlapLength, alignLen, minCPlength, ca2len, firstRes);\n\n\t\t\t\t// Adjust alignment length for trimming\n\t\t\t\t//alignLen -= cp.numResiduesCut; //TODO inaccurate\n\t\t\t\t\n\t\t\t\tfirstRes = cp.firstRes;\n\t\t\t\tlastRes = cp.lastRes;\n\t\t\t\t\n\t\t\t\t//TODO Now have CP site, and could do a NxM alignment for further optimization.\n\t\t\t\t// For now, does not appear to be worth the 50% increase in time\n\n\t\t\t\t//TODO Bug: scores need to be recalculated\n\t\t\t}\n\t\t}\n\n\n\n\t\t// Fix numbering:\n\t\t// First, split up the atoms into left and right blocks\n\t\tList< ResiduePair > left = new ArrayList<ResiduePair>(); // residues from left of duplication\n\t\tList< ResiduePair > right = new ArrayList<ResiduePair>(); // residues from right of duplication\n\n\t\tfor(int i=0;i<optLen[0];i++) {\n\t\t\tif( optAln[0][1][i] >= firstRes && optAln[0][1][i] <= lastRes ) { // not trimmed\n\t\t\t\tif(optAln[0][1][i] < ca2len) { // in first half of ca2\n\t\t\t\t\tleft.add(new ResiduePair(optAln[0][0][i],optAln[0][1][i]));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tright.add(new ResiduePair(optAln[0][0][i],optAln[0][1][i]-ca2len));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//assert(left.size()+right.size() == alignLen);\n\t\talignLen = 0;\n\n\t\t// Now we don't care about left/right, so just call them \"blocks\"\n\t\tList<List<ResiduePair>> blocks = new ArrayList<List<ResiduePair>>(2);\n\t\tif( !left.isEmpty() ) {\n\t\t\tblocks.add(left);\n\t\t\talignLen += left.size();\n\t\t}\n\t\tif( !right.isEmpty()) {\n\t\t\tblocks.add(right);\n\t\t\talignLen += right.size();\n\t\t}\n\t\tleft=null; right = null;\n\n\t\t// Put the blocks back together into arrays for the AFPChain\n\t\tint[][][] newAlign = new int[blocks.size()][][];\n\t\tint[] blockLengths = new int[blocks.size()];\n\t\tfor(int blockNum = 0; blockNum < blocks.size(); blockNum++) {\n\t\t\t//Alignment\n\t\t\tList<ResiduePair> block = blocks.get(blockNum);\n\t\t\tnewAlign[blockNum] = new int[2][block.size()];\n\t\t\tfor(int i=0;i<block.size();i++) {\n\t\t\t\tResiduePair pair = block.get(i);\n\t\t\t\tnewAlign[blockNum][0][i] = pair.a;\n\t\t\t\tnewAlign[blockNum][1][i] = pair.b;\n\t\t\t}\n\n\t\t\t// Block lengths\n\t\t\tblockLengths[blockNum] = block.size();\n\t\t}\n\t\t// Set Alignment\n\t\tnewAFPChain.setOptAln(newAlign);\n\t\tnewAFPChain.setOptLen(blockLengths );\n\t\tnewAFPChain.setOptLength(alignLen);\n\t\tnewAFPChain.setBlockNum(blocks.size());\n\t\tnewAFPChain.setBlockResSize(blockLengths.clone());\n\t\tnewAFPChain.setSequentialAlignment(blocks.size() == 1);\n\n\t\t// TODO make the AFPSet consistent\n\t\t// TODO lots more block properties & old AFP properties \n\n\t\t// Recalculate superposition\n\t\tAtom[] atoms1 = new Atom[alignLen];\n\t\tAtom[] atoms2 = new Atom[alignLen];\n\n\t\tint pos=0;\n\t\tfor(List<ResiduePair> block:blocks ) {\n\t\t\tfor(ResiduePair pair:block) {\n\t\t\t\tatoms1[pos] = ca1[pair.a];\n\t\t\t\t// Clone residue to allow modification\n\t\t\t\tAtom atom2 = ca2duplicated[pair.b];\n\t\t\t\tGroup g = (Group) atom2.getGroup().clone();\n\t\t\t\tatoms2[pos] = g.getAtom( atom2.getName() );\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tassert(pos == alignLen);\n\t\t\n\t\t// Sets the rotation matrix in ceCalc to the proper value\n\t\tdouble rmsd = -1;\n\t\tdouble tmScore = 0.;\n\t\tdouble[] blockRMSDs = new double[blocks.size()];\n\t\tMatrix[] blockRotationMatrices = new Matrix[blocks.size()];\n\t\tAtom[] blockShifts = new Atom[blocks.size()];\n\n\t\tif(alignLen>0) {\n\t\t\t// superimpose\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(atoms1, atoms2);\n\n\t\t\tMatrix matrix = svd.getRotation();\n\t\t\tAtom shift = svd.getTranslation();\n\n\t\t\tfor( Atom a : atoms2 ) {\n\t\t\t\tCalc.rotate(a.getGroup(), matrix);\n\t\t\t\tCalc.shift(a, shift);\n\t\t\t}\n\t\t\t\n\t\t\t//and get overall rmsd\n\t\t\trmsd = SVDSuperimposer.getRMS(atoms1, atoms2);\n\t\t\ttmScore = SVDSuperimposer.getTMScore(atoms1, atoms2, ca1.length, ca2len);\n\n\t\t\t// set all block rotations to the overall rotation\n\t\t\t// It's not well documented if this is the expected behavior, but\n\t\t\t// it seems to work.\n\t\t\tblockRotationMatrices[0] = matrix;\n\t\t\tblockShifts[0] = shift;\n\t\t\tblockRMSDs[0] = -1;\n\n\t\t\tfor(int i=1;i<blocks.size();i++) {\n\t\t\t\tblockRMSDs[i] = -1; //TODO Recalculate for the FATCAT text format\n\t\t\t\tblockRotationMatrices[i] = (Matrix) blockRotationMatrices[0].clone();\n\t\t\t\tblockShifts[i] = (Atom) blockShifts[0].clone();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tnewAFPChain.setOptRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRmsd(blockRMSDs);\n\t\tnewAFPChain.setBlockRotationMatrix(blockRotationMatrices);\n\t\tnewAFPChain.setBlockShiftVector(blockShifts);\n\t\tnewAFPChain.setTotalRmsdOpt(rmsd);\n\t\tnewAFPChain.setTMScore( tmScore );\n\t\t\n\t\t// Clean up remaining properties using the FatCat helper method\n\t\tAtom[] ca2 = new Atom[ca2len];\n\t\tSystem.arraycopy(ca2duplicated, 0, ca2, 0, ca2len);\n\t\tAFPAlignmentDisplay.getAlign(newAFPChain, ca1, ca2duplicated);\n\n\t\treturn newAFPChain;\n\t}\n\n\tprivate static int[] countCtermResidues(int[] block, int blockLen,\n\t\t\tint cEnd, int overlapLength) {\n\t\tint[] cTermResCount = new int[overlapLength+1]; // # res at or to the right of i within overlap\n\t\tcTermResCount[overlapLength] = 0;\n\t\tint alignPos = blockLen - 1;\n\t\tfor(int i=overlapLength-1;i>=0;i--) { // i starts at the c-term and increases to the left\n\t\t\tif(block[alignPos] == cEnd - overlapLength+1 + i) { // matches the aligned pair\n\t\t\t\t// the c-term contains the -ith overlapping residue\n\t\t\t\tcTermResCount[i] = cTermResCount[i+1]+1;\n\t\t\t\talignPos--;\n\t\t\t} else {\n\t\t\t\tcTermResCount[i] = cTermResCount[i+1];\n\t\t\t}\n\t\t}\n\t\treturn cTermResCount;\n\t}\n\n\tprivate static int[] countNtermResidues(int[] block, int nStart,\n\t\t\tint overlapLength) {\n\t\tint[] nTermResCount = new int[overlapLength+1]; // increases monotonically\n\t\tnTermResCount[0] = 0;\n\t\tint alignPos = 0; // index of the next aligned pair\n\n\t\tfor(int i=1;i<=overlapLength;i++) {\n\t\t\tif(block[alignPos] == nStart + i-1 ) { // matches the aligned pair\n\t\t\t\t// the n-term contains the ith overlapping residue\n\t\t\t\tnTermResCount[i] = nTermResCount[i-1]+1;\n\t\t\t\talignPos++;\n\t\t\t} else {\n\t\t\t\tnTermResCount[i] = nTermResCount[i-1];\n\t\t\t}\n\t\t}\n\t\treturn nTermResCount;\n\t}\n\n\n\t/**\n\t * A light class to store an alignment between two residues.\n\t * @author Spencer Bliven\n\t * @see #filterDuplicateAFPs()\n\t */\n\tprivate static class ResiduePair {\n\t\tpublic int a;\n\t\tpublic int b;\n\t\tpublic ResiduePair(int a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn a+\":\"+b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Tiny wrapper for the disallowed regions of an alignment.\n\t * @see CeCPMain#calculateMinCP(int[], int, int, int)\n\t * @author Spencer Bliven\n\t *\n\t */\n\tprotected static class CPRange {\n\t\t/**\n\t\t * last allowed n-term\n\t\t */\n\t\tpublic int n;\n\t\t/**\n\t\t * midpoint of the alignment\n\t\t */\n\t\tpublic int mid;\n\t\t/**\n\t\t * first allowed c-term\n\t\t */\n\t\tpublic int c;\n\t}\n\t\n\t/**\n\t * Finds the alignment index of the residues minCPlength before and after\n\t * the duplication.\n\t *  \n\t * @param block The permuted block being considered, generally optAln[0][1]\n\t * @param blockLen The length of the block (in case extra memory was allocated in block)\n\t * @param ca2len The length, in residues, of the protein specified by block\n\t * @param minCPlength The minimum number of residues allowed for a CP\n\t * @return a CPRange with the following components:\n\t *  <dl><dt>n</dt><dd>Index into <code>block</code> of the residue such that\n\t *  \t<code>minCPlength</code> residues remain to the end of <code>ca2len</code>,\n\t *  \tor -1 if no residue fits that criterium.</dd>\n\t *  <dt>mid</dt><dd>Index of the first residue higher than <code>ca2len</code>.</dd>\n\t *  <dt>c</dt><dd>Index of <code>minCPlength</code>-th residue after ca2len,\n\t *  \tor ca2len*2 if no residue fits that criterium.</dd>\n\t *  </dl>\n\t */\n\tprotected static CPRange calculateMinCP(int[] block, int blockLen, int ca2len, int minCPlength) {\n\t\tCPRange range = new CPRange();\n\t\t\n\t\t// Find the cut point within the alignment.\n\t\t// Either returns the index i of the alignment such that block[i] == ca2len,\n\t\t// or else returns -i-1 where block[i] is the first element > ca2len.\n\t\tint middle = Arrays.binarySearch(block, ca2len);\n\t\tif(middle < 0) {\n\t\t\tmiddle = -middle -1;\n\t\t}\n\t\t// Middle is now the first res after the duplication\n\t\trange.mid = middle;\n\t\t\n\t\tint minCPntermIndex = middle-minCPlength;\n\t\tif(minCPntermIndex >= 0) {\n\t\t\trange.n = block[minCPntermIndex];\n\t\t} else {\n\t\t\trange.n = -1;\n\t\t}\n\t\t\n\t\tint minCPctermIndex = middle+minCPlength-1;\n\t\tif(minCPctermIndex < blockLen) {\n\t\t\trange.c = block[minCPctermIndex];\n\t\t} else {\n\t\t\trange.c = ca2len*2;\n\t\t}\n\n\t\t// Stub:\n\t\t// Best-case: assume all residues in the termini are aligned\n\t\t//range.n = ca2len - minCPlength; \n\t\t//range.c = ca2len + minCPlength-1;\n\t\t\n\t\treturn range;\n\t}\n\t\n\t\n\tprivate static class CutPoint {\n\t\tpublic int numResiduesCut;\n\t\tpublic int firstRes;\n\t\tpublic int lastRes;\n\t}\n\t\n\tprivate static CutPoint calculateCutPoint(int[] block,int nStart, int cEnd,\n\t\t\tint overlapLength, int alignLen, int minCPlength, int ca2len, int firstRes) {\n\t\t\n\t\t// We require at least minCPlength residues in a block.\n\t\t//TODO calculate these explicitely based on the alignment\n\t\t\n\t\t// The last valid n-term\n\t\tCPRange minCP = calculateMinCP(block, alignLen, ca2len, minCPlength);\n\t\tint minCPnterm = minCP.n;\n\t\t// The first valid c-term\n\t\tint minCPcterm = minCP.c;\n\t\t\n\n\t\t// # res at or to the left of i within the overlap\n\t\tint[] nTermResCount = countNtermResidues(block, nStart,\n\t\t\t\toverlapLength);\n\t\t\n\t\t// Determine the position with the largest sum of lengths\n\t\tint[] cTermResCount = countCtermResidues(block, alignLen,\n\t\t\t\tcEnd, overlapLength);\n\t\t\n\t\t// Alignment length for a cut at the left of the overlap\n\t\tint maxResCount=-1;\n\t\tfor(int i=0;i<=overlapLength;i++) { // i is the position of the CP within the overlap region\n\t\t\t// Calculate number of residues which remain after the CP\n\t\t\tint nRemain,cRemain;\n\t\t\tif(nStart+i <= minCPnterm) {\n\t\t\t\tnRemain = nTermResCount[overlapLength]-nTermResCount[i];\n\t\t\t} else {\n\t\t\t\tnRemain = 0;\n\t\t\t}\n\t\t\tif(cEnd-overlapLength+i >= minCPcterm) {\n\t\t\t\tcRemain = cTermResCount[0] - cTermResCount[i];\n\t\t\t} else {\n\t\t\t\tcRemain = 0;\n\t\t\t}\n\n\t\t\t// Look for the cut point which cuts off the minimum number of res\n\t\t\tif(nRemain + cRemain > maxResCount ) { // '>' biases towards keeping the n-term \n\t\t\t\tmaxResCount = nRemain + cRemain;\n\t\t\t\tfirstRes = nStart+ i;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate the number of residues cut within the overlap\n\t\tint numResiduesCut = nTermResCount[overlapLength]+cTermResCount[0]-maxResCount;\n\t\t\n\t\t// Remove short blocks\n\t\tif(firstRes > minCPnterm) {\n\t\t\t// update number of residues cut for those outside the overlap\n\t\t\tnumResiduesCut += 0; //TODO\n\t\t\t\n\t\t\tfirstRes = ca2len;\n\t\t} \n\n\t\tint lastRes = firstRes+ca2len-1;\n\t\tif(lastRes < minCPcterm) {\n\t\t\t// update number of residues cut for those outside the overlap\n\t\t\tnumResiduesCut += 0; //TODO\n\n\t\t\tlastRes = ca2len-1;\n\t\t}\n\t\t\n\n\t\tCutPoint cp = new CutPoint();\n\t\tcp.firstRes=firstRes;\n\t\tcp.numResiduesCut = numResiduesCut;\n\t\tcp.lastRes = lastRes;\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Found a CP at residue %d. Trimming %d aligned residues from %d-%d of block 0 and %d-%d of block 1.\\n\",\n\t\t\t\t\tfirstRes,cp.numResiduesCut,nStart,firstRes-1,firstRes, cEnd-ca2len);\n\t\t}\n\t\t\n\t\treturn cp;\n\t}\n\n\n\t// try showing a GUI\n\t// requires additional dependencies biojava3-structure-gui and JmolApplet\n\t// TODO dmyersturnbull: This should probably be in structure-gui\n\t@SuppressWarnings(\"unused\")\n\tprivate static void displayAlignment(AFPChain afpChain, Atom[] ca1, Atom[] ca2) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, StructureException {\n\t\tAtom[] ca1clone = StructureTools.cloneCAArray(ca1);\n\t\tAtom[] ca2clone = StructureTools.cloneCAArray(ca2);\n\t\tif (! GuiWrapper.isGuiModuleInstalled()) {\n\t\t\tSystem.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n\t\t\t// display alignment in console\n\t\t\tSystem.out.println(afpChain.toCE(ca1clone, ca2clone));\n\t\t} else {\n\t\t\tObject jmol = GuiWrapper.display(afpChain,ca1clone,ca2clone);\n\t\t\tGuiWrapper.showAlignmentImage(afpChain, ca1clone,ca2clone,jmol);\n\t\t}\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n * \n */\npackage org.biojava.bio.structure.align.ce;\n\n//import static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.AminoAcidImpl;\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.AtomImpl;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.ChainImpl;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.ce.CECalculator;\nimport org.biojava.bio.structure.align.ce.CeCPMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.PDBParseException;\nimport org.junit.*;\n\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class CeCPMainTest extends TestCase {\n\n\t@Test\n\tpublic void testFilterDuplicateAFPs() throws Exception {\n\t\tint[][][] dupAlign = new int[1][2][];\n\n\t\tint ca2len = 12;\n\t\tdupAlign[0][0] = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13 };\n\t\tdupAlign[0][1] = new int[] { 3, 5, 6, 7, 8, 9,10,11, 0+ca2len, 1+ca2len, 2+ca2len, 3+ca2len, 4+ca2len, 7+ca2len };\n\t\tAtom[] ca1,ca2;\n\t\t\n\t\tca1 = makeDummyCA(dupAlign[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tAFPChain afp = makeDummyAFPChain(dupAlign, ca1, ca2);\n\n\t\tCECPParameters params = new CECPParameters();\n\t\tparams.setMinCPLength(0);\n//\t\tAFPChain newAFP = (AFPChain) filterDuplicateAFPs.invoke(null, afp, new CECalculator(null), ca1, ca2);\n\t\tAFPChain newAFP = CeCPMain.filterDuplicateAFPs(afp, new CECalculator(null), ca1, ca2, params);\n\n\t\tint[][][] align = newAFP.getOptAln();\n\t\tint[] blkLen = newAFP.getOptLen();\n\t\t// optimal alignment should be\n\t\t//  1  2  3  4  5  6  7 | 8  9 10 11 12\n\t\t//  5  6  7  8  9 10 11 | 0  1  2  3  4\n\t\tint[][][] expected = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 1,  2,  3,  4,  5,  6,  7, },\n\t\t\t\t\t\tnew int[] { 5,  6,  7,  8,  9, 10, 11, },\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 8,  9, 10, 11, 12, },\n\t\t\t\t\t\tnew int[] { 0,  1,  2,  3,  4, },\n\t\t\t\t},\n\t\t};\n\t\t\n\t\tint[] expectedLen = new int[] { expected[0][0].length, expected[1][0].length };\n\t\t\n\t\tassertTrue(Arrays.deepEquals(expected, align));\n\t\tassertTrue(Arrays.equals(expectedLen, blkLen));\n\t\t\n\t}\n\n\t@Test\n\tpublic void testFilterDuplicateAFPsMinLenCTerm() throws PDBParseException, StructureException {\n\t\tint[][][] startAln, filteredAln;\n\t\tint[] filteredLen;\n\t\tint ca2len;\n\t\t\n\t\tca2len = 10;\n\t\tstartAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  0, 3, 5, 6, 7, 8, 9, 0+ca2len, 1+ca2len, 2+ca2len, 3+ca2len,},\n\t\t\t\t},\n\t\t};\n\t\t\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain,result;\n\t\tca1 = makeDummyCA(startAln[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tafpChain = makeDummyAFPChain(startAln, ca1, ca2);\n\n\t\t\n\t\t\n\t\t// Best block with minCPlen 0-3\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  1, 2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  3, 5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 7, 8, 9,},\n\t\t\t\t\t\tnew int[] { 0, 1, 2,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\t\t\n\t\tCECPParameters params = new CECPParameters();\n\t\t\n\t\t\n\t\tfor(int minCPlength=0;minCPlength<4;minCPlength++) {\n\t\t\tparams.setMinCPLength(minCPlength);\n\t\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\t\t\n\t\t\tassertTrue(\"Wrong optAln for minCPlength=\"+minCPlength,Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\t\tassertTrue(\"Wrong optLen for minCPlength=\"+minCPlength,Arrays.equals(filteredLen, result.getOptLen()));\n\t}\n\n\t\t// For minCPlength=4, filtering changes\n\t\tparams.setMinCPLength(4);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] { 0, 1, 2, 3,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// For minCPlength=5, filtering changes\n\t\tparams.setMinCPLength(5);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  0, 3, 5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\tparams.setMinCPLength(7);\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// Eventually, no alignment!\n\t\tparams.setMinCPLength(8);\n\t\tfilteredAln = new int[0][][];\n\t\tfilteredLen = new int[0];\n\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t}\n\n\t@Test\n\tpublic void testFilterDuplicateAFPsMinLenNTerm() throws PDBParseException, StructureException {\n\t\tint[][][] startAln, filteredAln;\n\t\tint ca2len;\n\n\t\t// minCPLen == 5\n\t\tca2len = 10;\n\t\tstartAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  6, 8, 9,10,11,12,13,14,16,17,19,},\n\t\t\t\t},\n\t\t};\n\n\t\t// The longest alignment would include the second 0-3\n\t\t// However, this leads to a short block\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  1, 2,},\n\t\t\t\t\t\tnew int[] {  8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7, 8, 9,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 6, 7,},\n\t\t\t\t},\n\t\t};\n\n\t\tint[] filteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain,result;\n\t\tca1 = makeDummyCA(startAln[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tafpChain = makeDummyAFPChain(startAln, ca1, ca2);\n\n\t\tCECPParameters params = new CECPParameters();\n\n\t\tfor(int minCPlength=0;minCPlength<3;minCPlength++) {\n\t\t\tparams.setMinCPLength(minCPlength);\n\t\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\t\t}\n\n\t\t// For minCPlength=3, filtering changes\n\t\tparams.setMinCPLength(3);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2,},\n\t\t\t\t\t\tnew int[] {  6, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// For minCPlength=4, filtering changes\n\t\tparams.setMinCPLength(5);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 6, 7, 9,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\tparams.setMinCPLength(8);\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// Eventually, no alignment!\n\t\tparams.setMinCPLength(9);\n\t\tfilteredAln = new int[0][][];\n\t\tfilteredLen = new int[0];\n\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t}\n\n\n\t/**\n\t * Creates a minimal AFPChain from the specified alignment and proteins\n\t * @param dupAlign\n\t * @param ca1\n\t * @param ca2\n\t * @return\n\t */\n\tprivate AFPChain makeDummyAFPChain(int[][][] dupAlign, Atom[] ca1,Atom[] ca2) {\n\t\tAFPChain afp = new AFPChain();\n\t\tafp.setOptAln(dupAlign);\n\t\tafp.setOptLength(dupAlign[0][1].length);\n\t\tafp.setCa1Length(ca1.length);\n\t\tafp.setCa2Length(ca2.length);\n\t\tafp.setBlockNum(1);\n\t\tafp.setOptLen(new int[] {dupAlign[0][1].length});\n\t\treturn afp;\n\t}\n\t\n\t\n\t@Test\n\tpublic void testCalculateMinCP() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] block;\n\t\tint ca2len;\n\n\t\tblock = new int[] { 4,5,6,8,11,12,14,15, };\n\t\tca2len = 10;\n\n\t\tint minCPlength;\n\t\tCeCPMain.CPRange cpRange;\n\n\t\tminCPlength = 0;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,11,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,8,cpRange.c);\n\n\t\tminCPlength = 1;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,8,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,11,cpRange.c);\n\n\t\tminCPlength = 2;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,6,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,12,cpRange.c);\n\n\t\tminCPlength = 3;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,5,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,14,cpRange.c);\n\n\t\tminCPlength = 4;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,4,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,15,cpRange.c);\n\n\t\tminCPlength = 5;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t\tblock = new int[] {0,9,10,19};\n\t\tca2len = 10;\n\n\t\tminCPlength = 0;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,10,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,9,cpRange.c);\n\n\t\tminCPlength = 1;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,9,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,10,cpRange.c);\n\n\t\tminCPlength = 2;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,0,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,19,cpRange.c);\n\n\t\tminCPlength = 3;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t\tminCPlength = 4;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t}\n\n\t/**\n\t * Makes dummy CA atoms at 1A intervals\n\t * \n\t * @param len\n\t * @return\n\t * @throws PDBParseException\n\t */\n\tprivate Atom[] makeDummyCA(int len) throws PDBParseException {\n\t\tAtom[] ca1;\n\t\tChain chain1 = new ChainImpl();\n\t\t//Some dummy Atoms. Just check they're unique\n\t\tca1 = new Atom[len];\n\t\tfor(int i=0;i<len;i++) {\n\t\t\tca1[i] = new AtomImpl();\n\t\t\tca1[i].setName(\"CA\");\n\t\t\tca1[i].setCoords(new double[] { i, 0, 0 });\n\t\t\tGroup aa = new AminoAcidImpl();\n\t\t\taa.setPDBName(\"GLY\");\n\t\t\taa.setResidueNumber( ResidueNumber.fromString(i+\"\"));\n\t\t\taa.addAtom(ca1[i]);\n\t\t\tchain1.addGroup(aa);\n\t\t}\n\t\treturn ca1;\n\t}\n\t\n\tpublic void testCECP1() throws IOException, StructureException{ \n\n\t\tString name1 = \"PDP:3A2KAc\";\n\t\tString name2 = \"d1wy5a2\";\n\n\n\t\tCeCPMain algorithm = new CeCPMain();\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\t\tAFPChain afpChain = algorithm.align(ca1, ca2);\n\t\tCECalculator calculator = algorithm.getCECalculator();\n\n\t\t//               System.out.println(calculator.get);\n\t\t//StructureAlignmentJmol jmol =\n\t\t//StructureAlignmentDisplay.display(afpChain, ca1, ca2);\n\t\tif ( ! (afpChain.getBlockNum() == 1)){\n\t\t\tSystem.out.println(calculator.getLcmp());\n\t\t\tSystem.out.println(afpChain.toFatcat(ca1, ca2));\n\t\t}\n\t\tassertEquals(1,afpChain.getBlockNum());\n\n\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n * \n */\npackage org.biojava.bio.structure.align.ce;\n\n//import static org.junit.Assert.*;\n\nimport junit.framework.TestCase;\nimport org.biojava.bio.structure.*;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.PDBParseException;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Arrays;\n\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class CeCPMainTest extends TestCase {\n\n\t@Test\n\tpublic void testFilterDuplicateAFPs() throws Exception {\n\t\tint[][][] dupAlign = new int[1][2][];\n\n\t\tint ca2len = 12;\n\t\tdupAlign[0][0] = new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13 };\n\t\tdupAlign[0][1] = new int[] { 3, 5, 6, 7, 8, 9,10,11, 0+ca2len, 1+ca2len, 2+ca2len, 3+ca2len, 4+ca2len, 7+ca2len };\n\t\tAtom[] ca1,ca2;\n\t\t\n\t\tca1 = makeDummyCA(dupAlign[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tAFPChain afp = makeDummyAFPChain(dupAlign, ca1, ca2);\n\n\t\tCECPParameters params = new CECPParameters();\n\t\tparams.setMinCPLength(0);\n//\t\tAFPChain newAFP = (AFPChain) filterDuplicateAFPs.invoke(null, afp, new CECalculator(null), ca1, ca2);\n\t\tAFPChain newAFP = CeCPMain.filterDuplicateAFPs(afp, new CECalculator(null), ca1, ca2, params);\n\n\t\tint[][][] align = newAFP.getOptAln();\n\t\tint[] blkLen = newAFP.getOptLen();\n\t\t// optimal alignment should be\n\t\t//  1  2  3  4  5  6  7 | 8  9 10 11 12\n\t\t//  5  6  7  8  9 10 11 | 0  1  2  3  4\n\t\tint[][][] expected = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 1,  2,  3,  4,  5,  6,  7, },\n\t\t\t\t\t\tnew int[] { 5,  6,  7,  8,  9, 10, 11, },\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 8,  9, 10, 11, 12, },\n\t\t\t\t\t\tnew int[] { 0,  1,  2,  3,  4, },\n\t\t\t\t},\n\t\t};\n\t\t\n\t\tint[] expectedLen = new int[] { expected[0][0].length, expected[1][0].length };\n\t\t\n\t\tassertTrue(Arrays.deepEquals(expected, align));\n\t\tassertTrue(Arrays.equals(expectedLen, blkLen));\n\t\t\n\t}\n\n\t@Test\n\tpublic void testFilterDuplicateAFPsMinLenCTerm() throws PDBParseException, StructureException {\n\t\tint[][][] startAln, filteredAln;\n\t\tint[] filteredLen;\n\t\tint ca2len;\n\t\t\n\t\tca2len = 10;\n\t\tstartAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  0, 3, 5, 6, 7, 8, 9, 0+ca2len, 1+ca2len, 2+ca2len, 3+ca2len,},\n\t\t\t\t},\n\t\t};\n\t\t\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain,result;\n\t\tca1 = makeDummyCA(startAln[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tafpChain = makeDummyAFPChain(startAln, ca1, ca2);\n\n\t\t\n\t\t\n\t\t// Best block with minCPlen 0-3\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  1, 2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  3, 5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 7, 8, 9,},\n\t\t\t\t\t\tnew int[] { 0, 1, 2,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\t\t\n\t\tCECPParameters params = new CECPParameters();\n\t\t\n\t\t\n\t\tfor(int minCPlength=0;minCPlength<4;minCPlength++) {\n\t\t\tparams.setMinCPLength(minCPlength);\n\t\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\t\t\n\t\t\tassertTrue(\"Wrong optAln for minCPlength=\"+minCPlength,Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\t\tassertTrue(\"Wrong optLen for minCPlength=\"+minCPlength,Arrays.equals(filteredLen, result.getOptLen()));\n\t}\n\n\t\t// For minCPlength=4, filtering changes\n\t\tparams.setMinCPLength(4);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] { 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] { 0, 1, 2, 3,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// For minCPlength=5, filtering changes\n\t\tparams.setMinCPLength(5);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6,},\n\t\t\t\t\t\tnew int[] {  0, 3, 5, 6, 7, 8, 9,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\tparams.setMinCPLength(7);\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// Eventually, no alignment!\n\t\tparams.setMinCPLength(8);\n\t\tfilteredAln = new int[0][][];\n\t\tfilteredLen = new int[0];\n\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t}\n\n\t@Test\n\tpublic void testFilterDuplicateAFPsMinLenNTerm() throws PDBParseException, StructureException {\n\t\tint[][][] startAln, filteredAln;\n\t\tint ca2len;\n\n\t\t// minCPLen == 5\n\t\tca2len = 10;\n\t\tstartAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  6, 8, 9,10,11,12,13,14,16,17,19,},\n\t\t\t\t},\n\t\t};\n\n\t\t// The longest alignment would include the second 0-3\n\t\t// However, this leads to a short block\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  1, 2,},\n\t\t\t\t\t\tnew int[] {  8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7, 8, 9,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 6, 7,},\n\t\t\t\t},\n\t\t};\n\n\t\tint[] filteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain,result;\n\t\tca1 = makeDummyCA(startAln[0][0].length);\n\t\tca2 = makeDummyCA(ca2len);\n\t\tca2 = StructureTools.duplicateCA2(ca2);\n\t\tafpChain = makeDummyAFPChain(startAln, ca1, ca2);\n\n\t\tCECPParameters params = new CECPParameters();\n\n\t\tfor(int minCPlength=0;minCPlength<3;minCPlength++) {\n\t\t\tparams.setMinCPLength(minCPlength);\n\t\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\t\t}\n\n\t\t// For minCPlength=3, filtering changes\n\t\tparams.setMinCPLength(3);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  0, 1, 2,},\n\t\t\t\t\t\tnew int[] {  6, 8, 9,},\n\t\t\t\t},\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length, filteredAln[1][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// For minCPlength=4, filtering changes\n\t\tparams.setMinCPLength(5);\n\t\tfilteredAln = new int[][][] {\n\t\t\t\tnew int[][] {\n\t\t\t\t\t\tnew int[] {  3, 4, 5, 6, 7, 8, 9,10,},\n\t\t\t\t\t\tnew int[] {  0, 1, 2, 3, 4, 6, 7, 9,},\n\t\t\t\t},\n\t\t};\n\t\tfilteredLen = new int[] { filteredAln[0][0].length };\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\tparams.setMinCPLength(8);\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t\t// Eventually, no alignment!\n\t\tparams.setMinCPLength(9);\n\t\tfilteredAln = new int[0][][];\n\t\tfilteredLen = new int[0];\n\n\n\t\tresult = CeCPMain.filterDuplicateAFPs(afpChain, new CECalculator(null), ca1, ca2,params);\n\n\t\tassertTrue(\"Wrong optAln for minCPlength=\"+params.getMinCPLength(),Arrays.deepEquals(filteredAln, result.getOptAln()));\n\t\tassertTrue(\"Wrong optLen for minCPlength=\"+params.getMinCPLength(),Arrays.equals(filteredLen, result.getOptLen()));\n\n\t}\n\n\n\t/**\n\t * Creates a minimal AFPChain from the specified alignment and proteins\n\t * @param dupAlign\n\t * @param ca1\n\t * @param ca2\n\t * @return\n\t */\n\tprivate AFPChain makeDummyAFPChain(int[][][] dupAlign, Atom[] ca1,Atom[] ca2) {\n\t\tAFPChain afp = new AFPChain();\n\t\tafp.setOptAln(dupAlign);\n\t\tafp.setOptLength(dupAlign[0][1].length);\n\t\tafp.setCa1Length(ca1.length);\n\t\tafp.setCa2Length(ca2.length);\n\t\tafp.setBlockNum(1);\n\t\tafp.setOptLen(new int[] {dupAlign[0][1].length});\n\t\treturn afp;\n\t}\n\t\n\t\n\t@Test\n\tpublic void testCalculateMinCP() throws SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException {\n\t\tint[] block;\n\t\tint ca2len;\n\n\t\tblock = new int[] { 4,5,6,8,11,12,14,15, };\n\t\tca2len = 10;\n\n\t\tint minCPlength;\n\t\tCeCPMain.CPRange cpRange;\n\n\t\tminCPlength = 0;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,11,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,8,cpRange.c);\n\n\t\tminCPlength = 1;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,8,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,11,cpRange.c);\n\n\t\tminCPlength = 2;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,6,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,12,cpRange.c);\n\n\t\tminCPlength = 3;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,5,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,14,cpRange.c);\n\n\t\tminCPlength = 4;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,4,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,15,cpRange.c);\n\n\t\tminCPlength = 5;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t\tblock = new int[] {0,9,10,19};\n\t\tca2len = 10;\n\n\t\tminCPlength = 0;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,10,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,9,cpRange.c);\n\n\t\tminCPlength = 1;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,9,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,10,cpRange.c);\n\n\t\tminCPlength = 2;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,0,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,19,cpRange.c);\n\n\t\tminCPlength = 3;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t\tminCPlength = 4;\n\t\tcpRange = CeCPMain.calculateMinCP(block, block.length, ca2len, minCPlength);\n\t\tassertEquals(\"Wrong minCPnterm for minCPlen=\"+minCPlength,-1,cpRange.n);\n\t\tassertEquals(\"Wrong minCPcterm for minCPlen=\"+minCPlength,20,cpRange.c);\n\n\t}\n\n\t/**\n\t * Makes dummy CA atoms at 1A intervals\n\t * \n\t * @param len\n\t * @return\n\t * @throws PDBParseException\n\t */\n\tprivate Atom[] makeDummyCA(int len) throws PDBParseException {\n\t\tAtom[] ca1;\n\t\tChain chain1 = new ChainImpl();\n\t\t//Some dummy Atoms. Just check they're unique\n\t\tca1 = new Atom[len];\n\t\tfor(int i=0;i<len;i++) {\n\t\t\tca1[i] = new AtomImpl();\n\t\t\tca1[i].setName(\"CA\");\n\t\t\tca1[i].setCoords(new double[] { i, 0, 0 });\n\t\t\tGroup aa = new AminoAcidImpl();\n\t\t\taa.setPDBName(\"GLY\");\n\t\t\taa.setResidueNumber( ResidueNumber.fromString(i+\"\"));\n\t\t\taa.addAtom(ca1[i]);\n\t\t\tchain1.addGroup(aa);\n\t\t}\n\t\treturn ca1;\n\t}\n\t\n\tpublic void testCECP1() throws IOException, StructureException{ \n\n\t\tString name1 = \"PDP:3A2KAc\";\n\t\tString name2 = \"d1wy5a2\";\n\n\n\t\tCeCPMain algorithm = new CeCPMain();\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\tAtom[] ca1 = cache.getAtoms(name1);\n\t\tAtom[] ca2 = cache.getAtoms(name2);\n\n\t\tAFPChain afpChain = algorithm.align(ca1, ca2);\n\t\tCECalculator calculator = algorithm.getCECalculator();\n\n\t\t//               System.out.println(calculator.get);\n\t\t//StructureAlignmentJmol jmol =\n\t\t//StructureAlignmentDisplay.display(afpChain, ca1, ca2);\n\t\tif ( ! (afpChain.getBlockNum() == 1)){\n\t\t\tSystem.out.println(calculator.getLcmp());\n\t\t\tSystem.out.println(afpChain.toFatcat(ca1, ca2));\n\t\t}\n\t\tassertEquals(1,afpChain.getBlockNum());\n\n\n\t}\n\n}\n","commitMessage":"Ran Optimize Imports across the whole project.\n","test_commitMessage":"Ran Optimize Imports across the whole project.\n","allZero":false}