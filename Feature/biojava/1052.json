{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/ecod/EcodInstallation.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/ecod/EcodInstallationTest.java","prod_time":"2022-02-21 16:16:33","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b8e69a4b022aaa6b5f5ecfbd31de70e32358ce85","test_commitID":"","isfound":"not found test change","originPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.ecod;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.PdbId;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.core.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides access to the Evolutionary Classification of Protein Domains (ECOD).\n *\n * The preferred mechanism for obtaining instances of this class is through the\n * {@link EcodFactory} class.\n *\n * Reference:\n * H. Cheng, R. D. Schaeffer, Y. Liao, L. N. Kinch, J. Pei, S. Shi, B. H.\\\n *   Kim, N. V. Grishin. (2014) ECOD: An evolutionary classification of protein\n *   domains. PLoS Comput Biol 10(12): e1003926.\n * http://prodata.swmed.edu/ecod/\n *\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallation implements EcodDatabase {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\t// ECOD identifiers are e<pdbID><chain><domain>, where chain and domain\n\t// Chain and domain can both be multi-letter (e.g. e2q7zA10)\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"^e(....).+\\\\d+$\");\n\n\n\tprivate String cacheLocation;\n\tprivate String requestedVersion; // version requested, e.g. \"latest\". Used for the paths\n\tprivate String parsedVersion; // actual version parsed\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<PdbId,List<EcodDomain>> domainMap;//PDB ID -> domains, lazily constructed from allDomains\n\n\tprivate String url;\n\n\t// Frequency of ECOD updates, in days. If non-null, redownloads \"latest\" if older than this.\n\tprivate Integer updateFrequency = 14;\n\n\t/**\n\t * Use EcodFactory to create instances. The instantiation of multiple\n\t * installations at the same path can lead to race conditions when downloading\n\t * files.\n\t * @param cacheLocation Location to save files, typically from the PDB_CACHE_DIR parameter\n\t * @param requestedVersion ECOD requestedVersion to fetch\n\t */\n\tpublic EcodInstallation(String cacheLocation, String version) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.requestedVersion = version;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\t/**\n\t * @see EcodFactory#getEcodDatabase()\n\t */\n\tpublic EcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath(), DEFAULT_VERSION );\n\t}\n\t/**\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tthis( cacheLocation, DEFAULT_VERSION );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param id\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getDomainsForPdb(String id) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\n\t\t\tPdbId pdbId = null;\n\t\t\ttry {\n\t\t\t\tpdbId = new PdbId(id);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of domains within a particular level of the hierarchy\n\t * @param hierarchy A dot-separated list giving the X-group, H-group, and/or\n\t *  T-group (e.g. \"1.1\" for all members of the RIFT-related H-group)\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> filterByHierarchy(String hierarchy) throws IOException {\n\t\tString[] xhtGroup = hierarchy.split(\"\\\\.\");\n\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\tList<EcodDomain> filtered = new ArrayList<EcodDomain>();\n\t\tfor(EcodDomain d: getAllDomains()) {\n\t\t\tboolean match = true;\n\t\t\tif(xhtGroup.length>0) {\n\t\t\t\tmatch = match && xGroup.equals(d.getXGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>1) {\n\t\t\t\tmatch = match && hGroup.equals(d.getHGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>2) {\n\t\t\t\tmatch = match && tGroup.equals(d.getTGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>3) {\n\t\t\t\tlogger.warn(\"Ignoring unexpected additional parts of ECOD {}\",hierarchy);\n\t\t\t}\n\t\t\tif(match) {\n\t\t\t\tfiltered.add(d);\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Get a particular ECOD domain by the domain ID (e.g. \"e4hhbA1\")\n\t * @param ecodId\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPdb(pdbId);\n\t\tif(doms == null) {\n\t\t\tlogger.debug(\"Null domains for {} from {}\",pdbId,ecodId);\n\t\t\treturn null;\n\t\t}\n\t\tlogger.debug(\"Got {} domains from {}\",doms.size(),pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get all ECOD domains\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\t/**\n\t * Return the ECOD version, as parsed from the file.\n\t *\n\t * Note that this may differ from the version requested in the constructor\n\t * for the special case of \"latest\"\n\t * @return the ECOD version\n\t * @throws IOException If an error occurs while downloading or parsing the file\n\t */\n\t@Override\n\tpublic String getVersion() throws IOException {\n\t\tensureDomainsFileInstalled();\n\n\t\tif( parsedVersion == null) {\n\t\t\treturn requestedVersion;\n\t\t}\n\t\treturn parsedVersion;\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tthis.cacheLocation = cacheLocation;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t *\n\t * This may be useful in multithreaded environments.\n\t * @throws IOException\n\t */\n\t// Populates allDomains\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\tif (!f.exists() || f.length() <= 0 )\n\t\t\t\treturn false;\n\n\t\t\t// Re-download old copies of \"latest\"\n\t\t\tif(updateFrequency != null && requestedVersion == DEFAULT_VERSION ) {\n\t\t\t\tlong mod = f.lastModified();\n\t\t\t\t// Time of last update\n\t\t\t\tDate lastUpdate = new Date();\n\t\t\t\tCalendar cal = Calendar.getInstance();\n\t\t\t\tcal.setTime(lastUpdate);\n\t\t\t\tcal.add(Calendar.DAY_OF_WEEK, -updateFrequency);\n\t\t\t\tlong updateTime = cal.getTimeInMillis();\n\t\t\t\t// Check if file predates last update\n\t\t\t\tif( mod < updateTime ) {\n\t\t\t\t\tlogger.info(\"{} is out of date.\",f);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current requestedVersion.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,requestedVersion);\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * The expected ECOD update frequency determines whether the version\n\t * \"latest\" should be re-downloaded\n\t * @return the expected ECOD update frequency, in days\n\t */\n\tpublic Integer getUpdateFrequency() {\n\t\treturn updateFrequency;\n\t}\n\n\t/**\n\t * The \"latest\" version will be re-downloaded if it is older than\n\t * {@link #getUpdateFrequency()} days. Setting this to null disables\n\t * re-downloading (delete $PDB_CACHE_DIR/ecod.latest.domains.txt manually\n\t * to force updating). Setting to 0 will force downloading for every\n\t * program execution.\n\t * @param updateFrequency the updateFrequency to set\n\t */\n\tpublic void setUpdateFrequency(Integer updateFrequency) {\n\t\tthis.updateFrequency = updateFrequency;\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t\tparsedVersion = parser.getVersion();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap from allDomains\n\t * @throws IOException\n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<PdbId, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tPdbId pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = new PdbId(match.group(1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\t\t/*\nVersion Notes\n\nCurrent version (1.4) contains the following columns:\n\nColumn 1: ECOD uid - internal domain unique identifier\nColumn 2: ECOD domain id - domain identifier\nColumn 3: ECOD representative status - manual (curated) or automated nonrep\nColumn 4: ECOD hierachy identifier - [X-group].[H-group].[T-group].[F-group]\n\t* In develop45-66 these also include single numbers in the range 1-265\nColumn 5: PDB identifier\nColumn 6: Chain identifier (note: case-sensitive)\nColumn 7: PDB residue number range\n\t* These are sometimes incorrect up to at least develop124. Examples are:\n\t  e4lxaA2 (should be A:184-385), e4lxmC3 (should be C:46P-183)\nColumn 8: seq_id number range (based on internal PDB indices)\nColumn 9: Architecture name\nColumn 10: X-group name\nColumn 11: H-group name\nColumn 12: T-group name\nColumn 13: F-group name (F_UNCLASSIFIED denotes that domain has not been assigned to an F-group)\nColumn 14: Domain assembly status (if domain is member of assembly, partners' ecod domain ids listed)\nColumn 15: Comma-separated value list of non-polymer entities within 4 A of at least one residue of domain\n\nNotes older versions:\nchangelog:\nv1.0 - original version (8/04/2014)\nv1.1 - added rep/nonrep data (1/15/2015)\nv1.2 - added f-group identifiers to fasta file, domain description file. ECODf identifiers now used when available for F-group name.\n\tDomain assemblies now represented by assembly uid in domain assembly status.\nv1.4 - added seqid_range and headers (develop101)\n\t\t */\n\n\t\t/** String for unclassified F-groups */\n\t\tpublic static final String F_UNCLASSIFIED = \"F_UNCLASSIFIED\";\n\t\t/** String for single-domain assemblies */\n\t\tpublic static final String NOT_DOMAIN_ASSEMBLY = \"NOT_DOMAIN_ASSEMBLY\";\n\t\t/** Deprecated way of indicating there is an assembly. replaced by the assembly id */\n\t\tpublic static final String IS_DOMAIN_ASSEMBLY = \"IS_DOMAIN_ASSEMBLY\";\n\t\t/** Indicates a manual representative */\n\t\tpublic static final String IS_REPRESENTATIVE = \"MANUAL_REP\";\n\t\t/** Indicates not a manual representative */\n\t\tpublic static final String NOT_REPRESENTATIVE = \"AUTO_NONREP\";\n\n\t\tprivate List<EcodDomain> domains;\n\t\tprivate String version;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tversion = null;\n\t\t\tparse(reader);\n\t\t}\n\n\t\tprivate void parse(BufferedReader in) throws IOException {\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015\n\t\t\t\tArrayList<EcodDomain> domainsList = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tPattern versionRE = Pattern.compile(\"^\\\\s*#.*ECOD\\\\s*version\\\\s+(\\\\S+).*\");\n\t\t\t\tPattern commentRE = Pattern.compile(\"^\\\\s*#.*\");\n\n\t\t\t\t// prevent too many warnings; negative numbers print all warnings\n\t\t\t\tint warnIsDomainAssembly = 1;\n\t\t\t\tint warnHierarchicalFormat = 5;\n\t\t\t\tint warnNumberOfFields = 10;\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 1;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Check for requestedVersion string\n\t\t\t\t\tMatcher match = versionRE.matcher(line);\n\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t// special requestedVersion comment\n\t\t\t\t\t\tthis.version = match.group(1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = commentRE.matcher(line);\n\t\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t\t// ignore comments\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// data line\n\t\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\t\tif( fields.length == 13 || fields.length == 14 || fields.length == 15) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\t\t//Column 1: ECOD uid - internal domain unique identifier\n\t\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\t\t//Column 2: ECOD domain id - domain identifier\n\t\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\n\t\t\t\t\t\t\t\t\t//Column 3: ECOD representative status - manual (curated) or automated nonrep\n\t\t\t\t\t\t\t\t\t// Manual column may be missing in version 1.0 files\n\t\t\t\t\t\t\t\t\tBoolean manual = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 14) {\n\t\t\t\t\t\t\t\t\t\tString manualString = fields[i++];\n\t\t\t\t\t\t\t\t\t\tif(manualString.equalsIgnoreCase(IS_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = true;\n\t\t\t\t\t\t\t\t\t\t} else if(manualString.equalsIgnoreCase(NOT_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = false;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for manual field: {} in line {}\",manualString,lineNum);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Column 4: ECOD hierachy identifier - [X-group].[H-group].[T-group].[F-group]\n\t\t\t\t\t\t\t\t\t// hierarchical field, e.g. \"1.1.4.1\"\n\t\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\t\tif(xhtGroup.length < 3 || 4 < xhtGroup.length) {\n\t\t\t\t\t\t\t\t\t\tif(warnHierarchicalFormat > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnHierarchicalFormat != 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}. Not printing future similar warnings.\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\t\t\t\t\t\t\t\t\tInteger fGroup = xhtGroup.length>3 ? Integer.parseInt(xhtGroup[3]) : null;\n\n\t\t\t\t\t\t\t\t\t//Column 5: PDB identifier\n\t\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\t\t//Column 6: Chain identifier (note: case-sensitive)\n\t\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\t\t//Column 7: PDB residue number range\n\t\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t\t//Column 8: seq_id number range (based on internal PDB indices)\n\t\t\t\t\t\t\t\t\t//Added in version 1.4\n\t\t\t\t\t\t\t\t\tString seqId = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 15) {\n\t\t\t\t\t\t\t\t\t\tseqId = fields[i++];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Column 9: Architecture name\n\t\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 10: X-group name\n\t\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 11: H-group name\n\t\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 12: T-group name\n\t\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 13: F-group name (F_UNCLASSIFIED denotes that domain has not been assigned to an F-group)\n\t\t\t\t\t\t\t\t\t//Contents changed in version 1.3\n\t\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\n\t\t\t\t\t\t\t\t\thGroupName = clearStringQuotes(hGroupName);\n\t\t\t\t\t\t\t\t\ttGroupName = clearStringQuotes(tGroupName);\n\t\t\t\t\t\t\t\t\tfGroupName = clearStringQuotes(fGroupName);\n\t\t\t\t\t\t\t\t\txGroupName = clearStringQuotes(xGroupName);\n\n\t\t\t\t\t\t\t\t\t//Column 14: Domain assembly status (if domain is member of assembly, partners' ecod domain ids listed)\n\t\t\t\t\t\t\t\t\t//Column 15: Comma-separated value list of non-polymer entities within 4 A of at least one residue of domain\n\t\t\t\t\t\t\t\t\tLong assemblyId = null;\n\t\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\t\tif(assemblyStr.equals(NOT_DOMAIN_ASSEMBLY)) {\n\t\t\t\t\t\t\t\t\t\tassemblyId = uid;\n\t\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\") ) {\n\t\t\t\t\t\t\t\t\t\tif(warnIsDomainAssembly > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnIsDomainAssembly == 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}. Not printing future similar warnings.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//assemblyId = null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tassemblyId = Long.parseLong(assemblyStr);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, fGroup,pdbId, chainId, range, seqId, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, assemblyId, ligands);\n\t\t\t\t\t\t\t\t\tdomainsList.add(domain);\n\t\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(warnNumberOfFields > 1) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\twarnNumberOfFields--;\n\t\t\t\t\t\t\t\t} else if(warnNumberOfFields == 0) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}. Not printing future similar warnings\",lineNum);\n\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tif(this.version == null)\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domainsList.size());\n\t\t\t\telse\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains from version {}\",domainsList.size(),this.version);\n\n\n\t\t\t\tthis.domains = Collections.unmodifiableList( domainsList );\n\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate String clearStringQuotes(String name) {\n\t\t\tif ( name.startsWith(\"\\\"\"))\n\t\t\t\tname = name.substring(1);\n\n\t\t\tif ( name.endsWith(\"\\\"\"))\n\t\t\t\tname = name.substring(0,name.length()-1);\n\n\t\t\treturn name;\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return the requestedVersion for this file, or null if none was parsed\n\t\t */\n\t\tpublic String getVersion() {\n\t\t\treturn version;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tString version = null;\n\t\ttry {\n\t\t\tversion = getVersion();\n\t\t} catch (IOException e) {\n\t\t\t// For parsing errors, use the requested version\n\t\t\tversion = requestedVersion;\n\t\t}\n\n\t\treturn \"EcodInstallation [cacheLocation=\" + cacheLocation\n\t\t\t\t+ \", version=\" + version + \"]\";\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","changedPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.ecod;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.PdbId;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.core.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides access to the Evolutionary Classification of Protein Domains (ECOD).\n *\n * The preferred mechanism for obtaining instances of this class is through the\n * {@link EcodFactory} class.\n *\n * Reference:\n * H. Cheng, R. D. Schaeffer, Y. Liao, L. N. Kinch, J. Pei, S. Shi, B. H.\\\n *   Kim, N. V. Grishin. (2014) ECOD: An evolutionary classification of protein\n *   domains. PLoS Comput Biol 10(12): e1003926.\n * http://prodata.swmed.edu/ecod/\n *\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallation implements EcodDatabase {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\t// ECOD identifiers are e<pdbID><chain><domain>, where chain and domain\n\t// Chain and domain can both be multi-letter (e.g. e2q7zA10)\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"^e(....).+\\\\d+$\");\n\n\n\tprivate String cacheLocation;\n\tprivate String requestedVersion; // version requested, e.g. \"latest\". Used for the paths\n\tprivate String parsedVersion; // actual version parsed\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<PdbId,List<EcodDomain>> domainMap;//PDB ID -> domains, lazily constructed from allDomains\n\n\tprivate String url;\n\n\t// Frequency of ECOD updates, in days. If non-null, redownloads \"latest\" if older than this.\n\tprivate Integer updateFrequency = 14;\n\n\t/**\n\t * Use EcodFactory to create instances. The instantiation of multiple\n\t * installations at the same path can lead to race conditions when downloading\n\t * files.\n\t * @param cacheLocation Location to save files, typically from the PDB_CACHE_DIR parameter\n\t * @param requestedVersion ECOD requestedVersion to fetch\n\t */\n\tpublic EcodInstallation(String cacheLocation, String version) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.requestedVersion = version;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\t/**\n\t * @see EcodFactory#getEcodDatabase()\n\t */\n\tpublic EcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath(), DEFAULT_VERSION );\n\t}\n\t/**\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tthis( cacheLocation, DEFAULT_VERSION );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param id\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getDomainsForPdb(String id) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\n\t\t\tPdbId pdbId = null;\n\t\t\ttry {\n\t\t\t\tpdbId = new PdbId(id);\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of domains within a particular level of the hierarchy\n\t * @param hierarchy A dot-separated list giving the X-group, H-group, and/or\n\t *  T-group (e.g. \"1.1\" for all members of the RIFT-related H-group)\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> filterByHierarchy(String hierarchy) throws IOException {\n\t\tString[] xhtGroup = hierarchy.split(\"\\\\.\");\n\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\tList<EcodDomain> filtered = new ArrayList<EcodDomain>();\n\t\tfor(EcodDomain d: getAllDomains()) {\n\t\t\tboolean match = true;\n\t\t\tif(xhtGroup.length>0) {\n\t\t\t\tmatch = match && xGroup.equals(d.getXGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>1) {\n\t\t\t\tmatch = match && hGroup.equals(d.getHGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>2) {\n\t\t\t\tmatch = match && tGroup.equals(d.getTGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>3) {\n\t\t\t\tlogger.warn(\"Ignoring unexpected additional parts of ECOD {}\",hierarchy);\n\t\t\t}\n\t\t\tif(match) {\n\t\t\t\tfiltered.add(d);\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Get a particular ECOD domain by the domain ID (e.g. \"e4hhbA1\")\n\t * @param ecodId\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPdb(pdbId);\n\t\tif(doms == null) {\n\t\t\tlogger.debug(\"Null domains for {} from {}\",pdbId,ecodId);\n\t\t\treturn null;\n\t\t}\n\t\tlogger.debug(\"Got {} domains from {}\",doms.size(),pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get all ECOD domains\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\t/**\n\t * Return the ECOD version, as parsed from the file.\n\t *\n\t * Note that this may differ from the version requested in the constructor\n\t * for the special case of \"latest\"\n\t * @return the ECOD version\n\t * @throws IOException If an error occurs while downloading or parsing the file\n\t */\n\t@Override\n\tpublic String getVersion() throws IOException {\n\t\tensureDomainsFileInstalled();\n\n\t\tif( parsedVersion == null) {\n\t\t\treturn requestedVersion;\n\t\t}\n\t\treturn parsedVersion;\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tthis.cacheLocation = cacheLocation;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t *\n\t * This may be useful in multithreaded environments.\n\t * @throws IOException\n\t */\n\t// Populates allDomains\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\tif (! (f.exists() && FileDownloadUtils.validateFile(f)))\n\t\t\t\treturn false;\n\n\t\t\t// Re-download old copies of \"latest\"\n\t\t\tif(updateFrequency != null && requestedVersion == DEFAULT_VERSION ) {\n\t\t\t\tlong mod = f.lastModified();\n\t\t\t\t// Time of last update\n\t\t\t\tDate lastUpdate = new Date();\n\t\t\t\tCalendar cal = Calendar.getInstance();\n\t\t\t\tcal.setTime(lastUpdate);\n\t\t\t\tcal.add(Calendar.DAY_OF_WEEK, -updateFrequency);\n\t\t\t\tlong updateTime = cal.getTimeInMillis();\n\t\t\t\t// Check if file predates last update\n\t\t\t\tif( mod < updateTime ) {\n\t\t\t\t\tlogger.info(\"{} is out of date.\",f);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.createValidationFiles(domainsURL, localFile, null);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t\tif(! FileDownloadUtils.validateFile(localFile))\n\t\t\t\tthrow new IOException(\"Downloaded file invalid: \"+ localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current requestedVersion.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,requestedVersion);\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * The expected ECOD update frequency determines whether the version\n\t * \"latest\" should be re-downloaded\n\t * @return the expected ECOD update frequency, in days\n\t */\n\tpublic Integer getUpdateFrequency() {\n\t\treturn updateFrequency;\n\t}\n\n\t/**\n\t * The \"latest\" version will be re-downloaded if it is older than\n\t * {@link #getUpdateFrequency()} days. Setting this to null disables\n\t * re-downloading (delete $PDB_CACHE_DIR/ecod.latest.domains.txt manually\n\t * to force updating). Setting to 0 will force downloading for every\n\t * program execution.\n\t * @param updateFrequency the updateFrequency to set\n\t */\n\tpublic void setUpdateFrequency(Integer updateFrequency) {\n\t\tthis.updateFrequency = updateFrequency;\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t\tparsedVersion = parser.getVersion();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap from allDomains\n\t * @throws IOException\n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<PdbId, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tPdbId pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = new PdbId(match.group(1));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\t\t/*\nVersion Notes\n\nCurrent version (1.4) contains the following columns:\n\nColumn 1: ECOD uid - internal domain unique identifier\nColumn 2: ECOD domain id - domain identifier\nColumn 3: ECOD representative status - manual (curated) or automated nonrep\nColumn 4: ECOD hierachy identifier - [X-group].[H-group].[T-group].[F-group]\n\t* In develop45-66 these also include single numbers in the range 1-265\nColumn 5: PDB identifier\nColumn 6: Chain identifier (note: case-sensitive)\nColumn 7: PDB residue number range\n\t* These are sometimes incorrect up to at least develop124. Examples are:\n\t  e4lxaA2 (should be A:184-385), e4lxmC3 (should be C:46P-183)\nColumn 8: seq_id number range (based on internal PDB indices)\nColumn 9: Architecture name\nColumn 10: X-group name\nColumn 11: H-group name\nColumn 12: T-group name\nColumn 13: F-group name (F_UNCLASSIFIED denotes that domain has not been assigned to an F-group)\nColumn 14: Domain assembly status (if domain is member of assembly, partners' ecod domain ids listed)\nColumn 15: Comma-separated value list of non-polymer entities within 4 A of at least one residue of domain\n\nNotes older versions:\nchangelog:\nv1.0 - original version (8/04/2014)\nv1.1 - added rep/nonrep data (1/15/2015)\nv1.2 - added f-group identifiers to fasta file, domain description file. ECODf identifiers now used when available for F-group name.\n\tDomain assemblies now represented by assembly uid in domain assembly status.\nv1.4 - added seqid_range and headers (develop101)\n\t\t */\n\n\t\t/** String for unclassified F-groups */\n\t\tpublic static final String F_UNCLASSIFIED = \"F_UNCLASSIFIED\";\n\t\t/** String for single-domain assemblies */\n\t\tpublic static final String NOT_DOMAIN_ASSEMBLY = \"NOT_DOMAIN_ASSEMBLY\";\n\t\t/** Deprecated way of indicating there is an assembly. replaced by the assembly id */\n\t\tpublic static final String IS_DOMAIN_ASSEMBLY = \"IS_DOMAIN_ASSEMBLY\";\n\t\t/** Indicates a manual representative */\n\t\tpublic static final String IS_REPRESENTATIVE = \"MANUAL_REP\";\n\t\t/** Indicates not a manual representative */\n\t\tpublic static final String NOT_REPRESENTATIVE = \"AUTO_NONREP\";\n\n\t\tprivate List<EcodDomain> domains;\n\t\tprivate String version;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tversion = null;\n\t\t\tparse(reader);\n\t\t}\n\n\t\tprivate void parse(BufferedReader in) throws IOException {\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015\n\t\t\t\tArrayList<EcodDomain> domainsList = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tPattern versionRE = Pattern.compile(\"^\\\\s*#.*ECOD\\\\s*version\\\\s+(\\\\S+).*\");\n\t\t\t\tPattern commentRE = Pattern.compile(\"^\\\\s*#.*\");\n\n\t\t\t\t// prevent too many warnings; negative numbers print all warnings\n\t\t\t\tint warnIsDomainAssembly = 1;\n\t\t\t\tint warnHierarchicalFormat = 5;\n\t\t\t\tint warnNumberOfFields = 10;\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 1;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Check for requestedVersion string\n\t\t\t\t\tMatcher match = versionRE.matcher(line);\n\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t// special requestedVersion comment\n\t\t\t\t\t\tthis.version = match.group(1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = commentRE.matcher(line);\n\t\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t\t// ignore comments\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// data line\n\t\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\t\tif( fields.length == 13 || fields.length == 14 || fields.length == 15) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\t\t//Column 1: ECOD uid - internal domain unique identifier\n\t\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\t\t//Column 2: ECOD domain id - domain identifier\n\t\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\n\t\t\t\t\t\t\t\t\t//Column 3: ECOD representative status - manual (curated) or automated nonrep\n\t\t\t\t\t\t\t\t\t// Manual column may be missing in version 1.0 files\n\t\t\t\t\t\t\t\t\tBoolean manual = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 14) {\n\t\t\t\t\t\t\t\t\t\tString manualString = fields[i++];\n\t\t\t\t\t\t\t\t\t\tif(manualString.equalsIgnoreCase(IS_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = true;\n\t\t\t\t\t\t\t\t\t\t} else if(manualString.equalsIgnoreCase(NOT_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = false;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for manual field: {} in line {}\",manualString,lineNum);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Column 4: ECOD hierachy identifier - [X-group].[H-group].[T-group].[F-group]\n\t\t\t\t\t\t\t\t\t// hierarchical field, e.g. \"1.1.4.1\"\n\t\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\t\tif(xhtGroup.length < 3 || 4 < xhtGroup.length) {\n\t\t\t\t\t\t\t\t\t\tif(warnHierarchicalFormat > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnHierarchicalFormat != 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}. Not printing future similar warnings.\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\t\t\t\t\t\t\t\t\tInteger fGroup = xhtGroup.length>3 ? Integer.parseInt(xhtGroup[3]) : null;\n\n\t\t\t\t\t\t\t\t\t//Column 5: PDB identifier\n\t\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\t\t//Column 6: Chain identifier (note: case-sensitive)\n\t\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\t\t//Column 7: PDB residue number range\n\t\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t\t//Column 8: seq_id number range (based on internal PDB indices)\n\t\t\t\t\t\t\t\t\t//Added in version 1.4\n\t\t\t\t\t\t\t\t\tString seqId = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 15) {\n\t\t\t\t\t\t\t\t\t\tseqId = fields[i++];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t//Column 9: Architecture name\n\t\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 10: X-group name\n\t\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 11: H-group name\n\t\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 12: T-group name\n\t\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\t//Column 13: F-group name (F_UNCLASSIFIED denotes that domain has not been assigned to an F-group)\n\t\t\t\t\t\t\t\t\t//Contents changed in version 1.3\n\t\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\n\t\t\t\t\t\t\t\t\thGroupName = clearStringQuotes(hGroupName);\n\t\t\t\t\t\t\t\t\ttGroupName = clearStringQuotes(tGroupName);\n\t\t\t\t\t\t\t\t\tfGroupName = clearStringQuotes(fGroupName);\n\t\t\t\t\t\t\t\t\txGroupName = clearStringQuotes(xGroupName);\n\n\t\t\t\t\t\t\t\t\t//Column 14: Domain assembly status (if domain is member of assembly, partners' ecod domain ids listed)\n\t\t\t\t\t\t\t\t\t//Column 15: Comma-separated value list of non-polymer entities within 4 A of at least one residue of domain\n\t\t\t\t\t\t\t\t\tLong assemblyId = null;\n\t\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\t\tif(assemblyStr.equals(NOT_DOMAIN_ASSEMBLY)) {\n\t\t\t\t\t\t\t\t\t\tassemblyId = uid;\n\t\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\") ) {\n\t\t\t\t\t\t\t\t\t\tif(warnIsDomainAssembly > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnIsDomainAssembly == 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}. Not printing future similar warnings.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t//assemblyId = null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tassemblyId = Long.parseLong(assemblyStr);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, fGroup,pdbId, chainId, range, seqId, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, assemblyId, ligands);\n\t\t\t\t\t\t\t\t\tdomainsList.add(domain);\n\t\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(warnNumberOfFields > 1) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\twarnNumberOfFields--;\n\t\t\t\t\t\t\t\t} else if(warnNumberOfFields == 0) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}. Not printing future similar warnings\",lineNum);\n\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tif(this.version == null)\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domainsList.size());\n\t\t\t\telse\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains from version {}\",domainsList.size(),this.version);\n\n\n\t\t\t\tthis.domains = Collections.unmodifiableList( domainsList );\n\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate String clearStringQuotes(String name) {\n\t\t\tif ( name.startsWith(\"\\\"\"))\n\t\t\t\tname = name.substring(1);\n\n\t\t\tif ( name.endsWith(\"\\\"\"))\n\t\t\t\tname = name.substring(0,name.length()-1);\n\n\t\t\treturn name;\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return the requestedVersion for this file, or null if none was parsed\n\t\t */\n\t\tpublic String getVersion() {\n\t\t\treturn version;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tString version = null;\n\t\ttry {\n\t\t\tversion = getVersion();\n\t\t} catch (IOException e) {\n\t\t\t// For parsing errors, use the requested version\n\t\t\tversion = requestedVersion;\n\t\t}\n\n\t\treturn \"EcodInstallation [cacheLocation=\" + cacheLocation\n\t\t\t\t+ \", version=\" + version + \"]\";\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","originTest":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.test.ecod;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.core.util.ConcurrencyTools;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.ecod.EcodDatabase;\nimport org.biojava.nbio.structure.ecod.EcodDomain;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.ecod.EcodInstallation;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallationTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallationTest.class);\n\tprivate static final String VERSION = \"develop204\"; // Should be updated periodically\n\n\t// Info about known versions, for testing\n\tprivate static final int DEVELOP_FIRST_VERSION = 124;\n\tprivate static final int DEVELOP_LATEST_VERSION = 204; // Should be updated periodically\n\t//versions known to be unreleased\n\tprivate static final List<Integer> DEVELOP_VERSIONS_BLACKLIST = Arrays.asList( 85, 107, 113, 125, 128, 131,\n\t\t\t147, 151, 162, 165, 176, 177, 181, 185, 197, 200, 202 );\n\n\tstatic {\n\t\t//System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\");\n\t}\n\t@Rule\n\tpublic TemporaryFolder tmpFolder = new TemporaryFolder();\n\t@Test\n\tpublic void testDownloads() throws IOException {\n\t\t// Use second installation with tmp location to avoid overwriting main cache\n\t\tEcodInstallation ecod2 = new EcodInstallation(tmpFolder.getRoot().getAbsolutePath(),VERSION);\n\t\t// Delete old VERSION\n\t\tFile domainsFile = new File(ecod2.getCacheLocation(),\"ecod.\"+VERSION+\".domains.txt\");\n\t\tif( domainsFile.exists() ) {\n\t\t\tdomainsFile.delete();\n\t\t}\n\t\t// Force download\n\t\tecod2.ensureDomainsFileInstalled();\n\t\t// Check for download\n\t\tassertTrue(\"No downloaded file at \"+domainsFile.toString(),domainsFile.exists());\n\t}\n\n\n\t@Test\n\tpublic void testAllDomains() throws IOException {\n\t\tint expected;\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> domains = ecod.getAllDomains();\n\t\t// Taken from the official ecod stats file\n\t\tswitch(VERSION) {\n\t\tcase \"develop77\":\n\t\t\texpected = 423825; //version77\n\t\t\tbreak;\n\t\tcase \"develop78\":\n\t\t\texpected = 423869; //version78\n\t\t\tbreak;\n\t\tcase \"develop124\":\n\t\t\texpected = 468680; //version124\n\t\t\tbreak;\n\t\tcase \"develop133\":\n\t\t\texpected = 479738; //version133\n\t\t\tbreak;\n\t\tcase \"develop134\":\n\t\t\texpected = 483056; //version134 (stats file)\n\t\t\tbreak;\n\t\tcase \"develop135\":\n\t\t\texpected = 483812; //version135 (stats file)\n\t\t\tbreak;\n\t\tcase \"develop136\":\n\t\t\texpected = 484847; //version136 (stats file differs: 484463)\n\t\t\tbreak;\n\t\tcase \"develop204\":\n\t\t\texpected = 592427;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfail(\"Unrecognized version \"+VERSION);\n\t\t\treturn;\n\t\t}\n\t\tassertEquals(\"Wrong number of domains\",expected,domains.size());\n\t}\n\n\t@Test\n\tpublic void testByPDB() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString pdbId;\n\t\tString[] expectedDomains;\n\t\tList<EcodDomain> domains;\n\n\t\tpdbId = \"1lyw\";\n\t\texpectedDomains = new String[] {\"e1lyw.1\",\"e1lyw.2\",\"e1lyw.3\",\"e1lyw.4\"};\n\t\tdomains = ecod.getDomainsForPdb(pdbId);\n\n\t\tmatchNames(pdbId,expectedDomains,domains);\n\n\t}\n\n\tprivate void matchNames(String pdbId,String[] expected,List<EcodDomain> actual) {\n\t\tassertEquals(\"Wrong number of domains for \"+pdbId, expected.length, actual.size());\n\t\tSet<String> exp = new HashSet<String>(Arrays.asList(expected));\n\t\tfor(EcodDomain d : actual) {\n\t\t\tassertTrue(\"Unexpected domain \"+d.getDomainId()+\" in \"+pdbId,exp.contains(d.getDomainId()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testParsing() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString ecodId;\n\t\tEcodDomain domain,expected;\n\n\t\tecodId = \"e1lyw.1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\t// fGroup reassigned around dev200\n\t\tint fGroup;\n\t\tString fGroupName;\n\t\tif( ecod.getVersion().compareToIgnoreCase(\"develop200\") < 0 ) {\n\t\t\tfGroup = 2;\n\t\t\tfGroupName = \"EF00710\";\n\t\t} else {\n\t\t\tfGroup = 43;\n\t\t\tfGroupName = \"Asp_C,Asp_N\";\n\t\t}\n\t\texpected = new EcodDomain(\n\t\t\t\t//\t\t\t\tLong uid, String domainId, Boolean manual,\n\t\t\t\t20669l, \"e1lyw.1\", false,\n\t\t\t\t//\t\t\t\tInteger xGroup, Integer hGroup, Integer tGroup, Integer fGroup, String pdbId,\n\t\t\t\t1,1,1,fGroup,\"1lyw\",\n\t\t\t\t//\t\t\t\tString chainName, String range, String seqId, String architectureName,\n\t\t\t\t\".\", \"A:3-97,B:106-346\", \"A:3-97,B:1-241\", \"beta barrels\",\n\t\t\t\t//\t\t\t\tString xGroupName, String hGroupName, String tGroupName,\n\t\t\t\t\"cradle loop barrel\", \"RIFT-related\",\"acid protease\",\n\t\t\t\t//\t\t\t\tString fGroupName, Boolean isAssembly, List<String> ligands\n\t\t\t\tfGroupName,\n\t\t\t\t20669l, Collections.singleton(\"EPE\")\n\t\t\t\t);\n\t\tassertEquals(ecodId,expected,domain);\n\n\t\tecodId = \"e4v4fAA1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\tassertNotNull(ecodId,domain);\n\t\tassertEquals(ecodId,ecodId,domain.getDomainId());\n\t}\n\n\t@Test\n\tpublic void testMultithreaded() throws IOException {\n\t\tfinal EcodInstallation ecod = (EcodInstallation) EcodFactory.getEcodDatabase(VERSION);\n\t\tecod.clear();\n\t\tString[] ecodIds = new String[] {\n\t\t\t\t\"e4s1gA1\", \"e4umoB1\", \"e4v0cA1\", \"e4v1af1\", \"e3j7yj1\", \"e4wfcA1\",\"e4b0jP1\",\n\t\t};\n\t\tList<Future<EcodDomain>> futureDomains = new ArrayList<Future<EcodDomain>>();\n\t\tfor(final String ecodId : ecodIds) {\n\t\t\tCallable<EcodDomain> job = new Callable<EcodDomain>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EcodDomain call() throws Exception {\n\t\t\t\t\tlogger.info(\"Running \"+ecodId);\n\t\t\t\t\tEcodDomain d = ecod.getDomainsById(ecodId);\n\t\t\t\t\tlogger.info(\"Finished \"+ecodId);\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Job fetching ECOD \"+ecodId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<EcodDomain> future = ConcurrencyTools.submit(job,ecodId);\n\t\t\tfutureDomains.add(future);\n\t\t}\n\t\tint successful = 0;\n\t\tfor(Future<EcodDomain> future : futureDomains) {\n\t\t\ttry {\n\t\t\t\tEcodDomain domain = future.get(60, TimeUnit.SECONDS);\n\t\t\t\tif(domain != null) {\n\t\t\t\t\tsuccessful++;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" interrupted\",e);\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" error\",e);\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" timed out\",e);\n\t\t\t}\n\n\t\t}\n\t\tassertEquals(ecodIds.length, successful);\n\t}\n\n\t@Test\n\tpublic void testFilterByHierarchy() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> filtered;\n\t\tSet<String> expected,actual;\n\n\t\t// expected members through at least develop133\n\t\texpected = new HashSet<String>(Arrays.asList(\n\t\t\t\t\"e4il6R1 e4pj0R1 e4pj0r1 e4ub6R1 e4ub8R1\".split(\" \") ));\n\t\t// expanded by develop204\n\t\tif( ecod.getVersion().compareToIgnoreCase(\"develop204\") >= 0) {\n\t\t\texpected.addAll(Arrays.asList(\n\t\t\t\t\t(\"e5kafR1 e5kafr1 e5kaiR1 e5kair1 e5tisR1 e5tisr1 e5gthR1 e5gtiR1 \"\n\t\t\t\t\t\t\t+ \"e5ws5R1 e5ws6R1 e5mx2R1 e5mx2r1\").split(\" \") ));\n\t\t}\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\t}\n\n\t@Test\n\tpublic void testVersion() throws IOException {\n\t\tEcodDatabase ecod3 = EcodFactory.getEcodDatabase(\"latest\");\n\t\tString version = ecod3.getVersion();\n\t\tassertNotNull(version);\n\t\tassertNotEquals(\"latest\", version);\n\t}\n\n\t/**\n\t * Parses all known versions. Only fails due to exceptions, so manually check for warnings.\n\t * Hierarchical field warnings are expected for versions prior to develop68.\n\t * @throws IOException\n\t */\n\t@Ignore // Very slow parsing test\n\t@Test\n\tpublic void testAllVersions() throws IOException {\n\t\t// List all versions\n\t\tList<String> versions = getKnownEcodVersions();\n\t\tversions.add(EcodFactory.DEFAULT_VERSION);\n\n\t\t// Parse all versions\n\t\tfor(String version : versions) {\n\t\t\tEcodInstallation ecod = (EcodInstallation)EcodFactory.getEcodDatabase(version);\n\t\t\tecod.getAllDomains();\n\t\t\tSystem.out.println(version +\" -> \"+ ecod.getVersion());\n\n\t\t\t// Force garbage collection of all soft references\n\t\t\t// This shouldn't be required, but without it we get\n\t\t\t// 'OutOfMemoryError: GC overhead limit exceeded'.\n\t\t\t// Probably this is due to synchronization in EcodFactory blocking\n\t\t\t// the GC during parsing. -Spencer\n\t\t\tecod = null;\n\t\t\tSystem.gc();\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tObject[] ignored = new Object[(int) Runtime.getRuntime().maxMemory()];\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// Ignore OME\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testGetStructure() throws IOException, StructureException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\t// Save ECOD version, since AtomCache uses the global default\n\t\tString prevECOD = EcodFactory.getEcodDatabase().getVersion();\n\t\tEcodFactory.setEcodDatabase(\"develop124\");\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase();\n\n\t\tString name;\n\t\tEcodDomain id;\n\t\tList<ResidueRange> ranges;\n\n\t\t// Test some cases where Chain and domain number are ambiguous\n\t\tname = \"e1wz2B14\";\n\t\tid = ecod.getDomainsById(name);\n\t\tassertEquals(name, id.getIdentifier());\n\t\tranges = id.getResidueRanges();\n\t\tassertEquals(1,ranges.size());\n\t\tassertEquals(new ResidueRange(\"B\", new ResidueNumber(\"B\", 200,null), new ResidueNumber(\"B\",445,null)),ranges.get(0));\n\t\tcache.getStructure(name);\n\n\t\tname = \"e3j9zS13\";\n\t\tid = ecod.getDomainsById(name);\n\t\tassertEquals(name, id.getIdentifier());\n\t\tranges = id.getResidueRanges();\n\t\tassertEquals(1,ranges.size());\n\t\tassertEquals(new ResidueRange(\"S1\", new ResidueNumber(\"S1\", 288,null), new ResidueNumber(\"S1\",410,null)),ranges.get(0));\n\t\tcache.getStructure(name);\n\n\n\t\t// Restore previous ECOD database\n\t\tEcodFactory.setEcodDatabase(prevECOD);\n\t}\n\n\t/**\n\t * Get a list of all develop versions, generated based on the DEVELOP_*\n\t * static variables.\n\t * @return A list of all development versions: \"develop45\",\"develop46\",...\n\t */\n\tpublic static List<String> getKnownEcodVersions() {\n\t\t// Parse version from latest.\n\t\tint latestVersion = DEVELOP_LATEST_VERSION;\n\t\ttry {\n\t\t\tEcodDatabase latest = EcodFactory.getEcodDatabase(EcodFactory.DEFAULT_VERSION);\n\t\t\tString latestVersionStr;\n\t\t\tlatestVersionStr = latest.getVersion();\n\t\t\tMatcher match = Pattern.compile(\"develop([0-9]+)\",Pattern.CASE_INSENSITIVE).matcher(latestVersionStr);\n\t\t\tif(match.matches())\n\t\t\t\tlatestVersion = Integer.parseInt(match.group(1));\n\t\t\tlatest = null;\n\t\t} catch (IOException e) {}\n\t\tlatestVersion = Math.max(latestVersion, DEVELOP_LATEST_VERSION);\n\n\t\tList<String> versions = new ArrayList<>(latestVersion-DEVELOP_FIRST_VERSION+2);\n\t\tfor(int version=DEVELOP_FIRST_VERSION;version<=latestVersion;version++) {\n\t\t\tif( !DEVELOP_VERSIONS_BLACKLIST.contains(version) ) {\n\t\t\t\tversions.add(\"develop\"+version);\n\t\t\t}\n\t\t}\n\t\treturn versions;\n\t}\n}\n","changedTest":"","commitMessage":"Two utility methods to validate the downloaded file\n\nCurrently, we validate the file size only.\nWe could validate the content using any hashing function later.","test_commitMessage":"","allZero":false}