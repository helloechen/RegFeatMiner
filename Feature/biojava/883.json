{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/cif/CifFileSupplierImpl.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/cif/CifFileSupplierImplTest.java","prod_time":"2019-04-26 02:13:47","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":27,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":27,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f09a417b41484229e6bd8719c1e551a4781dfbce","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.cif.model.Block;\nimport org.rcsb.cif.model.Category;\nimport org.rcsb.cif.model.CifFile;\nimport org.rcsb.cif.model.Column;\nimport org.rcsb.cif.model.atomsite.AtomSite;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\n\n/**\n * Convert a BioJava {@link Structure} to a CifFile.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileSupplierImpl implements CifFileSupplier<Structure> {\n\n\n    @Override\n    public CifFile get(Structure structure) {\n        // for now BioJava only considered 3 categories for create a Cif representation of a structure\n\n        // cell\n        CrystalCell crystalCell = structure.getPDBHeader().getCrystallographicInfo().getCrystalCell();\n        // symmetry\n        SpaceGroup spaceGroup = structure.getPDBHeader().getCrystallographicInfo().getSpaceGroup();\n        // atom_site\n        List<WrappedAtom> wrappedAtoms = collectWrappedAtoms(structure);\n        AtomSite atomSite = wrappedAtoms.stream().collect(toAtomSite());\n\n        Block.BlockBuilder blockBuilder = CifFile.enterFile()\n                .enterBlock(structure.getPDBCode());\n\n        if (atomSite.isDefined() && atomSite.getRowCount() > 0) {\n            // set atom site\n            blockBuilder.addCategory(atomSite);\n        }\n\n        if (crystalCell != null) {\n            // set cell category\n            blockBuilder.enterCategory(\"cell\")\n                    .enterColumn(\"length_a\")\n                    .floatValues(crystalCell.getA())\n                    .leaveColumn()\n\n                    .enterColumn(\"length_b\")\n                    .floatValues(crystalCell.getB())\n                    .leaveColumn()\n\n                    .enterColumn(\"length_c\")\n                    .floatValues(crystalCell.getC())\n                    .leaveColumn()\n\n                    .enterColumn(\"angle_alpha\")\n                    .floatValues(crystalCell.getAlpha())\n                    .leaveColumn()\n\n                    .enterColumn(\"angle_beta\")\n                    .floatValues(crystalCell.getBeta())\n                    .leaveColumn()\n\n                    .enterColumn(\"angle_gamma\")\n                    .floatValues(crystalCell.getGamma())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        if (spaceGroup != null) {\n            // set symmetry category\n            blockBuilder.enterCategory(\"symmetry\")\n                    .enterColumn(\"space_group_name_H-M\")\n                    .stringValues(spaceGroup.getShortSymbol())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        return blockBuilder.leaveBlock().leaveFile();\n    }\n\n    private static List<WrappedAtom> collectWrappedAtoms(Structure structure) {\n        List<WrappedAtom> wrappedAtoms = new ArrayList<>();\n\n        for (int modelIndex = 0; modelIndex < structure.nrModels(); modelIndex++) {\n            final int model = modelIndex + 1;\n            for (Chain chain : structure.getChains(modelIndex)) {\n                final String chainName = chain.getName();\n                final String chainId = chain.getId();\n                for (Group group : chain.getAtomGroups()) {\n                    // The alt locs can have duplicates, since at parsing time we make sure that all alt loc groups have\n                    // all atoms (see StructureTools#cleanUpAltLocs)\n                    // Thus we have to remove duplicates here by using the atom id\n                    // See issue https://github.com/biojava/biojava/issues/778 and\n                    // TestAltLocs.testMmcifWritingAllAltlocs/testMmcifWritingPartialAltlocs\n                    Map<Integer, WrappedAtom> uniqueAtoms = new LinkedHashMap<>();\n                    for (int atomIndex = 0; atomIndex < group.size(); atomIndex++) {\n                        Atom atom = group.getAtom(atomIndex);\n                        if (atom == null) {\n                            continue;\n                        }\n\n                        uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                    }\n\n                    if (group.hasAltLoc()) {\n                        for (Group alt : group.getAltLocs()) {\n                            for (int atomIndex = 0; atomIndex < alt.size(); atomIndex++) {\n                                Atom atom = alt.getAtom(atomIndex);\n                                if (atom == null) {\n                                    continue;\n                                }\n\n                                uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                            }\n                        }\n                    }\n\n                    wrappedAtoms.addAll(uniqueAtoms.values());\n                }\n            }\n        }\n\n        return wrappedAtoms;\n    }\n\n    static class WrappedAtom {\n        private final Chain chain;\n        private final int model;\n        private final String chainName;\n        private final String chainId;\n        private final Atom atom;\n        private final int atomId;\n\n        public WrappedAtom(Chain chain, int model, String chainName, String chainId, Atom atom, int atomId) {\n            this.chain = chain;\n            this.model = model;\n            this.chainName = chainName;\n            this.chainId = chainId;\n            this.atom = atom;\n            this.atomId = atomId;\n        }\n\n        public Chain getChain() {\n            return chain;\n        }\n\n        public int getModel() {\n            return model;\n        }\n\n        public String getChainName() {\n            return chainName;\n        }\n\n        public String getChainId() {\n            return chainId;\n        }\n\n        public Atom getAtom() {\n            return atom;\n        }\n\n        public int getAtomId() {\n            return atomId;\n        }\n    }\n\n    private static Collector<WrappedAtom, ?, AtomSite> toAtomSite() {\n        return Collector.of(AtomSiteCollector::new,\n                AtomSiteCollector::accept,\n                AtomSiteCollector::combine,\n                AtomSiteCollector::get);\n    }\n\n    static class AtomSiteCollector implements Consumer<WrappedAtom> {\n        private final Column.StrColumnBuilder groupPDB;\n        private final Column.IntColumnBuilder id;\n        private final Column.StrColumnBuilder typeSymbol;\n        private final Column.StrColumnBuilder labelAtomId;\n        private final Column.StrColumnBuilder labelAltId;\n        private final Column.StrColumnBuilder labelCompId;\n        private final Column.StrColumnBuilder labelAsymId;\n        private final Column.StrColumnBuilder labelEntityId;\n        private final Column.IntColumnBuilder labelSeqId;\n        private final Column.StrColumnBuilder pdbxPDBInsCode;\n        private final Column.FloatColumnBuilder cartnX;\n        private final Column.FloatColumnBuilder cartnY;\n        private final Column.FloatColumnBuilder cartnZ;\n        private final Column.FloatColumnBuilder occupancy;\n        private final Column.FloatColumnBuilder bIsoOrEquiv;\n        private final Column.IntColumnBuilder authSeqId;\n        private final Column.StrColumnBuilder authCompId;\n        private final Column.StrColumnBuilder authAsymId;\n        private final Column.StrColumnBuilder authAtomId;\n        private final Column.IntColumnBuilder pdbxPDBModelNum;\n        private int atomId = 1;\n\n        AtomSiteCollector() {\n            this.groupPDB = Column.enterStrColumn(\"group_PDB\");\n            this.id = Column.enterIntColumn(\"id\");\n            this.typeSymbol = Column.enterStrColumn(\"type_symbol\");\n            this.labelAtomId = Column.enterStrColumn(\"label_atom_id\");\n            this.labelAltId = Column.enterStrColumn(\"label_alt_id\");\n            this.labelCompId = Column.enterStrColumn(\"label_comp_id\");\n            this.labelAsymId = Column.enterStrColumn(\"label_asym_id\");\n            this.labelEntityId = Column.enterStrColumn(\"label_entity_id\");\n            this.labelSeqId = Column.enterIntColumn(\"label_seq_id\");\n            this.pdbxPDBInsCode = Column.enterStrColumn(\"pdbx_PDB_ins_code\");\n            this.cartnX = Column.enterFloatColumn(\"Cartn_x\");\n            this.cartnY = Column.enterFloatColumn(\"Cartn_y\");\n            this.cartnZ = Column.enterFloatColumn(\"Cartn_z\");\n            this.occupancy = Column.enterFloatColumn(\"occupancy\");\n            this.bIsoOrEquiv = Column.enterFloatColumn(\"B_iso_or_equiv\");\n            this.authSeqId = Column.enterIntColumn(\"auth_seq_id\");\n            this.authCompId = Column.enterStrColumn(\"auth_comp_id\");\n            this.authAsymId = Column.enterStrColumn(\"auth_asym_id\");\n            this.authAtomId = Column.enterStrColumn(\"auth_atom_id\");\n            this.pdbxPDBModelNum = Column.enterIntColumn(\"pdbx_PDB_model_num\");\n        }\n\n        @Override\n        public void accept(WrappedAtom wrappedAtom) {\n            Atom atom = wrappedAtom.getAtom();\n            Group group = atom.getGroup();\n            Chain chain = group.getChain();\n\n            groupPDB.stringValues(group.getType().equals(GroupType.HETATM) ? \"HETATM\" : \"ATOM\");\n            id.intValues(wrappedAtom.getAtomId());\n            Element element = atom.getElement();\n            typeSymbol.stringValues(element.equals(Element.R) ? \"X\" : element.toString().toUpperCase());\n            labelAtomId.stringValues(atom.getName());\n            Character altLoc = atom.getAltLoc();\n            if (altLoc == null || altLoc == ' ') {\n                labelAltId.markNextNotPresent();\n            } else {\n                labelAltId.stringValues(String.valueOf(altLoc));\n            }\n            labelCompId.stringValues(group.getPDBName());\n            labelAsymId.stringValues(wrappedAtom.getChainId());\n            String entityId = \"0\";\n            int seqId = group.getResidueNumber().getSeqNum();\n            if (chain.getEntityInfo() != null) {\n                entityId = Integer.toString(chain.getEntityInfo().getMolId());\n                if (chain.getEntityInfo().getType() == EntityType.POLYMER) {\n                    // this only makes sense for polymeric chains, non-polymer chains will never have seqres groups and\n                    // there's no point in calling getAlignedResIndex\n                    seqId = chain.getEntityInfo().getAlignedResIndex(group, chain);\n                }\n            }\n            labelEntityId.stringValues(entityId);\n            labelSeqId.intValues(seqId);\n            String insCode = \"\";\n            if (group.getResidueNumber().getInsCode() != null ) {\n                insCode = Character.toString(group.getResidueNumber().getInsCode());\n            }\n            if (insCode.isEmpty()) {\n                pdbxPDBInsCode.markNextUnknown();\n            } else {\n                pdbxPDBInsCode.stringValues(insCode);\n            }\n            cartnX.floatValues(atom.getX());\n            cartnY.floatValues(atom.getY());\n            cartnZ.floatValues(atom.getZ());\n            occupancy.floatValues(atom.getOccupancy());\n            bIsoOrEquiv.floatValues(atom.getTempFactor());\n            authSeqId.intValues(group.getResidueNumber().getSeqNum());\n            authCompId.stringValues(group.getPDBName());\n            authAsymId.stringValues(wrappedAtom.getChainName());\n            authAtomId.stringValues(atom.getName());\n            pdbxPDBModelNum.intValues(wrappedAtom.getModel());\n\n            atomId++;\n        }\n\n        AtomSiteCollector combine(AtomSiteCollector other) {\n            throw new UnsupportedOperationException(\"impl by calling addAll for all collection - not feeling like writing that code\");\n        }\n        \n        @SuppressWarnings(\"Duplicates\")\n        AtomSite get() {\n            Map<String, Column> columns = new LinkedHashMap<>();\n            put(columns, groupPDB.build());\n            put(columns, groupPDB.build());\n            put(columns, id.build());\n            put(columns, typeSymbol.build());\n            put(columns, labelAtomId.build());\n            put(columns, labelAltId.build());\n            put(columns, labelCompId.build());\n            put(columns, labelAsymId.build());\n            put(columns, labelEntityId.build());\n            put(columns, labelSeqId.build());\n            put(columns, pdbxPDBInsCode.build());\n            put(columns, cartnX.build());\n            put(columns, cartnY.build());\n            put(columns, cartnZ.build());\n            put(columns, occupancy.build());\n            put(columns, bIsoOrEquiv.build());\n            put(columns, authSeqId.build());\n            put(columns, authCompId.build());\n            put(columns, authAsymId.build());\n            put(columns, authAtomId.build());\n            put(columns, pdbxPDBModelNum.build());\n\n            return (AtomSite) Category.enterCategory(\"atom_site\", columns, null).build();\n        }\n\n        private void put(Map<String, Column> columns, Column column) {\n            columns.put(column.getColumnName(), column);\n        }\n    }\n}\n","changedPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.cif.model.Block;\nimport org.rcsb.cif.model.Category;\nimport org.rcsb.cif.model.CifFile;\nimport org.rcsb.cif.model.Column;\nimport org.rcsb.cif.model.atomsite.AtomSite;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\n\n/**\n * Convert a BioJava {@link Structure} to a CifFile.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileSupplierImpl implements CifFileSupplier<Structure> {\n    @Override\n    public CifFile get(Structure structure) {\n        // for now BioJava only considered 3 categories for create a Cif representation of a structure\n\n        // cell\n        CrystalCell crystalCell = structure.getPDBHeader().getCrystallographicInfo().getCrystalCell();\n        // symmetry\n        SpaceGroup spaceGroup = structure.getPDBHeader().getCrystallographicInfo().getSpaceGroup();\n        // atom_site\n        List<WrappedAtom> wrappedAtoms = collectWrappedAtoms(structure);\n        AtomSite atomSite = wrappedAtoms.stream().collect(toAtomSite());\n\n        Block.BlockBuilder blockBuilder = CifFile.enterFile()\n                .enterBlock(structure.getPDBCode());\n\n        if (atomSite.isDefined() && atomSite.getRowCount() > 0) {\n            // set atom site\n            blockBuilder.addCategory(atomSite);\n        }\n\n        if (crystalCell != null) {\n            // set cell category\n            blockBuilder.enterCategory(\"cell\")\n                    .enterFloatColumn(\"length_a\")\n                    .floatValues(crystalCell.getA())\n                    .leaveColumn()\n\n                    .enterFloatColumn(\"length_b\")\n                    .floatValues(crystalCell.getB())\n                    .leaveColumn()\n\n                    .enterFloatColumn(\"length_c\")\n                    .floatValues(crystalCell.getC())\n                    .leaveColumn()\n\n                    .enterFloatColumn(\"angle_alpha\")\n                    .floatValues(crystalCell.getAlpha())\n                    .leaveColumn()\n\n                    .enterFloatColumn(\"angle_beta\")\n                    .floatValues(crystalCell.getBeta())\n                    .leaveColumn()\n\n                    .enterFloatColumn(\"angle_gamma\")\n                    .floatValues(crystalCell.getGamma())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        if (spaceGroup != null) {\n            // set symmetry category\n            blockBuilder.enterCategory(\"symmetry\")\n                    .enterStrColumn(\"space_group_name_H-M\")\n                    .stringValues(spaceGroup.getShortSymbol())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        return blockBuilder.leaveBlock().leaveFile();\n    }\n\n    private static List<WrappedAtom> collectWrappedAtoms(Structure structure) {\n        List<WrappedAtom> wrappedAtoms = new ArrayList<>();\n\n        for (int modelIndex = 0; modelIndex < structure.nrModels(); modelIndex++) {\n            final int model = modelIndex + 1;\n            for (Chain chain : structure.getChains(modelIndex)) {\n                final String chainName = chain.getName();\n                final String chainId = chain.getId();\n                for (Group group : chain.getAtomGroups()) {\n                    // The alt locs can have duplicates, since at parsing time we make sure that all alt loc groups have\n                    // all atoms (see StructureTools#cleanUpAltLocs)\n                    // Thus we have to remove duplicates here by using the atom id\n                    // See issue https://github.com/biojava/biojava/issues/778 and\n                    // TestAltLocs.testMmcifWritingAllAltlocs/testMmcifWritingPartialAltlocs\n                    Map<Integer, WrappedAtom> uniqueAtoms = new LinkedHashMap<>();\n                    for (int atomIndex = 0; atomIndex < group.size(); atomIndex++) {\n                        Atom atom = group.getAtom(atomIndex);\n                        if (atom == null) {\n                            continue;\n                        }\n\n                        uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                    }\n\n                    if (group.hasAltLoc()) {\n                        for (Group alt : group.getAltLocs()) {\n                            for (int atomIndex = 0; atomIndex < alt.size(); atomIndex++) {\n                                Atom atom = alt.getAtom(atomIndex);\n                                if (atom == null) {\n                                    continue;\n                                }\n\n                                uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                            }\n                        }\n                    }\n\n                    wrappedAtoms.addAll(uniqueAtoms.values());\n                }\n            }\n        }\n\n        return wrappedAtoms;\n    }\n\n    static class WrappedAtom {\n        private final Chain chain;\n        private final int model;\n        private final String chainName;\n        private final String chainId;\n        private final Atom atom;\n        private final int atomId;\n\n        public WrappedAtom(Chain chain, int model, String chainName, String chainId, Atom atom, int atomId) {\n            this.chain = chain;\n            this.model = model;\n            this.chainName = chainName;\n            this.chainId = chainId;\n            this.atom = atom;\n            this.atomId = atomId;\n        }\n\n        public Chain getChain() {\n            return chain;\n        }\n\n        public int getModel() {\n            return model;\n        }\n\n        public String getChainName() {\n            return chainName;\n        }\n\n        public String getChainId() {\n            return chainId;\n        }\n\n        public Atom getAtom() {\n            return atom;\n        }\n\n        public int getAtomId() {\n            return atomId;\n        }\n    }\n\n    private static Collector<WrappedAtom, ?, AtomSite> toAtomSite() {\n        return Collector.of(AtomSiteCollector::new,\n                AtomSiteCollector::accept,\n                AtomSiteCollector::combine,\n                AtomSiteCollector::get);\n    }\n\n    static class AtomSiteCollector implements Consumer<WrappedAtom> {\n        private final Column.StrColumnBuilder groupPDB;\n        private final Column.IntColumnBuilder id;\n        private final Column.StrColumnBuilder typeSymbol;\n        private final Column.StrColumnBuilder labelAtomId;\n        private final Column.StrColumnBuilder labelAltId;\n        private final Column.StrColumnBuilder labelCompId;\n        private final Column.StrColumnBuilder labelAsymId;\n        private final Column.StrColumnBuilder labelEntityId;\n        private final Column.IntColumnBuilder labelSeqId;\n        private final Column.StrColumnBuilder pdbxPDBInsCode;\n        private final Column.FloatColumnBuilder cartnX;\n        private final Column.FloatColumnBuilder cartnY;\n        private final Column.FloatColumnBuilder cartnZ;\n        private final Column.FloatColumnBuilder occupancy;\n        private final Column.FloatColumnBuilder bIsoOrEquiv;\n        private final Column.IntColumnBuilder authSeqId;\n        private final Column.StrColumnBuilder authCompId;\n        private final Column.StrColumnBuilder authAsymId;\n        private final Column.StrColumnBuilder authAtomId;\n        private final Column.IntColumnBuilder pdbxPDBModelNum;\n\n        AtomSiteCollector() {\n            this.groupPDB = Column.enterStrColumn(\"atom_site\", \"group_PDB\");\n            this.id = Column.enterIntColumn(\"atom_site\", \"id\");\n            this.typeSymbol = Column.enterStrColumn(\"atom_site\", \"type_symbol\");\n            this.labelAtomId = Column.enterStrColumn(\"atom_site\", \"label_atom_id\");\n            this.labelAltId = Column.enterStrColumn(\"atom_site\", \"label_alt_id\");\n            this.labelCompId = Column.enterStrColumn(\"atom_site\", \"label_comp_id\");\n            this.labelAsymId = Column.enterStrColumn(\"atom_site\", \"label_asym_id\");\n            this.labelEntityId = Column.enterStrColumn(\"atom_site\", \"label_entity_id\");\n            this.labelSeqId = Column.enterIntColumn(\"atom_site\", \"label_seq_id\");\n            this.pdbxPDBInsCode = Column.enterStrColumn(\"atom_site\", \"pdbx_PDB_ins_code\");\n            this.cartnX = Column.enterFloatColumn(\"atom_site\", \"Cartn_x\");\n            this.cartnY = Column.enterFloatColumn(\"atom_site\", \"Cartn_y\");\n            this.cartnZ = Column.enterFloatColumn(\"atom_site\", \"Cartn_z\");\n            this.occupancy = Column.enterFloatColumn(\"atom_site\", \"occupancy\");\n            this.bIsoOrEquiv = Column.enterFloatColumn(\"atom_site\", \"B_iso_or_equiv\");\n            this.authSeqId = Column.enterIntColumn(\"atom_site\", \"auth_seq_id\");\n            this.authCompId = Column.enterStrColumn(\"atom_site\", \"auth_comp_id\");\n            this.authAsymId = Column.enterStrColumn(\"atom_site\", \"auth_asym_id\");\n            this.authAtomId = Column.enterStrColumn(\"atom_site\", \"auth_atom_id\");\n            this.pdbxPDBModelNum = Column.enterIntColumn(\"atom_site\", \"pdbx_PDB_model_num\");\n        }\n\n        @Override\n        public void accept(WrappedAtom wrappedAtom) {\n            Atom atom = wrappedAtom.getAtom();\n            Group group = atom.getGroup();\n            Chain chain = group.getChain();\n\n            groupPDB.stringValues(group.getType().equals(GroupType.HETATM) ? \"HETATM\" : \"ATOM\");\n            id.intValues(wrappedAtom.getAtomId());\n            Element element = atom.getElement();\n            typeSymbol.stringValues(element.equals(Element.R) ? \"X\" : element.toString().toUpperCase());\n            labelAtomId.stringValues(atom.getName());\n            Character altLoc = atom.getAltLoc();\n            if (altLoc == null || altLoc == ' ') {\n                labelAltId.markNextNotPresent();\n            } else {\n                labelAltId.stringValues(String.valueOf(altLoc));\n            }\n            labelCompId.stringValues(group.getPDBName());\n            labelAsymId.stringValues(wrappedAtom.getChainId());\n            String entityId = \"0\";\n            int seqId = group.getResidueNumber().getSeqNum();\n            if (chain.getEntityInfo() != null) {\n                entityId = Integer.toString(chain.getEntityInfo().getMolId());\n                if (chain.getEntityInfo().getType() == EntityType.POLYMER) {\n                    // this only makes sense for polymeric chains, non-polymer chains will never have seqres groups and\n                    // there's no point in calling getAlignedResIndex\n                    seqId = chain.getEntityInfo().getAlignedResIndex(group, chain);\n                }\n            }\n            labelEntityId.stringValues(entityId);\n            labelSeqId.intValues(seqId);\n            String insCode = \"\";\n            if (group.getResidueNumber().getInsCode() != null ) {\n                insCode = Character.toString(group.getResidueNumber().getInsCode());\n            }\n            if (insCode.isEmpty()) {\n                pdbxPDBInsCode.markNextUnknown();\n            } else {\n                pdbxPDBInsCode.stringValues(insCode);\n            }\n            cartnX.floatValues(atom.getX());\n            cartnY.floatValues(atom.getY());\n            cartnZ.floatValues(atom.getZ());\n            occupancy.floatValues(atom.getOccupancy());\n            bIsoOrEquiv.floatValues(atom.getTempFactor());\n            authSeqId.intValues(group.getResidueNumber().getSeqNum());\n            authCompId.stringValues(group.getPDBName());\n            authAsymId.stringValues(wrappedAtom.getChainName());\n            authAtomId.stringValues(atom.getName());\n            pdbxPDBModelNum.intValues(wrappedAtom.getModel());\n        }\n\n        AtomSiteCollector combine(AtomSiteCollector other) {\n            throw new UnsupportedOperationException(\"impl by calling addAll for all collection - not feeling like writing that code\");\n        }\n        \n        @SuppressWarnings(\"Duplicates\")\n        AtomSite get() {\n            Map<String, Column> columns = new LinkedHashMap<>();\n            put(columns, groupPDB.build());\n            put(columns, groupPDB.build());\n            put(columns, id.build());\n            put(columns, typeSymbol.build());\n            put(columns, labelAtomId.build());\n            put(columns, labelAltId.build());\n            put(columns, labelCompId.build());\n            put(columns, labelAsymId.build());\n            put(columns, labelEntityId.build());\n            put(columns, labelSeqId.build());\n            put(columns, pdbxPDBInsCode.build());\n            put(columns, cartnX.build());\n            put(columns, cartnY.build());\n            put(columns, cartnZ.build());\n            put(columns, occupancy.build());\n            put(columns, bIsoOrEquiv.build());\n            put(columns, authSeqId.build());\n            put(columns, authCompId.build());\n            put(columns, authAsymId.build());\n            put(columns, authAtomId.build());\n            put(columns, pdbxPDBModelNum.build());\n\n            return (AtomSite) Category.enterCategory(\"atom_site\", columns, null).build();\n        }\n\n        private void put(Map<String, Column> columns, Column column) {\n            columns.put(column.getColumnName(), column);\n        }\n    }\n}\n","originTest":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.junit.Test;\nimport org.rcsb.cif.text.TextCifReader;\nimport org.rcsb.cif.text.TextCifWriter;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.*;\n\npublic class CifFileSupplierImplTest {\n    @Test\n    public void test1SMT() throws IOException, StructureException {\n        // an x-ray structure\n        testRoundTrip(\"1SMT\");\n    }\n\n    /**\n     * MMCIF write test for an NMR structure with 2 chains\n     * @throws IOException propagated\n     */\n    @Test\n    public void test2N3J() throws IOException, StructureException {\n        // an NMR structure (multimodel) with 2 chains\n        testRoundTrip(\"2N3J\");\n    }\n\n    @Test\n    public void test1A2C() throws IOException, StructureException {\n        // a structure with insertion codes\n        testRoundTrip(\"1A2C\");\n    }\n\n    private static void testRoundTrip(String pdbId) throws IOException, StructureException {\n        AtomCache cache = new AtomCache();\n\n        StructureIO.setAtomCache(cache);\n\n        cache.setUseCif(true);\n\n        FileParsingParameters params = new FileParsingParameters();\n        params.setAlignSeqRes(true);\n        cache.setFileParsingParams(params);\n\n        assertTrue(StructureIO.getAtomCache().isUseCif());\n        Structure originalStruct = StructureIO.getStructure(pdbId);\n\n        File outputFile = File.createTempFile(\"biojava_testing_\", \".cif\");\n        outputFile.deleteOnExit();\n\n        FileWriter fw = new FileWriter(outputFile);\n        String cif = new TextCifWriter().compose(CifFileConverter.convert(originalStruct));\n        System.out.println(cif);\n        fw.write(cif);\n        fw.close();\n\n        Structure readStruct = CifFileConverter.convert(new TextCifReader().parse(Files.newInputStream(outputFile.toPath())));\n\n        assertNotNull(readStruct);\n        assertEquals(originalStruct.getChains().size(), readStruct.getChains().size());\n        assertEquals(originalStruct.nrModels(), readStruct.nrModels());\n\n        for (int i = 0; i < originalStruct.nrModels(); i++) {\n            assertEquals(originalStruct.getModel(i).size(), readStruct.getModel(i).size());\n        }\n\n        for (int modelIdx = 0; modelIdx < originalStruct.nrModels(); modelIdx++) {\n            for (int i = 0; i < originalStruct.getModel(modelIdx).size(); i++) {\n                assertEquals(originalStruct.getChains().get(i).getAtomGroups().size(),\n                        readStruct.getChains().get(i).getAtomGroups().size());\n\n                Chain origChain = originalStruct.getModel(modelIdx).get(i);\n                Chain readChain = readStruct.getModel(modelIdx).get(i);\n\n                assertEquals(origChain.getAtomGroups().size(), readChain.getAtomGroups().size());\n                assertEquals(origChain.getId(), readChain.getId());\n                assertEquals(origChain.getName(), readChain.getName());\n\n                Atom[] origAtoms = StructureTools.getAllAtomArray(origChain);\n                Atom[] readAtoms = StructureTools.getAllAtomArray(readChain);\n\n                assertEquals(origAtoms.length, readAtoms.length);\n\n                for (int atomIdx = 0; atomIdx < origAtoms.length; atomIdx++) {\n                    assertEquals(\"atom serials don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getPDBserial(), readAtoms[atomIdx].getPDBserial());\n\n                    assertEquals(\"atom names don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getName(), readAtoms[atomIdx].getName());\n\n                    assertEquals(\"atom elements don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getElement(), readAtoms[atomIdx].getElement());\n\n                    assertEquals(\"x values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getX(), readAtoms[atomIdx].getX(),0.0001);\n\n                    assertEquals(\"y values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getY(), readAtoms[atomIdx].getY(),0.0001);\n\n                    assertEquals(\"z values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getZ(), readAtoms[atomIdx].getZ(),0.0001);\n                }\n            }\n        }\n\n        // Test cell and symmetry\n        assertEquals(originalStruct.getCrystallographicInfo().getSpaceGroup(),\n                readStruct.getCrystallographicInfo().getSpaceGroup());\n    }\n\n    /**\n     * Tests that structures containing symmetry mates with modified chain identifiers\n     * can be written out correctly.\n     */\n    @Test\n    public void testBiounitWriting()  {\n        Structure s = createDummyStructure();\n        String mmcif = new TextCifWriter().compose(CifFileConverter.convert(s));\n        String[] lines = mmcif.split(\"\\n\");\n        long atomLines = Arrays.stream(lines).filter(l -> l.startsWith(\"ATOM\")).count();\n        assertNotNull(mmcif);\n        assertEquals(4, atomLines);\n    }\n\n    private static Structure createDummyStructure() {\n        Group g = new AminoAcidImpl();\n        Atom a = getAtom(\"CA\", Element.C, 1, 1, 1, 1);\n        g.addAtom(a);\n        g.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n        Group altLocG = new AminoAcidImpl();\n        Atom a2 = getAtom(\"CA\", Element.C, 2, 2, 2, 2);\n        altLocG.addAtom(a2);\n        altLocG.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n\n        g.addAltLoc(altLocG);\n\n        Chain c1 = new ChainImpl();\n        c1.addGroup(g);\n        c1.setId(\"A\");\n        EntityInfo entityInfo = new EntityInfo();\n        entityInfo.setMolId(1);\n        entityInfo.addChain(c1);\n        c1.setEntityInfo(entityInfo);\n\n        Group gc2 = new AminoAcidImpl();\n        Atom ac2 = getAtom(\"CA\", Element.C, 3, 3, 3, 3);\n        gc2.addAtom(ac2);\n        gc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        Group altLocGc2 = new AminoAcidImpl();\n        Atom ac22 = getAtom(\"CA\", Element.C, 4, 4, 4, 4);\n        altLocGc2.addAtom(ac22);\n        altLocGc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        gc2.addAltLoc(altLocGc2);\n\n        Chain c2 = new ChainImpl();\n        c2.addGroup(gc2);\n        c2.setId(\"A_1\");\n        c2.setEntityInfo(entityInfo);\n        entityInfo.addChain(c2);\n\n        Structure s = new StructureImpl();\n        s.addChain(c1);\n        s.addChain(c2);\n        return s;\n    }\n\n    private static Atom getAtom(String name, Element e, int id, double x, double y, double z) {\n        Atom a = new AtomImpl();\n        a.setX(x);\n        a.setY(y);\n        a.setZ(z);\n        a.setPDBserial(id);\n        a.setName(name);\n        a.setElement(e);\n        return a;\n    }\n}","changedTest":"","commitMessage":"updates CifFileSupplier to infer types\n","test_commitMessage":"","allZero":false}