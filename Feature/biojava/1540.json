{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/io/FastaAFPChainConverter.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/io/FastaAFPChainConverterTest.java","prod_time":"2013-06-11 05:47:46","test_time":"2013-06-11 05:48:34","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":18,"add_classname_line":0,"add_condition_line":6,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":8,"add_return_line":3,"del_annotation_line":0,"del_call_line":60,"del_classname_line":0,"del_condition_line":14,"del_field_line":1,"del_import_line":6,"del_packageid_line":0,"del_parameter_line":7,"del_return_line":3,"label":"POSITIVE","prod_commitID":"79f7da0935043cc6b1a92a2bd11d70c9c0bb638b","test_commitID":"4eda7698104ded4e5ddcb6030520641916a2a26f","isfound":"found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFP;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.bio.structure.jama.Matrix;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.FastaReaderHelper;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * \n */\npublic class FastaAFPChainConverter {\n\n\tprivate boolean isFastaIncomplete;\n\n\tpublic FastaAFPChainConverter(boolean isFastaIncomplete) {\n\t\tsuper();\n\t\tthis.isFastaIncomplete = isFastaIncomplete;\n\t}\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two arrays of C-alpha {@link Atom Atoms} to create an AFPChain.\n\t */\n\tpublic AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2) throws Exception {\n\t\tLinkedHashMap<String, ProteinSequence> sequences = FastaReaderHelper.readFastaProteinSequence(fastaFile);\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\tpublic AFPChain fastaStringToAfpChain(String fastaString, Structure structure1, Structure structure2) throws Exception {\n\t\tInputStream is = null;\n\t\tLinkedHashMap<String, ProteinSequence> sequences;\n\t\ttry {\n\t\t\tis = new ByteArrayInputStream(fastaString.getBytes()); // default encoding\n\t\t\tsequences = FastaReaderHelper.readFastaProteinSequence(is);\n\t\t} finally {\n\t\t\tif (is != null) {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t}\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\tpublic AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1, Structure structure2)\n\t\t\tthrows StructureException {\n\n\t\tif (sequence1 == null || sequence2 == null || structure1 == null || structure2 == null) return null;\n\n\t\tString seqString1 = sequence1.getSequenceAsString();\n\t\tString seqString2 = sequence2.getSequenceAsString();\n\n\t\tif (isFastaIncomplete) {\n\t\t\tstructure1 = StructureSequenceMatcher.getSubstructureMatchingProteinSequence(sequence1, structure1);\n\t\t\tstructure2 = StructureSequenceMatcher.getSubstructureMatchingProteinSequence(sequence2, structure2);\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tString ungapped1 = StructureSequenceMatcher.removeGaps(sequence1).getSequenceAsString();\n\t\tString ungapped2 = StructureSequenceMatcher.removeGaps(sequence2).getSequenceAsString();\n\n\t\tif (seqString1.length() != seqString2.length()) {\n\t\t\tthrow new IllegalArgumentException(\"Sequence lengths differ: \" + seqString1.length() + \" is not equal to \" + seqString2.length());\n\t\t}\n\t\tif (ungapped1.length() != ca1.length) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"ca1 has \" + ca1.length + \" atoms but the sequence has \" + ungapped1.length() + \" residues\");\n\t\t}\n\t\tif (ungapped2.length() != ca2.length) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"ca2 has \" + ca2.length + \" atoms but the sequence has \" + ungapped2.length() + \" residues\");\n\t\t}\n\n\t\tAFPChain afpChain = new AFPChain();\n\t\tafpChain.setCa1Length(ca1.length);\n\t\tafpChain.setCa2Length(ca2.length);\n\n\t\tList<Atom> participating1 = new ArrayList<Atom>();\n\t\tList<Atom> participating2 = new ArrayList<Atom>();\n\t\t\n\t\t/*\n\t\t * Example:\n\t\t * ACC---CGGC--TTCGCAA\n\t\t * ACC---CGGCCCTTC--AA\n\t\t * Gap length = 3 + 2 + 2.\n\t\t * Notice that the first gap must be counted only once.\n\t\t * That is, if pos1 moves, pos2 moves, or both move, we increment gapLength by 1.\n\t\t * Whenever we move neither pos1 nor pos2, we increment alignedLength by 1.\n\t\t */\n\t\tint pos1 = 0; // the number of gaps in the first sequence\n\t\tint pos2 = 0; // the number of gaps in the second sequence\n\t\tint alignedLength = 0;\n\t\tint gapLength = 0;\n\t\tfor (int i = 0; i < seqString1.length(); i++) {\n\t\t\tchar aa1 = seqString1.charAt(i);\n\t\t\tchar aa2 = seqString2.charAt(i);\n\t\t\tboolean movedForward = false;\n\t\t\tif (aa1 == '-') {\n\t\t\t\tpos1++;\n\t\t\t\tmovedForward = true;\n\t\t\t}\n\t\t\tif (aa2 == '-') {\n\t\t\t\tpos2++;\n\t\t\t\tmovedForward = true;\n\t\t\t}\n\t\t\tif (movedForward) {\n\t\t\t\tgapLength++;\n\t\t\t} else {\n\t\t\t\tparticipating1.add(ca1[pos1]);\n\t\t\t\tparticipating2.add(ca2[pos2]);\n\t\t\t\talignedLength++;\n\t\t\t\tAFP afp = new AFP();\n\t\t\t\tafp.setP1(pos1);\n\t\t\t\tafp.setP2(pos2);\n\t\t\t\tafp.setFragLen(1); // every fragment contains just one residue (a little weird, but ok)\n\t\t\t\tafp.setId(i);\n\t\t\t\tafpChain.getAfpSet().add(afp);\n\t\t\t}\n\t\t}\n\n\t\tAtom[] participating1Array = new Atom[participating1.size()];\n\t\tfor (int i = 0; i < participating1.size(); i++) {\n\t\t\tparticipating1Array[i] = participating1.get(i);\n\t\t}\n\t\tAtom[] participating2Array = new Atom[participating2.size()];\n\t\tfor (int i = 0; i < participating2.size(); i++) {\n\t\t\tparticipating2Array[i] = participating2.get(i);\n\t\t}\n\n\t\t// the best possible alignment we can get matches the two sequences together without gaps\n\t\tafpChain.setOptLength(Math.min(ca1.length, ca2.length));\n\t\tint[] optLen = new int[] { afpChain.getOptLength() };\n\t\tafpChain.setOptLen(optLen);\n\n\t\tafpChain.setAlnLength(alignedLength);\n\t\tafpChain.setGapLen(gapLength);\n\n\t\tif (participating1Array.length != participating2Array.length) {\n\t\t\tSystem.err.println(\n\t\t\t\t\t\"ca1 has \" + participating1Array.length + \" atoms but ca2 has \" + participating2Array.length + \" atoms\");\n\t\t} else {\n\n\t\t\t// Perform singular value decomposition to find translation and rotation\n\t\t\t// This allows us to superimpose the aligned structures\n\t\t\t// This is only important for visualization of an alignment\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(participating1Array, participating2Array);\n\t\t\tMatrix matrix = svd.getRotation();\n\t\t\tAtom shift = svd.getTranslation();\n\n\t\t\t// apply the rotation and translation to the second structure ONLY\n\t\t\t// From now on, ca2 is rotated\n//\t\t\tAtom[] ca2Clone = StructureTools.cloneCAArray(ca2); // do this so we don't modify the method argument as a side effect\n\t\t\tfor (Atom atom : participating2Array) {\n\t\t\t\tCalc.rotate(atom, matrix);\n\t\t\t\tCalc.shift(atom, shift);\n\t\t\t}\n\n\t\t\tafpChain.setBlockNum(1);\n\t\t\t// TODO set identity, similarity, etc.\n\t\t\t\n\t\t\t// calculate RMSD and TM-score\n\t\t\tdouble rmsd = SVDSuperimposer.getRMS(participating1Array, participating2Array);\n\t\t\tdouble tmScore = SVDSuperimposer.getTMScore(participating1Array, participating2Array, ca1.length, ca2.length);\n\n\t\t\tfor (AFP afp : afpChain.getAfpSet()) {\n\t\t\t\tafp.setFragLen(1);\n\t\t\t\tafp.setM(matrix);\n\t\t\t\tafp.setRmsd(rmsd);\n\t\t\t\tafp.setScore(tmScore);\n\t\t\t}\n\n\t\t}\n\n\t\treturn afpChain;\n\t}\n\n\tpublic AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1.getName() == null || structure2.getName() == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure name is null\");\n\t\t}\n\t\tif (structure1.getName().equals(structure2.getName())) {\n\t\t\tthrow new IllegalArgumentException(\"\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\tpublic AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Prints out an AFPChain from a file of two FASTA sequences\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tAtomCache cache = new AtomCache();\n\t\tStructure structure1 = cache.getStructure(args[1]);\n\t\tStructure structure2 = cache.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","changedPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AlignmentTools;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.FastaReaderHelper;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows Exception {\n\t\tLinkedHashMap<String, ProteinSequence> sequences = FastaReaderHelper.readFastaProteinSequence(fastaFile);\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws Exception {\n\t\treturn fastaToAfpChain(new ProteinSequence(sequence1), new ProteinSequence(sequence2), structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1.getName() == null || structure2.getName() == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure name is null\");\n\t\t}\n\t\tif (structure1.getName().equals(structure2.getName())) {\n\t\t\tthrow new IllegalArgumentException(\"\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequence1 == null || sequence2 == null || structure1 == null || structure2 == null)\n\t\t\treturn null;\n\n\t\tResidueNumber[] rn1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] rn2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\tList<ResidueNumber> participating1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> participating2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < rn1.length; i++) {\n\t\t\tif (rn1[i] != null && rn2[i] != null) {\n\t\t\t\tparticipating1.add(rn1[i]);\n\t\t\t\tparticipating2.add(rn2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] participating1Array = new ResidueNumber[participating1.size()];\n\t\tfor (int i = 0; i < participating1.size(); i++) {\n\t\t\tparticipating1Array[i] = participating1.get(i);\n\t\t}\n\t\tResidueNumber[] participating2Array = new ResidueNumber[participating2.size()];\n\t\tfor (int i = 0; i < participating2.size(); i++) {\n\t\t\tparticipating2Array[i] = participating2.get(i);\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, participating1Array, participating2Array);\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tAtomCache cache = new AtomCache();\n\t\tStructure structure1 = cache.getStructure(args[1]);\n\t\tStructure structure2 = cache.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.IOException;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\n/**\n * A test for {@link FastaAFPChainConverter}.\n * @author dmyersturnbull\n *\n */\npublic class FastaAFPChainConverterTest {\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() {\n\t\tcache = new AtomCache();\n\t}\n\t\n//\t@Test\n\tpublic void testIncomplete() throws IOException, StructureException {\n\t\tStructure s1 = cache.getStructure(\"1w0p\");\n\t\tStructure s2 = cache.getStructure(\"1qdm\");\n\t\tProteinSequence seq1 = new ProteinSequence(\"GWGG----SEL--YRRNTSLNS--QQDW-------QSNAKIRIVDGAA-----NQIQ\");\n\t\tProteinSequence seq2 = new ProteinSequence(\"WMQNQLAQNKT--QDLILDYVNQLCNRL---PSPMESAV----DCGSLGSMPDIEFT\");\n\t\tFastaAFPChainConverter conv = new FastaAFPChainConverter(true);\n\t\tAFPChain afpChain = conv.fastaToAfpChain(seq1, seq2, s1, s2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","changedTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.custommonkey.xmlunit.DetailedDiff;\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.Difference;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.custommonkey.xmlunit.examples.RecursiveElementNameAndTextQualifier;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A test for {@link FastaAFPChainConverter}.\n * @author dmyersturnbull\n *\n */\npublic class FastaAFPChainConverterTest {\n\n\tstatic {\n\t\tXMLUnit.setIgnoreWhitespace(true);\n\t\tXMLUnit.setIgnoreComments(true);\n\t\tXMLUnit.setIgnoreAttributeOrder(true);\n\t}\n\n\tpublic static void printDetailedDiff(Diff diff, PrintStream ps) {\n\t\tDetailedDiff detDiff = new DetailedDiff(diff);\n\t\tfor (Object object : detDiff.getAllDifferences()) {\n\t\t\tDifference difference = (Difference) object;\n\t\t\tps.println(difference);\n\t\t}\n\t}\n\n\t/**\n\t * Compares two XML files without regard to the order of elements or attributes, and ignoring any element named \\\"releaseDate\\\".\n\t * @return Whether the files are \\\"similar\\\"\n\t */\n\tpublic static boolean compareXml(File expectedFile, File actualFile) {\n\t\ttry {\n\t\t\tFileReader expectedFr = new FileReader(expectedFile);\n\t\t\tFileReader actualFr = new FileReader(actualFile);\n\t\t\tDiff diff = new Diff(expectedFr, actualFr);\n\t\t\t// ignore order\n\t\t\t// look at element, id, and weight (weight is a nested element)\n\t\t\tdiff.overrideElementQualifier(new RecursiveElementNameAndTextQualifier());\n\t\t\tfinal boolean isSimilar = diff.similar();\n\t\t\tif (!isSimilar) printDetailedDiff(diff, System.err);\n\t\t\texpectedFr.close();\n\t\t\tactualFr.close();\n\t\t\treturn isSimilar;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() {\n\t\tcache = new AtomCache();\n\t}\n\t\n\t@Test\n\tpublic void testIncomplete() throws IOException, StructureException {\n\t\tStructure s1 = cache.getStructure(\"1w0p\");\n\t\tStructure s2 = cache.getStructure(\"1qdm\");\n\t\tProteinSequence seq1 = new ProteinSequence(\"GWGG----SEL--YRRNTSLNS--QQDW-------QSNAKIRIVDGAA-----NQIQ\");\n\t\tProteinSequence seq2 = new ProteinSequence(\"WMQNQLAQNKT--QDLILDYVNQLCNRL---PSPMESAV----DCGSLGSMPDIEFT\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.fastaToAfpChain(seq1, seq2, s1, s2);\n\t\tassertEquals(\"Wrong number of EQRs\", 33, afpChain.getNrEQR());\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tFile expected = new File(\"src/test/resources/1w0p_1qdm.xml\");\n\t\tFile x = File.createTempFile(\"1w0p_1qdm_output\", \"xml.tmp\");\n\t\tx.deleteOnExit();\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(x));\n\t\tbw.write(xml);\n\t\tbw.close();\n\t\tassertTrue(\"AFPChain is wrong\", compareXml(expected, x));\n\t}\n\n}\n","commitMessage":"Simplified FastaAFPChainConverter substantially, and fixed it.","test_commitMessage":"Finished test for FastaAFPChainConverter.","allZero":false}