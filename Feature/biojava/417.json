{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/search/io/blast/BlastTabularParser.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/search/io/blast/BlastTabularParserTest.java","prod_time":"2015-09-24 23:54:15","test_time":"2015-09-24 23:54:15","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":0,"label":"POSITIVE","prod_commitID":"911ba726009c5e234b3084ce8ccc1a2c254ca7a5","test_commitID":"911ba726009c5e234b3084ce8ccc1a2c254ca7a5","isfound":"found test change","originPro":"package org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.LineNumberReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.logging.Logger;\nimport org.biojava.nbio.core.exceptions.ParserException;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info \n * or discuss major changes.\n * https://github.com/paolopavan\n * \n * @author Paolo Pavan\n */\n\npublic class BlastTabularParser implements ResultFactory {\n    private final String blastReference = \n            \"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\";\n    /**\n     * Tries to define a different level of consistency during parsing\n     * LITERAL is intended a strict parsing much tight to the report.\n     * IMPROVED consistency tries to import data much tight to the data model\n     * (I hope you got the idea, if not have a look to the code.\n     * I'm not very sure I will leave to the user the possibility to choose)\n     */\n    private enum PARSING_CONSISTENCY {\n        IMPROVED,\n        LITERAL\n    }\n    private static final Logger log = Logger.getLogger(BlastTabularParser.class.getName());\n    \n    private File targetFile;\n    private int fileLinesCount;\n    private PARSING_CONSISTENCY parsingConsistency = PARSING_CONSISTENCY.IMPROVED;\n    \n    \n    // data imported private:\n    int queryIdNumber = 0;\n    HashMap<String,String> queryIdMapping = new HashMap();\n    String programName=null, queryName = null, databaseFile = null;\n    private String queryId      ;\n    private String subjectId    ;\n    private String percIdentity ;\n    private String alnLength    ;\n    private String mismatchCount;\n    private String gapOpenCount ;\n    private String queryStart   ;\n    private String queryEnd     ;\n    private String subjectStart ;\n    private String subjectEnd   ;\n    private String evalue       ;\n    private String bitScore     ;\n    \n\n    @Override\n    public List<String> getFileExtensions() {\n        List l = new ArrayList();\n        l.add(\"blasttabular\");\n        l.add(\"blasttxt\");\n        return l;\n    }\n\n    @Override\n    public void setFile(File f) {\n        targetFile = f;\n    }\n\n    @Override\n    public List<Result> createObjects(double maxEScore) throws Exception {\n        List<Result> results = new ArrayList();\n        \n        log.info(\"Query for hits\");\n        LineNumberReader  lnr = new LineNumberReader(new FileReader(targetFile));\n        lnr.skip(Long.MAX_VALUE);\n        fileLinesCount = lnr.getLineNumber();\n        log.info(fileLinesCount + \" hits approximately in all results\");\n        lnr.close();\n        \n        FileInputStream fileInputStream = new FileInputStream(targetFile);\n        Scanner scanner = new Scanner(fileInputStream);\n        \n        String line = fetchData(scanner);\n        while (scanner.hasNext()){\n            try {\n                BlastResultBuilder resultBuilder = new BlastResultBuilder();\n                resultBuilder\n                        .setQueryID(queryId)\n                        .setDbFile(databaseFile)\n                        .setProgram(programName)\n                        .setQueryDef(queryName)\n                        .setReference(blastReference);\n                \n                List<Hit> hits = new ArrayList();\n                \n                String currentQueryId = queryId;\n                while (currentQueryId.equals(queryId) && scanner.hasNext()){\n                    BlastHitBuilder hitBuilder = new BlastHitBuilder();\n                    \n                    List<Hsp> hsps = new ArrayList();\n                    \n                    String currentSubjectId=subjectId;\n                    while (currentSubjectId.equals(subjectId) && scanner.hasNext()){\n                        if (new Double(evalue) > maxEScore) {\n                            line = fetchData(scanner);\n                            continue;\n                        }\n                        BlastHspBuilder hspBuilder = new BlastHspBuilder();\n                        hspBuilder\n                            .setHspAlignLen(new Integer(alnLength))\n                            .setHspGaps(new Integer(gapOpenCount))\n                            .setHspQueryFrom(new Integer(queryStart))\n                            .setHspQueryTo(new Integer(queryEnd))\n                            .setHspHitFrom(new Integer(subjectStart))\n                            .setHspHitTo(new Integer(subjectEnd))\n                            .setHspEvalue(new Double(evalue))\n                            .setHspBitScore(new Double(bitScore))\n                            .setPercentageIdentity(new Double(percIdentity)/100)\n                            .setMismatchCount(new Integer(mismatchCount));\n                        hsps.add(hspBuilder.createBlastHsp());\n                        line = fetchData(scanner);\n                    }\n                    hits.add(hitBuilder.setHsps(hsps).createBlastHit());\n                }\n                results.add(resultBuilder.setHits(hits).createBlastResult());\n            } catch (NumberFormatException e) {\n                throw new ParserException(\"Invalid numeric value met in:\\n\"+line);\n            }\n        }\n        return results;\n    }\n    \n    private String fetchData(Scanner scanner){\n        String line;\n        String[] split;\n        \n        line = scanner.nextLine();    \n        while (line.startsWith(\"#\")){\n            // blast tabular with header options contains some more informations\n            if (line.matches(\"#\\\\s.?BLAST.+\")) programName = line.replace(\"#\\\\s\",\"\");\n            if (line.startsWith(\"# Query:\")) queryName = line.replace(\"# Query: \",\"\");\n            if (line.startsWith(\"# Database:\")) databaseFile = line.replace(\"# Database: \",\"\");\n            \n            // needed because blast report can end with a comment...\n            if (!scanner.hasNext()) return null;\n            line = scanner.nextLine(); \n        }\n        \n        // Here, programName != null checks if there was a header in the file\n        boolean headerFound = programName != null;\n        \n        split = line.split(\"\\\\t\");\n        queryId      =split[0];\n        subjectId    =split[1];\n        percIdentity =split[2];\n        alnLength    =split[3];\n        mismatchCount=split[4];\n        gapOpenCount =split[5];\n        queryStart   =split[6];\n        queryEnd     =split[7];\n        subjectStart =split[8];\n        subjectEnd   =split[9];\n        evalue       =split[10];\n        bitScore     =split[11];\n        \n        // blast tabular reports only the first word of the query name. \n        // If it was specified in the header it is better to use that definition\n        if (parsingConsistency == PARSING_CONSISTENCY.IMPROVED && headerFound) {\n            if (queryIdMapping.get(queryId)==null) {\n                queryIdNumber ++;\n                queryIdMapping.put(queryId,\"Query_\" + queryIdNumber);\n            }\n            // If a complete definition of the query name was readed, than we can use\n            // a queryID schema that is consistent with blast xml report\n            queryId = queryIdMapping.get(queryId);\n        }\n        if (!headerFound) queryName = queryId;\n        \n        return line;\n    }\n\n    @Override\n    public void storeObjects(List<Result> results) throws Exception {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n    /**\n     * Intended for use with run module. \n     * Although possible does not make a lot of sense to have it with limited \n     * information in report\n     * @param sequences \n     */\n    @Override\n    public void setQueryReferences(List sequences) {\n        throw new UnsupportedOperationException(\"Not supported for this parser.\");\n    }\n    /**\n     * Intended for use with run module. \n     * Although possible does not make a lot of sense to have it with limited \n     * information in report\n     * @param sequences \n     */\n    @Override\n    public void setDatabaseReferences(List sequences) {\n        throw new UnsupportedOperationException(\"Not supported for this parser.\");\n    }\n\n}\n","changedPro":"package org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.LineNumberReader;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.logging.Logger;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info \n * or discuss major changes.\n * https://github.com/paolopavan\n * \n * @author Paolo Pavan\n */\n\npublic class BlastTabularParser implements ResultFactory {\n    private final String blastReference = \n            \"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\";\n    /**\n     * Tries to define a different level of consistency during parsing\n     * LITERAL is intended a strict parsing much tight to the report.\n     * IMPROVED consistency tries to import data much tight to the data model\n     * (I hope you got the idea, if not have a look to the code.\n     * I'm not very sure I will leave to the user the possibility to choose)\n     */\n    private enum PARSING_CONSISTENCY {\n        IMPROVED,\n        LITERAL\n    }\n    private static final Logger log = Logger.getLogger(BlastTabularParser.class.getName());\n    \n    private File targetFile;\n    private int fileLinesCount;\n    private PARSING_CONSISTENCY parsingConsistency = PARSING_CONSISTENCY.IMPROVED;\n    \n    \n    // data imported private:\n    int queryIdNumber = 0;\n    HashMap<String,String> queryIdMapping = new HashMap();\n    String programName=null, queryName = null, databaseFile = null;\n    private String queryId      ;\n    private String subjectId    ;\n    private String percIdentity ;\n    private String alnLength    ;\n    private String mismatchCount;\n    private String gapOpenCount ;\n    private String queryStart   ;\n    private String queryEnd     ;\n    private String subjectStart ;\n    private String subjectEnd   ;\n    private String evalue       ;\n    private String bitScore     ;\n    \n\n    @Override\n    public List<String> getFileExtensions() {\n        List l = new ArrayList();\n        l.add(\"blasttabular\");\n        l.add(\"blasttxt\");\n        return l;\n    }\n\n    @Override\n    public void setFile(File f) {\n        targetFile = f;\n    }\n\n    @Override\n    public List<Result> createObjects(double maxEScore) throws IOException, ParseException {\n        List<Result> results = new ArrayList();\n        \n        log.info(\"Query for hits\");\n        LineNumberReader  lnr = new LineNumberReader(new FileReader(targetFile));\n        lnr.skip(Long.MAX_VALUE);\n        fileLinesCount = lnr.getLineNumber();\n        log.info(fileLinesCount + \" hits approximately in all results\");\n        lnr.close();\n        \n        FileInputStream fileInputStream = new FileInputStream(targetFile);\n        Scanner scanner = new Scanner(fileInputStream);\n        \n        String line = fetchData(scanner);\n        int lineNumber=1;\n        while (scanner.hasNext()){\n            try {\n                BlastResultBuilder resultBuilder = new BlastResultBuilder();\n                resultBuilder\n                        .setQueryID(queryId)\n                        .setDbFile(databaseFile)\n                        .setProgram(programName)\n                        .setQueryDef(queryName)\n                        .setReference(blastReference);\n                \n                List<Hit> hits = new ArrayList();\n                \n                String currentQueryId = queryId;\n                while (currentQueryId.equals(queryId) && scanner.hasNext()){\n                    BlastHitBuilder hitBuilder = new BlastHitBuilder();\n                    \n                    List<Hsp> hsps = new ArrayList();\n                    \n                    String currentSubjectId=subjectId;\n                    while (currentSubjectId.equals(subjectId) && scanner.hasNext()){\n                        if (new Double(evalue) > maxEScore) {\n                            line = fetchData(scanner);\n                            lineNumber++;\n                            continue;\n                        }\n                        BlastHspBuilder hspBuilder = new BlastHspBuilder();\n                        hspBuilder\n                            .setHspAlignLen(new Integer(alnLength))\n                            .setHspGaps(new Integer(gapOpenCount))\n                            .setHspQueryFrom(new Integer(queryStart))\n                            .setHspQueryTo(new Integer(queryEnd))\n                            .setHspHitFrom(new Integer(subjectStart))\n                            .setHspHitTo(new Integer(subjectEnd))\n                            .setHspEvalue(new Double(evalue))\n                            .setHspBitScore(new Double(bitScore))\n                            .setPercentageIdentity(new Double(percIdentity)/100)\n                            .setMismatchCount(new Integer(mismatchCount));\n                        hsps.add(hspBuilder.createBlastHsp());\n                        line = fetchData(scanner);\n                        lineNumber++;\n                    }\n                    hits.add(hitBuilder.setHsps(hsps).createBlastHit());\n                }\n                results.add(resultBuilder.setHits(hits).createBlastResult());\n            } catch (NumberFormatException e) {\n                throw new ParseException(\"Invalid numeric value met at line \"+ lineNumber+\" in:\\n\"+line,0);\n            }\n        }\n        return results;\n    }\n    \n    private String fetchData(Scanner scanner){\n        String line;\n        String[] split;\n        \n        line = scanner.nextLine();    \n        while (line.startsWith(\"#\")){\n            // blast tabular with header options contains some more informations\n            if (line.matches(\"#\\\\s.?BLAST.+\")) programName = line.replace(\"#\\\\s\",\"\");\n            if (line.startsWith(\"# Query:\")) queryName = line.replace(\"# Query: \",\"\");\n            if (line.startsWith(\"# Database:\")) databaseFile = line.replace(\"# Database: \",\"\");\n            \n            // needed because blast report can end with a comment...\n            if (!scanner.hasNext()) return null;\n            line = scanner.nextLine(); \n        }\n        \n        // Here, programName != null checks if there was a header in the file\n        boolean headerFound = programName != null;\n        \n        split = line.split(\"\\\\t\");\n        queryId      =split[0];\n        subjectId    =split[1];\n        percIdentity =split[2];\n        alnLength    =split[3];\n        mismatchCount=split[4];\n        gapOpenCount =split[5];\n        queryStart   =split[6];\n        queryEnd     =split[7];\n        subjectStart =split[8];\n        subjectEnd   =split[9];\n        evalue       =split[10];\n        bitScore     =split[11];\n        \n        // blast tabular reports only the first word of the query name. \n        // If it was specified in the header it is better to use that definition\n        if (parsingConsistency == PARSING_CONSISTENCY.IMPROVED && headerFound) {\n            if (queryIdMapping.get(queryId)==null) {\n                queryIdNumber ++;\n                queryIdMapping.put(queryId,\"Query_\" + queryIdNumber);\n            }\n            // If a complete definition of the query name was readed, than we can use\n            // a queryID schema that is consistent with blast xml report\n            queryId = queryIdMapping.get(queryId);\n        }\n        if (!headerFound) queryName = queryId;\n        \n        return line;\n    }\n\n    @Override\n    public void storeObjects(List<Result> results) throws IOException, ParseException {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n    \n    /**\n     * Intended for use with run module. \n     * Although possible does not make a lot of sense to have it with limited \n     * information in report\n     * @param sequences \n     */\n    @Override\n    public void setQueryReferences(List sequences) {\n        throw new UnsupportedOperationException(\"Not supported for this parser.\");\n    }\n    /**\n     * Intended for use with run module. \n     * Although possible does not make a lot of sense to have it with limited \n     * information in report\n     * @param sequences \n     */\n    @Override\n    public void setDatabaseReferences(List sequences) {\n        throw new UnsupportedOperationException(\"Not supported for this parser.\");\n    }\n\n}\n","originTest":"/*\r\n * To change this license header, choose License Headers in Project Properties.\r\n * To change this template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage org.biojava.nbio.core.search.io.blast;\r\n\r\nimport java.io.File;\r\nimport java.net.URL;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport org.biojava.nbio.core.search.io.Hit;\r\nimport org.biojava.nbio.core.search.io.Hsp;\r\nimport org.biojava.nbio.core.search.io.Result;\r\nimport org.junit.After;\r\nimport org.junit.AfterClass;\r\nimport org.junit.Before;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\nimport static org.junit.Assert.*;\r\n\r\n/**\r\n *\r\n * @author pavanpa\r\n */\r\npublic class BlastTabularParserTest {\r\n    \r\n    public BlastTabularParserTest() {\r\n    }\r\n    \r\n    @BeforeClass\r\n    public static void setUpClass() {\r\n    }\r\n    \r\n    @AfterClass\r\n    public static void tearDownClass() {\r\n    }\r\n    \r\n    @Before\r\n    public void setUp() {\r\n    }\r\n    \r\n    @After\r\n    public void tearDown() {\r\n    }\r\n\r\n    /**\r\n     * Test of getFileExtensions method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testGetFileExtensions() {\r\n        System.out.println(\"getFileExtensions\");\r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        \r\n        List<String> expResult = new ArrayList();\r\n        expResult.add(\"blasttabular\");\r\n        expResult.add(\"blasttxt\");\r\n        \r\n        List<String> result = instance.getFileExtensions();\r\n        assertEquals(expResult, result);\r\n    }\r\n\r\n    /**\r\n     * Test of setFile method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testSetFile() {\r\n        System.out.println(\"setFile\");\r\n        File f = null;\r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        instance.setFile(f);\r\n    }\r\n\r\n    /**\r\n     * Test of createObjects method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testCreateObjects() throws Exception {\r\n        System.out.println(\"createObjects\");\r\n        Result expRes1;\r\n        Hit expHit1res1;\r\n        Hsp expHsp1hit1res1;\r\n        \r\n        String resource = \"/org/biojava/nbio/core/search/io/blast/test.two-query.blasttxt\";\r\n        URL resourceURL = getClass().getResource(resource);\r\n        File file = new File(resourceURL.getFile());\r\n        \r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        instance.setFile(file);\r\n        \r\n        List<Result> results = instance.createObjects(1e-10);\r\n        \r\n        BlastHsp hsp1Hit1Res1 = new BlastHspBuilder()\r\n                .setHspNum(1)\r\n                .setPercentageIdentity(97.40/100)\r\n                .setHspAlignLen(77)\r\n                .setMismatchCount(2)\r\n                .setHspGaps(0)\r\n                .setHspQueryFrom(774)\r\n                .setHspQueryTo(850)\r\n                .setHspHitFrom(45396566)\r\n                .setHspQueryTo(45396336)\r\n                .setHspEvalue(1e-46)\r\n                .setHspBitScore(157)\r\n                .createBlastHsp();\r\n        \r\n        BlastHit hit1Res1 = new BlastHitBuilder()\r\n                .setHitDef(\"chr15\")\r\n                .createBlastHit();\r\n        \r\n        BlastResult res1 = new BlastResultBuilder()\r\n                .setQueryID(\"Query_1\")\r\n                .setQueryDef(\"Dual oxidase (DUOX1_RAT)\")\r\n                .createBlastResult();\r\n        \r\n        expRes1 = results.get(0);\r\n        expHit1res1 = expRes1.iterator().next();\r\n        expHsp1hit1res1 = expHit1res1.iterator().next();\r\n        \r\n        // results test\r\n        assertEquals(expRes1, res1);\r\n        // hit test\r\n        assertEquals(expHit1res1, hit1Res1);\r\n        // hsp test\r\n        assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\r\n        \r\n        \r\n        String resource2 = \"/org/biojava/nbio/core/search/io/blast/testBlastTabularReport.txt\";\r\n        URL resourceURL2 = getClass().getResource(resource2);\r\n        File file2 = new File(resourceURL2.getFile());\r\n        \r\n        BlastTabularParser instance2 = new BlastTabularParser();\r\n        instance2.setFile(file2);\r\n        \r\n        List<Result> results2 = instance2.createObjects(1e-10);\r\n        expRes1 = results2.get(0);\r\n        expHit1res1 = expRes1.iterator().next();\r\n        expHsp1hit1res1 = expHit1res1.iterator().next();\r\n        \r\n        hsp1Hit1Res1 = new BlastHspBuilder()\r\n                .setPercentageIdentity(100.00/100)\r\n                .setHspAlignLen(48)\r\n                .setMismatchCount(0)\r\n                .setHspGaps(0)\r\n                .setHspQueryFrom(1)\r\n                .setHspQueryTo(48)\r\n                .setHspHitFrom(344)\r\n                .setHspHitTo(391)\r\n                .setHspEvalue(4e-19)\r\n                .setHspBitScore(95.6)\r\n                .createBlastHsp();\r\n        \r\n        hit1Res1 = new BlastHitBuilder()\r\n                .setHitDef(\"KF031625.1.1775\")\r\n                .createBlastHit();\r\n        \r\n        res1 = new BlastResultBuilder()\r\n                .setQueryID(\"1_759_906_F3\")\r\n                .setQueryDef(\"1_759_906_F3\")\r\n                .createBlastResult();\r\n        \r\n        // results test\r\n        assertEquals(expRes1, res1);\r\n        // hit test\r\n        assertEquals(expHit1res1, hit1Res1);\r\n        // hsp test\r\n        assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\r\n    }\r\n\r\n    \r\n    \r\n}\r\n","changedTest":"package org.biojava.nbio.core.search.io.blast;\r\n\r\nimport java.io.File;\r\nimport java.net.URL;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport org.biojava.nbio.core.search.io.Hit;\r\nimport org.biojava.nbio.core.search.io.Hsp;\r\nimport org.biojava.nbio.core.search.io.Result;\r\nimport org.junit.After;\r\nimport org.junit.AfterClass;\r\nimport org.junit.Before;\r\nimport org.junit.BeforeClass;\r\nimport org.junit.Test;\r\nimport static org.junit.Assert.*;\r\n\r\n/**\r\n *\r\n * @author Paolo Pavan\r\n */\r\npublic class BlastTabularParserTest {\r\n    \r\n    public BlastTabularParserTest() {\r\n    }\r\n    \r\n    @BeforeClass\r\n    public static void setUpClass() {\r\n    }\r\n    \r\n    @AfterClass\r\n    public static void tearDownClass() {\r\n    }\r\n    \r\n    @Before\r\n    public void setUp() {\r\n    }\r\n    \r\n    @After\r\n    public void tearDown() {\r\n    }\r\n\r\n    /**\r\n     * Test of getFileExtensions method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testGetFileExtensions() {\r\n        System.out.println(\"getFileExtensions\");\r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        \r\n        List<String> expResult = new ArrayList();\r\n        expResult.add(\"blasttabular\");\r\n        expResult.add(\"blasttxt\");\r\n        \r\n        List<String> result = instance.getFileExtensions();\r\n        assertEquals(expResult, result);\r\n    }\r\n\r\n    /**\r\n     * Test of setFile method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testSetFile() {\r\n        System.out.println(\"setFile\");\r\n        File f = null;\r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        instance.setFile(f);\r\n    }\r\n\r\n    /**\r\n     * Test of createObjects method, of class BlastTabularParser.\r\n     */\r\n    @Test\r\n    public void testCreateObjects() throws Exception {\r\n        System.out.println(\"createObjects\");\r\n        Result expRes1;\r\n        Hit expHit1res1;\r\n        Hsp expHsp1hit1res1;\r\n        \r\n        String resource = \"/org/biojava/nbio/core/search/io/blast/test.two-query.blasttxt\";\r\n        URL resourceURL = getClass().getResource(resource);\r\n        File file = new File(resourceURL.getFile());\r\n        \r\n        BlastTabularParser instance = new BlastTabularParser();\r\n        instance.setFile(file);\r\n        \r\n        List<Result> results = instance.createObjects(1e-10);\r\n        \r\n        BlastHsp hsp1Hit1Res1 = new BlastHspBuilder()\r\n                .setHspNum(1)\r\n                .setPercentageIdentity(97.40/100)\r\n                .setHspAlignLen(77)\r\n                .setMismatchCount(2)\r\n                .setHspGaps(0)\r\n                .setHspQueryFrom(774)\r\n                .setHspQueryTo(850)\r\n                .setHspHitFrom(45396566)\r\n                .setHspQueryTo(45396336)\r\n                .setHspEvalue(1e-46)\r\n                .setHspBitScore(157)\r\n                .createBlastHsp();\r\n        \r\n        BlastHit hit1Res1 = new BlastHitBuilder()\r\n                .setHitDef(\"chr15\")\r\n                .createBlastHit();\r\n        \r\n        BlastResult res1 = new BlastResultBuilder()\r\n                .setQueryID(\"Query_1\")\r\n                .setQueryDef(\"Dual oxidase (DUOX1_RAT)\")\r\n                .createBlastResult();\r\n        \r\n        expRes1 = results.get(0);\r\n        expHit1res1 = expRes1.iterator().next();\r\n        expHsp1hit1res1 = expHit1res1.iterator().next();\r\n        \r\n        // results test\r\n        assertEquals(expRes1, res1);\r\n        // hit test\r\n        assertEquals(expHit1res1, hit1Res1);\r\n        // hsp test\r\n        assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\r\n        \r\n        \r\n        String resource2 = \"/org/biojava/nbio/core/search/io/blast/testBlastTabularReport.txt\";\r\n        URL resourceURL2 = getClass().getResource(resource2);\r\n        File file2 = new File(resourceURL2.getFile());\r\n        \r\n        BlastTabularParser instance2 = new BlastTabularParser();\r\n        instance2.setFile(file2);\r\n        \r\n        List<Result> results2 = instance2.createObjects(1e-10);\r\n        expRes1 = results2.get(0);\r\n        expHit1res1 = expRes1.iterator().next();\r\n        expHsp1hit1res1 = expHit1res1.iterator().next();\r\n        \r\n        hsp1Hit1Res1 = new BlastHspBuilder()\r\n                .setPercentageIdentity(100.00/100)\r\n                .setHspAlignLen(48)\r\n                .setMismatchCount(0)\r\n                .setHspGaps(0)\r\n                .setHspQueryFrom(1)\r\n                .setHspQueryTo(48)\r\n                .setHspHitFrom(344)\r\n                .setHspHitTo(391)\r\n                .setHspEvalue(4e-19)\r\n                .setHspBitScore(95.6)\r\n                .createBlastHsp();\r\n        \r\n        hit1Res1 = new BlastHitBuilder()\r\n                .setHitDef(\"KF031625.1.1775\")\r\n                .createBlastHit();\r\n        \r\n        res1 = new BlastResultBuilder()\r\n                .setQueryID(\"1_759_906_F3\")\r\n                .setQueryDef(\"1_759_906_F3\")\r\n                .createBlastResult();\r\n        \r\n        // results test\r\n        assertEquals(expRes1, res1);\r\n        // hit test\r\n        assertEquals(expHit1res1, hit1Res1);\r\n        // hsp test\r\n        assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\r\n    }\r\n\r\n    \r\n    \r\n}\r\n","commitMessage":"Better exception handling.\n","test_commitMessage":"Better exception handling.\n","allZero":false}