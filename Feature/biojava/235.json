{"repository":"biojava","prod_path":"phylo/src/main/java/org/biojavax/bio/phylo/io/nexus/TreesBlock.java","test_path":"phylo/src/test/java/org/biojavax/bio/phylo/io/nexus/TreesBlockTest.java","prod_time":"2009-12-21 23:19:19","test_time":"2009-12-21 23:19:19","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":13,"add_classname_line":0,"add_condition_line":3,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":1,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"8d1888de93415891b7b1136133def24eb86af163","test_commitID":"8d1888de93415891b7b1136133def24eb86af163","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojavax.bio.phylo.io.nexus;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.Vector;\n\nimport org.jgrapht.WeightedGraph;\nimport org.jgrapht.UndirectedGraph;\nimport org.jgrapht.graph.DefaultEdge;\nimport org.jgrapht.graph.DefaultWeightedEdge;\nimport org.jgrapht.graph.SimpleWeightedGraph;\n\nimport org.biojava.bio.seq.io.ParseException;\n\n\n/**\n * Represents Nexus trees blocks.\n * \n * @author Richard Holland\n * @author Tobias Thierer\n * @author Jim Balhoff\n * @author Tiago Antao\n * @since 1.6\n */\npublic class TreesBlock extends NexusBlock.Abstract {\n\n\t/**\n\t * A constant representing the name of Trees blocks.\n\t */\n\tpublic static final String TREES_BLOCK = \"TREES\";\n\n\tprivate Map translations = new LinkedHashMap();\n\n\tprivate List comments = new ArrayList();\n\n\tprivate Map trees = new LinkedHashMap();\n\n\tprivate WeightedGraph<String, DefaultWeightedEdge> weighted =  new SimpleWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n\n    private String topNode = null;\n\n\tprivate String nodePrefix = \"p\";\n\n\tprivate int pValue = 0;\n\tprivate Vector<String> uuids;\n\n\t/**\n\t * A simple representation of a Newick tree as a single string.\n\t */\n\tpublic static class NewickTreeString {\n\t\tprivate String rootType;\n\n\t\tprivate String treeString;\n\n\t\tprivate boolean starred;\n\n\t\t/**\n\t\t * Make the tree (un)rooted.\n\t\t * \n\t\t * @param rootType\n\t\t *            'U' for unrooted, 'R' for rooted, <tt>null</tt> for\n\t\t *            unsure.\n\t\t */\n\t\tpublic void setRootType(final String rootType) {\n\t\t\tthis.rootType = rootType;\n\t\t}\n\n\t\t/**\n\t\t * Set the Newick string describing the tree.\n\t\t */\n\t\tpublic void setTreeString(final String treeString) {\n\t\t\tthis.treeString = treeString;\n\t\t}\n\n\t\t/**\n\t\t * Sets whether this tree has a star before it's name.\n\t\t * \n\t\t * @param starred\n\t\t *            <tt>true</tt> if it has one.\n\t\t */\n\t\tpublic void setStarred(boolean starred) {\n\t\t\tthis.starred = starred;\n\t\t}\n\n\t\t/**\n\t\t * Tests whether this tree has a star before it's name.\n\t\t * \n\t\t * @return starred <tt>true</tt> if it has one.\n\t\t */\n\t\tpublic boolean isStarred() {\n\t\t\treturn this.starred;\n\t\t}\n\n\t\t/**\n\t\t * See if the tree is rooted.\n\t\t * \n\t\t * @return 'U' for unrooted, 'R' for rooted, <tt>null</tt> for unsure.\n\t\t */\n\t\tpublic String getRootType() {\n\t\t\treturn this.rootType;\n\t\t}\n\n\t\t/**\n\t\t * Get the Newick string describing the tree.\n\t\t * \n\t\t * @return the tree string.\n\t\t */\n\t\tpublic String getTreeString() {\n\t\t\treturn this.treeString;\n\t\t}\n\t}\n\n\t/**\n\t * Delegates to NexusBlock.Abstract constructor using TreesBlock.TREES_BLOCK\n\t * as the name.\n\t */\n\tpublic TreesBlock() {\n\t\tsuper(TreesBlock.TREES_BLOCK);\n\t}\n\n\t/**\n\t * Add a translation.\n\t * \n\t * @param label\n\t *            the label to add.\n\t * @param taxa\n\t *            the taxa name this label will represent.\n\t */\n\tpublic void addTranslation(final String label, final String taxa) {\n\t\tthis.translations.put(label, taxa);\n\t}\n\n\t/**\n\t * Removes the given translation.\n\t * \n\t * @param label\n\t *            the label to remove.\n\t */\n\tpublic void removeTranslation(final String label) {\n\t\tthis.translations.remove(label);\n\t}\n\n\t/**\n\t * Checks to see if we contain the given translation.\n\t * \n\t * @param label\n\t *            the label to check for.\n\t * @return <tt>true</tt> if we already contain it.\n\t */\n\tpublic boolean containsTranslation(final String label) {\n\t\treturn this.translations.containsKey(label);\n\t}\n\n\t/**\n\t * Get the translations added so far.\n\t * \n\t * @return the translations added so far.\n\t */\n\tpublic Map getTranslations() {\n\t\treturn this.translations;\n\t}\n\n\t/**\n\t * Adds a tree.\n\t * \n\t * @param label\n\t *            the label to give the tree.\n\t * @param tree\n\t *            the tree to add.\n\t */\n\tpublic void addTree(final String label, final NewickTreeString tree) {\n\t\tthis.trees.put(label, tree);\n\t}\n\n\t/**\n\t * Removes a tree.\n\t * \n\t * @param label\n\t *            the label to remove.\n\t */\n\tpublic void removeTree(final String label) {\n\t\tthis.trees.remove(label);\n\t}\n\n\t/**\n\t * Checks to see if we contain the given tree.\n\t * \n\t * @param label\n\t *            the label to check for.\n\t * @return <tt>true</tt> if we already contain it.\n\t */\n\tpublic boolean containsTree(final String label) {\n\t\treturn this.trees.containsKey(label);\n\t}\n\n\t/**\n\t * Returns all trees.\n\t * \n\t * @return all the selected trees.\n\t */\n\tpublic Map getTrees() {\n\t\treturn this.trees;\n\t}\n\n\t/**\n\t * Returns a tree for given label\n\t * @param label\n             * \t the label to select.\n\t *\n\t * @return selected tree.\n             */\n     \tpublic Object getTree(final String label) {\n\t\treturn this.trees.get(label);\n\t}\n\n\tpublic String getTreeText(UndirectedGraph<String, DefaultEdge> treegraph, String node, String parent){\n\t\tSet<DefaultEdge> edges = treegraph.edgesOf(node);\n\t\tint numOffspring = 0;\n\t\tStringBuffer nodeText = new StringBuffer(\"\");\n\t\tfor(DefaultEdge e : edges) {\n\t\t\tString child;\n\t\t\tif (treegraph.getEdgeSource(e).equals(node)) {\n\t\t\t\tchild = treegraph.getEdgeTarget(e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchild = treegraph.getEdgeSource(e);\n\t\t\t}\n\t\t\tif (child.equals(parent)) {\n\t\t\t\tbreak; //We dont want to go up the tree...\n\t\t\t}\n\t\t\tif (numOffspring>0) {\n\t\t\t\tnodeText.append(\", \");\n\t\t\t}\n\t\t\tnodeText.append(getTreeText(treegraph, child, node));\n\t\t\tnumOffspring++;\n\t\t}\n\t\tif (numOffspring==0) {\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\treturn \"(\" + nodeText + \")\";\n\t\t}\n\t}\n\n\n\t\n\n\t/**\n\t * Add a tree, converting weighted graph (JGraphT) to NewickString\n\t *\n\t * This will assume a (arbitrary) root node using the old convention\n\t * of labeling intermediate nodes as p*.\n\t *\n\t *\n\t * @deprecated\n\t * @param label\n\t * \t\t  the label to add\n\t *\n\t * @param treegraph\n\t * \t\t  the treegraph to convert.\n     */      \n\tpublic void addTree(final String label, WeightedGraph<String, DefaultWeightedEdge> treegraph) {\n\t\taddTree(label, treegraph, \"p0\");\n\t}\n\n\tpublic String getTreeText(WeightedGraph<String, DefaultWeightedEdge> treegraph, String node, String parent){\n\t\tSet<DefaultWeightedEdge> edges = treegraph.edgesOf(node);\n\t\tint numOffspring = 0;\n\t\tStringBuffer nodeText = new StringBuffer(\"\");\n\t\tfor(DefaultWeightedEdge e : edges) {\n\t\t\tString child;\n\t\t\tif (treegraph.getEdgeSource(e).equals(node)) {\n\t\t\t\tchild = treegraph.getEdgeTarget(e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchild = treegraph.getEdgeSource(e);\n\t\t\t}\n\t\t\tif (child.equals(parent)) {\n\t\t\t\tbreak; //We dont want to go up the tree...\n\t\t\t}\n\t\t\tif (numOffspring>0) {\n\t\t\t\tnodeText.append(\", \");\n\t\t\t}\n\t\t\tnodeText.append(getTreeText(treegraph, child, node));\n\t\t\tnodeText.append(\":\"+treegraph.getEdgeWeight(e));\n\t\t\tnumOffspring++;\n\t\t}\n\t\tif (numOffspring==0) {\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\treturn \"(\" + nodeText + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * Add a tree, converting weighted graph (JGraphT) to NewickString.\n\t *\n\t * @param label\n\t * \t\t  the label to add\n\t *\n\t * @param treegraph\n\t * \t\t  the treegraph to convert.\n\t *\n\t * @param topLabel\n\t *        the label of the top (root if rooted tree) node.\n     */\n\tpublic void addTree(final String label,\n\t\t\tWeightedGraph<String, DefaultWeightedEdge> treegraph, String topLabel) {\n\t\tfinal NewickTreeString tree = new NewickTreeString();\n\t\tString temp;\n\n\t\tfor(String vertex : treegraph.vertexSet()) {\n\t\t\tif (vertex.equals(topLabel)) {\n\t\t\t\ttopLabel = vertex; //String equality is not enough, has to be the same object\n\t\t\t}\n\t\t}\n\t\ttemp = getTreeText(treegraph, topLabel, null);\n\t\ttree.setTreeString(temp);\n\t\tthis.trees.put(label, tree);\n\t}\t\n\n\n\t/**\n\t * Renames a vertex of the weighted graph.\n\t *\n\t * @param v vertex name.\n\t * @param p_index the current suffix.\n\t * @return the new p_index.\n\t */\n\tprivate void renameVertex(String oldName, String newName) {\n\t\tSet<DefaultWeightedEdge> oldEdges = this.weighted.edgesOf(oldName);\n\n\t\tthis.weighted.addVertex(newName);\n\t\tfor (DefaultWeightedEdge e : oldEdges) {\n\t\t\tDefaultWeightedEdge tempEdge;\n\t\t\tif (this.weighted.getEdgeSource(e).equals(oldName)) {\n\t\t\t\ttempEdge = this.weighted.addEdge(newName,\n\t\t\t\t\t\tthis.weighted.getEdgeTarget(e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttempEdge = this.weighted.addEdge(this.weighted.getEdgeSource(e),\n\t\t\t\t\t\tnewName);\n\t\t\t}\n\t\t\tthis.weighted.setEdgeWeight(tempEdge,this.weighted.getEdgeWeight(e));\n\t\t\t//this.unweighted.removeEdge(e); Not needed\n\t\t}\n\t\tthis.weighted.removeVertex(oldName);\n\t}\n\n\n\n\t/**\n\t * Tokenizes a string representing a newick tree.\n\t * \n\t * Simple tokenizing, removing spaces and so on.\n\t * \n\t * @param text the string representing the tree\n\t * @return An array of tokens\n\t */\n\tVector<String> tokenize(String text) {\n\t\tVector<String> toks = new Vector<String>();\n\t\twhile (!text.equals(\"\")) {\n\t\t\ttext = text.trim();\n\t\t\tString delims = \"(),: \\t\";\n\t\t\tString c = text.substring(0, 1);\n\t\t\tif (delims.contains(c)) {\n\t\t\t\ttoks.add(c);\n\t\t\t\ttext = text.substring(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString currTok = \"\";\n\t\t\t\tint pos = 0;\n\t\t\t\twhile(!delims.contains(c)) {\n\t\t\t\t\t//StringBuffer here might be faster....\n\t\t\t\t\tcurrTok += c;\n\t\t\t\t\tif (text.length()>1) {\n\t\t\t\t\t\ttext = text.substring(1);\n\t\t\t\t\t\tc = text.substring(0, 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttoks.add(currTok);\n\t\t\t\t\t\treturn toks;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoks.add(currTok);\n\t\t\t}\n\t\t}\n\n\t\treturn toks;\n\t}\n\n\t/*\n\t * Checks if the graph has a name as vertex.\n\t */\n\tprivate boolean hasVertex(String name) {\n\t\tfor(String vertex : this.weighted.vertexSet()) {\n\t\t\tif (vertex.equals(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Parses a Newick tree.\n\t * \n\t * Alters this.weighted!\n\t * \n\t * The tree is passed as a set of tokens.\n\t * \n\t * If some tokens are not processed, these are maintained in the vector.\n\t * All consumed ones are removed.\n\t * \n\t * @param tokens Stream of tokens to be parser\n\t */\n\tvoid parseTree(Vector<String> tokens, String parent) throws ParseException {\n\t\tString myNode;\n\t\tif (parent == null) {\n\t\t\tpValue = 0;\n\t\t\tuuids = new Vector<String>();\n\t\t}\n\t\t//System.out.println(\"Top: \" + parent + \" \");\n\t\t//for(String tok: tokens) {\n\t\t//\tSystem.out.print(\" \" + tok);\n\t\t//}\n\t\t//System.out.println();\n\n\t\tif (tokens.get(0).equals(\"(\")) {\n\t\t\ttokens.remove(0);\n\t\t\tmyNode = UUID.randomUUID().toString();\n\t\t\tuuids.add(myNode);\n\t\t\tthis.weighted.addVertex(myNode);\n\t\t\tif (parent != null) {\n\t\t\t\tthis.weighted.addEdge(parent, myNode);\n\t\t\t}\n\t\t\twhile (!tokens.get(0).equals(\")\")) {\n\t\t\t\tparseTree(tokens, myNode);\n\t\t\t\tif (tokens.get(0).equals(\",\")) {\n\t\t\t\t\ttokens.remove(0);\n\t\t\t\t}\n\t\t\t\telse if (!tokens.get(0).equals(\")\") ) {\n\t\t\t\t\tthrow new ParseException (\"Expecting ), got \" + tokens.get(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens.remove(0);\n\t\t\tif (tokens.size() > 0) {\n\t\t\t\tif (tokens.get(0).equals(\":\")) {\n\t\t\t\t\ttokens.remove(0);\n\t\t\t\t\tthis.weighted.setEdgeWeight(\n\t\t\t\t\t\t\tthis.weighted.getEdge(parent, myNode),\n\t\t\t\t\t\t\tDouble.parseDouble(tokens.get(0)));\n\t\t\t\t\ttokens.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (parent == null) {\n\t\t\t\tString finalName;\n\t\t\t\t//Lets solve clashes\n\t\t\t\tfor (String uuid: uuids) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tfinalName = this.nodePrefix + (this.pValue++);\n\t\t\t\t\t} while (hasVertex(finalName));\n\t\t\t\t\tif (uuid.equals(myNode)) {\n\t\t\t\t\t\tthis.topNode = finalName;\n\t\t\t\t\t}\n\t\t\t\t\trenameVertex(uuid, finalName);\n\t\t\t\t}\n\n\t\t\t\tuuids = null; //for gc\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tmyNode = tokens.get(0);\n\t\t\ttokens.remove(0);\n\t\t\tthis.weighted.addVertex(myNode);\n\t\t\tthis.weighted.addEdge(parent, myNode);\n\t\t\tif (tokens.get(0).equals(\":\")) {\n\t\t\t\ttokens.remove(0);\n\t\t\t\tthis.weighted.setEdgeWeight(\n\t\t\t\t\t\tthis.weighted.getEdge(parent, myNode),\n\t\t\t\t\t\tDouble.parseDouble(tokens.get(0)));\n\t\t\t\ttokens.remove(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get given (NewickString) tree by label, converts it to weighted graph (JGraphT).\n\t * \n\t * Alters this.weighted!\n\t *\n\t * @param label\n\t * \t\t label for tree selection \n\t *\n\t * @return converted tree as undirectedGraph\n\t */\n\tpublic WeightedGraph<String, DefaultWeightedEdge> getTreeAsWeightedJGraphT(final String label)\n\tthrows ParseException {\n\t\tString temp;\n\t\tTreesBlock.NewickTreeString t = new TreesBlock.NewickTreeString();\n\t\n\t\tthis.weighted =  new SimpleWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n\t\tt = (TreesBlock.NewickTreeString) this.trees.get(label);\n\t\ttemp = t.getTreeString();\n\t\tparseTree(tokenize(temp), null);\n\n\t\treturn this.weighted;\n\t}\n      \n\t/**\n\t * Adds a comment.\n\t * \n\t * @param comment\n\t *            the comment to add.\n\t */\n\tpublic void addComment(final NexusComment comment) {\n\t\tthis.comments.add(comment);\n\t}\n\n\t/**\n\t * Removes a comment.\n\t * \n\t * @param comment\n\t *            the comment to remove.\n\t */\n\tpublic void removeComment(final NexusComment comment) {\n\t\tthis.comments.remove(comment);\n\t}\n\n\t/**\n\t * Returns all comments.\n\t * \n\t * @return all the selected comments.\n\t */\n\tpublic List getComments() {\n\t\treturn this.comments;\n\t}\n\n\tprotected void writeBlockContents(Writer writer) throws IOException {\n\t\tfor (final Iterator i = this.comments.iterator(); i.hasNext();) {\n\t\t\t((NexusComment) i.next()).writeObject(writer);\n\t\t\twriter.write(NexusFileFormat.NEW_LINE);\n\t\t}\n\t\twriter.write(\" TRANSLATE\" + NexusFileFormat.NEW_LINE);\n\t\tfor (final Iterator i = this.translations.entrySet().iterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tfinal Map.Entry entry = (Map.Entry) i.next();\n\t\t\twriter.write('\\t');\n\t\t\tthis.writeToken(writer, \"\" + entry.getKey());\n\t\t\twriter.write('\\t');\n\t\t\tthis.writeToken(writer, \"\" + entry.getValue());\n\t\t\tif (i.hasNext())\n\t\t\t\twriter.write(',');\n\t\t\telse\n\t\t\t\twriter.write(';');\n\t\t\twriter.write(NexusFileFormat.NEW_LINE);\n\t\t}\n\t\tfor (final Iterator i = this.trees.entrySet().iterator(); i.hasNext();) {\n\t\t\tfinal Map.Entry entry = (Map.Entry) i.next();\n\t\t\tfinal NewickTreeString treeStr = (NewickTreeString) entry\n\t\t\t\t\t.getValue();\n\t\t\twriter.write(\" TREE \");\n\t\t\tif (treeStr.isStarred())\n\t\t\t\twriter.write(\"* \");\n\t\t\tthis.writeToken(writer, \"\" + entry.getKey());\n\t\t\twriter.write('=');\n\t\t\tif (treeStr.getRootType() != null)\n\t\t\t\twriter.write(\"[\" + treeStr.getRootType() + \"]\");\n\t\t\tthis.writeToken(writer, treeStr.getTreeString());\n\t\t\twriter.write(\";\" + NexusFileFormat.NEW_LINE);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the top node of the previously requested graph.\n\t *\n\t * The topNode will be the root node if the tree is rooted, if not\n\t * then it will just be the top most node of the newick string with\n\t * no biological meaning.\n\t *\n\t * The top node from the {@link #getTreeAsJGraphT(java.lang.String)}\n\t * and {@link #getTreeAsWeightedJGraphT(java.lang.String)} might vary,\n\t * and this function will return the top node of the previously called\n\t * method only. If no method was called, null is returned.\n\t *\n\t * Note: the top node between graphs, probably does not vary, but,\n\t * just in case, the note is here and the user should get a different\n\t * top for each type of graph.\n\t *\n\t * @return the top node.\n\t */\n\tpublic String getTopNode() {\n\t\treturn topNode;\n\t}\n\n\t/**\n\t * Sets the node prefix of intermediate nodes for returned graphs.\n\t *\n\t * The intermediate nodes of graphs have to be named, the conventions\n\t * being:\n\t *    1. Generate a new node name using a prefix plus an integer\n\t *    2. If the node name clashes with any taxon name, use another integer\n\t *\n\t * @param prefix The prefix\n\t */\n\tpublic void setNodePrefix(String prefix) {\n\t\tthis.nodePrefix = prefix;\n\t}\n\n\t/**\n\t * Returns the node prefix.\n\t * \n\t * @return the node prefix\n\t */\n\tpublic String getNodePrefix() {\n\t\treturn this.nodePrefix;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojavax.bio.phylo.io.nexus;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.Vector;\n\nimport org.jgrapht.WeightedGraph;\nimport org.jgrapht.UndirectedGraph;\nimport org.jgrapht.graph.DefaultEdge;\nimport org.jgrapht.graph.DefaultWeightedEdge;\nimport org.jgrapht.graph.SimpleWeightedGraph;\n\nimport org.biojava.bio.seq.io.ParseException;\n\n\n/**\n * Represents Nexus trees blocks.\n * \n * @author Richard Holland\n * @author Tobias Thierer\n * @author Jim Balhoff\n * @author Tiago Antao\n * @since 1.6\n */\npublic class TreesBlock extends NexusBlock.Abstract {\n\n\t/**\n\t * A constant representing the name of Trees blocks.\n\t */\n\tpublic static final String TREES_BLOCK = \"TREES\";\n\n\tprivate Map translations = new LinkedHashMap();\n\n\tprivate List comments = new ArrayList();\n\n\tprivate Map trees = new LinkedHashMap();\n\n\tprivate WeightedGraph<String, DefaultWeightedEdge> weighted =  new SimpleWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n\n    private String topNode = null;\n\n\tprivate String nodePrefix = \"p\";\n\n\tprivate int pValue = 0;\n\tprivate Vector<String> uuids;\n\n\t/**\n\t * A simple representation of a Newick tree as a single string.\n\t */\n\tpublic static class NewickTreeString {\n\t\tprivate String rootType;\n\n\t\tprivate String treeString;\n\n\t\tprivate boolean starred;\n\n\t\t/**\n\t\t * Make the tree (un)rooted.\n\t\t * \n\t\t * @param rootType\n\t\t *            'U' for unrooted, 'R' for rooted, <tt>null</tt> for\n\t\t *            unsure.\n\t\t */\n\t\tpublic void setRootType(final String rootType) {\n\t\t\tthis.rootType = rootType;\n\t\t}\n\n\t\t/**\n\t\t * Set the Newick string describing the tree.\n\t\t */\n\t\tpublic void setTreeString(final String treeString) {\n\t\t\tthis.treeString = treeString;\n\t\t}\n\n\t\t/**\n\t\t * Sets whether this tree has a star before it's name.\n\t\t * \n\t\t * @param starred\n\t\t *            <tt>true</tt> if it has one.\n\t\t */\n\t\tpublic void setStarred(boolean starred) {\n\t\t\tthis.starred = starred;\n\t\t}\n\n\t\t/**\n\t\t * Tests whether this tree has a star before it's name.\n\t\t * \n\t\t * @return starred <tt>true</tt> if it has one.\n\t\t */\n\t\tpublic boolean isStarred() {\n\t\t\treturn this.starred;\n\t\t}\n\n\t\t/**\n\t\t * See if the tree is rooted.\n\t\t * \n\t\t * @return 'U' for unrooted, 'R' for rooted, <tt>null</tt> for unsure.\n\t\t */\n\t\tpublic String getRootType() {\n\t\t\treturn this.rootType;\n\t\t}\n\n\t\t/**\n\t\t * Get the Newick string describing the tree.\n\t\t * \n\t\t * @return the tree string.\n\t\t */\n\t\tpublic String getTreeString() {\n\t\t\treturn this.treeString;\n\t\t}\n\t}\n\n\t/**\n\t * Delegates to NexusBlock.Abstract constructor using TreesBlock.TREES_BLOCK\n\t * as the name.\n\t */\n\tpublic TreesBlock() {\n\t\tsuper(TreesBlock.TREES_BLOCK);\n\t}\n\n\t/**\n\t * Add a translation.\n\t * \n\t * @param label\n\t *            the label to add.\n\t * @param taxa\n\t *            the taxa name this label will represent.\n\t */\n\tpublic void addTranslation(final String label, final String taxa) {\n\t\tthis.translations.put(label, taxa);\n\t}\n\n\t/**\n\t * Removes the given translation.\n\t * \n\t * @param label\n\t *            the label to remove.\n\t */\n\tpublic void removeTranslation(final String label) {\n\t\tthis.translations.remove(label);\n\t}\n\n\t/**\n\t * Checks to see if we contain the given translation.\n\t * \n\t * @param label\n\t *            the label to check for.\n\t * @return <tt>true</tt> if we already contain it.\n\t */\n\tpublic boolean containsTranslation(final String label) {\n\t\treturn this.translations.containsKey(label);\n\t}\n\n\t/**\n\t * Get the translations added so far.\n\t * \n\t * @return the translations added so far.\n\t */\n\tpublic Map getTranslations() {\n\t\treturn this.translations;\n\t}\n\n\t/**\n\t * Adds a tree.\n\t * \n\t * @param label\n\t *            the label to give the tree.\n\t * @param tree\n\t *            the tree to add.\n\t */\n\tpublic void addTree(final String label, final NewickTreeString tree) {\n\t\tthis.trees.put(label, tree);\n\t}\n\n\t/**\n\t * Removes a tree.\n\t * \n\t * @param label\n\t *            the label to remove.\n\t */\n\tpublic void removeTree(final String label) {\n\t\tthis.trees.remove(label);\n\t}\n\n\t/**\n\t * Checks to see if we contain the given tree.\n\t * \n\t * @param label\n\t *            the label to check for.\n\t * @return <tt>true</tt> if we already contain it.\n\t */\n\tpublic boolean containsTree(final String label) {\n\t\treturn this.trees.containsKey(label);\n\t}\n\n\t/**\n\t * Returns all trees.\n\t * \n\t * @return all the selected trees.\n\t */\n\tpublic Map getTrees() {\n\t\treturn this.trees;\n\t}\n\n\t/**\n\t * Returns a tree for given label\n\t * @param label\n             * \t the label to select.\n\t *\n\t * @return selected tree.\n             */\n     \tpublic Object getTree(final String label) {\n\t\treturn this.trees.get(label);\n\t}\n\n\tpublic String getTreeText(UndirectedGraph<String, DefaultEdge> treegraph, String node, String parent){\n\t\tSet<DefaultEdge> edges = treegraph.edgesOf(node);\n\t\tint numOffspring = 0;\n\t\tStringBuffer nodeText = new StringBuffer(\"\");\n\t\tfor(DefaultEdge e : edges) {\n\t\t\tString child;\n\t\t\tif (treegraph.getEdgeSource(e).equals(node)) {\n\t\t\t\tchild = treegraph.getEdgeTarget(e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchild = treegraph.getEdgeSource(e);\n\t\t\t}\n\t\t\tif (child.equals(parent)) {\n\t\t\t\tbreak; //We dont want to go up the tree...\n\t\t\t}\n\t\t\tif (numOffspring>0) {\n\t\t\t\tnodeText.append(\", \");\n\t\t\t}\n\t\t\tnodeText.append(getTreeText(treegraph, child, node));\n\t\t\tnumOffspring++;\n\t\t}\n\t\tif (numOffspring==0) {\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\treturn \"(\" + nodeText + \")\";\n\t\t}\n\t}\n\n\n\t\n\n\t/**\n\t * Add a tree, converting weighted graph (JGraphT) to NewickString\n\t *\n\t * This will assume a (arbitrary) root node using the old convention\n\t * of labeling intermediate nodes as p*.\n\t *\n\t *\n\t * @deprecated\n\t * @param label\n\t * \t\t  the label to add\n\t *\n\t * @param treegraph\n\t * \t\t  the treegraph to convert.\n     */      \n\tpublic void addTree(final String label, WeightedGraph<String, DefaultWeightedEdge> treegraph) {\n\t\taddTree(label, treegraph, \"p0\");\n\t}\n\n\tpublic String getTreeText(WeightedGraph<String, DefaultWeightedEdge> treegraph, String node, String parent){\n\t\tSet<DefaultWeightedEdge> edges = treegraph.edgesOf(node);\n\t\tint numOffspring = 0;\n\t\tStringBuffer nodeText = new StringBuffer(\"\");\n\t\tfor(DefaultWeightedEdge e : edges) {\n\t\t\tString child;\n\t\t\tif (treegraph.getEdgeSource(e).equals(node)) {\n\t\t\t\tchild = treegraph.getEdgeTarget(e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchild = treegraph.getEdgeSource(e);\n\t\t\t}\n\t\t\tif (child.equals(parent)) {\n\t\t\t\tbreak; //We dont want to go up the tree...\n\t\t\t}\n\t\t\tif (numOffspring>0) {\n\t\t\t\tnodeText.append(\", \");\n\t\t\t}\n\t\t\tnodeText.append(getTreeText(treegraph, child, node));\n\t\t\tnodeText.append(\":\"+treegraph.getEdgeWeight(e));\n\t\t\tnumOffspring++;\n\t\t}\n\t\tif (numOffspring==0) {\n\t\t\treturn node;\n\t\t}\n\t\telse {\n\t\t\treturn \"(\" + nodeText + \")\";\n\t\t}\n\t}\n\n\t/**\n\t * Add a tree, converting weighted graph (JGraphT) to NewickString.\n\t *\n\t * @param label\n\t * \t\t  the label to add\n\t *\n\t * @param treegraph\n\t * \t\t  the treegraph to convert.\n\t *\n\t * @param topLabel\n\t *        the label of the top (root if rooted tree) node.\n     */\n\tpublic void addTree(final String label,\n\t\t\tWeightedGraph<String, DefaultWeightedEdge> treegraph, String topLabel) {\n\t\tfinal NewickTreeString tree = new NewickTreeString();\n\t\tString temp;\n\n\t\tfor(String vertex : treegraph.vertexSet()) {\n\t\t\tif (vertex.equals(topLabel)) {\n\t\t\t\ttopLabel = vertex; //String equality is not enough, has to be the same object\n\t\t\t}\n\t\t}\n\t\ttemp = getTreeText(treegraph, topLabel, null);\n\t\ttree.setTreeString(temp);\n\t\tthis.trees.put(label, tree);\n\t}\t\n\n\n\t/**\n\t * Renames a vertex of the weighted graph.\n\t *\n\t * @param oldName old name.\n\t * @param newName new name.\n\t */\n\tprivate void renameVertex(String oldName, String newName) {\n\t\tSet<DefaultWeightedEdge> oldEdges = this.weighted.edgesOf(oldName);\n\n\t\tthis.weighted.addVertex(newName);\n\t\tfor (DefaultWeightedEdge e : oldEdges) {\n\t\t\tDefaultWeightedEdge tempEdge;\n\t\t\tif (this.weighted.getEdgeSource(e).equals(oldName)) {\n\t\t\t\ttempEdge = this.weighted.addEdge(newName,\n\t\t\t\t\t\tthis.weighted.getEdgeTarget(e));\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttempEdge = this.weighted.addEdge(this.weighted.getEdgeSource(e),\n\t\t\t\t\t\tnewName);\n\t\t\t}\n\t\t\tthis.weighted.setEdgeWeight(tempEdge,this.weighted.getEdgeWeight(e));\n\t\t\t//this.unweighted.removeEdge(e); Not needed\n\t\t}\n\t\tthis.weighted.removeVertex(oldName);\n\t}\n\n\n\n\t/**\n\t * Tokenizes a string representing a newick tree.\n\t * \n\t * Simple tokenizing, removing spaces and so on.\n\t * \n\t * @param text the string representing the tree\n\t * @return An array of tokens\n\t */\n\tVector<String> tokenize(String text) {\n\t\tVector<String> toks = new Vector<String>();\n\t\twhile (!text.equals(\"\")) {\n\t\t\ttext = text.trim();\n\t\t\tString delims = \"(),: \\t\";\n\t\t\tString c = text.substring(0, 1);\n\t\t\tif (delims.contains(c)) {\n\t\t\t\ttoks.add(c);\n\t\t\t\ttext = text.substring(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString currTok = \"\";\n\t\t\t\tint pos = 0;\n\t\t\t\twhile(!delims.contains(c)) {\n\t\t\t\t\t//StringBuffer here might be faster....\n\t\t\t\t\tcurrTok += c;\n\t\t\t\t\tif (text.length()>1) {\n\t\t\t\t\t\ttext = text.substring(1);\n\t\t\t\t\t\tc = text.substring(0, 1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ttoks.add(currTok);\n\t\t\t\t\t\treturn toks;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoks.add(currTok);\n\t\t\t}\n\t\t}\n\n\t\treturn toks;\n\t}\n\n\t/*\n\t * Checks if the graph has a name as vertex.\n\t */\n\tprivate boolean hasVertex(String name) {\n\t\tfor(String vertex : this.weighted.vertexSet()) {\n\t\t\tif (vertex.equals(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n       /**\n         * Processes the weight part (if it exists).#\n         *\n         * @param tokens\n         */\n        void processWeight(Vector<String> tokens, String parent, String myNode) {\n            if (tokens.size() == 0) {\n                return;\n            }\n            if (tokens.get(0).equals(\":\")) {\n                    tokens.remove(0);\n                    this.weighted.setEdgeWeight(\n                                    this.weighted.getEdge(parent, myNode),\n                                    Double.parseDouble(tokens.get(0)));\n                    tokens.remove(0);\n            }\n        }\n\n\t/**\n\t * Parses a Newick tree.\n\t * \n\t * Alters this.weighted!\n\t * \n\t * The tree is passed as a set of tokens.\n\t * \n\t * If some tokens are not processed, these are maintained in the vector.\n\t * All consumed ones are removed.\n\t * \n\t * @param tokens Stream of tokens to be parser\n\t */\n\tvoid parseTree(Vector<String> tokens, String parent) throws ParseException {\n\t\tString myNode;\n\t\tif (parent == null) {\n\t\t\tpValue = 0;\n\t\t\tuuids = new Vector<String>();\n\t\t}\n\t\t//System.out.println(\"Top: \" + parent + \" \");\n\t\t//for(String tok: tokens) {\n\t\t//\tSystem.out.print(\" \" + tok);\n\t\t//}\n\t\t//System.out.println();\n\n\t\tif (tokens.get(0).equals(\"(\")) {\n\t\t\ttokens.remove(0);\n\t\t\tmyNode = UUID.randomUUID().toString();\n\t\t\tuuids.add(myNode);\n\t\t\tthis.weighted.addVertex(myNode);\n\t\t\tif (parent != null) {\n\t\t\t\tthis.weighted.addEdge(parent, myNode);\n\t\t\t}\n\t\t\twhile (!tokens.get(0).equals(\")\")) {\n\t\t\t\tparseTree(tokens, myNode);\n\t\t\t\tif (tokens.get(0).equals(\",\")) {\n\t\t\t\t\ttokens.remove(0);\n\t\t\t\t}\n\t\t\t\telse if (!tokens.get(0).equals(\")\") ) {\n\t\t\t\t\tthrow new ParseException (\"Expecting ), got \" + tokens.get(0));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttokens.remove(0);\n\t\t\tif (tokens.size() > 0) {\n\t\t\t\tString nextToken = tokens.get(0);\n\t\t\t\tchar firstChar = nextToken.charAt(0);\n\t\t\t\tif (Character.isLetter(firstChar)) {\n\t\t\t\t\tuuids.remove(myNode);\n\t\t\t\t\trenameVertex(myNode, nextToken);\n\t\t\t\t\tmyNode = nextToken;\n\t\t\t\t\ttokens.remove(0);\n\t\t\t\t}\n\t\t\t\tprocessWeight(tokens, parent, myNode);\n\t\t\t}\n\t\t\tif (parent == null) {\n\t\t\t\tString finalName;\n\t\t\t\t//Lets solve clashes\n\t\t\t\tfor (String uuid: uuids) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tfinalName = this.nodePrefix + (this.pValue++);\n\t\t\t\t\t} while (hasVertex(finalName));\n\t\t\t\t\tif (uuid.equals(myNode)) {\n\t\t\t\t\t\tthis.topNode = finalName;\n\t\t\t\t\t}\n\t\t\t\t\trenameVertex(uuid, finalName);\n\t\t\t\t}\n\n\t\t\t\tuuids = null; //for gc\n\t\t\t}\n\n\t\t}\n\t\telse {\n\t\t\tmyNode = tokens.get(0);\n\t\t\ttokens.remove(0);\n\t\t\tthis.weighted.addVertex(myNode);\n\t\t\tthis.weighted.addEdge(parent, myNode);\n\t\t\tif (tokens.get(0).equals(\":\")) {\n\t\t\t\ttokens.remove(0);\n\t\t\t\tthis.weighted.setEdgeWeight(\n\t\t\t\t\t\tthis.weighted.getEdge(parent, myNode),\n\t\t\t\t\t\tDouble.parseDouble(tokens.get(0)));\n\t\t\t\ttokens.remove(0);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get given (NewickString) tree by label, converts it to weighted graph (JGraphT).\n\t * \n\t * Alters this.weighted!\n\t *\n\t * @param label\n\t * \t\t label for tree selection \n\t *\n\t * @return converted tree as undirectedGraph\n\t */\n\tpublic WeightedGraph<String, DefaultWeightedEdge> getTreeAsWeightedJGraphT(final String label)\n\tthrows ParseException {\n\t\tString temp;\n\t\tTreesBlock.NewickTreeString t = new TreesBlock.NewickTreeString();\n\t\n\t\tthis.weighted =  new SimpleWeightedGraph<String, DefaultWeightedEdge>(DefaultWeightedEdge.class);\n\t\tt = (TreesBlock.NewickTreeString) this.trees.get(label);\n\t\ttemp = t.getTreeString();\n\t\tparseTree(tokenize(temp), null);\n\n\t\treturn this.weighted;\n\t}\n      \n\t/**\n\t * Adds a comment.\n\t * \n\t * @param comment\n\t *            the comment to add.\n\t */\n\tpublic void addComment(final NexusComment comment) {\n\t\tthis.comments.add(comment);\n\t}\n\n\t/**\n\t * Removes a comment.\n\t * \n\t * @param comment\n\t *            the comment to remove.\n\t */\n\tpublic void removeComment(final NexusComment comment) {\n\t\tthis.comments.remove(comment);\n\t}\n\n\t/**\n\t * Returns all comments.\n\t * \n\t * @return all the selected comments.\n\t */\n\tpublic List getComments() {\n\t\treturn this.comments;\n\t}\n\n\tprotected void writeBlockContents(Writer writer) throws IOException {\n\t\tfor (final Iterator i = this.comments.iterator(); i.hasNext();) {\n\t\t\t((NexusComment) i.next()).writeObject(writer);\n\t\t\twriter.write(NexusFileFormat.NEW_LINE);\n\t\t}\n\t\twriter.write(\" TRANSLATE\" + NexusFileFormat.NEW_LINE);\n\t\tfor (final Iterator i = this.translations.entrySet().iterator(); i\n\t\t\t\t.hasNext();) {\n\t\t\tfinal Map.Entry entry = (Map.Entry) i.next();\n\t\t\twriter.write('\\t');\n\t\t\tthis.writeToken(writer, \"\" + entry.getKey());\n\t\t\twriter.write('\\t');\n\t\t\tthis.writeToken(writer, \"\" + entry.getValue());\n\t\t\tif (i.hasNext())\n\t\t\t\twriter.write(',');\n\t\t\telse\n\t\t\t\twriter.write(';');\n\t\t\twriter.write(NexusFileFormat.NEW_LINE);\n\t\t}\n\t\tfor (final Iterator i = this.trees.entrySet().iterator(); i.hasNext();) {\n\t\t\tfinal Map.Entry entry = (Map.Entry) i.next();\n\t\t\tfinal NewickTreeString treeStr = (NewickTreeString) entry\n\t\t\t\t\t.getValue();\n\t\t\twriter.write(\" TREE \");\n\t\t\tif (treeStr.isStarred())\n\t\t\t\twriter.write(\"* \");\n\t\t\tthis.writeToken(writer, \"\" + entry.getKey());\n\t\t\twriter.write('=');\n\t\t\tif (treeStr.getRootType() != null)\n\t\t\t\twriter.write(\"[\" + treeStr.getRootType() + \"]\");\n\t\t\tthis.writeToken(writer, treeStr.getTreeString());\n\t\t\twriter.write(\";\" + NexusFileFormat.NEW_LINE);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the top node of the previously requested graph.\n\t *\n\t * The topNode will be the root node if the tree is rooted, if not\n\t * then it will just be the top most node of the newick string with\n\t * no biological meaning.\n\t *\n\t * The top node from the {@link #getTreeAsJGraphT(java.lang.String)}\n\t * and {@link #getTreeAsWeightedJGraphT(java.lang.String)} might vary,\n\t * and this function will return the top node of the previously called\n\t * method only. If no method was called, null is returned.\n\t *\n\t * Note: the top node between graphs, probably does not vary, but,\n\t * just in case, the note is here and the user should get a different\n\t * top for each type of graph.\n\t *\n\t * @return the top node.\n\t */\n\tpublic String getTopNode() {\n\t\treturn topNode;\n\t}\n\n\t/**\n\t * Sets the node prefix of intermediate nodes for returned graphs.\n\t *\n\t * The intermediate nodes of graphs have to be named, the conventions\n\t * being:\n\t *    1. Generate a new node name using a prefix plus an integer\n\t *    2. If the node name clashes with any taxon name, use another integer\n\t *\n\t * @param prefix The prefix\n\t */\n\tpublic void setNodePrefix(String prefix) {\n\t\tthis.nodePrefix = prefix;\n\t}\n\n\t/**\n\t * Returns the node prefix.\n\t * \n\t * @return the node prefix\n\t */\n\tpublic String getNodePrefix() {\n\t\treturn this.nodePrefix;\n\t}\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojavax.bio.phylo.io.nexus;\n\n//import java.io.BufferedReader;\n//import java.io.ByteArrayOutputStream;\nimport java.io.File;\n//import java.io.IOException;\n//import java.io.InputStream;\n//import java.io.InputStreamReader;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojavax.bio.phylo.io.nexus.NexusFile;\nimport org.biojavax.bio.phylo.io.nexus.NexusFileBuilder;\nimport org.biojavax.bio.phylo.io.nexus.NexusFileFormat;\nimport org.jgrapht.WeightedGraph;\nimport org.jgrapht.graph.DefaultWeightedEdge;\n\n/**\n * JUnit test for TreesBlock parsing.\n *\n * Currently very simple, but test for parsing ability.\n *\n * @author Tiago Antao\n */\npublic class TreesBlockTest extends TestCase {\n    NexusFile nexus1;\n    NexusFile nexus2;\n\n    public TreesBlockTest(String name) {\n        super(name);\n    }\n\n    /*\n     * Tests a binary tree.\n     */\n    public void testSimple() {\n        doVertexCount(nexus1, \"test1\", 3);\n    }\n\n    /*\n     * Tests more than binary.\n     */\n    public void testThreeOffspring() {\n        doVertexCount(nexus1, \"test2\", 4);\n    }\n\n    /*\n     * Tests depth >1.\n     */\n    public void testMoreDepth() {\n        doVertexCount(nexus1, \"test3\", 5);\n    }\n\n\n    /*\n     * Tests parsing distance.\n     */\n    public void testDistanceParsing() {\n        doVertexCount(nexus1, \"test4\", 5);\n    }\n\n    /*\n     * Tests complex tree, no distance.\n     */\n    public void testComplex() {\n        doVertexCount(nexus1, \"test5\", 28);\n    }\n\n    /*\n     * Tests complex tree, with distance.\n     */\n    public void testComplexWithDistance() {\n        doVertexCount(nexus1, \"test6\", 28);\n    }\n\n    /*\n     * Tests complex tree with name clashing, no distance.\n     */\n    public void testClash() {\n        doVertexCount(nexus1, \"test7\", 28);\n    }\n\n    /*\n     * Tests complex tree, name clashing, with distance.\n     */\n    public void testClashWithDistance() {\n        doVertexCount(nexus1, \"test8\", 28);\n    }\n\n    /*\n     * Tests resiliency to comma after last translate info.\n     */\n    public void testParseIncorrectTranslation() {\n        doVertexCount(nexus2, \"test1\", 3);\n    }\n\n\n    protected void setUp() {\n        try {\n            NexusFileBuilder builder = new NexusFileBuilder();\n            NexusFileFormat.parseInputStream(builder, this.getClass().getResourceAsStream(\"/test1.nex\"));\n            nexus1 = builder.getNexusFile();\n            NexusFileFormat.parseInputStream(builder, this.getClass().getResourceAsStream(\"/test2.nex\"));\n            nexus2 = builder.getNexusFile();\n        }\n        catch (Exception e) {\n            //Should not happen\n        }\n    }\n\n    private void doVertexCount(NexusFile nexus, String tree, int count) {\n        try {\n            getTree(nexus, tree);\n            assertEquals(countVertexes(), count);\n        }\n        catch (ParseException pe) {\n            fail(\"ParserFailure: \" + pe.getMessage());\n        }\n    }\n\n    private int countVertexes() {\n        Set<String> vertexes = tree.vertexSet();\n        int cnt = 0;\n\n        for (String v : vertexes) {\n            cnt++;\n        }\n        return cnt;\n    }\n\n    private String topNode;\n\n    private TreesBlock getTreeNode(NexusFile nexus) {\n        Iterator it = nexus.blockIterator();\n        NexusBlock block;\n        while(it.hasNext()) {\n            block = (NexusBlock)it.next();\n            if (block.getBlockName().equals(\"TREES\")) {\n                return (TreesBlock)block;\n            }\n        }\n        return null;\n    }\n\n    private WeightedGraph<String, DefaultWeightedEdge> tree;\n\n    private void getTree(NexusFile nexus, String name)\n    throws ParseException {\n        TreesBlock node = getTreeNode(nexus);\n        tree = node.getTreeAsWeightedJGraphT(name);\n        //System.out.println(node.getTopNode());\n        topNode = node.getTopNode();\n    }\n\n\n    // creates a suite\n    public static Test suite()\n    {\n        TestSuite suite = new TestSuite(TreesBlockTest.class);\n\n        return suite;\n    }\n\n    // harness for tests\n    public static void main(String [] args)\n    {\n        junit.textui.TestRunner.run(suite());\n    }\n\n}\n\n","changedTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojavax.bio.phylo.io.nexus;\n\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.Set;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojavax.bio.phylo.io.nexus.NexusFile;\nimport org.biojavax.bio.phylo.io.nexus.NexusFileBuilder;\nimport org.biojavax.bio.phylo.io.nexus.NexusFileFormat;\nimport org.jgrapht.WeightedGraph;\nimport org.jgrapht.graph.DefaultWeightedEdge;\n\n/**\n * JUnit test for TreesBlock parsing.\n *\n * Currently very simple, but test for parsing ability.\n *\n * @author Tiago Antao\n */\npublic class TreesBlockTest extends TestCase {\n    NexusFile nexus1;\n    NexusFile nexus2;\n    NexusFile nexus3;\n\n    public TreesBlockTest(String name) {\n        super(name);\n    }\n\n    /*\n     * Tests a binary tree.\n     */\n    public void testSimple() {\n        doVertexCount(nexus1, \"test1\", 3);\n    }\n\n    /*\n     * Tests more than binary.\n     */\n    public void testThreeOffspring() {\n        doVertexCount(nexus1, \"test2\", 4);\n    }\n\n    /*\n     * Tests depth >1.\n     */\n    public void testMoreDepth() {\n        doVertexCount(nexus1, \"test3\", 5);\n    }\n\n\n    /*\n     * Tests parsing distance.\n     */\n    public void testDistanceParsing() {\n        doVertexCount(nexus1, \"test4\", 5);\n    }\n\n    /*\n     * Tests complex tree, no distance.\n     */\n    public void testComplex() {\n        doVertexCount(nexus1, \"test5\", 28);\n    }\n\n    /*\n     * Tests complex tree, with distance.\n     */\n    public void testComplexWithDistance() {\n        doVertexCount(nexus1, \"test6\", 28);\n    }\n\n    /*\n     * Tests complex tree with name clashing, no distance.\n     */\n    public void testClash() {\n        doVertexCount(nexus1, \"test7\", 28);\n    }\n\n    /*\n     * Tests complex tree, name clashing, with distance.\n     */\n    public void testClashWithDistance() {\n        doVertexCount(nexus1, \"test8\", 28);\n    }\n\n    /*\n     * Tests resiliency to comma after last translate info.\n     */\n    public void testParseIncorrectTranslation() {\n        doVertexCount(nexus2, \"test1\", 3);\n    }\n\n    /*\n     * Tests resiliency to newline in the middle of a tree.\n     */\n    public void testParseNewline() {\n        doVertexCount(nexus3, \"test1\", 3);\n    }\n    /*\n     * Tests ability to read inner node names.\n     */\n    public void testInnerNodeName() {\n        doVertexCount(nexus3, \"test2\", 5);\n    }\n    /*\n     * Tests ability to read inner node names and newlines.\n     *\n     * This is a bug based on a Felsenstein example.\n     */\n    public void testInnerNodeNameAncestor1() {\n        doVertexCount(nexus3, \"test3\", 7);\n    }\n\n\n\n    protected void setUp() {\n        try {\n            NexusFileBuilder builder = new NexusFileBuilder();\n            NexusFileFormat.parseInputStream(builder, this.getClass().getResourceAsStream(\"/test1.nex\"));\n            nexus1 = builder.getNexusFile();\n            NexusFileFormat.parseInputStream(builder, this.getClass().getResourceAsStream(\"/test2.nex\"));\n            nexus2 = builder.getNexusFile();\n            NexusFileFormat.parseInputStream(builder, this.getClass().getResourceAsStream(\"/test3.nex\"));\n            nexus3 = builder.getNexusFile();\n        }\n        catch (Exception e) {\n            //Should not happen\n        }\n    }\n\n    private void doVertexCount(NexusFile nexus, String tree, int count) {\n        try {\n            getTree(nexus, tree);\n            assertEquals(countVertexes(), count);\n        }\n        catch (ParseException pe) {\n            fail(\"ParserFailure: \" + pe.getMessage());\n        }\n    }\n\n    private int countVertexes() {\n        Set<String> vertexes = tree.vertexSet();\n        int cnt = 0;\n\n        for (String v : vertexes) {\n            cnt++;\n        }\n        return cnt;\n    }\n\n    private String topNode;\n\n    private TreesBlock getTreeNode(NexusFile nexus) {\n        Iterator it = nexus.blockIterator();\n        NexusBlock block;\n        while(it.hasNext()) {\n            block = (NexusBlock)it.next();\n            if (block.getBlockName().equals(\"TREES\")) {\n                return (TreesBlock)block;\n            }\n        }\n        return null;\n    }\n\n    private WeightedGraph<String, DefaultWeightedEdge> tree;\n\n    private void getTree(NexusFile nexus, String name)\n    throws ParseException {\n        TreesBlock node = getTreeNode(nexus);\n        tree = node.getTreeAsWeightedJGraphT(name);\n        //System.out.println(node.getTopNode());\n        topNode = node.getTopNode();\n    }\n\n\n    // creates a suite\n    public static Test suite()\n    {\n        TestSuite suite = new TestSuite(TreesBlockTest.class);\n\n        return suite;\n    }\n\n    // harness for tests\n    public static void main(String [] args)\n    {\n        junit.textui.TestRunner.run(suite());\n    }\n\n}\n\n","commitMessage":"Tiago Antao's Nexus patch.\n\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7278 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Tiago Antao's Nexus patch.\n\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7278 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}