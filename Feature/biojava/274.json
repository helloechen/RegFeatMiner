{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava3/core/sequence/io/GenbankWriter.java","test_path":"biojava-core/src/test/java/org/biojava3/core/sequence/io/GenbankWriterTest.java","prod_time":"2015-01-30 06:34:57","test_time":"2015-01-30 06:34:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":3,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","test_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\r\n * \r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.Collection;\r\n\r\nimport org.biojava3.core.sequence.io.template.GenbankHeaderFormatInterface;\r\nimport org.biojava3.core.sequence.template.Compound;\r\nimport org.biojava3.core.sequence.template.Sequence;\r\nimport org.biojava3.core.util.StringManipulationHelper;\r\n\r\n\r\n/**\r\n * @author mckeee1\r\n * \r\n */\r\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\r\n\tint SEQUENCE_INDENT = 9;\r\n\r\n\tOutputStream os;\r\n\tCollection<S> sequences;\r\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\r\n\tprivate int lineLength = 60;\r\n\r\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\r\n\t/**\r\n\t * Use default line length of 60\r\n\t * \r\n\t * @param os\r\n\t * @param sequences\r\n\t * @param headerFormat\r\n\t */\r\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\r\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\r\n\r\n\t\tthis.os = os;\r\n\t\tthis.sequences = sequences;\r\n\t\tthis.headerFormat = headerFormat;\r\n\t}\r\n\r\n\t/**\r\n\t * Set custom lineLength\r\n\t * \r\n\t * @param os\r\n\t * @param sequences\r\n\t * @param headerFormat\r\n\t * @param lineLength\r\n\t */\r\n\r\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\r\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\r\n\t\tthis.os = os;\r\n\t\tthis.sequences = sequences;\r\n\t\tthis.headerFormat = headerFormat;\r\n\t\tthis.lineLength = lineLength;\r\n\t}\r\n\r\n\t/**\r\n\t * Allow an override of operating system line separator for programs that\r\n\t * needs a specific CRLF or CR or LF option\r\n\t * \r\n\t * @param lineSeparator\r\n\t */\r\n\r\n\tpublic void process() throws Exception {\r\n\t\t// Loosely based on code from Howard Salis\r\n\t\t// TODO - Force lower case?\r\n\t\t// boolean closeit = false;\r\n\t\tPrintWriter writer = new PrintWriter(os);\r\n\t\tfor (S sequence : sequences) {\r\n\t\t\tString header = headerFormat.getHeader(sequence);\r\n\t\t\twriter.format(header);\r\n\t\t\twriter.println();\r\n\t\t\t// os.write(lineSep);\r\n\r\n\t\t\t/*\r\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\r\n\t\t\t * the length, and there is no need #to record a long sequence of\r\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\r\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\r\n\t\t\t * return\r\n\t\t\t */\r\n\r\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\r\n\t\t\tint seq_len = data.length();\r\n\t\t\twriter.println(\"ORIGIN\");\r\n\t\t\t// os.write(lineSep);\r\n\r\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\r\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\r\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\r\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\r\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\r\n\t\t\t\t\tif ((words + 10) > data.length()) {\r\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// os.write(lineSep);\r\n\t\t\t\twriter.println();\r\n\t\t\t}\r\n\r\n\t\t\twriter.println(\"//\");\r\n\r\n\t\t}\r\n\r\n\t\twriter.flush();\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * public static void main(String[] args) { try { FileInputStream is = new\r\n\t * FileInputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds.faa\");\r\n\t * \r\n\t * \r\n\t * FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new\r\n\t * FastaReader<ProteinSequence, AminoAcidCompound>(is, new\r\n\t * GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new\r\n\t * ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n\t * LinkedHashMap<String, ProteinSequence> proteinSequences =\r\n\t * fastaReader.process(); is.close();\r\n\t * \r\n\t * \r\n\t * // System.out.println(proteinSequences);\r\n\t * \r\n\t * FileOutputStream fileOutputStream = new\r\n\t * FileOutputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds_temp.faa\"\r\n\t * );\r\n\t * \r\n\t * BufferedOutputStream bo = new BufferedOutputStream(fileOutputStream);\r\n\t * long start = System.currentTimeMillis(); FastaWriter<ProteinSequence,\r\n\t * AminoAcidCompound> fastaWriter = new FastaWriter<ProteinSequence,\r\n\t * AminoAcidCompound>(bo, proteinSequences.values(), new\r\n\t * GenericFastaHeaderFormat<ProteinSequence, AminoAcidCompound>());\r\n\t * fastaWriter.process(); bo.close(); long end = System.currentTimeMillis();\r\n\t * System.out.println(\"Took \" + (end - start) + \" seconds\");\r\n\t * \r\n\t * fileOutputStream.close();\r\n\t * \r\n\t * \r\n\t * } catch (Exception e) { e.printStackTrace(); } }\r\n\t */\r\n\t/**\r\n\t * @return the lineLength\r\n\t */\r\n\tpublic int getLineLength() {\r\n\t\treturn lineLength;\r\n\t}\r\n\r\n\t/**\r\n\t * @param lineLength\r\n\t *            the lineLength to set\r\n\t */\r\n\tpublic void setLineLength(int lineLength) {\r\n\t\tthis.lineLength = lineLength;\r\n\t}\r\n\t\r\n}\r\n","changedPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\n/**\r\n * \r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\nimport org.biojava3.core.sequence.io.template.GenbankHeaderFormatInterface;\r\nimport org.biojava3.core.sequence.template.Compound;\r\nimport org.biojava3.core.sequence.template.Sequence;\r\nimport org.biojava3.core.util.StringManipulationHelper;\r\n\r\nimport java.io.OutputStream;\r\nimport java.io.PrintWriter;\r\nimport java.util.Collection;\r\n\r\n\r\n/**\r\n * @author mckeee1\r\n * \r\n */\r\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\r\n\tint SEQUENCE_INDENT = 9;\r\n\r\n\tOutputStream os;\r\n\tCollection<S> sequences;\r\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\r\n\tprivate int lineLength = 60;\r\n\r\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\r\n\t/**\r\n\t * Use default line length of 60\r\n\t * \r\n\t * @param os\r\n\t * @param sequences\r\n\t * @param headerFormat\r\n\t */\r\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\r\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\r\n\r\n\t\tthis.os = os;\r\n\t\tthis.sequences = sequences;\r\n\t\tthis.headerFormat = headerFormat;\r\n\t}\r\n\r\n\t/**\r\n\t * Set custom lineLength\r\n\t * \r\n\t * @param os\r\n\t * @param sequences\r\n\t * @param headerFormat\r\n\t * @param lineLength\r\n\t */\r\n\r\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\r\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\r\n\t\tthis.os = os;\r\n\t\tthis.sequences = sequences;\r\n\t\tthis.headerFormat = headerFormat;\r\n\t\tthis.lineLength = lineLength;\r\n\t}\r\n\r\n\t/**\r\n\t * Allow an override of operating system line separator for programs that\r\n\t * needs a specific CRLF or CR or LF option\r\n\t * \r\n\t * @param lineSeparator\r\n\t */\r\n\r\n\tpublic void process() throws Exception {\r\n\t\t// Loosely based on code from Howard Salis\r\n\t\t// TODO - Force lower case?\r\n\t\t// boolean closeit = false;\r\n\t\tPrintWriter writer = new PrintWriter(os);\r\n\t\tfor (S sequence : sequences) {\r\n\t\t\tString header = headerFormat.getHeader(sequence);\r\n\t\t\twriter.format(header);\r\n\t\t\twriter.println();\r\n\t\t\t// os.write(lineSep);\r\n\r\n\t\t\t/*\r\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\r\n\t\t\t * the length, and there is no need #to record a long sequence of\r\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\r\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\r\n\t\t\t * return\r\n\t\t\t */\r\n\r\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\r\n\t\t\tint seq_len = data.length();\r\n\t\t\twriter.println(\"ORIGIN\");\r\n\t\t\t// os.write(lineSep);\r\n\r\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\r\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\r\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\r\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\r\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\r\n\t\t\t\t\tif ((words + 10) > data.length()) {\r\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// os.write(lineSep);\r\n\t\t\t\twriter.println();\r\n\t\t\t}\r\n\r\n\t\t\twriter.println(\"//\");\r\n\r\n\t\t}\r\n\r\n\t\twriter.flush();\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * public static void main(String[] args) { try { FileInputStream is = new\r\n\t * FileInputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds.faa\");\r\n\t * \r\n\t * \r\n\t * FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new\r\n\t * FastaReader<ProteinSequence, AminoAcidCompound>(is, new\r\n\t * GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new\r\n\t * ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\r\n\t * LinkedHashMap<String, ProteinSequence> proteinSequences =\r\n\t * fastaReader.process(); is.close();\r\n\t * \r\n\t * \r\n\t * // System.out.println(proteinSequences);\r\n\t * \r\n\t * FileOutputStream fileOutputStream = new\r\n\t * FileOutputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds_temp.faa\"\r\n\t * );\r\n\t * \r\n\t * BufferedOutputStream bo = new BufferedOutputStream(fileOutputStream);\r\n\t * long start = System.currentTimeMillis(); FastaWriter<ProteinSequence,\r\n\t * AminoAcidCompound> fastaWriter = new FastaWriter<ProteinSequence,\r\n\t * AminoAcidCompound>(bo, proteinSequences.values(), new\r\n\t * GenericFastaHeaderFormat<ProteinSequence, AminoAcidCompound>());\r\n\t * fastaWriter.process(); bo.close(); long end = System.currentTimeMillis();\r\n\t * System.out.println(\"Took \" + (end - start) + \" seconds\");\r\n\t * \r\n\t * fileOutputStream.close();\r\n\t * \r\n\t * \r\n\t * } catch (Exception e) { e.printStackTrace(); } }\r\n\t */\r\n\t/**\r\n\t * @return the lineLength\r\n\t */\r\n\tpublic int getLineLength() {\r\n\t\treturn lineLength;\r\n\t}\r\n\r\n\t/**\r\n\t * @param lineLength\r\n\t *            the lineLength to set\r\n\t */\r\n\tpublic void setLineLength(int lineLength) {\r\n\t\tthis.lineLength = lineLength;\r\n\t}\r\n\t\r\n}\r\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\r\n * \r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.InputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedHashMap;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport org.biojava3.core.sequence.DNASequence;\r\nimport org.junit.Test;\r\n\r\n\r\n/**\r\n * @author mckeee1\r\n * \r\n */\r\npublic class GenbankWriterTest extends TestCase{\r\n\r\n\r\n\t@Test\r\n\tpublic void testProcess() throws Exception {\r\n\r\n        InputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\r\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\r\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\r\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\r\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\r\n\t\tfor(DNASequence seq : dnaSequences.values()) {\r\n\t\t\tseqs.add(seq);\r\n\t\t}\r\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\r\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\r\n\t\t//System.out.println(fragwriter.toString());\r\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\r\n                /**\r\n                 * Hello Jacek\r\n                 * can you please investigate why this test fails? it seems that \r\n                 * fragreader at the line below is read with the last feature \r\n                 * in an invalid state: location = 2005..2004\r\n                 */\r\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\r\n\t\tfragwriter.close();\r\n\t\tassertEquals(seqs.get(0).getSequenceAsString(),dnaSequences.values().iterator().next().getSequenceAsString());\r\n\t}\r\n}\r\n","changedTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\n/**\r\n * \r\n */\r\npackage org.biojava3.core.sequence.io;\r\n\r\n\r\nimport junit.framework.TestCase;\r\nimport org.biojava3.core.sequence.DNASequence;\r\nimport org.junit.Test;\r\n\r\nimport java.io.ByteArrayInputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.InputStream;\r\nimport java.util.ArrayList;\r\nimport java.util.LinkedHashMap;\r\n\r\n\r\n/**\r\n * @author mckeee1\r\n * \r\n */\r\npublic class GenbankWriterTest extends TestCase{\r\n\r\n\r\n\t@Test\r\n\tpublic void testProcess() throws Exception {\r\n\r\n        InputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\r\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\r\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\r\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\r\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\r\n\t\tfor(DNASequence seq : dnaSequences.values()) {\r\n\t\t\tseqs.add(seq);\r\n\t\t}\r\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\r\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\r\n\t\t//System.out.println(fragwriter.toString());\r\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\r\n                /**\r\n                 * Hello Jacek\r\n                 * can you please investigate why this test fails? it seems that \r\n                 * fragreader at the line below is read with the last feature \r\n                 * in an invalid state: location = 2005..2004\r\n                 */\r\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\r\n\t\tfragwriter.close();\r\n\t\tassertEquals(seqs.get(0).getSequenceAsString(),dnaSequences.values().iterator().next().getSequenceAsString());\r\n\t}\r\n}\r\n","commitMessage":"Ran Optimize Imports across the whole project.\n","test_commitMessage":"Ran Optimize Imports across the whole project.\n","allZero":false}