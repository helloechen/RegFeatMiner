{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/util/AtomCache.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/util/AtomCacheTest.java","prod_time":"2016-04-28 03:07:41","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"348f91dc3388f1be14efabed92ff83644517852e","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomPositionMap;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.ResidueRangeAndLength;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.client.StructureName;\nimport org.biojava.nbio.structure.cath.CathDatabase;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.structure.io.MMCIFFileReader;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.quaternary.io.BioUnitDataProviderFactory;\nimport org.biojava.nbio.structure.quaternary.io.MmCifBiolAssemblyProvider;\nimport org.biojava.nbio.structure.quaternary.io.PDBBioUnitDataProvider;\nimport org.biojava.nbio.structure.scop.CachedRemoteScopInstallation;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDescription;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility class that provides easy access to Structure objects. If you are running a script that is frequently\n * re-using the same PDB structures, the AtomCache keeps an in-memory cache of the files for quicker access. The cache\n * is a soft-cache, this means it won't cause out of memory exceptions, but garbage collects the data if the Java\n * virtual machine needs to free up space. The AtomCache is thread-safe.\n *\n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Peter Rose\n * @since 3.0\n */\npublic class AtomCache {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomCache.class);\n\n\tpublic static final String BIOL_ASSEMBLY_IDENTIFIER = \"BIO:\";\n\tpublic static final String CHAIN_NR_SYMBOL = \":\";\n\tpublic static final String CHAIN_SPLIT_SYMBOL = \".\";\n\n\tpublic static final String PDP_DOMAIN_IDENTIFIER = \"PDP:\";\n\n\tpublic static final String UNDERSCORE = \"_\";\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\tprotected FileParsingParameters params;\n\tprotected PDPProvider pdpprovider;\n\n\tprivate FetchBehavior fetchBehavior;\n\tprivate ObsoleteBehavior obsoleteBehavior;\n\n\tprivate String cachePath;\n\n\t// make sure IDs are loaded uniquely\n\tprivate Collection<String> currentlyLoading = Collections.synchronizedCollection(new TreeSet<String>());\n\n\tprivate String path;\n\n\tprivate boolean useMmCif;\n\n\t/**\n\t * Default AtomCache constructor.\n\t *\n\t * Usually stores files in a temp directory, but this can be overriden by setting the PDB_DIR variable at runtime.\n\t *\n\t * @see UserConfiguration#UserConfiguration()\n\t */\n\tpublic AtomCache() {\n\t\tthis(new UserConfiguration());\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system. It will use the same value for pdbFilePath and cachePath.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t */\n\tpublic AtomCache(String pdbFilePath) {\n\t\tthis(pdbFilePath,pdbFilePath);\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t * @param cachePath\n\t */\n\tpublic AtomCache(String pdbFilePath, String cachePath) {\n\n\t\tlogger.debug(\"Initialising AtomCache with pdbFilePath={}, cachePath={}\",pdbFilePath, cachePath);\n\n\t\tif (!pdbFilePath.endsWith(FILE_SEPARATOR)) {\n\t\t\tpdbFilePath += FILE_SEPARATOR;\n\t\t}\n\n\t\t// we are caching the binary files that contain the PDBs gzipped\n\t\t// that is the most memory efficient way of caching...\n\t\t// set the input stream provider to caching mode\n\t\tSystem.setProperty(InputStreamProvider.CACHE_PROPERTY, \"true\");\n\n\t\tsetPath(pdbFilePath);\n\n\t\tthis.cachePath = cachePath;\n\n\t\tfetchBehavior = FetchBehavior.DEFAULT;\n\t\tobsoleteBehavior = ObsoleteBehavior.DEFAULT;\n\n\t\tcurrentlyLoading.clear();\n\t\tparams = new FileParsingParameters();\n\n\t\t// we don't need this here\n\t\tparams.setAlignSeqRes(false);\n\t\t// no secstruc either\n\t\tparams.setParseSecStruc(false);\n\t\t//\n\n\t\tsetUseMmCif(true);\n\n\t}\n\n\t/**\n\t * @param isSplit Ignored\n\t * @deprecated isSplit parameter is ignored (4.0.0)\n\t */\n\t@Deprecated\n\tpublic AtomCache(String pdbFilePath,boolean isSplit) {\n\t\tthis(pdbFilePath);\n\t}\n\t/**\n\t * @param isSplit Ignored\n\t * @deprecated isSplit parameter is ignored (4.0.0)\n\t */\n\t@Deprecated\n\tpublic AtomCache(String pdbFilePath, String cachePath,boolean isSplit) {\n\t\tthis(pdbFilePath,cachePath);\n\t}\n\n\t/**\n\t * Creates a new AtomCache object based on the provided UserConfiguration.\n\t *\n\t * @param config\n\t *            the UserConfiguration to use for this cache.\n\t */\n\tpublic AtomCache(UserConfiguration config) {\n\t\tthis(config.getPdbFilePath(), config.getCacheFilePath());\n\t\tfetchBehavior = config.getFetchBehavior();\n\t\tobsoleteBehavior = config.getObsoleteBehavior();\n\t\tuseMmCif = config.getFileFormat().equals( UserConfiguration.MMCIF_FORMAT );\n\t}\n\n\t/**\n\t * Returns the CA atoms for the provided name. See {@link #getStructure(String)} for supported naming conventions.\n\t * <p>\n\t * This method only works with protein chains. Use {@link #getRepresentativeAtoms(String)}\n\t * for a more general solution.\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getAtoms(String name) throws IOException, StructureException {\n\t\treturn getAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\t// System.out.println(\"loading \" + name);\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getAtomCAArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Returns the representative atoms for the provided name.\n\t * See {@link #getStructure(String)} for supported naming conventions.\n\t *\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getRepresentativeAtoms(String name) throws IOException, StructureException {\n\t\treturn getRepresentativeAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getRepresentativeAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getRepresentativeAtomArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Loads the biological assembly for a given PDB ID and bioAssemblyId. If a bioAssemblyId > 0 is specified, the\n\t * corresponding biological assembly file will be loaded. Note, the number of available biological unit files\n\t * varies. Many entries don't have a biological assembly specified (i.e. NMR structures), many entries have only one\n\t * biological assembly (bioAssemblyId=1), and a few structures have multiple biological assemblies. Set\n\t * bioAssemblyFallback to true, to download the original PDB file in cases that a biological assembly file is not\n\t * available.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @param bioAssemblyFallback\n\t *            if true, try reading original PDB file in case the biological assembly file is not available\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, int bioAssemblyId, boolean bioAssemblyFallback)\n\t\t\tthrows StructureException, IOException {\n\n\t\tif (bioAssemblyId < 0) {\n\t\t\tthrow new StructureException(\"bioAssemblyID must be nonnegative: \" + pdbId + \" bioAssemblyId \"\n\t\t\t\t\t+ bioAssemblyId);\n\t\t}\n\t\tStructure s = StructureIO.getBiologicalAssembly(pdbId, bioAssemblyId,this);\n\n\t\tif ( s == null && bioAssemblyFallback)\n\t\t\treturn StructureIO.getBiologicalAssembly(pdbId, 0,this);\n\n\t\treturn s;\n\t}\n\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * <p>Biological assemblies can also be accessed using\n\t * <tt>getStructure(\"BIO:<i>[pdbId]</i>\")</tt>\n\t * @param pdbId\n\t *            the PDB ID\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId) throws StructureException, IOException {\n\t\tint bioAssemblyId = 1;\n\t\treturn getBiologicalAssembly(pdbId, bioAssemblyId);\n\t}\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 3.2\n\t * @deprecated Renamed to {@link #getBiologicalAssembly(String)} in 4.2\n\t */\n\t@Deprecated\n\tpublic Structure getBiologicalUnit(String pdbId) throws StructureException, IOException {\n\t\treturn getBiologicalAssembly(pdbId);\n\t}\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId,int bioAssemblyId) throws StructureException, IOException {\n\t\tboolean bioAssemblyFallback = true;\n\t\treturn getBiologicalAssembly(pdbId, bioAssemblyId, bioAssemblyFallback);\n\t}\n\n\t/**\n\t * Returns the path that contains the caching file for utility data, such as domain definitions.\n\t *\n\t * @return\n\t */\n\tpublic String getCachePath() {\n\t\treturn cachePath;\n\t}\n\n\tpublic FileParsingParameters getFileParsingParams() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * Get the path that is used to cache PDB files.\n\t *\n\t * @return path to a directory\n\t */\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic PDPProvider getPdpprovider() {\n\t\treturn pdpprovider;\n\t}\n\n\t/**\n\t * Request a Structure based on a <i>name</i>.\n\t *\n\t * <pre>\n\t * \t\tFormal specification for how to specify the <i>name</i>:\n\t *\n\t * \t\tname     := pdbID\n\t * \t\t               | pdbID '.' chainID\n\t * \t\t               | pdbID '.' range\n\t * \t\t               | scopID\n\t * \t\trange         := '('? range (',' range)? ')'?\n\t * \t\t               | chainID\n\t * \t\t               | chainID '_' resNum '-' resNum\n\t * \t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t * \t\tchainID       := [a-zA-Z0-9]\n\t * \t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t * \t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\t *\n\t *\n\t * \t\tExample structures:\n\t * \t\t1TIM     #whole structure\n\t * \t\t4HHB.C     #single chain\n\t * \t\t4GCR.A_1-83     #one domain, by residue number\n\t * \t\t3AA0.A,B     #two chains treated as one structure\n\t * \t\td2bq6a1     #scop domain\n\t * </pre>\n\t *\n\t * With the additional set of rules:\n\t *\n\t * <ul>\n\t * <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model\n\t * only (for NMR).\n\t * <li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A</li>\n\t * <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names,\n\t * see {@link #setStrictSCOP(boolean)}</li>\n\t * <li>URLs are accepted as well</li>\n\t * </ul>\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException\n\t *             The PDB file cannot be cached due to IO errors\n\t * @throws StructureException\n\t *             The name appeared valid but did not correspond to a structure. Also thrown by some submethods upon\n\t *             errors, eg for poorly formatted subranges.\n\t */\n\tpublic Structure getStructure(String name) throws IOException, StructureException {\n\t\tStructureName structureName = new StructureName(name);\n\n\t\treturn getStructure(structureName);\n\t}\n\n\t/**\n\t * Get the structure corresponding to the given {@link StructureIdentifier}.\n\t * Equivalent to calling {@link StructureIdentifier#loadStructure(AtomCache)}\n\t * followed by {@link StructureIdentifier#reduce(Structure)}.\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param strucId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructure(StructureIdentifier strucId) throws IOException, StructureException {\n\t\tStructure s = strucId.loadStructure(this);\n\t\tStructure r = strucId.reduce(s);\n\t\tr.setStructureIdentifier(strucId);\n\t\treturn r;\n\n//\t\tif (name.length() < 4) {\n//\t\t\tthrow new IllegalArgumentException(\"Can't interpret IDs that are shorter than 4 characters!\");\n//\t\t}\n//\n//\t\tStructure n = null;\n//\n//\t\tboolean useChainNr = false;\n//\t\tboolean useDomainInfo = false;\n//\t\tString range = null;\n//\t\tint chainNr = -1;\n//\n//\n//\t\tStructureName structureName = new StructureName(name);\n//\n//\t\tString pdbId = null;\n//\t\tString chainId = null;\n//\n//\t\tif (name.length() == 4) {\n//\n//\t\t\tpdbId = name;\n//\t\t\tStructure s;\n//\t\t\tif (useMmCif) {\n//\t\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n//\t\t\t} else {\n//\t\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n//\t\t\t}\n//\t\t\treturn s;\n//\t\t} else if (structureName.isScopName()) {\n//\n//\t\t\t// return based on SCOP domain ID\n//\t\t\treturn getStructureFromSCOPDomain(name);\n//\t\t} else if (structureName.isCathID()) {\n//\t\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n//\t\t} else if (name.length() == 6) {\n//\t\t\t// name is PDB.CHAINID style (e.g. 4hhb.A)\n//\n//\t\t\tpdbId = name.substring(0, 4);\n//\t\t\tif (name.substring(4, 5).equals(CHAIN_SPLIT_SYMBOL)) {\n//\t\t\t\tchainId = name.substring(5, 6);\n//\t\t\t} else if (name.substring(4, 5).equals(CHAIN_NR_SYMBOL)) {\n//\n//\t\t\t\tuseChainNr = true;\n//\t\t\t\tchainNr = Integer.parseInt(name.substring(5, 6));\n//\t\t\t}\n//\n//\t\t} else if (name.startsWith(\"file:/\") || name.startsWith(\"http:/\")) {\n//\t\t\t// this is a URL\n//\n//\t\t\tURL url = new URL(name);\n//\t\t\treturn getStructureFromURL(url);\n//\n//\n//\t\t} else if (structureName.isPDPDomain()) {\n//\n//\t\t\t// this is a PDP domain definition\n//\n//\t\t\treturn getPDPStructure(name);\n//\n//\t\t} else if (name.startsWith(BIOL_ASSEMBLY_IDENTIFIER)) {\n//\n//\t\t\treturn getBioAssembly(name);\n//\n//\t\t} else if (name.length() > 6 && !name.startsWith(PDP_DOMAIN_IDENTIFIER)\n//\t\t\t\t&& (name.contains(CHAIN_NR_SYMBOL) || name.contains(UNDERSCORE))\n//\t\t\t\t&& !(name.startsWith(\"file:/\") || name.startsWith(\"http:/\"))\n//\n//\t\t\t\t) {\n//\n//\t\t\t// this is a name + range\n//\n//\t\t\tpdbId = name.substring(0, 4);\n//\t\t\t// this ID has domain split information...\n//\t\t\tuseDomainInfo = true;\n//\t\t\trange = name.substring(5);\n//\n//\t\t}\n//\n//\t\t// System.out.println(\"got: >\" + name + \"< \" + pdbId + \" \" + chainId + \" useChainNr:\" + useChainNr + \" \"\n//\t\t// +chainNr + \" useDomainInfo:\" + useDomainInfo + \" \" + range);\n//\n//\t\tif (pdbId == null) {\n//\n//\t\t\treturn null;\n//\t\t}\n//\n//\t\twhile (checkLoading(pdbId)) {\n//\t\t\t// waiting for loading to be finished...\n//\n//\t\t\ttry {\n//\t\t\t\tThread.sleep(100);\n//\t\t\t} catch (InterruptedException e) {\n//\t\t\t\tlogger.error(e.getMessage());\n//\t\t\t}\n//\n//\t\t}\n//\n//\t\t// long start = System.currentTimeMillis();\n//\n//\t\tStructure s;\n//\t\tif (useMmCif) {\n//\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n//\t\t} else {\n//\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n//\t\t}\n//\n//\t\t// long end = System.currentTimeMillis();\n//\t\t// System.out.println(\"time to load \" + pdbId + \" \" + (end-start) + \"\\t  size :\" +\n//\t\t// StructureTools.getNrAtoms(s) + \"\\t cached: \" + cache.size());\n//\n//\t\tif (chainId == null && chainNr < 0 && range == null) {\n//\t\t\t// we only want the 1st model in this case\n//\t\t\tn = StructureTools.getReducedStructure(s, -1);\n//\t\t} else {\n//\n//\t\t\tif (useChainNr) {\n//\t\t\t\t// System.out.println(\"using ChainNr\");\n//\t\t\t\tn = StructureTools.getReducedStructure(s, chainNr);\n//\t\t\t} else if (useDomainInfo) {\n//\t\t\t\t// System.out.println(\"calling getSubRanges\");\n//\t\t\t\tn = StructureTools.getSubRanges(s, range);\n//\t\t\t} else {\n//\t\t\t\t// System.out.println(\"reducing Chain Id \" + chainId);\n//\t\t\t\tn = StructureTools.getReducedStructure(s, chainId);\n//\t\t\t}\n//\t\t}\n//\n//\n//\n//\t\tn.setName(name);\n//\t\treturn n;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain) throws IOException, StructureException {\n\t\treturn getStructureForDomain(domain, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\treturn getStructureForDomain(domain, scopDatabase, false);\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @param strictLigandHandling\n\t *            If set to false, hetero-atoms are included if and only if they belong to a chain to which the SCOP\n\t *            domain belongs; if set to true, hetero-atoms are included if and only if they are strictly within the\n\t *            definition (residue numbers) of the SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase, boolean strictLigandHandling)\n\t\t\tthrows IOException, StructureException {\n\n\t\tString pdbId = domain.getPdbId();\n\t\tStructure fullStructure = getStructureForPdbId(pdbId);\n\t\tStructure structure = domain.reduce(fullStructure);\n\n\t\t// TODO It would be better to move all of this into the reduce method,\n\t\t// but that would require ligand handling properties in StructureIdentifiers\n\n\t\t// because ligands sometimes occur after TER records in PDB files, we may need to add some ligands back in\n\t\t// specifically, we add a ligand if and only if it occurs within the domain\n\t\tAtomPositionMap map = null;\n\t\tList<ResidueRangeAndLength> rrs = null;\n\t\tif (strictLigandHandling) {\n\t\t\tmap = new AtomPositionMap(StructureTools.getAllAtomArray(fullStructure), AtomPositionMap.ANYTHING_MATCHER);\n\t\t\trrs = ResidueRangeAndLength.parseMultiple(domain.getRanges(), map);\n\t\t}\n\t\tfor (Chain chain : fullStructure.getChains()) {\n\t\t\tif (!structure.hasChain(chain.getChainID())) {\n\t\t\t\tcontinue; // we can't do anything with a chain our domain\n\t\t\t}\n\t\t\t// doesn't contain\n\t\t\tChain newChain = structure.getChainByPDB(chain.getChainID());\n\t\t\tList<Group> ligands = StructureTools.filterLigands(chain.getAtomGroups());\n\t\t\tfor (Group group : ligands) {\n\t\t\t\tboolean shouldContain = true;\n\t\t\t\tif (strictLigandHandling) {\n\t\t\t\t\tshouldContain = false; // whether the ligand occurs within the domain\n\t\t\t\t\tfor (ResidueRange rr : rrs) {\n\t\t\t\t\t\tif (rr.contains(group.getResidueNumber(), map)) {\n\t\t\t\t\t\t\tshouldContain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean alreadyContains = newChain.getAtomGroups().contains(group); // we don't want to add duplicate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ligands\n\t\t\t\tif (shouldContain && !alreadyContains) {\n\t\t\t\t\tnewChain.addGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build a more meaningful description for the new structure\n\t\tStringBuilder header = new StringBuilder();\n\t\theader.append(domain.getClassificationId());\n\t\tif (scopDatabase != null) {\n\t\t\tint sf = domain.getSuperfamilyId();\n\t\t\tScopDescription description = scopDatabase.getScopDescriptionBySunid(sf);\n\t\t\tif (description != null) {\n\t\t\t\theader.append(\" | \");\n\t\t\t\theader.append(description.getDescription());\n\t\t\t}\n\t\t}\n\t\tstructure.getPDBHeader().setDescription(header.toString());\n\n\t\treturn structure;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId) throws IOException, StructureException {\n\t\treturn getStructureForDomain(scopId, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\tScopDomain domain = scopDatabase.getDomainByScopID(scopId);\n\t\treturn getStructureForDomain(domain, scopDatabase);\n\t}\n\n\t/**\n\t * Does the cache automatically download files that are missing from the local installation from the PDB FTP site?\n\t *\n\t * @return flag\n\t * @deprecated Use {@link #getFetchBehavior()}\n\t */\n\t@Deprecated\n\tpublic boolean isAutoFetch() {\n\t\treturn fetchBehavior != FetchBehavior.LOCAL_ONLY;\n\t}\n\n\t/**\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @return the fetchCurrent\n\t * @deprecated Use {@link FileParsingParameters#getObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic boolean isFetchCurrent() {\n\t\treturn getObsoleteBehavior() == ObsoleteBehavior.FETCH_CURRENT;\n\t}\n\n\t/**\n\t * forces the cache to fetch the file if its status is OBSOLETE. This feature has a higher priority than\n\t * {@link #setFetchCurrent(boolean)}.<br>\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @return the fetchFileEvenIfObsolete\n\t * @author Amr AL-Hossary\n\t * @see #fetchCurrent\n\t * @since 3.0.2\n\t * @deprecated Use {@link FileParsingParameters#getObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic boolean isFetchFileEvenIfObsolete() {\n\t\treturn getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE;\n\t}\n\n\n\t/**\n\t * Scop handling was changed in 4.2.0. For behaviour equivalent to\n\t * strictSCOP==true, use {@link ScopDatabase#getDomainByScopID(String)}.\n\t * For strictSCOP==False, create a {@link StructureName} or use\n\t * {@link StructureName#guessScopDomain(String, ScopDatabase)} explicitely.\n\t *\n\t * @return false; ignored\n\t * @deprecated since 4.2\n\t */\n\t@Deprecated\n\tpublic boolean isStrictSCOP() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Send a signal to the cache that the system is shutting down. Notifies underlying SerializableCache instances to\n\t * flush themselves...\n\t */\n\tpublic void notifyShutdown() {\n\t\t// System.out.println(\" AtomCache got notify shutdown..\");\n\t\tif (pdpprovider != null) {\n\t\t\tif (pdpprovider instanceof RemotePDPProvider) {\n\t\t\t\tRemotePDPProvider remotePDP = (RemotePDPProvider) pdpprovider;\n\t\t\t\tremotePDP.flushCache();\n\t\t\t}\n\t\t}\n\n\t\t// todo: use a SCOP implementation that is backed by SerializableCache\n\t\tScopDatabase scopInstallation = ScopFactory.getSCOP();\n\t\tif (scopInstallation != null) {\n\t\t\tif (scopInstallation instanceof CachedRemoteScopInstallation) {\n\t\t\t\tCachedRemoteScopInstallation cacheScop = (CachedRemoteScopInstallation) scopInstallation;\n\t\t\t\tcacheScop.flushCache();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Does the cache automatically download files that are missing from the local installation from the PDB FTP site?\n\t *\n\t * @param autoFetch\n\t *            flag\n\t * @deprecated Use {@link #getFetchBehavior()}\n\t */\n\t@Deprecated\n\tpublic void setAutoFetch(boolean autoFetch) {\n\t\tif(autoFetch) {\n\t\t\tsetFetchBehavior(FetchBehavior.DEFAULT);\n\t\t} else {\n\t\t\tsetFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\t}\n\t}\n\n\t/**\n\t * set the location at which utility data should be cached.\n\t *\n\t * @param cachePath\n\t */\n\tpublic void setCachePath(String cachePath) {\n\t\tthis.cachePath = cachePath;\n\t}\n\n\t/**\n\t * if enabled, the reader searches for the newest possible PDB ID, if not present in he local installation. The\n\t * {@link #setFetchFileEvenIfObsolete(boolean)} function has a higher priority than this function.<br>\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @param fetchCurrent\n\t *            the fetchCurrent to set\n\t * @author Amr AL-Hossary\n\t * @see #setFetchFileEvenIfObsolete(boolean)\n\t * @since 3.0.2\n\t * @deprecated Use {@link FileParsingParameters#setObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic void setFetchCurrent(boolean fetchNewestCurrent) {\n\t\tif(fetchNewestCurrent) {\n\t\t\tsetObsoleteBehavior(ObsoleteBehavior.FETCH_CURRENT);\n\t\t} else {\n\t\t\tif(getObsoleteBehavior() == ObsoleteBehavior.FETCH_CURRENT) {\n\t\t\t\tsetObsoleteBehavior(ObsoleteBehavior.DEFAULT);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @param fetchFileEvenIfObsolete\n\t *            the fetchFileEvenIfObsolete to set\n\t * @deprecated Use {@link FileParsingParameters#setObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic void setFetchFileEvenIfObsolete(boolean fetchFileEvenIfObsolete) {\n\t\tif(fetchFileEvenIfObsolete) {\n\t\t\tsetObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n\t\t} else {\n\t\t\tif(getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE) {\n\t\t\t\tsetObsoleteBehavior(ObsoleteBehavior.DEFAULT);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setFileParsingParams(FileParsingParameters params) {\n\t\tthis.params = params;\n\t}\n\n\n\t/**\n\t * <b>[Optional]</b> This method changes the behavior when obsolete entries\n\t * are requested. Current behaviors are:\n\t * <ul>\n\t * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n\t *   Throw a {@link StructureException} (the default)\n\t * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n\t *   Load the requested ID from the PDB's obsolete repository\n\t * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n\t *   Load the most recent version of the requested structure\n\t *\n\t * <p>This setting may be silently ignored by implementations which do not have\n\t * access to the server to determine whether an entry is obsolete, such as\n\t * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n\t * returned even this is FETCH_CURRENT if the entry is found locally.\n\t *\n\t * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n\t * @see #setFetchCurrent(boolean)\n\t * @since 4.0.0\n\t */\n\tpublic void setObsoleteBehavior(ObsoleteBehavior behavior) {\n\t\tobsoleteBehavior = behavior;\n\t}\n\n\t/**\n\t * Returns how this instance deals with obsolete entries. Note that this\n\t * setting may be ignored by some implementations or in some situations,\n\t * such as when {@link #isAutoFetch()} is false.\n\t *\n\t * <p>For most implementations, the default value is\n\t * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n\t *\n\t * @return The ObsoleteBehavior\n\t * @since 4.0.0\n\t */\n\tpublic ObsoleteBehavior getObsoleteBehavior() {\n\t\treturn obsoleteBehavior;\n\t}\n\n\t/**\n\t * Get the behavior for fetching files from the server\n\t * @return\n\t */\n\tpublic FetchBehavior getFetchBehavior() {\n\t\treturn fetchBehavior;\n\t}\n\t/**\n\t * Set the behavior for fetching files from the server\n\t * @param fetchBehavior\n\t */\n\tpublic void setFetchBehavior(FetchBehavior fetchBehavior) {\n\t\tthis.fetchBehavior = fetchBehavior;\n\t}\n\n\t/**\n\t * Set the path that is used to cache PDB files.\n\t *\n\t * @param path\n\t *            to a directory\n\t */\n\tpublic void setPath(String path) {\n\t\tthis.path = FileDownloadUtils.expandUserHome(path);\n\t}\n\n\tpublic void setPdpprovider(PDPProvider pdpprovider) {\n\t\tthis.pdpprovider = pdpprovider;\n\t}\n\n\n\t/**\n\t * This method does nothing.\n\t *\n\t * Scop handling was changed in 4.2.0. For behaviour equivalent to\n\t * strictSCOP==true, use {@link ScopDatabase#getDomainByScopID(String)}.\n\t * For strictSCOP==False, create a {@link StructureName} or use\n\t * {@link StructureName#guessScopDomain(String, ScopDatabase)} explicitely.\n\t *\n\t * @param strictSCOP Ignored\n\t * @deprecated Removed in 4.2.0\n\t */\n\t@Deprecated\n\tpublic void setStrictSCOP(boolean ignored) {}\n\n\t/**\n\t * @return the useMmCif\n\t */\n\tpublic boolean isUseMmCif() {\n\t\treturn useMmCif;\n\t}\n\n\t/**\n\t * @param useMmCif\n\t *            the useMmCif to set\n\t */\n\tpublic void setUseMmCif(boolean useMmCif) {\n\t\tthis.useMmCif = useMmCif;\n\n\t\tif ( useMmCif) {\n\t\t\t// get bio assembly from mmcif file\n\n\t\t\tBioUnitDataProviderFactory.setBioUnitDataProvider(MmCifBiolAssemblyProvider.class);\n\n\t\t} else {\n\n\t\t\tBioUnitDataProviderFactory.setBioUnitDataProvider(PDBBioUnitDataProvider.class);\n\n\t\t}\n\t}\n\n\tprivate boolean checkLoading(String name) {\n\t\treturn currentlyLoading.contains(name);\n\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the the {@link CathDatabase}\n\t * at {@link CathFactory#getCathDatabase()}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName) throws IOException, StructureException {\n\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the specified {@link CathDatabase}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName, CathDatabase cathInstall) throws IOException, StructureException {\n\n\t\tCathDomain cathDomain = cathInstall.getDomainByCathId(structureName.getIdentifier());\n\n\t\tStructure s = getStructureForPdbId(cathDomain.getIdentifier());\n\t\tStructure n = cathDomain.reduce(s);\n\n\t\t// add the ligands of the chain...\n\n\t\tChain newChain = n.getChainByPDB(structureName.getChainId());\n\t\tChain origChain = s.getChainByPDB(structureName.getChainId());\n\t\tList<Group> ligands = origChain.getAtomLigands();\n\n\t\tfor (Group g : ligands) {\n\t\t\tif (!newChain.getAtomGroups().contains(g)) {\n\t\t\t\tnewChain.addGroup(g);\n\t\t\t}\n\t\t}\n\n\t\treturn n;\n\t}\n\n\tprotected void flagLoading(String name) {\n\t\tif (!currentlyLoading.contains(name)) {\n\n\t\t\tcurrentlyLoading.add(name);\n\t\t}\n\t}\n\n\tprotected void flagLoadingFinished(String name) {\n\n\t\tcurrentlyLoading.remove(name);\n\t}\n\n\t/**\n\t * Loads a structure directly by PDB ID\n\t * @param pdbId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {\n\t\tif(pdbId == null)\n\t\t\treturn null;\n\t\tif(pdbId.length() != 4) {\n\t\t\tthrow new StructureException(\"Unrecognized PDB ID: \"+pdbId);\n\t\t}\n\t\twhile (checkLoading(pdbId)) {\n\t\t\t// waiting for loading to be finished...\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(e.getMessage());\n\t\t\t}\n\n\t\t}\n\n\t\tStructure s;\n\t\tif (useMmCif) {\n\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n\t\t} else {\n\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n\t\t}\n\t\treturn s;\n\t}\n\n\n\tprotected Structure loadStructureFromCifByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tMMCIFFileReader reader = new MMCIFFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprotected Structure loadStructureFromPdbByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tPDBFileReader reader = new PDBFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomPositionMap;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.ResidueRangeAndLength;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.client.StructureName;\nimport org.biojava.nbio.structure.cath.CathDatabase;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.structure.io.MMCIFFileReader;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.quaternary.io.BioUnitDataProviderFactory;\nimport org.biojava.nbio.structure.quaternary.io.MmCifBiolAssemblyProvider;\nimport org.biojava.nbio.structure.quaternary.io.PDBBioUnitDataProvider;\nimport org.biojava.nbio.structure.scop.CachedRemoteScopInstallation;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDescription;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility class that provides easy access to Structure objects. If you are running a script that is frequently\n * re-using the same PDB structures, the AtomCache keeps an in-memory cache of the files for quicker access. The cache\n * is a soft-cache, this means it won't cause out of memory exceptions, but garbage collects the data if the Java\n * virtual machine needs to free up space. The AtomCache is thread-safe.\n *\n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Peter Rose\n * @since 3.0\n */\npublic class AtomCache {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomCache.class);\n\n\tpublic static final String BIOL_ASSEMBLY_IDENTIFIER = \"BIO:\";\n\tpublic static final String CHAIN_NR_SYMBOL = \":\";\n\tpublic static final String CHAIN_SPLIT_SYMBOL = \".\";\n\n\tpublic static final String PDP_DOMAIN_IDENTIFIER = \"PDP:\";\n\n\tpublic static final String UNDERSCORE = \"_\";\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\tprotected FileParsingParameters params;\n\tprotected PDPProvider pdpprovider;\n\n\tprivate FetchBehavior fetchBehavior;\n\tprivate ObsoleteBehavior obsoleteBehavior;\n\n\tprivate String cachePath;\n\n\t// make sure IDs are loaded uniquely\n\tprivate Collection<String> currentlyLoading = Collections.synchronizedCollection(new TreeSet<String>());\n\n\tprivate String path;\n\n\tprivate boolean useMmCif;\n\n\t/**\n\t * Default AtomCache constructor.\n\t *\n\t * Usually stores files in a temp directory, but this can be overriden by setting the PDB_DIR variable at runtime.\n\t *\n\t * @see UserConfiguration#UserConfiguration()\n\t */\n\tpublic AtomCache() {\n\t\tthis(new UserConfiguration());\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system. It will use the same value for pdbFilePath and cachePath.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t */\n\tpublic AtomCache(String pdbFilePath) {\n\t\tthis(pdbFilePath,pdbFilePath);\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t * @param cachePath\n\t */\n\tpublic AtomCache(String pdbFilePath, String cachePath) {\n\n\t\tlogger.debug(\"Initialising AtomCache with pdbFilePath={}, cachePath={}\",pdbFilePath, cachePath);\n\n\t\tif (!pdbFilePath.endsWith(FILE_SEPARATOR)) {\n\t\t\tpdbFilePath += FILE_SEPARATOR;\n\t\t}\n\n\t\t// we are caching the binary files that contain the PDBs gzipped\n\t\t// that is the most memory efficient way of caching...\n\t\t// set the input stream provider to caching mode\n\t\tSystem.setProperty(InputStreamProvider.CACHE_PROPERTY, \"true\");\n\n\t\tsetPath(pdbFilePath);\n\n\t\tthis.cachePath = cachePath;\n\n\t\tfetchBehavior = FetchBehavior.DEFAULT;\n\t\tobsoleteBehavior = ObsoleteBehavior.DEFAULT;\n\n\t\tcurrentlyLoading.clear();\n\t\tparams = new FileParsingParameters();\n\n\t\tsetUseMmCif(true);\n\n\t}\n\n\t/**\n\t * @param isSplit Ignored\n\t * @deprecated isSplit parameter is ignored (4.0.0)\n\t */\n\t@Deprecated\n\tpublic AtomCache(String pdbFilePath,boolean isSplit) {\n\t\tthis(pdbFilePath);\n\t}\n\t/**\n\t * @param isSplit Ignored\n\t * @deprecated isSplit parameter is ignored (4.0.0)\n\t */\n\t@Deprecated\n\tpublic AtomCache(String pdbFilePath, String cachePath,boolean isSplit) {\n\t\tthis(pdbFilePath,cachePath);\n\t}\n\n\t/**\n\t * Creates a new AtomCache object based on the provided UserConfiguration.\n\t *\n\t * @param config\n\t *            the UserConfiguration to use for this cache.\n\t */\n\tpublic AtomCache(UserConfiguration config) {\n\t\tthis(config.getPdbFilePath(), config.getCacheFilePath());\n\t\tfetchBehavior = config.getFetchBehavior();\n\t\tobsoleteBehavior = config.getObsoleteBehavior();\n\t\tuseMmCif = config.getFileFormat().equals( UserConfiguration.MMCIF_FORMAT );\n\t}\n\n\t/**\n\t * Returns the CA atoms for the provided name. See {@link #getStructure(String)} for supported naming conventions.\n\t * <p>\n\t * This method only works with protein chains. Use {@link #getRepresentativeAtoms(String)}\n\t * for a more general solution.\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getAtoms(String name) throws IOException, StructureException {\n\t\treturn getAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\t// System.out.println(\"loading \" + name);\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getAtomCAArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Returns the representative atoms for the provided name.\n\t * See {@link #getStructure(String)} for supported naming conventions.\n\t *\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getRepresentativeAtoms(String name) throws IOException, StructureException {\n\t\treturn getRepresentativeAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getRepresentativeAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getRepresentativeAtomArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Loads the biological assembly for a given PDB ID and bioAssemblyId. If a bioAssemblyId > 0 is specified, the\n\t * corresponding biological assembly file will be loaded. Note, the number of available biological unit files\n\t * varies. Many entries don't have a biological assembly specified (i.e. NMR structures), many entries have only one\n\t * biological assembly (bioAssemblyId=1), and a few structures have multiple biological assemblies. Set\n\t * bioAssemblyFallback to true, to download the original PDB file in cases that a biological assembly file is not\n\t * available.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @param bioAssemblyFallback\n\t *            if true, try reading original PDB file in case the biological assembly file is not available\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, int bioAssemblyId, boolean bioAssemblyFallback)\n\t\t\tthrows StructureException, IOException {\n\n\t\tif (bioAssemblyId < 0) {\n\t\t\tthrow new StructureException(\"bioAssemblyID must be nonnegative: \" + pdbId + \" bioAssemblyId \"\n\t\t\t\t\t+ bioAssemblyId);\n\t\t}\n\t\tStructure s = StructureIO.getBiologicalAssembly(pdbId, bioAssemblyId,this);\n\n\t\tif ( s == null && bioAssemblyFallback)\n\t\t\treturn StructureIO.getBiologicalAssembly(pdbId, 0,this);\n\n\t\treturn s;\n\t}\n\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * <p>Biological assemblies can also be accessed using\n\t * <tt>getStructure(\"BIO:<i>[pdbId]</i>\")</tt>\n\t * @param pdbId\n\t *            the PDB ID\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId) throws StructureException, IOException {\n\t\tint bioAssemblyId = 1;\n\t\treturn getBiologicalAssembly(pdbId, bioAssemblyId);\n\t}\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 3.2\n\t * @deprecated Renamed to {@link #getBiologicalAssembly(String)} in 4.2\n\t */\n\t@Deprecated\n\tpublic Structure getBiologicalUnit(String pdbId) throws StructureException, IOException {\n\t\treturn getBiologicalAssembly(pdbId);\n\t}\n\t/**\n\t * Loads the default biological unit (e.g. *.pdb1.gz). If it is not available,\n\t * the asymmetric unit will be loaded, i.e. for NMR structures.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId,int bioAssemblyId) throws StructureException, IOException {\n\t\tboolean bioAssemblyFallback = true;\n\t\treturn getBiologicalAssembly(pdbId, bioAssemblyId, bioAssemblyFallback);\n\t}\n\n\t/**\n\t * Returns the path that contains the caching file for utility data, such as domain definitions.\n\t *\n\t * @return\n\t */\n\tpublic String getCachePath() {\n\t\treturn cachePath;\n\t}\n\n\tpublic FileParsingParameters getFileParsingParams() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * Get the path that is used to cache PDB files.\n\t *\n\t * @return path to a directory\n\t */\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic PDPProvider getPdpprovider() {\n\t\treturn pdpprovider;\n\t}\n\n\t/**\n\t * Request a Structure based on a <i>name</i>.\n\t *\n\t * <pre>\n\t * \t\tFormal specification for how to specify the <i>name</i>:\n\t *\n\t * \t\tname     := pdbID\n\t * \t\t               | pdbID '.' chainID\n\t * \t\t               | pdbID '.' range\n\t * \t\t               | scopID\n\t * \t\trange         := '('? range (',' range)? ')'?\n\t * \t\t               | chainID\n\t * \t\t               | chainID '_' resNum '-' resNum\n\t * \t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t * \t\tchainID       := [a-zA-Z0-9]\n\t * \t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t * \t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\t *\n\t *\n\t * \t\tExample structures:\n\t * \t\t1TIM     #whole structure\n\t * \t\t4HHB.C     #single chain\n\t * \t\t4GCR.A_1-83     #one domain, by residue number\n\t * \t\t3AA0.A,B     #two chains treated as one structure\n\t * \t\td2bq6a1     #scop domain\n\t * </pre>\n\t *\n\t * With the additional set of rules:\n\t *\n\t * <ul>\n\t * <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model\n\t * only (for NMR).\n\t * <li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A</li>\n\t * <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names,\n\t * see {@link #setStrictSCOP(boolean)}</li>\n\t * <li>URLs are accepted as well</li>\n\t * </ul>\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException\n\t *             The PDB file cannot be cached due to IO errors\n\t * @throws StructureException\n\t *             The name appeared valid but did not correspond to a structure. Also thrown by some submethods upon\n\t *             errors, eg for poorly formatted subranges.\n\t */\n\tpublic Structure getStructure(String name) throws IOException, StructureException {\n\t\tStructureName structureName = new StructureName(name);\n\n\t\treturn getStructure(structureName);\n\t}\n\n\t/**\n\t * Get the structure corresponding to the given {@link StructureIdentifier}.\n\t * Equivalent to calling {@link StructureIdentifier#loadStructure(AtomCache)}\n\t * followed by {@link StructureIdentifier#reduce(Structure)}.\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param strucId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructure(StructureIdentifier strucId) throws IOException, StructureException {\n\t\tStructure s = strucId.loadStructure(this);\n\t\tStructure r = strucId.reduce(s);\n\t\tr.setStructureIdentifier(strucId);\n\t\treturn r;\n\n//\t\tif (name.length() < 4) {\n//\t\t\tthrow new IllegalArgumentException(\"Can't interpret IDs that are shorter than 4 characters!\");\n//\t\t}\n//\n//\t\tStructure n = null;\n//\n//\t\tboolean useChainNr = false;\n//\t\tboolean useDomainInfo = false;\n//\t\tString range = null;\n//\t\tint chainNr = -1;\n//\n//\n//\t\tStructureName structureName = new StructureName(name);\n//\n//\t\tString pdbId = null;\n//\t\tString chainId = null;\n//\n//\t\tif (name.length() == 4) {\n//\n//\t\t\tpdbId = name;\n//\t\t\tStructure s;\n//\t\t\tif (useMmCif) {\n//\t\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n//\t\t\t} else {\n//\t\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n//\t\t\t}\n//\t\t\treturn s;\n//\t\t} else if (structureName.isScopName()) {\n//\n//\t\t\t// return based on SCOP domain ID\n//\t\t\treturn getStructureFromSCOPDomain(name);\n//\t\t} else if (structureName.isCathID()) {\n//\t\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n//\t\t} else if (name.length() == 6) {\n//\t\t\t// name is PDB.CHAINID style (e.g. 4hhb.A)\n//\n//\t\t\tpdbId = name.substring(0, 4);\n//\t\t\tif (name.substring(4, 5).equals(CHAIN_SPLIT_SYMBOL)) {\n//\t\t\t\tchainId = name.substring(5, 6);\n//\t\t\t} else if (name.substring(4, 5).equals(CHAIN_NR_SYMBOL)) {\n//\n//\t\t\t\tuseChainNr = true;\n//\t\t\t\tchainNr = Integer.parseInt(name.substring(5, 6));\n//\t\t\t}\n//\n//\t\t} else if (name.startsWith(\"file:/\") || name.startsWith(\"http:/\")) {\n//\t\t\t// this is a URL\n//\n//\t\t\tURL url = new URL(name);\n//\t\t\treturn getStructureFromURL(url);\n//\n//\n//\t\t} else if (structureName.isPDPDomain()) {\n//\n//\t\t\t// this is a PDP domain definition\n//\n//\t\t\treturn getPDPStructure(name);\n//\n//\t\t} else if (name.startsWith(BIOL_ASSEMBLY_IDENTIFIER)) {\n//\n//\t\t\treturn getBioAssembly(name);\n//\n//\t\t} else if (name.length() > 6 && !name.startsWith(PDP_DOMAIN_IDENTIFIER)\n//\t\t\t\t&& (name.contains(CHAIN_NR_SYMBOL) || name.contains(UNDERSCORE))\n//\t\t\t\t&& !(name.startsWith(\"file:/\") || name.startsWith(\"http:/\"))\n//\n//\t\t\t\t) {\n//\n//\t\t\t// this is a name + range\n//\n//\t\t\tpdbId = name.substring(0, 4);\n//\t\t\t// this ID has domain split information...\n//\t\t\tuseDomainInfo = true;\n//\t\t\trange = name.substring(5);\n//\n//\t\t}\n//\n//\t\t// System.out.println(\"got: >\" + name + \"< \" + pdbId + \" \" + chainId + \" useChainNr:\" + useChainNr + \" \"\n//\t\t// +chainNr + \" useDomainInfo:\" + useDomainInfo + \" \" + range);\n//\n//\t\tif (pdbId == null) {\n//\n//\t\t\treturn null;\n//\t\t}\n//\n//\t\twhile (checkLoading(pdbId)) {\n//\t\t\t// waiting for loading to be finished...\n//\n//\t\t\ttry {\n//\t\t\t\tThread.sleep(100);\n//\t\t\t} catch (InterruptedException e) {\n//\t\t\t\tlogger.error(e.getMessage());\n//\t\t\t}\n//\n//\t\t}\n//\n//\t\t// long start = System.currentTimeMillis();\n//\n//\t\tStructure s;\n//\t\tif (useMmCif) {\n//\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n//\t\t} else {\n//\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n//\t\t}\n//\n//\t\t// long end = System.currentTimeMillis();\n//\t\t// System.out.println(\"time to load \" + pdbId + \" \" + (end-start) + \"\\t  size :\" +\n//\t\t// StructureTools.getNrAtoms(s) + \"\\t cached: \" + cache.size());\n//\n//\t\tif (chainId == null && chainNr < 0 && range == null) {\n//\t\t\t// we only want the 1st model in this case\n//\t\t\tn = StructureTools.getReducedStructure(s, -1);\n//\t\t} else {\n//\n//\t\t\tif (useChainNr) {\n//\t\t\t\t// System.out.println(\"using ChainNr\");\n//\t\t\t\tn = StructureTools.getReducedStructure(s, chainNr);\n//\t\t\t} else if (useDomainInfo) {\n//\t\t\t\t// System.out.println(\"calling getSubRanges\");\n//\t\t\t\tn = StructureTools.getSubRanges(s, range);\n//\t\t\t} else {\n//\t\t\t\t// System.out.println(\"reducing Chain Id \" + chainId);\n//\t\t\t\tn = StructureTools.getReducedStructure(s, chainId);\n//\t\t\t}\n//\t\t}\n//\n//\n//\n//\t\tn.setName(name);\n//\t\treturn n;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain) throws IOException, StructureException {\n\t\treturn getStructureForDomain(domain, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\treturn getStructureForDomain(domain, scopDatabase, false);\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @param strictLigandHandling\n\t *            If set to false, hetero-atoms are included if and only if they belong to a chain to which the SCOP\n\t *            domain belongs; if set to true, hetero-atoms are included if and only if they are strictly within the\n\t *            definition (residue numbers) of the SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase, boolean strictLigandHandling)\n\t\t\tthrows IOException, StructureException {\n\n\t\tString pdbId = domain.getPdbId();\n\t\tStructure fullStructure = getStructureForPdbId(pdbId);\n\t\tStructure structure = domain.reduce(fullStructure);\n\n\t\t// TODO It would be better to move all of this into the reduce method,\n\t\t// but that would require ligand handling properties in StructureIdentifiers\n\n\t\t// because ligands sometimes occur after TER records in PDB files, we may need to add some ligands back in\n\t\t// specifically, we add a ligand if and only if it occurs within the domain\n\t\tAtomPositionMap map = null;\n\t\tList<ResidueRangeAndLength> rrs = null;\n\t\tif (strictLigandHandling) {\n\t\t\tmap = new AtomPositionMap(StructureTools.getAllAtomArray(fullStructure), AtomPositionMap.ANYTHING_MATCHER);\n\t\t\trrs = ResidueRangeAndLength.parseMultiple(domain.getRanges(), map);\n\t\t}\n\t\tfor (Chain chain : fullStructure.getChains()) {\n\t\t\tif (!structure.hasChain(chain.getChainID())) {\n\t\t\t\tcontinue; // we can't do anything with a chain our domain\n\t\t\t}\n\t\t\t// doesn't contain\n\t\t\tChain newChain = structure.getChainByPDB(chain.getChainID());\n\t\t\tList<Group> ligands = StructureTools.filterLigands(chain.getAtomGroups());\n\t\t\tfor (Group group : ligands) {\n\t\t\t\tboolean shouldContain = true;\n\t\t\t\tif (strictLigandHandling) {\n\t\t\t\t\tshouldContain = false; // whether the ligand occurs within the domain\n\t\t\t\t\tfor (ResidueRange rr : rrs) {\n\t\t\t\t\t\tif (rr.contains(group.getResidueNumber(), map)) {\n\t\t\t\t\t\t\tshouldContain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean alreadyContains = newChain.getAtomGroups().contains(group); // we don't want to add duplicate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ligands\n\t\t\t\tif (shouldContain && !alreadyContains) {\n\t\t\t\t\tnewChain.addGroup(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build a more meaningful description for the new structure\n\t\tStringBuilder header = new StringBuilder();\n\t\theader.append(domain.getClassificationId());\n\t\tif (scopDatabase != null) {\n\t\t\tint sf = domain.getSuperfamilyId();\n\t\t\tScopDescription description = scopDatabase.getScopDescriptionBySunid(sf);\n\t\t\tif (description != null) {\n\t\t\t\theader.append(\" | \");\n\t\t\t\theader.append(description.getDescription());\n\t\t\t}\n\t\t}\n\t\tstructure.getPDBHeader().setDescription(header.toString());\n\n\t\treturn structure;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId) throws IOException, StructureException {\n\t\treturn getStructureForDomain(scopId, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\tScopDomain domain = scopDatabase.getDomainByScopID(scopId);\n\t\treturn getStructureForDomain(domain, scopDatabase);\n\t}\n\n\t/**\n\t * Does the cache automatically download files that are missing from the local installation from the PDB FTP site?\n\t *\n\t * @return flag\n\t * @deprecated Use {@link #getFetchBehavior()}\n\t */\n\t@Deprecated\n\tpublic boolean isAutoFetch() {\n\t\treturn fetchBehavior != FetchBehavior.LOCAL_ONLY;\n\t}\n\n\t/**\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @return the fetchCurrent\n\t * @deprecated Use {@link FileParsingParameters#getObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic boolean isFetchCurrent() {\n\t\treturn getObsoleteBehavior() == ObsoleteBehavior.FETCH_CURRENT;\n\t}\n\n\t/**\n\t * forces the cache to fetch the file if its status is OBSOLETE. This feature has a higher priority than\n\t * {@link #setFetchCurrent(boolean)}.<br>\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @return the fetchFileEvenIfObsolete\n\t * @author Amr AL-Hossary\n\t * @see #fetchCurrent\n\t * @since 3.0.2\n\t * @deprecated Use {@link FileParsingParameters#getObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic boolean isFetchFileEvenIfObsolete() {\n\t\treturn getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE;\n\t}\n\n\n\t/**\n\t * Scop handling was changed in 4.2.0. For behaviour equivalent to\n\t * strictSCOP==true, use {@link ScopDatabase#getDomainByScopID(String)}.\n\t * For strictSCOP==False, create a {@link StructureName} or use\n\t * {@link StructureName#guessScopDomain(String, ScopDatabase)} explicitely.\n\t *\n\t * @return false; ignored\n\t * @deprecated since 4.2\n\t */\n\t@Deprecated\n\tpublic boolean isStrictSCOP() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Send a signal to the cache that the system is shutting down. Notifies underlying SerializableCache instances to\n\t * flush themselves...\n\t */\n\tpublic void notifyShutdown() {\n\t\t// System.out.println(\" AtomCache got notify shutdown..\");\n\t\tif (pdpprovider != null) {\n\t\t\tif (pdpprovider instanceof RemotePDPProvider) {\n\t\t\t\tRemotePDPProvider remotePDP = (RemotePDPProvider) pdpprovider;\n\t\t\t\tremotePDP.flushCache();\n\t\t\t}\n\t\t}\n\n\t\t// todo: use a SCOP implementation that is backed by SerializableCache\n\t\tScopDatabase scopInstallation = ScopFactory.getSCOP();\n\t\tif (scopInstallation != null) {\n\t\t\tif (scopInstallation instanceof CachedRemoteScopInstallation) {\n\t\t\t\tCachedRemoteScopInstallation cacheScop = (CachedRemoteScopInstallation) scopInstallation;\n\t\t\t\tcacheScop.flushCache();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Does the cache automatically download files that are missing from the local installation from the PDB FTP site?\n\t *\n\t * @param autoFetch\n\t *            flag\n\t * @deprecated Use {@link #getFetchBehavior()}\n\t */\n\t@Deprecated\n\tpublic void setAutoFetch(boolean autoFetch) {\n\t\tif(autoFetch) {\n\t\t\tsetFetchBehavior(FetchBehavior.DEFAULT);\n\t\t} else {\n\t\t\tsetFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\t}\n\t}\n\n\t/**\n\t * set the location at which utility data should be cached.\n\t *\n\t * @param cachePath\n\t */\n\tpublic void setCachePath(String cachePath) {\n\t\tthis.cachePath = cachePath;\n\t}\n\n\t/**\n\t * if enabled, the reader searches for the newest possible PDB ID, if not present in he local installation. The\n\t * {@link #setFetchFileEvenIfObsolete(boolean)} function has a higher priority than this function.<br>\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @param fetchCurrent\n\t *            the fetchCurrent to set\n\t * @author Amr AL-Hossary\n\t * @see #setFetchFileEvenIfObsolete(boolean)\n\t * @since 3.0.2\n\t * @deprecated Use {@link FileParsingParameters#setObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic void setFetchCurrent(boolean fetchNewestCurrent) {\n\t\tif(fetchNewestCurrent) {\n\t\t\tsetObsoleteBehavior(ObsoleteBehavior.FETCH_CURRENT);\n\t\t} else {\n\t\t\tif(getObsoleteBehavior() == ObsoleteBehavior.FETCH_CURRENT) {\n\t\t\t\tsetObsoleteBehavior(ObsoleteBehavior.DEFAULT);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * <b>N.B.</b> This feature won't work unless the structure wasn't found & autoFetch is set to <code>true</code>.\n\t *\n\t * @param fetchFileEvenIfObsolete\n\t *            the fetchFileEvenIfObsolete to set\n\t * @deprecated Use {@link FileParsingParameters#setObsoleteBehavior()} instead (4.0.0)\n\t */\n\t@Deprecated\n\tpublic void setFetchFileEvenIfObsolete(boolean fetchFileEvenIfObsolete) {\n\t\tif(fetchFileEvenIfObsolete) {\n\t\t\tsetObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n\t\t} else {\n\t\t\tif(getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE) {\n\t\t\t\tsetObsoleteBehavior(ObsoleteBehavior.DEFAULT);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void setFileParsingParams(FileParsingParameters params) {\n\t\tthis.params = params;\n\t}\n\n\n\t/**\n\t * <b>[Optional]</b> This method changes the behavior when obsolete entries\n\t * are requested. Current behaviors are:\n\t * <ul>\n\t * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n\t *   Throw a {@link StructureException} (the default)\n\t * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n\t *   Load the requested ID from the PDB's obsolete repository\n\t * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n\t *   Load the most recent version of the requested structure\n\t *\n\t * <p>This setting may be silently ignored by implementations which do not have\n\t * access to the server to determine whether an entry is obsolete, such as\n\t * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n\t * returned even this is FETCH_CURRENT if the entry is found locally.\n\t *\n\t * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n\t * @see #setFetchCurrent(boolean)\n\t * @since 4.0.0\n\t */\n\tpublic void setObsoleteBehavior(ObsoleteBehavior behavior) {\n\t\tobsoleteBehavior = behavior;\n\t}\n\n\t/**\n\t * Returns how this instance deals with obsolete entries. Note that this\n\t * setting may be ignored by some implementations or in some situations,\n\t * such as when {@link #isAutoFetch()} is false.\n\t *\n\t * <p>For most implementations, the default value is\n\t * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n\t *\n\t * @return The ObsoleteBehavior\n\t * @since 4.0.0\n\t */\n\tpublic ObsoleteBehavior getObsoleteBehavior() {\n\t\treturn obsoleteBehavior;\n\t}\n\n\t/**\n\t * Get the behavior for fetching files from the server\n\t * @return\n\t */\n\tpublic FetchBehavior getFetchBehavior() {\n\t\treturn fetchBehavior;\n\t}\n\t/**\n\t * Set the behavior for fetching files from the server\n\t * @param fetchBehavior\n\t */\n\tpublic void setFetchBehavior(FetchBehavior fetchBehavior) {\n\t\tthis.fetchBehavior = fetchBehavior;\n\t}\n\n\t/**\n\t * Set the path that is used to cache PDB files.\n\t *\n\t * @param path\n\t *            to a directory\n\t */\n\tpublic void setPath(String path) {\n\t\tthis.path = FileDownloadUtils.expandUserHome(path);\n\t}\n\n\tpublic void setPdpprovider(PDPProvider pdpprovider) {\n\t\tthis.pdpprovider = pdpprovider;\n\t}\n\n\n\t/**\n\t * This method does nothing.\n\t *\n\t * Scop handling was changed in 4.2.0. For behaviour equivalent to\n\t * strictSCOP==true, use {@link ScopDatabase#getDomainByScopID(String)}.\n\t * For strictSCOP==False, create a {@link StructureName} or use\n\t * {@link StructureName#guessScopDomain(String, ScopDatabase)} explicitely.\n\t *\n\t * @param strictSCOP Ignored\n\t * @deprecated Removed in 4.2.0\n\t */\n\t@Deprecated\n\tpublic void setStrictSCOP(boolean ignored) {}\n\n\t/**\n\t * @return the useMmCif\n\t */\n\tpublic boolean isUseMmCif() {\n\t\treturn useMmCif;\n\t}\n\n\t/**\n\t * @param useMmCif\n\t *            the useMmCif to set\n\t */\n\tpublic void setUseMmCif(boolean useMmCif) {\n\t\tthis.useMmCif = useMmCif;\n\n\t\tif ( useMmCif) {\n\t\t\t// get bio assembly from mmcif file\n\n\t\t\tBioUnitDataProviderFactory.setBioUnitDataProvider(MmCifBiolAssemblyProvider.class);\n\n\t\t} else {\n\n\t\t\tBioUnitDataProviderFactory.setBioUnitDataProvider(PDBBioUnitDataProvider.class);\n\n\t\t}\n\t}\n\n\tprivate boolean checkLoading(String name) {\n\t\treturn currentlyLoading.contains(name);\n\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the the {@link CathDatabase}\n\t * at {@link CathFactory#getCathDatabase()}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName) throws IOException, StructureException {\n\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the specified {@link CathDatabase}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName, CathDatabase cathInstall) throws IOException, StructureException {\n\n\t\tCathDomain cathDomain = cathInstall.getDomainByCathId(structureName.getIdentifier());\n\n\t\tStructure s = getStructureForPdbId(cathDomain.getIdentifier());\n\t\tStructure n = cathDomain.reduce(s);\n\n\t\t// add the ligands of the chain...\n\n\t\tChain newChain = n.getChainByPDB(structureName.getChainId());\n\t\tChain origChain = s.getChainByPDB(structureName.getChainId());\n\t\tList<Group> ligands = origChain.getAtomLigands();\n\n\t\tfor (Group g : ligands) {\n\t\t\tif (!newChain.getAtomGroups().contains(g)) {\n\t\t\t\tnewChain.addGroup(g);\n\t\t\t}\n\t\t}\n\n\t\treturn n;\n\t}\n\n\tprotected void flagLoading(String name) {\n\t\tif (!currentlyLoading.contains(name)) {\n\n\t\t\tcurrentlyLoading.add(name);\n\t\t}\n\t}\n\n\tprotected void flagLoadingFinished(String name) {\n\n\t\tcurrentlyLoading.remove(name);\n\t}\n\n\t/**\n\t * Loads a structure directly by PDB ID\n\t * @param pdbId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {\n\t\tif(pdbId == null)\n\t\t\treturn null;\n\t\tif(pdbId.length() != 4) {\n\t\t\tthrow new StructureException(\"Unrecognized PDB ID: \"+pdbId);\n\t\t}\n\t\twhile (checkLoading(pdbId)) {\n\t\t\t// waiting for loading to be finished...\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(e.getMessage());\n\t\t\t}\n\n\t\t}\n\n\t\tStructure s;\n\t\tif (useMmCif) {\n\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n\t\t} else {\n\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n\t\t}\n\t\treturn s;\n\t}\n\n\n\tprotected Structure loadStructureFromCifByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tMMCIFFileReader reader = new MMCIFFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprotected Structure loadStructureFromPdbByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tPDBFileReader reader = new PDBFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.structure.io.MMCIFFileReader;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\n\nimport static org.junit.Assert.*;\n\n\n/**\n * A test for {@link AtomCache}.\n * @author dmyerstu\n * @since 3.0.6\n */\npublic class AtomCacheTest {\n\n\tprivate AtomCache cache;\n\tprivate String previousPDB_DIR;\n\n\t@Before\n\tpublic void setUp() {\n\t\tpreviousPDB_DIR = System.getProperty(UserConfiguration.PDB_DIR, null);\n\t\tcache = new AtomCache();\n\t\tcache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n\t\t// Use a fixed SCOP version for stability\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75B);\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t\tif (previousPDB_DIR != null)\n\t\t\tSystem.setProperty(UserConfiguration.PDB_DIR, previousPDB_DIR);\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with no ligands but an explicit range (not whole-chain).\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain1() throws IOException, StructureException {\n\t\tString ranges = \"A:328-396,B:518-527\";\n\t\tStructure whole = cache.getStructure(\"1h6w\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthA = rrs.get(0).getLength();\n\t\tint expectedLengthB = rrs.get(1).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1h6w.2\");\n\t\tassertEquals(2, structure.getChains().size());\n\t\tChain a = structure.getChainByPDB(\"A\");\n\t\tChain b = structure.getChainByPDB(\"B\");\n\t\tassertEquals(expectedLengthA, a.getAtomGroups().size());\n\t\tassertEquals(expectedLengthB, b.getAtomGroups().size());\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with two zinc ligands that occurs after the TER. The ligands are in chains E and F, so they should not be included in the domain.\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain2() throws IOException, StructureException {\n\t\tString ranges = \"A:,B:\";\n\t\tStructure whole = cache.getStructure(\"1I3O\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthA = rrs.get(0).getLength();\n\t\tint expectedLengthB = rrs.get(1).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1i3o.1\");\n\t\tassertEquals(2, structure.getChains().size());\n\t\tChain a = structure.getChainByPDB(\"A\");\n\t\tChain b = structure.getChainByPDB(\"B\");\n\t\tassertEquals(expectedLengthA, a.getAtomGroups().size());\n\t\tassertEquals(expectedLengthB, b.getAtomGroups().size());\n\t\tList<Group> ligandsA = StructureTools.filterLigands(b.getAtomGroups());\n\t\tassertEquals(0, ligandsA.size());\n\t\tList<Group> ligandsB = StructureTools.filterLigands(b.getAtomGroups());\n\t\tassertEquals(0, ligandsB.size());\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a single-chain domain with two zinc ligands that occurs after the TER.\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain3() throws IOException, StructureException {\n\t\tString ranges = \"E:\";\n\t\tStructure whole = cache.getStructure(\"1I3O\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthE = rrs.get(0).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1i3oe_\");\n\t\tassertEquals(1, structure.getChains().size());\n\t\tChain e = structure.getChainByPDB(\"E\");\n\t\tassertEquals(expectedLengthE, e.getAtomGroups().size());\n\t\tList<Group> ligandsE = StructureTools.filterLigands(e.getAtomGroups());\n\t\tassertEquals(1, ligandsE.size());\n\t}\n\n\t/**\n\t * Test parsing of chain-less ranges (present in SCOP < 1.73)\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testGetStructureForChainlessDomains() throws IOException, StructureException {\n\t\tScopDatabase scop = ScopFactory.getSCOP(ScopFactory.VERSION_1_71); // Uses the range '1-135' without a chain\n\t\tStructure structure = cache.getStructureForDomain(\"d1hcy_1\",scop);\n\t\tassertEquals(1, structure.getChains().size());\n\t\tChain a = structure.getChainByPDB(\"A\");\n\t\tint expectedLengthA = 135+4;\n\t\tassertEquals(expectedLengthA, a.getAtomGroups().size());\n\t\tList<Group> ligandsE = StructureTools.filterLigands(a.getAtomGroups());\n\t\tassertEquals(4, ligandsE.size());\n\n\t}\n\n\t@Test\n\tpublic void testSetPath_withTilde() throws Exception {\n\t\tcache.setPath(\"~\" + File.separator);\n\n\t\tassertEquals(System.getProperty(\"user.home\") + File.separator, cache.getPath());\n\t}\n\n\t@Test\n\tpublic void testNewInstanceWithTilder() throws Exception {\n\t\tAtomCache cache1 = new AtomCache(\"~\" + File.separator);\n\n\t\tassertEquals(System.getProperty(\"user.home\") + File.separator, cache1.getPath());\n\t}\n\n\t@Test\n\tpublic void testFetchBehavior() throws IOException, ParseException {\n\t\t// really more of a LocalPDBDirectory test, but throw it in with AtomCache\n\t\tString pdbId = \"1hh0\"; // A small structure, since we download it multiple times\n\t\tLocalPDBDirectory reader = new MMCIFFileReader(cache.getPath());\n\n\t\t// delete\n\t\treader.deleteStructure(pdbId);\n\t\tassertNull(\"Failed to delete previous version\",reader.getLocalFile(pdbId));\n\n\t\t// LOCAL_ONLY fails\n\t\treader.setFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\tStructure s;\n\t\ttry {\n\t\t\ts = reader.getStructureById(pdbId);\n\t\t\tfail(\"LOCAL_ONLY shouldn't download files\");\n\t\t} catch(IOException e) {\n\t\t\tassertTrue(\"Wrong IOException reason\", e.getMessage().contains(\"configured not to download\"));\n\t\t}\n\n\t\t// delete\n\t\treader.deleteStructure(pdbId);\n\t\tassertNull(\"Failed to delete previous version\",reader.getLocalFile(pdbId));\n\n\t\t// fetch from server\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_FILES);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tFile location = reader.getLocalFile(pdbId);\n\n\t\tlong prerem = LocalPDBDirectory.LAST_REMEDIATION_DATE-1000*60*60*25; // 25 hours before the remediation\n\t\tlocation.setLastModified(prerem);\n\t\tassertEquals(prerem,location.lastModified()); //sanity check\n\n\t\t// force refetching\n\t\treader.setFetchBehavior(FetchBehavior.FORCE_DOWNLOAD);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tlong currMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod > prerem);\n\n\t\t// Now LOCAL_ONLY should work\n\t\treader.setFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\n\t\t// Check remediation\n\t\tlocation.setLastModified(prerem);\n\n\t\t// Shouldn't re-fetch\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_FILES);\n\t\ts = reader.getStructureById(pdbId);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tassertEquals(\"Falsely re-downloaded\", prerem,location.lastModified());\n\n\t\t// Now should re-fetch\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_REMEDIATED);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tcurrMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod > prerem);\n\n\t\t// test FETCH_IF_OUTDATED: change existing file timestamp to 2000 and try refetching (the file is from March 2009)\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"yyyy/MM/dd\", Locale.US);\n\t\tDate d = formatter.parse(\"2000/01/01\");\n\t\tlocation.setLastModified(d.getTime());\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_IF_OUTDATED);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tcurrMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod>d.getTime());\n\n\t\t// try again: should not download\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_IF_OUTDATED);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tcurrMod = location.lastModified();\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertEquals(\"Falsely re-downloaded\", currMod, location.lastModified());\n\n\t}\n\n\t@Test\n\tpublic void testSeqRes() throws StructureException, IOException {\n\t\tString name;\n\t\tStructureIdentifier id;\n\t\tStructure full, reduced;\n\t\tChain chain;\n\t\tList<Group> seqres;\n\n\t\t// normal structure\n\t\tname = \"1hh0\";\n\t\tid = new SubstructureIdentifier(name);\n\t\t\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\t\t\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\n\t\t// single chain\n\t\tname = \"1hh0.A\";\n\t\tid = new SubstructureIdentifier(name);\n\t\t\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\t\t\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\n\t\t// subrange\n\t\tname = \"1hh0.A:10-20\";\n\t\tid = new SubstructureIdentifier(name);\n\t\t\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\t\tassertEquals(\"Wrong SeqNum at first group in full\",1,(int)chain.getAtomGroup(0).getResidueNumber().getSeqNum());\n\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChain(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\t\t\n\t\tassertEquals(\"Wrong SeqNum at first group in reduced\",10,(int)chain.getAtomGroup(0).getResidueNumber().getSeqNum());\n\n\t}\n\t\n}\n","changedTest":"","commitMessage":"Fix #455. Use parsing params for AtomCache\n\nSpecifically, set default alignSeqRes parameter in AtomCache  to true.","test_commitMessage":"","allZero":false}