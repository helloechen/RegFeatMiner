{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/quaternary/QsAlign.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/quaternary/TestQsAlign.java","prod_time":"2016-08-05 20:52:04","test_time":"2016-08-05 20:52:04","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":63,"add_classname_line":0,"add_condition_line":5,"add_field_line":0,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":4,"add_return_line":2,"del_annotation_line":0,"del_call_line":21,"del_classname_line":0,"del_condition_line":7,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"f85ce2cd07a3118590f6ba97eea338247591ca14","test_commitID":"f85ce2cd07a3118590f6ba97eea338247591ca14","isfound":"found test change","originPro":"package org.biojava.nbio.structure.align.quaternary;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClusterer;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.cluster.SubunitExtractor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Quaternary Structure Alignment (QS-Align). The algorithm takes as input two\n * protein structures at the quaternary structure level (multiple interacting\n * chains) and calculates the equivalent cross chains and the optimal\n * superposition of the complexes, together with alignment quality scores.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class QsAlign {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(QsAlign.class);\n\n\tpublic static QsAlignResult align(Structure s1, Structure s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\t\treturn align(\n\t\t\t\tSubunitExtractor.extractSubunits(s1,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()),\n\t\t\t\tSubunitExtractor.extractSubunits(s2,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()), cParams, aParams);\n\t}\n\n\tpublic static QsAlignResult align(List<Subunit> s1, List<Subunit> s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\n\t\tQsAlignResult result = new QsAlignResult(s1, s2);\n\n\t\t// SETP 1: cluster each group of subunits O(N^2*L^2) - intra\n\t\tList<SubunitCluster> c1 = SubunitClusterer.cluster(s1, cParams);\n\t\tList<SubunitCluster> c2 = SubunitClusterer.cluster(s2, cParams);\n\n\t\t// STEP 2: match each subunit cluster between groups O(N^2*L^2) - inter\n\t\tMap<Integer, Integer> clusterMap = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < c1.size(); i++) {\n\t\t\tfor (int j = 0; j < c2.size(); j++) {\n\n\t\t\t\tif (clusterMap.keySet().contains(i))\n\t\t\t\t\tbreak;\n\t\t\t\tif (clusterMap.values().contains(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tswitch (cParams.getClustererMethod()) {\n\n\t\t\t\tcase IDENTITY:\n\t\t\t\t\tif (c1.get(i).mergeIdentical(c2.get(j)))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase SEQUENCE:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (c1.get(i).mergeSequence(c2.get(j),\n\t\t\t\t\t\t\t\tcParams.getSequenceIdentityThreshold(),\n\t\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\tlogger.warn(\"Could compare by Sequence. {}\",\n\t\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // case STRUCTURE:\n\t\t\t\t\tif (c1.get(i).mergeStructure(c2.get(j),\n\t\t\t\t\t\t\tcParams.getRmsdThreshold(),\n\t\t\t\t\t\t\tcParams.getCoverageThreshold()))\n\t\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: Align the assemblies for each cluster match O(L^2*N+N^2*L)\n\t\tfor (int globalKey : clusterMap.keySet()) {\n\n\t\t\t// Obtain the clusters\n\t\t\tSubunitCluster clust1 = c1.get(globalKey);\n\t\t\tSubunitCluster clust2 = c2.get(clusterMap.get(globalKey));\n\n\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\tint index1 = 0;\n\t\t\tint index2 = clust1.size() - clust2.size();\n\n\t\t\tAtom[] atoms1 = clust1.getAlignedAtomsSubunit(index1);\n\t\t\tAtom[] atoms2 = clust1.getAlignedAtomsSubunit(index2);\n\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(atoms1, atoms2);\n\t\t\tMatrix4d trans = svd.getTransformation();\n\n\t\t\t// Map the subunits of each cluster to their spatial equivalents\n\t\t\tMap<Integer, Map<Integer, Integer>> clustSubunitMap = new HashMap<Integer, Map<Integer, Integer>>();\n\n\t\t\tfor (int key : clusterMap.keySet()) {\n\n\t\t\t\t// Obtain the clusters\n\t\t\t\tclust1 = c1.get(key);\n\t\t\t\tclust2 = c2.get(clusterMap.get(key));\n\n\t\t\t\t// Take the cluster match as reference and obtain transformation\n\t\t\t\tindex1 = 0;\n\t\t\t\tindex2 = clust1.size() - clust2.size();\n\n\t\t\t\t// Map the subunits of the cluster to their spatial equivalents\n\t\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\n\t\t\t\tfor (int i = 0; i < index2; i++) {\n\t\t\t\t\tfor (int j = index2; j < clust1.size(); j++) {\n\n\t\t\t\t\t\tif (subunitMap.keySet().contains(i))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (subunitMap.values().contains(j))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// Obtain centroids and transform the second\n\t\t\t\t\t\tAtom centr1 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(i));\n\t\t\t\t\t\tAtom centr2 = Calc.getCentroid(clust1\n\t\t\t\t\t\t\t\t.getAlignedAtomsSubunit(j));\n\t\t\t\t\t\tCalc.transform(centr2, trans);\n\n\t\t\t\t\t\tif (Calc.getDistance(centr1, centr2) < aParams\n\t\t\t\t\t\t\t\t.getdCutoff())\n\t\t\t\t\t\t\tsubunitMap.put(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclustSubunitMap.put(key, subunitMap);\n\t\t\t}\n\n\t\t\t// Unfold the nested map into subunit map and alignment\n\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\t\t\tList<Integer> alignRes1 = new ArrayList<Integer>();\n\t\t\tList<Integer> alignRes2 = new ArrayList<Integer>();\n\t\t\tList<Atom> atomArray1 = new ArrayList<Atom>();\n\t\t\tList<Atom> atomArray2 = new ArrayList<Atom>();\n\n\t\t\tfor (int key : clustSubunitMap.keySet()) {\n\n\t\t\t\t// Obtain the cluster and the alignment in it\n\t\t\t\tSubunitCluster cluster = c1.get(key);\n\t\t\t\tList<List<Integer>> clusterEqrs = cluster\n\t\t\t\t\t\t.getMultipleAlignment().getBlock(0).getAlignRes();\n\n\t\t\t\tfor (Entry<Integer, Integer> pair : clustSubunitMap.get(key)\n\t\t\t\t\t\t.entrySet()) {\n\n\t\t\t\t\tint i = pair.getKey();\n\t\t\t\t\tint j = pair.getValue();\n\n\t\t\t\t\t// Obtain the indices of the original Subunit Lists\n\t\t\t\t\tint orig1 = s1.indexOf(cluster.getSubunits().get(i));\n\t\t\t\t\tint orig2 = s2.indexOf(cluster.getSubunits().get(j));\n\n\t\t\t\t\t// Append rescaled aligned residue indices\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(i))\n\t\t\t\t\t\talignRes1.add(eqr + atomArray1.size());\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(j))\n\t\t\t\t\t\talignRes2.add(eqr + atomArray2.size());\n\n\t\t\t\t\t// Apend atoms to the arrays\n\t\t\t\t\tatomArray1.addAll(Arrays.asList(s1.get(orig1)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\t\t\t\t\tatomArray2.addAll(Arrays.asList(s2.get(orig2)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\n\t\t\t\t\tsubunitMap.put(orig1, orig2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Evaluate the goodness of the match with an alignment object\n\t\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\t\tArrays.asList(new Atom[][] {\n\t\t\t\t\t\t\tatomArray1.toArray(new Atom[atomArray1.size()]),\n\t\t\t\t\t\t\tatomArray2.toArray(new Atom[atomArray2.size()]) }));\n\n\t\t\t// Fill in the alignment information\n\t\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\t\tBlock b = new BlockImpl(bs);\n\t\t\tList<List<Integer>> alignRes = new ArrayList<List<Integer>>(2);\n\t\t\talignRes.add(alignRes1);\n\t\t\talignRes.add(alignRes2);\n\t\t\tb.setAlignRes(alignRes);\n\n\t\t\t// Fill in the transformation matrices\n\t\t\tnew ReferenceSuperimposer().superimpose(msa);\n\n\t\t\t// Calculate some scores\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// If it is the best match found so far store it\n\t\t\tif (subunitMap.size() > result.getSubunitMap().size()) {\n\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\tresult.setAlignment(msa);\n\t\t\t} else if (subunitMap.size() == result.getSubunitMap().size()) {\n\t\t\t\tif (result.getAlignment() == null) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t} else if (msa.getScore(MultipleAlignmentScorer.RMSD) < result\n\t\t\t\t\t\t.getRmsd()) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.align.quaternary;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClusterer;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.cluster.SubunitExtractor;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.biojava.nbio.structure.geometry.UnitQuaternions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Quaternary Structure Alignment (QS-Align). The algorithm takes as input two\n * protein structures at the quaternary structure level (multiple chains or\n * subunits) and calculates the equivalent subunit matching and a residue-based\n * alignment, together with usual alignment quality scores.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class QsAlign {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(QsAlign.class);\n\n\tpublic static QsAlignResult align(Structure s1, Structure s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\t\treturn align(\n\t\t\t\tSubunitExtractor.extractSubunits(s1,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()),\n\t\t\t\tSubunitExtractor.extractSubunits(s2,\n\t\t\t\t\t\tcParams.getAbsoluteMinimumSequenceLength(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLengthFraction(),\n\t\t\t\t\t\tcParams.getMinimumSequenceLength()), cParams, aParams);\n\t}\n\n\tpublic static QsAlignResult align(List<Subunit> s1, List<Subunit> s2,\n\t\t\tSubunitClustererParameters cParams, QsAlignParameters aParams)\n\t\t\tthrows StructureException {\n\n\t\tQsAlignResult result = new QsAlignResult(s1, s2);\n\n\t\t// SETP 1: cluster each group of subunits O(N^2*L^2) - intra\n\t\tList<SubunitCluster> c1 = SubunitClusterer.cluster(s1, cParams);\n\t\tList<SubunitCluster> c2 = SubunitClusterer.cluster(s2, cParams);\n\n\t\t// STEP 2: match each subunit cluster between groups O(N^2*L^2) - inter\n\t\tMap<Integer, Integer> clusterMap = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < c1.size(); i++) {\n\t\t\tfor (int j = 0; j < c2.size(); j++) {\n\n\t\t\t\tif (clusterMap.keySet().contains(i))\n\t\t\t\t\tbreak;\n\t\t\t\tif (clusterMap.values().contains(j))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Use structural alignment to match the subunit clusters\n\t\t\t\tif (c1.get(i).mergeStructure(c2.get(j),\n\t\t\t\t\t\tcParams.getRmsdThreshold(),\n\t\t\t\t\t\tcParams.getCoverageThreshold(), aParams.getAligner()))\n\t\t\t\t\tclusterMap.put(i, j);\n\t\t\t}\n\t\t}\n\n\t\tlogger.info(\"Cluster Map: \" + clusterMap.toString());\n\n\t\t// STEP 3: Align the assemblies for each cluster match O(N^2*L)\n\t\tfor (int globalKey : clusterMap.keySet()) {\n\n\t\t\t// Obtain the clusters\n\t\t\tSubunitCluster clust1 = c1.get(globalKey);\n\t\t\tSubunitCluster clust2 = c2.get(clusterMap.get(globalKey));\n\n\t\t\t// Take a cluster match as reference\n\t\t\tint index1 = 0;\n\t\t\tint index2 = clust1.size() - clust2.size();\n\t\t\tMap<Integer, Integer> subunitMap = new HashMap<Integer, Integer>();\n\t\t\tsubunitMap.put(index1, index2);\n\n\t\t\t// Map cluster id to their subunit matching\n\t\t\tMap<Integer, Map<Integer, Integer>> clustSubunitMap = new HashMap<Integer, Map<Integer, Integer>>();\n\t\t\tclustSubunitMap.put(globalKey, subunitMap);\n\n\t\t\t// Change order of key set so that globalKey is first\n\t\t\tList<Integer> keySet = new ArrayList<Integer>(clusterMap.keySet());\n\t\t\tkeySet.remove((Integer) globalKey);\n\t\t\tkeySet.add(0, globalKey);\n\n\t\t\tfor (int key : clusterMap.keySet()) {\n\n\t\t\t\t// Recover subunitMap if it is the reference, new one otherwise\n\t\t\t\tif (key == globalKey)\n\t\t\t\t\tsubunitMap = clustSubunitMap.get(key);\n\t\t\t\telse\n\t\t\t\t\tsubunitMap = new HashMap<Integer, Integer>();\n\n\t\t\t\t// Obtain the clusters of each subunit group\n\t\t\t\tclust1 = c1.get(key);\n\t\t\t\tclust2 = c2.get(clusterMap.get(key));\n\n\t\t\t\t// Get the initial subunit indices of each group\n\t\t\t\tindex1 = 0;\n\t\t\t\tindex2 = clust1.size() - clust2.size();\n\n\t\t\t\tfor (int i = 0; i < index2; i++) {\n\t\t\t\t\tfor (int j = index2; j < clust1.size(); j++) {\n\n\t\t\t\t\t\tif (subunitMap.keySet().contains(i))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (subunitMap.values().contains(j))\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// Obtain cumulative transformation matrix\n\t\t\t\t\t\tMatrix4d transform = getTransformForClusterSubunitMap(\n\t\t\t\t\t\t\t\tc1, clustSubunitMap);\n\n\t\t\t\t\t\t// Obtain Atom arrays of the subunit pair to match\n\t\t\t\t\t\tAtom[] atoms1 = clust1.getAlignedAtomsSubunit(i);\n\t\t\t\t\t\tAtom[] atoms2 = clust1.getAlignedAtomsSubunit(j);\n\n\t\t\t\t\t\t// Obtain centroids and transform the second\n\t\t\t\t\t\tAtom centr1 = Calc.getCentroid(atoms1);\n\t\t\t\t\t\tAtom centr2 = Calc.getCentroid(atoms2);\n\t\t\t\t\t\tCalc.transform(centr2, transform);\n\n\t\t\t\t\t\t// 1- Check that the distance fulfills maximum\n\t\t\t\t\t\tdouble dCentroid = Calc.getDistance(centr1, centr2);\n\t\t\t\t\t\tif (dCentroid > aParams.getdCutoff()) {\n\t\t\t\t\t\t\tlogger.debug(String.format(\"Subunit matching %d \"\n\t\t\t\t\t\t\t\t\t+ \"vs %d of cluster %d could not be \"\n\t\t\t\t\t\t\t\t\t+ \"matched, because centroid distance is \"\n\t\t\t\t\t\t\t\t\t+ \"%.2f\", index1, index2, key, dCentroid));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Transform coordinates of second\n\t\t\t\t\t\tAtom[] atoms2c = StructureTools.cloneAtomArray(atoms2);\n\t\t\t\t\t\tCalc.transform(atoms2c, transform);\n\n\t\t\t\t\t\t// 2- Check the orientation metric condition\n\t\t\t\t\t\tdouble qOrient = UnitQuaternions.orientationAngle(\n\t\t\t\t\t\t\t\tCalc.atomsToPoints(atoms1),\n\t\t\t\t\t\t\t\tCalc.atomsToPoints(atoms2c));\n\t\t\t\t\t\tqOrient = Math.min(Math.abs(2*Math.PI - qOrient), qOrient);\n\t\t\t\t\t\tif (qOrient > aParams.getMaxOrientationAngle()) {\n\t\t\t\t\t\t\tlogger.debug(String.format(\"Subunit matching %d \"\n\t\t\t\t\t\t\t\t\t+ \"vs %d of cluster %d could not be \"\n\t\t\t\t\t\t\t\t\t+ \"matched, because orientation metric is \"\n\t\t\t\t\t\t\t\t\t+ \"%.2f\", i, j, key, qOrient));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 3- Check the RMSD condition\n\t\t\t\t\t\tdouble rmsd = SVDSuperimposer.getRMS(atoms1, atoms2c);\n\t\t\t\t\t\tif (rmsd > aParams.getMaxRmsd()) {\n\t\t\t\t\t\t\tlogger.debug(String.format(\"Subunit matching %d \"\n\t\t\t\t\t\t\t\t\t+ \"vs %d of cluster %d could not be \"\n\t\t\t\t\t\t\t\t\t+ \"matched, because RMSD is %.2f\", i,\n\t\t\t\t\t\t\t\t\tj, key, rmsd));\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger.info(String.format(\"Subunit matching %d vs %d\"\n\t\t\t\t\t\t\t\t+ \" of cluster %d with centroid distance %.2f\"\n\t\t\t\t\t\t\t\t+ \", orientation metric %.2f and RMSD %.2f\",\n\t\t\t\t\t\t\t\ti, j, key, dCentroid, qOrient, rmsd));\n\n\t\t\t\t\t\tsubunitMap.put(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tclustSubunitMap.put(key, subunitMap);\n\t\t\t}\n\t\t\t\n\t\t\tlogger.info(\"Cluster Subunit Map: \" + clustSubunitMap.toString());\n\n\t\t\t// Unfold the nested map into subunit map and alignment\n\t\t\tsubunitMap = new HashMap<Integer, Integer>();\n\t\t\tList<Integer> alignRes1 = new ArrayList<Integer>();\n\t\t\tList<Integer> alignRes2 = new ArrayList<Integer>();\n\t\t\tList<Atom> atomArray1 = new ArrayList<Atom>();\n\t\t\tList<Atom> atomArray2 = new ArrayList<Atom>();\n\n\t\t\tfor (int key : clustSubunitMap.keySet()) {\n\n\t\t\t\t// Obtain the cluster and the alignment in it\n\t\t\t\tSubunitCluster cluster = c1.get(key);\n\t\t\t\tList<List<Integer>> clusterEqrs = cluster\n\t\t\t\t\t\t.getMultipleAlignment().getBlock(0).getAlignRes();\n\n\t\t\t\tfor (Entry<Integer, Integer> pair : clustSubunitMap.get(key)\n\t\t\t\t\t\t.entrySet()) {\n\n\t\t\t\t\tint i = pair.getKey();\n\t\t\t\t\tint j = pair.getValue();\n\n\t\t\t\t\t// Obtain the indices of the original Subunit Lists\n\t\t\t\t\tint orig1 = s1.indexOf(cluster.getSubunits().get(i));\n\t\t\t\t\tint orig2 = s2.indexOf(cluster.getSubunits().get(j));\n\n\t\t\t\t\t// Append rescaled aligned residue indices\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(i))\n\t\t\t\t\t\talignRes1.add(eqr + atomArray1.size());\n\t\t\t\t\tfor (Integer eqr : clusterEqrs.get(j))\n\t\t\t\t\t\talignRes2.add(eqr + atomArray2.size());\n\n\t\t\t\t\t// Apend atoms to the arrays\n\t\t\t\t\tatomArray1.addAll(Arrays.asList(s1.get(orig1)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\t\t\t\t\tatomArray2.addAll(Arrays.asList(s2.get(orig2)\n\t\t\t\t\t\t\t.getRepresentativeAtoms()));\n\n\t\t\t\t\tsubunitMap.put(orig1, orig2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Evaluate the goodness of the match with an alignment object\n\t\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\t\tArrays.asList(new Atom[][] {\n\t\t\t\t\t\t\tatomArray1.toArray(new Atom[atomArray1.size()]),\n\t\t\t\t\t\t\tatomArray2.toArray(new Atom[atomArray2.size()]) }));\n\n\t\t\t// Fill in the alignment information\n\t\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\t\tBlock b = new BlockImpl(bs);\n\t\t\tList<List<Integer>> alignRes = new ArrayList<List<Integer>>(2);\n\t\t\talignRes.add(alignRes1);\n\t\t\talignRes.add(alignRes2);\n\t\t\tb.setAlignRes(alignRes);\n\n\t\t\t// Fill in the transformation matrices\n\t\t\tnew ReferenceSuperimposer().superimpose(msa);\n\n\t\t\t// Calculate some scores\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// If it is the best match found so far store it\n\t\t\tif (subunitMap.size() > result.getSubunitMap().size()) {\n\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\tresult.setAlignment(msa);\n\t\t\t\tlogger.info(\"Better result found: \" + result.toString());\n\t\t\t} else if (subunitMap.size() == result.getSubunitMap().size()) {\n\t\t\t\tif (result.getAlignment() == null) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t} else if (msa.getScore(MultipleAlignmentScorer.RMSD) < result\n\t\t\t\t\t\t.getRmsd()) {\n\t\t\t\t\tresult.setSubunitMap(subunitMap);\n\t\t\t\t\tresult.setAlignment(msa);\n\t\t\t\t\tlogger.info(\"Better result found: \" + result.toString());\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a pair of Atom arrays corresponding to the alignment of subunit\n\t * matchings, in order of appearance. Superposition of the two Atom sets\n\t * gives the transformation of the complex.\n\t * <p>\n\t * Utility method to cumulative calculate the alignment Atoms.\n\t * \n\t * @param clusters\n\t *            List of SubunitClusters\n\t * @param clusterSubunitMap\n\t *            map from cluster id to subunit matching\n\t * @return pair of atom arrays to be superposed\n\t */\n\tprivate static Pair<Atom[]> getAlignedAtomsForClusterSubunitMap(\n\t\t\tList<SubunitCluster> clusters,\n\t\t\tMap<Integer, Map<Integer, Integer>> clusterSubunitMap) {\n\n\t\tList<Atom> atomArray1 = new ArrayList<Atom>();\n\t\tList<Atom> atomArray2 = new ArrayList<Atom>();\n\n\t\t// For each cluster of subunits\n\t\tfor (int key : clusterSubunitMap.keySet()) {\n\n\t\t\t// Obtain the cluster and the alignment in it\n\t\t\tSubunitCluster cluster = clusters.get(key);\n\n\t\t\t// For each subunit matching in the cluster\n\t\t\tfor (Entry<Integer, Integer> pair : clusterSubunitMap.get(key)\n\t\t\t\t\t.entrySet()) {\n\n\t\t\t\tint i = pair.getKey();\n\t\t\t\tint j = pair.getValue();\n\n\t\t\t\t// Apend atoms to the arrays\n\t\t\t\tatomArray1.addAll(Arrays.asList(cluster\n\t\t\t\t\t\t.getAlignedAtomsSubunit(i)));\n\t\t\t\tatomArray2.addAll(Arrays.asList(cluster\n\t\t\t\t\t\t.getAlignedAtomsSubunit(j)));\n\t\t\t}\n\n\t\t}\n\t\treturn new Pair<Atom[]>(\n\t\t\t\tatomArray1.toArray(new Atom[atomArray1.size()]),\n\t\t\t\tatomArray2.toArray(new Atom[atomArray2.size()]));\n\t}\n\n\t/**\n\t * Returns the transformation matrix corresponding to the alignment of\n\t * subunit matchings.\n\t * <p>\n\t * Utility method to cumulative calculate the alignment transformation.\n\t * \n\t * @param clusters\n\t *            List of SubunitClusters\n\t * @param clusterSubunitMap\n\t *            map from cluster id to subunit matching\n\t * @return transformation matrix\n\t * @throws StructureException\n\t */\n\tprivate static Matrix4d getTransformForClusterSubunitMap(\n\t\t\tList<SubunitCluster> clusters,\n\t\t\tMap<Integer, Map<Integer, Integer>> clusterSubunitMap)\n\t\t\tthrows StructureException {\n\n\t\tPair<Atom[]> pair = getAlignedAtomsForClusterSubunitMap(clusters,\n\t\t\t\tclusterSubunitMap);\n\n\t\tSVDSuperimposer svd = new SVDSuperimposer(pair.getFirst(),\n\t\t\t\tpair.getSecond());\n\t\treturn svd.getTransformation();\n\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.align.quaternary;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.junit.Test;\n\n/**\n * Test the correctness of the {@link QsAlign} algorithm with some examples of\n * different levels of quaternary structure similarity.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestQsAlign {\n\n\t/**\n\t * Identity: test hemoglobin (4HHB) against itself.\n\t */\n\t@Test\n\tpublic void testIdentity() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = s1;\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 4);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertEquals(result.getAlignedSubunits1(), result.getAlignedSubunits2());\n\t\tassertEquals(result.getRmsd(), 0.0, 0.01);\n\n\t}\n\t\n\t/**\n\t * Different: test two completely different proteins (4HHB, 3IFV).\n\t */\n\t@Test\n\tpublic void testDifferent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = StructureIO.getStructure(\"3ifv\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 0);\n\t\tassertEquals(result.getRelation(), QsRelation.DIFFERENT);\n\n\t}\n\n\t/**\n\t * Proliferating cell nuclear antigens (3IFV, 3HI8) are structurally\n\t * equivalent C3 homotrimers.\n\t */\n\t@Test\n\tpublic void testHomoEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"3ifv\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:3hi8:1\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 3);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Phycocyanins (2VML, 2BV8) are equivalent D3 heterododecamers with A6B6\n\t * stoichiometry.\n\t */\n\t@Test\n\tpublic void testHeteroEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"2vml\");\n\t\tStructure s2 = StructureIO.getStructure(\"2bv8\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 12);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n\t/**\n\t * Hydratases (2B3M dimer, 1Q6W hexamer). The C2 dimer is\n\t * triplicated into a D3 assembly.\n\t */\n\t@Test\n\tpublic void testPartialComplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"BIO:2b3m:1\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:1Q6W:7\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 3);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_COMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Cytochrome bc1 complexes (1BCC, 1KB9) have some equivalent Chains and\n\t * some unmatched.\n\t */\n\t@Test\n\tpublic void testPartialIncomplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"1bcc\");\n\t\tStructure s2 = StructureIO.getStructure(\"1kb9\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 8);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_INCOMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.structure.align.quaternary;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.junit.Test;\n\n/**\n * Test the correctness of the {@link QsAlign} algorithm with some examples of\n * different levels of quaternary structure similarity.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestQsAlign {\n\n\t/**\n\t * Identity: test hemoglobin (4HHB) against itself.\n\t */\n\t@Test\n\tpublic void testIdentity() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = s1;\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 4);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertEquals(result.getAlignedSubunits1(), result.getAlignedSubunits2());\n\t\tassertEquals(result.getRmsd(), 0.0, 0.01);\n\n\t}\n\t\n\t/**\n\t * Different: test two completely different proteins (4HHB, 3IFV).\n\t */\n\t@Test\n\tpublic void testDifferent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"4hhb\");\n\t\tStructure s2 = StructureIO.getStructure(\"3ifv\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 0);\n\t\tassertEquals(result.getRelation(), QsRelation.DIFFERENT);\n\n\t}\n\n\t/**\n\t * Proliferating cell nuclear antigens (3IFV, 3HI8) are structurally\n\t * equivalent C3 homotrimers.\n\t */\n\t@Test\n\tpublic void testHomoEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"3ifv\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:3hi8:1\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 3);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Phycocyanins (2VML, 2BV8) are equivalent D3 heterododecamers with A6B6\n\t * stoichiometry.\n\t */\n\t@Test\n\tpublic void testHeteroEquivalent() throws StructureException, IOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"2vml\");\n\t\tStructure s2 = StructureIO.getStructure(\"2bv8\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 12);\n\t\tassertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n\t/**\n\t * Hydratases (2B3M dimer, 1Q6W hexamer). The C2 dimer is\n\t * triplicated into a D3 assembly.\n\t */\n\t@Test\n\tpublic void testPartialComplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"BIO:2b3m:1\");\n\t\tStructure s2 = StructureIO.getStructure(\"BIO:1Q6W:7\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 2);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_COMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\n\t}\n\n\t/**\n\t * Cytochrome bc1 complexes (1BCC, 1KB9) have some equivalent Chains and\n\t * some unmatched.\n\t */\n\t@Test\n\tpublic void testPartialIncomplete() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s1 = StructureIO.getStructure(\"1bcc\");\n\t\tStructure s2 = StructureIO.getStructure(\"1kb9\");\n\n\t\tSubunitClustererParameters clusterParams = new SubunitClustererParameters();\n\t\tQsAlignParameters alignParams = new QsAlignParameters();\n\n\t\tQsAlignResult result = QsAlign\n\t\t\t\t.align(s1, s2, clusterParams, alignParams);\n\n\t\tassertEquals(result.length(), 8);\n\t\tassertEquals(result.getRelation(), QsRelation.PARTIAL_INCOMPLETE);\n\t\tassertTrue(result.getRmsd() < 10.0);\n\t}\n\n}\n","commitMessage":"Introduce comparison by RMSD and orientation angle in QsAlign","test_commitMessage":"Introduce comparison by RMSD and orientation angle in QsAlign","allZero":false}