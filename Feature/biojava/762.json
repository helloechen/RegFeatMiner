{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/utils/SymmetryTools.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/utils/TestSymmetryTools.java","prod_time":"2016-11-08 01:02:24","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"019fa96f630ec5b52572ef4ebed335ca431dcce9","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.utils;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.GroupType;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.helper.AlignTools;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitClustererMethod;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.geometry.SuperPositions;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryDetector;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryParameters;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryResults;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.biojava.nbio.structure.symmetry.internal.SymmetryAxes;\nimport org.jgrapht.UndirectedGraph;\nimport org.jgrapht.graph.DefaultEdge;\nimport org.jgrapht.graph.SimpleGraph;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility methods for symmetry (quaternary and internal) detection and result\n * manipulation.\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @author Peter Rose\n *\n */\npublic class SymmetryTools {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SymmetryTools.class);\n\n\t/** Prevent instantiation. */\n\tprivate SymmetryTools() {\n\t}\n\n\t/**\n\t * Returns the \"reset value\" for graying out the main diagonal. If we're\n\t * blanking out the main diagonal, this value is always Integer.MIN_VALUE.\n\t * <p>\n\t * This is possible if {@code gradientPolyCoeff = Integer.MIN_VALUE} and\n\t * {@code gradientExpCoeff = 0}.\n\t *\n\t * @param unpenalizedScore\n\t * @param nResFromMainDiag\n\t * @param gradientPolyCoeff\n\t * @param gradientExpCoeff\n\t * @return\n\t */\n\tprivate static double getResetVal(double unpenalizedScore,\n\t\t\tdouble nResFromMainDiag, double[] gradientPolyCoeff,\n\t\t\tdouble gradientExpCoeff) {\n\n\t\tif (Double.isNaN(unpenalizedScore))\n\t\t\treturn 0; // what else?\n\n\t\t// We can actually return a positive value if this is high enough\n\t\tdouble updateVal = unpenalizedScore;\n\t\tupdateVal -= gradientExpCoeff * Math.pow(Math.E, -nResFromMainDiag);\n\t\tfor (int p = 0; p < gradientPolyCoeff.length; p++) {\n\t\t\tupdateVal -= gradientPolyCoeff[gradientPolyCoeff.length - 1 - p]\n\t\t\t\t\t* Math.pow(nResFromMainDiag, -p);\n\t\t}\n\t\treturn updateVal;\n\t}\n\n\t/**\n\t * Grays out the main diagonal of a duplicated distance matrix.\n\t *\n\t * @param ca2\n\t * @param rows\n\t *            Number of rows\n\t * @param cols\n\t *            Number of original columns\n\t * @param calculator\n\t *            Used to get the matrix if origM is null\n\t * @param origM\n\t *            starting matrix. If null, uses\n\t *            {@link CECalculator#getMatMatrix()}\n\t * @param blankWindowSize\n\t *            Width of section to gray out\n\t * @param gradientPolyCoeff\n\t * @param gradientExpCoeff\n\t * @return\n\t */\n\tpublic static Matrix grayOutCEOrig(Atom[] ca2, int rows, int cols,\n\t\t\tCECalculator calculator, Matrix origM, int blankWindowSize,\n\t\t\tdouble[] gradientPolyCoeff, double gradientExpCoeff) {\n\n\t\tif (origM == null) {\n\t\t\torigM = new Matrix(calculator.getMatMatrix());\n\t\t}\n\n\t\t// symmetry hack, disable main diagonal\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tint diff = Math.abs(i - j);\n\n\t\t\t\tdouble resetVal = getResetVal(origM.get(i, j), diff,\n\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\t\t\tif (diff < blankWindowSize) {\n\t\t\t\t\torigM.set(i, j, origM.get(i, j) + resetVal);\n\n\t\t\t\t}\n\t\t\t\tint diff2 = Math.abs(i - (j - ca2.length / 2)); // other side\n\n\t\t\t\tdouble resetVal2 = getResetVal(origM.get(i, j), diff2,\n\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\t\t\tif (diff2 < blankWindowSize) {\n\t\t\t\t\torigM.set(i, j, origM.get(i, j) + resetVal2);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn origM;\n\t}\n\n\tpublic static Matrix grayOutPreviousAlignment(AFPChain afpChain,\n\t\t\tAtom[] ca2, int rows, int cols, CECalculator calculator,\n\t\t\tMatrix max, int blankWindowSize, double[] gradientPolyCoeff,\n\t\t\tdouble gradientExpCoeff) {\n\n\t\tmax = grayOutCEOrig(ca2, rows, cols, calculator, max, blankWindowSize,\n\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\tdouble[][] dist1 = calculator.getDist1();\n\t\tdouble[][] dist2 = calculator.getDist2();\n\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// ca2 is circularly permutated\n\t\tint breakPoint = ca2.length / 2;\n\t\tfor (int bk = 0; bk < blockNum; bk++) {\n\n\t\t\tfor (int i = 0; i < optLen[bk]; i++) {\n\t\t\t\tint pos1 = optAln[bk][0][i];\n\t\t\t\tint pos2 = optAln[bk][1][i];\n\n\t\t\t\tint dist = blankWindowSize / 2;\n\t\t\t\tint start1 = Math.max(pos1 - dist, 0);\n\t\t\t\tint start2 = Math.max(pos2 - dist, 0);\n\t\t\t\tint end1 = Math.min(pos1 + dist, rows - 1);\n\t\t\t\tint end2 = Math.min(pos2 + dist, cols - 1);\n\n\t\t\t\tfor (int i1 = start1; i1 < end1; i1++) {\n\n\t\t\t\t\t// blank diagonal of dist1\n\t\t\t\t\tfor (int k = 0; k < blankWindowSize / 2; k++) {\n\t\t\t\t\t\tif (i1 - k >= 0) {\n\t\t\t\t\t\t\tdouble resetVal = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1 - k, i1 - k), 0,\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tdist1[i1 - k][i1 - k] = resetVal;\n\t\t\t\t\t\t} else if (i1 + k < rows) {\n\t\t\t\t\t\t\tdouble resetVal = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1 + k, i1 + k), 0,\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tdist1[i1 + k][i1 + k] = resetVal;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int j2 = start2; j2 < end2; j2++) {\n\t\t\t\t\t\tdouble resetVal = getResetVal(max.get(i1, j2),\n\t\t\t\t\t\t\t\tMath.abs(i1 - j2), gradientPolyCoeff,\n\t\t\t\t\t\t\t\tgradientExpCoeff);\n\t\t\t\t\t\tmax.set(i1, j2, resetVal);\n\t\t\t\t\t\tif (j2 < breakPoint) {\n\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1, j2 + breakPoint),\n\t\t\t\t\t\t\t\t\tMath.abs(i1 - (j2 + breakPoint)),\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tmax.set(i1, j2 + breakPoint, resetVal2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1, j2 - breakPoint),\n\t\t\t\t\t\t\t\t\tMath.abs(i1 - (j2 - breakPoint)),\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tmax.set(i1, j2 - breakPoint, resetVal2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = 0; k < blankWindowSize / 2; k++) {\n\t\t\t\t\t\t\tif (j2 - k >= 0) {\n\t\t\t\t\t\t\t\tif (j2 - k < breakPoint) {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\t\t\tmax.get(j2 - k, j2 - k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 - k][j2 - k] = resetVal2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(max.get(j2\n\t\t\t\t\t\t\t\t\t\t\t- k - breakPoint, j2 - k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 - k - breakPoint][j2 - k\n\t\t\t\t\t\t\t\t\t\t\t- breakPoint] = resetVal2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (j2 + k < cols) {\n\t\t\t\t\t\t\t\tif (j2 + k < breakPoint) {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\t\t\tmax.get(j2 + k, j2 + k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 + k][j2 + k] = resetVal2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(max.get(j2\n\t\t\t\t\t\t\t\t\t\t\t+ k - breakPoint, j2 + k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 + k - breakPoint][j2 + k\n\t\t\t\t\t\t\t\t\t\t\t- breakPoint] = resetVal2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcalculator.setDist1(dist1);\n\t\tcalculator.setDist2(dist2);\n\t\treturn max;\n\n\t}\n\n\tpublic Matrix getDkMatrix(Atom[] ca1, Atom[] ca2, int fragmentLength,\n\t\t\tdouble[] dist1, double[] dist2, int rows, int cols) {\n\n\t\tMatrix diffDistMax = Matrix.identity(ca1.length, ca2.length);\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tdouble score1 = 0;\n\t\t\tfor (int x = 0; x < fragmentLength; x++) {\n\t\t\t\tscore1 += dist1[i + x];\n\t\t\t}\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tdouble score2 = 0;\n\t\t\t\tfor (int y = 0; y < fragmentLength; y++) {\n\t\t\t\t\tscore2 += dist2[j + y];\n\t\t\t\t}\n\n\t\t\t\t// if the intramolecular distances are very similar\n\t\t\t\t// the two scores should be similar,\n\t\t\t\t// i.e. the difference is close to 0\n\t\t\t\tdiffDistMax.set(i, j, Math.abs(score1 - score2));\n\t\t\t}\n\t\t}\n\n\t\t// symmetry hack, disable main diagonal\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tint diff = Math.abs(i - j);\n\n\t\t\t\tif (diff < 15) {\n\t\t\t\t\tdiffDistMax.set(i, j, 99);\n\t\t\t\t}\n\t\t\t\tint diff2 = Math.abs(i - (j - ca2.length / 2));\n\t\t\t\tif (diff2 < 15) {\n\t\t\t\t\tdiffDistMax.set(i, j, 99);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diffDistMax;\n\n\t}\n\n\tpublic static Matrix blankOutPreviousAlignment(AFPChain afpChain,\n\t\t\tAtom[] ca2, int rows, int cols, CECalculator calculator,\n\t\t\tMatrix max, int blankWindowSize) {\n\t\treturn grayOutPreviousAlignment(afpChain, ca2, rows, cols, calculator,\n\t\t\t\tmax, blankWindowSize, new double[] { Integer.MIN_VALUE }, 0.0);\n\t}\n\n\tpublic static Matrix blankOutCEOrig(Atom[] ca2, int rows, int cols,\n\t\t\tCECalculator calculator, Matrix origM, int blankWindowSize) {\n\t\treturn grayOutCEOrig(ca2, rows, cols, calculator, origM,\n\t\t\t\tblankWindowSize, new double[] { Integer.MIN_VALUE }, 0.0);\n\t}\n\n\tpublic static Matrix getDkMatrix(Atom[] ca1, Atom[] ca2, int k,\n\t\t\tint fragmentLength) {\n\n\t\tdouble[] dist1 = AlignTools.getDiagonalAtK(ca1, k);\n\t\tdouble[] dist2 = AlignTools.getDiagonalAtK(ca2, k);\n\n\t\tint rows = ca1.length - fragmentLength - k + 1;\n\t\tint cols = ca2.length - fragmentLength - k + 1;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tMatrix m2 = new Matrix(rows, cols);\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tdouble score1 = 0;\n\t\t\tfor (int x = 0; x < fragmentLength; x++) {\n\t\t\t\tscore1 += dist1[i + x];\n\t\t\t}\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tdouble score2 = 0;\n\t\t\t\tfor (int y = 0; y < fragmentLength; y++) {\n\t\t\t\t\tscore2 += dist2[j + y];\n\t\t\t\t}\n\n\t\t\t\t// if the intramolecular distances are very similar\n\t\t\t\t// the two scores should be similar,\n\t\t\t\t// i.e. the difference is close to 0\n\t\t\t\tm2.set(i, j, Math.abs(score1 - score2));\n\t\t\t}\n\t\t}\n\t\treturn m2;\n\t}\n\n\tpublic static boolean[][] blankOutBreakFlag(AFPChain afpChain, Atom[] ca2,\n\t\t\tint rows, int cols, CECalculator calculator, boolean[][] breakFlag,\n\t\t\tint blankWindowSize) {\n\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// ca2 is circularly permutated at this point.\n\t\tint breakPoint = ca2.length / 2;\n\n\t\tfor (int bk = 0; bk < blockNum; bk++) {\n\n\t\t\t// Matrix m= afpChain.getBlockRotationMatrix()[bk];\n\t\t\t// Atom shift = afpChain.getBlockShiftVector()[bk];\n\t\t\tfor (int i = 0; i < optLen[bk]; i++) {\n\t\t\t\tint pos1 = optAln[bk][0][i];\n\t\t\t\tint pos2 = optAln[bk][1][i];\n\t\t\t\t// blank out area around these positions...\n\n\t\t\t\tint dist = blankWindowSize;\n\t\t\t\tint start1 = Math.max(pos1 - dist, 0);\n\t\t\t\tint start2 = Math.max(pos2 - dist, 0);\n\t\t\t\tint end1 = Math.min(pos1 + dist, rows - 1);\n\t\t\t\tint end2 = Math.min(pos2 + dist, cols - 1);\n\n\t\t\t\tfor (int i1 = start1; i1 < end1; i1++) {\n\n\t\t\t\t\tfor (int j2 = start2; j2 < end2; j2++) {\n\t\t\t\t\t\t// System.out.println(i1 + \" \" + j2 + \" (***)\");\n\t\t\t\t\t\tbreakFlag[i1][j2] = true;\n\t\t\t\t\t\tif (j2 < breakPoint) {\n\t\t\t\t\t\t\tbreakFlag[i1][j2 + breakPoint] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn breakFlag;\n\t}\n\n\t/**\n\t * Returns the <em>magnitude</em> of the angle between the first and second\n\t * blocks of {@code afpChain}, measured in degrees. This is always a\n\t * positive value (unsigned).\n\t *\n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @return\n\t */\n\tpublic static double getAngle(AFPChain afpChain, Atom[] ca1, Atom[] ca2) {\n\t\tMatrix rotation = afpChain.getBlockRotationMatrix()[0];\n\t\treturn Math.acos(rotation.trace() - 1) * 180 / Math.PI;\n\t}\n\n\t/**\n\t * Converts a set of AFP alignments into a Graph of aligned residues, where\n\t * each vertex is a residue and each edge means the connection between the\n\t * two residues in one of the alignments.\n\t *\n\t * @param afps\n\t *            List of AFPChains\n\t * @param atoms\n\t *            Atom array of the symmetric structure\n\t * @param undirected\n\t *            if true, the graph is undirected\n\t *\n\t * @return adjacency List of aligned residues\n\t */\n\tpublic static List<List<Integer>> buildSymmetryGraph(List<AFPChain> afps,\n\t\t\tAtom[] atoms, boolean undirected) {\n\n\t\tList<List<Integer>> graph = new ArrayList<List<Integer>>();\n\n\t\tfor (int n = 0; n < atoms.length; n++) {\n\t\t\tgraph.add(new ArrayList<Integer>());\n\t\t}\n\n\t\tfor (int k = 0; k < afps.size(); k++) {\n\t\t\tfor (int i = 0; i < afps.get(k).getOptAln().length; i++) {\n\t\t\t\tfor (int j = 0; j < afps.get(k).getOptAln()[i][0].length; j++) {\n\t\t\t\t\tInteger res1 = afps.get(k).getOptAln()[i][0][j];\n\t\t\t\t\tInteger res2 = afps.get(k).getOptAln()[i][1][j];\n\t\t\t\t\tgraph.get(res1).add(res2);\n\t\t\t\t\tif (undirected)\n\t\t\t\t\t\tgraph.get(res2).add(res1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Converts a self alignment into a directed jGraphT of aligned residues,\n\t * where each vertex is a residue and each edge means the equivalence\n\t * between the two residues in the self-alignment.\n\t *\n\t * @param selfAlignment\n\t *            AFPChain\n\t *\n\t * @return alignment Graph\n\t */\n\tpublic static UndirectedGraph<Integer, DefaultEdge> buildSymmetryGraph(\n\t\t\tAFPChain selfAlignment) {\n\n\t\tUndirectedGraph<Integer, DefaultEdge> graph = new SimpleGraph<Integer, DefaultEdge>(\n\t\t\t\tDefaultEdge.class);\n\n\t\tfor (int i = 0; i < selfAlignment.getOptAln().length; i++) {\n\t\t\tfor (int j = 0; j < selfAlignment.getOptAln()[i][0].length; j++) {\n\t\t\t\tInteger res1 = selfAlignment.getOptAln()[i][0][j];\n\t\t\t\tInteger res2 = selfAlignment.getOptAln()[i][1][j];\n\t\t\t\tgraph.addVertex(res1);\n\t\t\t\tgraph.addVertex(res2);\n\t\t\t\tgraph.addEdge(res1, res2);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Method that converts the symmetric units of a structure into different\n\t * structures, so that they can be individually visualized.\n\t *\n\t * @param symmetry\n\t *            CeSymmResult\n\t * @throws StructureException\n\t * @result List of structures, by repeat index sequentially\n\t * \n\t */\n\tpublic static List<Structure> divideStructure(CeSymmResult symmetry)\n\t\t\tthrows StructureException {\n\n\t\tif (!symmetry.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tint order = symmetry.getMultipleAlignment().size();\n\t\tAtom[] atoms = symmetry.getAtoms();\n\t\tSet<Group> allGroups = StructureTools.getAllGroupsFromSubset(atoms, GroupType.HETATM);\n\t\tList<StructureIdentifier> repeatsId = symmetry.getRepeatsID();\n\t\tList<Structure> repeats = new ArrayList<Structure>(order);\n\n\t\t// Create new structure containing the repeat atoms\n\t\tfor (int i = 0; i < order; i++) {\n\n\t\t\tStructure s = new StructureImpl();\n\t\t\ts.setStructureIdentifier(repeatsId.get(i));\n\n\t\t\tBlock align = symmetry.getMultipleAlignment().getBlock(0);\n\n\t\t\t// Get the start and end of the repeat\n\t\t\t// Repeats are always sequential blocks\n\t\t\tint res1 = align.getStartResidue(i);\n\t\t\tint res2 = align.getFinalResidue(i);\n\t\t\t\n\t\t\t// All atoms from the repeat, used for ligand search\n\t\t\t// AA have an average of 8.45 atoms, so guess capacity with that\n\t\t\tList<Atom> repeat = new ArrayList<>(Math.max(9*(res2-res1+1),9));\n\t\t\t// speedy chain lookup\n\t\t\tChain prevChain = null;\n\t\t\tfor(int k=res1;k<=res2; k++) {\n\t\t\t\tGroup g = atoms[k].getGroup();\n\t\t\t\tprevChain = StructureTools.addGroupToStructure(s, g, prevChain,true);\n\t\t\t\trepeat.addAll(g.getAtoms());\n\t\t\t}\n\n\t\t\t\n\t\t\tList<Group> ligands = StructureTools.getLigandsByProximity(\n\t\t\t\t\tallGroups,\n\t\t\t\t\trepeat.toArray(new Atom[repeat.size()]),\n\t\t\t\t\tStructureTools.DEFAULT_LIGAND_PROXIMITY_CUTOFF);\n\t\t\t\n\t\t\tlogger.warn(\"Adding {} ligands to {}\",ligands.size(), symmetry.getMultipleAlignment().getStructureIdentifier(i));\n\t\t\tfor( Group ligand : ligands) {\n\t\t\t\tprevChain = StructureTools.addGroupToStructure(s, ligand, prevChain,true);\n\t\t\t}\n\n\t\t\trepeats.add(s);\n\t\t}\n\t\treturn repeats;\n\t}\n\n\t/**\n\t * Method that converts a repeats symmetric alignment into an alignment of\n\t * whole structures.\n\t * <p>\n\t * Example: if the structure has repeats A,B and C, the original alignment\n\t * is A-B-C, and the returned alignment is ABC-BCA-CAB.\n\t *\n\t * @param symm\n\t *            CeSymmResult\n\t * @return MultipleAlignment of the full structure superpositions\n\t */\n\tpublic static MultipleAlignment toFullAlignment(CeSymmResult symm) {\n\n\t\tif (!symm.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tMultipleAlignment full = symm.getMultipleAlignment().clone();\n\n\t\tfor (int str = 1; str < full.size(); str++) {\n\t\t\t// Create a new Block with swapped AlignRes (move first to last)\n\t\t\tBlock b = full.getBlock(full.getBlocks().size() - 1).clone();\n\t\t\tb.getAlignRes().add(b.getAlignRes().get(0));\n\t\t\tb.getAlignRes().remove(0);\n\t\t\tfull.getBlockSet(0).getBlocks().add(b);\n\t\t}\n\t\treturn full;\n\t}\n\n\t/**\n\t * Method that converts a symmetry alignment into an alignment of the\n\t * repeats only, as new independent structures.\n\t * <p>\n\t * This method changes the structure identifiers, the Atom arrays and\n\t * re-scles the aligned residues in the Blocks corresponding to those\n\t * changes.\n\t * <p>\n\t * Application: display superimposed repeats in Jmol.\n\t *\n\t * @param result\n\t *            CeSymmResult of symmetry\n\t * @return MultipleAlignment of the repeats\n\t * @throws StructureException\n\t */\n\tpublic static MultipleAlignment toRepeatsAlignment(CeSymmResult result)\n\t\t\tthrows StructureException {\n\n\t\tif (!result.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tMultipleAlignment msa = result.getMultipleAlignment();\n\t\tMultipleAlignmentEnsemble newEnsemble = msa.getEnsemble().clone();\n\n\t\tList<Structure> repSt = SymmetryTools.divideStructure(result);\n\n\t\tMultipleAlignment repeats = newEnsemble.getMultipleAlignment(0);\n\t\tBlock block = repeats.getBlock(0);\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>();\n\n\t\tfor (Structure s : repSt)\n\t\t\tatomArrays.add(StructureTools.getRepresentativeAtomArray(s));\n\n\t\tnewEnsemble.setAtomArrays(atomArrays);\n\n\t\tfor (int su = 0; su < block.size(); su++) {\n\t\t\tInteger start = block.getStartResidue(su);\n\n\t\t\t// Normalize aligned residues\n\t\t\tfor (int res = 0; res < block.length(); res++) {\n\t\t\t\tInteger residue = block.getAlignRes().get(su).get(res);\n\t\t\t\tif (residue != null)\n\t\t\t\t\tresidue -= start;\n\t\t\t\tblock.getAlignRes().get(su).set(res, residue);\n\t\t\t}\n\t\t}\n\n\t\treturn repeats;\n\t}\n\n\t/**\n\t * Converts a refined symmetry AFPChain alignment into the standard\n\t * representation of symmetry in a MultipleAlignment, that contains the\n\t * entire Atom array of the strcuture and the symmetric repeats are orgaized\n\t * in different rows in a single Block.\n\t *\n\t * @param symm\n\t *            AFPChain created with a symmetry algorithm and refined\n\t * @param atoms\n\t *            Atom array of the entire structure\n\t * @return MultipleAlignment format of the symmetry\n\t * @throws StructureException\n\t */\n\tpublic static MultipleAlignment fromAFP(AFPChain symm, Atom[] atoms)\n\t\t\tthrows StructureException {\n\n\t\tif (!symm.getAlgorithmName().contains(\"symm\")) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The input alignment is not a symmetry alignment.\");\n\t\t}\n\n\t\tMultipleAlignmentEnsemble e = new MultipleAlignmentEnsembleImpl(symm,\n\t\t\t\tatoms, atoms, false);\n\t\te.setAtomArrays(new ArrayList<Atom[]>());\n\t\tStructureIdentifier name = null;\n\t\tif (e.getStructureIdentifiers() != null) {\n\t\t\tif (!e.getStructureIdentifiers().isEmpty())\n\t\t\t\tname = e.getStructureIdentifiers().get(0);\n\t\t} else\n\t\t\tname = atoms[0].getGroup().getChain().getStructure()\n\t\t\t\t\t.getStructureIdentifier();\n\n\t\te.setStructureIdentifiers(new ArrayList<StructureIdentifier>());\n\n\t\tMultipleAlignment result = new MultipleAlignmentImpl();\n\t\tBlockSet bs = new BlockSetImpl(result);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(new ArrayList<List<Integer>>());\n\n\t\tint order = symm.getBlockNum();\n\t\tfor (int su = 0; su < order; su++) {\n\t\t\tList<Integer> residues = e.getMultipleAlignment(0).getBlock(su)\n\t\t\t\t\t.getAlignRes().get(0);\n\t\t\tb.getAlignRes().add(residues);\n\t\t\te.getStructureIdentifiers().add(name);\n\t\t\te.getAtomArrays().add(atoms);\n\t\t}\n\t\te.getMultipleAlignments().set(0, result);\n\t\tresult.setEnsemble(e);\n\n\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\timposer.superimpose(result);\n\t\tupdateSymmetryScores(result);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determines if two symmetry axis are equivalent inside the error\n\t * threshold. It only takes into account the direction of the vector where\n\t * the rotation is made: the angle and translation are not taken into\n\t * account.\n\t *\n\t * @param axis1\n\t * @param axis2\n\t * @param epsilon\n\t *            error allowed in the axis comparison\n\t * @return true if equivalent, false otherwise\n\t */\n\t@Deprecated\n\tpublic static boolean equivalentAxes(Matrix4d axis1, Matrix4d axis2,\n\t\t\tdouble epsilon) {\n\n\t\tAxisAngle4d rot1 = new AxisAngle4d();\n\t\trot1.set(axis1);\n\t\tAxisAngle4d rot2 = new AxisAngle4d();\n\t\trot2.set(axis2);\n\n\t\t// rot1.epsilonEquals(rot2, error); //that also compares angle\n\t\t// L-infinite distance without comparing the angle (epsilonEquals)\n\t\tList<Double> sameDir = new ArrayList<Double>();\n\t\tsameDir.add(Math.abs(rot1.x - rot2.x));\n\t\tsameDir.add(Math.abs(rot1.y - rot2.y));\n\t\tsameDir.add(Math.abs(rot1.z - rot2.z));\n\n\t\tList<Double> otherDir = new ArrayList<Double>();\n\t\totherDir.add(Math.abs(rot1.x + rot2.x));\n\t\totherDir.add(Math.abs(rot1.y + rot2.y));\n\t\totherDir.add(Math.abs(rot1.z + rot2.z));\n\n\t\tDouble error = Math.min(Collections.max(sameDir),\n\t\t\t\tCollections.max(otherDir));\n\n\t\treturn error < epsilon;\n\t}\n\n\t/**\n\t * Given a symmetry result, it calculates the overall global symmetry,\n\t * factoring out the alignment and detection steps of\n\t * {@link QuatSymmetryDetector} algorithm.\n\t *\n\t * @param result\n\t *            symmetry result\n\t * @return global symmetry results\n\t * @throws StructureException\n\t */\n\tpublic static QuatSymmetryResults getQuaternarySymmetry(CeSymmResult result)\n\t\t\tthrows StructureException {\n\n\t\t// Obtain the subunits of the repeats\n\t\tList<Atom[]> atoms = toRepeatsAlignment(result).getAtomArrays();\n\t\tList<Subunit> subunits = atoms.stream()\n\t\t\t\t.map(a -> new Subunit(a, null, null, null))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\t// The clustering thresholds are set to 0 so that all always merged\n\t\tSubunitClustererParameters cp = new SubunitClustererParameters();\n\t\tcp.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n\t\tcp.setRmsdThreshold(10.0);\n\t\tcp.setCoverageThreshold(0.0);\n\t\tcp.setSequenceIdentityThreshold(1.1); // avoid using sequence cluster\n\n\t\tQuatSymmetryParameters sp = new QuatSymmetryParameters();\n\n\t\tQuatSymmetryResults gSymmetry = QuatSymmetryDetector\n\t\t\t\t.calcGlobalSymmetry(subunits, sp, cp);\n\n\t\treturn gSymmetry;\n\t}\n\n\t/**\n\t * Returns true a symmetry multiple alignment has been refined, false\n\t * otherwise.\n\t * <p>\n\t * For a refined alignment only one Block with no repeated residues is\n\t * necessary. Sufficient condition is not tested (only known from the\n\t * algorithm or CeSymmResult).\n\t *\n\t * @param symm\n\t *            the symmetry alignment\n\t * @return true if the alignment is refined\n\t */\n\t@Deprecated\n\tpublic static boolean isRefined(MultipleAlignment symm) {\n\n\t\tif (symm.getBlocks().size() > 1) {\n\t\t\treturn false;\n\t\t} else if (symm.size() < 2)\n\t\t\treturn false;\n\t\telse {\n\t\t\tList<Integer> alreadySeen = new ArrayList<Integer>();\n\t\t\tList<List<Integer>> align = symm.getBlock(0).getAlignRes();\n\t\t\tfor (int str = 0; str < symm.size(); str++) {\n\t\t\t\tfor (int res = 0; res < align.get(str).size(); res++) {\n\t\t\t\t\tInteger residue = align.get(str).get(res);\n\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (alreadySeen.contains(residue)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\talreadySeen.add(residue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // end of all repeats\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the symmetry alignment is significant, false otherwise.\n\t * <p>\n\t * For a symmetry alignment to be significant, the alignment has to be\n\t * refined and the TM-score has to be higher than the threshold.\n\t * <p>\n\t * It is recommended to use the {@link CeSymmResult#isSignificant()} method\n\t * instead.\n\t *\n\t * @param msa\n\t * @param symmetryThreshold\n\t * @return\n\t * @throws StructureException\n\t */\n\t@Deprecated\n\tpublic static boolean isSignificant(MultipleAlignment msa,\n\t\t\tdouble symmetryThreshold) throws StructureException {\n\n\t\t// Order/refinement check\n\t\tif (!SymmetryTools.isRefined(msa))\n\t\t\treturn false;\n\n\t\t// TM-score cutoff\n\t\tdouble tm = 0.0;\n\t\tif (msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE) == null)\n\t\t\ttm = MultipleAlignmentScorer.getAvgTMScore(msa);\n\t\telse\n\t\t\ttm = msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE);\n\n\t\tif (tm < symmetryThreshold)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the List of Groups of the corresponding representative Atom\n\t * array. The representative Atom array needs to fulfill: no two Atoms are\n\t * from the same Group and Groups are sequential (connected in the original\n\t * Structure), except if they are from different Chains.\n\t *\n\t * @param rAtoms\n\t *            array of representative Atoms (CA, P, etc).\n\t * @return List of Groups\n\t */\n\tpublic static List<Group> getGroups(Atom[] rAtoms) {\n\n\t\tList<Group> groups = new ArrayList<Group>(rAtoms.length);\n\n\t\tfor (Atom a : rAtoms) {\n\t\t\tGroup g = a.getGroup();\n\t\t\tif (g != null)\n\t\t\t\tgroups.add(g);\n\t\t\telse\n\t\t\t\tlogger.info(\"Group not found for representative Atom {}\", a);\n\t\t}\n\t\treturn groups;\n\t}\n\n\t/**\n\t * Calculates the set of symmetry operation Matrices (transformations) of\n\t * the new alignment, based on the symmetry relations in the SymmetryAxes\n\t * object. It sets the transformations to the input MultipleAlignment and\n\t * SymmetryAxes objects. If the SymmetryAxes object is null, the\n\t * superposition of the repeats is done without symmetry constraints.\n\t * <p>\n\t * This method also sets the scores (RMSD and TM-score) after the new\n\t * superposition has been updated.\n\t *\n\t * @param axes\n\t *            SymmetryAxes object. It will be modified.\n\t * @param msa\n\t *            MultipleAlignment. It will be modified.\n\t */\n\tpublic static void updateSymmetryTransformation(SymmetryAxes axes,\n\t\t\tMultipleAlignment msa) throws StructureException {\n\n\t\tList<List<Integer>> block = msa.getBlocks().get(0).getAlignRes();\n\t\tint length = block.get(0).size();\n\n\t\tif (axes != null) {\n\t\t\tfor (int level = 0; level < axes.getNumLevels(); level++) {\n\n\t\t\t\t// Calculate the aligned atom arrays to superimpose\n\t\t\t\tList<Atom> list1 = new ArrayList<Atom>();\n\t\t\t\tList<Atom> list2 = new ArrayList<Atom>();\n\n\t\t\t\tfor (int firstRepeat : axes.getFirstRepeats(level)) {\n\n\t\t\t\t\tMatrix4d transform = axes.getRepeatTransform(firstRepeat);\n\n\t\t\t\t\tList<List<Integer>> relation = axes.getRepeatRelation(\n\t\t\t\t\t\t\tlevel, firstRepeat);\n\n\t\t\t\t\tfor (int index = 0; index < relation.get(0).size(); index++) {\n\t\t\t\t\t\tint p1 = relation.get(0).get(index);\n\t\t\t\t\t\tint p2 = relation.get(1).get(index);\n\n\t\t\t\t\t\tfor (int k = 0; k < length; k++) {\n\t\t\t\t\t\t\tInteger pos1 = block.get(p1).get(k);\n\t\t\t\t\t\t\tInteger pos2 = block.get(p2).get(k);\n\t\t\t\t\t\t\tif (pos1 != null && pos2 != null) {\n\t\t\t\t\t\t\t\tAtom a = (Atom) msa.getAtomArrays().get(p1)[pos1]\n\t\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t\t\tAtom b = (Atom) msa.getAtomArrays().get(p2)[pos2]\n\t\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t\t\tCalc.transform(a, transform);\n\t\t\t\t\t\t\t\tCalc.transform(b, transform);\n\t\t\t\t\t\t\t\tlist1.add(a);\n\t\t\t\t\t\t\t\tlist2.add(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tAtom[] arr1 = list1.toArray(new Atom[list1.size()]);\n\t\t\t\tAtom[] arr2 = list2.toArray(new Atom[list2.size()]);\n\n\t\t\t\t// Calculate the new transformation information\n\t\t\t\tif (arr1.length > 0 && arr2.length > 0) {\n\t\t\t\t\tMatrix4d axis = SuperPositions.superpose(\n\t\t\t\t\t\t\tCalc.atomsToPoints(arr1), \n\t\t\t\t\t\t\tCalc.atomsToPoints(arr2));\n\t\t\t\t\taxes.updateAxis(level, axis);\n\t\t\t\t}\n\n\t\t\t\t// Get the transformations from the SymmetryAxes\n\t\t\t\tList<Matrix4d> transformations = new ArrayList<Matrix4d>();\n\t\t\t\tfor (int su = 0; su < msa.size(); su++) {\n\t\t\t\t\ttransformations.add(axes.getRepeatTransform(su));\n\t\t\t\t}\n\t\t\t\tmsa.getBlockSet(0).setTransformations(transformations);\n\t\t\t}\n\t\t} else {\n\t\t\tMultipleSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t}\n\t\tupdateSymmetryScores(msa);\n\t}\n\n\t/**\n\t * Update the scores (TM-score and RMSD) of a symmetry multiple alignment.\n\t * This method does not redo the superposition of the alignment.\n\t *\n\t * @param symm\n\t *            Symmetry Multiple Alignment of Repeats\n\t * @throws StructureException\n\t */\n\tpublic static void updateSymmetryScores(MultipleAlignment symm)\n\t\t\tthrows StructureException {\n\n\t\t// Multiply by the order of symmetry to normalize score\n\t\tdouble tmScore = MultipleAlignmentScorer.getAvgTMScore(symm)\n\t\t\t\t* symm.size();\n\t\tdouble rmsd = MultipleAlignmentScorer.getRMSD(symm);\n\n\t\tsymm.putScore(MultipleAlignmentScorer.AVGTM_SCORE, tmScore);\n\t\tsymm.putScore(MultipleAlignmentScorer.RMSD, rmsd);\n\t}\n\n\t/**\n\t * Returns the representative Atom Array of the first model, if the\n\t * structure is NMR, or the Array for each model, if it is a biological\n\t * assembly with multiple models.\n\t * \n\t * @param structure\n\t * @return representative Atom[]\n\t */\n\tpublic static Atom[] getRepresentativeAtoms(Structure structure) {\n\n\t\tif (structure.isNmr())\n\t\t\treturn StructureTools.getRepresentativeAtomArray(structure);\n\n\t\telse {\n\n\t\t\t// Get Atoms of all models\n\t\t\tList<Atom> atomList = new ArrayList<Atom>();\n\t\t\tfor (int m = 0; m < structure.nrModels(); m++) {\n\t\t\t\tfor (Chain c : structure.getModel(m))\n\t\t\t\t\tatomList.addAll(Arrays.asList(StructureTools\n\t\t\t\t\t\t\t.getRepresentativeAtomArray(c)));\n\t\t\t}\n\t\t\treturn atomList.toArray(new Atom[0]);\n\t\t}\n\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each Subunit cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tif (stoichiometry.isEmpty())\n\t\t\treturn denominators;\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.utils;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.GroupType;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.helper.AlignTools;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleSuperimposer;\nimport org.biojava.nbio.structure.cluster.Subunit;\nimport org.biojava.nbio.structure.cluster.SubunitClustererMethod;\nimport org.biojava.nbio.structure.cluster.SubunitClustererParameters;\nimport org.biojava.nbio.structure.geometry.SuperPositions;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryDetector;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryParameters;\nimport org.biojava.nbio.structure.symmetry.core.QuatSymmetryResults;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.biojava.nbio.structure.symmetry.internal.SymmetryAxes;\nimport org.jgrapht.UndirectedGraph;\nimport org.jgrapht.graph.DefaultEdge;\nimport org.jgrapht.graph.SimpleGraph;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utility methods for symmetry (quaternary and internal) detection and result\n * manipulation.\n *\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @author Peter Rose\n *\n */\npublic class SymmetryTools {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SymmetryTools.class);\n\n\t/** Prevent instantiation. */\n\tprivate SymmetryTools() {\n\t}\n\n\t/**\n\t * Returns the \"reset value\" for graying out the main diagonal. If we're\n\t * blanking out the main diagonal, this value is always Integer.MIN_VALUE.\n\t * <p>\n\t * This is possible if {@code gradientPolyCoeff = Integer.MIN_VALUE} and\n\t * {@code gradientExpCoeff = 0}.\n\t *\n\t * @param unpenalizedScore\n\t * @param nResFromMainDiag\n\t * @param gradientPolyCoeff\n\t * @param gradientExpCoeff\n\t * @return\n\t */\n\tprivate static double getResetVal(double unpenalizedScore,\n\t\t\tdouble nResFromMainDiag, double[] gradientPolyCoeff,\n\t\t\tdouble gradientExpCoeff) {\n\n\t\tif (Double.isNaN(unpenalizedScore))\n\t\t\treturn 0; // what else?\n\n\t\t// We can actually return a positive value if this is high enough\n\t\tdouble updateVal = unpenalizedScore;\n\t\tupdateVal -= gradientExpCoeff * Math.pow(Math.E, -nResFromMainDiag);\n\t\tfor (int p = 0; p < gradientPolyCoeff.length; p++) {\n\t\t\tupdateVal -= gradientPolyCoeff[gradientPolyCoeff.length - 1 - p]\n\t\t\t\t\t* Math.pow(nResFromMainDiag, -p);\n\t\t}\n\t\treturn updateVal;\n\t}\n\n\t/**\n\t * Grays out the main diagonal of a duplicated distance matrix.\n\t *\n\t * @param ca2\n\t * @param rows\n\t *            Number of rows\n\t * @param cols\n\t *            Number of original columns\n\t * @param calculator\n\t *            Used to get the matrix if origM is null\n\t * @param origM\n\t *            starting matrix. If null, uses\n\t *            {@link CECalculator#getMatMatrix()}\n\t * @param blankWindowSize\n\t *            Width of section to gray out\n\t * @param gradientPolyCoeff\n\t * @param gradientExpCoeff\n\t * @return\n\t */\n\tpublic static Matrix grayOutCEOrig(Atom[] ca2, int rows, int cols,\n\t\t\tCECalculator calculator, Matrix origM, int blankWindowSize,\n\t\t\tdouble[] gradientPolyCoeff, double gradientExpCoeff) {\n\n\t\tif (origM == null) {\n\t\t\torigM = new Matrix(calculator.getMatMatrix());\n\t\t}\n\n\t\t// symmetry hack, disable main diagonal\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tint diff = Math.abs(i - j);\n\n\t\t\t\tdouble resetVal = getResetVal(origM.get(i, j), diff,\n\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\t\t\tif (diff < blankWindowSize) {\n\t\t\t\t\torigM.set(i, j, origM.get(i, j) + resetVal);\n\n\t\t\t\t}\n\t\t\t\tint diff2 = Math.abs(i - (j - ca2.length / 2)); // other side\n\n\t\t\t\tdouble resetVal2 = getResetVal(origM.get(i, j), diff2,\n\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\t\t\tif (diff2 < blankWindowSize) {\n\t\t\t\t\torigM.set(i, j, origM.get(i, j) + resetVal2);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn origM;\n\t}\n\n\tpublic static Matrix grayOutPreviousAlignment(AFPChain afpChain,\n\t\t\tAtom[] ca2, int rows, int cols, CECalculator calculator,\n\t\t\tMatrix max, int blankWindowSize, double[] gradientPolyCoeff,\n\t\t\tdouble gradientExpCoeff) {\n\n\t\tmax = grayOutCEOrig(ca2, rows, cols, calculator, max, blankWindowSize,\n\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\n\t\tdouble[][] dist1 = calculator.getDist1();\n\t\tdouble[][] dist2 = calculator.getDist2();\n\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// ca2 is circularly permutated\n\t\tint breakPoint = ca2.length / 2;\n\t\tfor (int bk = 0; bk < blockNum; bk++) {\n\n\t\t\tfor (int i = 0; i < optLen[bk]; i++) {\n\t\t\t\tint pos1 = optAln[bk][0][i];\n\t\t\t\tint pos2 = optAln[bk][1][i];\n\n\t\t\t\tint dist = blankWindowSize / 2;\n\t\t\t\tint start1 = Math.max(pos1 - dist, 0);\n\t\t\t\tint start2 = Math.max(pos2 - dist, 0);\n\t\t\t\tint end1 = Math.min(pos1 + dist, rows - 1);\n\t\t\t\tint end2 = Math.min(pos2 + dist, cols - 1);\n\n\t\t\t\tfor (int i1 = start1; i1 < end1; i1++) {\n\n\t\t\t\t\t// blank diagonal of dist1\n\t\t\t\t\tfor (int k = 0; k < blankWindowSize / 2; k++) {\n\t\t\t\t\t\tif (i1 - k >= 0) {\n\t\t\t\t\t\t\tdouble resetVal = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1 - k, i1 - k), 0,\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tdist1[i1 - k][i1 - k] = resetVal;\n\t\t\t\t\t\t} else if (i1 + k < rows) {\n\t\t\t\t\t\t\tdouble resetVal = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1 + k, i1 + k), 0,\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tdist1[i1 + k][i1 + k] = resetVal;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int j2 = start2; j2 < end2; j2++) {\n\t\t\t\t\t\tdouble resetVal = getResetVal(max.get(i1, j2),\n\t\t\t\t\t\t\t\tMath.abs(i1 - j2), gradientPolyCoeff,\n\t\t\t\t\t\t\t\tgradientExpCoeff);\n\t\t\t\t\t\tmax.set(i1, j2, resetVal);\n\t\t\t\t\t\tif (j2 < breakPoint) {\n\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1, j2 + breakPoint),\n\t\t\t\t\t\t\t\t\tMath.abs(i1 - (j2 + breakPoint)),\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tmax.set(i1, j2 + breakPoint, resetVal2);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\tmax.get(i1, j2 - breakPoint),\n\t\t\t\t\t\t\t\t\tMath.abs(i1 - (j2 - breakPoint)),\n\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\tmax.set(i1, j2 - breakPoint, resetVal2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int k = 0; k < blankWindowSize / 2; k++) {\n\t\t\t\t\t\t\tif (j2 - k >= 0) {\n\t\t\t\t\t\t\t\tif (j2 - k < breakPoint) {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\t\t\tmax.get(j2 - k, j2 - k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 - k][j2 - k] = resetVal2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(max.get(j2\n\t\t\t\t\t\t\t\t\t\t\t- k - breakPoint, j2 - k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 - k - breakPoint][j2 - k\n\t\t\t\t\t\t\t\t\t\t\t- breakPoint] = resetVal2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (j2 + k < cols) {\n\t\t\t\t\t\t\t\tif (j2 + k < breakPoint) {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(\n\t\t\t\t\t\t\t\t\t\t\tmax.get(j2 + k, j2 + k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 + k][j2 + k] = resetVal2;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdouble resetVal2 = getResetVal(max.get(j2\n\t\t\t\t\t\t\t\t\t\t\t+ k - breakPoint, j2 + k), 0,\n\t\t\t\t\t\t\t\t\t\t\tgradientPolyCoeff, gradientExpCoeff);\n\t\t\t\t\t\t\t\t\tdist2[j2 + k - breakPoint][j2 + k\n\t\t\t\t\t\t\t\t\t\t\t- breakPoint] = resetVal2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcalculator.setDist1(dist1);\n\t\tcalculator.setDist2(dist2);\n\t\treturn max;\n\n\t}\n\n\tpublic Matrix getDkMatrix(Atom[] ca1, Atom[] ca2, int fragmentLength,\n\t\t\tdouble[] dist1, double[] dist2, int rows, int cols) {\n\n\t\tMatrix diffDistMax = Matrix.identity(ca1.length, ca2.length);\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tdouble score1 = 0;\n\t\t\tfor (int x = 0; x < fragmentLength; x++) {\n\t\t\t\tscore1 += dist1[i + x];\n\t\t\t}\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tdouble score2 = 0;\n\t\t\t\tfor (int y = 0; y < fragmentLength; y++) {\n\t\t\t\t\tscore2 += dist2[j + y];\n\t\t\t\t}\n\n\t\t\t\t// if the intramolecular distances are very similar\n\t\t\t\t// the two scores should be similar,\n\t\t\t\t// i.e. the difference is close to 0\n\t\t\t\tdiffDistMax.set(i, j, Math.abs(score1 - score2));\n\t\t\t}\n\t\t}\n\n\t\t// symmetry hack, disable main diagonal\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tint diff = Math.abs(i - j);\n\n\t\t\t\tif (diff < 15) {\n\t\t\t\t\tdiffDistMax.set(i, j, 99);\n\t\t\t\t}\n\t\t\t\tint diff2 = Math.abs(i - (j - ca2.length / 2));\n\t\t\t\tif (diff2 < 15) {\n\t\t\t\t\tdiffDistMax.set(i, j, 99);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diffDistMax;\n\n\t}\n\n\tpublic static Matrix blankOutPreviousAlignment(AFPChain afpChain,\n\t\t\tAtom[] ca2, int rows, int cols, CECalculator calculator,\n\t\t\tMatrix max, int blankWindowSize) {\n\t\treturn grayOutPreviousAlignment(afpChain, ca2, rows, cols, calculator,\n\t\t\t\tmax, blankWindowSize, new double[] { Integer.MIN_VALUE }, 0.0);\n\t}\n\n\tpublic static Matrix blankOutCEOrig(Atom[] ca2, int rows, int cols,\n\t\t\tCECalculator calculator, Matrix origM, int blankWindowSize) {\n\t\treturn grayOutCEOrig(ca2, rows, cols, calculator, origM,\n\t\t\t\tblankWindowSize, new double[] { Integer.MIN_VALUE }, 0.0);\n\t}\n\n\tpublic static Matrix getDkMatrix(Atom[] ca1, Atom[] ca2, int k,\n\t\t\tint fragmentLength) {\n\n\t\tdouble[] dist1 = AlignTools.getDiagonalAtK(ca1, k);\n\t\tdouble[] dist2 = AlignTools.getDiagonalAtK(ca2, k);\n\n\t\tint rows = ca1.length - fragmentLength - k + 1;\n\t\tint cols = ca2.length - fragmentLength - k + 1;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tMatrix m2 = new Matrix(rows, cols);\n\n\t\tfor (int i = 0; i < rows; i++) {\n\t\t\tdouble score1 = 0;\n\t\t\tfor (int x = 0; x < fragmentLength; x++) {\n\t\t\t\tscore1 += dist1[i + x];\n\t\t\t}\n\t\t\tfor (int j = 0; j < cols; j++) {\n\t\t\t\tdouble score2 = 0;\n\t\t\t\tfor (int y = 0; y < fragmentLength; y++) {\n\t\t\t\t\tscore2 += dist2[j + y];\n\t\t\t\t}\n\n\t\t\t\t// if the intramolecular distances are very similar\n\t\t\t\t// the two scores should be similar,\n\t\t\t\t// i.e. the difference is close to 0\n\t\t\t\tm2.set(i, j, Math.abs(score1 - score2));\n\t\t\t}\n\t\t}\n\t\treturn m2;\n\t}\n\n\tpublic static boolean[][] blankOutBreakFlag(AFPChain afpChain, Atom[] ca2,\n\t\t\tint rows, int cols, CECalculator calculator, boolean[][] breakFlag,\n\t\t\tint blankWindowSize) {\n\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint blockNum = afpChain.getBlockNum();\n\n\t\tint[] optLen = afpChain.getOptLen();\n\n\t\t// ca2 is circularly permutated at this point.\n\t\tint breakPoint = ca2.length / 2;\n\n\t\tfor (int bk = 0; bk < blockNum; bk++) {\n\n\t\t\t// Matrix m= afpChain.getBlockRotationMatrix()[bk];\n\t\t\t// Atom shift = afpChain.getBlockShiftVector()[bk];\n\t\t\tfor (int i = 0; i < optLen[bk]; i++) {\n\t\t\t\tint pos1 = optAln[bk][0][i];\n\t\t\t\tint pos2 = optAln[bk][1][i];\n\t\t\t\t// blank out area around these positions...\n\n\t\t\t\tint dist = blankWindowSize;\n\t\t\t\tint start1 = Math.max(pos1 - dist, 0);\n\t\t\t\tint start2 = Math.max(pos2 - dist, 0);\n\t\t\t\tint end1 = Math.min(pos1 + dist, rows - 1);\n\t\t\t\tint end2 = Math.min(pos2 + dist, cols - 1);\n\n\t\t\t\tfor (int i1 = start1; i1 < end1; i1++) {\n\n\t\t\t\t\tfor (int j2 = start2; j2 < end2; j2++) {\n\t\t\t\t\t\t// System.out.println(i1 + \" \" + j2 + \" (***)\");\n\t\t\t\t\t\tbreakFlag[i1][j2] = true;\n\t\t\t\t\t\tif (j2 < breakPoint) {\n\t\t\t\t\t\t\tbreakFlag[i1][j2 + breakPoint] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn breakFlag;\n\t}\n\n\t/**\n\t * Returns the <em>magnitude</em> of the angle between the first and second\n\t * blocks of {@code afpChain}, measured in degrees. This is always a\n\t * positive value (unsigned).\n\t *\n\t * @param afpChain\n\t * @param ca1\n\t * @param ca2\n\t * @return\n\t */\n\tpublic static double getAngle(AFPChain afpChain, Atom[] ca1, Atom[] ca2) {\n\t\tMatrix rotation = afpChain.getBlockRotationMatrix()[0];\n\t\treturn Math.acos(rotation.trace() - 1) * 180 / Math.PI;\n\t}\n\n\t/**\n\t * Converts a set of AFP alignments into a Graph of aligned residues, where\n\t * each vertex is a residue and each edge means the connection between the\n\t * two residues in one of the alignments.\n\t *\n\t * @param afps\n\t *            List of AFPChains\n\t * @param atoms\n\t *            Atom array of the symmetric structure\n\t * @param undirected\n\t *            if true, the graph is undirected\n\t *\n\t * @return adjacency List of aligned residues\n\t */\n\tpublic static List<List<Integer>> buildSymmetryGraph(List<AFPChain> afps,\n\t\t\tAtom[] atoms, boolean undirected) {\n\n\t\tList<List<Integer>> graph = new ArrayList<List<Integer>>();\n\n\t\tfor (int n = 0; n < atoms.length; n++) {\n\t\t\tgraph.add(new ArrayList<Integer>());\n\t\t}\n\n\t\tfor (int k = 0; k < afps.size(); k++) {\n\t\t\tfor (int i = 0; i < afps.get(k).getOptAln().length; i++) {\n\t\t\t\tfor (int j = 0; j < afps.get(k).getOptAln()[i][0].length; j++) {\n\t\t\t\t\tInteger res1 = afps.get(k).getOptAln()[i][0][j];\n\t\t\t\t\tInteger res2 = afps.get(k).getOptAln()[i][1][j];\n\t\t\t\t\tgraph.get(res1).add(res2);\n\t\t\t\t\tif (undirected)\n\t\t\t\t\t\tgraph.get(res2).add(res1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Converts a self alignment into a directed jGraphT of aligned residues,\n\t * where each vertex is a residue and each edge means the equivalence\n\t * between the two residues in the self-alignment.\n\t *\n\t * @param selfAlignment\n\t *            AFPChain\n\t *\n\t * @return alignment Graph\n\t */\n\tpublic static UndirectedGraph<Integer, DefaultEdge> buildSymmetryGraph(\n\t\t\tAFPChain selfAlignment) {\n\n\t\tUndirectedGraph<Integer, DefaultEdge> graph = new SimpleGraph<Integer, DefaultEdge>(\n\t\t\t\tDefaultEdge.class);\n\n\t\tfor (int i = 0; i < selfAlignment.getOptAln().length; i++) {\n\t\t\tfor (int j = 0; j < selfAlignment.getOptAln()[i][0].length; j++) {\n\t\t\t\tInteger res1 = selfAlignment.getOptAln()[i][0][j];\n\t\t\t\tInteger res2 = selfAlignment.getOptAln()[i][1][j];\n\t\t\t\tgraph.addVertex(res1);\n\t\t\t\tgraph.addVertex(res2);\n\t\t\t\tgraph.addEdge(res1, res2);\n\t\t\t}\n\t\t}\n\t\treturn graph;\n\t}\n\n\t/**\n\t * Method that converts the symmetric units of a structure into different\n\t * structures, so that they can be individually visualized.\n\t *\n\t * @param symmetry\n\t *            CeSymmResult\n\t * @throws StructureException\n\t * @result List of structures, by repeat index sequentially\n\t * \n\t */\n\tpublic static List<Structure> divideStructure(CeSymmResult symmetry)\n\t\t\tthrows StructureException {\n\n\t\tif (!symmetry.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tint order = symmetry.getMultipleAlignment().size();\n\t\tAtom[] atoms = symmetry.getAtoms();\n\t\tSet<Group> allGroups = StructureTools.getAllGroupsFromSubset(atoms, GroupType.HETATM);\n\t\tList<StructureIdentifier> repeatsId = symmetry.getRepeatsID();\n\t\tList<Structure> repeats = new ArrayList<Structure>(order);\n\n\t\t// Create new structure containing the repeat atoms\n\t\tfor (int i = 0; i < order; i++) {\n\n\t\t\tStructure s = new StructureImpl();\n\t\t\ts.setStructureIdentifier(repeatsId.get(i));\n\n\t\t\tBlock align = symmetry.getMultipleAlignment().getBlock(0);\n\n\t\t\t// Get the start and end of the repeat\n\t\t\t// Repeats are always sequential blocks\n\t\t\tint res1 = align.getStartResidue(i);\n\t\t\tint res2 = align.getFinalResidue(i);\n\t\t\t\n\t\t\t// All atoms from the repeat, used for ligand search\n\t\t\t// AA have an average of 8.45 atoms, so guess capacity with that\n\t\t\tList<Atom> repeat = new ArrayList<>(Math.max(9*(res2-res1+1),9));\n\t\t\t// speedy chain lookup\n\t\t\tChain prevChain = null;\n\t\t\tfor(int k=res1;k<=res2; k++) {\n\t\t\t\tGroup g = atoms[k].getGroup();\n\t\t\t\tprevChain = StructureTools.addGroupToStructure(s, g, 0, prevChain,true);\n\t\t\t\trepeat.addAll(g.getAtoms());\n\t\t\t}\n\n\t\t\t\n\t\t\tList<Group> ligands = StructureTools.getLigandsByProximity(\n\t\t\t\t\tallGroups,\n\t\t\t\t\trepeat.toArray(new Atom[repeat.size()]),\n\t\t\t\t\tStructureTools.DEFAULT_LIGAND_PROXIMITY_CUTOFF);\n\t\t\t\n\t\t\tlogger.warn(\"Adding {} ligands to {}\",ligands.size(), symmetry.getMultipleAlignment().getStructureIdentifier(i));\n\t\t\tfor( Group ligand : ligands) {\n\t\t\t\tprevChain = StructureTools.addGroupToStructure(s, ligand, 0, prevChain,true);\n\t\t\t}\n\n\t\t\trepeats.add(s);\n\t\t}\n\t\treturn repeats;\n\t}\n\n\t/**\n\t * Method that converts a repeats symmetric alignment into an alignment of\n\t * whole structures.\n\t * <p>\n\t * Example: if the structure has repeats A,B and C, the original alignment\n\t * is A-B-C, and the returned alignment is ABC-BCA-CAB.\n\t *\n\t * @param symm\n\t *            CeSymmResult\n\t * @return MultipleAlignment of the full structure superpositions\n\t */\n\tpublic static MultipleAlignment toFullAlignment(CeSymmResult symm) {\n\n\t\tif (!symm.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tMultipleAlignment full = symm.getMultipleAlignment().clone();\n\n\t\tfor (int str = 1; str < full.size(); str++) {\n\t\t\t// Create a new Block with swapped AlignRes (move first to last)\n\t\t\tBlock b = full.getBlock(full.getBlocks().size() - 1).clone();\n\t\t\tb.getAlignRes().add(b.getAlignRes().get(0));\n\t\t\tb.getAlignRes().remove(0);\n\t\t\tfull.getBlockSet(0).getBlocks().add(b);\n\t\t}\n\t\treturn full;\n\t}\n\n\t/**\n\t * Method that converts a symmetry alignment into an alignment of the\n\t * repeats only, as new independent structures.\n\t * <p>\n\t * This method changes the structure identifiers, the Atom arrays and\n\t * re-scles the aligned residues in the Blocks corresponding to those\n\t * changes.\n\t * <p>\n\t * Application: display superimposed repeats in Jmol.\n\t *\n\t * @param result\n\t *            CeSymmResult of symmetry\n\t * @return MultipleAlignment of the repeats\n\t * @throws StructureException\n\t */\n\tpublic static MultipleAlignment toRepeatsAlignment(CeSymmResult result)\n\t\t\tthrows StructureException {\n\n\t\tif (!result.isRefined())\n\t\t\tthrow new IllegalArgumentException(\"The symmetry result \"\n\t\t\t\t\t+ \"is not refined, repeats cannot be defined\");\n\n\t\tMultipleAlignment msa = result.getMultipleAlignment();\n\t\tMultipleAlignmentEnsemble newEnsemble = msa.getEnsemble().clone();\n\n\t\tList<Structure> repSt = SymmetryTools.divideStructure(result);\n\n\t\tMultipleAlignment repeats = newEnsemble.getMultipleAlignment(0);\n\t\tBlock block = repeats.getBlock(0);\n\t\tList<Atom[]> atomArrays = new ArrayList<Atom[]>();\n\n\t\tfor (Structure s : repSt)\n\t\t\tatomArrays.add(StructureTools.getRepresentativeAtomArray(s));\n\n\t\tnewEnsemble.setAtomArrays(atomArrays);\n\n\t\tfor (int su = 0; su < block.size(); su++) {\n\t\t\tInteger start = block.getStartResidue(su);\n\n\t\t\t// Normalize aligned residues\n\t\t\tfor (int res = 0; res < block.length(); res++) {\n\t\t\t\tInteger residue = block.getAlignRes().get(su).get(res);\n\t\t\t\tif (residue != null)\n\t\t\t\t\tresidue -= start;\n\t\t\t\tblock.getAlignRes().get(su).set(res, residue);\n\t\t\t}\n\t\t}\n\n\t\treturn repeats;\n\t}\n\n\t/**\n\t * Converts a refined symmetry AFPChain alignment into the standard\n\t * representation of symmetry in a MultipleAlignment, that contains the\n\t * entire Atom array of the strcuture and the symmetric repeats are orgaized\n\t * in different rows in a single Block.\n\t *\n\t * @param symm\n\t *            AFPChain created with a symmetry algorithm and refined\n\t * @param atoms\n\t *            Atom array of the entire structure\n\t * @return MultipleAlignment format of the symmetry\n\t * @throws StructureException\n\t */\n\tpublic static MultipleAlignment fromAFP(AFPChain symm, Atom[] atoms)\n\t\t\tthrows StructureException {\n\n\t\tif (!symm.getAlgorithmName().contains(\"symm\")) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The input alignment is not a symmetry alignment.\");\n\t\t}\n\n\t\tMultipleAlignmentEnsemble e = new MultipleAlignmentEnsembleImpl(symm,\n\t\t\t\tatoms, atoms, false);\n\t\te.setAtomArrays(new ArrayList<Atom[]>());\n\t\tStructureIdentifier name = null;\n\t\tif (e.getStructureIdentifiers() != null) {\n\t\t\tif (!e.getStructureIdentifiers().isEmpty())\n\t\t\t\tname = e.getStructureIdentifiers().get(0);\n\t\t} else\n\t\t\tname = atoms[0].getGroup().getChain().getStructure()\n\t\t\t\t\t.getStructureIdentifier();\n\n\t\te.setStructureIdentifiers(new ArrayList<StructureIdentifier>());\n\n\t\tMultipleAlignment result = new MultipleAlignmentImpl();\n\t\tBlockSet bs = new BlockSetImpl(result);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(new ArrayList<List<Integer>>());\n\n\t\tint order = symm.getBlockNum();\n\t\tfor (int su = 0; su < order; su++) {\n\t\t\tList<Integer> residues = e.getMultipleAlignment(0).getBlock(su)\n\t\t\t\t\t.getAlignRes().get(0);\n\t\t\tb.getAlignRes().add(residues);\n\t\t\te.getStructureIdentifiers().add(name);\n\t\t\te.getAtomArrays().add(atoms);\n\t\t}\n\t\te.getMultipleAlignments().set(0, result);\n\t\tresult.setEnsemble(e);\n\n\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\timposer.superimpose(result);\n\t\tupdateSymmetryScores(result);\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Determines if two symmetry axis are equivalent inside the error\n\t * threshold. It only takes into account the direction of the vector where\n\t * the rotation is made: the angle and translation are not taken into\n\t * account.\n\t *\n\t * @param axis1\n\t * @param axis2\n\t * @param epsilon\n\t *            error allowed in the axis comparison\n\t * @return true if equivalent, false otherwise\n\t */\n\t@Deprecated\n\tpublic static boolean equivalentAxes(Matrix4d axis1, Matrix4d axis2,\n\t\t\tdouble epsilon) {\n\n\t\tAxisAngle4d rot1 = new AxisAngle4d();\n\t\trot1.set(axis1);\n\t\tAxisAngle4d rot2 = new AxisAngle4d();\n\t\trot2.set(axis2);\n\n\t\t// rot1.epsilonEquals(rot2, error); //that also compares angle\n\t\t// L-infinite distance without comparing the angle (epsilonEquals)\n\t\tList<Double> sameDir = new ArrayList<Double>();\n\t\tsameDir.add(Math.abs(rot1.x - rot2.x));\n\t\tsameDir.add(Math.abs(rot1.y - rot2.y));\n\t\tsameDir.add(Math.abs(rot1.z - rot2.z));\n\n\t\tList<Double> otherDir = new ArrayList<Double>();\n\t\totherDir.add(Math.abs(rot1.x + rot2.x));\n\t\totherDir.add(Math.abs(rot1.y + rot2.y));\n\t\totherDir.add(Math.abs(rot1.z + rot2.z));\n\n\t\tDouble error = Math.min(Collections.max(sameDir),\n\t\t\t\tCollections.max(otherDir));\n\n\t\treturn error < epsilon;\n\t}\n\n\t/**\n\t * Given a symmetry result, it calculates the overall global symmetry,\n\t * factoring out the alignment and detection steps of\n\t * {@link QuatSymmetryDetector} algorithm.\n\t *\n\t * @param result\n\t *            symmetry result\n\t * @return global symmetry results\n\t * @throws StructureException\n\t */\n\tpublic static QuatSymmetryResults getQuaternarySymmetry(CeSymmResult result)\n\t\t\tthrows StructureException {\n\n\t\t// Obtain the subunits of the repeats\n\t\tList<Atom[]> atoms = toRepeatsAlignment(result).getAtomArrays();\n\t\tList<Subunit> subunits = atoms.stream()\n\t\t\t\t.map(a -> new Subunit(a, null, null, null))\n\t\t\t\t.collect(Collectors.toList());\n\n\t\t// The clustering thresholds are set to 0 so that all always merged\n\t\tSubunitClustererParameters cp = new SubunitClustererParameters();\n\t\tcp.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n\t\tcp.setRmsdThreshold(10.0);\n\t\tcp.setCoverageThreshold(0.0);\n\t\tcp.setSequenceIdentityThreshold(1.1); // avoid using sequence cluster\n\n\t\tQuatSymmetryParameters sp = new QuatSymmetryParameters();\n\n\t\tQuatSymmetryResults gSymmetry = QuatSymmetryDetector\n\t\t\t\t.calcGlobalSymmetry(subunits, sp, cp);\n\n\t\treturn gSymmetry;\n\t}\n\n\t/**\n\t * Returns true a symmetry multiple alignment has been refined, false\n\t * otherwise.\n\t * <p>\n\t * For a refined alignment only one Block with no repeated residues is\n\t * necessary. Sufficient condition is not tested (only known from the\n\t * algorithm or CeSymmResult).\n\t *\n\t * @param symm\n\t *            the symmetry alignment\n\t * @return true if the alignment is refined\n\t */\n\t@Deprecated\n\tpublic static boolean isRefined(MultipleAlignment symm) {\n\n\t\tif (symm.getBlocks().size() > 1) {\n\t\t\treturn false;\n\t\t} else if (symm.size() < 2)\n\t\t\treturn false;\n\t\telse {\n\t\t\tList<Integer> alreadySeen = new ArrayList<Integer>();\n\t\t\tList<List<Integer>> align = symm.getBlock(0).getAlignRes();\n\t\t\tfor (int str = 0; str < symm.size(); str++) {\n\t\t\t\tfor (int res = 0; res < align.get(str).size(); res++) {\n\t\t\t\t\tInteger residue = align.get(str).get(res);\n\t\t\t\t\tif (residue == null)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (alreadySeen.contains(residue)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\talreadySeen.add(residue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // end of all repeats\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the symmetry alignment is significant, false otherwise.\n\t * <p>\n\t * For a symmetry alignment to be significant, the alignment has to be\n\t * refined and the TM-score has to be higher than the threshold.\n\t * <p>\n\t * It is recommended to use the {@link CeSymmResult#isSignificant()} method\n\t * instead.\n\t *\n\t * @param msa\n\t * @param symmetryThreshold\n\t * @return\n\t * @throws StructureException\n\t */\n\t@Deprecated\n\tpublic static boolean isSignificant(MultipleAlignment msa,\n\t\t\tdouble symmetryThreshold) throws StructureException {\n\n\t\t// Order/refinement check\n\t\tif (!SymmetryTools.isRefined(msa))\n\t\t\treturn false;\n\n\t\t// TM-score cutoff\n\t\tdouble tm = 0.0;\n\t\tif (msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE) == null)\n\t\t\ttm = MultipleAlignmentScorer.getAvgTMScore(msa);\n\t\telse\n\t\t\ttm = msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE);\n\n\t\tif (tm < symmetryThreshold)\n\t\t\treturn false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the List of Groups of the corresponding representative Atom\n\t * array. The representative Atom array needs to fulfill: no two Atoms are\n\t * from the same Group and Groups are sequential (connected in the original\n\t * Structure), except if they are from different Chains.\n\t *\n\t * @param rAtoms\n\t *            array of representative Atoms (CA, P, etc).\n\t * @return List of Groups\n\t */\n\tpublic static List<Group> getGroups(Atom[] rAtoms) {\n\n\t\tList<Group> groups = new ArrayList<Group>(rAtoms.length);\n\n\t\tfor (Atom a : rAtoms) {\n\t\t\tGroup g = a.getGroup();\n\t\t\tif (g != null)\n\t\t\t\tgroups.add(g);\n\t\t\telse\n\t\t\t\tlogger.info(\"Group not found for representative Atom {}\", a);\n\t\t}\n\t\treturn groups;\n\t}\n\n\t/**\n\t * Calculates the set of symmetry operation Matrices (transformations) of\n\t * the new alignment, based on the symmetry relations in the SymmetryAxes\n\t * object. It sets the transformations to the input MultipleAlignment and\n\t * SymmetryAxes objects. If the SymmetryAxes object is null, the\n\t * superposition of the repeats is done without symmetry constraints.\n\t * <p>\n\t * This method also sets the scores (RMSD and TM-score) after the new\n\t * superposition has been updated.\n\t *\n\t * @param axes\n\t *            SymmetryAxes object. It will be modified.\n\t * @param msa\n\t *            MultipleAlignment. It will be modified.\n\t */\n\tpublic static void updateSymmetryTransformation(SymmetryAxes axes,\n\t\t\tMultipleAlignment msa) throws StructureException {\n\n\t\tList<List<Integer>> block = msa.getBlocks().get(0).getAlignRes();\n\t\tint length = block.get(0).size();\n\n\t\tif (axes != null) {\n\t\t\tfor (int level = 0; level < axes.getNumLevels(); level++) {\n\n\t\t\t\t// Calculate the aligned atom arrays to superimpose\n\t\t\t\tList<Atom> list1 = new ArrayList<Atom>();\n\t\t\t\tList<Atom> list2 = new ArrayList<Atom>();\n\n\t\t\t\tfor (int firstRepeat : axes.getFirstRepeats(level)) {\n\n\t\t\t\t\tMatrix4d transform = axes.getRepeatTransform(firstRepeat);\n\n\t\t\t\t\tList<List<Integer>> relation = axes.getRepeatRelation(\n\t\t\t\t\t\t\tlevel, firstRepeat);\n\n\t\t\t\t\tfor (int index = 0; index < relation.get(0).size(); index++) {\n\t\t\t\t\t\tint p1 = relation.get(0).get(index);\n\t\t\t\t\t\tint p2 = relation.get(1).get(index);\n\n\t\t\t\t\t\tfor (int k = 0; k < length; k++) {\n\t\t\t\t\t\t\tInteger pos1 = block.get(p1).get(k);\n\t\t\t\t\t\t\tInteger pos2 = block.get(p2).get(k);\n\t\t\t\t\t\t\tif (pos1 != null && pos2 != null) {\n\t\t\t\t\t\t\t\tAtom a = (Atom) msa.getAtomArrays().get(p1)[pos1]\n\t\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t\t\tAtom b = (Atom) msa.getAtomArrays().get(p2)[pos2]\n\t\t\t\t\t\t\t\t\t\t.clone();\n\t\t\t\t\t\t\t\tCalc.transform(a, transform);\n\t\t\t\t\t\t\t\tCalc.transform(b, transform);\n\t\t\t\t\t\t\t\tlist1.add(a);\n\t\t\t\t\t\t\t\tlist2.add(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tAtom[] arr1 = list1.toArray(new Atom[list1.size()]);\n\t\t\t\tAtom[] arr2 = list2.toArray(new Atom[list2.size()]);\n\n\t\t\t\t// Calculate the new transformation information\n\t\t\t\tif (arr1.length > 0 && arr2.length > 0) {\n\t\t\t\t\tMatrix4d axis = SuperPositions.superpose(\n\t\t\t\t\t\t\tCalc.atomsToPoints(arr1), \n\t\t\t\t\t\t\tCalc.atomsToPoints(arr2));\n\t\t\t\t\taxes.updateAxis(level, axis);\n\t\t\t\t}\n\n\t\t\t\t// Get the transformations from the SymmetryAxes\n\t\t\t\tList<Matrix4d> transformations = new ArrayList<Matrix4d>();\n\t\t\t\tfor (int su = 0; su < msa.size(); su++) {\n\t\t\t\t\ttransformations.add(axes.getRepeatTransform(su));\n\t\t\t\t}\n\t\t\t\tmsa.getBlockSet(0).setTransformations(transformations);\n\t\t\t}\n\t\t} else {\n\t\t\tMultipleSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t}\n\t\tupdateSymmetryScores(msa);\n\t}\n\n\t/**\n\t * Update the scores (TM-score and RMSD) of a symmetry multiple alignment.\n\t * This method does not redo the superposition of the alignment.\n\t *\n\t * @param symm\n\t *            Symmetry Multiple Alignment of Repeats\n\t * @throws StructureException\n\t */\n\tpublic static void updateSymmetryScores(MultipleAlignment symm)\n\t\t\tthrows StructureException {\n\n\t\t// Multiply by the order of symmetry to normalize score\n\t\tdouble tmScore = MultipleAlignmentScorer.getAvgTMScore(symm)\n\t\t\t\t* symm.size();\n\t\tdouble rmsd = MultipleAlignmentScorer.getRMSD(symm);\n\n\t\tsymm.putScore(MultipleAlignmentScorer.AVGTM_SCORE, tmScore);\n\t\tsymm.putScore(MultipleAlignmentScorer.RMSD, rmsd);\n\t}\n\n\t/**\n\t * Returns the representative Atom Array of the first model, if the\n\t * structure is NMR, or the Array for each model, if it is a biological\n\t * assembly with multiple models.\n\t * \n\t * @param structure\n\t * @return representative Atom[]\n\t */\n\tpublic static Atom[] getRepresentativeAtoms(Structure structure) {\n\n\t\tif (structure.isNmr())\n\t\t\treturn StructureTools.getRepresentativeAtomArray(structure);\n\n\t\telse {\n\n\t\t\t// Get Atoms of all models\n\t\t\tList<Atom> atomList = new ArrayList<Atom>();\n\t\t\tfor (int m = 0; m < structure.nrModels(); m++) {\n\t\t\t\tfor (Chain c : structure.getModel(m))\n\t\t\t\t\tatomList.addAll(Arrays.asList(StructureTools\n\t\t\t\t\t\t\t.getRepresentativeAtomArray(c)));\n\t\t\t}\n\t\t\treturn atomList.toArray(new Atom[0]);\n\t\t}\n\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each Subunit cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tif (stoichiometry.isEmpty())\n\t\t\treturn denominators;\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.utils;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\n/**\n * Test the methods in {@link SymmetryTools} class.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n *\n */\npublic class TestSymmetryTools {\n\n\t/**\n\t * Test {@link SymmetryTools#getValidFolds(List)}.\n\t */\n\t@Test\n\tpublic void testValidFolds() {\n\n\t\tList<Integer> stoich;\n\t\tList<Integer> folds;\n\t\tList<Integer> expected;\n\n\t\tstoich = Arrays.asList(6, 4);\n\t\texpected = Arrays.asList(1, 2);\n\t\tfolds = SymmetryTools.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 6);\n\t\texpected = Arrays.asList(1, 2, 3, 6);\n\t\tfolds = SymmetryTools.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 3);\n\t\texpected = Arrays.asList(1, 3);\n\t\tfolds = SymmetryTools.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 5);\n\t\texpected = Arrays.asList(1);\n\t\tfolds = SymmetryTools.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t}\n}\n","changedTest":"","commitMessage":"Update to biojava 5.0 ligand and chain model\n\nClearly define ligand handling:\n- Full-chain selections ('1abc.A') use all groups with that chain name,\n  including waters and ligands\n- Residue selections (1ab.A:1-100) do not include waters, and they may\n  include ligands from other chains if they appear within the cutoff distance\n\nAlso\n\n- Use StructureTools.addGroupToStructure more systematically\n  - Fix bug regarding entity copies\n- Remove deprecated Chain.getChainID calls & replace with correct version\n- Bug fixes regarding ligand definitions\n- Reverting earlier biojava 4 specific test changes (better ligand model in 5)\n- Really sweet use of Java 8 streams in SubstructureIdentifier.reduce\n","test_commitMessage":"","allZero":false}