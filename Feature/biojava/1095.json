{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cath/CathDomain.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/cath/CathDomainTest.java","prod_time":"2024-02-26 23:42:40","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ac75f31259e94a6d9d417e7faa2eaf2598c56f1a","test_commitID":"","isfound":"not found test change","originPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Author: Daniel Asarnow\n * Date:   2012-7-23\n */\n\npackage org.biojava.nbio.structure.cath;\n\n/**\n * @author Daniel Asarnow\n */\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\n\n/**\n * A class which represents a single CATH domain.\n */\npublic class CathDomain implements Serializable, StructureIdentifier {\n\n\tpublic static final long serialVersionUID = 1L;\n\n\t/**\n\t * The CATH domain code. Always 7 characters in length, combining the PDB and chain letter with the number of the domain within CATH.\n\t * Example: 1aoiA00\n\t * If the chain letter '0', domain refers to an entire PDB entry.\n\t */\n\tString domainName; // 7 characters 1oaiA00\n\n\t/**\n\t * The class number of this domain.\n\t */\n\tInteger classId; // C\n\n\t/**\n\t * The architecture number of this domain.\n\t */\n\tInteger architectureId; // A\n\n\t/**\n\t * The topology number of this domain.\n\t */\n\tInteger topologyId; // T\n\n\t/**\n\t * The homologous superfamily number of this domain.\n\t */\n\tInteger homologyId; // H\n\n\t/**\n\t * The sequence family (35% identity) number of this domain.\n\t */\n\tInteger sequenceFamilyId; // S\n\n\t/**\n\t * The \"orthologous\" sequence family (60% identity) number of this domain.\n\t */\n\tInteger orthologousSequenceFamilyId; // O\n\n\t/**\n\t * The \"Like\" sequence family (95% identity) number of this domain.\n\t */\n\tInteger likeSequenceFamilyId; // L\n\n\t/**\n\t * The identical sequence family (100% identity) number of this domain.\n\t */\n\n\tInteger identicalSequenceFamilyId; // I\n\n\t/**\n\t * The count of this domain among the identical sequence family members.\n\t */\n\tInteger domainCounter; // D\n\n\t/**\n\t * The domain length..\n\t */\n\tInteger length;\n\n\t/**\n\t * The resolution of the domain structure. Nominally in Angstroms,\n\t * the values 999.000 and 1000.000 signify NMR structures and obsolete structures, respectively.\n\t */\n\tDouble resolution;\n\n\t/**\n\t * The format and version of the CathDomainDescriptionFile.\n\t */\n\tString format;\n\n\t/**\n\t * The CATH version.\n\t */\n\tString version;\n\n\tDate date;\n\n\t/**\n\t * The so-called name field holds a potentially long description of the domain.\n\t */\n\tString name;\n\n\t/**\n\t * Complete source organism listing.\n\t */\n\tString source;\n\n\t/**\n\t * FASTA header.\n\t */\n\tString sequenceHeader;\n\n\t/**\n\t * FASTA sequence.\n\t */\n\tString sequence;\n\n\t/**\n\t * List of all sub-domain segments.\n\t */\n\tList<CathSegment> segments;\n\n\t/**\n\t * A (potentially long) comment. Usually empty.\n\t */\n\tString comment;\n\n\tpublic String getDomainName() {\n\t\treturn domainName;\n\t}\n\n\tpublic void setDomainName(String domainName) {\n\t\tthis.domainName = domainName;\n\t}\n\n\t/**\n\t * Returns the PDB ID.\n\t */\n\tpublic String getThePdbId() {\n\t\treturn domainName.substring(0, 4);\n\t}\n\n\t/**\n\t * Returns a string of the form {@code PDBID.CHAIN}.\n\t * For example: {@code 1hiv.A}.\n\t */\n\tpublic String getPdbIdAndChain() {\n\t\treturn domainName.substring(0, 4) +\n\t\t\t\t(!domainName.substring(4, 5).equals(\"0\") ? \".\" + domainName.substring(4, 5) : \"\");\n\t}\n\n\tpublic Integer getDomainId() {\n\t\treturn Integer.parseInt(domainName.substring(5));\n\t}\n\n\tpublic Integer getClassId() {\n\t\treturn classId;\n\t}\n\n\tpublic void setClassId(Integer classId) {\n\t\tthis.classId = classId;\n\t}\n\n\tpublic Integer getArchitectureId() {\n\t\treturn architectureId;\n\t}\n\n\tpublic void setArchitectureId(Integer architectureId) {\n\t\tthis.architectureId = architectureId;\n\t}\n\n\tpublic Integer getTopologyId() {\n\t\treturn topologyId;\n\t}\n\n\tpublic void setTopologyId(Integer topologyId) {\n\t\tthis.topologyId = topologyId;\n\t}\n\n\tpublic Integer getHomologyId() {\n\t\treturn homologyId;\n\t}\n\n\tpublic void setHomologyId(Integer homologyId) {\n\t\tthis.homologyId = homologyId;\n\t}\n\n\tpublic Integer getSequenceFamilyId() {\n\t\treturn sequenceFamilyId;\n\t}\n\n\tpublic void setSequenceFamilyId(Integer sequenceFamilyId) {\n\t\tthis.sequenceFamilyId = sequenceFamilyId;\n\t}\n\n\tpublic Integer getOrthologousSequenceFamilyId() {\n\t\treturn orthologousSequenceFamilyId;\n\t}\n\n\tpublic void setOrthologousSequenceFamilyId(Integer orthologousSequenceFamilyId) {\n\t\tthis.orthologousSequenceFamilyId = orthologousSequenceFamilyId;\n\t}\n\n\tpublic Integer getLikeSequenceFamilyId() {\n\t\treturn likeSequenceFamilyId;\n\t}\n\n\tpublic void setLikeSequenceFamilyId(Integer likeSequenceFamilyId) {\n\t\tthis.likeSequenceFamilyId = likeSequenceFamilyId;\n\t}\n\n\tpublic Integer getIdenticalSequenceFamilyId() {\n\t\treturn identicalSequenceFamilyId;\n\t}\n\n\tpublic void setIdenticalSequenceFamilyId(Integer identicalSequenceFamilyId) {\n\t\tthis.identicalSequenceFamilyId = identicalSequenceFamilyId;\n\t}\n\n\tpublic Integer getDomainCounter() {\n\t\treturn domainCounter;\n\t}\n\n\tpublic void setDomainCounter(Integer domainCounter) {\n\t\tthis.domainCounter = domainCounter;\n\t}\n\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(Integer length) {\n\t\tthis.length = length;\n\t}\n\n\tpublic Double getResolution() {\n\t\treturn resolution;\n\t}\n\n\tpublic void setResolution(Double resolution) {\n\t\tthis.resolution = resolution;\n\t}\n\n\tpublic void setCATH(String cathCode) {\n\t\tString[] token = cathCode.split(\"[.]\");\n\t\tsetClassId(Integer.parseInt(token[0]));\n\t\tsetArchitectureId(Integer.parseInt(token[1]));\n\t\tsetTopologyId(Integer.parseInt(token[2]));\n\t\tsetHomologyId(Integer.parseInt(token[3]));\n\t}\n\n\tpublic String getCATH() {\n\t\treturn Integer.toString(getClassId()) + \".\" +\n\t\t\t\tInteger.toString(getArchitectureId()) + \".\" +\n\t\t\t\tInteger.toString(getTopologyId()) + \".\" +\n\t\t\t\tInteger.toString(getHomologyId());\n\t}\n\n\tpublic void setSOLID(String cathCode) {\n\t\tString[] token = cathCode.split(\"[.]\");\n\t\tsetSequenceFamilyId(Integer.parseInt(token[0]));\n\t\tsetOrthologousSequenceFamilyId(Integer.parseInt(token[1]));\n\t\tsetLikeSequenceFamilyId(Integer.parseInt(token[2]));\n\t\tsetIdenticalSequenceFamilyId(Integer.parseInt(token[3]));\n\t\tsetDomainCounter(Integer.parseInt(token[4]));\n\t}\n\n\tpublic String getSOILD() {\n\t\treturn Integer.toString(getSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getOrthologousSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getLikeSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getIdenticalSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getDomainCounter());\n\t}\n\n\tpublic Integer getClassificationId(CathCategory cathCategory) {\n\t\tswitch (cathCategory) {\n\t\t\tcase Class:\n\t\t\t\treturn getClassId();\n\t\t\tcase Architecture:\n\t\t\t\treturn getArchitectureId();\n\t\t\tcase Topolgy:\n\t\t\t\treturn getTopologyId();\n\t\t\tcase Homology:\n\t\t\t\treturn getHomologyId();\n\t\t\tcase SequenceFamily:\n\t\t\t\treturn getSequenceFamilyId();\n\t\t\tcase OrthologousSequenceFamily:\n\t\t\t\treturn getOrthologousSequenceFamilyId();\n\t\t\tcase LikeSequenceFamily:\n\t\t\t\treturn getLikeSequenceFamilyId();\n\t\t\tcase IdenticalSequenceFamily:\n\t\t\t\treturn getIdenticalSequenceFamilyId();\n\t\t\tcase DomainCounter:\n\t\t\t\treturn getDomainCounter();\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String getFormat() {\n\t\treturn format;\n\t}\n\n\tpublic void setFormat(String format) {\n\t\tthis.format = format;\n\t}\n\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic void setVersion(String version) {\n\t\tthis.version = version;\n\t}\n\n\tpublic Date getDate() {\n\t\treturn date;\n\t}\n\n\tpublic void setDate(Date date) {\n\t\tthis.date = date;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getSource() {\n\t\treturn source;\n\t}\n\n\tpublic void setSource(String source) {\n\t\tthis.source = source;\n\t}\n\n\tpublic String getSequenceHeader() {\n\t\treturn sequenceHeader;\n\t}\n\n\tpublic void setSequenceHeader(String sequenceHeader) {\n\t\tthis.sequenceHeader = sequenceHeader;\n\t}\n\n\tpublic String getSequence() {\n\t\treturn sequence;\n\t}\n\n\tpublic void setSequence(String sequence) {\n\t\tthis.sequence = sequence;\n\t}\n\n\tpublic List<CathSegment> getSegments() {\n\t\treturn segments;\n\t}\n\n\tpublic void setSegments(List<CathSegment> segments) {\n\t\tthis.segments = segments;\n\t}\n\n\tpublic String getComment() {\n\t\treturn comment;\n\t}\n\n\tpublic void setComment(String comment) {\n\t\tthis.comment = comment;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CathDomain [domainName=\" + domainName + \", classId=\" + classId\n\t\t\t\t+ \", architectureId=\" + architectureId + \", topologyId=\"\n\t\t\t\t+ topologyId + \", homologyId=\" + homologyId\n\t\t\t\t+ \", sequenceFamilyId=\" + sequenceFamilyId\n\t\t\t\t+ \", orthologousSequenceFamilyId=\"\n\t\t\t\t+ orthologousSequenceFamilyId + \", likeSequenceFamilyId=\"\n\t\t\t\t+ likeSequenceFamilyId + \", identicalSequenceFamilyId=\"\n\t\t\t\t+ identicalSequenceFamilyId + \", domainCounter=\"\n\t\t\t\t+ domainCounter + \", length=\" + length + \", resolution=\"\n\t\t\t\t+ resolution + \", format=\" + format + \", version=\" + version\n\t\t\t\t+ \", date=\" + date + \", name=\" + name + \", source=\" + source\n\t\t\t\t+ \", sequenceHeader=\" + sequenceHeader + \", sequence=\"\n\t\t\t\t+ sequence + \", segments=\" + segments + \", comment=\" + comment\n\t\t\t\t+ \"]\";\n\t}\n\n\t/**\n\t * Returns the chains this domain is defined over; contains more than 1 element only if this domains is a multi-chain domain.\n\t * @throws StructureException \n\t */\n\tpublic Set<String> getChains() throws StructureException {\n\t\tSet<String> chains = new HashSet<String>();\n\t\tList<ResidueRange> rrs = toCanonical().getResidueRanges();\n\t\tfor (ResidueRange rr : rrs) chains.add(rr.getChainName());\n\t\treturn chains;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn getCATH();\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException{\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>();\n\t\tString chain = String.valueOf(getDomainName().charAt(getDomainName().length() - 3));\n\t\tfor (CathSegment segment : this.getSegments()) {\n\t\t\tranges.add(new ResidueRange(chain, segment.getStart(), segment.getStop()));\n\t\t}\n\n\t\treturn new SubstructureIdentifier(getThePdbId(), ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\t\t\tIOException {\n\t\treturn cache.getStructure(getThePdbId());\n\t}\n\n\n}\n","changedPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Author: Daniel Asarnow\n * Date:   2012-7-23\n */\n\npackage org.biojava.nbio.structure.cath;\n\n/**\n * @author Daniel Asarnow\n */\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.align.util.AtomCache;\n\n/**\n * A class which represents a single CATH domain.\n */\npublic class CathDomain implements Serializable, StructureIdentifier {\n\n\tpublic static final long serialVersionUID = 1L;\n\n\t/**\n\t * The CATH domain code. Always 7 characters in length, combining the PDB and chain letter with the number of the domain within CATH.\n\t * Example: 1aoiA00\n\t * If the chain letter '0', domain refers to an entire PDB entry.\n\t */\n\tString domainName; // 7 characters 1oaiA00\n\n\t/**\n\t * The class number of this domain.\n\t */\n\tInteger classId; // C\n\n\t/**\n\t * The architecture number of this domain.\n\t */\n\tInteger architectureId; // A\n\n\t/**\n\t * The topology number of this domain.\n\t */\n\tInteger topologyId; // T\n\n\t/**\n\t * The homologous superfamily number of this domain.\n\t */\n\tInteger homologyId; // H\n\n\t/**\n\t * The sequence family (35% identity) number of this domain.\n\t */\n\tInteger sequenceFamilyId; // S\n\n\t/**\n\t * The \"orthologous\" sequence family (60% identity) number of this domain.\n\t */\n\tInteger orthologousSequenceFamilyId; // O\n\n\t/**\n\t * The \"Like\" sequence family (95% identity) number of this domain.\n\t */\n\tInteger likeSequenceFamilyId; // L\n\n\t/**\n\t * The identical sequence family (100% identity) number of this domain.\n\t */\n\n\tInteger identicalSequenceFamilyId; // I\n\n\t/**\n\t * The count of this domain among the identical sequence family members.\n\t */\n\tInteger domainCounter; // D\n\n\t/**\n\t * The domain length..\n\t */\n\tInteger length;\n\n\t/**\n\t * The resolution of the domain structure. Nominally in Angstroms,\n\t * the values 999.000 and 1000.000 signify NMR structures and obsolete structures, respectively.\n\t */\n\tDouble resolution;\n\n\t/**\n\t * The format and version of the CathDomainDescriptionFile.\n\t */\n\tString format;\n\n\t/**\n\t * The CATH version.\n\t */\n\tString version;\n\n\tDate date;\n\n\t/**\n\t * The so-called name field holds a potentially long description of the domain.\n\t */\n\tString name;\n\n\t/**\n\t * Complete source organism listing.\n\t */\n\tString source;\n\n\t/**\n\t * FASTA header.\n\t */\n\tString sequenceHeader;\n\n\t/**\n\t * FASTA sequence.\n\t */\n\tString sequence;\n\n\t/**\n\t * List of all sub-domain segments.\n\t */\n\tList<CathSegment> segments;\n\n\t/**\n\t * A (potentially long) comment. Usually empty.\n\t */\n\tString comment;\n\n\tpublic String getDomainName() {\n\t\treturn domainName;\n\t}\n\n\tpublic void setDomainName(String domainName) {\n\t\tthis.domainName = domainName;\n\t}\n\n\t/**\n\t * Returns the PDB ID.\n\t */\n\tpublic String getThePdbId() {\n\t\treturn domainName.substring(0, 4);\n\t}\n\n\t/**\n\t * Returns a string of the form {@code PDBID.CHAIN}.\n\t * For example: {@code 1hiv.A}.\n\t */\n\tpublic String getPdbIdAndChain() {\n\t\treturn domainName.substring(0, 4) +\n\t\t\t\t(!\"0\".equals(domainName.substring(4, 5)) ? \".\" + domainName.substring(4, 5) : \"\");\n\t}\n\n\tpublic Integer getDomainId() {\n\t\treturn Integer.parseInt(domainName.substring(5));\n\t}\n\n\tpublic Integer getClassId() {\n\t\treturn classId;\n\t}\n\n\tpublic void setClassId(Integer classId) {\n\t\tthis.classId = classId;\n\t}\n\n\tpublic Integer getArchitectureId() {\n\t\treturn architectureId;\n\t}\n\n\tpublic void setArchitectureId(Integer architectureId) {\n\t\tthis.architectureId = architectureId;\n\t}\n\n\tpublic Integer getTopologyId() {\n\t\treturn topologyId;\n\t}\n\n\tpublic void setTopologyId(Integer topologyId) {\n\t\tthis.topologyId = topologyId;\n\t}\n\n\tpublic Integer getHomologyId() {\n\t\treturn homologyId;\n\t}\n\n\tpublic void setHomologyId(Integer homologyId) {\n\t\tthis.homologyId = homologyId;\n\t}\n\n\tpublic Integer getSequenceFamilyId() {\n\t\treturn sequenceFamilyId;\n\t}\n\n\tpublic void setSequenceFamilyId(Integer sequenceFamilyId) {\n\t\tthis.sequenceFamilyId = sequenceFamilyId;\n\t}\n\n\tpublic Integer getOrthologousSequenceFamilyId() {\n\t\treturn orthologousSequenceFamilyId;\n\t}\n\n\tpublic void setOrthologousSequenceFamilyId(Integer orthologousSequenceFamilyId) {\n\t\tthis.orthologousSequenceFamilyId = orthologousSequenceFamilyId;\n\t}\n\n\tpublic Integer getLikeSequenceFamilyId() {\n\t\treturn likeSequenceFamilyId;\n\t}\n\n\tpublic void setLikeSequenceFamilyId(Integer likeSequenceFamilyId) {\n\t\tthis.likeSequenceFamilyId = likeSequenceFamilyId;\n\t}\n\n\tpublic Integer getIdenticalSequenceFamilyId() {\n\t\treturn identicalSequenceFamilyId;\n\t}\n\n\tpublic void setIdenticalSequenceFamilyId(Integer identicalSequenceFamilyId) {\n\t\tthis.identicalSequenceFamilyId = identicalSequenceFamilyId;\n\t}\n\n\tpublic Integer getDomainCounter() {\n\t\treturn domainCounter;\n\t}\n\n\tpublic void setDomainCounter(Integer domainCounter) {\n\t\tthis.domainCounter = domainCounter;\n\t}\n\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(Integer length) {\n\t\tthis.length = length;\n\t}\n\n\tpublic Double getResolution() {\n\t\treturn resolution;\n\t}\n\n\tpublic void setResolution(Double resolution) {\n\t\tthis.resolution = resolution;\n\t}\n\n\tpublic void setCATH(String cathCode) {\n\t\tString[] token = cathCode.split(\"[.]\");\n\t\tsetClassId(Integer.parseInt(token[0]));\n\t\tsetArchitectureId(Integer.parseInt(token[1]));\n\t\tsetTopologyId(Integer.parseInt(token[2]));\n\t\tsetHomologyId(Integer.parseInt(token[3]));\n\t}\n\n\tpublic String getCATH() {\n\t\treturn Integer.toString(getClassId()) + \".\" +\n\t\t\t\tInteger.toString(getArchitectureId()) + \".\" +\n\t\t\t\tInteger.toString(getTopologyId()) + \".\" +\n\t\t\t\tInteger.toString(getHomologyId());\n\t}\n\n\tpublic void setSOLID(String cathCode) {\n\t\tString[] token = cathCode.split(\"[.]\");\n\t\tsetSequenceFamilyId(Integer.parseInt(token[0]));\n\t\tsetOrthologousSequenceFamilyId(Integer.parseInt(token[1]));\n\t\tsetLikeSequenceFamilyId(Integer.parseInt(token[2]));\n\t\tsetIdenticalSequenceFamilyId(Integer.parseInt(token[3]));\n\t\tsetDomainCounter(Integer.parseInt(token[4]));\n\t}\n\n\tpublic String getSOILD() {\n\t\treturn Integer.toString(getSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getOrthologousSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getLikeSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getIdenticalSequenceFamilyId()) + \".\" +\n\t\t\t\tInteger.toString(getDomainCounter());\n\t}\n\n\tpublic Integer getClassificationId(CathCategory cathCategory) {\n\t\tswitch (cathCategory) {\n\t\t\tcase Class:\n\t\t\t\treturn getClassId();\n\t\t\tcase Architecture:\n\t\t\t\treturn getArchitectureId();\n\t\t\tcase Topolgy:\n\t\t\t\treturn getTopologyId();\n\t\t\tcase Homology:\n\t\t\t\treturn getHomologyId();\n\t\t\tcase SequenceFamily:\n\t\t\t\treturn getSequenceFamilyId();\n\t\t\tcase OrthologousSequenceFamily:\n\t\t\t\treturn getOrthologousSequenceFamilyId();\n\t\t\tcase LikeSequenceFamily:\n\t\t\t\treturn getLikeSequenceFamilyId();\n\t\t\tcase IdenticalSequenceFamily:\n\t\t\t\treturn getIdenticalSequenceFamilyId();\n\t\t\tcase DomainCounter:\n\t\t\t\treturn getDomainCounter();\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic String getFormat() {\n\t\treturn format;\n\t}\n\n\tpublic void setFormat(String format) {\n\t\tthis.format = format;\n\t}\n\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic void setVersion(String version) {\n\t\tthis.version = version;\n\t}\n\n\tpublic Date getDate() {\n\t\treturn date;\n\t}\n\n\tpublic void setDate(Date date) {\n\t\tthis.date = date;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getSource() {\n\t\treturn source;\n\t}\n\n\tpublic void setSource(String source) {\n\t\tthis.source = source;\n\t}\n\n\tpublic String getSequenceHeader() {\n\t\treturn sequenceHeader;\n\t}\n\n\tpublic void setSequenceHeader(String sequenceHeader) {\n\t\tthis.sequenceHeader = sequenceHeader;\n\t}\n\n\tpublic String getSequence() {\n\t\treturn sequence;\n\t}\n\n\tpublic void setSequence(String sequence) {\n\t\tthis.sequence = sequence;\n\t}\n\n\tpublic List<CathSegment> getSegments() {\n\t\treturn segments;\n\t}\n\n\tpublic void setSegments(List<CathSegment> segments) {\n\t\tthis.segments = segments;\n\t}\n\n\tpublic String getComment() {\n\t\treturn comment;\n\t}\n\n\tpublic void setComment(String comment) {\n\t\tthis.comment = comment;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CathDomain [domainName=\" + domainName + \", classId=\" + classId\n\t\t\t\t+ \", architectureId=\" + architectureId + \", topologyId=\"\n\t\t\t\t+ topologyId + \", homologyId=\" + homologyId\n\t\t\t\t+ \", sequenceFamilyId=\" + sequenceFamilyId\n\t\t\t\t+ \", orthologousSequenceFamilyId=\"\n\t\t\t\t+ orthologousSequenceFamilyId + \", likeSequenceFamilyId=\"\n\t\t\t\t+ likeSequenceFamilyId + \", identicalSequenceFamilyId=\"\n\t\t\t\t+ identicalSequenceFamilyId + \", domainCounter=\"\n\t\t\t\t+ domainCounter + \", length=\" + length + \", resolution=\"\n\t\t\t\t+ resolution + \", format=\" + format + \", version=\" + version\n\t\t\t\t+ \", date=\" + date + \", name=\" + name + \", source=\" + source\n\t\t\t\t+ \", sequenceHeader=\" + sequenceHeader + \", sequence=\"\n\t\t\t\t+ sequence + \", segments=\" + segments + \", comment=\" + comment\n\t\t\t\t+ \"]\";\n\t}\n\n\t/**\n\t * Returns the chains this domain is defined over; contains more than 1 element only if this domains is a multi-chain domain.\n\t * @throws StructureException \n\t */\n\tpublic Set<String> getChains() throws StructureException {\n\t\tSet<String> chains = new HashSet<String>();\n\t\tList<ResidueRange> rrs = toCanonical().getResidueRanges();\n\t\tfor (ResidueRange rr : rrs) chains.add(rr.getChainName());\n\t\treturn chains;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn getCATH();\n\t}\n\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException{\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>();\n\t\tString chain = String.valueOf(getDomainName().charAt(getDomainName().length() - 3));\n\t\tfor (CathSegment segment : this.getSegments()) {\n\t\t\tranges.add(new ResidueRange(chain, segment.getStart(), segment.getStop()));\n\t\t}\n\n\t\treturn new SubstructureIdentifier(getThePdbId(), ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException,\n\t\t\tIOException {\n\t\treturn cache.getStructure(getThePdbId());\n\t}\n\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.test.cath;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\n\n/**\n * A test for {@link CathDomain}.\n * @author dmyersturnbull\n */\npublic class CathDomainTest {\n\t@Test\n\tpublic void test() throws StructureException {\n\t\tString id = \"1qvrC03\";\n\t\tCathDomain domain = CathFactory.getCathDatabase().getDomainByCathId(id);\n\t\tassertEquals(\"1QVR.C_332-400,C_514-540\", domain.toCanonical().getIdentifier());\n\t}\n}\n","changedTest":"","commitMessage":"fix: issue #1081 Sonar S1132 Strings literals should be placed on the left side when checking for equality\n","test_commitMessage":"","allZero":false}