{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/GuideTree.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/GuideTreeTest.java","prod_time":"2012-10-18 08:48:43","test_time":"2012-10-18 08:48:43","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"28f2a11c65452d710853c2d242bc786149c37563","test_commitID":"28f2a11c65452d710853c2d242bc786149c37563","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport javax.swing.tree.TreeNode;\n\nimport org.biojava3.alignment.template.GuideTreeNode;\nimport org.biojava3.alignment.template.PairwiseSequenceScorer;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\nimport org.forester.phylogenyinference.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogenyinference.NeighborJoining;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n    private List<S> sequences;\n    private List<PairwiseSequenceScorer<S, C>> scorers;\n    private BasicSymmetricalDistanceMatrix distances;\n    private String newick;\n    private Node root;\n\n    /**\n     * Creates a guide tree for use during progressive multiple sequence alignment.\n     *\n     * @param sequences the {@link List} of {@link Sequence}s to align\n     * @param scorers list of sequence pair scorers, one for each pair of sequences given\n     */\n    public GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n        this.sequences = Collections.unmodifiableList(sequences);\n        this.scorers = Collections.unmodifiableList(scorers);\n        distances = new BasicSymmetricalDistanceMatrix(sequences.size());\n        for (int i = 0, n = 0; i < sequences.size(); i++) {\n            AccessionID id = sequences.get(i).getAccession();\n            distances.setIdentifier(i, (id == null) ? Integer.toString(i + 1) : id.getID());\n            for (int j = i+1; j < sequences.size(); j++) {\n                PairwiseSequenceScorer<S, C> scorer = scorers.get(n++);\n                distances.setValue(i, j, scorer.getDistance());\n            }\n        }\n        // TODO UPGMA and other hierarchical clustering routines\n        Phylogeny phylogeny = NeighborJoining.createInstance().execute(distances);\n        newick = phylogeny.toString();\n        root = new Node(phylogeny.getRoot(), null);\n    }\n\n    /**\n     * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n     *\n     * @return list of sequence pair scores\n     */\n    public int[] getAllPairsScores() {\n        int[] scores = new int[scorers.size()];\n        int n = 0;\n        for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n            scores[n++] = scorer.getScore();\n        }\n        return scores;\n    }\n\n    /**\n     * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n     *\n     * @return the distance matrix used to construct this guide tree\n     */\n    public double[][] getDistanceMatrix() {\n        double[][] matrix = new double[distances.getSize()][distances.getSize()];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n     *\n     * @return the root node\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n     *\n     * @return the similarity matrix used to construct this guide tree\n     */\n    public int[][] getScoreMatrix() {\n        int[][] matrix = new int[sequences.size()][sequences.size()];\n        for (int i = 0, n = 0; i < matrix.length; i++) {\n            matrix[i][i] = scorers.get(i).getMaxScore();\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the {@link Sequence}s which make up the leaves of this tree.\n     *\n     * @return the sequences which make up the leaves of this tree\n     */\n    public List<S> getSequences() {\n        return sequences;\n    }\n\n    // method for Iterable\n\n    /**\n     * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n     */\n    @Override\n    public Iterator<GuideTreeNode<S, C>> iterator() {\n        return new PostOrderIterator();\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return newick;\n    }\n\n    /**\n     * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n     */\n    public class Node implements GuideTreeNode<S, C> {\n\n        private GuideTreeNode<S, C> parent, child1, child2;\n        private double distance;\n        private String name;\n        private boolean isLeaf, isVisited;\n        private Profile<S, C> profile;\n        private Future<ProfilePair<S, C>> profileFuture;\n\n        private Node(PhylogenyNode node, Node parent) {\n            this.parent = parent;\n            distance = node.getDistanceToParent();\n            name = node.getNodeName();\n            if(isLeaf = node.isExternal()) {\n                profile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n            } else {\n                child1 = new Node(node.getChildNode1(), this);\n                child2 = new Node(node.getChildNode2(), this);\n            }\n        }\n\n        // methods for GuideTreeNode\n\n        @Override\n        public GuideTreeNode<S, C> getChild1() {\n            return child1;\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChild2() {\n            return child2;\n        }\n\n        @Override\n        public double getDistanceToParent() {\n            return distance;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public Profile<S, C> getProfile() {\n            return profile;\n        }\n\n        @Override\n        public Future<ProfilePair<S, C>> getProfileFuture() {\n            return profileFuture;\n        }\n\n        @Override\n        public void setProfile(Profile<S, C> profile) {\n            this.profile = profile;\n            profileFuture = null;\n        }\n\n        @Override\n        public void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n            this.profileFuture = profileFuture;\n            profile = null;\n        }\n\n        // methods for TreeNode\n\n        @Override\n        public Enumeration<GuideTreeNode<S, C>> children() {\n            Vector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n            children.add(getChild1());\n            children.add(getChild2());\n            return children.elements();\n        }\n\n        @Override\n        public boolean getAllowsChildren() {\n            return !isLeaf();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChildAt(int childIndex) {\n            if (childIndex == 1) {\n                return getChild1();\n            } else if (childIndex == 2) {\n                return getChild2();\n            }\n            throw new IndexOutOfBoundsException();\n        }\n\n        @Override\n        public int getChildCount() {\n            return 2;\n        }\n\n        @Override\n        public int getIndex(TreeNode child) {\n            return getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getParent() {\n            return parent;\n        }\n\n        @Override\n        public boolean isLeaf() {\n            return isLeaf;\n        }\n\n        // helper methods for iterator\n\n        private void clearVisited() {\n            isVisited = false;\n            if (!isLeaf()) {\n                ((Node) getChild1()).clearVisited();\n                ((Node) getChild2()).clearVisited();\n            }\n        }\n\n        private boolean isVisited() {\n            return isVisited;\n        }\n\n        private void visit() {\n            isVisited = true;\n        }\n\n    }\n\n    // helper class that defines the default post-order (leaves to root) traversal\n    private class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n        private Stack<Node> nodes;\n\n        private PostOrderIterator() {\n            getRoot().clearVisited();\n            nodes = new Stack<Node>();\n            nodes.push(getRoot());\n        }\n\n        // methods for Iterator\n\n        @Override\n        public boolean hasNext() {\n            return !nodes.isEmpty();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> next() {\n            while (hasNext()) {\n                Node next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n                if (child1 != null && !child1.isVisited()) {\n                    nodes.push(child1);\n                } else if (child2 != null && !child2.isVisited()) {\n                    nodes.push(child2);\n                } else {\n                    next.visit();\n                    return nodes.pop();\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.Vector;\nimport java.util.concurrent.Future;\nimport javax.swing.tree.TreeNode;\n\nimport org.biojava3.alignment.template.GuideTreeNode;\nimport org.biojava3.alignment.template.PairwiseSequenceScorer;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.evoinference.distance.NeighborJoining;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n    private List<S> sequences;\n    private List<PairwiseSequenceScorer<S, C>> scorers;\n    private BasicSymmetricalDistanceMatrix distances;\n    private String newick;\n    private Node root;\n\n    /**\n     * Creates a guide tree for use during progressive multiple sequence alignment.\n     *\n     * @param sequences the {@link List} of {@link Sequence}s to align\n     * @param scorers list of sequence pair scorers, one for each pair of sequences given\n     */\n    public GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n        this.sequences = Collections.unmodifiableList(sequences);\n        this.scorers = Collections.unmodifiableList(scorers);\n        distances = new BasicSymmetricalDistanceMatrix(sequences.size());\n        BasicSymmetricalDistanceMatrix distclone = new BasicSymmetricalDistanceMatrix(sequences.size());\n        for (int i = 0, n = 0; i < sequences.size(); i++) {\n            AccessionID id = sequences.get(i).getAccession();\n            String str = (id == null) ? Integer.toString(i + 1) : id.getID();\n            distances.setIdentifier(i, str);\n            distclone.setIdentifier(i, str);\n            for (int j = i+1; j < sequences.size(); j++) {\n                double dist = scorers.get(n++).getDistance();\n                distances.setValue(i, j, dist);\n                distclone.setValue(i, j, dist);\n            }\n        }\n        // TODO UPGMA and other hierarchical clustering routines\n        Phylogeny phylogeny = NeighborJoining.createInstance().execute(distclone);\n        newick = phylogeny.toString();\n        root = new Node(phylogeny.getRoot(), null);\n    }\n\n    /**\n     * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n     *\n     * @return list of sequence pair scores\n     */\n    public int[] getAllPairsScores() {\n        int[] scores = new int[scorers.size()];\n        int n = 0;\n        for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n            scores[n++] = scorer.getScore();\n        }\n        return scores;\n    }\n\n    /**\n     * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n     *\n     * @return the distance matrix used to construct this guide tree\n     */\n    public double[][] getDistanceMatrix() {\n        double[][] matrix = new double[distances.getSize()][distances.getSize()];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n     *\n     * @return the root node\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n     *\n     * @return the similarity matrix used to construct this guide tree\n     */\n    public int[][] getScoreMatrix() {\n        int[][] matrix = new int[sequences.size()][sequences.size()];\n        for (int i = 0, n = 0; i < matrix.length; i++) {\n            matrix[i][i] = scorers.get(i).getMaxScore();\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the {@link Sequence}s which make up the leaves of this tree.\n     *\n     * @return the sequences which make up the leaves of this tree\n     */\n    public List<S> getSequences() {\n        return sequences;\n    }\n\n    // method for Iterable\n\n    /**\n     * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n     */\n    @Override\n    public Iterator<GuideTreeNode<S, C>> iterator() {\n        return new PostOrderIterator();\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return newick;\n    }\n\n    /**\n     * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n     */\n    public class Node implements GuideTreeNode<S, C> {\n\n        private GuideTreeNode<S, C> parent, child1, child2;\n        private double distance;\n        private String name;\n        private boolean isLeaf, isVisited;\n        private Profile<S, C> profile;\n        private Future<ProfilePair<S, C>> profileFuture;\n\n        private Node(PhylogenyNode node, Node parent) {\n            this.parent = parent;\n            distance = node.getDistanceToParent();\n            name = node.getName();\n            if(isLeaf = node.isExternal()) {\n                profile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n            } else {\n                child1 = new Node(node.getChildNode1(), this);\n                child2 = new Node(node.getChildNode2(), this);\n            }\n        }\n\n        // methods for GuideTreeNode\n\n        @Override\n        public GuideTreeNode<S, C> getChild1() {\n            return child1;\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChild2() {\n            return child2;\n        }\n\n        @Override\n        public double getDistanceToParent() {\n            return distance;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public Profile<S, C> getProfile() {\n            return profile;\n        }\n\n        @Override\n        public Future<ProfilePair<S, C>> getProfileFuture() {\n            return profileFuture;\n        }\n\n        @Override\n        public void setProfile(Profile<S, C> profile) {\n            this.profile = profile;\n            profileFuture = null;\n        }\n\n        @Override\n        public void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n            this.profileFuture = profileFuture;\n            profile = null;\n        }\n\n        // methods for TreeNode\n\n        @Override\n        public Enumeration<GuideTreeNode<S, C>> children() {\n            Vector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n            children.add(getChild1());\n            children.add(getChild2());\n            return children.elements();\n        }\n\n        @Override\n        public boolean getAllowsChildren() {\n            return !isLeaf();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChildAt(int childIndex) {\n            if (childIndex == 1) {\n                return getChild1();\n            } else if (childIndex == 2) {\n                return getChild2();\n            }\n            throw new IndexOutOfBoundsException();\n        }\n\n        @Override\n        public int getChildCount() {\n            return 2;\n        }\n\n        @Override\n        public int getIndex(TreeNode child) {\n            return getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getParent() {\n            return parent;\n        }\n\n        @Override\n        public boolean isLeaf() {\n            return isLeaf;\n        }\n\n        // helper methods for iterator\n\n        private void clearVisited() {\n            isVisited = false;\n            if (!isLeaf()) {\n                ((Node) getChild1()).clearVisited();\n                ((Node) getChild2()).clearVisited();\n            }\n        }\n\n        private boolean isVisited() {\n            return isVisited;\n        }\n\n        private void visit() {\n            isVisited = true;\n        }\n\n    }\n\n    // helper class that defines the default post-order (leaves to root) traversal\n    private class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n        private Stack<Node> nodes;\n\n        private PostOrderIterator() {\n            getRoot().clearVisited();\n            nodes = new Stack<Node>();\n            nodes.push(getRoot());\n        }\n\n        // methods for Iterator\n\n        @Override\n        public boolean hasNext() {\n            return !nodes.isEmpty();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> next() {\n            while (hasNext()) {\n                Node next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n                if (child1 != null && !child1.isVisited()) {\n                    nodes.push(child1);\n                } else if (child2 != null && !child2.isVisited()) {\n                    nodes.push(child2);\n                } else {\n                    next.visit();\n                    return nodes.pop();\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava3.alignment.Alignments.PairwiseSequenceScorerType;\nimport org.biojava3.alignment.Alignments.ProfileProfileAlignerType;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.GuideTreeNode;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class GuideTreeTest {\n\n    private List<ProteinSequence> proteins;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private GuideTree<ProteinSequence, AminoAcidCompound> tree;\n\n    @Before\n    public void setup() {\n        proteins = Arrays.asList(new ProteinSequence[] {new ProteinSequence(\"ARND\"), new ProteinSequence(\"ARND\"),\n                new ProteinSequence(\"HILK\"), new ProteinSequence(\"ANDR\")});\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        tree = new GuideTree<ProteinSequence, AminoAcidCompound>(proteins, Alignments.getAllPairsScorers(proteins,\n                PairwiseSequenceScorerType.GLOBAL_IDENTITIES, gaps, blosum62));\n    }\n\n    @Test\n    public void testGuideTree() {\n        assertNotNull(tree);\n    }\n\n    @Test\n    public void testGetAllPairsScores() {\n        assertArrayEquals(tree.getAllPairsScores(), new int[] {4, 0, 3, 0, 3, 0});\n    }\n\n    // FIXME [0][3] and [3][0] should be 0.4\n    @Test\n    public void testGetDistanceMatrix() {\n        assertArrayEquals(tree.getDistanceMatrix(), new double[][] {\n                {0.0, 0.0, 1.0, 0.19999999999999996},\n                {0.0, 0.0, 1.0, 0.4},\n                {1.0, 1.0, 0.0, 1.0},\n                {0.19999999999999996, 0.4, 1.0, 0.0}});\n    }\n\n    @Test\n    public void testGetRoot() {\n        assertEquals(Alignments.getProgressiveAlignment(tree, ProfileProfileAlignerType.GLOBAL, gaps,\n                blosum62).toString(), String.format(\"%s%n%s%n%s%n%s%n\",\n                \"--ARND-\",\n                \"--ARND-\",\n                \"HILK---\",\n                \"--A-NDR\"));\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        assertArrayEquals(tree.getScoreMatrix(), new int[][] {\n                {4, 4, 0, 3},\n                {4, 6, 0, 3},\n                {0, 0, 5, 0},\n                {3, 3, 0, 6}});\n    }\n\n    @Test\n    public void testGetSequences() {\n        List<ProteinSequence> list = tree.getSequences();\n        assertEquals(list.size(), 4);\n        assertEquals(list.get(0), proteins.get(0));\n        assertEquals(list.get(1), proteins.get(1));\n        assertEquals(list.get(2), proteins.get(2));\n        assertEquals(list.get(3), proteins.get(3));\n    }\n\n    @Test\n    public void testIterator() {\n        int i = 0;\n        for (GuideTreeNode<ProteinSequence, AminoAcidCompound> n : tree) {\n            switch (i++) {\n            case 0: assertEquals(n.getName(), \"1\"); break;\n            case 1: assertEquals(n.getName(), \"2\"); break;\n            case 2: assertEquals(n.getName(), \"\"); break;\n            case 3: assertEquals(n.getName(), \"3\"); break;\n            case 4: assertEquals(n.getName(), \"\"); break;\n            case 5: assertEquals(n.getName(), \"4\"); break;\n            case 6: assertEquals(n.getName(), \"\"); break;\n            }\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(tree.toString(),\n                \"(((1:0.0,2:0.0):0.19999999999999996,3:0.8):0.09999999999999998,4:0.09999999999999998)\");\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava3.alignment.Alignments.PairwiseSequenceScorerType;\nimport org.biojava3.alignment.Alignments.ProfileProfileAlignerType;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.GuideTreeNode;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class GuideTreeTest {\n\n    private List<ProteinSequence> proteins;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private GuideTree<ProteinSequence, AminoAcidCompound> tree;\n\n    @Before\n    public void setup() {\n        proteins = Arrays.asList(new ProteinSequence[] {new ProteinSequence(\"ARND\"), new ProteinSequence(\"ARND\"),\n                new ProteinSequence(\"HILK\"), new ProteinSequence(\"ANDR\")});\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        tree = new GuideTree<ProteinSequence, AminoAcidCompound>(proteins, Alignments.getAllPairsScorers(proteins,\n                PairwiseSequenceScorerType.GLOBAL_IDENTITIES, gaps, blosum62));\n    }\n\n    @Test\n    public void testGuideTree() {\n        assertNotNull(tree);\n    }\n\n    @Test\n    public void testGetAllPairsScores() {\n        assertArrayEquals(tree.getAllPairsScores(), new int[] {4, 0, 3, 0, 3, 0});\n    }\n\n    @Test\n    public void testGetDistanceMatrix() {\n        assertArrayEquals(tree.getDistanceMatrix(), new double[][] {\n                {0.0, 0.0, 1.0, 0.4},\n                {0.0, 0.0, 1.0, 0.4},\n                {1.0, 1.0, 0.0, 1.0},\n                {0.4, 0.4, 1.0, 0.0}});\n    }\n\n    @Test\n    public void testGetRoot() {\n        assertEquals(Alignments.getProgressiveAlignment(tree, ProfileProfileAlignerType.GLOBAL, gaps,\n                blosum62).toString(), String.format(\"%s%n%s%n%s%n%s%n\",\n                \"--ARND-\",\n                \"--ARND-\",\n                \"HILK---\",\n                \"--A-NDR\"));\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        assertArrayEquals(tree.getScoreMatrix(), new int[][] {\n                {4, 4, 0, 3},\n                {4, 6, 0, 3},\n                {0, 0, 5, 0},\n                {3, 3, 0, 6}});\n    }\n\n    @Test\n    public void testGetSequences() {\n        List<ProteinSequence> list = tree.getSequences();\n        assertEquals(list.size(), 4);\n        assertEquals(list.get(0), proteins.get(0));\n        assertEquals(list.get(1), proteins.get(1));\n        assertEquals(list.get(2), proteins.get(2));\n        assertEquals(list.get(3), proteins.get(3));\n    }\n\n    @Test\n    public void testIterator() {\n        int i = 0;\n        for (GuideTreeNode<ProteinSequence, AminoAcidCompound> n : tree) {\n            switch (i++) {\n            case 0: assertEquals(n.getName(), \"1\"); break;\n            case 1: assertEquals(n.getName(), \"2\"); break;\n            case 2: assertEquals(n.getName(), \"\"); break;\n            case 3: assertEquals(n.getName(), \"3\"); break;\n            case 4: assertEquals(n.getName(), \"\"); break;\n            case 5: assertEquals(n.getName(), \"4\"); break;\n            case 6: assertEquals(n.getName(), \"\"); break;\n            }\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(tree.toString(),\n                \"(((1:0.0,2:0.0):-1.4,3:0.8999999999999999):-0.7,4:-0.7)\");\n    }\n\n}\n","commitMessage":"Refactor to use forester 1.005\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9793 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Refactor to use forester 1.005\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9793 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}