{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/StructureTools.java","test_path":"integrationtest/src/test/java/org/biojava/bio/structure/StructureToolsTest.java","prod_time":"2013-04-07 23:11:32","test_time":"","type":"","proType":"EDIT","add_annotation_line":1,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"379d6b246d291aae6b8fd9f69ff42d293984bac3","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n\tpublic static final String caAtomName = \" CA \";\n\n\tpublic static final String nAtomName = \"N\";\n\n\tpublic static final String oAtomName = \"O\";\n\n\tpublic static final String cbAtomName = \"CB\";\n\n\n\t/** The names of the Atoms that form the backbone.\n\t *\n\t */\n\tpublic static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n\tpublic static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\n\t//private static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n\t//private static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\t//amino acid 3 and 1 letter code definitions\n\tprivate static final Map<String, Character> aminoAcids;\n\n\tprivate static final Set<Element> hBondDonorAcceptors;\n\t//\t// for conversion 3code 1code\n\t//\tprivate static  SymbolTokenization threeLetter ;\n\t//\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n\t/**\n\t * Pattern to describe subranges. Matches \"A\", \"A:\", \"A:7-53\",\"A_7-53\", etc.\n\t * @see #getSubRanges(Structure, String)\n\t */\n\tpublic static final Pattern pdbNumRangeRegex = Pattern.compile(\n\t\t\t\"^\\\\s*(\\\\w)\" + //chain ID\n\t\t\t\t\t\"(?:\" + //begin range, this is a \"non-capturing group\"\n\t\t\t\t\t\"(?::|_|:$|_$|$)\" + //colon or underscore, could be at the end of a line, another non-capt. group.\n\t\t\t\t\t\"(?:\"+ // another non capturing group for the residue range\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // first residue\n\t\t\t\t\t\"\\\\s*-\\\\s*\" + // -\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // second residue\n\t\t\t\t\t\")?+\"+\n\t\t\t\t\t\")?\" + //end range\n\t\t\t\"\\\\s*\");\n\n\n\tstatic {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\t\taminoAcids = new HashMap<String, Character>();\n\t\taminoAcids.put(\"GLY\", new Character('G'));\n\t\taminoAcids.put(\"ALA\", new Character('A'));\n\t\taminoAcids.put(\"VAL\", new Character('V'));\n\t\taminoAcids.put(\"LEU\", new Character('L'));\n\t\taminoAcids.put(\"ILE\", new Character('I'));\n\t\taminoAcids.put(\"PHE\", new Character('F'));\n\t\taminoAcids.put(\"TYR\", new Character('Y'));\n\t\taminoAcids.put(\"TRP\", new Character('W'));\n\t\taminoAcids.put(\"PRO\", new Character('P'));\n\t\taminoAcids.put(\"HIS\", new Character('H'));\n\t\taminoAcids.put(\"LYS\", new Character('K'));\n\t\taminoAcids.put(\"ARG\", new Character('R'));\n\t\taminoAcids.put(\"SER\", new Character('S'));\n\t\taminoAcids.put(\"THR\", new Character('T'));\n\t\taminoAcids.put(\"GLU\", new Character('E'));\n\t\taminoAcids.put(\"GLN\", new Character('Q'));\n\t\taminoAcids.put(\"ASP\", new Character('D'));\n\t\taminoAcids.put(\"ASN\", new Character('N'));\n\t\taminoAcids.put(\"CYS\", new Character('C'));\n\t\taminoAcids.put(\"MET\", new Character('M'));\n\t\t//MSE is only found as a molecular replacement for MET\n\t\taminoAcids.put(\"MSE\", new Character('M'));\n\t\t//'non-standard', genetically encoded\n\t\t//http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n\t\t//IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n\t\t//likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n\t\taminoAcids.put(\"CSE\", new Character('U'));\n\t\taminoAcids.put(\"SEC\", new Character('U'));\n\t\taminoAcids.put(\"PYH\", new Character('O'));\n\t\taminoAcids.put(\"PYL\", new Character('O'));\n\n\t\thBondDonorAcceptors = new HashSet<Element>();\n\t\thBondDonorAcceptors.add(Element.N);\n\t\thBondDonorAcceptors.add(Element.O);\n\t\thBondDonorAcceptors.add(Element.S);\n\n\t}\n\n\n\t/** Count how many number of Atoms are contained within a Structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of Atoms in this Structure\n\t */\n\tpublic static final int getNrAtoms(Structure s){\n\n\t\tint nrAtoms = 0;\n\n\t\tIterator<Group> iter = new GroupIterator(s);\n\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\t\t\tnrAtoms += g.size();\n\t\t}\n\n\t\treturn nrAtoms;\n\t}\n\n\n\t/** Count how many groups are contained within a structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of groups in the structure\n\t */\n\tpublic static final int getNrGroups(Structure s){\n\t\tint nrGroups = 0;\n\n\t\tList<Chain> chains = s.getChains(0);\n\t\tIterator<Chain> iter = chains.iterator();\n\t\twhile (iter.hasNext()){\n\t\t\tChain c = (Chain) iter.next();\n\t\t\tnrGroups += c.getAtomLength();\n\t\t}\n\t\treturn nrGroups;\n\t}\n\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a  {@link AminoAcid} or {@link HetatomImpl} group.\n\t * For structures with more than one model, only model 0 will be used.\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Structure s, String[] atomNames){\n\t\tList<Chain> chains = s.getModel(0);\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\textractCAatoms(atomNames, chains, atoms);\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. \n\t * In contrast to {@link #getAtomArray(Structure, String[])} this method iterates over all chains.\n\t * Iterates over all chains and groups\n\t * and checks if the requested atoms are in this group, no matter if this is a {@link AminoAcid} or {@link HetatomImpl} group.\n\t * For structures with more than one model, only model 0 will be used.\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArrayAllModels(Structure s, String[] atomNames){\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (int i =0 ; i < s.nrModels(); i++ ) {\n\t\t\tList<Chain> chains = s.getModel(i);\n\t\t\textractCAatoms(atomNames, chains, atoms);\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\n\t/** Convert all atoms of the structure (first model) into an Atom array\n\t * \n\t * @param s input structure\n\t * @return all atom array\n\t */\n\tpublic static final Atom[] getAllAtomArray(Structure s) {\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tAtomIterator iter = new AtomIterator(s);\n\t\twhile (iter.hasNext()){\n\t\t\tAtom a = iter.next();\n\t\t\tatoms.add(a);\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\t\n\t}\n\n\n\tprivate static void extractCAatoms(String[] atomNames, List<Chain> chains,\n\t\t\tList<Atom> atoms) {\n\t\tfor ( Chain c : chains) {\n\n\t\t\tfor ( Group g : c.getAtomGroups()) {\n\n\t\t\t\t// a temp container for the atoms of this group\n\t\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\t\tString atomName = atomNames[i];\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\t\tatoms.add(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param c the Chain to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n\t\tList<Group> groups = c.getAtomGroups();\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (Group g : groups){\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param c the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomCAArray(Chain c){\n\t\tString[] atomNames = {\" CA \" };\n\t\treturn getAtomArray(c,atomNames);\n\t}\n\n\t/** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n\t * groups and chains. The chain will only contain groups that are part of the CA array.\n\t * \n\t * @param ca array of CA atoms\n\t * @return Atom array\n\t */\n\tpublic static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n\t\tAtom[] newCA = new Atom[ca.length];\n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getGroup();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getChainID().equals(parentC.getChainID())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setChainID(parentC.getChainID());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup parentN = (Group)parentG.clone();\n\n\t\t\tnewCA[apos] = parentN.getAtom(\" CA \");\n\t\t\tnewChain.addGroup(parentN);\n\t\t}\n\t\treturn newCA;\n\t}\n\n\t/** Clone a set of CA Atoms, but returns the parent groups\n\t *  \n\t * @param ca Atom array\n\t * @return Group array\n\t */\n\tpublic static Group[] cloneGroups(Atom[] ca) {\n\t\tGroup[] newGroup = new Group[ca.length]; \n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getGroup();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getChainID().equals(parentC.getChainID())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setChainID(parentC.getChainID());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup ng = (Group)parentG.clone();\n\t\t\tnewGroup[apos] = ng;\n\t\t\tnewChain.addGroup(ng);\n\t\t}\n\t\treturn newGroup;\n\t}\n\n\t/** Utility method for working with circular permutations. Creates a duplicated and cloned set of Calpha atoms from the input array.\n\t * \n\t * @param ca2 atom array\n\t * @return cloned and duplicated set of input array\n\t * @throws StructureException\n\t */\n\tpublic static Atom[] duplicateCA2(Atom[] ca2) throws StructureException{\n\t\t// we don't want to rotate input atoms, do we?\n\t\tAtom[] ca2clone = new Atom[ca2.length*2];\n\n\t\tint pos = 0;\n\n\t\tChain c = null;\n\t\tString prevChainId = \"\";\n\t\tfor (Atom a : ca2){\t\t\t\n\t\t\tGroup g = (Group) a.getGroup().clone(); // works because each group has only a CA atom\n\n\t\t\tif (c == null ) {\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t} else {\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tif ( ! orig.getChainID().equals(prevChainId)){\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.addGroup(g);\n\t\t\tca2clone[pos] = g.getAtom(StructureTools.caAtomName);\n\n\t\t\tpos++;\n\t\t}\n\n\t\t// Duplicate ca2!\n\t\tc = null;\n\t\tprevChainId = \"\";\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone();\n\n\t\t\tif (c == null ) {\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t} else {\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tif ( ! orig.getChainID().equals(prevChainId)){\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.addGroup(g);\n\t\t\tca2clone[pos] = g.getAtom(StructureTools.caAtomName);\n\n\t\t\tpos++;\n\t\t}\n\n\t\treturn ca2clone;\n\n\t}\n\n\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getAtomCAArray(Structure s){\n\t\tString[] atomNames = {\" CA \"};\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\t/** Returns an Atom array of the MainChain atoms.\n\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getBackboneAtomArray(Structure s){\n\t\tString[] atomNames = backboneAtomNames;\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\n\t/** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static final Character convert_3code_1code(String code3)\n\t\t\tthrows UnknownPdbAminoAcidException {\n\t\t//\t{\n\t\t//\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\t//\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\t\t//\n\t\t//\t\treturn new Character(code1.charAt(0)) ;\n\t\tCharacter code1 = null;\n\t\tcode1 = aminoAcids.get(code3);\n\n\t\tif (code1 == null) {\n\t\t\tthrow new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n\t\t} else {\n\t\t\treturn code1;\n\t\t}\n\n\t}\n\n\t/** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static final Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\t//logger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n\t/* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static final boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n\t * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n\t * \n\t * @param s\n\t * @param chainId\n\t * @return Structure\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.setCompounds(s.getCompounds());\n\t\tnewS.setConnections(s.getConnections());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setSites(s.getSites());\n\n\t\tif ( chainId != null)\n\t\t\tchainId = chainId.trim();\n\n\t\tif ( chainId == null || chainId.equals(\"\")){\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\t\tChain c =  null;\n\t\ttry {\n\t\t\tc = s.getChainByPDB(chainId);\n\t\t} catch (StructureException e){\n\t\t\tSystem.err.println(e.getMessage() + \" trying upper case Chain id...\");\n\t\t\tc = s.getChainByPDB(chainId.toUpperCase());\n\n\n\t\t}\n\t\tif ( c != null) {\n\t\t\tnewS.addChain(c);\n\t\t\tfor ( Compound comp : s.getCompounds()){\n\t\t\t\tif ( comp.getChainId().contains(c.getChainID())){\n\t\t\t\t\t// found matching compound. set description...\n\t\t\t\t\tnewS.getPDBHeader().setDescription(\"Chain \" + c.getChainID() + \" of \" + s.getPDBCode() + \" \" + comp.getMolName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn newS;\n\t}\n\n\n\t/** Reduce a structure to provide a smaller representation.\n\t * Only takes the first model of the structure. If chainNr >=0 only takes\n\t * the chain at that position into account.\n\t * \n\t * @param s\n\t * @param chainNr can be -1 to request all chains of model 0, otherwise will only add chain at this position \n\t * @return Structure object\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.setCompounds(s.getCompounds());\n\t\tnewS.setConnections(s.getConnections());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\tnewS.getPDBHeader().setDescription(\"subset of \" + s.getPDBCode() + \" \" + s.getPDBHeader().getDescription() );\n\n\t\tif ( chainNr < 0 ) {\n\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\t\t}\n\t\tChain c =  null;\n\n\t\tc = s.getChain(0, chainNr);\n\n\t\tnewS.addChain(c);\n\n\t\treturn newS;\n\t}\n\n\n\n\t/** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n\t * specification:\n\t * \n\t * \n\t * ranges can be surrounded by ( and ). (but will be removed).\n\t * ranges are specified as\n\t * PDBresnum1 : PDBresnum2\n\t * \n\t *  a list of ranges is separated by ,\n\t *  \n\t *  Example\n\t *  4GCR (A:1-83)\n\t *  1CDG (A:407-495,A:582-686)\n\t *  1CDG (A_407-495,A_582-686)\n\t * \n\t * @param s The full structure\n\t * @param ranges A comma-seperated list of ranges, optionally surrounded by parentheses\n\t * @return Substructure of s specified by ranges\n\t */\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getSubRanges(Structure s, String ranges ) \n\t\t\tthrows StructureException\n\t\t\t{\n\t\tStructure struc = getReducedStructure(s, null);\n\n\t\tif ( ranges == null || ranges.equals(\"\"))\n\t\t\tthrow new IllegalArgumentException(\"ranges can't be null or empty\");\n\n\t\tranges = ranges.trim();\n\n\t\tif ( ranges.startsWith(\"(\"))\n\t\t\tranges = ranges.substring(1);\n\t\tif ( ranges.endsWith(\")\")) {\n\t\t\tranges = ranges.substring(0,ranges.length()-1);\n\t\t}\n\n\t\t//special case: '-' means 'everything'\n\t\tif ( ranges.equals(\"-\") ) {\n\t\t\treturn s;\n\t\t}\n\n\t\tStructure newS = new StructureImpl();\n\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.getPDBHeader().setDescription(\"sub-range \" + ranges + \" of \"  + newS.getPDBCode() + \" \" + s.getPDBHeader().getDescription());\n\t\tnewS.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\t// TODO The following should be only copied for atoms which are present in the range.\n\t\t//newS.setCompounds(s.getCompounds());\n\t\t//newS.setConnections(s.getConnections());\n\t\t//newS.setSSBonds(s.getSSBonds());\n\t\t//newS.setSites(s.getSites());\n\n\t\tString[] rangS =ranges.split(\",\");\n\n\t\tStringWriter name = new StringWriter();\n\t\tname.append(s.getName());\n\t\tboolean firstRange = true;\n\t\tString prevChainId = null;\n\n\t\t// parse the ranges, adding the specified residues to newS\n\t\tfor ( String r: rangS){\n\t\t\t//System.out.println(\">\"+r+\"<\");\n\t\t\t// Match a single range, eg \"A_4-27\"\n\n\t\t\tMatcher matcher = pdbNumRangeRegex.matcher(r);\n\t\t\tif( ! matcher.matches() ){\n\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID_pdbResnum1-pdbRensum2: \"+ranges);\n\t\t\t}\n\t\t\tString chainId = matcher.group(1);\n\t\t\tChain chain;\n\n\t\t\tif(chainId.equals(\"_\") && struc.size() == 1) {\n\t\t\t\t// Handle special case of \"_\" chain for single-chain proteins\n\t\t\t\tchain = struc.getChain(0);\n\t\t\t} else {\n\t\t\t\t// Explicit chain\n\t\t\t\tchain = struc.getChainByPDB(chainId);\n\t\t\t}\n\n\t\t\tGroup[] groups;\n\n\t\t\tString pdbresnumStart = matcher.group(2);\n\t\t\tString pdbresnumEnd   = matcher.group(3);\n\n\t\t\tif ( ! firstRange){\n\t\t\t\tname.append( \",\");\n\t\t\t} else {\n\t\t\t\tname.append(AtomCache.CHAIN_SPLIT_SYMBOL);\n\t\t\t}\n\t\t\tif( pdbresnumStart != null && pdbresnumEnd != null) {\n\t\t\t\t// not a full chain\n\t\t\t\t//since Java doesn't allow '+' before integers, fix this up.\n\t\t\t\tif(pdbresnumStart.charAt(0) == '+')\n\t\t\t\t\tpdbresnumStart = pdbresnumStart.substring(1);\n\t\t\t\tif(pdbresnumEnd.charAt(0) == '+')\n\t\t\t\t\tpdbresnumEnd = pdbresnumEnd.substring(1);\n\t\t\t\tgroups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\n\t\t\t\tname.append( chainId + AtomCache.UNDERSCORE + pdbresnumStart+\"-\" + pdbresnumEnd);\n\n\t\t\t} else {\n\t\t\t\t// full chain\n\t\t\t\tgroups = chain.getAtomGroups().toArray(new Group[chain.getAtomGroups().size()]);\n\t\t\t\tname.append(chainId);\n\t\t\t}\n\t\t\tfirstRange = true;\n\n\t\t\t// Create new chain, if needed\n\t\t\tChain c = null;\n\t\t\tif ( prevChainId == null) {\n\t\t\t\t// first chain...\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tc.setChainID(chain.getChainID());\n\t\t\t\tnewS.addChain(c);\n\t\t\t} else if ( prevChainId.equals(chain.getChainID())) {\n\t\t\t\tc = newS.getChainByPDB(prevChainId);\n\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tc = newS.getChainByPDB(chain.getChainID());\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// chain not in structure yet...\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(chain.getChainID());\n\t\t\t\t\tnewS.addChain(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the groups to the chain:\n\t\t\tfor ( Group g: groups) {\n\t\t\t\tc.addGroup(g);\n\t\t\t}\n\n\t\t\tprevChainId = c.getChainID();\n\t\t}\n\n\t\tnewS.setName(name.toString());\n\n\t\treturn newS;\n\t\t\t}\n\n\tpublic static final String convertAtomsToSeq(Atom[] atoms) {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tGroup prevGroup  = null;\n\t\tfor (Atom a : atoms){\n\t\t\tGroup g = a.getGroup();\n\t\t\tif ( prevGroup != null) {\n\t\t\t\tif ( prevGroup.equals(g)) {\n\t\t\t\t\t// we add each group only once.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString code3 = g.getPDBName();\n\t\t\ttry {\n\t\t\t\tbuf.append(convert_3code_1code(code3) );\n\t\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t\tbuf.append('X');\n\t\t\t}\n\t\t\tprevGroup = g;\n\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/** get a PDB residue number object for this group\n\t * \n\t * @param g Group object\n\t * @return a ResidueNumber object\n\t * @deprecated replaced by  Group.getResidueNumber()\n\t */\n\tpublic static final ResidueNumber getPDBResidueNumber(Group g){\n\n\t\treturn g.getResidueNumber();\n\n\t}\n\n\t/** Get a group represented by a ResidueNumber.\n\t * \n\t * @param struc a {@link Structure}\n\t * @param pdbResNum a {@link ResidueNumber}\n\t * @return a group in the structure that is represented by the pdbResNum. \n\t * @throws StructureException if the group cannot be found.\n\t */\n\tpublic static final Group getGroupByPDBResidueNumber(Structure struc, \n\t\t\tResidueNumber pdbResNum) throws StructureException {\n\t\tif (struc == null || pdbResNum==null) {\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\n\t\t}\n\n\t\tChain chain = struc.findChain(pdbResNum.getChainId());\n\n\t\t//\t\tString numIns = \"\" + pdbResNum.getSeqNum();\n\t\t//\t\tif (pdbResNum.getInsCode() != null) {\n\t\t//\t\t\tnumIns += pdbResNum.getInsCode();\n\t\t//\t\t}\n\n\n\t\treturn chain.getGroupByPDB(pdbResNum);\n\t}\n\n\t/*\n\t * Returns a List of Groups in a structure within the distance specified of a given group.\n\t */\n\tpublic static List<Group> getGroupsWithinShell(Structure structure, Group group, double distance, boolean includeWater) {\n\t\tSet<Group> returnSet = new LinkedHashSet<Group>();\n\n\t\t//square the distance to use as a comparison against getDistanceFast which returns the square of a distance.\n\t\tdistance = distance * distance;\n\n\t\tfor (Atom atomA : group.getAtoms()) {\n\t\t\tfor (Chain chain : structure.getChains()) {\n\t\t\t\tfor (Group chainGroup : chain.getAtomGroups()) {\n\t\t\t\t\t//                        System.out.println(\"Checking group: \" + chainGroup);\n\t\t\t\t\tif (chainGroup.getResidueNumber().equals(group.getResidueNumber())) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!includeWater && chainGroup.getPDBName().equals(\"HOH\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (Atom atomB : chainGroup.getAtoms()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t//use getDistanceFast as we are doing a lot of comparisons\n\t\t\t\t\t\t\t\tdouble dist = Calc.getDistanceFast(atomA, atomB);\n\t\t\t\t\t\t\t\tif (dist <= distance) {\n\t\t\t\t\t\t\t\t\treturnSet.add(chainGroup);\n\t\t\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} catch (StructureException ex) {\n\t\t\t\t\t\t\t\tLogger.getLogger(StructureTools.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<Group> returnList = new ArrayList<Group>();\n\t\treturnList.addAll(returnSet);\n\t\treturn returnList;\n\t}\n\n\t/*\n\t * Very simple distance-based bond calculator. Will give approximations,\n\t * but do not rely on this to be chemically correct.\n\t */\n\tpublic static List<Bond> findBonds(Group group, List<Group> groups) {\n\t\tList<Bond> bondList = new ArrayList<Bond>();\n\t\tfor (Atom atomA : group.getAtoms()) {\n\t\t\tfor (Group groupB : groups) {\n\t\t\t\tif (groupB.getType().equals(GroupType.HETATM)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (Atom atomB : groupB.getAtoms()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdouble dist = Calc.getDistance(atomA, atomB);\n\t\t\t\t\t\tBondType bondType = BondType.UNDEFINED;\n\t\t\t\t\t\tif (dist <= 2) {\n\t\t\t\t\t\t\tbondType = BondType.COVALENT;\n\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dist <= 3.25) {\n\n\t\t\t\t\t\t\tif (isHbondDonorAcceptor(atomA) && isHbondDonorAcceptor(atomB)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HBOND;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (atomA.getElement().isMetal() && isHbondDonorAcceptor(atomB)) {\n\t\t\t\t\t\t\t\tbondType = BondType.METAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (atomA.getElement().equals(Element.C) && atomB.getElement().equals(Element.C)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HYDROPHOBIC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not really interested in 'undefined' types\n\t\t\t\t\t\t\tif (bondType != BondType.UNDEFINED) {\n\t\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t} else if (dist <= 3.9) {\n\t\t\t\t\t\t\tif (atomA.getElement().equals(Element.C) && atomB.getElement().equals(Element.C)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HYDROPHOBIC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not really interested in 'undefined' types\n\t\t\t\t\t\t\tif (bondType != BondType.UNDEFINED) {\n\t\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (StructureException ex) {\n\t\t\t\t\t\tLogger.getLogger(StructureTools.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn bondList;\n\t}\n\n\tprivate static boolean isHbondDonorAcceptor(Atom atom) {\n\t\tif (hBondDonorAcceptors.contains(atom.getElement())) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Remove all models from a Structure and keep only the first\n\t * \n\t * @param s original Structure\n\t * @return a structure that contains only  the first model\n\t * @since 3.0.5\n\t */\n\tpublic static Structure removeModels(Structure s){\n\t\tif ( ! s.isNmr())\n\t\t\treturn s;\n\n\t\tStructure n = new StructureImpl();\n\t\t// go through whole substructure and clone ...\n\n\t\t// copy structure data\n\t\tn.setNmr(true);\n\n\t\tn.setPDBCode(s.getPDBCode());\n\t\tn.setName(s.getName());\n\t\tn.setHeader(s.getHeader());\n\t\t//TODO: do deep copying of data!\n\t\tn.setPDBHeader(s.getPDBHeader());\n\t\tn.setDBRefs(s.getDBRefs());\n\t\tn.setConnections(s.getConnections());\n\t\tn.setSites(s.getSites());\n\t\tn.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\t\n\t\tn.setChains(s.getModel(0));\n\t\t\n\t\treturn n;\n\n\n\t}\n}\n","changedPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n\tpublic static final String caAtomName = \" CA \";\n\n\tpublic static final String nAtomName = \"N\";\n\n\tpublic static final String oAtomName = \"O\";\n\n\tpublic static final String cbAtomName = \"CB\";\n\n\n\t/** The names of the Atoms that form the backbone.\n\t *\n\t */\n\tpublic static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n\tpublic static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\n\t//private static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n\t//private static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\t//amino acid 3 and 1 letter code definitions\n\tprivate static final Map<String, Character> aminoAcids;\n\n\tprivate static final Set<Element> hBondDonorAcceptors;\n\t//\t// for conversion 3code 1code\n\t//\tprivate static  SymbolTokenization threeLetter ;\n\t//\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n\t/**\n\t * Pattern to describe subranges. Matches \"A\", \"A:\", \"A:7-53\",\"A_7-53\", etc.\n\t * @see #getSubRanges(Structure, String)\n\t */\n\tpublic static final Pattern pdbNumRangeRegex = Pattern.compile(\n\t\t\t\"^\\\\s*(\\\\w)\" + //chain ID\n\t\t\t\t\t\"(?:\" + //begin range, this is a \"non-capturing group\"\n\t\t\t\t\t\"(?::|_|:$|_$|$)\" + //colon or underscore, could be at the end of a line, another non-capt. group.\n\t\t\t\t\t\"(?:\"+ // another non capturing group for the residue range\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // first residue\n\t\t\t\t\t\"\\\\s*-\\\\s*\" + // -\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // second residue\n\t\t\t\t\t\")?+\"+\n\t\t\t\t\t\")?\" + //end range\n\t\t\t\"\\\\s*\");\n\n\n\tstatic {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\t\taminoAcids = new HashMap<String, Character>();\n\t\taminoAcids.put(\"GLY\", new Character('G'));\n\t\taminoAcids.put(\"ALA\", new Character('A'));\n\t\taminoAcids.put(\"VAL\", new Character('V'));\n\t\taminoAcids.put(\"LEU\", new Character('L'));\n\t\taminoAcids.put(\"ILE\", new Character('I'));\n\t\taminoAcids.put(\"PHE\", new Character('F'));\n\t\taminoAcids.put(\"TYR\", new Character('Y'));\n\t\taminoAcids.put(\"TRP\", new Character('W'));\n\t\taminoAcids.put(\"PRO\", new Character('P'));\n\t\taminoAcids.put(\"HIS\", new Character('H'));\n\t\taminoAcids.put(\"LYS\", new Character('K'));\n\t\taminoAcids.put(\"ARG\", new Character('R'));\n\t\taminoAcids.put(\"SER\", new Character('S'));\n\t\taminoAcids.put(\"THR\", new Character('T'));\n\t\taminoAcids.put(\"GLU\", new Character('E'));\n\t\taminoAcids.put(\"GLN\", new Character('Q'));\n\t\taminoAcids.put(\"ASP\", new Character('D'));\n\t\taminoAcids.put(\"ASN\", new Character('N'));\n\t\taminoAcids.put(\"CYS\", new Character('C'));\n\t\taminoAcids.put(\"MET\", new Character('M'));\n\t\t//MSE is only found as a molecular replacement for MET\n\t\taminoAcids.put(\"MSE\", new Character('M'));\n\t\t//'non-standard', genetically encoded\n\t\t//http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n\t\t//IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n\t\t//likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n\t\taminoAcids.put(\"CSE\", new Character('U'));\n\t\taminoAcids.put(\"SEC\", new Character('U'));\n\t\taminoAcids.put(\"PYH\", new Character('O'));\n\t\taminoAcids.put(\"PYL\", new Character('O'));\n\n\t\thBondDonorAcceptors = new HashSet<Element>();\n\t\thBondDonorAcceptors.add(Element.N);\n\t\thBondDonorAcceptors.add(Element.O);\n\t\thBondDonorAcceptors.add(Element.S);\n\n\t}\n\n\n\t/** Count how many number of Atoms are contained within a Structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of Atoms in this Structure\n\t */\n\tpublic static final int getNrAtoms(Structure s){\n\n\t\tint nrAtoms = 0;\n\n\t\tIterator<Group> iter = new GroupIterator(s);\n\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\t\t\tnrAtoms += g.size();\n\t\t}\n\n\t\treturn nrAtoms;\n\t}\n\n\n\t/** Count how many groups are contained within a structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of groups in the structure\n\t */\n\tpublic static final int getNrGroups(Structure s){\n\t\tint nrGroups = 0;\n\n\t\tList<Chain> chains = s.getChains(0);\n\t\tIterator<Chain> iter = chains.iterator();\n\t\twhile (iter.hasNext()){\n\t\t\tChain c = (Chain) iter.next();\n\t\t\tnrGroups += c.getAtomLength();\n\t\t}\n\t\treturn nrGroups;\n\t}\n\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a  {@link AminoAcid} or {@link HetatomImpl} group.\n\t * For structures with more than one model, only model 0 will be used.\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Structure s, String[] atomNames){\n\t\tList<Chain> chains = s.getModel(0);\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\textractCAatoms(atomNames, chains, atoms);\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. \n\t * In contrast to {@link #getAtomArray(Structure, String[])} this method iterates over all chains.\n\t * Iterates over all chains and groups\n\t * and checks if the requested atoms are in this group, no matter if this is a {@link AminoAcid} or {@link HetatomImpl} group.\n\t * For structures with more than one model, only model 0 will be used.\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArrayAllModels(Structure s, String[] atomNames){\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (int i =0 ; i < s.nrModels(); i++ ) {\n\t\t\tList<Chain> chains = s.getModel(i);\n\t\t\textractCAatoms(atomNames, chains, atoms);\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\n\t/** Convert all atoms of the structure (first model) into an Atom array\n\t * \n\t * @param s input structure\n\t * @return all atom array\n\t */\n\tpublic static final Atom[] getAllAtomArray(Structure s) {\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tAtomIterator iter = new AtomIterator(s);\n\t\twhile (iter.hasNext()){\n\t\t\tAtom a = iter.next();\n\t\t\tatoms.add(a);\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\t\n\t}\n\n\n\tprivate static void extractCAatoms(String[] atomNames, List<Chain> chains,\n\t\t\tList<Atom> atoms) {\n\t\tfor ( Chain c : chains) {\n\n\t\t\tfor ( Group g : c.getAtomGroups()) {\n\n\t\t\t\t// a temp container for the atoms of this group\n\t\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\t\tString atomName = atomNames[i];\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\t\tatoms.add(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param c the Chain to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n\t\tList<Group> groups = c.getAtomGroups();\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (Group g : groups){\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param c the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomCAArray(Chain c){\n\t\tString[] atomNames = {\" CA \" };\n\t\treturn getAtomArray(c,atomNames);\n\t}\n\n\t/** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n\t * groups and chains. The chain will only contain groups that are part of the CA array.\n\t * \n\t * @param ca array of CA atoms\n\t * @return Atom array\n\t */\n\tpublic static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n\t\tAtom[] newCA = new Atom[ca.length];\n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getGroup();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getChainID().equals(parentC.getChainID())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setChainID(parentC.getChainID());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup parentN = (Group)parentG.clone();\n\n\t\t\tnewCA[apos] = parentN.getAtom(\" CA \");\n\t\t\tnewChain.addGroup(parentN);\n\t\t}\n\t\treturn newCA;\n\t}\n\n\t/** Clone a set of CA Atoms, but returns the parent groups\n\t *  \n\t * @param ca Atom array\n\t * @return Group array\n\t */\n\tpublic static Group[] cloneGroups(Atom[] ca) {\n\t\tGroup[] newGroup = new Group[ca.length]; \n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getGroup();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getChainID().equals(parentC.getChainID())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setChainID(parentC.getChainID());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup ng = (Group)parentG.clone();\n\t\t\tnewGroup[apos] = ng;\n\t\t\tnewChain.addGroup(ng);\n\t\t}\n\t\treturn newGroup;\n\t}\n\n\t/** Utility method for working with circular permutations. Creates a duplicated and cloned set of Calpha atoms from the input array.\n\t * \n\t * @param ca2 atom array\n\t * @return cloned and duplicated set of input array\n\t * @throws StructureException\n\t */\n\tpublic static Atom[] duplicateCA2(Atom[] ca2) throws StructureException{\n\t\t// we don't want to rotate input atoms, do we?\n\t\tAtom[] ca2clone = new Atom[ca2.length*2];\n\n\t\tint pos = 0;\n\n\t\tChain c = null;\n\t\tString prevChainId = \"\";\n\t\tfor (Atom a : ca2){\t\t\t\n\t\t\tGroup g = (Group) a.getGroup().clone(); // works because each group has only a CA atom\n\n\t\t\tif (c == null ) {\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t} else {\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tif ( ! orig.getChainID().equals(prevChainId)){\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.addGroup(g);\n\t\t\tca2clone[pos] = g.getAtom(StructureTools.caAtomName);\n\n\t\t\tpos++;\n\t\t}\n\n\t\t// Duplicate ca2!\n\t\tc = null;\n\t\tprevChainId = \"\";\n\t\tfor (Atom a : ca2){\n\t\t\tGroup g = (Group)a.getGroup().clone();\n\n\t\t\tif (c == null ) {\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t} else {\n\t\t\t\tChain orig= a.getGroup().getChain();\n\t\t\t\tif ( ! orig.getChainID().equals(prevChainId)){\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(orig.getChainID());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.addGroup(g);\n\t\t\tca2clone[pos] = g.getAtom(StructureTools.caAtomName);\n\n\t\t\tpos++;\n\t\t}\n\n\t\treturn ca2clone;\n\n\t}\n\n\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getAtomCAArray(Structure s){\n\t\tString[] atomNames = {\" CA \"};\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\t/** Returns an Atom array of the MainChain atoms.\n\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getBackboneAtomArray(Structure s){\n\t\tString[] atomNames = backboneAtomNames;\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\n\t/** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static final Character convert_3code_1code(String code3)\n\t\t\tthrows UnknownPdbAminoAcidException {\n\t\t//\t{\n\t\t//\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\t//\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\t\t//\n\t\t//\t\treturn new Character(code1.charAt(0)) ;\n\t\tCharacter code1 = null;\n\t\tcode1 = aminoAcids.get(code3);\n\n\t\tif (code1 == null) {\n\t\t\tthrow new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n\t\t} else {\n\t\t\treturn code1;\n\t\t}\n\n\t}\n\n\t/** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static final Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\t//logger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n\t/* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static final boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n\t * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n\t * \n\t * @param s\n\t * @param chainId\n\t * @return Structure\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.setCompounds(s.getCompounds());\n\t\tnewS.setConnections(s.getConnections());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setSites(s.getSites());\n\n\t\tif ( chainId != null)\n\t\t\tchainId = chainId.trim();\n\n\t\tif ( chainId == null || chainId.equals(\"\")){\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\t\tChain c =  null;\n\t\ttry {\n\t\t\tc = s.getChainByPDB(chainId);\n\t\t} catch (StructureException e){\n\t\t\tSystem.err.println(e.getMessage() + \" trying upper case Chain id...\");\n\t\t\tc = s.getChainByPDB(chainId.toUpperCase());\n\n\n\t\t}\n\t\tif ( c != null) {\n\t\t\tnewS.addChain(c);\n\t\t\tfor ( Compound comp : s.getCompounds()){\n\t\t\t\tif ( comp.getChainId().contains(c.getChainID())){\n\t\t\t\t\t// found matching compound. set description...\n\t\t\t\t\tnewS.getPDBHeader().setDescription(\"Chain \" + c.getChainID() + \" of \" + s.getPDBCode() + \" \" + comp.getMolName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn newS;\n\t}\n\n\n\t/** Reduce a structure to provide a smaller representation.\n\t * Only takes the first model of the structure. If chainNr >=0 only takes\n\t * the chain at that position into account.\n\t * \n\t * @param s\n\t * @param chainNr can be -1 to request all chains of model 0, otherwise will only add chain at this position \n\t * @return Structure object\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.setCompounds(s.getCompounds());\n\t\tnewS.setConnections(s.getConnections());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setSites(s.getSites());\n\t\tnewS.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\tnewS.getPDBHeader().setDescription(\"subset of \" + s.getPDBCode() + \" \" + s.getPDBHeader().getDescription() );\n\n\t\tif ( chainNr < 0 ) {\n\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\t\t}\n\t\tChain c =  null;\n\n\t\tc = s.getChain(0, chainNr);\n\n\t\tnewS.addChain(c);\n\n\t\treturn newS;\n\t}\n\n\n\n\t/** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n\t * specification:\n\t * \n\t * \n\t * ranges can be surrounded by ( and ). (but will be removed).\n\t * ranges are specified as\n\t * PDBresnum1 : PDBresnum2\n\t * \n\t *  a list of ranges is separated by ,\n\t *  \n\t *  Example\n\t *  4GCR (A:1-83)\n\t *  1CDG (A:407-495,A:582-686)\n\t *  1CDG (A_407-495,A_582-686)\n\t * \n\t * @param s The full structure\n\t * @param ranges A comma-seperated list of ranges, optionally surrounded by parentheses\n\t * @return Substructure of s specified by ranges\n\t */\n\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getSubRanges(Structure s, String ranges ) \n\t\t\tthrows StructureException\n\t\t\t{\n\t\tStructure struc = getReducedStructure(s, null);\n\n\t\tif ( ranges == null || ranges.equals(\"\"))\n\t\t\tthrow new IllegalArgumentException(\"ranges can't be null or empty\");\n\n\t\tranges = ranges.trim();\n\n\t\tif ( ranges.startsWith(\"(\"))\n\t\t\tranges = ranges.substring(1);\n\t\tif ( ranges.endsWith(\")\")) {\n\t\t\tranges = ranges.substring(0,ranges.length()-1);\n\t\t}\n\n\t\t//special case: '-' means 'everything'\n\t\tif ( ranges.equals(\"-\") ) {\n\t\t\treturn s;\n\t\t}\n\n\t\tStructure newS = new StructureImpl();\n\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setName(s.getName());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tnewS.setNmr(s.isNmr());\n\t\tnewS.setBiologicalAssembly(s.isBiologicalAssembly());\n\t\tnewS.getPDBHeader().setDescription(\"sub-range \" + ranges + \" of \"  + newS.getPDBCode() + \" \" + s.getPDBHeader().getDescription());\n\t\tnewS.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\t// TODO The following should be only copied for atoms which are present in the range.\n\t\t//newS.setCompounds(s.getCompounds());\n\t\t//newS.setConnections(s.getConnections());\n\t\t//newS.setSSBonds(s.getSSBonds());\n\t\t//newS.setSites(s.getSites());\n\n\t\tString[] rangS =ranges.split(\",\");\n\n\t\tStringWriter name = new StringWriter();\n\t\tname.append(s.getName());\n\t\tboolean firstRange = true;\n\t\tString prevChainId = null;\n\n\t\t// parse the ranges, adding the specified residues to newS\n\t\tfor ( String r: rangS){\n\t\t\t//System.out.println(\">\"+r+\"<\");\n\t\t\t// Match a single range, eg \"A_4-27\"\n\n\t\t\tMatcher matcher = pdbNumRangeRegex.matcher(r);\n\t\t\tif( ! matcher.matches() ){\n\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID_pdbResnum1-pdbRensum2: \"+ranges);\n\t\t\t}\n\t\t\tString chainId = matcher.group(1);\n\t\t\tChain chain;\n\n\t\t\tif(chainId.equals(\"_\") && struc.size() == 1) {\n\t\t\t\t// Handle special case of \"_\" chain for single-chain proteins\n\t\t\t\tchain = struc.getChain(0);\n\t\t\t} else {\n\t\t\t\t// Explicit chain\n\t\t\t\tchain = struc.getChainByPDB(chainId);\n\t\t\t}\n\n\t\t\tGroup[] groups;\n\n\t\t\tString pdbresnumStart = matcher.group(2);\n\t\t\tString pdbresnumEnd   = matcher.group(3);\n\n\t\t\tif ( ! firstRange){\n\t\t\t\tname.append( \",\");\n\t\t\t} else {\n\t\t\t\tname.append(AtomCache.CHAIN_SPLIT_SYMBOL);\n\t\t\t}\n\t\t\tif( pdbresnumStart != null && pdbresnumEnd != null) {\n\t\t\t\t// not a full chain\n\t\t\t\t//since Java doesn't allow '+' before integers, fix this up.\n\t\t\t\tif(pdbresnumStart.charAt(0) == '+')\n\t\t\t\t\tpdbresnumStart = pdbresnumStart.substring(1);\n\t\t\t\tif(pdbresnumEnd.charAt(0) == '+')\n\t\t\t\t\tpdbresnumEnd = pdbresnumEnd.substring(1);\n\t\t\t\tgroups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\n\t\t\t\tname.append( chainId + AtomCache.UNDERSCORE + pdbresnumStart+\"-\" + pdbresnumEnd);\n\n\t\t\t} else {\n\t\t\t\t// full chain\n\t\t\t\tgroups = chain.getAtomGroups().toArray(new Group[chain.getAtomGroups().size()]);\n\t\t\t\tname.append(chainId);\n\t\t\t}\n\t\t\tfirstRange = true;\n\n\t\t\t// Create new chain, if needed\n\t\t\tChain c = null;\n\t\t\tif ( prevChainId == null) {\n\t\t\t\t// first chain...\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tc.setChainID(chain.getChainID());\n\t\t\t\tnewS.addChain(c);\n\t\t\t} else if ( prevChainId.equals(chain.getChainID())) {\n\t\t\t\tc = newS.getChainByPDB(prevChainId);\n\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tc = newS.getChainByPDB(chain.getChainID());\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// chain not in structure yet...\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setChainID(chain.getChainID());\n\t\t\t\t\tnewS.addChain(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the groups to the chain:\n\t\t\tfor ( Group g: groups) {\n\t\t\t\tc.addGroup(g);\n\t\t\t}\n\n\t\t\tprevChainId = c.getChainID();\n\t\t}\n\n\t\tnewS.setName(name.toString());\n\n\t\treturn newS;\n\t\t\t}\n\n\tpublic static final String convertAtomsToSeq(Atom[] atoms) {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tGroup prevGroup  = null;\n\t\tfor (Atom a : atoms){\n\t\t\tGroup g = a.getGroup();\n\t\t\tif ( prevGroup != null) {\n\t\t\t\tif ( prevGroup.equals(g)) {\n\t\t\t\t\t// we add each group only once.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString code3 = g.getPDBName();\n\t\t\ttry {\n\t\t\t\tbuf.append(convert_3code_1code(code3) );\n\t\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t\tbuf.append('X');\n\t\t\t}\n\t\t\tprevGroup = g;\n\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/** get a PDB residue number object for this group\n\t * \n\t * @param g Group object\n\t * @return a ResidueNumber object\n\t * @deprecated replaced by  Group.getResidueNumber()\n\t */\n\tpublic static final ResidueNumber getPDBResidueNumber(Group g){\n\n\t\treturn g.getResidueNumber();\n\n\t}\n\n\t/** Get a group represented by a ResidueNumber.\n\t * \n\t * @param struc a {@link Structure}\n\t * @param pdbResNum a {@link ResidueNumber}\n\t * @return a group in the structure that is represented by the pdbResNum. \n\t * @throws StructureException if the group cannot be found.\n\t */\n\tpublic static final Group getGroupByPDBResidueNumber(Structure struc, \n\t\t\tResidueNumber pdbResNum) throws StructureException {\n\t\tif (struc == null || pdbResNum==null) {\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\n\t\t}\n\n\t\tChain chain = struc.findChain(pdbResNum.getChainId());\n\n\t\t//\t\tString numIns = \"\" + pdbResNum.getSeqNum();\n\t\t//\t\tif (pdbResNum.getInsCode() != null) {\n\t\t//\t\t\tnumIns += pdbResNum.getInsCode();\n\t\t//\t\t}\n\n\n\t\treturn chain.getGroupByPDB(pdbResNum);\n\t}\n\n\t/*\n\t * Returns a List of Groups in a structure within the distance specified of a given group.\n\t */\n\tpublic static List<Group> getGroupsWithinShell(Structure structure, Group group, double distance, boolean includeWater) {\n\t\tSet<Group> returnSet = new LinkedHashSet<Group>();\n\n\t\t//square the distance to use as a comparison against getDistanceFast which returns the square of a distance.\n\t\tdistance = distance * distance;\n\n\t\tfor (Atom atomA : group.getAtoms()) {\n\t\t\tfor (Chain chain : structure.getChains()) {\n\t\t\t\tfor (Group chainGroup : chain.getAtomGroups()) {\n\t\t\t\t\t//                        System.out.println(\"Checking group: \" + chainGroup);\n\t\t\t\t\tif (chainGroup.getResidueNumber().equals(group.getResidueNumber())) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!includeWater && chainGroup.getPDBName().equals(\"HOH\")) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfor (Atom atomB : chainGroup.getAtoms()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t//use getDistanceFast as we are doing a lot of comparisons\n\t\t\t\t\t\t\t\tdouble dist = Calc.getDistanceFast(atomA, atomB);\n\t\t\t\t\t\t\t\tif (dist <= distance) {\n\t\t\t\t\t\t\t\t\treturnSet.add(chainGroup);\n\t\t\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} catch (StructureException ex) {\n\t\t\t\t\t\t\t\tLogger.getLogger(StructureTools.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<Group> returnList = new ArrayList<Group>();\n\t\treturnList.addAll(returnSet);\n\t\treturn returnList;\n\t}\n\n\t/*\n\t * Very simple distance-based bond calculator. Will give approximations,\n\t * but do not rely on this to be chemically correct.\n\t */\n\tpublic static List<Bond> findBonds(Group group, List<Group> groups) {\n\t\tList<Bond> bondList = new ArrayList<Bond>();\n\t\tfor (Atom atomA : group.getAtoms()) {\n\t\t\tfor (Group groupB : groups) {\n\t\t\t\tif (groupB.getType().equals(GroupType.HETATM)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (Atom atomB : groupB.getAtoms()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdouble dist = Calc.getDistance(atomA, atomB);\n\t\t\t\t\t\tBondType bondType = BondType.UNDEFINED;\n\t\t\t\t\t\tif (dist <= 2) {\n\t\t\t\t\t\t\tbondType = BondType.COVALENT;\n\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dist <= 3.25) {\n\n\t\t\t\t\t\t\tif (isHbondDonorAcceptor(atomA) && isHbondDonorAcceptor(atomB)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HBOND;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (atomA.getElement().isMetal() && isHbondDonorAcceptor(atomB)) {\n\t\t\t\t\t\t\t\tbondType = BondType.METAL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (atomA.getElement().equals(Element.C) && atomB.getElement().equals(Element.C)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HYDROPHOBIC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not really interested in 'undefined' types\n\t\t\t\t\t\t\tif (bondType != BondType.UNDEFINED) {\n\t\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//                                    System.out.println(String.format(\"%s within %s of %s\", atomB, dist, atomA));\n\t\t\t\t\t\t} else if (dist <= 3.9) {\n\t\t\t\t\t\t\tif (atomA.getElement().equals(Element.C) && atomB.getElement().equals(Element.C)) {\n\t\t\t\t\t\t\t\tbondType = BondType.HYDROPHOBIC;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//not really interested in 'undefined' types\n\t\t\t\t\t\t\tif (bondType != BondType.UNDEFINED) {\n\t\t\t\t\t\t\t\tBond bond = new Bond(dist, bondType, group, atomA, groupB, atomB);\n\t\t\t\t\t\t\t\tbondList.add(bond);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} catch (StructureException ex) {\n\t\t\t\t\t\tLogger.getLogger(StructureTools.class.getName()).log(Level.SEVERE, null, ex);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\treturn bondList;\n\t}\n\n\tprivate static boolean isHbondDonorAcceptor(Atom atom) {\n\t\tif (hBondDonorAcceptors.contains(atom.getElement())) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** Remove all models from a Structure and keep only the first\n\t * \n\t * @param s original Structure\n\t * @return a structure that contains only  the first model\n\t * @since 3.0.5\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static Structure removeModels(Structure s){\n\t\tif ( ! s.isNmr())\n\t\t\treturn s;\n\n\t\tStructure n = new StructureImpl();\n\t\t// go through whole substructure and clone ...\n\n\t\t// copy structure data\n\t\tn.setNmr(true);\n\n\t\tn.setPDBCode(s.getPDBCode());\n\t\tn.setName(s.getName());\n\t\t\n\t\t// we are calling this legacy menthod for backwards compatibility\n\t\tn.setHeader(s.getHeader());\n\t\t//TODO: do deep copying of data!\n\t\tn.setPDBHeader(s.getPDBHeader());\n\t\tn.setDBRefs(s.getDBRefs());\n\t\tn.setConnections(s.getConnections());\n\t\tn.setSites(s.getSites());\n\t\tn.setCrystallographicInfo(s.getCrystallographicInfo());\n\t\t\n\t\tn.setChains(s.getModel(0));\n\t\t\n\t\treturn n;\n\n\n\t}\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava.bio.structure.io.PDBFileParser;\n\nimport junit.framework.TestCase;\n\npublic class StructureToolsTest extends TestCase {\n\n\tStructure structure, structure2, structure3;\n\n\t@Override\n\tprotected void setUp() throws IOException\n\t{\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/5pti.pdb\");\n\t\tassertNotNull(inStream);\n\n\n\t\tPDBFileParser pdbpars = new PDBFileParser();\n\t\tFileParsingParameters params = new FileParsingParameters();\n\t\tparams.setAlignSeqRes(false);\n\n\t\tpdbpars.setFileParsingParameters(params);\n\n\t\tstructure = pdbpars.parsePDBFile(inStream) ;\n\n\t\tassertNotNull(structure);\n\n\t\tassertEquals(\"structure does not contain one chain \", 1 ,structure.size());\n\n\t\tChain chain = structure.getChain(0);\n\t\tassertEquals(\"Wrong number of residues.\",123,chain.getAtomLength());\n\t\t\n\t\tinStream.close();\n\n\t\t// Load structure2\n\t\tinStream = this.getClass().getResourceAsStream(\"/1lnl.pdb\");\n\t\tassertNotNull(inStream);\n\n\t\tstructure2 = pdbpars.parsePDBFile(inStream) ;\n\n\t\tassertNotNull(structure2);\n\n\t\tassertEquals(\"structure does not contain 3 chains \", 3 ,structure2.size());\n\n\t\tinStream.close();\n\n\t\t// Load structure2\n\t\tinStream = this.getClass().getResourceAsStream(\"/1a4w.pdb\");\n\t\tassertNotNull(inStream);\n\n\t\tstructure3 = pdbpars.parsePDBFile(inStream) ;\n\n\t\tassertNotNull(structure3);\n\n\t\tassertEquals(\"structure does not contain 3 chains \", 3 ,structure3.size());\n\n\t\tinStream.close();\n\t}\n\n\n\tpublic void testGetCAAtoms(){\n\t\tAtom[] cas = StructureTools.getAtomCAArray(structure);\n\t\tassertEquals(\"did not find the expected number of Atoms (58), but got \" + cas.length,58,cas.length);\n\t}\n\n\tpublic void testGetNrAtoms(){\n\t\tint length = StructureTools.getNrAtoms(structure);\n\t\tassertEquals(\"did not find the expected number of Atoms (1070), but got \" + length,1070,length);\n\n\n\t}\n\n\tpublic void testGetSubRanges() throws StructureException {\n\t\tString range;\n\t\tStructure substr;\n\t\tChain chain;\n\n\t\t// normal substructures\n\t\trange = \"A:3-7\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 5, chain.getAtomLength() );\n\n\t\t// full chains\n\t\trange = \"A\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 411, chain.getAtomLength() );\n\t\t//assertEquals(\"subrange doesn't equal original chain A.\", structure2.getChainByPDB(\"A\"), chain);\n\n\t\t// full chains\n\t\trange = \"A:\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 411, chain.getAtomLength() );\n\t\t//assertEquals(\"subrange doesn't equal original chain A.\", structure2.getChainByPDB(\"A\"), chain);\n\n\t\t// combined ranges\n\t\trange = \"A:3-7,B:8-12\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 2, substr.size());\n\n\t\tchain = substr.getChain(0);\n\t\tassertEquals(\"Did not find the expected number of residues in first chain of \"+range, 5, chain.getAtomLength() );\n\n\t\tchain = substr.getChain(1);\n\t\tassertEquals(\"Did not find the expected number of residues in second chain of \"+range, 5, chain.getAtomLength() );\n\n\t\t// combined ranges\n\t\trange = \"A,B:8-12\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 2, substr.size());\n\n\t\tchain = substr.getChain(0);\n\t\tassertEquals(\"Did not find the expected number of residues in first chain of \"+range, 411, chain.getAtomLength() );\n\n\t\tchain = substr.getChain(1);\n\t\tassertEquals(\"Did not find the expected number of residues in second chain of \"+range, 5, chain.getAtomLength() );\n\n\t\t// parentheses\n\t\trange = \"(A:3-7)\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 5, chain.getAtomLength() );\n\n\t\t// Special '-' case\n\t\trange = \"-\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Should have gotten whole structure\",structure2, substr);\n\t\t\n\t\t// Test single-chain syntax\n\t\trange = \"_:\";\n\t\tsubstr = StructureTools.getSubRanges(structure, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\t\t\n\t\tchain = substr.getChain(0);\n\t\tassertEquals(\"Did not find the expected number of residues in first chain of \"+range, 123, chain.getAtomLength() );\n\t\t\n\t\ttry {\n\t\t\trange = \"_:\";\n\t\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\t\tfail(\"Illegal chain name in '\"+range+\"'. Should throw StructureException\");\n\t\t} catch(StructureException ex) {} //expected \n\t\t\n\t\t// some negative tests\n\t\ttry {\n\t\t\trange = \"7-10\";\n\t\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\t\tfail(\"Illegal range '\"+range+\"'. Should throw StructureException\");\n\t\t} catch(StructureException ex) {} //expected \n\t\ttry {\n\t\t\trange = \"A7-10\";\n\t\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\t\tfail(\"Illegal range '\"+range+\"'. Should throw StructureException\");\n\t\t} catch(StructureException ex) {} //expected \n\t}\n\n\tpublic void testRevisedConvention() throws IOException, StructureException{\n\n\t\tAtomCache cache = new AtomCache();\n\n\t\t\n\t\tString name11 = \"4hhb.A\";\n\t\tStructure s = cache.getStructure(name11);\n\t\tassertTrue(s.getChains().size() == 1);\n\n\n\t\tString name12 = \"4hhb.A:\";\n\t\ts = cache.getStructure(name12);\n\t\tassertTrue(s.getChains().size() == 1);\n\n\t\tString name13 = \"4hhb.A_\";\n\t\ts = cache.getStructure(name13);\n\t\tassertTrue(s.getChains().size() == 1);\n\t\t\n\t\tString name9 = \"4hhb.C_1-83\";\n\t\tString chainId = \"C\";\n\t\ts = cache.getStructure(name9);\n\n\t\tassertTrue(s.getChains().size() == 1);\n\t\tChain c = s.getChainByPDB(chainId);\n\t\tassertEquals(c.getChainID(),chainId);\n\t\tAtom[] ca = StructureTools.getAtomCAArray(s);\n\t\tassertEquals(83,ca.length);\n\n\t\tString name10 = \"4hhb.C_1-83,A_1-10\";\n\t\ts = cache.getStructure(name10);\n\t\tassertTrue(s.getChains().size() == 2);\n\t\tca = StructureTools.getAtomCAArray(s);\n\t\tassertEquals(93, ca.length);\n\n\t\t\n\t}\n\n\tpublic void testStructureToolsRegexp(){\n\n\n\t\tPattern p =  StructureTools.pdbNumRangeRegex;\n\n\t\tString t2 = \"A_10-20\";\n\t\tMatcher m2 = p.matcher(t2);\n\t\tassertNotNull(m2);\n\t\tassertTrue(m2.find());\n\t\tassertTrue(m2.matches());\n\n\t\t//\tfor (int i=0;i< m2.groupCount();i++){\n\t\t//\t\tString s = m2.group(i);\n\t\t//\t\tSystem.out.println(s);\n\t\t//\t}\n\t\tassertEquals(3,m2.groupCount());\n\n\n\t\tString t1 = \"A:10-20\";\n\t\tMatcher m1  = p.matcher(t1);\n\t\tassertNotNull(m1);\n\t\tassertTrue(m1.find());\n\t\tassertTrue(m1.matches());\n\t\tassertEquals(3,m1.groupCount());\n\n\n\t\tString t3 = \"A\";\n\t\tMatcher m3  = p.matcher(t3);\n\n\t\tassertNotNull(m3);\n\t\tassertTrue(m3.find());\n\t\tassertTrue(m3.matches());\n\t\tassertEquals(3,m3.groupCount());\n\n\n\t}\n\n\t/**\n\t * Test some subranges that we used to have problems with\n\t * @throws StructureException\n\t */\n\tpublic void testGetSubRangesExtended() throws StructureException {\n\t\tString range;\n\t\tStructure substr;\n\t\tChain chain;\n\n\t\t// negative indices\n\t\trange = \"A:-3-7\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\t// Note residue 0 is missing from 1lnl\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 10, chain.getAtomLength() );\n\n\t\t// double negative indices\n\t\trange = \"A:-3--1\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 3, chain.getAtomLength() );\n\n\t\t// mixed indices\n\t\trange = \"A:-3-+1\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 4, chain.getAtomLength() );\n\n\t\t// positive indices\n\t\trange = \"A:+1-6\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 6, chain.getAtomLength() );\n\n\n\t\t// whitespace\n\t\trange = \"A:3-7, B:8-12\";\n\t\tsubstr = StructureTools.getSubRanges(structure2, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 2, substr.size());\n\n\t\tchain = substr.getChain(0);\n\t\tassertEquals(\"Did not find the expected number of residues in first chain of \"+range, 5, chain.getAtomLength() );\n\n\t\tchain = substr.getChain(1);\n\t\tassertEquals(\"Did not find the expected number of residues in second chain of \"+range, 5, chain.getAtomLength() );\n\n\t}\n\n\t/**\n\t * Test insertion codes\n\t * @throws StructureException\n\t */\n\tpublic void testGetSubRangesInsertionCodes() throws StructureException {\n\t\tString range;\n\t\tStructure substr;\n\t\tChain chain;\n\n\t\t// range including insertion\n\t\trange = \"H:35-37\"; //includes 36A\n\t\tsubstr = StructureTools.getSubRanges(structure3, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 4, chain.getAtomLength() );\n\n\n\t\t// end with insertion\n\t\trange = \"H:35-36A\";\n\t\tsubstr = StructureTools.getSubRanges(structure3, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 3, chain.getAtomLength() );\n\n\t\t// begin with insertion\n\t\trange = \"H:36A-38\"; //includes 36A\n\t\tsubstr = StructureTools.getSubRanges(structure3, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 3, chain.getAtomLength() );\n\n\t\t// within insertion\n\t\trange = \"L:14-14K\"; //includes 36A\n\t\tsubstr = StructureTools.getSubRanges(structure3, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 12, chain.getAtomLength() );\n\n\t\t// within insertion\n\t\trange = \"L:14C-14J\"; //includes 36A\n\t\tsubstr = StructureTools.getSubRanges(structure3, range);\n\t\tassertEquals(\"Wrong number of chains in \"+range, 1, substr.size());\n\n\t\tchain = substr.getChain(0);\n\n\t\tassertEquals(\"Did not find the expected number of residues in \"+range, 8, chain.getAtomLength() );\n\t}\n\n\tpublic void testGroupsWithinShell() {\n\t\t//TODO\n\t}\n\n}\n","changedTest":"","commitMessage":"removing eclipse warning","test_commitMessage":"","allZero":false}