{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/ResidueRange.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/ResidueRangeTest.java","prod_time":"2013-02-26 08:22:41","test_time":"2013-02-26 08:22:41","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":7,"add_classname_line":0,"add_condition_line":2,"add_field_line":1,"add_import_line":4,"add_packageid_line":0,"add_parameter_line":6,"add_return_line":2,"del_annotation_line":0,"del_call_line":9,"del_classname_line":0,"del_condition_line":4,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":6,"del_return_line":3,"label":"POSITIVE","prod_commitID":"d9287cff287d17629a4bcfb3b58c937ea7c65317","test_commitID":"d9287cff287d17629a4bcfb3b58c937ea7c65317","isfound":"found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-10-18\n * Created by Douglas Myers-Turnbull\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A chain, a start {@link ResidueNumber} and an end ResidueNumber, optionally with length (number of residues). Due to\n * insertion codes, the length of a structure is not necessarily its end position minus its start. However, since\n * residue numbers are unique within any particular PDB file, each ResidueNumber in a {@link Structure} can be mapped to\n * a unique ATOM record in that Structure's PDB file; this is done by {@link AtomPositionMap}. ResidueRange can use this\n * information to determine the length of a range of residues accurately. Example use: <code>\n * AtomPositionMap map = AtomPositionMap.ofAminoAcids(cache.getAtoms(\"1qdm\"));\n * ResidueRange range = ResidueRange.parse(\"A_246-85S\", map);\n * System.out.println(range.getLength()); // should print 59\n * </code>\n * \n * @author dmyerstu\n * @see ResidueNumber\n * @since 3.0.6\n */\npublic class ResidueRange {\n\n\tprivate final String chain;\n\tprivate final ResidueNumber end;\n\tprivate final Integer length;\n\tprivate final ResidueNumber start;\n\n\t/**\n\t * Calculates the combined number of residues of the ResidueRanges in {@code ranges},\n\t * <em>given that each ResidueRange has a length calculated</em>. Does not check for overlap between the\n\t * ResidueRanges.\n\t * \n\t * @param ranges\n\t *            A list of ResidueRanges\n\t * @return The combined length\n\t * @throws IllegalArgumentException\n\t *             If the {@link #getLength() length} of one or more ResidueRange is null\n\t * @see #getLength()\n\t */\n\tpublic static int calcLength(List<ResidueRange> ranges) {\n\t\tint length = 0;\n\t\tfor (ResidueRange range : ranges) {\n\t\t\tif (range.getLength() == null) throw new IllegalArgumentException(\n\t\t\t\t\t\"At least one ResidueRange does not have a length.\");\n\t\t\tlength += range.getLength();\n\t\t}\n\t\treturn length;\n\t}\n\n\t/**\n\t * @param string\n\t *            A string of the form chain_start-end or chain.start-end. For example: <code>A.5-100</code> and\n\t *            <code>A_5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code string}. The result will have a null {@link #getLength()\n\t *         length}.\n\t */\n\tpublic static ResidueRange parse(String string) {\n\t\tString[] supParts = string.split(\"[\\\\._]\");\n\t\tString chain = supParts[0];\n\t\tString[] parts = supParts[1].split(\"-\");\n\t\tResidueNumber start = ResidueNumber.fromString(parts[0]);\n\t\tstart.setChainId(String.valueOf(chain));\n\t\tResidueNumber end = ResidueNumber.fromString(parts[1]);\n\t\tend.setChainId(String.valueOf(chain));\n\t\treturn new ResidueRange(chain, start, end, null);\n\t}\n\n\t/**\n\t * @param string\n\t *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code string}. The result will have the correct\n\t *         {@link #getLength() length}.\n\t */\n\tpublic static ResidueRange parse(String string, AtomPositionMap map) {\n\t\tResidueRange rr = parse(string);\n\t\tint length = map.calcLength(rr.getStart(), rr.getEnd());\n\t\treturn new ResidueRange(rr.getChain(), rr.getStart(), rr.getEnd(), length);\n\t}\n\n\t/**\n\t * @param string\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique list of ResidueRanges corresponding to {@code string}. Each ResidueRange will have a null\n\t *         {@link #getLength() length}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String string) {\n\t\tString[] parts = string.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param string\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @param map\n\t *            An {@link AtomPositionMap} containing one e\n\t * @return The unique ResidueRange corresponding to {@code string}. Each ResidueRange will have the correct\n\t *         {@link #getLength() length}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String string, AtomPositionMap map) {\n\t\tString[] parts = string.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part, map));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(String chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.length = length;\n\t}\n\n\t/**\n\t * Two ResidueRanges are equal iff they have the same chain, start residue, and end residue. Note that length is not\n\t * included.\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain == null) {\n\t\t\tif (other.chain != null) return false;\n\t\t} else if (!chain.equals(other.chain)) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\tpublic String getChain() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\t/**\n\t * @return The number of residues in this ResidueRange, including any alignment gaps. This value will be null if and\n\t *         only if this ResidueRange was created with a null length.\n\t */\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (chain == null ? 0 : chain.hashCode());\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.Structure;\n\n/**\n * A chain, a start residue, and an end residue. May also store a length value. Because of insertion codes, this length\n * is not necessarily end-start. Since residue numbers are unique within a PDB file, each ResidueNumber in a\n * {@link Structure} can be mapped to a unique ATOM record in that Structure's PDB file. ResidueRange provides a static\n * method {@link #getAminoAcidPositions(Atom[])} that returns a {@link HashMap} that maps each {@link ResidueNumber} to\n * its position in the PDB file's ATOM records. It also provides static methods for working with this map. Note that\n * these are defined as static utility methods only for performance reasons; it is not economical to store this data in\n * each ResidueRange.\n * \n * @author dmyerstu\n * @see ResidueNumber\n */\npublic class ResidueRange {\n\tprivate final char chain;\n\tprivate final ResidueNumber end;\n\tprivate final Integer length;\n\tprivate final ResidueNumber start;\n\n\t/**\n\t * Calculates the combined number of residues of the ResidueRanges in {@code rrs},\n\t * <em>given that each ResidueRange has a length calculated</em>. The value, if calculated,\n\t * <em>will include any alignment gaps</em>.\n\t * \n\t * @param rrs\n\t *            A list of ResidueRanges\n\t * @return The combined length\n\t * @throws IllegalArgumentException\n\t *             If the {@link #getLength() length} of one or more ResidueRange is null\n\t * @see #getLength()\n\t */\n\tpublic static int calcLength(List<ResidueRange> rrs) {\n\t\tint l = 0;\n\t\tfor (ResidueRange rr : rrs) {\n\t\t\tif (rr.getLength() == null) throw new IllegalArgumentException(\n\t\t\t\t\t\"At least one ResidueRange does not have a length.\");\n\t\t\tl += rr.getLength();\n\t\t}\n\t\treturn l;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static ResidueRange parse(String s) {\n\t\tchar chain = s.charAt(0);\n\t\tString[] parts = s.substring(2).split(\"-\");\n\t\tResidueNumber start = ResidueNumber.fromString(parts[0]);\n\t\tstart.setChainId(String.valueOf(chain));\n\t\tResidueNumber end = ResidueNumber.fromString(parts[1]);\n\t\tend.setChainId(String.valueOf(chain));\n\t\treturn new ResidueRange(chain, start, end, null);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static ResidueRange parse(String s, AtomPositionMap map) {\n\t\tResidueRange rr = parse(s);\n\t\tint length = map.calcLength(rr.getStart(), rr.getEnd());\n\t\treturn new ResidueRange(rr.getChain(), rr.getStart(), rr.getEnd(), length);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s, AtomPositionMap map) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part, map));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(char chain, ResidueNumber start, ResidueNumber end, Integer length) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.length = length;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain != other.chain) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\tpublic char getChain() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\t/**\n\t * @return The number of residues in this ResidueRange, including any alignment gaps. This value will be null if and\n\t *         only if this ResidueRange was created with a null length.\n\t */\n\tpublic Integer getLength() {\n\t\treturn length;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + chain;\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-10-18\n * Created by dmyerstu\n *\n */\npackage org.biojava.bio.structure;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableMap;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * A unit test for {@link ResidueRange}. Make sure to change the AtomCache directory in {@link #setUp()}.\n * \n * @author dmyerstu\n * @since 3.0.6\n */\npublic class ResidueRangeTest {\n\n\tprivate AtomCache cache;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache();\n\t}\n\n\t/**\n\t * Tests creating ResidueRanges and calculating their lengths.\n\t */\n\t@Test\n\tpublic void testBasic() {\n\t\tString[] ids = new String[] { \"1w0p\", \"3qq3\", \"3chc\", \"2ei7\" }; // more: , \"2qbr\"\n\t\tString[] chains = new String[] { \"A\", \"B\", \"A\", \"L\" };\n\t\tResidueNumber[] starts = new ResidueNumber[] { new ResidueNumber(\"A\", 5, ' '), new ResidueNumber(\"B\", 10, 's'),\n\t\t\t\tnew ResidueNumber(\"A\", 15, 'm'), new ResidueNumber(\"L\", 44, ' ') };\n\t\tResidueNumber[] ends = new ResidueNumber[] { new ResidueNumber(\"A\", 117, ' '),\n\t\t\t\tnew ResidueNumber(\"B\", 200, 's'), new ResidueNumber(\"A\", 464, 'q'), new ResidueNumber(\"L\", 254, 't') };\n\t\tInteger[] lengths = new Integer[] { 117 - 5, 200 - 10, 111, null };\n\t\tint totalLength = 0;\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>(ids.length);\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tResidueRange rr = new ResidueRange(chains[i], starts[i], ends[i], lengths[i]);\n\t\t\tassertEquals(\"The chain is incorrect\", chains[i], rr.getChain());\n\t\t\tassertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n\t\t\tassertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n\t\t\tassertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n\t\t\tranges.add(rr);\n\t\t\tif (lengths[i] != null) {\n\t\t\t\ttotalLength += lengths[i];\n\t\t\t\tassertEquals(\"Total length is wrong\", totalLength, ResidueRange.calcLength(ranges));\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tResidueRange.calcLength(ranges); // should fail\n\t\t\t\t\tfail(\"Lengths should be undefined\");\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String)}.\n\t */\n\t@Test\n\tpublic void testParseAndEqual() {\n\n\t\tString pdbId1 = \"2eke\";\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1);\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null),\n\t\t\t\tlist1.get(0));\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null),\n\t\t\t\tlist1.get(1));\n\t\tassertEquals(null, list1.get(0).getLength());\n\t\tassertEquals(null, list1.get(1).getLength());\n\n\t\tString pdbId = \"1qdm\";\n\t\tString string2 = \"A.3S-37S,A_65S-99S\";\n\t\tList<ResidueRange> list2 = ResidueRange.parseMultiple(string2);\n\t\tassertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 3, 'S'), new ResidueNumber(\"A\", 37, 'S'), null),\n\t\t\t\tlist2.get(0));\n\t\tassertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 65, 'S'), new ResidueNumber(\"A\", 99, 'S'), null),\n\t\t\t\tlist2.get(1));\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String, NavigableMap)}.\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testParseAndEqualWithLengths() throws IOException, StructureException {\n\n\t\tAtomPositionMap map;\n\n\t\tString pdbId1 = \"2eke\";\n\t\tmap = AtomPositionMap.ofAminoAcids(cache.getAtoms(pdbId1)); // TODO this could probably be mocked\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null),\n\t\t\t\tlist1.get(0));\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null),\n\t\t\t\tlist1.get(1));\n\t\tassertEquals(1063 - 1023, list1.get(0).getLength().intValue()); // no insertion codes\n\t\tassertEquals(1084 - 1064, list1.get(1).getLength().intValue());\n\n\t\tlist1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null),\n\t\t\t\tlist1.get(0));\n\t\tassertEquals(\n\t\t\t\tnew ResidueRange(\"C\", new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null),\n\t\t\t\tlist1.get(1));\n\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NavigableMap;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * A unit test for {@link ResidueRange}.\n * @author dmyerstu\n *\n */\npublic class ResidueRangeTest {\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache();\n\t}\n\t\n\t/**\n\t * Tests creating ResidueRanges and calculating their lengths.\n\t */\n\t@Test\n\tpublic void testBasic() {\n\t\tString[] ids = new String[] {\"1w0p\", \"3qq3\", \"3chc\", \"2ei7\"}; // more: , \"2qbr\"\n\t\tchar[] chains = new char[] {'A', 'B', 'A', 'L'};\n\t\tResidueNumber[] starts = new ResidueNumber[] {new ResidueNumber(\"A\", 5, ' '), new ResidueNumber(\"B\", 10, 's'), new ResidueNumber(\"A\", 15, 'm'), new ResidueNumber(\"L\", 44, ' ')};\n\t\tResidueNumber[] ends = new ResidueNumber[] {new ResidueNumber(\"A\", 117, ' '), new ResidueNumber(\"B\", 200, 's'), new ResidueNumber(\"A\", 464, 'q'), new ResidueNumber(\"L\", 254, 't')};\n\t\tInteger[] lengths = new Integer[] {117-5, 200-10, 111, null};\n\t\tint totalLength = 0;\n\t\tList<ResidueRange> ranges = new ArrayList<ResidueRange>(ids.length);\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tResidueRange rr = new ResidueRange(chains[i], starts[i], ends[i], lengths[i]);\n\t\t\tassertEquals(\"The chain is incorrect\", chains[i], rr.getChain());\n\t\t\tassertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n\t\t\tassertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n\t\t\tassertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n\t\t\tranges.add(rr);\n\t\t\tif (lengths[i] != null) {\n\t\t\t\ttotalLength += lengths[i];\n\t\t\t\tassertEquals(\"Total length is wrong\", totalLength, ResidueRange.calcLength(ranges));\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tResidueRange.calcLength(ranges); // should fail\n\t\t\t\t\tfail(\"Lengths should be undefined\");\n\t\t\t\t} catch (IllegalArgumentException e) {}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String)}.\n\t */\n\t@Test\n\tpublic void testParseAndEqual() {\n\n\t\tString pdbId1 = \"2eke\";\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(null, list1.get(0).getLength());\n\t\tassertEquals(null, list1.get(1).getLength());\n\n\t\tString pdbId = \"1qdm\";\n\t\tString string2 = \"A_3S-37S,A_65S-99S\";\n\t\tList<ResidueRange> list2 = ResidueRange.parseMultiple(string2);\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 3, 'S'), new ResidueNumber(\"A\", 37, 'S'), null), list2.get(0));\n\t\tassertEquals(new ResidueRange('A', new ResidueNumber(\"A\", 65, 'S'), new ResidueNumber(\"A\", 99, 'S'), null), list2.get(1));\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String, NavigableMap)}.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testParseAndEqualWithLengths() throws IOException, StructureException {\n\n\t\tAtomPositionMap map;\n\t\t\n\t\tString pdbId1 = \"2eke\";\n\t\tmap = new AtomPositionMap(cache.getAtoms(pdbId1)); // TODO this could probably be mocked\n\t\tString string1 = \"C_1023-1063,C_1064-1084\";\n\t\tList<ResidueRange> list1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\tassertEquals(1063-1023, list1.get(0).getLength().intValue()); // no insertion codes\n\t\tassertEquals(1084-1064, list1.get(1).getLength().intValue());\n\n\t\tlist1 = ResidueRange.parseMultiple(string1, map);\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), null), list1.get(0));\n\t\tassertEquals(new ResidueRange('C', new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), null), list1.get(1));\n\t\t\n\t}\n\t\n}\n","commitMessage":"Small improvements to ResidueRange, AtomPosition, and ResidueNumber; added a few useful methods. No bug fixes.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@10057 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Small improvements to ResidueRange, AtomPosition, and ResidueNumber; added a few useful methods. No bug fixes.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@10057 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}