{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/FileDownloadUtils.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/FileDownloadUtilsTest.java","prod_time":"2024-03-05 15:59:21","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"1ac29b3fae37ab43b2316ea1c9901de33620c978","test_commitID":"","isfound":"not found test change","originPro":"/**\n * BioJava development code\n *\n * This code may be freely distributed and modified under the terms of the GNU\n * Lesser General Public Licence. This should be distributed with the code. If\n * you do not have a copy, see:\n *\n * http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual authors. These\n * should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims, or to join the\n * biojava-l mailing list, visit the home page at:\n *\n * http://www.biojava.org/\n *\n * Created on Feb 23, 2012 Created by Andreas Prlic\n *\n * @since 3.0.2\n */\npackage org.biojava.nbio.core.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.net.HttpURLConnection;\nimport java.net.SocketTimeoutException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Scanner;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class FileDownloadUtils {\n\n\tprivate static final String SIZE_EXT = \".size\";\n\tprivate static final String HASH_EXT = \".hash\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(FileDownloadUtils.class);\n\n\tpublic enum Hash{\n\t\tMD5, SHA1, SHA256, UNKNOWN\n\t}\n\n\t/**\n\t * Copy the content of file src to dst TODO since java 1.7 this is provided\n\t * in java.nio.file.Files\n\t *\n\t * @param src\n\t * @param dst\n\t * @throws IOException\n\t */\n\t@SuppressWarnings(\"resource\")\n\tpublic static void copy(File src, File dst) throws IOException {\n\n\t\t// Took following recipe from\n\t\t// http://stackoverflow.com/questions/106770/standard-concise-way-to-copy-a-file-in-java\n\t\t// The nio package seems to be the most efficient way to copy a file\n\t\tFileChannel source = null;\n\t\tFileChannel destination = null;\n\n\t\ttry {\n\t\t\t// we need the supress warnings here (the warning that the stream is not closed is harmless)\n\t\t\t// see http://stackoverflow.com/questions/12970407/does-filechannel-close-close-the-underlying-stream\n\t\t\tsource = new FileInputStream(src).getChannel();\n\t\t\tdestination = new FileOutputStream(dst).getChannel();\n\t\t\tdestination.transferFrom(source, 0, source.size());\n\t\t} finally {\n\t\t\tif (source != null) {\n\t\t\t\tsource.close();\n\t\t\t}\n\t\t\tif (destination != null) {\n\t\t\t\tdestination.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the file extension of a file, excluding '.'.\n\t * If the file name has no extension the file name is returned.\n\t * @param f a File\n\t * @return The extension\n\t */\n\tpublic static String getFileExtension(File f) {\n\t\tString fileName = f.getName();\n\t\tString ext = \"\";\n\t\tint mid = fileName.lastIndexOf(\".\");\n\t\text = fileName.substring(mid + 1, fileName.length());\n\t\treturn ext;\n\t}\n\n\t/**\n\t * Gets the file name up to and excluding the first\n\t * '.' character. If there is no extension, the full filename\n\t * is returned.\n\t * @param f A file\n\t * @return A possibly empty but non-null String.\n\t */\n\tpublic static String getFilePrefix(File f) {\n\t\tString fileName = f.getName();\n\t\tint mid = fileName.indexOf(\".\");\n\t\tif (mid < 0) {\n\t\t\treturn fileName;\n\t\t}\n\t\treturn fileName.substring(0, mid);\n\t}\n\n\t/**\n\t * Download the content provided at URL url and store the result to a local\n\t * file, using a temp file to cache the content in case something goes wrong\n\t * in download. A timeout of 60 seconds is hard-coded and 10 retries are attempted.\n\t *\n\t * @param url\n\t * @param destination\n\t * @throws IOException\n\t */\n\tpublic static void downloadFile(URL url, File destination) throws IOException {\n\t\tint count = 0;\n\t\tint maxTries = 10;\n\t\tint timeout = 60000; //60 sec\n\n\t\tFile tempFile = Files.createTempFile(getFilePrefix(destination), \".\" + getFileExtension(destination)).toFile();\n\n\t\t// Took following recipe from stackoverflow:\n\t\t// http://stackoverflow.com/questions/921262/how-to-download-and-save-a-file-from-internet-using-java\n\t\t// It seems to be the most efficient way to transfer a file\n\t\t// See: http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\n\t\tReadableByteChannel rbc = null;\n\t\tFileOutputStream fos = null;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tURLConnection connection = prepareURLConnection(url.toString(), timeout);\n\t\t\t\tconnection.connect();\n\t\t\t\tInputStream inputStream = connection.getInputStream();\n\n\t\t\t\trbc = Channels.newChannel(inputStream);\n\t\t\t\tfos = new FileOutputStream(tempFile);\n\t\t\t\tfos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n\t\t\t\tbreak;\n\t\t\t} catch (SocketTimeoutException e) {\n\t\t\t\tif (++count == maxTries) throw e;\n\t\t\t} finally {\n\t\t\t\tif (rbc != null) {\n\t\t\t\t\trbc.close();\n\t\t\t\t}\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"Copying temp file [{}] to final location [{}]\", tempFile, destination);\n\t\tcopy(tempFile, destination);\n\n\t\t// delete the tmp file\n\t\ttempFile.delete();\n\n\t}\n\t\n\t/**\n\t * Creates validation files beside a file to be downloaded.<br>\n\t * Whenever possible, for a <code>file.ext</code> file, it creates \n\t * <code>file.ext.size</code> and <code>file.hash</code> for in the same \n\t * folder where <code>file.ext</code> exists.\n\t * If the file connection size could not be deduced from the URL, no size file is created. \n\t * If <code>hashURL</code> is <code>null</code>, no hash file is created.\n\t * @param url the remote file URL to download\n\t * @param localDestination the local file to download into\n\t * @param hashURL the URL of the hash file to download. Can be <code>null</code>.\n\t * @param hash The Hashing algorithm. Ignored if <code>hashURL</code> is <code>null</code>.\n\t */\n\tpublic static void createValidationFiles(URL url, File localDestination, URL hashURL, Hash hash){\n\t\ttry {\n\t\t\tURLConnection resourceConnection = url.openConnection();\n\t\t\tcreateValidationFiles(resourceConnection, localDestination, hashURL, FileDownloadUtils.Hash.UNKNOWN);\n\t\t} catch (IOException e) {\n\t\t\tlogger.warn(\"could not open connection to resource file due to exception: {}\", e.getMessage());\n\t\t}\n\t}\n\t/**\n\t * Creates validation files beside a file to be downloaded.<br>\n\t * Whenever possible, for a <code>file.ext</code> file, it creates \n\t * <code>file.ext.size</code> and <code>file.hash_XXXX</code> in the same \n\t * folder where <code>file.ext</code> exists (XXXX may be DM5, SHA1, or SHA256).\n\t * If the file connection size could not be deduced from the resourceUrlConnection \n\t * {@link URLConnection}, no size file is created. \n\t * If <code>hashURL</code> is <code>null</code>, no hash file is created.<br>\n\t * <b>N.B.</b> None of the hashing algorithms is implemented (yet), because we did not need any of them yet.\n\t * @param resourceUrlConnection the remote file URLConnection to download\n\t * @param localDestination the local file to download into\n\t * @param hashURL the URL of the hash file to download. Can be <code>null</code>.\n\t * @param hash The Hashing algorithm. Ignored if <code>hashURL</code> is <code>null</code>.\n\t * @since 7.0.0\n\t */\n\tpublic static void createValidationFiles(URLConnection resourceUrlConnection, File localDestination, URL hashURL, Hash hash){\n\t\tlong size = resourceUrlConnection.getContentLengthLong();\n\t\tif(size == -1) {\n\t\t\tlogger.warn(\"could not find expected file size for resource {}.\", resourceUrlConnection.getURL());\n\t\t} else {\n\t\t\tlogger.debug(\"Content-Length: \" + size);\n\t\t\tFile sizeFile = new File(localDestination.getParentFile(), localDestination.getName() + SIZE_EXT);\n\t\t\ttry (PrintStream sizePrintStream = new PrintStream(sizeFile)) {\n\t\t\t\tsizePrintStream.print(size);\n\t\t\t\tsizePrintStream.close();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tlogger.warn(\"could not write size validation file due to exception: {}\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(hashURL == null)\n\t\t\treturn;\n\n\t\tif(hash == Hash.UNKNOWN)\n\t\t\tthrow new IllegalArgumentException(\"Hash URL given but algorithm is unknown\");\n\t\ttry {\n\t\t\tFile hashFile = new File(localDestination.getParentFile(), String.format(\"%s%s_%s\", localDestination.getName(), HASH_EXT, hash));\n\t\t\tdownloadFile(hashURL, hashFile);\n\t\t} catch (IOException e) {\n\t\t\tlogger.warn(\"could not write validation hash file due to exception: {}\", e.getMessage());\n\t\t}\n\t}\n\t\n\t/**\n\t * Validate a local file based on pre-existing metadata files for size and hash.<br>\n\t * If the passed in <code>localFile</code> parameter is a file named <code>file.ext</code>, the function searches in the same folder for:\n\t * <ul>\n\t * <li><code>file.ext.size</code>: If found, it compares the size stored in it to the length of <code>localFile</code> (in bytes).</li>\n\t * <li><code>file.ext.hash_XXXX (where XXXX is DM5, SHA1, or SHA256)</code>: If found, it compares the size stored in it to the hash code of <code>localFile</code>.</li>\n\t * </ul>\n\t * If any of these comparisons fail, the function returns <code>false</code>. otherwise it returns true.\n\t * <p>\n\t * <b>N.B.</b> None of the 3 common verification hashing algorithms are implement yet.\n\t * @param localFile The file to validate\n\t * @return <code>false</code> if any of the size or hash code metadata files exists but its contents does not match the expected value in the file, <code>true</code> otherwise.\n\t * @since 7.0.0\n\t */\n\tpublic static boolean validateFile(File localFile) {\n\t\tFile sizeFile = new File(localFile.getParentFile(), localFile.getName() + SIZE_EXT);\n\t\tif(sizeFile.exists()) {\n\t\t\tScanner scanner = null;\n\t\t\ttry {\n\t\t\t\tscanner = new Scanner(sizeFile);\n\t\t\t\tlong expectedSize = scanner.nextLong();\n\t\t\t\tlong actualLSize = localFile.length();\n\t\t\t\tif (expectedSize != actualLSize) {\n\t\t\t\t\tlogger.warn(\"File [{}] size ({}) does not match expected size ({}).\", localFile, actualLSize, expectedSize);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tlogger.warn(\"could not validate size of file [{}] because no size metadata file exists.\", localFile);\n\t\t\t} finally {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t}\n\n\t\tFile[] hashFiles = localFile.getParentFile().listFiles(new FilenameFilter() {\n\t\t\tString hashPattern = String.format(\"%s%s_(%s|%s|%s)\", localFile.getName(), HASH_EXT, Hash.MD5, Hash.SHA1, Hash.SHA256);\n\t\t\t@Override\n\t\t\tpublic boolean accept(File dir, String name) {\n\t\t\t\treturn name.matches(hashPattern);\n\t\t\t}\n\t\t});\n\t\tif(hashFiles.length > 0) {\n\t\t\tFile hashFile = hashFiles[0];\n\t\t\tString name = hashFile.getName();\n\t\t\tString algo = name.substring(name.lastIndexOf('_') + 1);\n\t\t\tswitch (Hash.valueOf(algo)) {\n\t\t\tcase MD5:\n\t\t\tcase SHA1:\n\t\t\tcase SHA256:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not yet implemented\");\n\t\t\tcase UNKNOWN:\n\t\t\tdefault: // No need. Already checked above\n\t\t\t\tthrow new IllegalArgumentException(\"Hashing algorithm not known: \" + algo);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Converts path to Unix convention and adds a terminating slash if it was\n\t * omitted. \n\t *\n\t * @param path original platform dependent path\n\t * @return path in Unix convention\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic static String toUnixPath(String path) {\n\t\tString uPath = path;\n\t\tif (uPath.contains(\"\\\\\")) {\n\t\t\tuPath = uPath.replaceAll(\"\\\\\\\\\", \"/\");\n\t\t}\n\t\t// this should be removed, it's need since \"\\\" is added AtomCache code\n\t\tif (uPath.endsWith(\"//\")) {\n\t\t\tuPath = uPath.substring(0, uPath.length() - 1);\n\t\t}\n\t\tif (!uPath.endsWith(\"/\")) {\n\t\t\tuPath = uPath + \"/\";\n\t\t}\n\t\treturn uPath;\n\t}\n\n\t/**\n\t * Expands ~ in paths to the user's home directory.\n\t *\n\t * <p>\n\t * This does not work for some special cases for paths: Other users' homes\n\t * (~user/...), and Tilde expansion within the path (/.../~/...). In these cases\n\t *  the original argument is returned.\n\t *\n\t * @param file A filepath starting with a tilde\n\t * @return An absolute path\n\t */\n\tpublic static String expandUserHome(String file) {\n\t\t// replace any / with the proper separator (/ or \\ for Linux and Windows respectively).\n\t\tfile = file.replaceAll(\"/\", \"\\\\\"+File.separator); //The \"\\\\\" is to escape the separator if needed.\n\t\tif (file.startsWith(\"~\") && (file.length() == 1 || File.separator.equals(file.substring(1, 2)))) {\n\t\t\tfile = System.getProperty(\"user.home\") + file.substring(1);\n\t\t}\n\t\treturn file;\n\t}\n\n\t/**\n\t * Pings a HTTP URL. This effectively sends a HEAD request and returns\n\t * <code>true</code> if the response code is in the 200-399 range.\n\t *\n\t * @param url The HTTP URL to be pinged.\n\t * @param timeout The timeout in millis for both the connection timeout and\n\t * the response read timeout. Note that the total timeout is effectively two\n\t * times the given timeout.\n\t * @return <code>true</code> if the given HTTP URL has returned response\n\t * code 200-399 on a HEAD request within the given timeout, otherwise\n\t * <code>false</code>.\n\t * @author BalusC,\n\t * http://stackoverflow.com/questions/3584210/preferred-java-way-to-ping-a-http-url-for-availability\n\t */\n\tpublic static boolean ping(String url, int timeout) {\n\t\t//url = url.replaceFirst(\"https\", \"http\"); // Otherwise an exception may be thrown on invalid SSL certificates.\n\n\t\ttry {\n\t\t\tHttpURLConnection connection = (HttpURLConnection) prepareURLConnection(url, timeout);\n\t\t\tconnection.setRequestMethod(\"HEAD\");\n\t\t\tint responseCode = connection.getResponseCode();\n\t\t\treturn (200 <= responseCode && responseCode <= 399);\n\t\t} catch (IOException exception) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Prepare {@link URLConnection} with customised timeouts.\n\t *\n\t * @param url The URL\n\t * @param timeout The timeout in millis for both the connection timeout and\n\t * the response read timeout. Note that the total timeout is effectively two\n\t * times the given timeout.\n\t *\n\t * <p>\n\t * Example of code.      <code>\n\t\t * UrlConnection conn = prepareURLConnection(\"http://www.google.com/\", 20000);\n\t * conn.connect();\n\t * conn.getInputStream();\n\t * </code>\n\t * <p>\n\t *\n\t * <bold>NB. User should execute connect() method before getting input\n\t * stream.</bold>\n\t * @return\n\t * @throws IOException\n\t * @author Jacek Grzebyta\n\t */\n\tpublic static URLConnection prepareURLConnection(String url, int timeout) throws IOException {\n\t\tURLConnection connection = new URL(url).openConnection();\n\t\tconnection.setReadTimeout(timeout);\n\t\tconnection.setConnectTimeout(timeout);\n\t\treturn connection;\n\t}\n\n\t/**\n\t * Recursively delete a folder & contents\n\t *\n\t * @param dir directory to delete\n\t */\n\tpublic static void deleteDirectory(Path dir) throws IOException {\n\t\tif(dir == null || !Files.exists(dir))\n\t\t\treturn;\n\t\tFiles.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n\t        @Override\n\t        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t            Files.delete(file);\n\t            return FileVisitResult.CONTINUE;\n\t        }\n\n\t        @Override\n\t        public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n\t            if (e != null) {\n\t                throw e;\n\t            }\n\t            Files.delete(dir);\n\t            return FileVisitResult.CONTINUE;\n\t        }\n\t    });\n\t}\n\t/**\n\t * Recursively delete a folder & contents\n\t *\n\t * @param dir directory to delete\n\t */\n\tpublic static void deleteDirectory(String dir) throws IOException {\n\t\tdeleteDirectory(Paths.get(dir));\n\t}\n\n}\n","changedPro":"/**\n * BioJava development code\n *\n * This code may be freely distributed and modified under the terms of the GNU\n * Lesser General Public Licence. This should be distributed with the code. If\n * you do not have a copy, see:\n *\n * http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual authors. These\n * should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims, or to join the\n * biojava-l mailing list, visit the home page at:\n *\n * http://www.biojava.org/\n *\n * Created on Feb 23, 2012 Created by Andreas Prlic\n *\n * @since 3.0.2\n */\npackage org.biojava.nbio.core.util;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.net.HttpURLConnection;\nimport java.net.SocketTimeoutException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.SimpleFileVisitor;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Scanner;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class FileDownloadUtils {\n\n\tprivate static final String SIZE_EXT = \".size\";\n\tprivate static final String HASH_EXT = \".hash\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(FileDownloadUtils.class);\n\n\tpublic enum Hash{\n\t\tMD5, SHA1, SHA256, UNKNOWN\n\t}\n\n\t/**\n\t * Copy the content of file src to dst TODO since java 1.7 this is provided\n\t * in java.nio.file.Files\n\t *\n\t * @param src\n\t * @param dst\n\t * @throws IOException\n\t */\n\t@SuppressWarnings(\"resource\")\n\tpublic static void copy(File src, File dst) throws IOException {\n\n\t\t// Took following recipe from\n\t\t// http://stackoverflow.com/questions/106770/standard-concise-way-to-copy-a-file-in-java\n\t\t// The nio package seems to be the most efficient way to copy a file\n\t\tFileChannel source = null;\n\t\tFileChannel destination = null;\n\n\t\ttry {\n\t\t\t// we need the supress warnings here (the warning that the stream is not closed is harmless)\n\t\t\t// see http://stackoverflow.com/questions/12970407/does-filechannel-close-close-the-underlying-stream\n\t\t\tsource = new FileInputStream(src).getChannel();\n\t\t\tdestination = new FileOutputStream(dst).getChannel();\n\t\t\tdestination.transferFrom(source, 0, source.size());\n\t\t} finally {\n\t\t\tif (source != null) {\n\t\t\t\tsource.close();\n\t\t\t}\n\t\t\tif (destination != null) {\n\t\t\t\tdestination.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the file extension of a file, excluding '.'.\n\t * If the file name has no extension the file name is returned.\n\t * @param f a File\n\t * @return The extension\n\t */\n\tpublic static String getFileExtension(File f) {\n\t\tString fileName = f.getName();\n\t\tString ext = \"\";\n\t\tint mid = fileName.lastIndexOf(\".\");\n\t\text = fileName.substring(mid + 1, fileName.length());\n\t\treturn ext;\n\t}\n\n\t/**\n\t * Gets the file name up to and excluding the first\n\t * '.' character. If there is no extension, the full filename\n\t * is returned.\n\t * @param f A file\n\t * @return A possibly empty but non-null String.\n\t */\n\tpublic static String getFilePrefix(File f) {\n\t\tString fileName = f.getName();\n\t\tint mid = fileName.indexOf(\".\");\n\t\tif (mid < 0) {\n\t\t\treturn fileName;\n\t\t}\n\t\treturn fileName.substring(0, mid);\n\t}\n\n\t/**\n\t * Download the content provided at URL url and store the result to a local\n\t * file, using a temp file to cache the content in case something goes wrong\n\t * in download. A timeout of 60 seconds is hard-coded and 10 retries are attempted.\n\t *\n\t * @param url\n\t * @param destination\n\t * @throws IOException\n\t */\n\tpublic static void downloadFile(URL url, File destination) throws IOException {\n\t\tint count = 0;\n\t\tint maxTries = 10;\n\t\tint timeout = 60000; //60 sec\n\n\t\tFile tempFile = Files.createTempFile(getFilePrefix(destination), \".\" + getFileExtension(destination)).toFile();\n\n\t\t// Took following recipe from stackoverflow:\n\t\t// http://stackoverflow.com/questions/921262/how-to-download-and-save-a-file-from-internet-using-java\n\t\t// It seems to be the most efficient way to transfer a file\n\t\t// See: http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\n\t\tReadableByteChannel rbc = null;\n\t\tFileOutputStream fos = null;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tURLConnection connection = prepareURLConnection(url.toString(), timeout);\n\t\t\t\tconnection.connect();\n\t\t\t\tInputStream inputStream = connection.getInputStream();\n\n\t\t\t\trbc = Channels.newChannel(inputStream);\n\t\t\t\tfos = new FileOutputStream(tempFile);\n\t\t\t\tfos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n\t\t\t\tbreak;\n\t\t\t} catch (SocketTimeoutException e) {\n\t\t\t\tif (++count == maxTries) throw e;\n\t\t\t} finally {\n\t\t\t\tif (rbc != null) {\n\t\t\t\t\trbc.close();\n\t\t\t\t}\n\t\t\t\tif (fos != null) {\n\t\t\t\t\tfos.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"Copying temp file [{}] to final location [{}]\", tempFile, destination);\n\t\tcopy(tempFile, destination);\n\n\t\t// delete the tmp file\n\t\ttempFile.delete();\n\n\t}\n\t\n\t/**\n\t * Creates validation files beside a file to be downloaded.<br>\n\t * Whenever possible, for a <code>file.ext</code> file, it creates \n\t * <code>file.ext.size</code> and <code>file.hash</code> for in the same \n\t * folder where <code>file.ext</code> exists.\n\t * If the file connection size could not be deduced from the URL, no size file is created. \n\t * If <code>hashURL</code> is <code>null</code>, no hash file is created.\n\t * @param url the remote file URL to download\n\t * @param localDestination the local file to download into\n\t * @param hashURL the URL of the hash file to download. Can be <code>null</code>.\n\t * @param hash The Hashing algorithm. Ignored if <code>hashURL</code> is <code>null</code>.\n\t */\n\tpublic static void createValidationFiles(URL url, File localDestination, URL hashURL, Hash hash){\n\t\ttry {\n\t\t\tURLConnection resourceConnection = url.openConnection();\n\t\t\tcreateValidationFiles(resourceConnection, localDestination, hashURL, FileDownloadUtils.Hash.UNKNOWN);\n\t\t} catch (IOException e) {\n\t\t\tlogger.warn(\"could not open connection to resource file due to exception: {}\", e.getMessage());\n\t\t}\n\t}\n\t/**\n\t * Creates validation files beside a file to be downloaded.<br>\n\t * Whenever possible, for a <code>file.ext</code> file, it creates \n\t * <code>file.ext.size</code> and <code>file.hash_XXXX</code> in the same \n\t * folder where <code>file.ext</code> exists (XXXX may be DM5, SHA1, or SHA256).\n\t * If the file connection size could not be deduced from the resourceUrlConnection \n\t * {@link URLConnection}, no size file is created. \n\t * If <code>hashURL</code> is <code>null</code>, no hash file is created.<br>\n\t * <b>N.B.</b> None of the hashing algorithms is implemented (yet), because we did not need any of them yet.\n\t * @param resourceUrlConnection the remote file URLConnection to download\n\t * @param localDestination the local file to download into\n\t * @param hashURL the URL of the hash file to download. Can be <code>null</code>.\n\t * @param hash The Hashing algorithm. Ignored if <code>hashURL</code> is <code>null</code>.\n\t * @since 7.0.0\n\t */\n\tpublic static void createValidationFiles(URLConnection resourceUrlConnection, File localDestination, URL hashURL, Hash hash){\n\t\tlong size = resourceUrlConnection.getContentLengthLong();\n\t\tif(size == -1) {\n\t\t\tlogger.warn(\"could not find expected file size for resource {}.\", resourceUrlConnection.getURL());\n\t\t} else {\n\t\t\tlogger.debug(\"Content-Length: {}\", size);\n\t\t\tFile sizeFile = new File(localDestination.getParentFile(), localDestination.getName() + SIZE_EXT);\n\t\t\ttry (PrintStream sizePrintStream = new PrintStream(sizeFile)) {\n\t\t\t\tsizePrintStream.print(size);\n\t\t\t\tsizePrintStream.close();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tlogger.warn(\"could not write size validation file due to exception: {}\", e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(hashURL == null)\n\t\t\treturn;\n\n\t\tif(hash == Hash.UNKNOWN)\n\t\t\tthrow new IllegalArgumentException(\"Hash URL given but algorithm is unknown\");\n\t\ttry {\n\t\t\tFile hashFile = new File(localDestination.getParentFile(), String.format(\"%s%s_%s\", localDestination.getName(), HASH_EXT, hash));\n\t\t\tdownloadFile(hashURL, hashFile);\n\t\t} catch (IOException e) {\n\t\t\tlogger.warn(\"could not write validation hash file due to exception: {}\", e.getMessage());\n\t\t}\n\t}\n\t\n\t/**\n\t * Validate a local file based on pre-existing metadata files for size and hash.<br>\n\t * If the passed in <code>localFile</code> parameter is a file named <code>file.ext</code>, the function searches in the same folder for:\n\t * <ul>\n\t * <li><code>file.ext.size</code>: If found, it compares the size stored in it to the length of <code>localFile</code> (in bytes).</li>\n\t * <li><code>file.ext.hash_XXXX (where XXXX is DM5, SHA1, or SHA256)</code>: If found, it compares the size stored in it to the hash code of <code>localFile</code>.</li>\n\t * </ul>\n\t * If any of these comparisons fail, the function returns <code>false</code>. otherwise it returns true.\n\t * <p>\n\t * <b>N.B.</b> None of the 3 common verification hashing algorithms are implement yet.\n\t * @param localFile The file to validate\n\t * @return <code>false</code> if any of the size or hash code metadata files exists but its contents does not match the expected value in the file, <code>true</code> otherwise.\n\t * @since 7.0.0\n\t */\n\tpublic static boolean validateFile(File localFile) {\n\t\tFile sizeFile = new File(localFile.getParentFile(), localFile.getName() + SIZE_EXT);\n\t\tif(sizeFile.exists()) {\n\t\t\tScanner scanner = null;\n\t\t\ttry {\n\t\t\t\tscanner = new Scanner(sizeFile);\n\t\t\t\tlong expectedSize = scanner.nextLong();\n\t\t\t\tlong actualLSize = localFile.length();\n\t\t\t\tif (expectedSize != actualLSize) {\n\t\t\t\t\tlogger.warn(\"File [{}] size ({}) does not match expected size ({}).\", localFile, actualLSize, expectedSize);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tlogger.warn(\"could not validate size of file [{}] because no size metadata file exists.\", localFile);\n\t\t\t} finally {\n\t\t\t\tscanner.close();\n\t\t\t}\n\t\t}\n\n\t\tFile[] hashFiles = localFile.getParentFile().listFiles(new FilenameFilter() {\n\t\t\tString hashPattern = String.format(\"%s%s_(%s|%s|%s)\", localFile.getName(), HASH_EXT, Hash.MD5, Hash.SHA1, Hash.SHA256);\n\t\t\t@Override\n\t\t\tpublic boolean accept(File dir, String name) {\n\t\t\t\treturn name.matches(hashPattern);\n\t\t\t}\n\t\t});\n\t\tif(hashFiles.length > 0) {\n\t\t\tFile hashFile = hashFiles[0];\n\t\t\tString name = hashFile.getName();\n\t\t\tString algo = name.substring(name.lastIndexOf('_') + 1);\n\t\t\tswitch (Hash.valueOf(algo)) {\n\t\t\tcase MD5:\n\t\t\tcase SHA1:\n\t\t\tcase SHA256:\n\t\t\t\tthrow new UnsupportedOperationException(\"Not yet implemented\");\n\t\t\tcase UNKNOWN:\n\t\t\tdefault: // No need. Already checked above\n\t\t\t\tthrow new IllegalArgumentException(\"Hashing algorithm not known: \" + algo);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Converts path to Unix convention and adds a terminating slash if it was\n\t * omitted. \n\t *\n\t * @param path original platform dependent path\n\t * @return path in Unix convention\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic static String toUnixPath(String path) {\n\t\tString uPath = path;\n\t\tif (uPath.contains(\"\\\\\")) {\n\t\t\tuPath = uPath.replaceAll(\"\\\\\\\\\", \"/\");\n\t\t}\n\t\t// this should be removed, it's need since \"\\\" is added AtomCache code\n\t\tif (uPath.endsWith(\"//\")) {\n\t\t\tuPath = uPath.substring(0, uPath.length() - 1);\n\t\t}\n\t\tif (!uPath.endsWith(\"/\")) {\n\t\t\tuPath = uPath + \"/\";\n\t\t}\n\t\treturn uPath;\n\t}\n\n\t/**\n\t * Expands ~ in paths to the user's home directory.\n\t *\n\t * <p>\n\t * This does not work for some special cases for paths: Other users' homes\n\t * (~user/...), and Tilde expansion within the path (/.../~/...). In these cases\n\t *  the original argument is returned.\n\t *\n\t * @param file A filepath starting with a tilde\n\t * @return An absolute path\n\t */\n\tpublic static String expandUserHome(String file) {\n\t\t// replace any / with the proper separator (/ or \\ for Linux and Windows respectively).\n\t\tfile = file.replaceAll(\"/\", \"\\\\\"+File.separator); //The \"\\\\\" is to escape the separator if needed.\n\t\tif (file.startsWith(\"~\") && (file.length() == 1 || File.separator.equals(file.substring(1, 2)))) {\n\t\t\tfile = System.getProperty(\"user.home\") + file.substring(1);\n\t\t}\n\t\treturn file;\n\t}\n\n\t/**\n\t * Pings a HTTP URL. This effectively sends a HEAD request and returns\n\t * <code>true</code> if the response code is in the 200-399 range.\n\t *\n\t * @param url The HTTP URL to be pinged.\n\t * @param timeout The timeout in millis for both the connection timeout and\n\t * the response read timeout. Note that the total timeout is effectively two\n\t * times the given timeout.\n\t * @return <code>true</code> if the given HTTP URL has returned response\n\t * code 200-399 on a HEAD request within the given timeout, otherwise\n\t * <code>false</code>.\n\t * @author BalusC,\n\t * http://stackoverflow.com/questions/3584210/preferred-java-way-to-ping-a-http-url-for-availability\n\t */\n\tpublic static boolean ping(String url, int timeout) {\n\t\t//url = url.replaceFirst(\"https\", \"http\"); // Otherwise an exception may be thrown on invalid SSL certificates.\n\n\t\ttry {\n\t\t\tHttpURLConnection connection = (HttpURLConnection) prepareURLConnection(url, timeout);\n\t\t\tconnection.setRequestMethod(\"HEAD\");\n\t\t\tint responseCode = connection.getResponseCode();\n\t\t\treturn (200 <= responseCode && responseCode <= 399);\n\t\t} catch (IOException exception) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Prepare {@link URLConnection} with customised timeouts.\n\t *\n\t * @param url The URL\n\t * @param timeout The timeout in millis for both the connection timeout and\n\t * the response read timeout. Note that the total timeout is effectively two\n\t * times the given timeout.\n\t *\n\t * <p>\n\t * Example of code.      <code>\n\t\t * UrlConnection conn = prepareURLConnection(\"http://www.google.com/\", 20000);\n\t * conn.connect();\n\t * conn.getInputStream();\n\t * </code>\n\t * <p>\n\t *\n\t * <bold>NB. User should execute connect() method before getting input\n\t * stream.</bold>\n\t * @return\n\t * @throws IOException\n\t * @author Jacek Grzebyta\n\t */\n\tpublic static URLConnection prepareURLConnection(String url, int timeout) throws IOException {\n\t\tURLConnection connection = new URL(url).openConnection();\n\t\tconnection.setReadTimeout(timeout);\n\t\tconnection.setConnectTimeout(timeout);\n\t\treturn connection;\n\t}\n\n\t/**\n\t * Recursively delete a folder & contents\n\t *\n\t * @param dir directory to delete\n\t */\n\tpublic static void deleteDirectory(Path dir) throws IOException {\n\t\tif(dir == null || !Files.exists(dir))\n\t\t\treturn;\n\t\tFiles.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n\t        @Override\n\t        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n\t            Files.delete(file);\n\t            return FileVisitResult.CONTINUE;\n\t        }\n\n\t        @Override\n\t        public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n\t            if (e != null) {\n\t                throw e;\n\t            }\n\t            Files.delete(dir);\n\t            return FileVisitResult.CONTINUE;\n\t        }\n\t    });\n\t}\n\t/**\n\t * Recursively delete a folder & contents\n\t *\n\t * @param dir directory to delete\n\t */\n\tpublic static void deleteDirectory(String dir) throws IOException {\n\t\tdeleteDirectory(Paths.get(dir));\n\t}\n\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.biojava.nbio.core.util.FileDownloadUtils.getFileExtension;\nimport static org.biojava.nbio.core.util.FileDownloadUtils.getFilePrefix;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.net.URL;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nclass FileDownloadUtilsTest {\n\n    @Nested\n    class FileCopy {   \n        \n        private File createSrcFile () throws IOException {\n            byte [] toSave = new byte []{1,2,3,4,5};\n            File src = Files.createTempFile(\"test\", \".dat\").toFile();\n            try (FileOutputStream fos = new FileOutputStream(src);){\n                fos.write(toSave);\n            }\n            return src;\n        }\n\n        @Test\n        void copyFile() throws IOException {\n            File src = createSrcFile();\n            //sanity check\n            assertEquals(5, src.length());\n            File dest = Files.createTempFile(\"dest\", \".dat\").toFile();\n            assertEquals(0, dest.length());\n            FileDownloadUtils.copy(src, dest);\n            assertEquals(5, dest.length());\n\n            //original is unaffected\n            assertEquals(5, src.length());\n            \n            // bytes are identical\n            try (FileInputStream fis1 = new FileInputStream(src);\n                FileInputStream fis2 =  new FileInputStream(dest)) {\n                int b = -1;\n                while (( b = fis1.read()) != -1) {\n                    int b2 = fis2.read();\n                    assertEquals (b, b2);\n                }\n            }\n        }\n    }\n\n    @Nested\n    class FileExtension {\n        @Test\n        void getExtensionHappyCase(){\n            File someFile = new File(\"sequence.fasta\");\n            assertEquals(\"fasta\", getFileExtension(someFile));\n        }\n\n        @Test\n        void lastSuffixOnlyReturned(){\n            File someFile = new File(\"sequence.1.a.fasta\");\n            assertEquals(\"fasta\", getFileExtension(someFile));\n        }\n        \n        @Test\n        void fileNameEndingInDotReturnsEmptyString(){\n            File someFile = new File(\"noExtension.\");\n            assertEquals(\"\", getFileExtension(someFile));\n        }\n\n        @Test\n        void hiddenFile(){\n            File someFile = new File(\".m2\");\n            assertEquals(\"m2\", getFileExtension(someFile));\n        }\n\n        @Test\n        void noExtension(){\n            File someFile = new File(\"nameOnly\");\n            assertEquals(\"nameOnly\", getFileExtension(someFile));\n        }        \n    }\n\n    @Nested\n    class GetFilePrefix{\n        @Test\n        void standardFileName(){\n            File someFile = new File(\"sequence.fasta\");\n            assertEquals(\"sequence\", getFilePrefix(someFile));\n        }\n        @Test\n        void prefixIsUpToFirstDot(){\n            File someFile = new File(\"sequence.1.2.fasta\");\n            assertEquals(\"sequence\", getFilePrefix(someFile));\n        }\n\n        @Test\n        void noExtension(){\n            File someFile = new File(\"nameOnly\");\n            assertEquals(\"nameOnly\", getFilePrefix(someFile));\n        }\n\n        @Test\n        void hiddenFile(){\n            File someFile = new File(\".m2\");\n            assertEquals(\"\", getFilePrefix(someFile));\n        }\n    }\n\n    @Nested\n    class ToUnixPath {\n        @Test\n        void windowsToUnixAddsTrailingSlash(){\n            String winPath = \"C:\\\\a\\\\b\\\\c\";\n            assertEquals(\"C:/a/b/c/\", FileDownloadUtils.toUnixPath(winPath));\n        }\n        @Test\n        void unixPathReturnedUnchanged(){\n            String path = \"/a/b/c/\";\n            assertEquals(path, FileDownloadUtils.toUnixPath(path));\n        }\n    }\n\n    @Nested\n    class ExpandUserHome {\n        String currUserHome = System.getProperty(\"user.home\");\n        @Test\n        void minimalPath (){\n        \tString path=\"~\";\n        \tassertEquals(currUserHome, FileDownloadUtils.expandUserHome(path));\n        }\n        @Test\n        void simplePath (){\n            String path=\"~/sequence.gb\";\n            assertEquals(currUserHome+File.separator+\"sequence.gb\", FileDownloadUtils.expandUserHome(path));\n        }\n        @Test\n        void nestedPath (){\n            String path=\"~/a/b/c/sequence.gb\";\n            assertEquals(currUserHome+File.separator\n            \t\t+ \"a\" + File.separator \n            \t\t+ \"b\" + File.separator \n            \t\t+ \"c\" + File.separator \n            \t\t+ \"sequence.gb\", \n            \t\tFileDownloadUtils.expandUserHome(path));\n        }  \n    }\n\n    @Nested\n    class URLMethods {\n        final String availableUrl = \"https://www.google.com\";\n\n        @Test\n        void pingGoogleOK(){\n            assertTrue(FileDownloadUtils.ping(availableUrl, 1000));\n        }\n\n        @Test\n        void pingNonExistentFalse(){\n            assertFalse(FileDownloadUtils.ping(\"https://non-existent.biojava\", 1));\n        }\n    }\n    @Nested\n    class DeleteDirectory {\n\n        private File createDirectoryTree () throws IOException {\n\n            File tmpdir = Files.createTempDirectory(\"tmpDirPrefix\").toFile();\n            File child1 = new File(tmpdir, \"a\");\n            File child2 = new File(child1, \"b\");\n            File child3 = new File(child2, \"c\");\n            File f = new File(child3, \"seq.fa\");\n            child3.mkdirs();\n            f.createNewFile();\n            return tmpdir;\n        }\n\n        @Test\n        void deleteFolderTree() throws IOException{\n            File toDelete = createDirectoryTree();\n            assertTrue(toDelete.exists());\n\n            FileDownloadUtils.deleteDirectory(toDelete.getAbsolutePath());\n            assertFalse(toDelete.exists());\n        }\n    }\n    \n    @Nested\n    class CreateValidationFiles{\n    \t\n    \t@Test\n    \tvoid testValidationFiles() throws IOException{\n    \t\tURL sourceUrl = new URL(\"https://files.wwpdb.org/pub/pdb/data/structures/divided/mmCIF/45/145d.cif.gz\");\n    \t\tFile destFile = new File(System.getProperty(\"java.io.tmpdir\"), \"145d.cif.gz\");\n    \t\tFile sizeFile = new File(destFile.getParentFile(), destFile.getName()+\".size\");\n    \t\tFile hashFile = new File(destFile.getParentFile(), destFile.getName()+\".hash_MD5\");\n    \t\tSystem.out.println(destFile.getAbsolutePath());\n    \t\tdestFile.delete();\n    \t\tsizeFile.delete();\n    \t\thashFile.delete();\n    \t\tassertFalse(destFile.exists(), \"couldn't delete dest file\");\n    \t\tassertFalse(sizeFile.exists(), \"couldn't delete size file\");\n    \t\tassertFalse(hashFile.exists(), \"couldn't delete hash file\");\n    \t\t\n    \t\tFileDownloadUtils.downloadFile(sourceUrl, destFile);\n    \t\tassertTrue(destFile.exists(), \"couldn't create dest file\");\n\n    \t\tassertTrue(FileDownloadUtils.validateFile(destFile), \"file detected to be invalid although there are no validation files\");\n\n    \t\tPrintStream temp1 = new PrintStream(sizeFile);\n    \t\ttemp1.print(15); // some wrong size value\n    \t\ttemp1.close();\n    \t\tassertFalse(FileDownloadUtils.validateFile(destFile), \"file not detected to be invalid although size value is wrong.\");\n    \t\tSystem.out.println(\"Just ignore the previous warning. It is expected.\");\n    \t\t\n    \t\tFileDownloadUtils.createValidationFiles(sourceUrl, destFile, null, FileDownloadUtils.Hash.UNKNOWN);\n    \t\tassertTrue(sizeFile.exists(), \"couldn't create size file\");\n    \t\tassertTrue(FileDownloadUtils.validateFile(destFile), \"file not detected to be invalid although there is correct size validation file\");\n\n    \t\tPrintStream temp2 = new PrintStream(hashFile);\n    \t\ttemp2.print(\"ABCD\"); // some wrong hash value\n    \t\ttemp2.close();\n    \t\t//This is not yet implemented. I am using this test for documentation purpose.\n    \t\tassertThrows(UnsupportedOperationException.class, \n    \t\t\t\t() -> FileDownloadUtils.validateFile(destFile), \n    \t\t\t\t\"file not detected to be invalid although hash value is wrong.\");\n    \t\t\n    \t\tdestFile.delete();\n    \t\tsizeFile.delete();\n    \t\thashFile.delete();\n    \t}\n    }\n}\n","changedTest":"","commitMessage":"fix sonar issue 2629 Logging arguments should not require evaluation\n","test_commitMessage":"","allZero":false}