{"repository":"biojava","prod_path":"biojava-alignment/src/main/java/org/biojava3/alignment/SimpleAlignedSequence.java","test_path":"biojava-alignment/src/test/java/org/biojava3/alignment/SimpleAlignedSequenceTest.java","prod_time":"2015-01-30 06:34:57","test_time":"2015-01-30 06:34:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":5,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":9,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","test_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.location.template.Point;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\nimport org.biojava3.core.sequence.template.SequenceMixin;\nimport org.biojava3.core.sequence.template.SequenceView;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<S extends Sequence<C>, C extends Compound> implements AlignedSequence<S, C> {\n\n    private static final String gap = \"-\";\n\n    // always stored\n    private AlignedSequence<S, C> prev;\n    private S original;\n    private int length, numBefore, numAfter;\n    private Location location;\n\n    // cached (lazily initialized)\n    private int numGaps = -1;\n    private int[] alignmentFromSequence, sequenceFromAlignment;\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(S original, List<Step> steps) {\n        this(original, steps, 0, 0);\n    }\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(S original, List<Step> steps, int numBefore, int numAfter) {\n        this.original = original;\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    /**\n     * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a global alignment.\n     *\n     * @param prev the previous {@link AlignedSequence} before this alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps) {\n        this(prev, steps, 0, 0);\n    }\n\n    /**\n     * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a local alignment.\n     *\n     * @param prev the previous {@link AlignedSequence} before this alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps, int numBefore, int numAfter) {\n        this.prev = prev;\n        this.original = prev.getOriginalSequence();\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        if (prev instanceof SimpleAlignedSequence<?, ?>) {\n            SimpleAlignedSequence<?, ?> p = (SimpleAlignedSequence<?, ?>) prev;\n            this.numBefore += p.numBefore;\n            this.numAfter += p.numAfter;\n        }\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    // methods for AlignedSequence\n\n    @Override\n    public void clearCache() {\n        alignmentFromSequence = null;\n        sequenceFromAlignment = null;\n    }\n\n    @Override\n    public int getAlignmentIndexAt(int sequenceIndex) {\n        if (alignmentFromSequence == null) {\n            alignmentFromSequence = new int[original.getLength()];\n            int s = 1, a = 1;\n            for (int i = 0; i < numBefore; i++, s++) {\n                alignmentFromSequence[s - 1] = a;\n            }\n            for (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n                while (a <= length && isGap(a)) {\n                    a++;\n                }\n                alignmentFromSequence[s - 1] = a;\n            }\n            a--;\n            for (int i = 0; i < numAfter; i++, s++) {\n                alignmentFromSequence[s - 1] = a;\n            }\n        }\n        return alignmentFromSequence[sequenceIndex - 1];\n    }\n\n    @Override\n    public Point getEnd() {\n        return location.getEnd();\n    }\n\n    @Override\n    public Location getLocationInAlignment() {\n        return location;\n    }\n\n    @Override\n    public int getNumGaps() {\n        if (numGaps == -1) {\n            numGaps = 0;\n            C cGap = getCompoundSet().getCompoundForString(gap);\n            boolean inGap = false;\n            for (C compound : getAsList()) {\n                if (compound == null || compound.equalsIgnoreCase(cGap)) {\n                    if (!inGap) {\n                        numGaps++;\n                        inGap = true;\n                    }\n                } else {\n                    inGap = false;\n                }\n            }\n        }\n        return numGaps;\n    }\n\n    @Override\n    public S getOriginalSequence() {\n        return original;\n    }\n\n    @Override\n    public int getOverlapCount() {\n        // TODO handle circular alignments\n        return 1;\n    }\n\n    @Override\n    public int getSequenceIndexAt(int alignmentIndex) {\n        if (sequenceFromAlignment == null) {\n            sequenceFromAlignment = new int[length];\n            int a = 1, s = numBefore + 1;\n            for (int i = 0; i < getStart().getPosition(); i++, a++) {\n                sequenceFromAlignment[a - 1] = s;\n            }\n            for (; a <= length; a++) {\n                if (!isGap(a)) {\n                    s++;\n                }\n                sequenceFromAlignment[a - 1] = s;\n            }\n        }\n        return sequenceFromAlignment[alignmentIndex - 1];\n    }\n\n    @Override\n    public Point getStart() {\n        return location.getStart();\n    }\n\n    @Override\n    public boolean isCircular() {\n        return location.isCircular();\n    }\n\n    @Override\n    public boolean isGap(int alignmentIndex) {\n        if (getStart().getPosition() <= alignmentIndex && alignmentIndex <= getEnd().getPosition()) {\n            if (!location.isComplex()) {\n                return false;\n            }\n            for (Location sublocation : location) {\n                if (sublocation.getStart().getPosition() <= alignmentIndex &&\n                        alignmentIndex <= sublocation.getEnd().getPosition()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // methods for Sequence\n\n    @Override\n    public int countCompounds(C... compounds) {\n        int count = 0;\n        List<C> search = Arrays.asList(compounds);\n        for (C compound : getAsList()) {\n            if (search.contains(compound)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return original.getAccession();\n    }\n\n    @Override\n    public List<C> getAsList() {\n        List<C> compounds = new ArrayList<C>();\n        for (int i = 1; i <= length; i++) {\n            compounds.add(getCompoundAt(i));\n        }\n        return compounds;\n    }\n\n    @Override\n    public C getCompoundAt(int alignmentIndex) {\n        return alignmentIndex >= 1 && alignmentIndex <= length && isGap(alignmentIndex) ?\n                getCompoundSet().getCompoundForString(gap) :\n                original.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return original.getCompoundSet();\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return SequenceMixin.toString(this);\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(Integer start, Integer end) {\n        return SequenceMixin.createSubSequence(this, start, end);\n    }\n\n    // method for Iterable\n\n    @Override\n    public Iterator<C> iterator() {\n        return getAsList().iterator();\n    }\n\n    // method from Object\n\n    /**\n     * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n     */\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    // helper method to initialize the location\n    private void setLocation(List<Step> steps) {\n        List<Location> sublocations = new ArrayList<Location>();\n        int start = 0, step = 0, oStep = numBefore+numAfter, oMax = this.original.getLength(), pStep = 0, pMax =\n                (prev == null) ? 0 : prev.getLength();\n        boolean inGap = true;\n\n        // build sublocations: pieces of sequence separated by gaps\n        for (; step < length; step++) {\n            boolean isGapStep = (steps.get(step) == Step.GAP),\n                    isGapPrev = (pStep < pMax && prev.isGap(pStep + 1));\n            if (!isGapStep && !isGapPrev) {\n                oStep++;\n                if (inGap) {\n                    inGap = false;\n                    start = step + 1;\n                }\n            } else if (!inGap) {\n                inGap = true;\n                sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n            }\n            if (prev != null && !isGapStep) {\n                pStep++;\n            }\n        }\n        if (!inGap) {\n            sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n        }\n\n        // combine sublocations into 1 Location\n        if (sublocations.size() == 0) {\n        \tlocation = null;\n        } else if (sublocations.size() == 1) {\n        \tlocation = sublocations.get(0);\n        } else {\n        \tlocation = new SimpleLocation(sublocations.get(0).getStart(), sublocations.get(sublocations.size() - 1).getEnd(),\n        \t\t\tStrand.UNDEFINED,\n                    false, sublocations);\n        }\n        // TODO handle circular alignments\n\n        // check that alignment has correct number of compounds in it to fit original sequence\n        if (step != length || oStep != oMax || pStep != pMax) {\n            throw new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n        }\n    }\n\n    @Override\n    //TODO Needs to implements\n    public SequenceView<C> getInverse() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.location.template.Point;\nimport org.biojava3.core.sequence.template.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<S extends Sequence<C>, C extends Compound> implements AlignedSequence<S, C> {\n\n    private static final String gap = \"-\";\n\n    // always stored\n    private AlignedSequence<S, C> prev;\n    private S original;\n    private int length, numBefore, numAfter;\n    private Location location;\n\n    // cached (lazily initialized)\n    private int numGaps = -1;\n    private int[] alignmentFromSequence, sequenceFromAlignment;\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(S original, List<Step> steps) {\n        this(original, steps, 0, 0);\n    }\n\n    /**\n     * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n     *\n     * @param original the original {@link Sequence} before alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(S original, List<Step> steps, int numBefore, int numAfter) {\n        this.original = original;\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    /**\n     * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a global alignment.\n     *\n     * @param prev the previous {@link AlignedSequence} before this alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps) {\n        this(prev, steps, 0, 0);\n    }\n\n    /**\n     * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a local alignment.\n     *\n     * @param prev the previous {@link AlignedSequence} before this alignment\n     * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param numBefore number of {@link Compound}s before a local alignment\n     * @param numAfter number of {@link Compound}s after a local alignment\n     * @throws IllegalArgumentException if given sequence does not fit in alignment\n     */\n    public SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps, int numBefore, int numAfter) {\n        this.prev = prev;\n        this.original = prev.getOriginalSequence();\n        this.numBefore = numBefore;\n        this.numAfter = numAfter;\n        if (prev instanceof SimpleAlignedSequence<?, ?>) {\n            SimpleAlignedSequence<?, ?> p = (SimpleAlignedSequence<?, ?>) prev;\n            this.numBefore += p.numBefore;\n            this.numAfter += p.numAfter;\n        }\n        length = steps.size();\n        setLocation(steps);\n    }\n\n    // methods for AlignedSequence\n\n    @Override\n    public void clearCache() {\n        alignmentFromSequence = null;\n        sequenceFromAlignment = null;\n    }\n\n    @Override\n    public int getAlignmentIndexAt(int sequenceIndex) {\n        if (alignmentFromSequence == null) {\n            alignmentFromSequence = new int[original.getLength()];\n            int s = 1, a = 1;\n            for (int i = 0; i < numBefore; i++, s++) {\n                alignmentFromSequence[s - 1] = a;\n            }\n            for (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n                while (a <= length && isGap(a)) {\n                    a++;\n                }\n                alignmentFromSequence[s - 1] = a;\n            }\n            a--;\n            for (int i = 0; i < numAfter; i++, s++) {\n                alignmentFromSequence[s - 1] = a;\n            }\n        }\n        return alignmentFromSequence[sequenceIndex - 1];\n    }\n\n    @Override\n    public Point getEnd() {\n        return location.getEnd();\n    }\n\n    @Override\n    public Location getLocationInAlignment() {\n        return location;\n    }\n\n    @Override\n    public int getNumGaps() {\n        if (numGaps == -1) {\n            numGaps = 0;\n            C cGap = getCompoundSet().getCompoundForString(gap);\n            boolean inGap = false;\n            for (C compound : getAsList()) {\n                if (compound == null || compound.equalsIgnoreCase(cGap)) {\n                    if (!inGap) {\n                        numGaps++;\n                        inGap = true;\n                    }\n                } else {\n                    inGap = false;\n                }\n            }\n        }\n        return numGaps;\n    }\n\n    @Override\n    public S getOriginalSequence() {\n        return original;\n    }\n\n    @Override\n    public int getOverlapCount() {\n        // TODO handle circular alignments\n        return 1;\n    }\n\n    @Override\n    public int getSequenceIndexAt(int alignmentIndex) {\n        if (sequenceFromAlignment == null) {\n            sequenceFromAlignment = new int[length];\n            int a = 1, s = numBefore + 1;\n            for (int i = 0; i < getStart().getPosition(); i++, a++) {\n                sequenceFromAlignment[a - 1] = s;\n            }\n            for (; a <= length; a++) {\n                if (!isGap(a)) {\n                    s++;\n                }\n                sequenceFromAlignment[a - 1] = s;\n            }\n        }\n        return sequenceFromAlignment[alignmentIndex - 1];\n    }\n\n    @Override\n    public Point getStart() {\n        return location.getStart();\n    }\n\n    @Override\n    public boolean isCircular() {\n        return location.isCircular();\n    }\n\n    @Override\n    public boolean isGap(int alignmentIndex) {\n        if (getStart().getPosition() <= alignmentIndex && alignmentIndex <= getEnd().getPosition()) {\n            if (!location.isComplex()) {\n                return false;\n            }\n            for (Location sublocation : location) {\n                if (sublocation.getStart().getPosition() <= alignmentIndex &&\n                        alignmentIndex <= sublocation.getEnd().getPosition()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // methods for Sequence\n\n    @Override\n    public int countCompounds(C... compounds) {\n        int count = 0;\n        List<C> search = Arrays.asList(compounds);\n        for (C compound : getAsList()) {\n            if (search.contains(compound)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    @Override\n    public AccessionID getAccession() {\n        return original.getAccession();\n    }\n\n    @Override\n    public List<C> getAsList() {\n        List<C> compounds = new ArrayList<C>();\n        for (int i = 1; i <= length; i++) {\n            compounds.add(getCompoundAt(i));\n        }\n        return compounds;\n    }\n\n    @Override\n    public C getCompoundAt(int alignmentIndex) {\n        return alignmentIndex >= 1 && alignmentIndex <= length && isGap(alignmentIndex) ?\n                getCompoundSet().getCompoundForString(gap) :\n                original.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return original.getCompoundSet();\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (compound.equals(getCompoundAt(i))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public String getSequenceAsString() {\n        return SequenceMixin.toString(this);\n    }\n\n    @Override\n    public SequenceView<C> getSubSequence(Integer start, Integer end) {\n        return SequenceMixin.createSubSequence(this, start, end);\n    }\n\n    // method for Iterable\n\n    @Override\n    public Iterator<C> iterator() {\n        return getAsList().iterator();\n    }\n\n    // method from Object\n\n    /**\n     * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n     */\n    @Override\n    public String toString() {\n        return getSequenceAsString();\n    }\n\n    // helper method to initialize the location\n    private void setLocation(List<Step> steps) {\n        List<Location> sublocations = new ArrayList<Location>();\n        int start = 0, step = 0, oStep = numBefore+numAfter, oMax = this.original.getLength(), pStep = 0, pMax =\n                (prev == null) ? 0 : prev.getLength();\n        boolean inGap = true;\n\n        // build sublocations: pieces of sequence separated by gaps\n        for (; step < length; step++) {\n            boolean isGapStep = (steps.get(step) == Step.GAP),\n                    isGapPrev = (pStep < pMax && prev.isGap(pStep + 1));\n            if (!isGapStep && !isGapPrev) {\n                oStep++;\n                if (inGap) {\n                    inGap = false;\n                    start = step + 1;\n                }\n            } else if (!inGap) {\n                inGap = true;\n                sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n            }\n            if (prev != null && !isGapStep) {\n                pStep++;\n            }\n        }\n        if (!inGap) {\n            sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n        }\n\n        // combine sublocations into 1 Location\n        if (sublocations.size() == 0) {\n        \tlocation = null;\n        } else if (sublocations.size() == 1) {\n        \tlocation = sublocations.get(0);\n        } else {\n        \tlocation = new SimpleLocation(sublocations.get(0).getStart(), sublocations.get(sublocations.size() - 1).getEnd(),\n        \t\t\tStrand.UNDEFINED,\n                    false, sublocations);\n        }\n        // TODO handle circular alignments\n\n        // check that alignment has correct number of compounds in it to fit original sequence\n        if (step != length || oStep != oMax || pStep != pMax) {\n            throw new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n        }\n    }\n\n    @Override\n    //TODO Needs to implements\n    public SequenceView<C> getInverse() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class SimpleAlignedSequenceTest {\n\n    private ProteinSequence go, lo;\n    private AlignedSequence<ProteinSequence, AminoAcidCompound> global, local, local2;\n    private AminoAcidCompoundSet cs;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        go = new ProteinSequence(\"ARND\");\n        lo = new ProteinSequence(\"CEQGHILKM\");\n        global = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n                Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n        local = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND,\n                Step.COMPOUND}), 1, 3);\n        local2 = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0);\n        cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLocal() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLong() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceShort() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test\n    public void testGetAlignmentIndexAt() {\n        assertEquals(global.getAlignmentIndexAt(1), 2);\n        assertEquals(global.getAlignmentIndexAt(2), 3);\n        assertEquals(global.getAlignmentIndexAt(3), 5);\n        assertEquals(global.getAlignmentIndexAt(4), 6);\n        assertEquals(local.getAlignmentIndexAt(1), 1);\n        assertEquals(local.getAlignmentIndexAt(2), 1);\n        assertEquals(local.getAlignmentIndexAt(3), 2);\n        assertEquals(local.getAlignmentIndexAt(4), 5);\n        assertEquals(local.getAlignmentIndexAt(5), 7);\n        assertEquals(local.getAlignmentIndexAt(6), 8);\n        assertEquals(local.getAlignmentIndexAt(7), 8);\n        assertEquals(local.getAlignmentIndexAt(8), 8);\n        assertEquals(local.getAlignmentIndexAt(9), 8);\n        assertEquals(local2.getAlignmentIndexAt(1), 1);\n        assertEquals(local2.getAlignmentIndexAt(2), 1);\n        assertEquals(local2.getAlignmentIndexAt(3), 2);\n        assertEquals(local2.getAlignmentIndexAt(4), 3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds() {\n        global.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds2() {\n        global.getAlignmentIndexAt(5);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds3() {\n        local.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds4() {\n        local.getAlignmentIndexAt(10);\n    }\n\n    @Test\n    public void testGetEnd() {\n        assertEquals(global.getEnd().getPosition(), Integer.valueOf(6));\n        assertEquals(local.getEnd().getPosition(), Integer.valueOf(8));\n        assertEquals(local2.getEnd().getPosition(), Integer.valueOf(3));\n    }\n\n    @Test\n    public void testGetLocationInAlignment() {\n        assertEquals(global.getLocationInAlignment(), new SimpleLocation(2, 6, Strand.UNDEFINED,\n                new SimpleLocation(2, 3, Strand.UNDEFINED), new SimpleLocation(5, 6, Strand.UNDEFINED)));\n        assertEquals(local.getLocationInAlignment(), new SimpleLocation(1, 8, Strand.UNDEFINED,\n                new SimpleLocation(1, 2, Strand.UNDEFINED), new SimpleLocation(5, 5, Strand.UNDEFINED),\n                new SimpleLocation(7, 8, Strand.UNDEFINED)));\n        assertEquals(local2.getLocationInAlignment(), new SimpleLocation(1, 3, Strand.UNDEFINED));\n    }\n\n    @Test\n    public void testGetNumGaps() {\n        assertEquals(global.getNumGaps(), 3);\n        assertEquals(local.getNumGaps(), 2);\n        assertEquals(local2.getNumGaps(), 0);\n    }\n\n    @Test\n    public void testGetOriginalSequence() {\n        assertEquals(global.getOriginalSequence(), go);\n        assertEquals(local.getOriginalSequence(), lo);\n        assertEquals(local2.getOriginalSequence(), go);\n    }\n\n    @Test\n    public void testGetOverlapCount() {\n        assertEquals(global.getOverlapCount(), 1);\n        assertEquals(local.getOverlapCount(), 1);\n        assertEquals(local2.getOverlapCount(), 1);\n    }\n\n    @Test\n    public void testGetSequenceIndexAt() {\n        assertEquals(global.getSequenceIndexAt(1), 1);\n        assertEquals(global.getSequenceIndexAt(2), 1);\n        assertEquals(global.getSequenceIndexAt(3), 2);\n        assertEquals(global.getSequenceIndexAt(4), 2);\n        assertEquals(global.getSequenceIndexAt(5), 3);\n        assertEquals(global.getSequenceIndexAt(6), 4);\n        assertEquals(global.getSequenceIndexAt(7), 4);\n        assertEquals(local.getSequenceIndexAt(1), 2);\n        assertEquals(local.getSequenceIndexAt(2), 3);\n        assertEquals(local.getSequenceIndexAt(3), 3);\n        assertEquals(local.getSequenceIndexAt(4), 3);\n        assertEquals(local.getSequenceIndexAt(5), 4);\n        assertEquals(local.getSequenceIndexAt(6), 4);\n        assertEquals(local.getSequenceIndexAt(7), 5);\n        assertEquals(local.getSequenceIndexAt(8), 6);\n        assertEquals(local2.getSequenceIndexAt(1), 2);\n        assertEquals(local2.getSequenceIndexAt(2), 3);\n        assertEquals(local2.getSequenceIndexAt(3), 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds() {\n        global.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds2() {\n        global.getSequenceIndexAt(8);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds3() {\n        local.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds4() {\n        local.getSequenceIndexAt(9);\n    }\n\n    @Test\n    public void testGetStart() {\n        assertEquals(global.getStart().getPosition(), Integer.valueOf(2));\n        assertEquals(local.getStart().getPosition(), Integer.valueOf(1));\n        assertEquals(local2.getStart().getPosition(), Integer.valueOf(1));\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(global.isCircular());\n        assertFalse(local.isCircular());\n        assertFalse(local2.isCircular());\n    }\n\n    @Test\n    public void testCountCompounds() {\n        assertEquals(global.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 1);\n        assertEquals(local2.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 2);\n    }\n\n    @Test\n    public void testGetAccession() {\n        assertNull(global.getAccession());\n        assertNull(local.getAccession());\n        assertNull(local2.getAccession());\n    }\n\n    @Test\n    public void testGetAsList() {\n        assertArrayEquals(global.getAsList().toArray(new AminoAcidCompound[7]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"R\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\"),\n            cs.getCompoundForString(\"-\")});\n        assertArrayEquals(local.getAsList().toArray(new AminoAcidCompound[8]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"Q\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"H\"), cs.getCompoundForString(\"I\")});\n        assertArrayEquals(local2.getAsList().toArray(new AminoAcidCompound[3]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"R\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\")});\n    }\n\n    @Test\n    public void testGetCompoundAt() {\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(2), cs.getCompoundForString(\"A\"));\n        assertEquals(global.getCompoundAt(3), cs.getCompoundForString(\"R\"));\n        assertEquals(global.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(5), cs.getCompoundForString(\"N\"));\n        assertEquals(global.getCompoundAt(6), cs.getCompoundForString(\"D\"));\n        assertEquals(global.getCompoundAt(7), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(1), cs.getCompoundForString(\"E\"));\n        assertEquals(local.getCompoundAt(2), cs.getCompoundForString(\"Q\"));\n        assertEquals(local.getCompoundAt(3), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(5), cs.getCompoundForString(\"G\"));\n        assertEquals(local.getCompoundAt(6), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(7), cs.getCompoundForString(\"H\"));\n        assertEquals(local.getCompoundAt(8), cs.getCompoundForString(\"I\"));\n        assertEquals(local2.getCompoundAt(1), cs.getCompoundForString(\"R\"));\n        assertEquals(local2.getCompoundAt(2), cs.getCompoundForString(\"N\"));\n        assertEquals(local2.getCompoundAt(3), cs.getCompoundForString(\"D\"));\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(global.getCompoundSet(), cs);\n        assertEquals(local.getCompoundSet(), cs);\n        assertEquals(local2.getCompoundSet(), cs);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 3);\n        assertEquals(local2.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local2.getIndexOf(cs.getCompoundForString(\"-\")), -1);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 7);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 6);\n        assertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"-\")), -1);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(global.getLength(), 7);\n        assertEquals(local.getLength(), 8);\n        assertEquals(local2.getLength(), 3);\n    }\n\n    @Test\n    public void testGetSequenceAsString() {\n        assertEquals(global.getSequenceAsString(), \"-AR-ND-\");\n        assertEquals(local.getSequenceAsString(), \"EQ--G-HI\");\n        assertEquals(local2.getSequenceAsString(), \"RND\");\n    }\n\n    @Test\n    public void testGetSequenceAsStringIntegerIntegerStrand() {\n        assertEquals(global.getSubSequence(2, 5).getSequenceAsString(), \"AR-N\");\n        assertEquals(local.getSubSequence(2, 6).getSequenceAsString(), \"Q--G-\");\n        assertEquals(local2.getSubSequence(2, 3).getSequenceAsString(), \"ND\");\n    }\n\n    @Ignore // TODO SimpleAlignedSequence.getSubSequence(Integer, Integer)\n    @Test\n    public void testGetSubSequence() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIterator() {\n        for (AminoAcidCompound c : global) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n        for (AminoAcidCompound c : local) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n        for (AminoAcidCompound c : local2) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(global.toString(), \"-AR-ND-\");\n        assertEquals(local.toString(), \"EQ--G-HI\");\n        assertEquals(local2.toString(), \"RND\");\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.Strand;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.location.SimpleLocation;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.*;\n\npublic class SimpleAlignedSequenceTest {\n\n    private ProteinSequence go, lo;\n    private AlignedSequence<ProteinSequence, AminoAcidCompound> global, local, local2;\n    private AminoAcidCompoundSet cs;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        go = new ProteinSequence(\"ARND\");\n        lo = new ProteinSequence(\"CEQGHILKM\");\n        global = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n                Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n        local = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND,\n                Step.COMPOUND}), 1, 3);\n        local2 = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0);\n        cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLocal() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {Step.COMPOUND,\n                Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceLong() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleAlignedSequenceShort() {\n        new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n                Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.GAP}));\n    }\n\n    @Test\n    public void testGetAlignmentIndexAt() {\n        assertEquals(global.getAlignmentIndexAt(1), 2);\n        assertEquals(global.getAlignmentIndexAt(2), 3);\n        assertEquals(global.getAlignmentIndexAt(3), 5);\n        assertEquals(global.getAlignmentIndexAt(4), 6);\n        assertEquals(local.getAlignmentIndexAt(1), 1);\n        assertEquals(local.getAlignmentIndexAt(2), 1);\n        assertEquals(local.getAlignmentIndexAt(3), 2);\n        assertEquals(local.getAlignmentIndexAt(4), 5);\n        assertEquals(local.getAlignmentIndexAt(5), 7);\n        assertEquals(local.getAlignmentIndexAt(6), 8);\n        assertEquals(local.getAlignmentIndexAt(7), 8);\n        assertEquals(local.getAlignmentIndexAt(8), 8);\n        assertEquals(local.getAlignmentIndexAt(9), 8);\n        assertEquals(local2.getAlignmentIndexAt(1), 1);\n        assertEquals(local2.getAlignmentIndexAt(2), 1);\n        assertEquals(local2.getAlignmentIndexAt(3), 2);\n        assertEquals(local2.getAlignmentIndexAt(4), 3);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds() {\n        global.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds2() {\n        global.getAlignmentIndexAt(5);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds3() {\n        local.getAlignmentIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignmentIndexAtOutOfBounds4() {\n        local.getAlignmentIndexAt(10);\n    }\n\n    @Test\n    public void testGetEnd() {\n        assertEquals(global.getEnd().getPosition(), Integer.valueOf(6));\n        assertEquals(local.getEnd().getPosition(), Integer.valueOf(8));\n        assertEquals(local2.getEnd().getPosition(), Integer.valueOf(3));\n    }\n\n    @Test\n    public void testGetLocationInAlignment() {\n        assertEquals(global.getLocationInAlignment(), new SimpleLocation(2, 6, Strand.UNDEFINED,\n                new SimpleLocation(2, 3, Strand.UNDEFINED), new SimpleLocation(5, 6, Strand.UNDEFINED)));\n        assertEquals(local.getLocationInAlignment(), new SimpleLocation(1, 8, Strand.UNDEFINED,\n                new SimpleLocation(1, 2, Strand.UNDEFINED), new SimpleLocation(5, 5, Strand.UNDEFINED),\n                new SimpleLocation(7, 8, Strand.UNDEFINED)));\n        assertEquals(local2.getLocationInAlignment(), new SimpleLocation(1, 3, Strand.UNDEFINED));\n    }\n\n    @Test\n    public void testGetNumGaps() {\n        assertEquals(global.getNumGaps(), 3);\n        assertEquals(local.getNumGaps(), 2);\n        assertEquals(local2.getNumGaps(), 0);\n    }\n\n    @Test\n    public void testGetOriginalSequence() {\n        assertEquals(global.getOriginalSequence(), go);\n        assertEquals(local.getOriginalSequence(), lo);\n        assertEquals(local2.getOriginalSequence(), go);\n    }\n\n    @Test\n    public void testGetOverlapCount() {\n        assertEquals(global.getOverlapCount(), 1);\n        assertEquals(local.getOverlapCount(), 1);\n        assertEquals(local2.getOverlapCount(), 1);\n    }\n\n    @Test\n    public void testGetSequenceIndexAt() {\n        assertEquals(global.getSequenceIndexAt(1), 1);\n        assertEquals(global.getSequenceIndexAt(2), 1);\n        assertEquals(global.getSequenceIndexAt(3), 2);\n        assertEquals(global.getSequenceIndexAt(4), 2);\n        assertEquals(global.getSequenceIndexAt(5), 3);\n        assertEquals(global.getSequenceIndexAt(6), 4);\n        assertEquals(global.getSequenceIndexAt(7), 4);\n        assertEquals(local.getSequenceIndexAt(1), 2);\n        assertEquals(local.getSequenceIndexAt(2), 3);\n        assertEquals(local.getSequenceIndexAt(3), 3);\n        assertEquals(local.getSequenceIndexAt(4), 3);\n        assertEquals(local.getSequenceIndexAt(5), 4);\n        assertEquals(local.getSequenceIndexAt(6), 4);\n        assertEquals(local.getSequenceIndexAt(7), 5);\n        assertEquals(local.getSequenceIndexAt(8), 6);\n        assertEquals(local2.getSequenceIndexAt(1), 2);\n        assertEquals(local2.getSequenceIndexAt(2), 3);\n        assertEquals(local2.getSequenceIndexAt(3), 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds() {\n        global.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds2() {\n        global.getSequenceIndexAt(8);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds3() {\n        local.getSequenceIndexAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetSequenceIndexAtOutOfBounds4() {\n        local.getSequenceIndexAt(9);\n    }\n\n    @Test\n    public void testGetStart() {\n        assertEquals(global.getStart().getPosition(), Integer.valueOf(2));\n        assertEquals(local.getStart().getPosition(), Integer.valueOf(1));\n        assertEquals(local2.getStart().getPosition(), Integer.valueOf(1));\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(global.isCircular());\n        assertFalse(local.isCircular());\n        assertFalse(local2.isCircular());\n    }\n\n    @Test\n    public void testCountCompounds() {\n        assertEquals(global.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 3);\n        assertEquals(local.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 1);\n        assertEquals(local2.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n                cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 2);\n    }\n\n    @Test\n    public void testGetAccession() {\n        assertNull(global.getAccession());\n        assertNull(local.getAccession());\n        assertNull(local2.getAccession());\n    }\n\n    @Test\n    public void testGetAsList() {\n        assertArrayEquals(global.getAsList().toArray(new AminoAcidCompound[7]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"R\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\"),\n            cs.getCompoundForString(\"-\")});\n        assertArrayEquals(local.getAsList().toArray(new AminoAcidCompound[8]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"Q\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"-\"), cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"-\"),\n            cs.getCompoundForString(\"H\"), cs.getCompoundForString(\"I\")});\n        assertArrayEquals(local2.getAsList().toArray(new AminoAcidCompound[3]), new AminoAcidCompound[] {\n            cs.getCompoundForString(\"R\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\")});\n    }\n\n    @Test\n    public void testGetCompoundAt() {\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(2), cs.getCompoundForString(\"A\"));\n        assertEquals(global.getCompoundAt(3), cs.getCompoundForString(\"R\"));\n        assertEquals(global.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(5), cs.getCompoundForString(\"N\"));\n        assertEquals(global.getCompoundAt(6), cs.getCompoundForString(\"D\"));\n        assertEquals(global.getCompoundAt(7), cs.getCompoundForString(\"-\"));\n        assertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(1), cs.getCompoundForString(\"E\"));\n        assertEquals(local.getCompoundAt(2), cs.getCompoundForString(\"Q\"));\n        assertEquals(local.getCompoundAt(3), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(5), cs.getCompoundForString(\"G\"));\n        assertEquals(local.getCompoundAt(6), cs.getCompoundForString(\"-\"));\n        assertEquals(local.getCompoundAt(7), cs.getCompoundForString(\"H\"));\n        assertEquals(local.getCompoundAt(8), cs.getCompoundForString(\"I\"));\n        assertEquals(local2.getCompoundAt(1), cs.getCompoundForString(\"R\"));\n        assertEquals(local2.getCompoundAt(2), cs.getCompoundForString(\"N\"));\n        assertEquals(local2.getCompoundAt(3), cs.getCompoundForString(\"D\"));\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(global.getCompoundSet(), cs);\n        assertEquals(local.getCompoundSet(), cs);\n        assertEquals(local2.getCompoundSet(), cs);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 3);\n        assertEquals(local2.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local2.getIndexOf(cs.getCompoundForString(\"-\")), -1);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 3);\n        assertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 7);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 6);\n        assertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n        assertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"-\")), -1);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(global.getLength(), 7);\n        assertEquals(local.getLength(), 8);\n        assertEquals(local2.getLength(), 3);\n    }\n\n    @Test\n    public void testGetSequenceAsString() {\n        assertEquals(global.getSequenceAsString(), \"-AR-ND-\");\n        assertEquals(local.getSequenceAsString(), \"EQ--G-HI\");\n        assertEquals(local2.getSequenceAsString(), \"RND\");\n    }\n\n    @Test\n    public void testGetSequenceAsStringIntegerIntegerStrand() {\n        assertEquals(global.getSubSequence(2, 5).getSequenceAsString(), \"AR-N\");\n        assertEquals(local.getSubSequence(2, 6).getSequenceAsString(), \"Q--G-\");\n        assertEquals(local2.getSubSequence(2, 3).getSequenceAsString(), \"ND\");\n    }\n\n    @Ignore // TODO SimpleAlignedSequence.getSubSequence(Integer, Integer)\n    @Test\n    public void testGetSubSequence() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIterator() {\n        for (AminoAcidCompound c : global) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n        for (AminoAcidCompound c : local) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n        for (AminoAcidCompound c : local2) {\n            assertNotNull(cs.getStringForCompound(c));\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(global.toString(), \"-AR-ND-\");\n        assertEquals(local.toString(), \"EQ--G-HI\");\n        assertEquals(local2.toString(), \"RND\");\n    }\n\n}\n","commitMessage":"Ran Optimize Imports across the whole project.\n","test_commitMessage":"Ran Optimize Imports across the whole project.\n","allZero":false}