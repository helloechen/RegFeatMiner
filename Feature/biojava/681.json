{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitClusterer.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitClusterer.java","prod_time":"2016-06-24 21:18:41","test_time":"2016-07-18 23:44:59","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":8,"add_classname_line":0,"add_condition_line":5,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"5fec0994ebccba175cd742548ca8b5ad15dea3fd","test_commitID":"533ca1775c12a3f7494b28081054e4b4206dd617","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The SubunitClusterer takes as input a collection of {@link Subunit} and\n * returns a collection of {@link SubunitCluster}.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitClusterer {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitClusterer.class);\n\n\t/** Prevent instantiation **/\n\tprivate SubunitClusterer() {\n\t}\n\n\tpublic static List<SubunitCluster> cluster(Structure structure,\n\t\t\tSubunitClustererParameters params) {\n\t\tList<Subunit> subunits = SubunitExtractor.extractSubunits(structure,\n\t\t\t\tparams);\n\t\treturn cluster(subunits, params);\n\t}\n\n\tpublic static List<SubunitCluster> cluster(List<Subunit> subunits,\n\t\t\tSubunitClustererParameters params) {\n\n\t\t// The collection of clusters to return\n\t\tList<SubunitCluster> clusters = new ArrayList<SubunitCluster>();\n\n\t\tif (subunits.size() == 0)\n\t\t\treturn clusters;\n\n\t\t// First generate a new cluster for each Subunit\n\t\tfor (Subunit s : subunits)\n\t\t\tclusters.add(new SubunitCluster(s));\n\n\t\t// Now merge clusters by IDENTITY\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\tif (clusters.get(c1).mergeIdentical(clusters.get(c2)))\n\t\t\t\t\tclusters.remove(c2);\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.IDENTITY)\n\t\t\treturn clusters;\n\n\t\t// Now merge clusters by SEQUENCE similarity\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\ttry {\n\t\t\t\t\tif (clusters.get(c1).mergeSequence(clusters.get(c2),\n\t\t\t\t\t\t\tparams.getSequenceIdentityThreshold(),\n\t\t\t\t\t\t\tparams.getCoverageThreshold()))\n\t\t\t\t\t\tclusters.remove(c2);\n\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\tlogger.warn(\"Could not merge by Sequence. {}\",\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.SEQUENCE)\n\t\t\treturn clusters;\n\n\t\t// Now merge clusters by STRUCTURAL similarity\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\ttry {\n\t\t\t\t\tif (clusters.get(c1).mergeStructure(clusters.get(c2),\n\t\t\t\t\t\t\tparams.getRmsdThreshold(),\n\t\t\t\t\t\t\tparams.getCoverageThreshold()))\n\t\t\t\t\t\tclusters.remove(c2);\n\t\t\t\t} catch (StructureException e) {\n\t\t\t\t\tlogger.warn(\"Could not merge by Structure. {}\",\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.STRUCTURE)\n\t\t\treturn clusters;\n\n\t\t// Now divide clusters by their INTERNAL SYMMETRY\n\t\tfor (int c = 0; c < clusters.size(); c++) {\n\t\t\ttry {\n\t\t\t\tclusters.get(c).divideInternally(params.getCoverageThreshold(),\n\t\t\t\t\t\tparams.getRmsdThreshold(),\n\t\t\t\t\t\tparams.getMinimumSequenceLength());\n\t\t\t} catch (StructureException e) {\n\t\t\t\tlogger.warn(\"Error analyzing internal symmetry. {}\",\n\t\t\t\t\t\te.getMessage());\n\t\t\t}\n\t\t}\n\n\t\treturn clusters;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The SubunitClusterer takes as input a collection of {@link Subunit} and\n * returns a collection of {@link SubunitCluster}.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitClusterer {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitClusterer.class);\n\n\t/** Prevent instantiation **/\n\tprivate SubunitClusterer() {\n\t}\n\n\tpublic static List<SubunitCluster> cluster(Structure structure,\n\t\t\tSubunitClustererParameters params) {\n\t\tList<Subunit> subunits = SubunitExtractor.extractSubunits(structure,\n\t\t\t\tparams);\n\t\treturn cluster(subunits, params);\n\t}\n\n\tpublic static List<SubunitCluster> cluster(List<Subunit> subunits,\n\t\t\tSubunitClustererParameters params) {\n\n\t\t// The collection of clusters to return\n\t\tList<SubunitCluster> clusters = new ArrayList<SubunitCluster>();\n\n\t\tif (subunits.size() == 0)\n\t\t\treturn clusters;\n\n\t\t// First generate a new cluster for each Subunit\n\t\tfor (Subunit s : subunits)\n\t\t\tclusters.add(new SubunitCluster(s));\n\n\t\t// Now merge clusters by IDENTITY\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\tif (clusters.get(c1).mergeIdentical(clusters.get(c2)))\n\t\t\t\t\tclusters.remove(c2);\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.IDENTITY)\n\t\t\treturn clusters;\n\n\t\t// Now merge clusters by SEQUENCE similarity\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\ttry {\n\t\t\t\t\tif (clusters.get(c1).mergeSequence(clusters.get(c2),\n\t\t\t\t\t\t\tparams.getSequenceIdentityThreshold(),\n\t\t\t\t\t\t\tparams.getCoverageThreshold()))\n\t\t\t\t\t\tclusters.remove(c2);\n\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\tlogger.warn(\"Could not merge by Sequence. {}\",\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.SEQUENCE)\n\t\t\treturn clusters;\n\n\t\t// Now merge clusters by STRUCTURAL similarity\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\ttry {\n\t\t\t\t\tif (clusters.get(c1).mergeStructure(clusters.get(c2),\n\t\t\t\t\t\t\tparams.getRmsdThreshold(),\n\t\t\t\t\t\t\tparams.getCoverageThreshold()))\n\t\t\t\t\t\tclusters.remove(c2);\n\t\t\t\t} catch (StructureException e) {\n\t\t\t\t\tlogger.warn(\"Could not merge by Structure. {}\",\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (params.getClustererMethod() == SubunitClustererMethod.STRUCTURE)\n\t\t\treturn clusters;\n\n\t\t// Now divide clusters by their INTERNAL SYMMETRY\n\t\tfor (int c = 0; c < clusters.size(); c++) {\n\t\t\ttry {\n\t\t\t\tclusters.get(c).divideInternally(params.getCoverageThreshold(),\n\t\t\t\t\t\tparams.getRmsdThreshold(),\n\t\t\t\t\t\tparams.getMinimumSequenceLength());\n\t\t\t} catch (StructureException e) {\n\t\t\t\tlogger.warn(\"Error analyzing internal symmetry. {}\",\n\t\t\t\t\t\te.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// After internal symmetry merge again by structural similarity\n\t\t// Use case: C8 propeller with 3 chains with 3+3+2 repeats each\n\t\tfor (int c1 = 0; c1 < clusters.size(); c1++) {\n\t\t\tfor (int c2 = clusters.size() - 1; c2 > c1; c2--) {\n\t\t\t\ttry {\n\t\t\t\t\tif (clusters.get(c1).mergeStructure(clusters.get(c2),\n\t\t\t\t\t\t\tparams.getRmsdThreshold(),\n\t\t\t\t\t\t\tparams.getCoverageThreshold()))\n\t\t\t\t\t\tclusters.remove(c2);\n\t\t\t\t} catch (StructureException e) {\n\t\t\t\t\tlogger.warn(\"Could not merge by Structure. {}\",\n\t\t\t\t\t\t\te.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\n\t\treturn clusters;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\n/**\n * Test the {@link SubunitClusterer} clustering correctness on different real\n * structures with different types of chain clustering difficulties.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSubunitClusterer {\n\n\t/**\n\t * Test modified residues: 1HIV\n\t */\n\t@Test\n\tpublic void testPTMs() throws StructureException, IOException {\n\n\t\tAtomCache cache = new AtomCache(); // TODO change to StructureIO\n\t\tcache.setUseMmCif(true);\n\t\tStructure s = cache.getStructure(\"1hiv\");\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single cluster with length 99\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).length(), 99);\n\t}\n\n\t/**\n\t * Test pseudostoichiometry: 4HHB\n\t */\n\t@Test\n\tpublic void testPseudostoichiometry() throws StructureException,\n\t\t\tIOException {\n\n\t\tAtomCache cache = new AtomCache(); // TODO change to StructureIO\n\t\tcache.setUseMmCif(true);\n\t\tStructure s = cache.getStructure(\"4HHB\");\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\t\tparams.setSequenceIdentityThreshold(0.95);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect two SEQUENCE clusters with length 141 and 146\n\t\tassertEquals(clusters.size(), 2);\n\t\tassertEquals(clusters.get(0).length(), 141);\n\t\tassertEquals(clusters.get(1).length(), 146);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\t\tassertEquals(clusters.get(1).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\n\t\tparams.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n\t\tparams.setRmsdThreshold(3.0);\n\n\t\tclusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single STRUCTURE cluster with length 140\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).length(), 140, 2);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.STRUCTURE);\n\t}\n\n\t/**\n\t * Test internally symmetric: 4E3E bioassembly 1\n\t */\n\t@Test\n\tpublic void testInternalSymmetry() throws StructureException, IOException {\n\n\t\tAtomCache cache = new AtomCache(); // TODO change to StructureIO\n\t\tcache.setUseMmCif(true);\n\t\tStructure s = cache.getStructure(\"BIO:4E3E:1\");\n\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\t\tparams.setCoverageThreshold(0.8);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect one SEQUENCE cluster with 3 Subunits of length 351\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).size(), 3);\n\t\tassertEquals(clusters.get(0).length(), 351);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\n\t\tparams.setClustererMethod(SubunitClustererMethod.INTERNAL_SYMMETRY);\n\t\tparams.setRmsdThreshold(3.0);\n\n\t\tclusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single INTERNAL_SYMMETRY cluster with 6 Subunits\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).size(), 6);\n\t\tassertTrue(clusters.get(0).length() < 177);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.INTERNAL_SYMMETRY);\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.junit.Test;\n\n/**\n * Test the {@link SubunitClusterer} clustering correctness on different real\n * structures with different types of chain clustering difficulties.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSubunitClusterer {\n\n\t/**\n\t * Test modified residues: 1HIV\n\t */\n\t@Test\n\tpublic void testPTMs() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"1hiv\");\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single cluster with length 99\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).length(), 99);\n\t}\n\n\t/**\n\t * Test pseudostoichiometry: 4HHB\n\t */\n\t@Test\n\tpublic void testPseudostoichiometry() throws StructureException,\n\t\t\tIOException {\n\n\t\tStructure s = StructureIO.getStructure(\"4HHB\");\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\t\tparams.setSequenceIdentityThreshold(0.95);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect two SEQUENCE clusters with length 141 and 146\n\t\tassertEquals(clusters.size(), 2);\n\t\tassertEquals(clusters.get(0).length(), 141);\n\t\tassertEquals(clusters.get(1).length(), 146);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\t\tassertEquals(clusters.get(1).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\n\t\tparams.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n\t\tparams.setRmsdThreshold(3.0);\n\n\t\tclusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single STRUCTURE cluster with length 140\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).length(), 140, 2);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.STRUCTURE);\n\t}\n\n\t/**\n\t * Test internally symmetric: 4E3E bioassembly 1\n\t */\n\t@Test\n\tpublic void testInternalSymmetry() throws StructureException, IOException {\n\n\t\tStructure s = StructureIO.getStructure(\"BIO:4E3E:1\");\n\n\t\tSubunitClustererParameters params = new SubunitClustererParameters();\n\t\tparams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n\t\tparams.setCoverageThreshold(0.8);\n\n\t\tList<SubunitCluster> clusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect one SEQUENCE cluster with 3 Subunits of length 351\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).size(), 3);\n\t\tassertEquals(clusters.get(0).length(), 351);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.IDENTITY);\n\n\t\tparams.setClustererMethod(SubunitClustererMethod.INTERNAL_SYMMETRY);\n\t\tparams.setRmsdThreshold(3.0);\n\n\t\tclusters = SubunitClusterer.cluster(s, params);\n\n\t\t// We expect a single INTERNAL_SYMMETRY cluster with 6 Subunits\n\t\tassertEquals(clusters.size(), 1);\n\t\tassertEquals(clusters.get(0).size(), 6);\n\t\tassertTrue(clusters.get(0).length() < 177);\n\t\tassertEquals(clusters.get(0).getClustererMethod(),\n\t\t\t\tSubunitClustererMethod.INTERNAL_SYMMETRY);\n\t}\n}\n","commitMessage":"Include a second structure clustering after internal symmetry\n\nProposed by spencer, with the use case of a C8 propeller with 3 chains\nwith 3+3+2 repeats each. This is useful in any case where chains with\nequivalent repeats but different number of them are compared.","test_commitMessage":"Change all QuatSymmetry tests to mmtf format\n\nSome tests do not pass, issue #517 needs to be fixed.","allZero":false}