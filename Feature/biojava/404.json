{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/FastaAFPChainConverter.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/FastaAFPChainConverterTest.java","prod_time":"2015-09-16 22:43:32","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"5ad3cc9e93ee928561a4423a0ac9a3835370b1b7","test_commitID":"","isfound":"not found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.nbio.structure.io;\n\nimport org.biojava.nbio.alignment.template.AlignedSequence;\nimport org.biojava.nbio.alignment.template.SequencePair;\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\nimport org.biojava.nbio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.CasePreservingProteinSequenceCreator;\nimport org.biojava.nbio.core.sequence.io.FastaReader;\nimport org.biojava.nbio.core.sequence.io.GenericFastaHeaderParser;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.SequenceTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaAFPChainConverter.class);\n\t\n\t\t\n\tpublic static AFPChain cpFastaToAfpChain(String first, String second, Structure structure, int cpSite) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence s1 = new ProteinSequence(first);\n\t\ts1.setUserCollection(getAlignedUserCollection(first));\n\t\tProteinSequence s2 = new ProteinSequence(second);\n\t\ts2.setUserCollection(getAlignedUserCollection(second));\n\t\treturn cpFastaToAfpChain(s1, s2, structure, cpSite);\n\t}\n\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param fastaFile A FASTA file containing exactly 2 sequences, the first unpermuted and the second permuted\n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t * @throws IOException \n\t * @throws StructureException \n\t */\n\tpublic static AFPChain cpFastaToAfpChain(File fastaFile, Structure structure, int cpSite) throws IOException, StructureException {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tSequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\tIterator<ProteinSequence> iter = sequences.values().iterator();\n\t\tProteinSequence first = iter.next();\n\t\tProteinSequence second = iter.next();\n\t\treturn cpFastaToAfpChain(first, second, structure, cpSite);\n\t}\n\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param first The unpermuted sequence\n\t * @param second The sequence permuted by cpSite\n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain cpFastaToAfpChain(ProteinSequence first, ProteinSequence second, Structure structure, int cpSite)\n\t\t\tthrows StructureException {\n\n\t\tif (structure == null) {\n\t\t\tthrow new IllegalArgumentException(\"The structure is null\");\n\t\t}\n\n\t\tif (first == null) {\n\t\t\tthrow new IllegalArgumentException(\"The sequence is null\");\n\t\t}\n\n\t\t// we need to find the ungapped CP site\n\t\tint gappedCpShift = 0;\n\t\tint ungappedCpShift = 0;\n\t\twhile (ungappedCpShift < Math.abs(cpSite)) {\n\t\t\tchar c;\n\t\t\ttry {\n\t\t\t\tif (cpSite <= 0) {\n\t\t\t\t\tc = second.getSequenceAsString().charAt(gappedCpShift);\n\t\t\t\t} else {\n\t\t\t\t\tc = second.getSequenceAsString().charAt(first.getLength()-1 - gappedCpShift);\n\t\t\t\t}\n\t\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"CP site of \" + cpSite + \" is wrong\");\n\t\t\t}\n\t\t\tif (c != '-') {\n\t\t\t\tungappedCpShift++;\n\t\t\t}\n\t\t\tgappedCpShift++;\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getRepresentativeAtomArray(structure);\n\t\tAtom[] ca2 =  StructureTools.getRepresentativeAtomArray(structure); // can't use cloneCAArray because it doesn't set parent group.chain.structure\n\t\t\n\t\tProteinSequence antipermuted = null;\n\t\ttry {\n\t\t\tantipermuted = new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(), gappedCpShift));\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// this can't happen, the original sequence comes from a ProteinSequence\n\t\t\tlogger.error(\"Unexpected error while creating protein sequence: {}. This is most likely a bug.\",e.getMessage() );\n\t\t}\n\n\t\tResidueNumber[] residues = StructureSequenceMatcher.matchSequenceToStructure(first, structure);\n\t\tResidueNumber[] antipermutedResidues = StructureSequenceMatcher.matchSequenceToStructure(antipermuted, structure);\n\n\t\tResidueNumber[] nonpermutedResidues = new ResidueNumber[antipermutedResidues.length];\n\t\tSequenceTools.permuteCyclic(antipermutedResidues, nonpermutedResidues, -gappedCpShift);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (first.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(first, residues);\n\t\t}\n\t\tif (second.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(second, nonpermutedResidues);\n\t\t}\n\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (residues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(sequence.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (nonpermutedResidues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(second.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n\n\t\treturn buildAlignment(ca1, ca2, residues, nonpermutedResidues);\n\n\t}\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment. Uses a\n\t * {@link CasePreservingProteinSequenceCreator} and assumes that a residue is aligned if and only if it is given by an uppercase letter.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows IOException, StructureException {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tSequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\tinStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t * @throws StructureException\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence seq1 = new ProteinSequence(sequence1);\n\t\tProteinSequence seq2 = new ProteinSequence(sequence2);\n\t\treturn fastaToAfpChain(seq1, seq2, structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * TODO Write comment\n\t * @param sequence1\n\t * @param sequence2\n\t * @param structure1\n\t * @param structure2\n\t * @return\n\t * @throws StructureException\n\t * @throws CompoundNotFoundException \n\t */\n\tpublic static AFPChain fastaToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence s1 = new ProteinSequence(sequence1);\n\t\ts1.setUserCollection(getAlignedUserCollection(sequence1));\n\t\tProteinSequence s2 = new ProteinSequence(sequence2);\n\t\ts2.setUserCollection(getAlignedUserCollection(sequence2));\n\t\treturn fastaToAfpChain(s1, s2, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures. Assumes that a residue is aligned if and only if it is given by\n\t * an uppercase letter.\n\t * @param sequence1 <em>Must</em> have {@link ProteinSequence#getUserCollection()} set to document upper- and lower-case as aligned and unaligned; see {@link #getAlignedUserCollection(String)}\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tif (sequence1 == null || sequence2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A sequence is null\");\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getRepresentativeAtomArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getRepresentativeAtomArray(structure2);\n\n\t\tResidueNumber[] residues1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] residues2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence1.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence1, residues1);\n\t\t}\n\t\tif (sequence2.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence2, residues2);\n\t\t}\n\n\t\treturn buildAlignment(ca1, ca2, residues1, residues2);\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\ttry {\n\t\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\t\tsb1.append(a.getBase());\n\t\t\t}\n\t\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\t\tmap.put(structure1.getName(), seq1);\n\t\t\tmap.put(structure2.getName(), seq2);\n\t\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tlogger.error(\"Unexpected error while creating protein sequences: {}. This is most likely a bug.\",e.getMessage());\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Builds an {@link AFPChain} from already-matched arrays of atoms and residues.\n\t * \n\t * @param ca1\n\t *            An array of atoms in the first structure\n\t * @param ca2\n\t *            An array of atoms in the second structure\n\t * @param residues1\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @param residues2\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @throws StructureException\n\t */\n\tprivate static AFPChain buildAlignment(Atom[] ca1, Atom[] ca2, ResidueNumber[] residues1, ResidueNumber[] residues2)\n\t\t\tthrows StructureException {\n\n\t\t// remove any gap\n\t\t// this includes the ones introduced by the nullifying above\n\t\tList<ResidueNumber> alignedResiduesList1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> alignedResiduesList2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < residues1.length; i++) {\n\t\t\tif (residues1[i] != null && residues2[i] != null) {\n\t\t\t\talignedResiduesList1.add(residues1[i]);\n\t\t\t\talignedResiduesList2.add(residues2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] alignedResidues1 = alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);\n\t\tResidueNumber[] alignedResidues2 = alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, alignedResidues1, alignedResidues2);\n\t\tafpChain.setAlgorithmName(\"unknown\");\n\n\t\tAlignmentTools.updateSuperposition(afpChain, ca1, ca2);\n\n\t\tafpChain.setBlockSize(new int[] {afpChain.getNrEQR()});\n\t\tafpChain.setBlockRmsd(new double[] {afpChain.getTotalRmsdOpt()});\n\t\tafpChain.setBlockGap(new int[] {afpChain.getGapLen()});\n\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Takes a protein sequence string with capital and lowercase letters and sets its {@link ProteinSequence#getUserCollection() user collection} to record which letters are uppercase (aligned) and which are lowercase (unaligned).\n\t * @param sequence Make sure <em>not</em> to use {@link ProteinSequence#getSequenceAsString()} for this, as it won't preserve upper- and lower-case\n\t */\n\tpublic static List<Object> getAlignedUserCollection(String sequence) {\n\t\tList<Object> aligned = new ArrayList<Object>(sequence.length());\n\t\tfor (char c : sequence.toCharArray()) {\n\t\t\taligned.add(Character.isUpperCase(c));\n\t\t}\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws StructureException, IOException {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tStructure structure1 = StructureTools.getStructure(args[1]);\n\t\tStructure structure2 = StructureTools.getStructure(args[2]);\n\t\tif (structure1 == null) throw new IllegalArgumentException(\"No structure for \" + args[1] + \" was found\");\n\t\tif (structure2 == null) throw new IllegalArgumentException(\"No structure for \" + args[2] + \" was found\");\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\t\n}\n","changedPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.nbio.structure.io;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.SequencePair;\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\nimport org.biojava.nbio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.CasePreservingProteinSequenceCreator;\nimport org.biojava.nbio.core.sequence.io.FastaReader;\nimport org.biojava.nbio.core.sequence.io.GenericFastaHeaderParser;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.SequenceTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaAFPChainConverter.class);\n\t\n\t\t\n\tpublic static AFPChain cpFastaToAfpChain(String first, String second, Structure structure, int cpSite) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence s1 = new ProteinSequence(first);\n\t\ts1.setUserCollection(getAlignedUserCollection(first));\n\t\tProteinSequence s2 = new ProteinSequence(second);\n\t\ts2.setUserCollection(getAlignedUserCollection(second));\n\t\treturn cpFastaToAfpChain(s1, s2, structure, cpSite);\n\t}\n\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param fastaFile A FASTA file containing exactly 2 sequences, the first unpermuted and the second permuted\n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t * @throws IOException \n\t * @throws StructureException \n\t */\n\tpublic static AFPChain cpFastaToAfpChain(File fastaFile, Structure structure, int cpSite) throws IOException, StructureException {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tSequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\tIterator<ProteinSequence> iter = sequences.values().iterator();\n\t\tProteinSequence first = iter.next();\n\t\tProteinSequence second = iter.next();\n\t\treturn cpFastaToAfpChain(first, second, structure, cpSite);\n\t}\n\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param first The unpermuted sequence\n\t * @param second The sequence permuted by cpSite\n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain cpFastaToAfpChain(ProteinSequence first, ProteinSequence second, Structure structure, int cpSite)\n\t\t\tthrows StructureException {\n\n\t\tif (structure == null) {\n\t\t\tthrow new IllegalArgumentException(\"The structure is null\");\n\t\t}\n\n\t\tif (first == null) {\n\t\t\tthrow new IllegalArgumentException(\"The sequence is null\");\n\t\t}\n\n\t\t// we need to find the ungapped CP site\n\t\tint gappedCpShift = 0;\n\t\tint ungappedCpShift = 0;\n\t\twhile (ungappedCpShift < Math.abs(cpSite)) {\n\t\t\tchar c;\n\t\t\ttry {\n\t\t\t\tif (cpSite <= 0) {\n\t\t\t\t\tc = second.getSequenceAsString().charAt(gappedCpShift);\n\t\t\t\t} else {\n\t\t\t\t\tc = second.getSequenceAsString().charAt(first.getLength()-1 - gappedCpShift);\n\t\t\t\t}\n\t\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"CP site of \" + cpSite + \" is wrong\");\n\t\t\t}\n\t\t\tif (c != '-') {\n\t\t\t\tungappedCpShift++;\n\t\t\t}\n\t\t\tgappedCpShift++;\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getRepresentativeAtomArray(structure);\n\t\tAtom[] ca2 =  StructureTools.getRepresentativeAtomArray(structure); // can't use cloneCAArray because it doesn't set parent group.chain.structure\n\t\t\n\t\tProteinSequence antipermuted = null;\n\t\ttry {\n\t\t\tantipermuted = new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(), gappedCpShift));\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// this can't happen, the original sequence comes from a ProteinSequence\n\t\t\tlogger.error(\"Unexpected error while creating protein sequence: {}. This is most likely a bug.\",e.getMessage() );\n\t\t}\n\n\t\tResidueNumber[] residues = StructureSequenceMatcher.matchSequenceToStructure(first, structure);\n\t\tResidueNumber[] antipermutedResidues = StructureSequenceMatcher.matchSequenceToStructure(antipermuted, structure);\n\n\t\tResidueNumber[] nonpermutedResidues = new ResidueNumber[antipermutedResidues.length];\n\t\tSequenceTools.permuteCyclic(antipermutedResidues, nonpermutedResidues, -gappedCpShift);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (first.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(first, residues);\n\t\t}\n\t\tif (second.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(second, nonpermutedResidues);\n\t\t}\n\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (residues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(sequence.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (nonpermutedResidues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(second.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n\n\t\treturn buildAlignment(ca1, ca2, residues, nonpermutedResidues);\n\n\t}\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment. Uses a\n\t * {@link CasePreservingProteinSequenceCreator} and assumes that a residue is aligned if and only if it is given by an uppercase letter.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows IOException, StructureException {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tSequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\tinStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t * @throws StructureException\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence seq1 = new ProteinSequence(sequence1);\n\t\tProteinSequence seq2 = new ProteinSequence(sequence2);\n\t\treturn fastaToAfpChain(seq1, seq2, structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * TODO Write comment\n\t * @param sequence1\n\t * @param sequence2\n\t * @param structure1\n\t * @param structure2\n\t * @return\n\t * @throws StructureException\n\t * @throws CompoundNotFoundException \n\t */\n\tpublic static AFPChain fastaToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException, CompoundNotFoundException {\n\t\tProteinSequence s1 = new ProteinSequence(sequence1);\n\t\ts1.setUserCollection(getAlignedUserCollection(sequence1));\n\t\tProteinSequence s2 = new ProteinSequence(sequence2);\n\t\ts2.setUserCollection(getAlignedUserCollection(sequence2));\n\t\treturn fastaToAfpChain(s1, s2, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures. Assumes that a residue is aligned if and only if it is given by\n\t * an uppercase letter.\n\t * @param sequence1 <em>Must</em> have {@link ProteinSequence#getUserCollection()} set to document upper- and lower-case as aligned and unaligned; see {@link #getAlignedUserCollection(String)}\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tif (sequence1 == null || sequence2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A sequence is null\");\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getRepresentativeAtomArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getRepresentativeAtomArray(structure2);\n\n\t\tResidueNumber[] residues1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] residues2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence1.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence1, residues1);\n\t\t}\n\t\tif (sequence2.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence2, residues2);\n\t\t}\n\n\t\treturn buildAlignment(ca1, ca2, residues1, residues2);\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\ttry {\n\t\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\t\tsb1.append(a.getBase());\n\t\t\t}\n\t\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\t\tmap.put(structure1.getName(), seq1);\n\t\t\tmap.put(structure2.getName(), seq2);\n\t\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tlogger.error(\"Unexpected error while creating protein sequences: {}. This is most likely a bug.\",e.getMessage());\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Builds an {@link AFPChain} from already-matched arrays of atoms and residues.\n\t * \n\t * @param ca1\n\t *            An array of atoms in the first structure\n\t * @param ca2\n\t *            An array of atoms in the second structure\n\t * @param residues1\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @param residues2\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @throws StructureException\n\t */\n\tprivate static AFPChain buildAlignment(Atom[] ca1, Atom[] ca2, ResidueNumber[] residues1, ResidueNumber[] residues2)\n\t\t\tthrows StructureException {\n\n\t\t// remove any gap\n\t\t// this includes the ones introduced by the nullifying above\n\t\tList<ResidueNumber> alignedResiduesList1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> alignedResiduesList2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < residues1.length; i++) {\n\t\t\tif (residues1[i] != null && residues2[i] != null) {\n\t\t\t\talignedResiduesList1.add(residues1[i]);\n\t\t\t\talignedResiduesList2.add(residues2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] alignedResidues1 = alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);\n\t\tResidueNumber[] alignedResidues2 = alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, alignedResidues1, alignedResidues2);\n\t\tafpChain.setAlgorithmName(\"unknown\");\n\n\t\tAlignmentTools.updateSuperposition(afpChain, ca1, ca2);\n\n\t\tafpChain.setBlockSize(new int[] {afpChain.getNrEQR()});\n\t\tafpChain.setBlockRmsd(new double[] {afpChain.getTotalRmsdOpt()});\n\t\tafpChain.setBlockGap(new int[] {afpChain.getGapLen()});\n\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Takes a protein sequence string with capital and lowercase letters and sets its {@link ProteinSequence#getUserCollection() user collection} to record which letters are uppercase (aligned) and which are lowercase (unaligned).\n\t * @param sequence Make sure <em>not</em> to use {@link ProteinSequence#getSequenceAsString()} for this, as it won't preserve upper- and lower-case\n\t */\n\tpublic static List<Object> getAlignedUserCollection(String sequence) {\n\t\tList<Object> aligned = new ArrayList<Object>(sequence.length());\n\t\tfor (char c : sequence.toCharArray()) {\n\t\t\taligned.add(Character.isUpperCase(c));\n\t\t}\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\tpublic static void main(String[] args) throws StructureException, IOException {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tStructure structure1 = StructureTools.getStructure(args[1]);\n\t\tStructure structure2 = StructureTools.getStructure(args[2]);\n\t\tif (structure1 == null) throw new IllegalArgumentException(\"No structure for \" + args[1] + \" was found\");\n\t\tif (structure2 == null) throw new IllegalArgumentException(\"No structure for \" + args[2] + \" was found\");\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\t\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.nbio.structure.io;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.custommonkey.xmlunit.DetailedDiff;\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.Difference;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.custommonkey.xmlunit.examples.RecursiveElementNameAndTextQualifier;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXException;\n\nimport java.io.*;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\n\n/**\n * A test for {@link FastaAFPChainConverter}.\n * @author dmyersturnbull\n *\n */\npublic class FastaAFPChainConverterTest {\n\n\tstatic {\n\t\tXMLUnit.setIgnoreWhitespace(true);\n\t\tXMLUnit.setIgnoreComments(true);\n\t\tXMLUnit.setIgnoreAttributeOrder(true);\n\t}\n\n\tpublic static void printDetailedDiff(Diff diff, PrintStream ps) {\n\t\tDetailedDiff detDiff = new DetailedDiff(diff);\n\t\tfor (Object object : detDiff.getAllDifferences()) {\n\t\t\tDifference difference = (Difference) object;\n\t\t\tps.println(difference);\n\t\t}\n\t}\n\n\t/**\n\t * Compares two XML files without regard to the order of elements or attributes, and ignoring any element named \\\"releaseDate\\\".\n\t * @return Whether the files are \\\"similar\\\"\n\t */\n\tpublic static boolean compareXml(File expectedFile, File actualFile) {\n\t\ttry {\n\t\t\tFileReader expectedFr = new FileReader(expectedFile);\n\t\t\tFileReader actualFr = new FileReader(actualFile);\n\t\t\tDiff diff = new Diff(expectedFr, actualFr);\n\t\t\t// ignore order\n\t\t\t// look at element, id, and weight (weight is a nested element)\n\t\t\tdiff.overrideElementQualifier(new RecursiveElementNameAndTextQualifier());\n\t\t\tfinal boolean isSimilar = diff.similar();\n\t\t\tif (!isSimilar) printDetailedDiff(diff, System.err);\n\t\t\texpectedFr.close();\n\t\t\tactualFr.close();\n\t\t\treturn isSimilar;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() {\n\t\tcache = new AtomCache();\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75B);\n\t}\n\t\n\t@Test\n\tpublic void testCpAsymmetric() throws IOException, StructureException, CompoundNotFoundException {\n\t\tStructure structure = cache.getStructure(\"1w0p\");\n\t\tString first = (\"alfdynatgdtefdspakqgwmqdntnngsgvltnadgmpawlvqgiggraqwtyslstnqhaqassfgwrmttemkvlsggmitnyyangtqrvlpiisldssgnlvvefegqtgrtvlatgtaateyhkfelvflpgsnpsasfyfdgklirdniqptaskQNMIVWGNGSSntdgvaayrdikfei------------------------------------------------------------------------------------------------------------------QGDVIf------------RGPDRIPSIVASsvTPGVVTAFAEKRVGGgdpgalsntNDIITRTSRDGGITWDTELNLTEQinvsdeFDFSDPRPIYDPs---SNTVLVSYARWPtdaaqngdrikpwmpNGIFYSVYDVASgnWQAPIDVTdqvkersfqiagwggselyrrntslnsqqdwqsnakirivdgaanqiqvadgsrkyvvtlsidesgglvanlngvsapiilqsehakvhsfhdyelqysalnhtttlfvdgqqittwagevsqenniqfgnadaqidgrlhvqkivltqqghnlvefdafylaqqtpevekdleklgwtkiktgntmslygNASVNPGpgHGITLtrqqnisgsqNGRLIYPAIVLdrfFLNVMSIYSDDGgsnwq-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------TGSTLpipfrwksssileTLEPSEADMVELQN--GDLLLTARLDFNQivngvny--SPRQQFLSKDGGITWSLLEANNANvfsnistgTVDASITRFEqsdgSHFLLFTNPQGnpagTNgr------------QNLGLWFSFDEG--VTWKGPIQ--LVNGasaysdiyqldsenaivivetdnsnmrilrmpitllkqklt\");\n\t\tString second =   (\"--------------------------------------------------------------------------------------------kirivdgaanqiqvadgsrkyvvtlsidesgglvanlngvsapiilqsehakvhsfhdyelqysalnhtttLFVDGQQITTWagevsqenniqfgnadaqidgrlhvqkivltqqghnlvefdafylaqqtpevekdleklgwtkiktgntmslygnasvnpgpghgitltrqqnisgsqngrliypaivldrfflnvmsiysddggsnwqTGSTLpipfrwksssileTLEPSEADMVEL--QNGDLLLTARLDFNQivngvny--SPRQQFLSKDGGITWSLLEANNANvfsnisTGTVDASITRFEqsdgSHFLLFTNPQGNpagtngr--------QNLGLWFSFDEG--VTWKGPIQlv---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------NGASAYS--DIYQLd---------SENAIVIVETD---NSNMRILRMPITllkqkltalfdynatgdtefdspakqgwmqdntnngsgvltnadgmpawlvqgiggraqwtyslstnqhaqassfgwrmttemkvlsggmitnyyangtqrvlpiisldssgnlvvefegqtgrtvlatgtaateyhkfelvflpgsnpsasfyfdgklirdniqptaskqnmivwgngssntdgvaayrdikfeiQGDVIf------------RGPDRIPSIVASSVtpGVVTAFAEKRVGGgdpgalsntNDIITRTSRDGGITWDTELNLTEQinvsdefdFSDPRPIYDPs---SNTVLVSYARW----PTdaaqngdrikpwmpNGIFYSVYDVASgnWQAPIDVTdqVKERsfqiagwggselyrrntslnsqqdwqsna------------\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(first, second, structure, -393);\n\t\tassertEquals(\"Wrong TM-score\", 0.2949, afpChain.getTMScore(), 0.001);\n\t\tassertEquals(\"Wrong RMSD\", 3.605, afpChain.getTotalRmsdOpt(), 0.001);\n\t}\n\n\t@Test\n\tpublic void testCpSymmetric2() throws IOException,StructureException, CompoundNotFoundException {\n\t\tString a = \"--vRSLNCTLRDSQQ-KSLVMSG---PYELKALHLQgqdmeq-----QVVFSMSFVQGeesndkiPVALGLKEK-NLYLSSVLKdDKPTLQLESVdpknypkkkmekRFVFNKIEInn--KLEFESAQFpnWYISTSqAENmPVFLGGT----KGgqDITDFTMQFV---\";\n\t\tString b = \"esnDKIPVALGLKEKnLYLSSVLkddKPTLQLESVDpknypkkkmekRFVFNKIEINN-------KLEFESAQFpNWYISTSQA-ENMPVFLGGTkggqd-------ITDFTMQFVvrslNCTLRDSQQ--KSLVMS-GPY-ELKALHLqgqdME--QQVVFSMSFVqge\";\n\t\tStructure structure = StructureTools.getStructure(\"31BI\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(a, b, structure, -101);\n\t\tassertEquals(\"Wrong TM-score\", 0.6284, afpChain.getTMScore(), 0.001);\n\t\tassertEquals(\"Wrong RMSD\", 2.50569, afpChain.getTotalRmsdOpt(), 0.001);\n\t}\n\t\n\t@Test\n\tpublic void testBug1() throws IOException, StructureException, CompoundNotFoundException {\n\t\t/*\n\t\t * From CriteriaDifference:\n\t\t * [d3er9b_: TM-score=0.6984812617301941, Tmpr=0.14740000665187836]\n\t\t * This is a HUGE difference\n\t\t * 0.6984813 appears to be correct.\n\t\t * The TM-score is so high for such an asymmetric domains simply because the alignment partially follows the main diagonal (trivial alignment).\n\t\t */\n\t\tString a = \"nitlkiietylgrvpsvneyhmlksqarniqkitvfnkdifvslvkknkkrffsdvntsaseikdrilsyfsKQTQty-------NIGKLFTIIELQSVLVTTYTDilgvLTINV----TSMEELARDMLnsmnVAVVSSLVKNVNKLMEEYLRRHNKSCICYGSYSLYLINPNIRYGDIDILQTNSRTFLIDLAFLIKFITGNNIILSKIPYLRNYMVIKDENDNHIIDSFNIRQDTMNVVPKIFIDNIYIVDP---TFQLLNMIKMfsqIDRLEDLSkdpeKFNARMATMLEYVRYT------HGIVFdgKRNNMPMKCIIDENNRIVTVTTKDYFSFKKCLVYLDENVLSSDILDLNADTSCDFESVTNSVYLIHDNIMYTYFSNTILLSDKGKVheiSARGLCAHILLYQml-----TSG--EYKQCLSDLLNsmMNRDKIPIysHTERDKKPGRHGFINIEKDIIVF-------------------------------------------------------------------\";\n\t\tString b = \"----------------------------------------------------------------------lsYFSKqtqtynigkLFTIIELQSVLVTTYTDILGV----LTINVtsmeELARDMLNSMN----VAVVSSLVKNVNKLMEEYLRRHNKSCICYGSYSLYLINPNIRYGDIDILQTNSRTFLIDLAFLIKFITGNNIILSKIPYLRNYMVIKDENDNHIIDSFNIRQDTMNVVPKIFIDNIYIVDPtfqLLNMIKMFSQ---IDRLEDLS----KDPEKFNARMATMLEYvrythgIVFDG--KRNNMPMKCIIDENNRIVTVTTKDYFSFKKCLVYLDENVLSSDILDLNADTSCDFESVTNSVYLIHDNIMYTYFSNTILLSDKGKV---HEISARGLCAHILlyqmltsGEYkqCLSDLLNSMMN--RDKIPIYS--HTERDKKPGRHGFINIEKDIIVFnitlkiietylgrvpsvneyhmlksqarniqkitvfnkdifvslvkknkkrffsdvntsaseikdri\";\n//\t\t            ========================================================================KQTQ=========NIGKLFTIIELQSVLVTTYTD====LTINV====TSMEELARDML====VAVVSSLVKNVNKLMEEYLRRHNKSCICYGSYSLYLINPNIRYGDIDILQTNSRTFLIDLAFLIKFITGNNIILSKIPYLRNYMVIKDENDNHIIDSFNIRQDTMNVVPKIFIDNIYIVDP===TFQLLNMIKM===IDRLEDLS====KFNARMATMLEYVRYT======HGIVF==KRNNMPMKCIIDENNRIVTVTTKDYFSFKKCLVYLDENVLSSDILDLNADTSCDFESVTNSVYLIHDNIMYTYFSNTILLSDKGKV===SARGLCAHILLYQ=======TSG==EYKQCLSDLLN==MNRDKIPI==HTERDKKPGRHGFINIEKDIIVF===================================================================\n//\t\t            ========================================================================YFSK=========LFTIIELQSVLVTTYTDILGV====LTINV====ELARDMLNSMN====VAVVSSLVKNVNKLMEEYLRRHNKSCICYGSYSLYLINPNIRYGDIDILQTNSRTFLIDLAFLIKFITGNNIILSKIPYLRNYMVIKDENDNHIIDSFNIRQDTMNVVPKIFIDNIYIVDP===LLNMIKMFSQ===IDRLEDLS====KDPEKFNARMATMLEY======IVFDG==KRNNMPMKCIIDENNRIVTVTTKDYFSFKKCLVYLDENVLSSDILDLNADTSCDFESVTNSVYLIHDNIMYTYFSNTILLSDKGKV===HEISARGLCAHIL=======GEY==CLSDLLNSMMN==RDKIPIYS==HTERDKKPGRHGFINIEKDIIVF===================================================================\n\t\tStructure structure = StructureTools.getStructure(\"d3er9b_\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(a, b, structure, 67);\n\t\tassertEquals(\"Wrong RMSD\", 2.681, afpChain.getTotalRmsdOpt(), 0.001);\n\t\tassertEquals(\"Wrong TM-score\", 0.69848, afpChain.getTMScore(), 0.001);\n\t}\n\t\n\t@Test\n\tpublic void testCpSymmetric1() throws IOException,StructureException, CompoundNotFoundException {\n\t\t//cat 2GG6-best.fasta |tr -d \\\\n|pbcopy\n\t\tString a = \"-SSRPATAR-KSSGLSGTVRIPGDKSISHRSFMFGGLA-SGETRITGLLEG-EDvINTGKAMQAMGARIRKEGd---------TWIIDGVgngglLAPEAPLD---FGNAATGCRLTMGLVGvydFDSTFIGDASLtkrp---MGRVLNPLREMGVQVKSEDgdrLPVTLRGPK---TPT---PITYRVpMASAQVKSAVLLAGLNTPGITTVIEpi---MTRDHTEKMLQGFGANLTVEtdadGVRTIRLEgRGKLTGQVIDVPGDPSSTAFPLVAALLVpGSDVTILNVLMNpTR-TGLILTLQEMGADIEVINprlaggedvaDLRVRSS-----TLKGVTVPedrAPSMIDEYPILAVAAAFAEGATVMNGLEELrvkesdrLSAVANGLKLNGVDCDEGE---TSLVVRGRPdgkGLGNasgAAVAT-HLDHRIAMSFLVMGLVSENPVTVDDatmIATSFPEFMDLMAGLGAKIELS---\";\n\t\tString b = \"dGVRTIRLEgRGKLTGQVIDVPGDPSSTAFPLVAALLVpGSDVTILNVLMNpTR-TGLILTLQEMGADIEVINprlaggedvaDLRVRSS-----TLKGVTVPedrAPSMIDEYPILAVAAAfaeGATVMNGLEELrvkesdrLSAVANGLKLNGVDCDEGE---TSLVVRGRPdgkGLGnasGAAVAT-HLDHRIAMSFLVMGLVSENPVTVDDatmiaTSFPEFMDLMAGLGAKIELS----SSRPATAR-KSSGLSGTVRIPGDKSISHRSFMFGGLA-SGETRITGLLEG-EDvINTGKAMQAMGARIRKEGd---------TWIIDGVgngglLAPEAPLD---FGNAATGCRLTMGLVGVYDFDSTFIGDASLtkrp---MGRVLNPLREMGVQVKSEDgdrLPVTLRGPK---TPTP---ITYRVpMASAQVKSAVLLAGLNTPGITTVIE---PIMTRDHTEKMLQGFGANLTVEtda\";\n\t\tStructure structure = StructureTools.getStructure(\"2GG6\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(a, b, structure, -230); // 215\n\t\tassertEquals(\"Wrong TM-score\", 0.7701, afpChain.getTMScore(), 0.001);\n\t\tassertEquals(\"Wrong RMSD\", 3.035, afpChain.getTotalRmsdOpt(), 0.001);\n\t}\n\t\n\t@Test\n\tpublic void testFromFasta() throws IOException, StructureException, CompoundNotFoundException {  \n\t\tStructure s1 = cache.getStructure(\"1w0p\");\n\t\tStructure s2 = cache.getStructure(\"1qdm\");\n\t\tProteinSequence seq1 = new ProteinSequence(\"GWGG----SEL--YRRNTSLNS--QQDW-------QSNAKIRIVDGAA-----NQIQ\");\n\t\tProteinSequence seq2 = new ProteinSequence(\"WMQNQLAQNKT--QDLILDYVNQLCNRL---PSPMESAV----DCGSLGSMPDIEFT\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.fastaToAfpChain(seq1, seq2, s1, s2);\n\t\tassertEquals(\"Wrong number of EQRs\", 33, afpChain.getNrEQR());\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tFile expected = new File(\"src/test/resources/1w0p_1qdm.xml\");\n\t\tFile x = File.createTempFile(\"1w0p_1qdm_output\", \"xml.tmp\");\n\t\tx.deleteOnExit();\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(x));\n\t\tbw.write(xml);\n\t\tbw.close();\n\t\tboolean match = compareXml(expected, x);\n\t\tif (!match) {\n\t\t\tSystem.err.println(xml);\n\t\t\tfail(\"AFPChain is wrong\");\n\t\t}\n\t}\n\n}\n","changedTest":"","commitMessage":"Massive refactoring: moved alignment data structures from biojava-alignment to biojava-core.\nMantaining main biological data structures in core will help to avoid problems of unwanted dependency. Unfortunately the substitution matrices related classes are tight coupled with SimpleSequencePair class and were moved too from alignment.\n\nUpdated pom file to remove dependency of core from alignment module temporary added by first implementation of SearchIO.\n","test_commitMessage":"","allZero":false}