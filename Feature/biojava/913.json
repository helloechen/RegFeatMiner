{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/contact/InterfaceFinder.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/contact/TestInterfaceFinder.java","prod_time":"2020-01-26 03:36:08","test_time":"2020-01-26 03:58:56","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"e70f0ef8131897137cc2f6b201b2eca4ff9c662f","test_commitID":"2807d3d1cc76128599d79410717327696feb45ef","isfound":"found test change","originPro":"package org.biojava.nbio.structure.contact;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.xtal.CrystalTransform;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\n\nimport javax.vecmath.Point3d;\nimport java.util.List;\n\n/**\n * A class containing methods to find interfaces in a given structure.\n * @author Jose Duarte\n * @since 5.4.0\n */\npublic class InterfaceFinder {\n\n    public static final double DEFAULT_CONTACT_CUTOFF = 6;\n\n    private static final CrystalTransform IDENTITY_TRANSFORM = new CrystalTransform(SpaceGroup.parseSpaceGroup(\"P1\"));\n    private static final boolean INCLUDE_HETATOMS = true;\n\n    private Structure structure;\n    private double cutoff;\n\n    private BoundingBox[] boundingBoxes;\n\n    public InterfaceFinder(Structure structure) {\n        this.structure = structure;\n        this.cutoff = DEFAULT_CONTACT_CUTOFF;\n    }\n\n    /**\n     * Set the contact distance cutoff.\n     * @param cutoff the distance value in Angstroms\n     */\n    public void setCutoff(double cutoff) {\n        this.cutoff = cutoff;\n    }\n\n    /**\n     * Find all inter polymer-chain interfaces in the structure.\n     * Two chains will be considered in contact if at least a pair of atoms from each is within the\n     * contact cutoff.\n     * @return the list of all interfaces\n     */\n    public StructureInterfaceList getAllInterfaces() {\n        initBoundingBoxes();\n\n        StructureInterfaceList list = new StructureInterfaceList();\n\n        List<Chain> polyChains = structure.getPolyChains();\n        for (int i = 0; i<polyChains.size(); i++) {\n            for (int j = i + 1; j<polyChains.size(); j++) {\n                if (! boundingBoxes[i].overlaps(boundingBoxes[j], cutoff)) {\n                    continue;\n                }\n                StructureInterface interf = calcInterface(polyChains.get(i), polyChains.get(j));\n                if (interf!=null) {\n                    list.add(interf);\n                }\n            }\n        }\n        return list;\n    }\n\n    private void initBoundingBoxes() {\n        List<Chain> polyChains = structure.getPolyChains();\n        boundingBoxes = new BoundingBox[polyChains.size()];\n        for (int i = 0; i<polyChains.size(); i++) {\n            Atom[] atoms = StructureTools.getAllNonHAtomArray(polyChains.get(i), INCLUDE_HETATOMS);\n            Point3d[] points = Calc.atomsToPoints(atoms);\n            BoundingBox bb = new BoundingBox(points);\n            boundingBoxes[i] = bb;\n        }\n    }\n\n    private StructureInterface calcInterface(Chain chain1, Chain chain2) {\n        AtomContactSet graph = StructureTools.getAtomsInContact(chain1, chain2, cutoff, INCLUDE_HETATOMS);\n\n        StructureInterface interf = null;\n        if (graph.size()>0) {\n            interf = new StructureInterface(\n                    StructureTools.getAllNonHAtomArray(chain1, INCLUDE_HETATOMS), StructureTools.getAllNonHAtomArray(chain2, INCLUDE_HETATOMS),\n                    chain1.getName(), chain2.getName(),\n                    graph,\n                    IDENTITY_TRANSFORM, IDENTITY_TRANSFORM);\n        }\n\n        return interf;\n    }\n}\n","changedPro":"package org.biojava.nbio.structure.contact;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.xtal.CrystalTransform;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\n\nimport javax.vecmath.Point3d;\nimport java.util.List;\n\n/**\n * A class containing methods to find interfaces in a given structure.\n * @author Jose Duarte\n * @since 5.4.0\n */\npublic class InterfaceFinder {\n\n    public static final double DEFAULT_CONTACT_CUTOFF = 6;\n\n    private static final CrystalTransform IDENTITY_TRANSFORM = new CrystalTransform((SpaceGroup) null);\n    private static final boolean INCLUDE_HETATOMS = true;\n\n    private Structure structure;\n    private double cutoff;\n\n    private BoundingBox[] boundingBoxes;\n\n    public InterfaceFinder(Structure structure) {\n        this.structure = structure;\n        this.cutoff = DEFAULT_CONTACT_CUTOFF;\n    }\n\n    /**\n     * Set the contact distance cutoff.\n     * @param cutoff the distance value in Angstroms\n     */\n    public void setCutoff(double cutoff) {\n        this.cutoff = cutoff;\n    }\n\n    /**\n     * Find all inter polymer-chain interfaces in the structure.\n     * Two chains will be considered in contact if at least a pair of atoms (one from each chain) is within the\n     * contact cutoff.\n     * @return the list of all interfaces\n     */\n    public StructureInterfaceList getAllInterfaces() {\n        initBoundingBoxes();\n\n        StructureInterfaceList list = new StructureInterfaceList();\n\n        List<Chain> polyChains = structure.getPolyChains();\n        for (int i = 0; i<polyChains.size(); i++) {\n            for (int j = i + 1; j<polyChains.size(); j++) {\n                if (! boundingBoxes[i].overlaps(boundingBoxes[j], cutoff)) {\n                    continue;\n                }\n                StructureInterface interf = calcInterface(polyChains.get(i), polyChains.get(j));\n                if (interf!=null) {\n                    list.add(interf);\n                }\n            }\n        }\n        return list;\n    }\n\n    private void initBoundingBoxes() {\n        List<Chain> polyChains = structure.getPolyChains();\n        boundingBoxes = new BoundingBox[polyChains.size()];\n        for (int i = 0; i<polyChains.size(); i++) {\n            Atom[] atoms = StructureTools.getAllNonHAtomArray(polyChains.get(i), INCLUDE_HETATOMS);\n            Point3d[] points = Calc.atomsToPoints(atoms);\n            BoundingBox bb = new BoundingBox(points);\n            boundingBoxes[i] = bb;\n        }\n    }\n\n    private StructureInterface calcInterface(Chain chain1, Chain chain2) {\n        AtomContactSet graph = StructureTools.getAtomsInContact(chain1, chain2, cutoff, INCLUDE_HETATOMS);\n\n        StructureInterface interf = null;\n        if (graph.size()>0) {\n            interf = new StructureInterface(\n                    StructureTools.getAllNonHAtomArray(chain1, INCLUDE_HETATOMS), StructureTools.getAllNonHAtomArray(chain2, INCLUDE_HETATOMS),\n                    chain1.getName(), chain2.getName(),\n                    graph,\n                    IDENTITY_TRANSFORM, IDENTITY_TRANSFORM);\n        }\n\n        return interf;\n    }\n}\n","originTest":"package org.biojava.nbio.structure.contact;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.Point3d;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class TestInterfaceFinder {\n\n    @Test\n    public void testGetAllInterfaces() {\n        Structure s = mockStructure();\n        InterfaceFinder finder = new InterfaceFinder(s);\n\n        StructureInterfaceList list = finder.getAllInterfaces();\n\n        assertEquals(3, list.size());\n\n        Set<Pair<String>> unique = new HashSet<>();\n\n        for (StructureInterface interf : list) {\n            System.out.println(\"Interface \" + interf.getMoleculeIds());\n            AtomContactSet set = interf.getContacts();\n            for (AtomContact c : set)\n                System.out.println(c.getPair() +\" - \" + c.getDistance());\n\n            unique.add(interf.getMoleculeIds());\n\n        }\n        assertEquals(3, unique.size());\n    }\n\n    /**\n     * Create a mock structure with 2 entities 1 (chains A, B) and 2 (chain C).\n     * @return a structure\n     */\n    private Structure mockStructure() {\n        Structure structure = new StructureImpl();\n        EntityInfo entity1 = new EntityInfo();\n        entity1.setMolId(1);\n        EntityInfo entity2 = new EntityInfo();\n        entity2.setMolId(2);\n        structure.addEntityInfo(entity1);\n        structure.addEntityInfo(entity2);\n\n        Chain chainA = new ChainImpl();\n        chainA.setId(\"A\");\n        chainA.setName(\"A\");\n        Chain chainB = new ChainImpl();\n        chainB.setId(\"B\");\n        chainB.setName(\"B\");\n        entity1.addChain(chainA);\n        entity1.addChain(chainB);\n        Chain chainC = new ChainImpl();\n        chainC.setId(\"C\");\n        chainC.setName(\"C\");\n        entity2.addChain(chainC);\n\n        structure.addChain(chainA);\n        structure.addChain(chainB);\n        structure.addChain(chainC);\n\n        // entity 1: chain A 10 observed residues, chain B 9 observed residues (first unobserved)\n        List<Group> aGroups = getGroupList(10, \"ALA\", chainA, new Point3d(0,0,0));\n        chainA.setAtomGroups(new ArrayList<>(aGroups));\n        chainA.setSeqResGroups(aGroups);\n        chainA.setEntityInfo(entity1);\n\n        List<Group> bGroups = getGroupList(10, \"ALA\", chainB, new Point3d(4, 0, 0));\n        chainB.setAtomGroups(new ArrayList<>(bGroups.subList(1,10)));\n        chainB.setSeqResGroups(bGroups);\n        chainB.setEntityInfo(entity1);\n\n        List<Group> cGroups = getGroupList(20, \"GLY\", chainC, new Point3d(0, 4, 0));\n        chainC.setAtomGroups(new ArrayList<>(cGroups));\n        chainC.setSeqResGroups(cGroups);\n        chainC.setEntityInfo(entity2);\n\n        return structure;\n    }\n\n    private List<Group> getGroupList(int size, String type, Chain chain, Point3d center) {\n        List<Group> list = new ArrayList<>();\n        double offsetx = 0;\n        double offsety = 0;\n        double offsetz = 0;\n        for (int i=0;i<size;i++) {\n            Group g = new AminoAcidImpl();\n            g.setPDBName(type);\n            g.setResidueNumber(new ResidueNumber(chain.getId(), i+1, null));\n            chain.addGroup(g);\n            Atom a = new AtomImpl();\n            a.setName(StructureTools.CA_ATOM_NAME);\n            a.setX(center.x + offsetx);\n            a.setY(center.y + offsety);\n            a.setZ(center.z + offsetz);\n            g.addAtom(a);\n            list.add(g);\n\n            if (i%3 == 0) offsetx += 1;\n            if (i%3 == 1) offsety += 1;\n            if (i%3 == 2) offsetz += 1;\n        }\n\n        return list;\n    }\n\n}\n","changedTest":"package org.biojava.nbio.structure.contact;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.Point3d;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class TestInterfaceFinder {\n\n    private static final Logger logger = LoggerFactory.getLogger(TestInterfaceFinder.class);\n\n    @Test\n    public void testGetAllInterfaces() {\n        Structure s = mockStructure();\n        InterfaceFinder finder = new InterfaceFinder(s);\n\n        StructureInterfaceList list = finder.getAllInterfaces();\n\n        assertEquals(3, list.size());\n\n        Set<Pair<String>> unique = new HashSet<>();\n\n        for (StructureInterface interf : list) {\n            System.out.println(\"Interface \" + interf.getMoleculeIds());\n            AtomContactSet set = interf.getContacts();\n            for (AtomContact c : set)\n                System.out.println(c.getPair() +\" - \" + c.getDistance());\n\n            unique.add(interf.getMoleculeIds());\n\n        }\n        assertEquals(3, unique.size());\n    }\n\n    /**\n     * Create a mock structure with 2 entities 1 (chains A, B) and 2 (chain C).\n     * @return a structure\n     */\n    private Structure mockStructure() {\n        Structure structure = new StructureImpl();\n        EntityInfo entity1 = new EntityInfo();\n        entity1.setMolId(1);\n        EntityInfo entity2 = new EntityInfo();\n        entity2.setMolId(2);\n        structure.addEntityInfo(entity1);\n        structure.addEntityInfo(entity2);\n\n        Chain chainA = new ChainImpl();\n        chainA.setId(\"A\");\n        chainA.setName(\"A\");\n        Chain chainB = new ChainImpl();\n        chainB.setId(\"B\");\n        chainB.setName(\"B\");\n        entity1.addChain(chainA);\n        entity1.addChain(chainB);\n        Chain chainC = new ChainImpl();\n        chainC.setId(\"C\");\n        chainC.setName(\"C\");\n        entity2.addChain(chainC);\n\n        structure.addChain(chainA);\n        structure.addChain(chainB);\n        structure.addChain(chainC);\n\n        // entity 1: chain A 10 observed residues, chain B 9 observed residues (first unobserved)\n        List<Group> aGroups = getGroupList(10, \"ALA\", chainA, new Point3d(0,0,0));\n        chainA.setAtomGroups(new ArrayList<>(aGroups));\n        chainA.setSeqResGroups(aGroups);\n        chainA.setEntityInfo(entity1);\n\n        List<Group> bGroups = getGroupList(10, \"ALA\", chainB, new Point3d(4, 0, 0));\n        chainB.setAtomGroups(new ArrayList<>(bGroups.subList(1,10)));\n        chainB.setSeqResGroups(bGroups);\n        chainB.setEntityInfo(entity1);\n\n        List<Group> cGroups = getGroupList(20, \"GLY\", chainC, new Point3d(0, 4, 0));\n        chainC.setAtomGroups(new ArrayList<>(cGroups));\n        chainC.setSeqResGroups(cGroups);\n        chainC.setEntityInfo(entity2);\n\n        return structure;\n    }\n\n    private List<Group> getGroupList(int size, String type, Chain chain, Point3d center) {\n        List<Group> list = new ArrayList<>();\n        double offsetx = 0;\n        double offsety = 0;\n        double offsetz = 0;\n        for (int i=0;i<size;i++) {\n            Group g = new AminoAcidImpl();\n            g.setPDBName(type);\n            g.setResidueNumber(new ResidueNumber(chain.getId(), i+1, null));\n            chain.addGroup(g);\n            Atom a = new AtomImpl();\n            a.setName(StructureTools.CA_ATOM_NAME);\n            a.setX(center.x + offsetx);\n            a.setY(center.y + offsety);\n            a.setZ(center.z + offsetz);\n            g.addAtom(a);\n            list.add(g);\n\n            if (i%3 == 0) offsetx += 1;\n            if (i%3 == 1) offsety += 1;\n            if (i%3 == 2) offsetz += 1;\n        }\n\n        return list;\n    }\n\n}\n","commitMessage":"Fixes\n","test_commitMessage":"Cleanup\n","allZero":false}