{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/molbio/RestrictionEnzyme.java","test_path":"core/src/test/java/org/biojava/bio/molbio/RestrictionEnzymeTest.java","prod_time":"2009-10-10 06:18:49","test_time":"2009-10-10 06:18:49","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"POSITIVE","prod_commitID":"a4668eff3bdbbce5a2cbd7523167c867315b2087","test_commitID":"a4668eff3bdbbce5a2cbd7523167c867315b2087","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport java.io.Serializable;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.MotifTools;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * <code>RestrictionEnzyme</code> represents a restriction enzyme\n * according to the REBASE standard. The cut positions are indicated\n * relative to the 5' end of the recognition site and occur downstream\n * of the given residue. Note that some enzmyes cut in more than one\n * position and that cut positions may occur outside the recognition\n * site.\n *\n * @author Keith James\n * @since 1.3\n */\npublic class RestrictionEnzyme implements Serializable\n{\n    /**\n     * <code>CUT_SIMPLE</code> a cut type where the enzyme cuts in one\n     * position relative to the recognition site. This covers the vast\n     * majority of cases.\n     */\n    public static final int CUT_SIMPLE = 0;\n\n    /**\n     * <code>CUT_COMPOUND</code> a cut type where the enzyme cuts in\n     * two positions relative to the recognition site.\n     */\n    public static final int CUT_COMPOUND = 1;\n\n    /**\n     * <code>OVERHANG_5PRIME</code> the sticky end type created by\n     * enzymes which leave a 5' overhang.\n     */\n    public static final int OVERHANG_5PRIME = 0;\n\n    /**\n     * <code>OVERHANG_3PRIME</code> the sticky end type created by\n     * enzymes which leave a 3' overhang.\n     */\n    public static final int OVERHANG_3PRIME = 1;\n\n    /**\n     * <code>BLUNT</code> the end type created by enzymes which leave\n     * a blunt end.\n     */\n    public static final int BLUNT = 2;\n\n    protected String name;\n    protected SymbolList site;\n    protected int cutType;\n    protected int [] dsCutPositions;\n    protected int [] usCutPositions;\n\n    protected String forwardRegex;\n    protected String reverseRegex;\n\n    private String summary;\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code> which cuts within\n     * or downstream of the recognition site. The cut position indices\n     * are <strong>always</strong> in the same coordinate space as the\n     * recognition site. <code>RestrictionEnzyme</code>s are\n     * immutable.\n     *\n     * @param name a <code>String</code> such as EcoRI.\n     * @param site a <code>SymbolList</code> recognition site.\n     * @param dsForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3') of the recognition site at which the\n     * cut occurs. The cut occurs between this base and the following\n     * one.\n     * @param dsReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5') of the recognition site at which the\n     * cut occurs. The cut occurs between this base and the following\n     * one.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    public RestrictionEnzyme(String name, SymbolList site,\n                             int dsForward, int dsReverse)\n        throws IllegalAlphabetException\n    {\n        this(name, site,\n             null,\n             new int [] { dsForward, dsReverse });\n        cutType = CUT_SIMPLE;\n    }\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code> of the unusual\n     * type which cuts both upstream and downstream of its recognition\n     * site. The cut position indices are <strong>always</strong> in\n     * the same coordinate space as the recognition site.\n     *\n     * @param name a <code>String</code> such as Bsp24I.\n     * @param site a <code>SymbolList</code> recognition site.\n     * @param usForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3' upstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param usReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5) upstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param dsForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3') downstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param dsReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5') downstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    public RestrictionEnzyme(String name, SymbolList site,\n                             int usForward, int usReverse,\n                             int dsForward, int dsReverse)\n        throws IllegalAlphabetException\n    {\n        this(name, site,\n             new int [] { usForward, usReverse },\n             new int [] { dsForward, dsReverse });\n        cutType = CUT_COMPOUND;\n    }\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code>.\n     *\n     * @param name a <code>String</code> name.\n     * @param site a <code>SymbolList</code> site.\n     * @param usCutPositions an <code>int []</code> array of optional\n     * upstream indices.\n     * @param dsCutPositions an <code>int []</code> array of\n     * downstream indices.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    private RestrictionEnzyme(String name, SymbolList site,\n                              int [] usCutPositions,\n                              int [] dsCutPositions)\n        throws IllegalAlphabetException\n    {\n        if (site.getAlphabet() != DNATools.getDNA())\n            throw new IllegalAlphabetException(\"RestrictionEnzyme site can only be a DNA SymbolList.\"\n                                               + \" A SymbolList using the \"\n                                               + site.getAlphabet().getName()\n                                               + \" was supplied\" );\n        this.name = name;\n        this.site = site;\n        this.usCutPositions = usCutPositions;\n        this.dsCutPositions = dsCutPositions;\n\n        forwardRegex = MotifTools.createRegex(site);\n\n        try\n        {\n            reverseRegex =\n                MotifTools.createRegex(DNATools.reverseComplement(site));\n        }\n        catch (IllegalAlphabetException iae)\n        {\n            throw new BioError(\"RestrictionEnzyme site was not composed of a complementable Alphabet\", iae);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        sb.append(name);\n        sb.append(\" \");\n\n        if (usCutPositions != null)\n        {\n            sb.append(\"(\");\n            sb.append(usCutPositions[0]);\n            sb.append(\"/\");\n            sb.append(usCutPositions[1]);\n            sb.append(\") \");\n        }\n\n        try\n        {\n            for (int i = 1; i <= site.length(); i++)\n                sb.append(Character.toUpperCase(DNATools.dnaToken(site.symbolAt(i))));\n        }\n        catch (IllegalSymbolException ise)\n        {\n            throw new BioError(\"RestrictionEnzyme site contained non-DNA Symbol\", ise);\n        }\n\n        sb.append(\" (\");\n        sb.append(dsCutPositions[0]);\n        sb.append(\"/\");\n        sb.append(dsCutPositions[1]);\n        sb.append(\")\");\n\n        summary = sb.substring(0);\n    }\n\n    /**\n     * <code>getName</code> returns the enzyme name.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getName()\n    {\n        return name;\n    }\n\n    /**\n     * <code>getRecognitionSite</code> returns the forward strand of\n     * the recognition site.\n     *\n     * @return a <code>SymbolList</code>.\n     */\n    public SymbolList getRecognitionSite()\n    {\n        return site;\n    }\n\n    /**\n     * <code>getForwardRegex</code> returns a regular expression which\n     * matches the forward strand of the recognition site.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getForwardRegex()\n    {\n        return forwardRegex;\n    }\n\n    /**\n     * <code>getReverseRegex</code> returns a regular expression which\n     * matches the reverse strand of the recognition site.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getReverseRegex()\n    {\n        return reverseRegex;\n    }\n\n    /**\n     * <code>isPalindromic</code> returns true if the recognition site\n     * is palindromic.\n     *\n     * @return a <code>boolean</code>.\n     */\n    public boolean isPalindromic()\n    {\n        return forwardRegex.equals(reverseRegex);\n    }\n\n    /**\n     * <code>getCutType</code> returns the type of cut produced by the\n     * enzyme. This will be one of either RestrictionEnzyme.CUT_SIMPLE\n     * (where it cuts in one position relative to the recognition site\n     * i.e. the vast majority of cases) or\n     * RestrictionEnzyme.CUT_COMPOUND (where it cuts in two positions).\n     *\n     * @return an <code>int</code>.\n     */\n    public int getCutType()\n    {\n        return cutType;\n    }\n\n    /**\n     * <code>getDownstreamCut</code> returns the cut site within or\n     * downstream of the recognition site.\n     *\n     * @return an <code>int []</code> array with the position in the\n     * 5'- strand at index 0 and the 3'- strand at index 1.\n     */\n    public int [] getDownstreamCut()\n    {\n        return dsCutPositions;\n    }\n\n    /**\n     * <code>getUpstreamCut</code> returns the cut site upstream of\n     * the recognition site.\n     *\n     * @return an <code>int []</code> array with the position in the\n     * 5'- strand at index 0 and the 3'- strand at index 1.\n     *\n     * @exception BioException if the enzyme does not cleave on both\n     * sides of its recognition site.\n     */\n    public int [] getUpstreamCut() throws BioException\n    {\n        if (cutType == CUT_SIMPLE)\n            throw new BioException(name + \" does not cut upstream of the recognition site\");\n\n        return usCutPositions;\n    }\n\n    /**\n     * <code>getDownstreamEndType</code> returns the double-stranded\n     * end type produced by the primary (intra-site or downstream)\n     * cut.\n     *\n     * @return an <code>int</code> equal to one of the constant fields\n     * OVERHANG_5PRIME, OVERHANG_3PRIME or BLUNT.\n     */\n    public int getDownstreamEndType()\n    {\n        if (dsCutPositions[0] > dsCutPositions[1])\n            return OVERHANG_5PRIME;\n        else if (dsCutPositions[0] < dsCutPositions[1])\n            return OVERHANG_3PRIME;\n        else\n            return BLUNT;\n    }\n\n    /**\n     * <code>getUpstreamEndType</code> returns the double-stranded end\n     * type produced by the secondary (upstream) cut.\n     *\n     * @return an <code>int</code> equal to one of the constant fields\n     * OVERHANG_5PRIME, OVERHANG_3PRIME or BLUNT.\n     *\n     * @exception BioException if the enzyme does not cleave on both\n     * sides of its recognition site.\n     */\n    public int getUpstreamEndType() throws BioException\n    {\n        if (cutType == CUT_SIMPLE)\n            throw new BioException(name + \" does not cut upstream of the recognition site\");\n\n        if (usCutPositions[0] > usCutPositions[1])\n            return OVERHANG_5PRIME;\n        else if (usCutPositions[0] < usCutPositions[1])\n            return OVERHANG_3PRIME;\n        else\n            return BLUNT;\n    }\n\n    public int hashCode()\n    {\n        return name.hashCode() ^ forwardRegex.hashCode();\n    }\n\n    public boolean equals(Object o)\n    {\n        return (o instanceof RestrictionEnzyme)\n            && name.equals(((RestrictionEnzyme) o).getName());\n    }\n\n    public String toString()\n    {\n        return summary;\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport java.io.Serializable;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.MotifTools;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * <code>RestrictionEnzyme</code> represents a restriction enzyme\n * according to the REBASE standard. The cut positions are indicated\n * relative to the 5' end of the recognition site and occur downstream\n * of the given residue. Note that some enzymes cut in more than one\n * position and that cut positions may occur outside the recognition\n * site.\n *\n * @author Keith James\n * @author George Waldon - fix cutsites\n * @since 1.3\n */\npublic class RestrictionEnzyme implements Serializable\n{\n    /**\n     * <code>CUT_SIMPLE</code> a cut type where the enzyme cuts in one\n     * position relative to the recognition site. This covers the vast\n     * majority of cases.\n     */\n    public static final int CUT_SIMPLE = 0;\n\n    /**\n     * <code>CUT_COMPOUND</code> a cut type where the enzyme cuts in\n     * two positions relative to the recognition site.\n     */\n    public static final int CUT_COMPOUND = 1;\n\n    /**\n     * <code>OVERHANG_5PRIME</code> the sticky end type created by\n     * enzymes which leave a 5' overhang (e.g. a stretch of single-stranded\n     * DNA with a free 5' end).\n     */\n    public static final int OVERHANG_5PRIME = 0;\n\n    /**\n     * <code>OVERHANG_3PRIME</code> the sticky end type created by\n     * enzymes which leave a 3' overhang (e.g. a stretch of single-stranded\n     * DNA with a free 3' end).\n     */\n    public static final int OVERHANG_3PRIME = 1;\n\n    /**\n     * <code>BLUNT</code> the end type created by enzymes which leave\n     * a blunt end.\n     */\n    public static final int BLUNT = 2;\n\n    protected String name;\n    protected SymbolList site;\n    protected int cutType;\n    protected int [] dsCutPositions;\n    protected int [] usCutPositions;\n\n    protected String forwardRegex;\n    protected String reverseRegex;\n\n    private String summary;\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code> which cuts within\n     * or downstream of the recognition site. The cut position indices\n     * are <strong>always</strong> in the same coordinate space as the\n     * recognition site. <code>RestrictionEnzyme</code>s are\n     * immutable.\n     *\n     * @param name a <code>String</code> such as EcoRI.\n     * @param site a <code>SymbolList</code> recognition site.\n     * @param dsForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3') of the recognition site at which the\n     * cut occurs. The cut occurs between this base and the following\n     * one.\n     * @param dsReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5') of the recognition site at which the\n     * cut occurs. The cut occurs between this base and the following\n     * one.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    public RestrictionEnzyme(String name, SymbolList site,\n                             int dsForward, int dsReverse)\n        throws IllegalAlphabetException\n    {\n        this(name, site,\n             null,\n             new int [] { dsForward, dsReverse });\n        cutType = CUT_SIMPLE;\n    }\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code> of the unusual\n     * type which cuts both upstream and downstream of its recognition\n     * site. The cut position indices are <strong>always</strong> in\n     * the same coordinate space as the recognition site.\n     *\n     * @param name a <code>String</code> such as Bsp24I.\n     * @param site a <code>SymbolList</code> recognition site.\n     * @param usForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3' upstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param usReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5) upstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param dsForward an <code>int</code> index in the forward\n     * strand (the strand conventionally written\n     * <strong>5'</strong>-3') downstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     * @param dsReverse an <code>int</code> index in the reverse\n     * strand (the strand conventionally written\n     * <strong>3'</strong>-5') downstream of the recognition site at\n     * which the cut occurs. The cut occurs between this base and the\n     * following one.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    public RestrictionEnzyme(String name, SymbolList site,\n                             int usForward, int usReverse,\n                             int dsForward, int dsReverse)\n        throws IllegalAlphabetException\n    {\n        this(name, site,\n             new int [] { usForward, usReverse },\n             new int [] { dsForward, dsReverse });\n        cutType = CUT_COMPOUND;\n    }\n\n    /**\n     * Creates a new <code>RestrictionEnzyme</code>.\n     *\n     * @param name a <code>String</code> name.\n     * @param site a <code>SymbolList</code> site.\n     * @param usCutPositions an <code>int []</code> array of optional\n     * upstream indices.\n     * @param dsCutPositions an <code>int []</code> array of\n     * downstream indices.\n     *\n     * @exception IllegalAlphabetException if an error occurs.\n     */\n    private RestrictionEnzyme(String name, SymbolList site,\n                              int [] usCutPositions,\n                              int [] dsCutPositions)\n        throws IllegalAlphabetException\n    {\n        if (site.getAlphabet() != DNATools.getDNA())\n            throw new IllegalAlphabetException(\"RestrictionEnzyme site can only be a DNA SymbolList.\"\n                                               + \" A SymbolList using the \"\n                                               + site.getAlphabet().getName()\n                                               + \" was supplied\" );\n        this.name = name;\n        this.site = site;\n        this.usCutPositions = usCutPositions;\n        this.dsCutPositions = dsCutPositions;\n\n        forwardRegex = MotifTools.createRegex(site);\n\n        try\n        {\n            reverseRegex =\n                MotifTools.createRegex(DNATools.reverseComplement(site));\n        }\n        catch (IllegalAlphabetException iae)\n        {\n            throw new BioError(\"RestrictionEnzyme site was not composed of a complementable Alphabet\", iae);\n        }\n\n        StringBuffer sb = new StringBuffer();\n        sb.append(name);\n        sb.append(\" \");\n\n        if (usCutPositions != null)\n        {\n            sb.append(\"(\");\n            sb.append(usCutPositions[0]);\n            sb.append(\"/\");\n            sb.append(usCutPositions[1]);\n            sb.append(\") \");\n        }\n\n        try\n        {\n            for (int i = 1; i <= site.length(); i++)\n                sb.append(Character.toUpperCase(DNATools.dnaToken(site.symbolAt(i))));\n        }\n        catch (IllegalSymbolException ise)\n        {\n            throw new BioError(\"RestrictionEnzyme site contained non-DNA Symbol\", ise);\n        }\n\n        sb.append(\" (\");\n        sb.append(dsCutPositions[0]);\n        sb.append(\"/\");\n        sb.append(dsCutPositions[1]);\n        sb.append(\")\");\n\n        summary = sb.substring(0);\n    }\n\n    /**\n     * <code>getName</code> returns the enzyme name.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getName()\n    {\n        return name;\n    }\n\n    /**\n     * <code>getRecognitionSite</code> returns the forward strand of\n     * the recognition site.\n     *\n     * @return a <code>SymbolList</code>.\n     */\n    public SymbolList getRecognitionSite()\n    {\n        return site;\n    }\n\n    /**\n     * <code>getForwardRegex</code> returns a regular expression which\n     * matches the forward strand of the recognition site.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getForwardRegex()\n    {\n        return forwardRegex;\n    }\n\n    /**\n     * <code>getReverseRegex</code> returns a regular expression which\n     * matches the reverse strand of the recognition site.\n     *\n     * @return a <code>String</code>.\n     */\n    public String getReverseRegex()\n    {\n        return reverseRegex;\n    }\n\n    /**\n     * <code>isPalindromic</code> returns true if the recognition site\n     * is palindromic.\n     *\n     * @return a <code>boolean</code>.\n     */\n    public boolean isPalindromic()\n    {\n        return forwardRegex.equals(reverseRegex);\n    }\n\n    /**\n     * <code>getCutType</code> returns the type of cut produced by the\n     * enzyme. This will be one of either RestrictionEnzyme.CUT_SIMPLE\n     * (where it cuts in one position relative to the recognition site\n     * i.e. the vast majority of cases) or\n     * RestrictionEnzyme.CUT_COMPOUND (where it cuts in two positions).\n     *\n     * @return an <code>int</code>.\n     */\n    public int getCutType()\n    {\n        return cutType;\n    }\n\n    /**\n     * <code>getDownstreamCut</code> returns the cut site within or\n     * downstream of the recognition site.\n     *\n     * @return an <code>int []</code> array with the position in the\n     * 5'-strand at index 0 and the 3'-strand at index 1.\n     */\n    public int [] getDownstreamCut()\n    {\n        return dsCutPositions;\n    }\n\n    /**\n     * <code>getUpstreamCut</code> returns the cut site upstream of\n     * the recognition site.\n     *\n     * @return an <code>int []</code> array with the position in the\n     * 5'-strand at index 0 and the 3'-strand at index 1. For example,\n     * Bsp24I will return -8 and -13:\n     *\n     *          5'      ^NNNNNNNNGACNNNNNNTGGNNNNNNNNNNNN^   3'\n     *          3' ^NNNNNNNNNNNNNCTGNNNNNNACCNNNNNNN^        5'\n     *\n     * @exception BioException if the enzyme does not cleave on both\n     * sides of its recognition site.\n     */\n    public int [] getUpstreamCut() throws BioException\n    {\n        if (cutType == CUT_SIMPLE)\n            throw new BioException(name + \" does not cut upstream of the recognition site\");\n\n        return usCutPositions;\n    }\n\n    /**\n     * <code>getDownstreamEndType</code> returns the double-stranded\n     * end type produced by the primary (intra-site or downstream)\n     * cut.\n     *\n     * @return an <code>int</code> equal to one of the constant fields\n     * OVERHANG_5PRIME, OVERHANG_3PRIME or BLUNT.\n     */\n    public int getDownstreamEndType()\n    {\n        if (dsCutPositions[0] > dsCutPositions[1])\n            return OVERHANG_3PRIME;\n        else if (dsCutPositions[0] < dsCutPositions[1])\n            return OVERHANG_5PRIME;\n        else\n            return BLUNT;\n    }\n\n    /**\n     * <code>getUpstreamEndType</code> returns the double-stranded end\n     * type produced by the secondary (upstream) cut.\n     *\n     * @return an <code>int</code> equal to one of the constant fields\n     * OVERHANG_5PRIME, OVERHANG_3PRIME or BLUNT.\n     *\n     * @exception BioException if the enzyme does not cleave on both\n     * sides of its recognition site.\n     */\n    public int getUpstreamEndType() throws BioException\n    {\n        if (cutType == CUT_SIMPLE)\n            throw new BioException(name + \" does not cut upstream of the recognition site\");\n\n        if (usCutPositions[0] > usCutPositions[1])\n            return OVERHANG_3PRIME;\n        else if (usCutPositions[0] < usCutPositions[1])\n            return OVERHANG_5PRIME;\n        else\n            return BLUNT;\n    }\n\n    public int hashCode()\n    {\n        return name.hashCode() ^ forwardRegex.hashCode();\n    }\n\n    public boolean equals(Object o)\n    {\n        return (o instanceof RestrictionEnzyme)\n            && name.equals(((RestrictionEnzyme) o).getName());\n    }\n\n    public String toString()\n    {\n        return summary;\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * <code>RestrictionEnzymeTest</code> tests enzyme functionality.\n *\n * @author Keith James\n */\npublic class RestrictionEnzymeTest extends TestCase\n{\n    public RestrictionEnzymeTest(String name)\n    {\n        super(name);\n    }\n\n    public void testGetName() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(\"EcoRI\", ecoRI.getName());\n    }\n\n    public void testGetRecognitionSite() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        SymbolList site = ecoRI.getRecognitionSite();\n\n        SymbolList test = null;\n        try\n        {\n            test = DNATools.createDNA(\"GAATTC\");\n        }\n        catch (IllegalSymbolException ise)\n        {\n            throw new BioError(ise, \"Internal error in test\");\n        }\n\n        for (int i = 1; i <= site.length(); i++)\n        {\n            assertEquals(test.symbolAt(i), site.symbolAt(i));\n        }\n    }\n\n    public void testIsPalindromic()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertTrue(ecoRI.isPalindromic());\n\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertTrue(! bsp24I.isPalindromic());\n    }\n\n    public void testGetCutType()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(RestrictionEnzyme.CUT_SIMPLE, ecoRI.getCutType());\n\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertEquals(RestrictionEnzyme.CUT_COMPOUND, bsp24I.getCutType());\n    }\n\n    public void testGetDownstreamCut() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        int [] ds = ecoRI.getDownstreamCut();\n\n        assertEquals(1, ds[0]);\n        assertEquals(5, ds[1]);\n    }\n\n    public void testGetUpstreamCut() throws BioException\n    {\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        int [] us = bsp24I.getUpstreamCut();\n\n        assertEquals(8,  us[0]);\n        assertEquals(13, us[1]);\n\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        try\n        {\n            us = ecoRI.getUpstreamCut();\n        }\n        catch (BioException be)\n        {\n            return;\n        }\n\n        fail(\"Expected BioException\");\n    }\n\n    public void testGetDownstreamEndType() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(RestrictionEnzyme.OVERHANG_3PRIME,\n                     ecoRI.getDownstreamEndType());\n\n        RestrictionEnzyme apaI = RestrictionEnzymeManager.getEnzyme(\"ApaI\");\n        assertEquals(RestrictionEnzyme.OVERHANG_5PRIME,\n                     apaI.getDownstreamEndType());\n\n        RestrictionEnzyme smaI = RestrictionEnzymeManager.getEnzyme(\"SmaI\");\n        assertEquals(RestrictionEnzyme.BLUNT,\n                     smaI.getDownstreamEndType());\n    }\n\n    public void testGetUpstreamEndType() throws BioException\n    {\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertEquals(RestrictionEnzyme.OVERHANG_3PRIME,\n                     bsp24I.getUpstreamEndType());\n\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        try\n        {\n            ecoRI.getUpstreamEndType();\n        }\n        catch (BioException be)\n        {\n            return;\n        }\n\n        fail(\"Expected BioException\");\n    }\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.molbio;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * <code>RestrictionEnzymeTest</code> tests enzyme functionality.\n *\n * @author Keith James\n * @author George Waldon - fix upstream cutsites\n */\npublic class RestrictionEnzymeTest extends TestCase\n{\n    public RestrictionEnzymeTest(String name)\n    {\n        super(name);\n    }\n\n    public void testGetName() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(\"EcoRI\", ecoRI.getName());\n    }\n\n    public void testGetRecognitionSite() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        SymbolList site = ecoRI.getRecognitionSite();\n\n        SymbolList test = null;\n        try\n        {\n            test = DNATools.createDNA(\"GAATTC\");\n        }\n        catch (IllegalSymbolException ise)\n        {\n            throw new BioError(ise, \"Internal error in test\");\n        }\n\n        for (int i = 1; i <= site.length(); i++)\n        {\n            assertEquals(test.symbolAt(i), site.symbolAt(i));\n        }\n    }\n\n    public void testIsPalindromic()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertTrue(ecoRI.isPalindromic());\n\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertTrue(! bsp24I.isPalindromic());\n    }\n\n    public void testGetCutType()\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(RestrictionEnzyme.CUT_SIMPLE, ecoRI.getCutType());\n\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertEquals(RestrictionEnzyme.CUT_COMPOUND, bsp24I.getCutType());\n    }\n\n    public void testGetDownstreamCut() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        int [] ds = ecoRI.getDownstreamCut();\n\n        assertEquals(1, ds[0]);\n        assertEquals(5, ds[1]);\n    }\n\n    public void testGetUpstreamCut() throws BioException\n    {\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        int [] us = bsp24I.getUpstreamCut();\n\n        assertEquals(-8,  us[0]);\n        assertEquals(-13, us[1]);\n\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        try\n        {\n            us = ecoRI.getUpstreamCut();\n        }\n        catch (BioException be)\n        {\n            return;\n        }\n\n        fail(\"Expected BioException\");\n    }\n\n    public void testGetDownstreamEndType() throws BioException\n    {\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        assertEquals(RestrictionEnzyme.OVERHANG_5PRIME,\n                     ecoRI.getDownstreamEndType());\n\n        RestrictionEnzyme apaI = RestrictionEnzymeManager.getEnzyme(\"ApaI\");\n        assertEquals(RestrictionEnzyme.OVERHANG_3PRIME,\n                     apaI.getDownstreamEndType());\n\n        RestrictionEnzyme smaI = RestrictionEnzymeManager.getEnzyme(\"SmaI\");\n        assertEquals(RestrictionEnzyme.BLUNT,\n                     smaI.getDownstreamEndType());\n    }\n\n    public void testGetUpstreamEndType() throws BioException\n    {\n        RestrictionEnzyme bsp24I = RestrictionEnzymeManager.getEnzyme(\"Bsp24I\");\n        assertEquals(RestrictionEnzyme.OVERHANG_3PRIME,\n                     bsp24I.getUpstreamEndType());\n\n        RestrictionEnzyme ecoRI = RestrictionEnzymeManager.getEnzyme(\"EcoRI\");\n        try\n        {\n            ecoRI.getUpstreamEndType();\n        }\n        catch (BioException be)\n        {\n            return;\n        }\n\n        fail(\"Expected BioException\");\n    }\n}\n","commitMessage":"Fix restriction enzyme overhangs and upstream cutsites.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7240 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Fix restriction enzyme overhangs and upstream cutsites.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7240 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}