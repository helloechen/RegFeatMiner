{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/FastaStreamer.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/FastaStreamerTest.java","prod_time":"2024-01-14 21:37:34","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ef665e26ce560ac2c14af46535e250f61336d84b","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.util.InputStreamProvider;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class FastaStreamer {\n\n\tprivate final Path path;\n\tprivate int batchSize = 1_000;\n\tprivate SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser;\n\tprivate SequenceCreatorInterface<AminoAcidCompound> sequenceCreator;\n\tprivate LinkedHashMap<String, ProteinSequence> chunk = new LinkedHashMap<>();\n\tprivate Iterator<Map.Entry<String, ProteinSequence>> iterator = Collections.emptyIterator();\n\tprivate boolean closed = false;\n\n\t/**\n\t * The constructor is private.  Created via the <tt>from(...)</tt> static factory method\n\t *\n\t * @param path the path to the file containing the FASTA content (possibly GZipped)\n\t */\n\tprivate FastaStreamer(final Path path) {\n\t\tthis.path = path;\n\t}\n\n\tpublic static FastaStreamer from(final Path path) {\n\t\treturn new FastaStreamer(path);\n\t}\n\n\tpublic static FastaStreamer from(File file) {\n\t\treturn from(file.toPath());\n\t}\n\n\tpublic FastaStreamer withHeaderParser(SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser) {\n\t\tthis.headerParser = headerParser;\n\t\treturn this;\n\t}\n\n\tpublic FastaStreamer withSequenceCreator(SequenceCreatorInterface<AminoAcidCompound> sequenceCreator) {\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\treturn this;\n\t}\n\n\tpublic FastaStreamer batchSize(int size) {\n\t\tthis.batchSize = size;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a stream of protein sequences from the contents of the path\n\t * @return the stream\n\t * @throws IOException if there is an error opening the file\n\t */\n\tpublic Stream<ProteinSequence> stream() throws IOException {\n\t\tInputStreamProvider provider = new InputStreamProvider();\n\t\tInputStream input = provider.getInputStream(getPath().toFile());\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> reader = new FastaReader<>(input, getHeaderParser(), getSequenceCreator());\n\t\tSpliterator<ProteinSequence> source = new Spliterators.AbstractSpliterator<>(Integer.MAX_VALUE, Spliterator.IMMUTABLE | Spliterator.NONNULL) {\n\t\t\t@Override\n\t\t\tpublic boolean tryAdvance(Consumer<? super ProteinSequence> action) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tProteinSequence protein = next(reader);\n\t\t\t\tif (null == protein) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\taction.accept(protein);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Fetch the next header/protein tuple from the cache.  If the cache is empty, fetch another\n\t\t\t * batch from the source file\n\t\t\t *\n\t\t\t * @param reader\n\t\t\t * \t\tthe input stream from which the FASTA content is read\n\t\t\t * @return the protein sequence\n\t\t\t */\n\t\t\tprivate ProteinSequence next(FastaReader<ProteinSequence, AminoAcidCompound> reader) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!iterator.hasNext()) {\n\t\t\t\t\t\tchunk = reader.process(getBatchSize());\n\t\t\t\t\t\tif (null == chunk) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\treader.close();\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titerator = chunk.entrySet().iterator();\n\t\t\t\t\t}\n\t\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t\tMap.Entry<String, ProteinSequence> entry = iterator.next();\n\t\t\t\t\t\treturn createSequence(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t\tclosed = true;\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new RuntimeException(String.format(\"I/O error reading the FASTA file from '%s'\", getPath()));\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}; // Spliterator\n\t\treturn StreamSupport.stream(source, false);\n\t}\n\n\t/**\n\t * Create the sequence with the information from the header.  This implementation return the sequence as-is, but\n\t * this is an opportunity for the implementer to build specifc information into the user collection space\n\t * of the sequence\n\t *\n\t * @param header the original header\n\t * @param sequence the protein sequence\n\t * @return the sequence\n\t */\n\tprotected ProteinSequence createSequence(String header, ProteinSequence sequence) {\n\t\treturn sequence;\n\t}\n\n\tprotected Path getPath() {\n\t\treturn path;\n\t}\n\n\tprotected int getBatchSize() {\n\t\treturn batchSize;\n\t}\n\n\tprotected SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> getHeaderParser() {\n\t\treturn Optional.ofNullable(headerParser).orElse(new GenericFastaHeaderParser<>());\n\t}\n\n\tpublic SequenceCreatorInterface<AminoAcidCompound> getSequenceCreator() {\n\t\treturn Optional.ofNullable(sequenceCreator).orElse(new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t}\n}\n","changedPro":"package org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.util.InputStreamProvider;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * Read from a FASTA file (or gzipped FASTA file) and create a Java stream of {@link ProteinSequence} objects\n * for use in a functional programming paradigm.\n *\n * @author Gary Murphy\n * @since 7.0.3\n */\npublic class FastaStreamer {\n\n\tprivate final Path path;\n\tprivate int batchSize = 1_000;\n\tprivate SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser;\n\tprivate SequenceCreatorInterface<AminoAcidCompound> sequenceCreator;\n\tprivate LinkedHashMap<String, ProteinSequence> chunk = new LinkedHashMap<>();\n\tprivate Iterator<Map.Entry<String, ProteinSequence>> iterator = Collections.emptyIterator();\n\tprivate boolean closed = false;\n\n\t/**\n\t * The constructor is private.  Created via the <tt>from(...)</tt> static factory method\n\t *\n\t * @param path the path to the file containing the FASTA content (possibly GZipped)\n\t */\n\tprivate FastaStreamer(final Path path) {\n\t\tthis.path = path;\n\t}\n\n\tpublic static FastaStreamer from(final Path path) {\n\t\treturn new FastaStreamer(path);\n\t}\n\n\tpublic static FastaStreamer from(File file) {\n\t\treturn from(file.toPath());\n\t}\n\n\tpublic FastaStreamer withHeaderParser(SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser) {\n\t\tthis.headerParser = headerParser;\n\t\treturn this;\n\t}\n\n\tpublic FastaStreamer withSequenceCreator(SequenceCreatorInterface<AminoAcidCompound> sequenceCreator) {\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\treturn this;\n\t}\n\n\tpublic FastaStreamer batchSize(int size) {\n\t\tthis.batchSize = size;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a stream of protein sequences from the contents of the path\n\t * @return the stream\n\t * @throws IOException if there is an error opening the file\n\t */\n\tpublic Stream<ProteinSequence> stream() throws IOException {\n\t\tInputStreamProvider provider = new InputStreamProvider();\n\t\tInputStream input = provider.getInputStream(getPath().toFile());\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> reader = new FastaReader<>(input, getHeaderParser(), getSequenceCreator());\n\t\tSpliterator<ProteinSequence> source = new Spliterators.AbstractSpliterator<>(Integer.MAX_VALUE, Spliterator.IMMUTABLE | Spliterator.NONNULL) {\n\t\t\t@Override\n\t\t\tpublic boolean tryAdvance(Consumer<? super ProteinSequence> action) {\n\t\t\t\tif (closed) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tProteinSequence protein = next(reader);\n\t\t\t\tif (null == protein) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\taction.accept(protein);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Fetch the next header/protein tuple from the cache.  If the cache is empty, fetch another\n\t\t\t * batch from the source file\n\t\t\t *\n\t\t\t * @param reader\n\t\t\t * \t\tthe input stream from which the FASTA content is read\n\t\t\t * @return the protein sequence\n\t\t\t */\n\t\t\tprivate ProteinSequence next(FastaReader<ProteinSequence, AminoAcidCompound> reader) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!iterator.hasNext()) {\n\t\t\t\t\t\tchunk = reader.process(getBatchSize());\n\t\t\t\t\t\tif (null == chunk) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\treader.close();\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\titerator = chunk.entrySet().iterator();\n\t\t\t\t\t}\n\t\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\t\tMap.Entry<String, ProteinSequence> entry = iterator.next();\n\t\t\t\t\t\treturn createSequence(entry.getKey(), entry.getValue());\n\t\t\t\t\t}\n\t\t\t\t\tclosed = true;\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException exception) {\n\t\t\t\t\tthrow new RuntimeException(String.format(\"I/O error reading the FASTA file from '%s'\", getPath()));\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}; // Spliterator\n\t\treturn StreamSupport.stream(source, false);\n\t}\n\n\t/**\n\t * Create the sequence with the information from the header.  This implementation return the sequence as-is, but\n\t * this is an opportunity for the implementer to build specific information into the user collection space\n\t * of the sequence\n\t *\n\t * @param header the original header\n\t * @param sequence the protein sequence\n\t * @return the sequence\n\t */\n\tprotected ProteinSequence createSequence(String header, ProteinSequence sequence) {\n\t\treturn sequence;\n\t}\n\n\tprotected Path getPath() {\n\t\treturn path;\n\t}\n\n\tprotected int getBatchSize() {\n\t\treturn batchSize;\n\t}\n\n\tprotected SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> getHeaderParser() {\n\t\treturn Optional.ofNullable(headerParser).orElse(new GenericFastaHeaderParser<>());\n\t}\n\n\tpublic SequenceCreatorInterface<AminoAcidCompound> getSequenceCreator() {\n\t\treturn Optional.ofNullable(sequenceCreator).orElse(new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t}\n}\n","originTest":"package org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * Test the functionality of the {@link FastaStreamer} code\n */\npublic class FastaStreamerTest {\n\n\t@Test\n\tpublic void stream() throws IOException {\n\t\tString file = this.getClass().getResource(\"PF00104_small.fasta.gz\").getFile();\n\t\tPath path = Paths.get(file);\n\t\tList<ProteinSequence> sequences;\n\n\t\tsequences = FastaStreamer.from(path).stream().collect(Collectors.toList());\n\t\tAssert.assertEquals(\"Count\", 283, sequences.size());\n\n\t\tProteinSequence sequence;\n\t\tsequence = sequences.get(0);\n\t\tAssert.assertEquals(\"A2D504_ATEGE/1-46\", sequence.getOriginalHeader());\n\t\tsequence = sequences.get(sequences.size()-1);\n\t\tAssert.assertEquals(\"Q98SJ1_CHICK/15-61\", sequence.getOriginalHeader());\n\n\t\tsequences = FastaStreamer.from(path)\n\t\t\t\t.batchSize(2) // Ensure there isn't an edge condition loading the next buffer\n\t\t\t\t.stream()\n\t\t\t\t.collect(Collectors.toList());\n\t\tAssert.assertEquals(\"Count\", 283, sequences.size());\n\t}\n}\n","changedTest":"","commitMessage":"Added comments\n","test_commitMessage":"","allZero":true}