{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/ResidueRange.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/ResidueRangeTest.java","prod_time":"2015-01-30 03:20:53","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":4,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"a1b74790e21b038699fe3f9f098474dee46aba28","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A chain, a start residue, and an end residue.\n * \n * @author dmyerstu\n * @see ResidueNumber\n * @see org.biojava.bio.structure.ResidueRangeAndLength\n */\npublic class ResidueRange {\n\n\tprivate final String chain;\n\tprivate final ResidueNumber end;\n\tprivate final ResidueNumber start;\n\n\tpublic static final Pattern RANGE_REGEX = Pattern.compile(\n\t\t\t\"^\\\\s*([a-zA-Z0-9]+|_)\" + //chain ID. Be flexible here, rather than restricting to 4-char IDs\n\t\t\t\"(?:\" + //begin range, this is a \"non-capturing group\"\n\t\t\t\t\"(?::|_|:$|_$|$)\" + //colon or underscore, could be at the end of a line, another non-capt. group.\n\t\t\t\t\"(?:\"+ // another non capturing group for the residue range\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // first residue\n\t\t\t\t\t\"\\\\s*-\\\\s*\" + // -\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // second residue\n\t\t\t\t\")?+\"+\n\t\t\t\")?\" + //end range\n\t\t\t\"\\\\s*\");\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end or chain.start-end. For example: <code>A.5-100</code> or <code>A_5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}\n\t */\n\tpublic static ResidueRange parse(String s) {\n\t\tResidueNumber start = null, end = null;\n\t\tString chain = null;\n\t\tMatcher matcher = RANGE_REGEX.matcher(s);\n\t\tif (matcher.matches()) {\n\t\t\ttry {\n\t\t\t\tchain = matcher.group(1);\n\t\t\t\tif (matcher.group(2) != null) {\n\t\t\t\t\tstart = ResidueNumber.fromString(matcher.group(2));\n\t\t\t\t\tend = ResidueNumber.fromString(matcher.group(3));\n\t\t\t\t\tstart.setChainId(chain);\n\t\t\t\t\tend.setChainId(chain);\n\t\t\t\t}\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range \" + s + \" was not valid\", e);\n\t\t\t}\n\t\t}\n\t\treturn new ResidueRange(chain, start, end);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(String chain, String start, String end) {\n\t\tthis.chain = chain;\n\t\tthis.start = ResidueNumber.fromString(start);\n\t\tthis.start.setChainId(chain);\n\t\tthis.end = ResidueNumber.fromString(end);\n\t\tthis.end.setChainId(chain);\n\t}\n\n\tpublic ResidueRange(String chain, ResidueNumber start, ResidueNumber end) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain == null) {\n\t\t\tif (other.chain != null) return false;\n\t\t} else if (!chain.equals(other.chain)) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\tpublic String getChainId() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (chain == null ? 0 : chain.hashCode());\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n\t/**\n\t * Returns the ResidueNumber that is at position {@code positionInRange} in\n\t * <em>this</em> ResidueRange.\n\t * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n\t */\n\tpublic ResidueNumber getResidue(int positionInRange, AtomPositionMap map) {\n\t\tif (map == null) throw new IllegalArgumentException(\"The AtomPositionMap must be non-null\");\n\t\tint i = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : map.getNavMap().entrySet()) {\n\t\t\tif (i == positionInRange) return entry.getKey();\n\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return True if and only if {@code residueNumber} is within this ResidueRange\n\t */\n\tpublic boolean contains(ResidueNumber residueNumber, AtomPositionMap map) {\n\t\tif (residueNumber == null)\n\t\t\tthrow new NullPointerException(\"Can't find a null ResidueNumber\");\n\t\tif (map == null)\n\t\t\tthrow new NullPointerException(\"The AtomPositionMap must be non-null\");\n\t\t// TODO treat missing bounds as full chain\n\t\tif (getStart() == null || getEnd() == null)\n\t\t\tthrow new IllegalArgumentException(\"The bounds of this ResidueNumber aren't known\");\n\t\tInteger pos = map.getPosition(residueNumber);\n\t\tif (pos == null) throw new IllegalArgumentException(\"Couldn't find residue \" + residueNumber.printFull());\n\t\tInteger startPos = map.getPosition(getStart());\n\t\tif (startPos == null) throw new IllegalArgumentException(\"Couldn't find the start position\");\n\t\tInteger endPos = map.getPosition(getEnd());\n\t\tif (endPos == null) throw new IllegalArgumentException(\"Couldn't find the end position\");\n\t\treturn pos >= startPos && pos <= endPos;\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic Iterator<ResidueNumber> iterator(final AtomPositionMap map) {\n\t\t//Use Entries to guarentee not null\n\t\tfinal Iterator<Entry<ResidueNumber, Integer>> entryIt = map.getNavMap().entrySet().iterator();\n\t\tif(! entryIt.hasNext()) {\n\t\t\t// empty iterator\n\t\t\treturn Arrays.asList(new ResidueNumber[0]).iterator();\n\t\t}\n\t\t// Peek at upcoming entry\n\t\t\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tEntry<ResidueNumber,Integer> next = loadNext();\n\t\t\t\n\t\t\tprivate Entry<ResidueNumber,Integer> loadNext() {\n\n\t\t\t\twhile( entryIt.hasNext() ) {\n\t\t\t\t\tnext = entryIt.next();\n\t\t\t\t\tResidueNumber nextPos = next.getKey();\n\t\t\t\t\tif( contains(nextPos, map)) {\n\t\t\t\t\t\t// loaded a valid next value\n\t\t\t\t\t\treturn next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext = null;\n\t\t\t\treturn next;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn next != null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tResidueNumber pos = next.getKey();\n\t\t\t\tloadNext();\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Not modifiable\");\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(final AtomPositionMap map, final ResidueRange... rrs) {\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate int r = 0;\n\t\t\tprivate Iterator<ResidueNumber> internal;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (r == rrs.length - 1) {\n\t\t\t\t\tinit();\n\t\t\t\t\treturn internal.hasNext();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprivate void init() {\n\t\t\t\tif (internal == null) {\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (rrs.length == 0) throw new NoSuchElementException();\n\t\t\t\tinit();\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tif (!internal.hasNext()) {\n\t\t\t\t\tr++;\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t\treturn internal.next();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Not modifiable\");\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(AtomPositionMap map, List<? extends ResidueRange> rrs) {\n\t\tResidueRange[] ranges = new ResidueRange[rrs.size()];\n\t\tfor (int i = 0; i < rrs.size(); i++) {\n\t\t\tranges[i] = rrs.get(i);\n\t\t}\n\t\treturn multiIterator(map, ranges);\n\t}\n\n\tpublic static List<ResidueRange> parseMultiple(List<String> ranges) {\n\t\tList<ResidueRange> rrs = new ArrayList<ResidueRange>(ranges.size());\n\t\tfor (String range : ranges) {\n\t\t\tResidueRange rr = ResidueRange.parse(range);\n\t\t\tif (rr != null) rrs.add(rr);\n\t\t}\n\t\treturn rrs;\n\t}\n\n\tpublic static List<String> toStrings(List<? extends ResidueRange> ranges) {\n\t\tList<String> list = new ArrayList<String>(ranges.size());\n\t\tfor (ResidueRange range : ranges) {\n\t\t\tlist.add(range.toString());\n\t\t}\n\t\treturn list;\n\t}\n\t\n\tpublic static String toString(List<? extends ResidueRange> ranges) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < ranges.size(); i++) {\n\t\t\tsb.append(ranges.get(i));\n\t\t\tif (i < ranges.size() - 1) sb.append(\",\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A chain, a start residue, and an end residue.\n * \n * @author dmyerstu\n * @see ResidueNumber\n * @see org.biojava.bio.structure.ResidueRangeAndLength\n */\npublic class ResidueRange {\n\n\tprivate final String chain;\n\tprivate final ResidueNumber end;\n\tprivate final ResidueNumber start;\n\n\tpublic static final Pattern RANGE_REGEX = Pattern.compile(\n\t\t\t\"^\\\\s*([a-zA-Z0-9]+|_)\" + //chain ID. Be flexible here, rather than restricting to 4-char IDs\n\t\t\t\"(?:\" + //begin range, this is a \"non-capturing group\"\n\t\t\t\t\"(?::|_|:$|_$|$)\" + //colon or underscore, could be at the end of a line, another non-capt. group.\n\t\t\t\t\"(?:\"+ // another non capturing group for the residue range\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // first residue\n\t\t\t\t\t\"\\\\s*-\\\\s*\" + // -\n\t\t\t\t\t\"([-+]?[0-9]+[A-Za-z]?)\" + // second residue\n\t\t\t\t\")?+\"+\n\t\t\t\")?\" + //end range\n\t\t\t\"\\\\s*\");\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end or chain.start-end. For example: <code>A.5-100</code> or <code>A_5-100</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}\n\t */\n\tpublic static ResidueRange parse(String s) {\n\t\tResidueNumber start = null, end = null;\n\t\tString chain = null;\n\t\tMatcher matcher = RANGE_REGEX.matcher(s);\n\t\tif (matcher.matches()) {\n\t\t\ttry {\n\t\t\t\tchain = matcher.group(1);\n\t\t\t\tif (matcher.group(2) != null) {\n\t\t\t\t\tstart = ResidueNumber.fromString(matcher.group(2));\n\t\t\t\t\tend = ResidueNumber.fromString(matcher.group(3));\n\t\t\t\t\tstart.setChainId(chain);\n\t\t\t\t\tend.setChainId(chain);\n\t\t\t\t}\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"Range \" + s + \" was not valid\", e);\n\t\t\t}\n\t\t}\n\t\treturn new ResidueRange(chain, start, end);\n\t}\n\n\t/**\n\t * @param s\n\t *            A string of the form chain_start-end,chain_start-end, ... For example:\n\t *            <code>A.5-100,R_110-190,Z_200-250</code>.\n\t * @return The unique ResidueRange corresponding to {@code s}.\n\t */\n\tpublic static List<ResidueRange> parseMultiple(String s) {\n\t\tString[] parts = s.split(\",\");\n\t\tList<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n\t\tfor (String part : parts) {\n\t\t\tlist.add(parse(part));\n\t\t}\n\t\treturn list;\n\t}\n\n\tpublic ResidueRange(String chain, String start, String end) {\n\t\tthis.chain = chain;\n\t\tthis.start = ResidueNumber.fromString(start);\n\t\tthis.start.setChainId(chain);\n\t\tthis.end = ResidueNumber.fromString(end);\n\t\tthis.end.setChainId(chain);\n\t}\n\n\tpublic ResidueRange(String chain, ResidueNumber start, ResidueNumber end) {\n\t\tthis.chain = chain;\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj) return true;\n\t\tif (obj == null) return false;\n\t\tif (getClass() != obj.getClass()) return false;\n\t\tResidueRange other = (ResidueRange) obj;\n\t\tif (chain == null) {\n\t\t\tif (other.chain != null) return false;\n\t\t} else if (!chain.equals(other.chain)) return false;\n\t\tif (end == null) {\n\t\t\tif (other.end != null) return false;\n\t\t} else if (!end.equals(other.end)) return false;\n\t\tif (start == null) {\n\t\t\tif (other.start != null) return false;\n\t\t} else if (!start.equals(other.start)) return false;\n\t\treturn true;\n\t}\n\n\tpublic String getChainId() {\n\t\treturn chain;\n\t}\n\n\tpublic ResidueNumber getEnd() {\n\t\treturn end;\n\t}\n\n\tpublic ResidueNumber getStart() {\n\t\treturn start;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + (chain == null ? 0 : chain.hashCode());\n\t\tresult = prime * result + (end == null ? 0 : end.hashCode());\n\t\tresult = prime * result + (start == null ? 0 : start.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn chain + \"_\" + start + \"-\" + end;\n\t}\n\n\t/**\n\t * Returns the ResidueNumber that is at position {@code positionInRange} in\n\t * <em>this</em> ResidueRange.\n\t * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n\t */\n\tpublic ResidueNumber getResidue(int positionInRange, AtomPositionMap map) {\n\t\tif (map == null) throw new NullPointerException(\"The AtomPositionMap must be non-null\");\n\t\tint i = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : map.getNavMap().entrySet()) {\n\t\t\tif (i == positionInRange) return entry.getKey();\n\t\t\tif (contains(entry.getKey(), map)) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return True if and only if {@code residueNumber} is within this ResidueRange\n\t */\n\tpublic boolean contains(ResidueNumber residueNumber, AtomPositionMap map) {\n\n\t\tif (residueNumber == null)\n\t\t\tthrow new NullPointerException(\"Can't find the ResidueNumber because it is null\");\n\n\t\tif (map == null)\n\t\t\tthrow new NullPointerException(\"The AtomPositionMap must be non-null\");\n\n\t\tInteger pos = map.getPosition(residueNumber);\n\t\tif (pos == null) throw new IllegalArgumentException(\"Couldn't find residue \" + residueNumber.printFull());\n\n\t\tResidueNumber startResidue = getStart()==null? map.getFirst(getChainId()) : getStart();\n\t\tInteger startPos = map.getPosition(startResidue);\n\t\tif (startPos == null) throw new IllegalArgumentException(\"Couldn't find the start position\");\n\n\t\tResidueNumber endResidue = getEnd()==null? map.getLast(getChainId()) : getEnd();\n\t\tInteger endPos = map.getPosition(endResidue);\n\t\tif (endPos == null) throw new IllegalArgumentException(\"Couldn't find the end position\");\n\t\treturn pos >= startPos && pos <= endPos;\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic Iterator<ResidueNumber> iterator(final AtomPositionMap map) {\n\t\t//Use Entries to guarentee not null\n\t\tfinal Iterator<Entry<ResidueNumber, Integer>> entryIt = map.getNavMap().entrySet().iterator();\n\t\tif(! entryIt.hasNext()) {\n\t\t\t// empty iterator\n\t\t\treturn Arrays.asList(new ResidueNumber[0]).iterator();\n\t\t}\n\t\t// Peek at upcoming entry\n\t\t\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tEntry<ResidueNumber,Integer> next = loadNext();\n\t\t\t\n\t\t\tprivate Entry<ResidueNumber,Integer> loadNext() {\n\n\t\t\t\twhile( entryIt.hasNext() ) {\n\t\t\t\t\tnext = entryIt.next();\n\t\t\t\t\tResidueNumber nextPos = next.getKey();\n\t\t\t\t\tif( contains(nextPos, map)) {\n\t\t\t\t\t\t// loaded a valid next value\n\t\t\t\t\t\treturn next;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext = null;\n\t\t\t\treturn next;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn next != null;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tResidueNumber pos = next.getKey();\n\t\t\t\tloadNext();\n\t\t\t\treturn pos;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Not modifiable\");\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(final AtomPositionMap map, final ResidueRange... rrs) {\n\t\treturn new Iterator<ResidueNumber>() {\n\t\t\tprivate int r = 0;\n\t\t\tprivate Iterator<ResidueNumber> internal;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\tif (r == rrs.length - 1) {\n\t\t\t\t\tinit();\n\t\t\t\t\treturn internal.hasNext();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprivate void init() {\n\t\t\t\tif (internal == null) {\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic ResidueNumber next() {\n\t\t\t\tif (rrs.length == 0) throw new NoSuchElementException();\n\t\t\t\tinit();\n\t\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\t\tif (!internal.hasNext()) {\n\t\t\t\t\tr++;\n\t\t\t\t\tinternal = rrs[r].iterator(map);\n\t\t\t\t}\n\t\t\t\treturn internal.next();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"Not modifiable\");\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n\t * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n\t */\n\tpublic static Iterator<ResidueNumber> multiIterator(AtomPositionMap map, List<? extends ResidueRange> rrs) {\n\t\tResidueRange[] ranges = new ResidueRange[rrs.size()];\n\t\tfor (int i = 0; i < rrs.size(); i++) {\n\t\t\tranges[i] = rrs.get(i);\n\t\t}\n\t\treturn multiIterator(map, ranges);\n\t}\n\n\tpublic static List<ResidueRange> parseMultiple(List<String> ranges) {\n\t\tList<ResidueRange> rrs = new ArrayList<ResidueRange>(ranges.size());\n\t\tfor (String range : ranges) {\n\t\t\tResidueRange rr = ResidueRange.parse(range);\n\t\t\tif (rr != null) rrs.add(rr);\n\t\t}\n\t\treturn rrs;\n\t}\n\n\tpublic static List<String> toStrings(List<? extends ResidueRange> ranges) {\n\t\tList<String> list = new ArrayList<String>(ranges.size());\n\t\tfor (ResidueRange range : ranges) {\n\t\t\tlist.add(range.toString());\n\t\t}\n\t\treturn list;\n\t}\n\t\n\tpublic static String toString(List<? extends ResidueRange> ranges) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < ranges.size(); i++) {\n\t\t\tsb.append(ranges.get(i));\n\t\t\tif (i < ranges.size() - 1) sb.append(\",\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-11-20\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\n/**\n * A unit test for {@link ResidueRange}.\n * \n * @author dmyerstu\n *\n */\npublic class ResidueRangeTest {\n\n\tprivate AtomCache cache;\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache(); // TODO Should mock instead of depending on\n\t\t// real data from AtomCache\n\t\tcache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n\t}\n\n\t@Test\n\tpublic void testWholeChainBasic() {\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRange.parse(range);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertNull(\"Start residue should be null\", rr.getStart());\n\t\tassertNull(\"End residue should be null\", rr.getEnd());\n\t}\n\n\t@Test\n\tpublic void testPartialChainWithMap() throws IOException,\n\tStructureException {\n\t\tString pdbId = \"1cph\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tString range = \"B:1-30\";\n\t\tResidueRange rr = ResidueRangeAndLength.parse(range, map);\n\t\tResidueNumber start = new ResidueNumber(\"B\", 1, null);\n\t\tResidueNumber end = new ResidueNumber(\"B\", 30, null);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertEquals(\"Wrong start\", start, rr.getStart());\n\t\tassertEquals(\"Wrong end\", end, rr.getEnd());\n\t}\n\n\t@Test\n\tpublic void testWholeChainWithMap() throws IOException, StructureException {\n\t\tString pdbId = \"1cph\";\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tString range = \"B:\";\n\t\tResidueRange rr = ResidueRangeAndLength.parse(range, map);\n\t\tassertEquals(\"Wrong chain Id\", \"B\", rr.getChainId());\n\t\tassertEquals(\"Wrong start\", new ResidueNumber(\"B\",1,null),rr.getStart());\n\t\tassertEquals(\"Wrong end\", new ResidueNumber(\"B\",30,null),rr.getEnd());\n\t}\n\n\t/**\n\t * Tests creating ResidueRanges and calculating their lengths.\n\t */\n\t@Test\n\tpublic void testWithLengths() throws IOException, StructureException {\n\t\tString[] ids = new String[] { \"1w0p\", \"3qq3\", \"3chc\", \"2ei7\" }; // more:\n\t\t// ,\n\t\t// \"2qbr\"\n\t\tString[] chains = new String[] { \"A\", \"B\", \"A\", \"L\" };\n\t\tResidueNumber[] starts = new ResidueNumber[] {\n\t\t\t\tnew ResidueNumber(\"A\", 5, ' '),\n\t\t\t\tnew ResidueNumber(\"B\", 10, 's'),\n\t\t\t\tnew ResidueNumber(\"A\", 15, 'm'),\n\t\t\t\tnew ResidueNumber(\"L\", 44, ' ') };\n\t\tResidueNumber[] ends = new ResidueNumber[] {\n\t\t\t\tnew ResidueNumber(\"A\", 117, ' '),\n\t\t\t\tnew ResidueNumber(\"B\", 200, 's'),\n\t\t\t\tnew ResidueNumber(\"A\", 464, 'q'),\n\t\t\t\tnew ResidueNumber(\"L\", 254, 't') };\n\t\tint[] lengths = new int[] { 117 - 5, 200 - 10, 111, 55 };\n\t\tint totalLength = 0;\n\t\tList<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>(\n\t\t\t\tids.length);\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tResidueRangeAndLength rr = new ResidueRangeAndLength(chains[i],\n\t\t\t\t\tstarts[i], ends[i], lengths[i]);\n\t\t\tassertEquals(\"The chain is incorrect\", chains[i], rr.getChainId());\n\t\t\tassertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n\t\t\tassertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n\t\t\tassertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n\t\t\tranges.add(rr);\n\t\t\ttotalLength += lengths[i];\n\t\t\tassertEquals(\"Total length is wrong\", totalLength,\n\t\t\t\t\tResidueRangeAndLength.calcLength(ranges));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testLengths() throws IOException, StructureException {\n\t\tString pdbId = \"1w0p\";\n\t\tString rangeStr = \"A:25-26\";\n\t\tAtom[] atoms = cache.getAtoms(pdbId);\n\t\tAtomPositionMap map = new AtomPositionMap(atoms);\n\t\tResidueRangeAndLength range = ResidueRangeAndLength\n\t\t\t\t.parse(rangeStr, map);\n\t\tassertEquals(2, range.getLength());\n\t}\n\n\t@Test\n\tpublic void testIterator() throws IOException, StructureException {\n\t\tString pdbId = \"2eke\";\n\t\tString[] expected = new String[] { \"C_1023\", \"C_1024\", \"C_1025\",\n\t\t\t\t\"C_1026\", \"C_1027\", \"C_1028\", \"C_1029\", \"C_1030\", \"C_1031\",\n\t\t\t\t\"C_1032\", \"C_1033\", \"C_1034\", \"C_1035\", \"C_1036\", \"C_1037\",\n\t\t\t\t\"C_1038\", \"C_1039\", \"C_1040\", \"C_1041\", \"C_1042\", \"C_1043\",\n\t\t\t\t\"C_1044\", \"C_1045\", \"C_1046\", \"C_1047\", \"C_1048\", \"C_1049\",\n\t\t\t\t\"C_1050\", \"C_1051\", \"C_1052\", \"C_1053\", \"C_1054\", \"C_1055\",\n\t\t\t\t\"C_1056\", \"C_1057\", \"C_1058\", \"C_1059\", \"C_1060\", \"C_1061\",\n\t\t\t\t\"C_1062\", \"C_1063\" };\n\t\tResidueRange rr = ResidueRange.parse(\"C_1023-1063\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = rr.iterator(map);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertTrue(i<expected.length);\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t\tassertEquals(expected.length,i);\n\t}\n\n\t@Test\n\tpublic void testMultiIterator() throws IOException, StructureException {\n\t\tString pdbId = \"1qdm\";\n\t\tString[] expected = new String[] { \"A_3S\", \"A_4S\", \"A_5S\", \"A_6S\",\n\t\t\t\t\"A_7S\", \"A_8S\", \"A_9S\", \"A_10S\", \"A_11S\", \"A_12S\", \"A_13S\",\n\t\t\t\t\"A_14S\", \"A_15S\", \"A_16S\", \"A_17S\", \"A_18S\", \"A_19S\", \"A_20S\",\n\t\t\t\t\"A_21S\", \"A_22S\", \"A_23S\", \"A_24S\", \"A_25S\", \"A_26S\", \"A_27S\",\n\t\t\t\t\"A_28S\", \"A_29S\", \"A_30S\", \"A_31S\", \"A_32S\", \"A_33S\", \"A_34S\",\n\t\t\t\t\"A_35S\", \"A_36S\", \"A_37S\", \"A_65S\", \"A_66S\", \"A_67S\", \"A_68S\",\n\t\t\t\t\"A_69S\", \"A_70S\", \"A_71S\", \"A_72S\", \"A_73S\", \"A_74S\", \"A_75S\",\n\t\t\t\t\"A_76S\", \"A_77S\", \"A_78S\", \"A_79S\", \"A_80S\", \"A_81S\", \"A_82S\",\n\t\t\t\t\"A_83S\", \"A_84S\", \"A_85S\", \"A_86S\", \"A_87S\", \"A_88S\", \"A_89S\",\n\t\t\t\t\"A_90S\", \"A_91S\", \"A_92S\", \"A_93S\", \"A_94S\", \"A_95S\", \"A_96S\",\n\t\t\t\t\"A_97S\", \"A_98S\", \"A_99S\" };\n\t\tList<ResidueRange> rrs = ResidueRange\n\t\t\t\t.parseMultiple(\"A_3S-37S,A_65S-99S\");\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tIterator<ResidueNumber> iter = ResidueRange.multiIterator(map, rrs);\n\t\tint i = 0;\n\t\twhile (iter.hasNext()) {\n\t\t\tResidueNumber rn = iter.next();\n\t\t\tassertEquals(expected[i], rn.printFull());\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n\t * Tests {@link ResidueRange#parseMultiple(String)}.\n\t */\n\t@Test\n\tpublic void testParseAndEqual() {\n\t\tString rangeStr;\n\t\tList<ResidueRange> ranges;\n\t\tResidueRange range;\n\n\t\t// String pdbId1 = \"2eke\";\n\t\trangeStr = \"C_1023-1063,C_1064-1084\";\n\t\tranges = ResidueRange.parseMultiple(rangeStr);\n\t\tassertEquals(new ResidueRange(\"C\", new ResidueNumber(\"C\", 1023, null),\n\t\t\t\tnew ResidueNumber(\"C\", 1063, null)), ranges.get(0));\n\t\tassertEquals(new ResidueRange(\"C\", new ResidueNumber(\"C\", 1064, null),\n\t\t\t\tnew ResidueNumber(\"C\", 1084, null)), ranges.get(1));\n\n\t\t// String pdbId = \"1qdm\";\n\t\trangeStr = \"A_3S-37S,A_65S-99S\";\n\t\tranges = ResidueRange.parseMultiple(rangeStr);\n\t\tassertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 3, 'S'),\n\t\t\t\tnew ResidueNumber(\"A\", 37, 'S')), ranges.get(0));\n\t\tassertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 65, 'S'),\n\t\t\t\tnew ResidueNumber(\"A\", 99, 'S')), ranges.get(1));\n\n\t\t// Multi-character chains\n\t\trangeStr = \"AB,A1,ABCD_1-55,NotAG00dID:-5-1R\";\n\t\tranges = ResidueRange.parseMultiple(rangeStr);\n\t\trange = ranges.get(0);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"AB\", range.getChainId());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getStart());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getEnd());\n\t\trange = ranges.get(1);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"A1\", range.getChainId());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getStart());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getEnd());\n\t\trange = ranges.get(2);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"ABCD\", range.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"ABCD\", 1,\n\t\t\t\tnull), range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"ABCD\", 55,\n\t\t\t\tnull), range.getEnd());\n\t\trange = ranges.get(3);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"NotAG00dID\",\n\t\t\t\trange.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\n\t\t\t\t\"NotAG00dID\", -5, null), range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\n\t\t\t\t\"NotAG00dID\", 1, 'R'), range.getEnd());\n\n\t\t// Wildcard chains\n\t\trangeStr = \"_,__,_:1-5\";\n\t\tranges = ResidueRange.parseMultiple(rangeStr);\n\t\trange = ranges.get(0);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainId());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getStart());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getEnd());\n\t\trange = ranges.get(1);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainId());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getStart());\n\t\tassertNull(\"Error parsing \" + rangeStr, range.getEnd());\n\t\trange = ranges.get(2);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 1,\n\t\t\t\tnull), range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 5,\n\t\t\t\tnull), range.getEnd());\n\n\t}\n\n\t/**\n\t * Tests\n\t * {@link org.biojava.bio.structure.ResidueRangeAndLength#parseMultiple(String, org.biojava.bio.structure.AtomPositionMap)}\n\t * .\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testParseAndEqualWithLengths() throws IOException,\n\tStructureException {\n\t\tString rangeStr;\n\t\tList<ResidueRangeAndLength> ranges;\n\t\tResidueRangeAndLength range;\n\n\t\tAtomPositionMap map;\n\n\t\tString pdbId = \"2eke\";\n\t\tmap = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\trangeStr = \"C_1023-1063,C_1064-1084,C\";//C is 105-112,1013-1095\n\t\tranges = ResidueRangeAndLength.parseMultiple(rangeStr, map);\n\t\tassertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\",\n\t\t\t\t1023, null), new ResidueNumber(\"C\", 1063, null), 1063 - 1023+1),\n\t\t\t\tranges.get(0));\n\t\tassertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\",\n\t\t\t\t1064, null), new ResidueNumber(\"C\", 1084, null), 1084 - 1064+1),\n\t\t\t\tranges.get(1));\n\t\tassertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\", 105,\n\t\t\t\tnull), new ResidueNumber(\"C\", 1095, null), 91), ranges.get(2));\n\n\t\t// Wildcard chains\n\n\t\tpdbId = \"4r61\"; // A:8-52,58-109,119-161\n\t\tmap = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\trangeStr = \"_,__,_:52-58\";\n\t\tranges = ResidueRangeAndLength.parseMultiple(rangeStr, map);\n\t\trange = ranges.get(0);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\",8,null),range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\",161,null),range.getEnd());\n\t\trange = ranges.get(1);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\",8,null),range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\",161,null),range.getEnd());\n\t\trange = ranges.get(2);\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainId());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 52,null), range.getStart());\n\t\tassertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 58,null), range.getEnd());\n\n\t\t// wildcards not converted without the map\n\t\tResidueRange range2 = ResidueRange.parse(\"_\");\n\t\tassertEquals(\"Error parsing \" + rangeStr, \"_\", range2.getChainId());\n\t\tassertNull(\"Error parsing \" + rangeStr,range2.getStart());\n\t\tassertNull(\"Error parsing \" + rangeStr,range2.getEnd());\n\n\t}\n\n\t@Test\n\tpublic void testRangeRegex() {\n\t\t// Valid ranges\n\t\tString[] yes = new String[] { \"A_\", \"A:\", \"ABC:\", \"abc:\", \"A_5-100\",\n\t\t\t\t\"A_5-100S\", \"A_5S-100\", \"A_5S-100S\", \"A_-5-100\", \"A_-5--100\",\n\t\t\t\t\"A_-5S--100S\", \"ABC:-5--200S\", \"A\", \"ABCD\", \"A1\", // valid\n\t\t\t\t// multi-char\n\t\t\t\t// chain\n\t\t\t\t// name\n\t\t\t\t\"3A:1-100\", // Weird chain name\n\t\t\t\t\"_\", \"_:1-10\", \"__-2--1\", \"__\"// catch-all chain\n\t\t};\n\t\tfor (String s : yes) {\n\t\t\tassertTrue(s + \" was not considered a valid range format\",\n\t\t\t\t\tResidueRange.RANGE_REGEX.matcher(s).matches());\n\t\t}\n\t\t// invalid ranges\n\t\tString[] no = new String[] { \"A_1\", \"A_1-\", \"A_1S-\", \"A_1-100-\",\n\t\t\t\t\"A_-10-1000_\", \"\", \"-\", \"___\", \"__:\" };\n\t\tfor (String s : no) {\n\t\t\tassertFalse(s + \" was considered a valid range format\",\n\t\t\t\t\tResidueRange.RANGE_REGEX.matcher(s).matches());\n\t\t}\n\t}\n\n}\n","changedTest":"","commitMessage":"Made ResidueRange.contains() work even when the start or end is missing (related to fixes for issue #247).\n","test_commitMessage":"","allZero":false}