{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/align/util/AlignmentTools.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/align/util/AlignmentToolsTest.java","prod_time":"2011-11-08 06:14:53","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"d8f4969eee0adff12f19535a217b92778320440f","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.bio.structure.align.util;\n\nimport org.biojava.bio.structure.align.model.AFPChain;\n\n/**\n * Some utility methods for analyzing and manipulating AFPChains.\n * \n * @author Spencer Bliven\n *\n */\npublic class AlignmentTools {\n\t/**\n\t * Checks that the alignment given by afpChain is sequential. This means\n\t * that the residue indices of both proteins increase monotonically as\n\t * a function of the alignment position (ie both proteins are sorted).\n\t * \n\t * This will return false for circularly permuted alignments or other\n\t * non-topological alignments. It will also return false for cases where\n\t * the alignment itself is sequential but it is not stored in the afpChain\n\t * in a sorted manner.\n\t * \n\t * Since algorithms which create non-sequential alignments split the\n\t * alignment into multiple blocks, some computational time can be saved\n\t * by only checking block boundaries for sequentiality. Setting\n\t * <tt>checkWithinBlocks</tt> to <tt>true</tt> makes this function slower,\n\t * but detects AFPChains with non-sequential blocks.\n\t * \n\t * Note that this method should give the same results as\n\t * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n\t * relies on the StructureAlignment algorithm correctly setting this\n\t * parameter, which is sadly not always the case.\n\t * \n\t * @param afpChain An alignment\n\t * @param checkWithinBlocks Indicates whether individual blocks should be\n\t * \tchecked for sequentiality\n\t * @return True if the alignment is sequential.\n\t */\n\tpublic static boolean isSequentialAlignment(AFPChain afpChain, boolean checkWithinBlocks) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] alnLen = afpChain.getOptLen();\n\t\tint blocks = afpChain.getBlockNum();\n\t\t\n\t\tif(blocks < 1) return true; //trivial case\n\t\t\n\t\t// Check that blocks are sequential\n\t\tif(checkWithinBlocks) {\n\t\t\tfor(int block = 0; block<blocks; block++) {\n\t\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\t\t\t\t\n\t\t\t\tint prevRes1 = optAln[block][0][0];\n\t\t\t\tint prevRes2 = optAln[block][1][0];\n\t\t\t\t\n\t\t\t\tfor(int pos = 1; pos<alnLen[block]; pos++) {\n\t\t\t\t\tint currRes1 = optAln[block][0][pos];\n\t\t\t\t\tint currRes2 = optAln[block][1][pos];\n\t\t\t\t\t\n\t\t\t\t\tif(currRes1 < prevRes1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(currRes2 < prevRes2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprevRes1 = currRes1;\n\t\t\t\t\tprevRes2 = currRes2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that blocks are sequential\n\t\tint prevRes1 = optAln[0][0][alnLen[0]-1];\n\t\tint prevRes2 = optAln[0][1][alnLen[0]-1];\n\t\t\n\t\tfor(int block = 1; block<blocks;block++) {\n\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\n\t\t\tif(optAln[block][0][0]<prevRes1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(optAln[block][1][0]<prevRes2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprevRes1 = optAln[block][0][alnLen[block]-1];\n\t\t\tprevRes2 = optAln[block][1][alnLen[block]-1];\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n}\n","changedPro":"package org.biojava.bio.structure.align.util;\n\nimport org.biojava.bio.structure.align.model.AFPChain;\n\n/**\n * Some utility methods for analyzing and manipulating AFPChains.\n * \n * @author Spencer Bliven\n *\n */\npublic class AlignmentTools {\n\t/**\n\t * Checks that the alignment given by afpChain is sequential. This means\n\t * that the residue indices of both proteins increase monotonically as\n\t * a function of the alignment position (ie both proteins are sorted).\n\t * \n\t * This will return false for circularly permuted alignments or other\n\t * non-topological alignments. It will also return false for cases where\n\t * the alignment itself is sequential but it is not stored in the afpChain\n\t * in a sorted manner.\n\t * \n\t * Since algorithms which create non-sequential alignments split the\n\t * alignment into multiple blocks, some computational time can be saved\n\t * by only checking block boundaries for sequentiality. Setting\n\t * <tt>checkWithinBlocks</tt> to <tt>true</tt> makes this function slower,\n\t * but detects AFPChains with non-sequential blocks.\n\t * \n\t * Note that this method should give the same results as\n\t * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n\t * relies on the StructureAlignment algorithm correctly setting this\n\t * parameter, which is sadly not always the case.\n\t * \n\t * @param afpChain An alignment\n\t * @param checkWithinBlocks Indicates whether individual blocks should be\n\t * \tchecked for sequentiality\n\t * @return True if the alignment is sequential.\n\t */\n\tpublic static boolean isSequentialAlignment(AFPChain afpChain, boolean checkWithinBlocks) {\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint[] alnLen = afpChain.getOptLen();\n\t\tint blocks = afpChain.getBlockNum();\n\t\t\n\t\tif(blocks < 1) return true; //trivial case\n\t\tif ( alnLen[0] < 1) return true;\n\t\t\n\t\t// Check that blocks are sequential\n\t\tif(checkWithinBlocks) {\n\t\t\tfor(int block = 0; block<blocks; block++) {\n\t\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\t\t\t\t\n\t\t\t\tint prevRes1 = optAln[block][0][0];\n\t\t\t\tint prevRes2 = optAln[block][1][0];\n\t\t\t\t\n\t\t\t\tfor(int pos = 1; pos<alnLen[block]; pos++) {\n\t\t\t\t\tint currRes1 = optAln[block][0][pos];\n\t\t\t\t\tint currRes2 = optAln[block][1][pos];\n\t\t\t\t\t\n\t\t\t\t\tif(currRes1 < prevRes1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif(currRes2 < prevRes2) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tprevRes1 = currRes1;\n\t\t\t\t\tprevRes2 = currRes2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check that blocks are sequential\n\t\tint prevRes1 = optAln[0][0][alnLen[0]-1];\n\t\tint prevRes2 = optAln[0][1][alnLen[0]-1];\n\t\t\n\t\tfor(int block = 1; block<blocks;block++) {\n\t\t\tif(alnLen[block] < 1 ) continue; //skip empty blocks\n\n\t\t\tif(optAln[block][0][0]<prevRes1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(optAln[block][1][0]<prevRes2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tprevRes1 = optAln[block][0][alnLen[block]-1];\n\t\t\tprevRes2 = optAln[block][1][alnLen[block]-1];\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure.align.util;\n\nimport java.io.IOException;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.StructureAlignment;\nimport org.biojava.bio.structure.align.StructureAlignmentFactory;\nimport org.biojava.bio.structure.align.ce.CeCPMain;\nimport org.biojava.bio.structure.align.ce.CeMain;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\n\nimport junit.framework.TestCase;\n\npublic class AlignmentToolsTest extends TestCase {\n\t\n\tpublic void testIsSequential() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tString name1, name2;\n\t\tAtom[] ca1, ca2;\n\t\tAFPChain afpChain;\n\t\tStructureAlignment ce;\n\t\t\n\t\t\n\t\t// CP case\n\t\tname1=\"1QDM.A\"; // swaposin\n\t\tname2=\"1NKL\"; // saposin\n\t\t\n\t\tca1=cache.getAtoms(name1);\n\t\tca2=cache.getAtoms(name2);\n\t\t\n\t\tce = StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n\t\tafpChain = ce.align(ca1,ca2);\n\t\t\n\t\tassertFalse(\"CeCPMain should give non-sequential alignments (between blocks).\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\t\tassertFalse(\"CeCPMain should give non-sequential alignments (within blocks).\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\n\t\t// linear case\t\t\n\t\tce = StructureAlignmentFactory.getAlgorithm(CeMain.algorithmName);\n\t\tafpChain = ce.align(ca1,ca2);\n\t\t\n\t\tassertTrue(\"CeMain should give sequential alignments (within blocks).\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\t\tassertTrue(\"CeMain should give sequential alignments (between blocks).\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\n\t\t// now change the block interior a bit\n\t\t\n\t\tint[][][] optAln = afpChain.getOptAln();\n\t\tint tmp;\n\t\ttmp = optAln[0][0][2];\n\t\toptAln[0][0][2] = optAln[0][0][1];\n\t\toptAln[0][0][1] = tmp;\n\t\ttmp = optAln[0][1][2];\n\t\toptAln[0][1][2] = optAln[0][1][1];\n\t\toptAln[0][1][1] = tmp;\n\t\t\n\t\tassertTrue(\"Modifying block interior shouldn't effect block sequence.\",AlignmentTools.isSequentialAlignment(afpChain,false));\n\t\tassertFalse(\"Modifying block interior should be not sequential.\",AlignmentTools.isSequentialAlignment(afpChain,true));\n\n\t}\n}\n","changedTest":"","commitMessage":"prevent an out of index error\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9389 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}