{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/GeneSequence.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/GeneSequenceTest.java","prod_time":"2021-11-27 01:43:05","test_time":"2021-11-27 01:43:05","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":2,"label":"POSITIVE","prod_commitID":"508845609636a5716f2bf676b792888b03a90c0f","test_commitID":"508845609636a5716f2bf676b792888b03a90c0f","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\n\n/**\n *\n * @author Scooter Willis\n */\npublic class GeneSequence extends DNASequence {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GeneSequence.class);\n\n\tprivate final LinkedHashMap<String, TranscriptSequence> transcriptSequenceHashMap = new LinkedHashMap<String, TranscriptSequence>();\n\tprivate final LinkedHashMap<String, IntronSequence> intronSequenceHashMap = new LinkedHashMap<String, IntronSequence>();\n\tprivate final LinkedHashMap<String, ExonSequence> exonSequenceHashMap = new LinkedHashMap<String, ExonSequence>();\n\tprivate final ArrayList<IntronSequence> intronSequenceList = new ArrayList<IntronSequence>();\n\tprivate final ArrayList<ExonSequence> exonSequenceList = new ArrayList<ExonSequence>();\n\tboolean intronAdded = false; // need to deal with the problem that typically introns are not added when validating the list and adding in introns as the regions not included in exons\n\tprivate Strand strand = Strand.UNDEFINED;\n\tprivate ChromosomeSequence chromosomeSequence;\n\n\t/**\n\t * Use GeneSequence(ChromosomeSequence parentSequence, AccessionID accessionId,  int begin, int end, Strand strand)\n\t * which mandates an accessionID.\n\t * @param parentSequence\n\t * @param begin\n\t * @param end inclusive of end\n\t * @param strand force a gene to have strand and transcription sequence will inherit\n\t * @deprecated\n\t */\n\tpublic GeneSequence(ChromosomeSequence parentSequence,  int begin, int end, Strand strand) {\n\t\tsetCompoundSet(DNACompoundSet.getDNACompoundSet());\n\t\ttry {\n\t\t\tinitSequenceStorage(parentSequence.getSequenceAsString());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\tchromosomeSequence = parentSequence;\n\t\tsetParentSequence(parentSequence);\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t\tsetStrand(strand);\n\t}\n\n\t/**\n\t * A class that keeps track of the details of a GeneSequence which is difficult to properly model. Two important concepts that is difficult\n\t * to make everything flexible but still work. You can have GFF features that only describe Exons or Exons/Introns or CDS regions and one\n\t * or more Transcriptions. You can have exon sequences but that does not imply transcription to the actual protein.\n\t *\n\t * The GeneSequence will keep track of Exons and Introns but to get a Protein sequence you need to start with a\n\t * TranscriptSequence and then add CDS sequences.\n\t *\n\t * This is also a key class in the biojava-3-genome module for reading and writing GFF3 files\n\t *\n\t * @param parentSequence\n\t * @param accessionId An identifier for the gene.\n\t * @param begin\n\t * @param end\n\t * @param strand force a gene to have strand and transcription sequence will inherit\n\t */\n\tpublic GeneSequence(ChromosomeSequence parentSequence, AccessionID accessionId,  int begin, int end, Strand strand) {\n\t\tthis(parentSequence,begin,end,strand);\n\t\tsetAccession(accessionId);\n\t}\n\n\t/**\n\t * The parent ChromosomeSequence which contains the actual DNA sequence data\n\t * @return Chromosome sequence\n\t */\n\tpublic ChromosomeSequence getParentChromosomeSequence() {\n\t\treturn chromosomeSequence;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn Math.abs(this.getBioEnd() - this.getBioBegin()) + 1;\n\t}\n\n\t/**\n\t * Once everything has been added to the gene sequence where you might have added exon sequences only then you\n\t * can infer the intron sequences and add them. You may also have the case where you only added one or more\n\t * TranscriptSequences and from that you can infer the exon sequences and intron sequences.\n\t * Currently not implement\n\t */\n\tpublic void addIntronsUsingExons() throws Exception {\n\t\tif (intronAdded) { //going to assume introns are correct\n\t\t\treturn;\n\t\t}\n\t\tif (exonSequenceList.size() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tExonComparator exonComparator = new ExonComparator();\n\t\t//sort based on start position and sense;\n\t\tCollections.sort(exonSequenceList, exonComparator);\n\t\tint shift = -1;\n\t\tif (getStrand() == Strand.NEGATIVE) {\n\t\t\tshift = 1;\n\t\t}\n\t\t//ExonSequence firstExonSequence = exonSequenceList.get(0);\n\t\tint intronIndex = 1;\n//       if (firstExonSequence.getBioBegin().intValue() != getBioBegin().intValue()) {\n//           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), getBioBegin(), firstExonSequence.getBioBegin() + shift);\n//           intronIndex++;\n//       }\n\t\tfor (int i = 0; i < exonSequenceList.size() - 1; i++) {\n\t\t\tExonSequence exon1 = exonSequenceList.get(i);\n\t\t\tExonSequence exon2 = exonSequenceList.get(i + 1);\n\t\t\tAccessionID intronId= new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex);\n\t\t\tthis.addIntron(intronId, exon1.getBioEnd() - shift, exon2.getBioBegin() + shift);\n\t\t\tintronIndex++;\n\t\t}\n\n//       ExonSequence lastExonSequence = exonSequenceList.get(exonSequenceList.size() - 1);\n//       if (lastExonSequence.getBioEnd().intValue() != getBioEnd().intValue()) {\n//           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), lastExonSequence.getBioEnd() - shift, getBioEnd());\n//           intronIndex++;\n//       }\n\n\t\t//    log.severe(\"Add in support for building introns based on added exons\");\n\n\t}\n\n\t/**\n\t * A gene should have Strand\n\t * @return the strand\n\t */\n\tpublic Strand getStrand() {\n\t\treturn strand;\n\t}\n\n\t/**\n\t * @param strand the strand to set\n\t */\n\tpublic void setStrand(Strand strand) {\n\t\tthis.strand = strand;\n\t}\n\n\t/**\n\t * Get the transcript sequence by accession\n\t * @param accession\n\t * @return the transcript\n\t */\n\tpublic TranscriptSequence getTranscript(String accession) {\n\t\treturn transcriptSequenceHashMap.get(accession);\n\t}\n\n\t/**\n\t * Get the collection of transcription sequences assigned to this gene\n\t * @return transcripts\n\t */\n\tpublic LinkedHashMap<String, TranscriptSequence> getTranscripts() {\n\t\treturn transcriptSequenceHashMap;\n\t}\n\n\t/**\n\t * Remove the transcript sequence from the gene\n\t * @param accession\n\t * @return transcriptsequence\n\t */\n\tpublic TranscriptSequence removeTranscript(String accession) {\n\t\treturn transcriptSequenceHashMap.remove(accession);\n\t}\n\n\t/**\n\t * Add a transcription sequence to a gene which describes a ProteinSequence\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return transcript sequence\n\t * @throws Exception If the accession id is already used\n\t */\n\tpublic TranscriptSequence addTranscript(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (transcriptSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\t\tTranscriptSequence transcriptSequence = new TranscriptSequence(this, begin, end);\n\t\ttranscriptSequence.setAccession(accession);\n\t\ttranscriptSequenceHashMap.put(accession.getID(), transcriptSequence);\n\t\treturn transcriptSequence;\n\t}\n\n\t/**\n\t * Remove the intron by accession\n\t * @param accession\n\t * @return the removed intron sequence, or null if no intron with that accession exists.\n\t */\n\tpublic IntronSequence removeIntron(String accession) {\n\t\tfor (IntronSequence intronSequence : intronSequenceList) {\n\t\t\tif (intronSequence.getAccession().getID().equals(accession)) {\n\t\t\t\tintronSequenceList.remove(intronSequence);\n\t\t\t\tintronSequenceHashMap.remove(accession);\n\t\t\t\treturn intronSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add an Intron Currently used to mark an IntronSequence as a feature\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return intron sequence\n\t */\n\tpublic IntronSequence addIntron(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (intronSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\t\tintronAdded = true;\n\t\tIntronSequence intronSequence = new IntronSequence(this, begin, end); // working off the assumption that intron frame is always 0 or doesn't matter and same sense as parent\n\t\tintronSequence.setAccession(accession);\n\t\tintronSequenceList.add(intronSequence);\n\t\tintronSequenceHashMap.put(accession.getID(), intronSequence);\n\t\treturn intronSequence;\n\t}\n\n\t/**\n\t * Remove the exon sequence\n\t * @param accession\n\t * @return exon sequence\n\t */\n\tpublic ExonSequence removeExon(String accession) {\n\t\tfor (ExonSequence exonSequence : exonSequenceList) {\n\t\t\tif (exonSequence.getAccession().getID().equals(accession)) {\n\t\t\t\texonSequenceList.remove(exonSequence);\n\t\t\t\texonSequenceHashMap.remove(accession);\n\t\t\t\t// we now have a new gap which creates an intron\n\t\t\t\tintronSequenceList.clear();\n\t\t\t\tintronSequenceHashMap.clear();\n\t\t\t\tintronAdded = false;\n\t\t\t\ttry{\n\t\t\t\t\taddIntronsUsingExons();\n\t\t\t\t} catch(Exception e){\n\t\t\t\t\tlogger.error(\"Remove Exon validate() error \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\treturn exonSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add an ExonSequence mainly used to mark as a feature\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return exon sequence\n\t */\n\tpublic ExonSequence addExon(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (exonSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\n\t\tExonSequence exonSequence = new ExonSequence(this, begin, end); //sense should be the same as parent\n\t\texonSequence.setAccession(accession);\n\t\texonSequenceList.add(exonSequence);\n\t\texonSequenceHashMap.put(accession.getID(), exonSequence);\n\t\treturn exonSequence;\n\t}\n\n\t/**\n\t * Get the exons as an ArrayList\n\t * @return exons\n\t */\n\tpublic ArrayList<ExonSequence> getExonSequences() {\n\t\treturn exonSequenceList;\n\t}\n\n\t/**\n\t * Get the introns as an ArrayList\n\t * @return introns\n\t */\n\tpublic ArrayList<IntronSequence> getIntronSequences() {\n\t\treturn intronSequenceList;\n\t}\n\n\t/**\n\t * Try to give method clarity where you want a DNASequence coding in the 5' to 3' direction\n\t * Returns the DNASequence representative of the 5' and 3' reading based on strand\n\t * @return dna sequence or null if sequence could not be generated.\n\t */\n\tpublic DNASequence getSequence5PrimeTo3Prime() {\n\t\tString sequence = getSequenceAsString(this.getBioBegin(), this.getBioEnd(), this.getStrand());\n\t\tif (getStrand() == Strand.NEGATIVE) {\n\t\t\t//need to take complement of sequence because it is negative and we are returning the gene sequence from the opposite strand\n\t\t\tStringBuilder b = new StringBuilder(getLength());\n\t\t\tCompoundSet<NucleotideCompound> compoundSet = this.getCompoundSet();\n\t\t\tfor (int i = 0; i < sequence.length(); i++) {\n\t\t\t\tString nucleotide = String.valueOf(sequence.charAt(i));\n\t\t\t\tNucleotideCompound nucleotideCompound = compoundSet.getCompoundForString(nucleotide);\n\t\t\t\tb.append(nucleotideCompound.getComplement().getShortName());\n\t\t\t}\n\t\t\tsequence = b.toString();\n\t\t}\n\t\tDNASequence dnaSequence = null;\n\t\ttry {\n\t\t\tdnaSequence = new DNASequence(sequence.toUpperCase());\n\t\t    dnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// this should not happen, the sequence is DNA originally, if it does, there's a bug somewhere\n\t\t\tlogger.error(\"Could not create new DNA sequence in getSequence5PrimeTo3Prime(). Error: {}\",e.getMessage());\n\t\t}\n\t\treturn dnaSequence;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\n\n/**\n *\n * @author Scooter Willis\n */\npublic class GeneSequence extends DNASequence {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GeneSequence.class);\n\n\tprivate final LinkedHashMap<String, TranscriptSequence> transcriptSequenceHashMap = new LinkedHashMap<String, TranscriptSequence>();\n\tprivate final LinkedHashMap<String, IntronSequence> intronSequenceHashMap = new LinkedHashMap<String, IntronSequence>();\n\tprivate final LinkedHashMap<String, ExonSequence> exonSequenceHashMap = new LinkedHashMap<String, ExonSequence>();\n\tprivate final ArrayList<IntronSequence> intronSequenceList = new ArrayList<IntronSequence>();\n\tprivate final ArrayList<ExonSequence> exonSequenceList = new ArrayList<ExonSequence>();\n\tboolean intronAdded = false; // need to deal with the problem that typically introns are not added when validating the list and adding in introns as the regions not included in exons\n\tprivate Strand strand = Strand.UNDEFINED;\n\tprivate ChromosomeSequence chromosomeSequence;\n\n\t/**\n\t * Use GeneSequence(ChromosomeSequence parentSequence, AccessionID accessionId,  int begin, int end, Strand strand)\n\t * which mandates an accessionID.\n\t * @param parentSequence\n\t * @param begin\n\t * @param end inclusive of end\n\t * @param strand force a gene to have strand and transcription sequence will inherit\n\t * @deprecated\n\t */\n\tpublic GeneSequence(ChromosomeSequence parentSequence,  int begin, int end, Strand strand) {\n\t\tsetCompoundSet(DNACompoundSet.getDNACompoundSet());\n\t\ttry {\n\t\t\tinitSequenceStorage(parentSequence.getSequenceAsString());\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\tchromosomeSequence = parentSequence;\n\t\tsetParentSequence(parentSequence);\n\t\tsetBioBegin(begin);\n\t\tsetBioEnd(end);\n\t\tsetStrand(strand);\n\t}\n\n\t/**\n\t * A class that keeps track of the details of a GeneSequence which is difficult to properly model. Two important concepts that is difficult\n\t * to make everything flexible but still work. You can have GFF features that only describe Exons or Exons/Introns or CDS regions and one\n\t * or more Transcriptions. You can have exon sequences but that does not imply transcription to the actual protein.\n\t *\n\t * The GeneSequence will keep track of Exons and Introns but to get a Protein sequence you need to start with a\n\t * TranscriptSequence and then add CDS sequences.\n\t *\n\t * This is also a key class in the biojava-3-genome module for reading and writing GFF3 files\n\t *\n\t * @param parentSequence\n\t * @param accessionId An identifier for the gene.\n\t * @param begin\n\t * @param end\n\t * @param strand force a gene to have strand and transcription sequence will inherit\n\t */\n\tpublic GeneSequence(ChromosomeSequence parentSequence, AccessionID accessionId,  int begin, int end, Strand strand) {\n\t\tthis(parentSequence,begin,end,strand);\n\t\tsetAccession(accessionId);\n\t}\n\n\t/**\n\t * The parent ChromosomeSequence which contains the actual DNA sequence data\n\t * @return Chromosome sequence\n\t */\n\tpublic ChromosomeSequence getParentChromosomeSequence() {\n\t\treturn chromosomeSequence;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn Math.abs(this.getBioEnd() - this.getBioBegin()) + 1;\n\t}\n\n\t/**\n\t * Once everything has been added to the gene sequence where you might have added exon sequences only then you\n\t * can infer the intron sequences and add them. You may also have the case where you only added one or more\n\t * TranscriptSequences and from that you can infer the exon sequences and intron sequences.\n\t * Currently not implement\n\t */\n\tpublic void addIntronsUsingExons() throws Exception {\n\t\tif (intronAdded) { //going to assume introns are correct\n\t\t\treturn;\n\t\t}\n\t\tif (exonSequenceList.size() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tExonComparator exonComparator = new ExonComparator();\n\t\t//sort based on start position and sense;\n\t\tCollections.sort(exonSequenceList, exonComparator);\n\t\tint shift = -1;\n\t\tif (getStrand() == Strand.NEGATIVE) {\n\t\t\tshift = 1;\n\t\t}\n\t\t//ExonSequence firstExonSequence = exonSequenceList.get(0);\n\t\tint intronIndex = 1;\n//       if (firstExonSequence.getBioBegin().intValue() != getBioBegin().intValue()) {\n//           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), getBioBegin(), firstExonSequence.getBioBegin() + shift);\n//           intronIndex++;\n//       }\n\t\tfor (int i = 0; i < exonSequenceList.size() - 1; i++) {\n\t\t\tExonSequence exon1 = exonSequenceList.get(i);\n\t\t\tExonSequence exon2 = exonSequenceList.get(i + 1);\n\t\t\tAccessionID intronId= new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex);\n\t\t\tthis.addIntron(intronId, exon1.getBioEnd() - shift, exon2.getBioBegin() + shift);\n\t\t\tintronIndex++;\n\t\t}\n\n//       ExonSequence lastExonSequence = exonSequenceList.get(exonSequenceList.size() - 1);\n//       if (lastExonSequence.getBioEnd().intValue() != getBioEnd().intValue()) {\n//           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), lastExonSequence.getBioEnd() - shift, getBioEnd());\n//           intronIndex++;\n//       }\n\n\t\t//    log.severe(\"Add in support for building introns based on added exons\");\n\n\t}\n\n\t/**\n\t * A gene should have Strand\n\t * @return the strand\n\t */\n\tpublic Strand getStrand() {\n\t\treturn strand;\n\t}\n\n\t/**\n\t * @param strand the strand to set\n\t */\n\tpublic void setStrand(Strand strand) {\n\t\tthis.strand = strand;\n\t}\n\n\t/**\n\t * Get the transcript sequence by accession\n\t * @param accession\n\t * @return the transcript\n\t */\n\tpublic TranscriptSequence getTranscript(String accession) {\n\t\treturn transcriptSequenceHashMap.get(accession);\n\t}\n\n\t/**\n\t * Get the collection of transcription sequences assigned to this gene\n\t * @return transcripts\n\t */\n\tpublic LinkedHashMap<String, TranscriptSequence> getTranscripts() {\n\t\treturn transcriptSequenceHashMap;\n\t}\n\n\t/**\n\t * Remove the transcript sequence from the gene\n\t * @param accession\n\t * @return transcriptsequence\n\t */\n\tpublic TranscriptSequence removeTranscript(String accession) {\n\t\treturn transcriptSequenceHashMap.remove(accession);\n\t}\n\n\t/**\n\t * Add a transcription sequence to a gene which describes a ProteinSequence\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return transcript sequence\n\t * @throws Exception If the accession id is already used\n\t */\n\tpublic TranscriptSequence addTranscript(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (transcriptSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\t\tTranscriptSequence transcriptSequence = new TranscriptSequence(this, begin, end);\n\t\ttranscriptSequence.setAccession(accession);\n\t\ttranscriptSequenceHashMap.put(accession.getID(), transcriptSequence);\n\t\treturn transcriptSequence;\n\t}\n\n\t/**\n\t * Remove the intron by accession\n\t * @param accession\n\t * @return the removed intron sequence, or null if no intron with that accession exists.\n\t */\n\tpublic IntronSequence removeIntron(String accession) {\n\t\tfor (IntronSequence intronSequence : intronSequenceList) {\n\t\t\tif (intronSequence.getAccession().getID().equals(accession)) {\n\t\t\t\tintronSequenceList.remove(intronSequence);\n\t\t\t\tintronSequenceHashMap.remove(accession);\n\t\t\t\treturn intronSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add an Intron Currently used to mark an IntronSequence as a feature\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return intron sequence\n\t */\n\tpublic IntronSequence addIntron(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (intronSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\t\tintronAdded = true;\n\t\tIntronSequence intronSequence = new IntronSequence(this, begin, end); // working off the assumption that intron frame is always 0 or doesn't matter and same sense as parent\n\t\tintronSequence.setAccession(accession);\n\t\tintronSequenceList.add(intronSequence);\n\t\tintronSequenceHashMap.put(accession.getID(), intronSequence);\n\t\treturn intronSequence;\n\t}\n\n\t/**\n\t * Remove the exon sequence\n\t * @param accession\n\t * @return exon sequence\n\t */\n\tpublic ExonSequence removeExon(String accession) {\n\t\tfor (ExonSequence exonSequence : exonSequenceList) {\n\t\t\tif (exonSequence.getAccession().getID().equals(accession)) {\n\t\t\t\texonSequenceList.remove(exonSequence);\n\t\t\t\texonSequenceHashMap.remove(accession);\n\t\t\t\t// we now have a new gap which creates an intron\n\t\t\t\tintronSequenceList.clear();\n\t\t\t\tintronSequenceHashMap.clear();\n\t\t\t\tintronAdded = false;\n\t\t\t\ttry{\n\t\t\t\t\taddIntronsUsingExons();\n\t\t\t\t} catch(Exception e){\n\t\t\t\t\tlogger.error(\"Remove Exon validate() error \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\treturn exonSequence;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Add an ExonSequence mainly used to mark as a feature\n\t * @param accession\n\t * @param begin\n\t * @param end\n\t * @return exon sequence\n\t */\n\tpublic ExonSequence addExon(AccessionID accession, int begin, int end) throws Exception {\n\t\tif (exonSequenceHashMap.containsKey(accession.getID())) {\n\t\t\tthrow new Exception(\"Duplicate accesion id \" + accession.getID());\n\t\t}\n\n\t\tExonSequence exonSequence = new ExonSequence(this, begin, end); //sense should be the same as parent\n\t\texonSequence.setAccession(accession);\n\t\texonSequenceList.add(exonSequence);\n\t\texonSequenceHashMap.put(accession.getID(), exonSequence);\n\t\treturn exonSequence;\n\t}\n\n\t/**\n\t * Get the exons as an ArrayList. Modifying this list will not modify the underlying collection\n\t * @return exons\n\t */\n\tpublic ArrayList<ExonSequence> getExonSequences() {\n\t\treturn new ArrayList<>(exonSequenceList);\n\t}\n\n\t/**\n\t * Get the introns as an ArrayList. Modifying this list will not modify the underlying collection\n\t * @return introns\n\t */\n\tpublic ArrayList<IntronSequence> getIntronSequences() {\n\t\treturn  new ArrayList<>(intronSequenceList);\n\t}\n\n\t/**\n\t * Try to give method clarity where you want a DNASequence coding in the 5' to 3' direction\n\t * Returns the DNASequence representative of the 5' and 3' reading based on strand\n\t * @return dna sequence or null if sequence could not be generated.\n\t */\n\tpublic DNASequence getSequence5PrimeTo3Prime() {\n\t\tString sequence = getSequenceAsString(this.getBioBegin(), this.getBioEnd(), this.getStrand());\n\t\tif (getStrand() == Strand.NEGATIVE) {\n\t\t\t//need to take complement of sequence because it is negative and we are returning the gene sequence from the opposite strand\n\t\t\tStringBuilder b = new StringBuilder(getLength());\n\t\t\tCompoundSet<NucleotideCompound> compoundSet = this.getCompoundSet();\n\t\t\tfor (int i = 0; i < sequence.length(); i++) {\n\t\t\t\tString nucleotide = String.valueOf(sequence.charAt(i));\n\t\t\t\tNucleotideCompound nucleotideCompound = compoundSet.getCompoundForString(nucleotide);\n\t\t\t\tb.append(nucleotideCompound.getComplement().getShortName());\n\t\t\t}\n\t\t\tsequence = b.toString();\n\t\t}\n\t\tDNASequence dnaSequence = null;\n\t\ttry {\n\t\t\tdnaSequence = new DNASequence(sequence.toUpperCase());\n\t\t    dnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// this should not happen, the sequence is DNA originally, if it does, there's a bug somewhere\n\t\t\tlogger.error(\"Could not create new DNA sequence in getSequence5PrimeTo3Prime(). Error: {}\",e.getMessage());\n\t\t}\n\t\treturn dnaSequence;\n\t}\n}\n","originTest":"package org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass GeneSequenceTest {\n    GeneSequence geneSequence;\n    ChromosomeSequence chromosomeSequence;\n    @BeforeEach\n    void before() throws CompoundNotFoundException {\n        chromosomeSequence = new ChromosomeSequence(ChromosomeSequenceTest.CHROMOSOME_SEQ);\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"mygene\"), 10,19, Strand.POSITIVE);\n    }\n\n    @Nested\n    class AfterValidConstruction {\n\n\n        @Test\n        void lengthIsSetByBeginAndEnd() {\n            assertEquals(10, geneSequence.getLength());\n        }\n\n        @Test\n        void noExonsIntronsOrTranscripts() {\n            assertEquals(0, geneSequence.getExonSequences().size());\n            assertEquals(0, geneSequence.getIntronSequences().size());\n            assertEquals(0, geneSequence.getTranscripts().size());\n        }\n        @Test\n        void geneSequenceIsChromosomeSequence() {\n            assertEquals(chromosomeSequence.getSequenceAsString(), geneSequence.getSequenceAsString());\n        }\n\n        @Test\n        void geneSequenceIsChromos2omeSequence() {\n            geneSequence.setStrand(Strand.NEGATIVE);\n            geneSequence.getSequenceAsString();\n            geneSequence.getBioBegin();\n        }\n    }\n\n\n    @Test\n    void addIntronsUsingExonsPositiveStrand() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence,new AccessionID(\"geneId\"), 10,150, Strand.POSITIVE);\n        geneSequence.addExon( new AccessionID(\"a\"), 10,29);\n        geneSequence.addExon( new AccessionID(\"b\"), 33,80);\n        geneSequence.addExon( new AccessionID(\"c\"), 100,120);\n        geneSequence.addIntronsUsingExons();\n        assertEquals(2, geneSequence.getIntronSequences().size());\n        assertEquals(30, geneSequence.getIntronSequences().get(0).getBioBegin());\n        assertEquals(32, geneSequence.getIntronSequences().get(0).getBioEnd());\n        assertEquals(81, geneSequence.getIntronSequences().get(1).getBioBegin());\n        assertEquals(99, geneSequence.getIntronSequences().get(1).getBioEnd());\n    }\n\n    @Test\n    @Disabled(\"gives odd results for intron coords\")\n    void addIntronsUsingExonsNegativeStrand() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence,new AccessionID(\"geneId\"), 150,10, Strand.NEGATIVE);\n        ExonSequence e1 = geneSequence.addExon( new AccessionID(\"c\"), 120,100);\n\n        geneSequence.addExon( new AccessionID(\"b\"), 80,33);\n        geneSequence.addExon( new AccessionID(\"a\"), 29,10);\n\n        // this MUST be set in order to avoid NPE when adding introns\n        geneSequence.addIntronsUsingExons();\n        // actual values generated are (9,81) for I1 and (32,121) for I2\n        assertEquals(2, geneSequence.getIntronSequences().size());\n        assertEquals(99, geneSequence.getIntronSequences().get(0).getBioBegin());\n        assertEquals(81, geneSequence.getIntronSequences().get(0).getBioEnd());\n        assertEquals(32, geneSequence.getIntronSequences().get(1).getBioBegin());\n        assertEquals(30, geneSequence.getIntronSequences().get(1).getBioEnd());\n    }\n\n    @Test\n    void getPositiveStrandSequence5To3Prime() {\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"geneId\"), 10,150, Strand.POSITIVE);\n        // this must be set to avoid NPE\n        assertEquals(chromosomeSequence.getSequenceAsString().substring(9,150),\n                geneSequence.getSequence5PrimeTo3Prime().getSequenceAsString());\n    }\n\n    @Test\n   @Disabled(\"not complementing - seems to complement twice???\")\n    void getNegativeStrandSequence5To3Prime() throws CompoundNotFoundException {\n        ChromosomeSequence shortChrSeq= new ChromosomeSequence(\"TTTTTTTTTTTTTTT\");\n        geneSequence = new GeneSequence(shortChrSeq, new AccessionID(\"geneId\"),5,10, Strand.NEGATIVE);\n        // this must be set to avoid NPE\n        DNASequence seq = geneSequence.getSequence5PrimeTo3Prime();\n        //This should be sequence of A's ( as it's on complemetnary strand)but it is TTTTTTTT\n        System.err.println(  geneSequence.getSequence5PrimeTo3Prime().getSequenceAsString());\n    }\n\n    @Test\n    void addRemoveExon() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"mygene\"),5,150, Strand.POSITIVE);\n        geneSequence.addExon(new AccessionID(\"a\"), 20, 50);\n        geneSequence.addExon(new AccessionID(\"c\"), 20, 50);\n        assertEquals(2, geneSequence.getExonSequences().size());\n        geneSequence.removeExon(\"unknown\");\n        assertEquals(2, geneSequence.getExonSequences().size());\n\n        geneSequence.removeExon(\"c\");\n        assertEquals(1, geneSequence.getExonSequences().size());\n    }\n\n   @Test\n    void returnedCollectionsAreMutable() throws Exception {\n       geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"geneId\"), 5,150, Strand.POSITIVE);\n       geneSequence.addExon(new AccessionID(\"a\"), 20, 50);\n       List<ExonSequence> exons  =  geneSequence.getExonSequences();\n       // this breaks encapsulation of the collections\n       exons.remove(0);\n       assertEquals(0, geneSequence.getExonSequences().size());\n   }\n}","changedTest":"package org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass GeneSequenceTest {\n    GeneSequence geneSequence;\n    ChromosomeSequence chromosomeSequence;\n    @BeforeEach\n    void before() throws CompoundNotFoundException {\n        chromosomeSequence = new ChromosomeSequence(ChromosomeSequenceTest.CHROMOSOME_SEQ);\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"mygene\"), 10,19, Strand.POSITIVE);\n    }\n\n    @Nested\n    class AfterValidConstruction {\n\n\n        @Test\n        void lengthIsSetByBeginAndEnd() {\n            assertEquals(10, geneSequence.getLength());\n        }\n\n        @Test\n        void noExonsIntronsOrTranscripts() {\n            assertEquals(0, geneSequence.getExonSequences().size());\n            assertEquals(0, geneSequence.getIntronSequences().size());\n            assertEquals(0, geneSequence.getTranscripts().size());\n        }\n        @Test\n        void geneSequenceIsChromosomeSequence() {\n            assertEquals(chromosomeSequence.getSequenceAsString(), geneSequence.getSequenceAsString());\n        }\n\n        @Test\n        void geneSequenceIsChromos2omeSequence() {\n            geneSequence.setStrand(Strand.NEGATIVE);\n            geneSequence.getSequenceAsString();\n            geneSequence.getBioBegin();\n        }\n    }\n\n\n    @Test\n    void addIntronsUsingExonsPositiveStrand() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence,new AccessionID(\"geneId\"), 10,150, Strand.POSITIVE);\n        geneSequence.addExon( new AccessionID(\"a\"), 10,29);\n        geneSequence.addExon( new AccessionID(\"b\"), 33,80);\n        geneSequence.addExon( new AccessionID(\"c\"), 100,120);\n        geneSequence.addIntronsUsingExons();\n        assertEquals(2, geneSequence.getIntronSequences().size());\n        assertEquals(30, geneSequence.getIntronSequences().get(0).getBioBegin());\n        assertEquals(32, geneSequence.getIntronSequences().get(0).getBioEnd());\n        assertEquals(81, geneSequence.getIntronSequences().get(1).getBioBegin());\n        assertEquals(99, geneSequence.getIntronSequences().get(1).getBioEnd());\n    }\n\n    @Test\n    @Disabled(\"gives odd results for intron coords\")\n    void addIntronsUsingExonsNegativeStrand() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence,new AccessionID(\"geneId\"), 150,10, Strand.NEGATIVE);\n        ExonSequence e1 = geneSequence.addExon( new AccessionID(\"c\"), 120,100);\n\n        geneSequence.addExon( new AccessionID(\"b\"), 80,33);\n        geneSequence.addExon( new AccessionID(\"a\"), 29,10);\n\n        // this MUST be set in order to avoid NPE when adding introns\n        geneSequence.addIntronsUsingExons();\n        // actual values generated are (9,81) for I1 and (32,121) for I2\n        assertEquals(2, geneSequence.getIntronSequences().size());\n        assertEquals(99, geneSequence.getIntronSequences().get(0).getBioBegin());\n        assertEquals(81, geneSequence.getIntronSequences().get(0).getBioEnd());\n        assertEquals(32, geneSequence.getIntronSequences().get(1).getBioBegin());\n        assertEquals(30, geneSequence.getIntronSequences().get(1).getBioEnd());\n    }\n\n    @Test\n    void getPositiveStrandSequence5To3Prime() {\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"geneId\"), 10,150, Strand.POSITIVE);\n        // this must be set to avoid NPE\n        assertEquals(chromosomeSequence.getSequenceAsString().substring(9,150),\n                geneSequence.getSequence5PrimeTo3Prime().getSequenceAsString());\n    }\n\n    @Test\n   @Disabled(\"not complementing - seems to complement twice???\")\n    void getNegativeStrandSequence5To3Prime() throws CompoundNotFoundException {\n        ChromosomeSequence shortChrSeq= new ChromosomeSequence(\"TTTTTTTTTTTTTTT\");\n        geneSequence = new GeneSequence(shortChrSeq, new AccessionID(\"geneId\"),5,10, Strand.NEGATIVE);\n        // this must be set to avoid NPE\n        DNASequence seq = geneSequence.getSequence5PrimeTo3Prime();\n        //This should be sequence of A's ( as it's on complemetnary strand)but it is TTTTTTTT\n        System.err.println(  geneSequence.getSequence5PrimeTo3Prime().getSequenceAsString());\n    }\n\n    @Test\n    void addRemoveExon() throws Exception {\n        geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"mygene\"),5,150, Strand.POSITIVE);\n        geneSequence.addExon(new AccessionID(\"a\"), 20, 50);\n        geneSequence.addExon(new AccessionID(\"c\"), 20, 50);\n        assertEquals(2, geneSequence.getExonSequences().size());\n        geneSequence.removeExon(\"unknown\");\n        assertEquals(2, geneSequence.getExonSequences().size());\n\n        geneSequence.removeExon(\"c\");\n        assertEquals(1, geneSequence.getExonSequences().size());\n    }\n\n   @Test\n    void returnedExonCollectionsAreNotMutable() throws Exception {\n       geneSequence = new GeneSequence(chromosomeSequence, new AccessionID(\"geneId\"), 5,150, Strand.POSITIVE);\n       geneSequence.addExon(new AccessionID(\"a\"), 20, 50);\n       List<ExonSequence> exons  =  geneSequence.getExonSequences();\n       // this breaks encapsulation of the collections\n       exons.remove(0);\n       assertEquals(1, geneSequence.getExonSequences().size());\n   }\n    @Test\n    void returnedIntronCollectionsAreNotMutable() throws Exception {\n        geneSequence = SequenceTestUtils.anyGeneSequence();\n        geneSequence.addExon(new AccessionID(\"a\"), 20, 50);\n        geneSequence.addExon(new AccessionID(\"b\"), 80, 100);\n        geneSequence.addIntronsUsingExons();\n        ArrayList<IntronSequence> introns  =  geneSequence.getIntronSequences();\n        assertEquals(1, introns.size());\n        introns.remove(0);\n        assertEquals(1, geneSequence.getIntronSequences().size());\n    }\n}","commitMessage":"fix mutable collections in GeneSequence\n","test_commitMessage":"fix mutable collections in GeneSequence\n","allZero":false}