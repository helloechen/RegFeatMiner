{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/PDBStatus.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/PDBStatusTest.java","prod_time":"2020-11-23 06:48:48","test_time":"2020-11-23 06:48:48","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":22,"add_classname_line":0,"add_condition_line":7,"add_field_line":2,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":5,"del_annotation_line":2,"del_call_line":121,"del_classname_line":0,"del_condition_line":48,"del_field_line":1,"del_import_line":7,"del_packageid_line":0,"del_parameter_line":7,"del_return_line":29,"label":"POSITIVE","prod_commitID":"0a70219111cbb9dfa5def02ec8368849724c2bf5","test_commitID":"0a70219111cbb9dfa5def02ec8368849724c2bf5","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.structure;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.biojava.nbio.structure.align.util.URLConnectionTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.*;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.*;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n *\n * <p>\n * All methods query the\n * <a href=\"https://data.rcsb.org\">\n * RCSB Data REST API</a>\n *\n * <p>\n * PDB supersessions form a directed acyclic graph, where edges point from an\n * obsolete ID to the entry that directly superseded it. For example, here are\n * edges from one portion of the graph:\n * <p>\n * 1CAT -> 3CAT<br/>\n * 3CAT -> 7CAT<br/>\n * 3CAT -> 8CAT<br/>\n *\n * <p>\n * The methods {@link #getReplaces(String, boolean) getReplaces(pdbId, false)}/\n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, false, true)}\n * just get the incoming/outgoing edges for a single node. The recursive versions\n * ({@link #getReplaces(String, boolean) getReplaces(pdbId, true)},\n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, true, false)})\n * will do a depth-first search up/down the tree and return a list of all nodes ]\n * reached.\n *\n * <p>\n * Finally, the {@link #getCurrent(String)} method returns a single PDB ID from among the\n * results of\n * {@link #getReplacement(String, boolean, boolean)}.\n * To be consistent with the old REST ordering, this is the PDB ID that occurs\n * last alphabetically.\n *\n * <p>\n * Results are cached to reduce server load.\n *\n * @author Spencer Bliven\n * @author Amr AL-Hossary\n * @author Jose Duarte\n * @since 3.0.2\n */\npublic class PDBStatus {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(PDBStatus.class);\n\n\t//public static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String DEFAULT_RCSB_DATA_API_SERVER = \"data.rcsb.org\";\n\tpublic static final String ALL_CURRENT_ENDPOINT = \"https://%s/rest/v1/holdings/current/entry_ids\";\n\n\t/**\n\t * saves the returned results for further use.\n\t *\n\t */\n\tprivate static final Map<String, Map<String, String>> recordsCache= new Hashtable<>();\n\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven\n\t *\n\t */\n\tpublic enum Status {\n\t\t// this is the list for unreleased: \"AUCO\" \"AUTH\" \"HOLD\" \"HPUB\" \"POLC\" \"PROC\" \"REFI\" \"REPL\" \"WAIT\" \"WDRN\"\n\t\t// The remaining from below are removed-related: OBSOLETE, MODEL (not available in Data API).\n\t\t// In Data API in rcsb_repository_holdings_insilico_models.status_code: 3 values \"OBS\", \"TRSF\", \"WDRN\" and 1 in  rcsb_repository_holdings_transferred.status_code: \"TRSF\"\n\t\t// for current: CURRENT (not available in current API)\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tMODEL,\n\t\tUNKNOWN;\n\n\t\t/**\n\t\t * @throws IllegalArgumentException If the string is not recognized\n\t\t */\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tString statusStrUpper = statusStr.toUpperCase();\n\t\t\tif(statusStrUpper.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"MODEL\"))\n\t\t\t\tstatus = Status.MODEL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"UNKNOWN\"))\n\t\t\t\tstatus = Status.UNKNOWN;\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to parse status '\"+statusStrUpper+\"'.\");\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the PDB in question.\n\t *\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) throws IOException {\n\t\tStatus[] statuses = getStatus(new String[] {pdbId});\n\t\tif(statuses != null) {\n\t\t\tassert(statuses.length == 1);\n\t\t\treturn statuses[0];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the a collection of PDBs in question in a single query.\n\t *\n\t * @see #getStatus(String)\n\t * @param pdbIds\n\t * @return The status array, or null if an error occurred.\n\t */\n\tpublic static Status[] getStatus(String[] pdbIds) throws IOException {\n\t\tStatus[] statuses = new Status[pdbIds.length];\n\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(pdbIds);\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != pdbIds.length) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", Arrays.toString(pdbIds));\n\t\t\treturn null;\n\t\t}\n\n\n\t\tfor(int pdbNum = 0;pdbNum<pdbIds.length;pdbNum++) {\n\t\t\t//Locate first element of attrList with matching structureId.\n\t\t\t//attrList is usually short, so don't worry about performance\n\t\t\tboolean foundAttr = false;\n\t\t\tfor( Map<String,String> attrs : attrList) {\n\n\t\t\t\t//Check that the record matches pdbId\n\t\t\t\tString id = attrs.get(\"structureId\");\n\t\t\t\tif(id == null || !id.equalsIgnoreCase(pdbIds[pdbNum])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Check that the status is given\n\t\t\t\tString statusStr = attrs.get(\"status\");\n\t\t\t\tStatus status = null;\n\t\t\t\tif(statusStr == null ) {\n\t\t\t\t\tlogger.error(\"No status returned for {}\", pdbIds[pdbNum]);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t} else {\n\t\t\t\t\tstatus = Status.fromString(statusStr);\n\t\t\t\t}\n\n\t\t\t\tif(status == null) {\n\t\t\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t}\n\n\t\t\t\tstatuses[pdbNum] = status;\n\t\t\t\tfoundAttr = true;\n\t\t\t}\n\t\t\tif(!foundAttr) {\n\t\t\t\tlogger.error(\"No result found for {}\", pdbIds[pdbNum]);\n\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t}\n\t\t}\n\n\t\treturn statuses;\n\t}\n\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to selecting\n\t * the first element from\n\t * {@link #getReplacement(String,boolean,boolean)\n\t *\n\t * @param oldPdbId\n\t * @return The replacement for oldPdbId, or null if none are found or if an error occurred.\n\t */\n\tpublic static String getCurrent(String oldPdbId) throws IOException {\n\t\tList<String> replacements = getReplacement(oldPdbId,true, false);\n\t\tif(replacements != null && !replacements.isEmpty())\n\t\t\treturn replacements.get(0);\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT IDs, this will\n\t * be itself. For obsolete IDs, the behavior depends on the recursion\n\t * parameter. If false, only IDs which directly supersede oldPdbId are\n\t * returned. If true, the replacements for obsolete records are recursively\n\t * fetched, yielding a list of all current replacements of oldPdbId.\n\t *\n\t *\n\t *\n\t * @param oldPdbId A pdb ID\n\t * @param recurse Indicates whether the replacements for obsolete records\n\t * \t\tshould be fetched.\n\t * @param includeObsolete Indicates whether obsolete records should be\n\t * \t\tincluded in the results.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB or that an error has occurred.\n\t */\n\tpublic static List<String> getReplacement(String oldPdbId, boolean recurse, boolean includeObsolete) throws IOException {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equalsIgnoreCase(oldPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tlogger.error(\"No status returned for {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we're current, just return\n\t\tLinkedList<String> results = new LinkedList<>();\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\tresults.add(oldPdbId);\n\t\t\t\treturn results;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\tlogger.error(\"{} is OBSOLETE but lacks a replacedBy attribute.\", oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t//include this result\n\t\t\t\tif(includeObsolete) {\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn results; //empty\n\t\t\t\t}\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(includeObsolete) {\n\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check status of replacement\n\t\t\t\t\t\t\tStatus replacementStatus = getStatus(replacement);\n\t\t\t\t\t\t\tswitch(replacementStatus) {\n\t\t\t\t\t\t\t\tcase OBSOLETE:\n\t\t\t\t\t\t\t\t\t//ignore obsolete\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURRENT:\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// include it\n\t\t\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, treat like we're current\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\n\t\t\t\t//include this result, since it's not obsolete\n\t\t\t\tresults.add(oldPdbId);\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes two reverse sorted lists of strings and merges the second into the\n\t * first. Duplicates are removed.\n\t *\n\t * @param merged A reverse sorted list. Modified by this method to contain\n\t * \t\tthe contents of other.\n\t * @param other A reverse sorted list. Not modified.\n\t */\n\tprivate static void mergeReversed(List<String> merged,\n\t                                  final List<String> other) {\n\n\t\tif(other.isEmpty())\n\t\t\treturn;\n\n\t\tif(merged.isEmpty()) {\n\t\t\tmerged.addAll(other);\n\t\t\treturn;\n\t\t}\n\n\t\tListIterator<String> m = merged.listIterator();\n\t\tListIterator<String> o = other.listIterator();\n\n\t\tString nextM, prevO;\n\t\tprevO = o.next();\n\t\twhile(m.hasNext()) {\n\t\t\t// peek at m\n\t\t\tnextM = m.next();\n\t\t\tm.previous();\n\n\t\t\t//insert from O until exhausted or occurs after nextM\n\t\t\twhile(prevO.compareTo(nextM) > 0) {\n\t\t\t\tm.add(prevO);\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\t\t\t//remove duplicates\n\t\t\tif(prevO.equals(nextM)) {\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\n\t\t\tm.next();\n\t\t}\n\t\tm.add(prevO);\n\t\twhile(o.hasNext()) {\n\t\t\tm.add(o.next());\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t *\n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) throws IOException {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimited 'replaces'\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = new LinkedList<String>();\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tmergeReversed(allDescendents,roots);\n\t\t\t}\n\t\t\tmergeReversed(allDescendents,Arrays.asList(directDescendents));\n\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\n\n\t/**\n\t * The status of PDB IDs are cached to reduce server overload.\n\t *\n\t * This method clears the cached records.\n\t */\n\tpublic static void clearCache() {\n\t\trecordsCache.clear();\n\t}\n\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t *\n\t * <p>\n\t * Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t *\n\t * <p>\n\t * Example:\n\t * <p>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t * <pre>\n\t * &lt;idStatus&gt;\n\t *   &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *   &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t * &lt;/idStatus&gt;\n\t * </pre>\n\t *\n\t * <p>\n\t * Results are not guaranteed to be returned in the same order as pdbIDs.\n\t * Refer to the structureId property to match them.\n\t *\n\t * @param pdbIDs the PDB identifiers\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) throws IOException {\n\n\t\tList<Map<String,String>> result = new ArrayList<>(pdbIDs.length);\n\n\t\tString serverName = DEFAULT_RCSB_DATA_API_SERVER;\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=\",serverName);\n\t\tfor(String pdbId : pdbIDs) {\n\t\t\tpdbId = pdbId.toUpperCase();\n\t\t\t//check the cache\n\t\t\tif (recordsCache.containsKey(pdbId)) {\n\t\t\t\t//logger.debug(\"Fetching \"+pdbId+\" from Cache\");\n\t\t\t\tresult.add( recordsCache.get(pdbId) );\n\t\t\t} else {\n\t\t\t\turlStr += pdbId + \",\";\n\t\t\t}\n\t\t}\n\n\t\t// check if any ids still need fetching\n\t\tif(urlStr.charAt(urlStr.length()-1) == '=') {\n\t\t\treturn result;\n\t\t}\n\n\t\tlogger.info(\"Fetching {}\", urlStr);\n\n\t\tURL url = new URL(urlStr);\n\n\t\tInputStream uStream = url.openStream();\n\n\t\tInputSource source = new InputSource(uStream);\n\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\tXMLReader reader = parser.getXMLReader();\n\n\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\n\t\treader.setContentHandler(handler);\n\t\treader.parse(source);\n\n\t\t// Fetch results of SAX parsing\n\t\tList<Map<String, String>> records = handler.getRecords();\n\n\t\t//add to cache\n\t\tfor (Map<String, String> record : records) {\n\t\t\tString pdbId = record.get(\"structureId\").toUpperCase();\n\t\t\tif (pdbId != null) {\n\t\t\t\trecordsCache.put(pdbId, record);\n\t\t\t}\n\t\t}\n\n\t\t// return results\n\t\tresult.addAll(handler.getRecords());\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all current PDB IDs\n\t *\n\t * @return a list of PDB IDs\n\t * @throws IOException if a problem occurs retrieving the information\n\t */\n\tpublic static SortedSet<String> getCurrentPDBIds() throws IOException {\n\n\t\t//String serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\t\tString serverName = DEFAULT_RCSB_DATA_API_SERVER;\n\n\t\t// Build REST query URL\n\t\tString urlStr = String.format(ALL_CURRENT_ENDPOINT, serverName);\n\t\tURL u = new URL(urlStr);\n\n\t\tInputStream stream = URLConnectionTools.getInputStream(u, 60000);\n\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tTypeFactory typeFactory = objectMapper.getTypeFactory();\n\t\tList<String> pdbIdList = objectMapper.readValue(stream, typeFactory.constructCollectionType(List.class, String.class));\n\n\t\treturn new TreeSet<>(pdbIdList);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSortedSet<String> all = getCurrentPDBIds();\n\t\tSystem.out.println(\"Number of current PDB ids is: \" + all.size());\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.biojava.nbio.structure.align.util.URLConnectionTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.*;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, unreleased)\n * and for accessing different versions of the structure.\n *\n * <p>\n * All methods query the\n * <a href=\"https://data.rcsb.org\">\n * RCSB Data REST API</a>\n * <p>\n *\n * @author Spencer Bliven\n * @author Amr AL-Hossary\n * @author Jose Duarte\n * @since 3.0.2\n */\npublic class PDBStatus {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(PDBStatus.class);\n\n\tpublic static final String DEFAULT_RCSB_DATA_API_SERVER = \"data.rcsb.org\";\n\tpublic static final String ALL_CURRENT_ENDPOINT = \"https://%s/rest/v1/holdings/current/entry_ids\";\n\tpublic static final String STATUS_ENDPOINT = \"https://%s/rest/v1/holdings/status/%s\";\n\tpublic static final String STATUS_LIST_ENDPOINT = \"https://%s/rest/v1/holdings/status?ids=%s\";\n\n\t/**\n\t * Represents a simplified 3 state status of PDB IDs.\n\t * @author Spencer Bliven\n\t *\n\t */\n\tpublic enum Status {\n\t\t// the simplified status enum in rcsb_repository_holdings_combined\n\t\tREMOVED,\n\t\tCURRENT,\n\t\tUNRELEASED;\n\n\t\t/**\n\t\t * @throws IllegalArgumentException If the string is not recognized\n\t\t */\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tString statusStrUpper = statusStr.toUpperCase();\n\t\t\tif(statusStrUpper.equalsIgnoreCase(\"REMOVED\"))\n\t\t\t\tstatus = Status.REMOVED;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"UNRELEASED\"))\n\t\t\t\tstatus = Status.UNRELEASED;\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to parse status '\"+statusStrUpper+\"'.\");\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the PDB in question.\n\t *\n\t * @param pdbId the id\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) throws IOException {\n\t\tURL url = new URL(String.format(STATUS_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER, pdbId.toUpperCase()));\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tJsonNode node = objectMapper.readValue(url.openStream(), JsonNode.class);\n\t\treturn parseStatusRecord(node);\n\t}\n\n\t/**\n\t * Get the status of the a collection of PDBs in question in a single query.\n\t *\n\t * @see #getStatus(String)\n\t * @param pdbIds the ids\n\t * @return The status array, or null if an error occurred.\n\t */\n\tpublic static Status[] getStatus(String[] pdbIds) throws IOException {\n\n\t\tURL url = new URL(String.format(STATUS_LIST_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER, String.join(\",\", pdbIds)));\n\n\t\tList<Status> statuses = new ArrayList<>();\n\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tJsonNode node = objectMapper.readValue(url.openStream(), JsonNode.class);\n\n\t\tif (node !=null && node.isArray()) {\n\t\t\tfor (JsonNode record : node) {\n\t\t\t\tStatus status = parseStatusRecord(record);\n\t\t\t\tstatuses.add(status);\n\t\t\t}\n\t\t}\n\n\t\tif (statuses.size() != pdbIds.length) {\n\t\t\tlogger.warn(\"RCSB status request was for {} ids, but {} were returned\", pdbIds.length, statuses.size());\n\t\t}\n\n\t\treturn statuses.toArray(new Status[0]);\n\t}\n\n\tprivate static Status parseStatusRecord(JsonNode jsonNode) {\n\t\t// \"rcsb_repository_holdings_combined\": {\n\t\t//\"id_code_replaced_by_latest\": \"4HHB\",\n\t\t//\"status\": \"REMOVED\",\n\t\t//\"status_code\": \"OBS\"\n\t\t//},\n\t\tJsonNode rcsbRepoHoldingsNode = jsonNode.get(\"rcsb_repository_holdings_combined\");\n\t\treturn Status.fromString(rcsbRepoHoldingsNode.get(\"status\").asText());\n\t}\n\n\t/**\n\t * Gets the current version of a PDB ID.\n\t *\n\t * @param oldPdbId the id\n\t * @return The replacement for oldPdbId, or null if none are found.\n\t * If entry is current then the input PDB id is returned\n\t */\n\tpublic static String getCurrent(String oldPdbId) throws IOException {\n\t\tURL url = new URL(String.format(STATUS_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER, oldPdbId.toUpperCase()));\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tJsonNode node = objectMapper.readValue(url.openStream(), JsonNode.class);\n\t\tJsonNode rcsbRepoHoldingsNode = node.get(\"rcsb_repository_holdings_combined\");\n\t\tStatus st = Status.fromString(rcsbRepoHoldingsNode.get(\"status\").asText());\n\t\tif (st == Status.REMOVED) {\n\t\t\tJsonNode replacedByNode = rcsbRepoHoldingsNode.get(\"id_code_replaced_by_latest\");\n\t\t\tif (replacedByNode != null)\n\t\t\t\treturn replacedByNode.asText();\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} else if (st == Status.CURRENT) {\n\t\t\treturn oldPdbId;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns all current PDB IDs\n\t *\n\t * @return a list of PDB IDs\n\t * @throws IOException if a problem occurs retrieving the information\n\t */\n\tpublic static SortedSet<String> getCurrentPDBIds() throws IOException {\n\n\t\t// Build REST query URL\n\t\tString urlStr = String.format(ALL_CURRENT_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER);\n\t\tURL u = new URL(urlStr);\n\n\t\tInputStream stream = URLConnectionTools.getInputStream(u, 60000);\n\n\t\tObjectMapper objectMapper = new ObjectMapper();\n\t\tTypeFactory typeFactory = objectMapper.getTypeFactory();\n\t\tList<String> pdbIdList = objectMapper.readValue(stream, typeFactory.constructCollectionType(List.class, String.class));\n\n\t\treturn new TreeSet<>(pdbIdList);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSortedSet<String> all = getCurrentPDBIds();\n\t\tSystem.out.println(\"Number of current PDB ids is: \" + all.size());\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.PDBStatus.Status;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t *\n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\t@Test\n\tpublic void testGetStatus() {\n\t\tAssert.assertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tAssert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tAssert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\n\t@Test\n\tpublic void testGetReplacement() {\n\t\tAssert.assertFalse(Arrays.asList(\"YES\").equals(Arrays.asList(\"NO\"))); //check for deep equals\n\n\t\t// 1CMW is replacedBy NONE\n\t\tAssert.assertEquals(Arrays.asList(), PDBStatus.getReplacement(\"1CMW\", true, false));\n\t\tAssert.assertEquals(Arrays.asList(\"1CMW\"), PDBStatus.getReplacement(\"1CMW\", true, true));\n\n\t\t// 1HHB is replacedBy 2-4HHB\n\t\tAssert.assertEquals(Arrays.asList(\"3HHB\"), PDBStatus.getReplacement(\"3HHB\", false, false));\n\t\tAssert.assertEquals(Arrays.asList(\"3HHB\"), PDBStatus.getReplacement(\"3HHB\", false, true));\n\t\tAssert.assertEquals(Arrays.asList(\"4HHB\", \"3HHB\", \"2HHB\"), PDBStatus.getReplacement(\"1HHB\", false, false));\n\t\tAssert.assertEquals(Arrays.asList(\"4HHB\", \"3HHB\", \"2HHB\", \"1HHB\"), PDBStatus.getReplacement(\"1HHB\", false, true));\n\n\t\t// 1CAT is replacedBy 3CAT is replacedBy 7-8CAT\n\t\tAssert.assertEquals(Arrays.asList(\"8CAT\", \"7CAT\", \"3CAT\", \"1CAT\"), PDBStatus.getReplacement(\"1CAT\", true, true));\n\t\tAssert.assertEquals(Arrays.asList(\"8CAT\", \"7CAT\"), PDBStatus.getReplacement(\"1CAT\", true, false));\n\t\tAssert.assertEquals(Arrays.asList(\"8CAT\", \"7CAT\", \"3CAT\"), PDBStatus.getReplacement(\"3CAT\", true, true));\n\t\tAssert.assertEquals(Arrays.asList(\"8CAT\", \"7CAT\"), PDBStatus.getReplacement(\"3CAT\", true, false));\n\t}\n\n\n\t@Test\n\tpublic void testGetCurrent() {\n\t\tAssert.assertEquals(\"4HHB\", PDBStatus.getCurrent(\"1HHB\"));\n\t\tAssert.assertEquals(\"3HHB\", PDBStatus.getCurrent(\"3HHB\"));\n\t\tAssert.assertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tAssert.assertEquals(\"3ENI\", PDBStatus.getCurrent(\"1KSA\"));\n\t\tAssert.assertEquals(\"8CAT\", PDBStatus.getCurrent(\"1CAT\"));\n\t\tAssert.assertEquals(\"8CAT\", PDBStatus.getCurrent(\"3CAT\"));\n\t\tAssert.assertEquals(\"7CAT\", PDBStatus.getCurrent(\"7CAT\"));\n\t}\n\n\t@Test\n\tpublic void testGetReplaces() {\n\t\tAssert.assertEquals(new ArrayList<String>(), Arrays.asList(new String[]{}));\n\n\t\tAssert.assertEquals(Arrays.asList(\"1HHB\"), PDBStatus.getReplaces(\"4HHB\", false));\n\t\tAssert.assertEquals(Arrays.asList(\"1HHB\"), PDBStatus.getReplaces(\"3HHB\", false));\n\t\tAssert.assertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\", false));\n\t\tAssert.assertEquals(Arrays.asList(\"1M50\", \"1KSA\"), PDBStatus.getReplaces(\"3ENI\", false));\n\t\tAssert.assertEquals(Arrays.asList(\"1M50\", \"1KSA\"), PDBStatus.getReplaces(\"3ENI\", true));\n\t\tAssert.assertEquals(Arrays.asList(\"3CAT\"), PDBStatus.getReplaces(\"8CAT\", false));\n\t\tAssert.assertEquals(Arrays.asList(\"3CAT\", \"1CAT\"), PDBStatus.getReplaces(\"8CAT\", true));\n\n\t}\n\n\t/**\n\t * Tests a helper method for merging that was giving me problems\n\t */\n\t@Test\n\tpublic void testMergeReversed() {\n\t\ttry {\n\t\t\tMethod mergeReversed = PDBStatus.class.getDeclaredMethod(\"mergeReversed\",\n\t\t\t\t\tList.class,List.class);\n\t\t\tmergeReversed.setAccessible(true);\n\n\n\t\t\tList<String> a,b;\n\n\t\t\tb = Arrays.asList(\"F\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"F\", \"A\"), a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"B\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"F\", \"B\", \"A\"), a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"G\", \"F\", \"A\"), a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"F\", \"A\", \"1\"), a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"G\", \"F\", \"A\", \"1\"), a);\n\n\t\t\tb = Arrays.asList();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"G\", \"F\", \"A\", \"1\"), a);\n\n\t\t\tb = Arrays.asList(\"G\",\"D\",\"C\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"F\");\n\t\t\ta.add(\"B\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tAssert.assertEquals(Arrays.asList(\"G\", \"F\", \"D\", \"C\", \"B\", \"A\", \"1\"), a);\n\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Test low-level connectivity to the PDB\n\t */\n\t@Test\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tAssert.assertEquals(\"Wrong number of records.\", 1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tAssert.assertEquals(\"Wrong number of attributes\", 3, attrs.size());\n\t\t\tAssert.assertEquals(\"Wrong structureId\", \"1HHB\", attrs.get(\"structureId\"));\n\t\t\tAssert.assertEquals(\"Wrong status\", \"OBSOLETE\", attrs.get(\"status\"));\n\t\t\tAssert.assertEquals(\"Wrong replacedBy\", \"4HHB 3HHB 2HHB\", attrs.get(\"replacedBy\"));\n\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tAssert.assertEquals(\"Wrong number of records.\", 2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tAssert.assertEquals(\"Wrong number of attributes\", 3, attrs.size());\n\t\t\tAssert.assertEquals(\"Wrong structureId\", \"4HHB\", attrs.get(\"structureId\"));\n\t\t\tAssert.assertEquals(\"Wrong status\", \"CURRENT\", attrs.get(\"status\"));\n\t\t\tAssert.assertEquals(\"Wrong replaces\", \"1HHB\", attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tAssert.assertEquals(\"Wrong number of attributes\", 3, attrs.size());\n\t\t\tAssert.assertEquals(\"Wrong structureId\", \"1HHB\", attrs.get(\"structureId\"));\n\t\t\tAssert.assertEquals(\"Wrong status\", \"OBSOLETE\", attrs.get(\"status\"));\n\t\t\tAssert.assertEquals(\"Wrong replacedBy\", \"4HHB 3HHB 2HHB\", attrs.get(\"replacedBy\"));\n\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"3ENI\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tAssert.assertEquals(\"Wrong number of records.\", 1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tAssert.assertEquals(\"Wrong number of attributes\", 3, attrs.size());\n\t\t\tAssert.assertEquals(\"Wrong structureId\", \"3ENI\", attrs.get(\"structureId\"));\n\t\t\tAssert.assertEquals(\"Wrong status\", \"CURRENT\", attrs.get(\"status\"));\n\t\t\tAssert.assertEquals(\"Wrong replacedBy\", \"1M50 1KSA\", attrs.get(\"replaces\"));\n\n\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tAssert.fail(e.getMessage());\n\t\t}\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.PDBStatus.Status;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.IOException;\n\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t *\n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\t@Test\n\tpublic void testGetStatus() throws IOException {\n\t\tAssert.assertEquals(Status.REMOVED, PDBStatus.getStatus(\"1HHB\"));\n\t\tAssert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tAssert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\n\t@Test\n\tpublic void testGetCurrent() throws IOException {\n\t\tAssert.assertEquals(\"4HHB\", PDBStatus.getCurrent(\"1HHB\"));\n\t\tAssert.assertEquals(\"3HHB\", PDBStatus.getCurrent(\"3HHB\"));\n\t\tAssert.assertNull(PDBStatus.getCurrent(\"1CMW\"));\n\t\tAssert.assertEquals(\"3ENI\", PDBStatus.getCurrent(\"1KSA\"));\n\t\tAssert.assertEquals(\"8CAT\", PDBStatus.getCurrent(\"1CAT\"));\n\t\tAssert.assertEquals(\"8CAT\", PDBStatus.getCurrent(\"3CAT\"));\n\t\tAssert.assertEquals(\"7CAT\", PDBStatus.getCurrent(\"7CAT\"));\n\t}\n}\n","commitMessage":"Now PDBStatus uses the current RCSB Data API\n","test_commitMessage":"Now PDBStatus uses the current RCSB Data API\n","allZero":false}