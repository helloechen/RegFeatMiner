{"repository":"biojava","prod_path":"structure/src/main/java/org/biojava/bio/structure/StructureTools.java","test_path":"structure/src/test/java/org/biojava/bio/structure/StructureToolsTest.java","prod_time":"2010-06-18 03:23:15","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"4be9a67d86aa89db640e4c78f522e9b600b15ee2","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n//import org.biojava.bio.seq.ProteinTools;\n//import org.biojava.bio.seq.io.SymbolTokenization;\n//import org.biojava.bio.symbol.Alphabet;\n//import org.biojava.bio.symbol.IllegalSymbolException;\n//import org.biojava.bio.symbol.Symbol;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n   /** The Atom name of C-alpha atoms.\n    *\n    */\n   public static final String caAtomName = \" CA \";\n\n   public static final String nAtomName = \"N\";\n\n   public static final String oAtomName = \"O\";\n\n   public static final String cbAtomName = \"CB\";\n\n\n   /** The names of the Atoms that form the backbone.\n    *\n    */\n   public static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n   public static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n   \n   private static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n   private static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n   \n   // there is a file format change in PDB 3.0 and nucleotides are being renamed\n   static private Map<String, Integer> nucleotides30 ;\n   static private Map<String, Integer> nucleotides23 ;\n\n   //amino acid 3 and 1 letter code definitions\n   private static final Map<String, Character> aminoAcids;\n\n   //\t// for conversion 3code 1code\n   //\tprivate static  SymbolTokenization threeLetter ;\n   //\tprivate static  SymbolTokenization oneLetter ;\n\n   public static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n   static {\n      nucleotides30 = new HashMap<String,Integer>();\n      nucleotides30.put(\"DA\",1);\n      nucleotides30.put(\"DC\",1);\n      nucleotides30.put(\"DG\",1);\n      nucleotides30.put(\"DT\",1);\n      nucleotides30.put(\"DI\",1);\n      nucleotides30.put(\"A\",1);\n      nucleotides30.put(\"G\",1);\n      nucleotides30.put(\"C\",1);\n      nucleotides30.put(\"U\",1);\n      nucleotides30.put(\"I\",1);\n\n      //TODO: check if they are always HETATMs, in that case this will not be necessary\n      // the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n      nucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n      nucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n      nucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n      nucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n      nucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n      nucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n      nucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n      nucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n      nucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n      nucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n      nucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n      // store nucleic acids (C, G, A, T, U, and I), and\n      // the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n      nucleotides23  = new HashMap<String,Integer>();\n      String[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n      for (int i = 0; i < names.length; i++) {\n         String n = names[i];\n         nucleotides23.put(n,1);\n      }\n\n      aminoAcids = new HashMap<String, Character>();\n      aminoAcids.put(\"GLY\", new Character('G'));\n      aminoAcids.put(\"ALA\", new Character('A'));\n      aminoAcids.put(\"VAL\", new Character('V'));\n      aminoAcids.put(\"LEU\", new Character('L'));\n      aminoAcids.put(\"ILE\", new Character('I'));\n      aminoAcids.put(\"PHE\", new Character('F'));\n      aminoAcids.put(\"TYR\", new Character('Y'));\n      aminoAcids.put(\"TRP\", new Character('W'));\n      aminoAcids.put(\"PRO\", new Character('P'));\n      aminoAcids.put(\"HIS\", new Character('H'));\n      aminoAcids.put(\"LYS\", new Character('K'));\n      aminoAcids.put(\"ARG\", new Character('R'));\n      aminoAcids.put(\"SER\", new Character('S'));\n      aminoAcids.put(\"THR\", new Character('T'));\n      aminoAcids.put(\"GLU\", new Character('E'));\n      aminoAcids.put(\"GLN\", new Character('Q'));\n      aminoAcids.put(\"ASP\", new Character('D'));\n      aminoAcids.put(\"ASN\", new Character('N'));\n      aminoAcids.put(\"CYS\", new Character('C'));\n      aminoAcids.put(\"MET\", new Character('M'));\n      //MSE is only found as a molecular replacement for MET\n      aminoAcids.put(\"MSE\", new Character('M'));\n      //'non-standard', genetically encoded\n      //http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n      //IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n      //likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n      aminoAcids.put(\"CSE\", new Character('U'));\n      aminoAcids.put(\"SEC\", new Character('U'));\n      aminoAcids.put(\"PYH\", new Character('O'));\n      aminoAcids.put(\"PYL\", new Character('O'));\n\n      //\t\ttry {\n      //\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n      //\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n      //\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n      //\t\t} catch (Exception e) {\n      //\t\t\t// this should not happen.\n      //\t\t\t// only if BioJava has not been built correctly...\n      //\t\t\tlogger.config(e.getMessage());\n      //\t\t\te.printStackTrace() ;\n      //\t\t}\n\n   }\n\n\n   /** Count how many number of Atoms are contained within a Structure object.\n    *\n    * @param s the structure object\n    * @return the number of Atoms in this Structure\n    */\n   public static final int getNrAtoms(Structure s){\n\n      int nrAtoms = 0;\n\n      Iterator<Group> iter = new GroupIterator(s);\n\n      while ( iter.hasNext()){\n         Group g = (Group) iter.next();\n         nrAtoms += g.size();\n      }\n\n      return nrAtoms;\n   }\n\n\n   /** Count how many groups are contained within a structure object.\n    *\n    * @param s the structure object\n    * @return the number of groups in the structure\n    */\n   public static final int getNrGroups(Structure s){\n      int nrGroups = 0;\n\n      List<Chain> chains = s.getChains(0);\n      Iterator<Chain> iter = chains.iterator();\n      while (iter.hasNext()){\n         Chain c = (Chain) iter.next();\n         nrGroups += c.getAtomLength();\n      }\n      return nrGroups;\n   }\n\n\n   /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n    * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n    *\n    *\n    * @param s the structure to get the atoms from\n    *\n    * @param atomNames  contains the atom names to be used.\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomArray(Structure s, String[] atomNames){\n      Iterator<Group> iter = new GroupIterator(s);\n      List<Atom> atoms = new ArrayList<Atom>();\n      while ( iter.hasNext()){\n         Group g = (Group) iter.next();\n\n         // a temp container for the atoms of this group\n         List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n         // flag to check if this group contains all the requested atoms.\n         boolean thisGroupAllAtoms = true;\n         for ( int i = 0 ; i < atomNames.length; i++){\n            String atomName = atomNames[i];\n            try {\n               Atom a = g.getAtom(atomName);\n               thisGroupAtoms.add(a);\n            } catch (StructureException e){\n               // this group does not have a required atom, skip it...\n               thisGroupAllAtoms = false;\n               break;\n            }\n         }\n         if ( thisGroupAllAtoms){\n            // add the atoms of this group to the array.\n            Iterator<Atom> aIter = thisGroupAtoms.iterator();\n            while(aIter.hasNext()){\n               Atom a = (Atom) aIter.next();\n               atoms.add(a);\n            }\n         }\n\n      }\n      return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n   }\n\n   /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n    * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n    *\n    *\n    * @param c the Chain to get the atoms from\n    *\n    * @param atomNames  contains the atom names to be used.\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n      List<Group> groups = c.getAtomGroups();\n\n      List<Atom> atoms = new ArrayList<Atom>();\n\n      for (Group g : groups){\n\n         // a temp container for the atoms of this group\n         List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n         // flag to check if this group contains all the requested atoms.\n         boolean thisGroupAllAtoms = true;\n         for ( int i = 0 ; i < atomNames.length; i++){\n            String atomName = atomNames[i];\n            try {\n               Atom a = g.getAtom(atomName);\n               thisGroupAtoms.add(a);\n            } catch (StructureException e){\n               // this group does not have a required atom, skip it...\n               thisGroupAllAtoms = false;\n               break;\n            }\n         }\n         if ( thisGroupAllAtoms){\n            // add the atoms of this group to the array.\n            Iterator<Atom> aIter = thisGroupAtoms.iterator();\n            while(aIter.hasNext()){\n               Atom a = (Atom) aIter.next();\n               atoms.add(a);\n            }\n         }\n\n      }\n      return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n   }\n\n   /** Returns an Atom array of the CA atoms.\n    * @param c the structure object\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomCAArray(Chain c){\n      String[] atomNames = {\" CA \" };\n      return getAtomArray(c,atomNames);\n   }\n\n   /** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n    * groups and chains. The chain will only contain groups that are part of the CA array.\n    * \n    * @param ca array of CA atoms\n    * @return Atom array\n    */\n   public static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n      Atom[] newCA = new Atom[ca.length];\n\n      List<Chain> model = new ArrayList<Chain>();\n      int apos = -1;\n      for(Atom a: ca){\n         apos++;\n         Group parentG = a.getParent();\n         Chain parentC = parentG.getParent();\n\n         Chain newChain = null;\n         for ( Chain c : model){\n            if ( c.getName().equals(parentC.getName())){\n               newChain = c;\n               break;\n            }\n         }\n         if ( newChain == null){\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n         }\n\n         Group parentN = (Group)parentG.clone();\n\n         newCA[apos] = parentN.getAtom(\" CA \");\n         newChain.addGroup(parentN);\n      }\n      return newCA;\n   }\n\n   /** Clone a set of CA Atoms, but returns the parent groups\n    *  \n    * @param ca Atom array\n    * @return Group array\n    */\n   public static Group[] cloneGroups(Atom[] ca) {\n      Group[] newGroup = new Group[ca.length]; \n\n      List<Chain> model = new ArrayList<Chain>();\n      int apos = -1;\n      for(Atom a: ca){\n         apos++;\n         Group parentG = a.getParent();\n         Chain parentC = parentG.getParent();\n\n         Chain newChain = null;\n         for ( Chain c : model){\n            if ( c.getName().equals(parentC.getName())){\n               newChain = c;\n               break;\n            }\n         }\n         if ( newChain == null){\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n         }\n\n         Group ng = (Group)parentG.clone();\n         newGroup[apos] = ng;\n         newChain.addGroup(ng);\n      }\n      return newGroup;\n   }\n\n   /** Returns an Atom array of the CA atoms.\n    * @param s the structure object\n    * @return an Atom[] array\n    */\n   public static Atom[] getAtomCAArray(Structure s){\n      String[] atomNames = {\" CA \"};\n      return getAtomArray(s,atomNames);\n   }\n\n   /** Returns an Atom array of the MainChain atoms.\n\n    * @param s the structure object\n    * @return an Atom[] array\n    */\n   public static Atom[] getBackboneAtomArray(Structure s){\n      String[] atomNames = backboneAtomNames;\n      return getAtomArray(s,atomNames);\n   }\n\n\n   /** convert three character amino acid codes into single character\n    *  e.g. convert CYS to C\n    *  @return a character\n    *  @param code3 a three character amino acid representation String\n    *  @throws IllegalSymbolException\n    */\n\n   public static final Character convert_3code_1code(String code3)\n   throws UnknownPdbAminoAcidException {\n      //\t{\n      //\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n      //\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n      //\n      //\t\treturn new Character(code1.charAt(0)) ;\n      Character code1 = null;\n      code1 = aminoAcids.get(code3);\n\n      if (code1 == null) {\n         throw new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n      } else {\n         return code1;\n      }\n\n   }\n\n   /** convert a three letter code into single character.\n    * catches for unusual characters\n    *\n    * @param groupCode3 three letter representation\n    * @return null if group is a nucleotide code\n    */\n   public static final Character get1LetterCode(String groupCode3){\n\n      Character aminoCode1 = null;\n      try {\n         // is it a standard amino acid ?\n         aminoCode1 = convert_3code_1code(groupCode3);\n      } catch (UnknownPdbAminoAcidException e){\n         // hm groupCode3 is not standard\n         // perhaps it is an nucleotide?\n         if ( isNucleotide(groupCode3) ) {\n            //System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n            aminoCode1= null;\n         } else {\n            // does not seem to be so let's assume it is\n            //  nonstandard aminoacid and label it \"X\"\n            //logger.warning(\"unknown group name \"+groupCode3 );\n            aminoCode1 = UNKNOWN_GROUP_LABEL;\n         }\n      }\n\n      return aminoCode1;\n\n   }\n\n\n   /* Test if the threelettercode of an ATOM entry corresponds to a\n    * nucleotide or to an aminoacid.\n    * @param a 3-character code for a group.\n    *\n    */\n   public static final boolean isNucleotide(String groupCode3){\n\n      String code = groupCode3.trim();\n      if ( nucleotides30.containsKey(code)){\n         return true;\n      }\n\n      if ( nucleotides23.containsKey(code)){\n         return true;\n      }\n\n      return false ;\n   }\n\n   /** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n    * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n    * \n    * @param s\n    * @param chainId\n    * @return Structure\n    * @since 3.0\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n      // since we deal here with structure alignments,\n      // only use Model 1...\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n\n      if ( chainId != null)\n         chainId = chainId.trim();\n\n      if ( chainId == null || chainId.equals(\"\")){\n         // only get model 0\n         List<Chain> model0 = s.getModel(0);\n         for (Chain c : model0){\n            newS.addChain(c);\n         }\n         return newS;\n\n      }\n\n      Chain c =  null;\n      try {\n         c = s.getChainByPDB(chainId);\n      } catch (StructureException e){\n         System.err.println(e.getMessage() + \" trying upper case Chain id...\");\n         c = s.getChainByPDB(chainId.toUpperCase());\n\n      }\n      if ( c != null)\n         newS.addChain(c);\n\n\n      return newS;\n   }\n\n\n   /** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainNr >=0 only takes the chain at that position into account.\t * \n    * @param s\n    * @param chainNr\n    * @return Structure object\n    * @since 3.0\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n      // since we deal here with structure alignments,\n      // only use Model 1...\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n\n      if ( chainNr < 0 ) {\n\n         // only get model 0\n         List<Chain> model0 = s.getModel(0);\n         for (Chain c : model0){\n            newS.addChain(c);\n         }\n         return newS;\n\n      }\n\n\n      Chain c =  null;\n\n      c = s.getChain(chainNr);\n\n      newS.addChain(c);\n\n\n      return newS;\n   }\n\n   /** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n    * specification:\n    *\n    * If range is null or \"\" returns the whole structure / chain.\n    * \n    * range can be surrounded by ( and ). (but will be removed).\n    * ranges are specified as\n    * PDBresnum1 : PDBresnum2\n    * \n    *  a list of ranges is separated by ,\n    *  \n    *  Example\n    *  4GCR(A:1-83)\n    *  1CDG(A:407-495,A:582-686)\n    *  \n    * \n    * \n    * @param s\n    * @param ranges\n    * @return a structure object\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getSubRanges(Structure s, String ranges ) \n   throws StructureException\n   {\n      Structure struc = getReducedStructure(s, null);\n\n      if ( ranges == null || ranges.equals(\"\"))\n         throw new IllegalArgumentException(\"ranges can't be null or empty\");\n\n      ranges = ranges.trim();\n\n      if ( ranges.startsWith(\"(\"))\n         ranges = ranges.substring(1);\n      if ( ranges.endsWith(\")\")) {\n         ranges = ranges.substring(0,ranges.length()-1);\n      }\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n\n      String[] rangS =ranges.split(\",\");\n\n\n      String prevChainId = null;\n\n      for ( String r: rangS){\n         String[] coords = r.split(\":\");\n         if ( coords.length != 2){\n            throw new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n         }\n\n         Chain chain = struc.getChainByPDB(coords[0]);\n\n         String[] pdbRanges = coords[1].split(\"-\");\n         if ( pdbRanges.length!= 2)\n            throw new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n         String pdbresnumStart = pdbRanges[0].trim();\n         String pdbresnumEnd   = pdbRanges[1].trim();\n\n         Group[] groups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\n         Chain c = null;\n         if ( prevChainId == null) {\n            // first chain...\n            c = new ChainImpl();\n            c.setName(chain.getName());\n            newS.addChain(c);\n         } else if ( prevChainId.equals(chain.getName())) {\n            c = newS.getChainByPDB(prevChainId);\n\n         } else {\n            try {\n               c = newS.getChainByPDB(chain.getName());\n            } catch (StructureException e){\n               // chain not in structure yet...\n               c = new ChainImpl();\n               c.setName(chain.getName());\n               newS.addChain(c);\n            }\n         }\n\n         // add the groups to the chain:\n         for ( Group g: groups) {\n            c.addGroup(g);\n         }\n\n         prevChainId = c.getName();\n      }\n\n\n      return newS;\n   }\n\n   public static final String convertAtomsToSeq(Atom[] atoms) {\n\n      StringBuffer buf = new StringBuffer();\n      Group prevGroup  = null;\n      for (Atom a : atoms){\n         Group g = a.getParent();\n         if ( prevGroup != null) {\n            if ( prevGroup.equals(g)) {\n               // we add each group only once.\n               continue;\n            }\n         }\n         String code3 = g.getPDBName();\n         try {\n            buf.append(convert_3code_1code(code3) );\n         } catch (UnknownPdbAminoAcidException e){\n            buf.append('X');\n         }\n         prevGroup = g;\n\n      }\n      return buf.toString();\n   }\n\n   /** get a PDB residue number object for this group\n    * \n    * @param g Group object\n    * @return a PDBResidueNumber object\n    */\n   public static final PDBResidueNumber getPDBResidueNumber(Group g){\n\n      PDBResidueNumber pdbResNum = new PDBResidueNumber();\n\n      Chain parent = g.getParent();\n      if ( parent != null)\n         pdbResNum.setChainId(parent.getName());\n\n      Matcher matcher = insertionCodePattern.matcher(g.getPDBCode());\n      if (matcher.find()){\n        \n        String number = matcher.group(1);\n        String insCode = matcher.group(2);\n        pdbResNum.setResidueNumber(Integer.parseInt(number));\n        if ((insCode != null) && (! insCode.equals(\"\"))){\n           pdbResNum.setInsCode(insCode);\n        }\n      } else {\n         try {\n            pdbResNum.setResidueNumber(Integer.parseInt(g.getPDBCode()));\n         } catch (NumberFormatException e){\n            \n         }\n      }\n\n      return pdbResNum;\n\n   }\n\n}\n","changedPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n//import org.biojava.bio.seq.ProteinTools;\n//import org.biojava.bio.seq.io.SymbolTokenization;\n//import org.biojava.bio.symbol.Alphabet;\n//import org.biojava.bio.symbol.IllegalSymbolException;\n//import org.biojava.bio.symbol.Symbol;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n   /** The Atom name of C-alpha atoms.\n    *\n    */\n   public static final String caAtomName = \" CA \";\n\n   public static final String nAtomName = \"N\";\n\n   public static final String oAtomName = \"O\";\n\n   public static final String cbAtomName = \"CB\";\n\n\n   /** The names of the Atoms that form the backbone.\n    *\n    */\n   public static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n   public static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n   \n   private static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n   private static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n   \n   // there is a file format change in PDB 3.0 and nucleotides are being renamed\n   static private Map<String, Integer> nucleotides30 ;\n   static private Map<String, Integer> nucleotides23 ;\n\n   //amino acid 3 and 1 letter code definitions\n   private static final Map<String, Character> aminoAcids;\n\n   //\t// for conversion 3code 1code\n   //\tprivate static  SymbolTokenization threeLetter ;\n   //\tprivate static  SymbolTokenization oneLetter ;\n\n   public static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n   static {\n      nucleotides30 = new HashMap<String,Integer>();\n      nucleotides30.put(\"DA\",1);\n      nucleotides30.put(\"DC\",1);\n      nucleotides30.put(\"DG\",1);\n      nucleotides30.put(\"DT\",1);\n      nucleotides30.put(\"DI\",1);\n      nucleotides30.put(\"A\",1);\n      nucleotides30.put(\"G\",1);\n      nucleotides30.put(\"C\",1);\n      nucleotides30.put(\"U\",1);\n      nucleotides30.put(\"I\",1);\n\n      //TODO: check if they are always HETATMs, in that case this will not be necessary\n      // the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n      nucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n      nucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n      nucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n      nucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n      nucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n      nucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n      nucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n      nucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n      nucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n      nucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n      nucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n      // store nucleic acids (C, G, A, T, U, and I), and\n      // the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n      nucleotides23  = new HashMap<String,Integer>();\n      String[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n      for (int i = 0; i < names.length; i++) {\n         String n = names[i];\n         nucleotides23.put(n,1);\n      }\n\n      aminoAcids = new HashMap<String, Character>();\n      aminoAcids.put(\"GLY\", new Character('G'));\n      aminoAcids.put(\"ALA\", new Character('A'));\n      aminoAcids.put(\"VAL\", new Character('V'));\n      aminoAcids.put(\"LEU\", new Character('L'));\n      aminoAcids.put(\"ILE\", new Character('I'));\n      aminoAcids.put(\"PHE\", new Character('F'));\n      aminoAcids.put(\"TYR\", new Character('Y'));\n      aminoAcids.put(\"TRP\", new Character('W'));\n      aminoAcids.put(\"PRO\", new Character('P'));\n      aminoAcids.put(\"HIS\", new Character('H'));\n      aminoAcids.put(\"LYS\", new Character('K'));\n      aminoAcids.put(\"ARG\", new Character('R'));\n      aminoAcids.put(\"SER\", new Character('S'));\n      aminoAcids.put(\"THR\", new Character('T'));\n      aminoAcids.put(\"GLU\", new Character('E'));\n      aminoAcids.put(\"GLN\", new Character('Q'));\n      aminoAcids.put(\"ASP\", new Character('D'));\n      aminoAcids.put(\"ASN\", new Character('N'));\n      aminoAcids.put(\"CYS\", new Character('C'));\n      aminoAcids.put(\"MET\", new Character('M'));\n      //MSE is only found as a molecular replacement for MET\n      aminoAcids.put(\"MSE\", new Character('M'));\n      //'non-standard', genetically encoded\n      //http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n      //IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n      //likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n      aminoAcids.put(\"CSE\", new Character('U'));\n      aminoAcids.put(\"SEC\", new Character('U'));\n      aminoAcids.put(\"PYH\", new Character('O'));\n      aminoAcids.put(\"PYL\", new Character('O'));\n\n      //\t\ttry {\n      //\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n      //\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n      //\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n      //\t\t} catch (Exception e) {\n      //\t\t\t// this should not happen.\n      //\t\t\t// only if BioJava has not been built correctly...\n      //\t\t\tlogger.config(e.getMessage());\n      //\t\t\te.printStackTrace() ;\n      //\t\t}\n\n   }\n\n\n   /** Count how many number of Atoms are contained within a Structure object.\n    *\n    * @param s the structure object\n    * @return the number of Atoms in this Structure\n    */\n   public static final int getNrAtoms(Structure s){\n\n      int nrAtoms = 0;\n\n      Iterator<Group> iter = new GroupIterator(s);\n\n      while ( iter.hasNext()){\n         Group g = (Group) iter.next();\n         nrAtoms += g.size();\n      }\n\n      return nrAtoms;\n   }\n\n\n   /** Count how many groups are contained within a structure object.\n    *\n    * @param s the structure object\n    * @return the number of groups in the structure\n    */\n   public static final int getNrGroups(Structure s){\n      int nrGroups = 0;\n\n      List<Chain> chains = s.getChains(0);\n      Iterator<Chain> iter = chains.iterator();\n      while (iter.hasNext()){\n         Chain c = (Chain) iter.next();\n         nrGroups += c.getAtomLength();\n      }\n      return nrGroups;\n   }\n\n\n   /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n    * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n    *\n    *\n    * @param s the structure to get the atoms from\n    *\n    * @param atomNames  contains the atom names to be used.\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomArray(Structure s, String[] atomNames){\n      Iterator<Group> iter = new GroupIterator(s);\n      List<Atom> atoms = new ArrayList<Atom>();\n      while ( iter.hasNext()){\n         Group g = (Group) iter.next();\n\n         // a temp container for the atoms of this group\n         List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n         // flag to check if this group contains all the requested atoms.\n         boolean thisGroupAllAtoms = true;\n         for ( int i = 0 ; i < atomNames.length; i++){\n            String atomName = atomNames[i];\n            try {\n               Atom a = g.getAtom(atomName);\n               thisGroupAtoms.add(a);\n            } catch (StructureException e){\n               // this group does not have a required atom, skip it...\n               thisGroupAllAtoms = false;\n               break;\n            }\n         }\n         if ( thisGroupAllAtoms){\n            // add the atoms of this group to the array.\n            Iterator<Atom> aIter = thisGroupAtoms.iterator();\n            while(aIter.hasNext()){\n               Atom a = (Atom) aIter.next();\n               atoms.add(a);\n            }\n         }\n\n      }\n      return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n   }\n\n   /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n    * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n    *\n    *\n    * @param c the Chain to get the atoms from\n    *\n    * @param atomNames  contains the atom names to be used.\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n      List<Group> groups = c.getAtomGroups();\n\n      List<Atom> atoms = new ArrayList<Atom>();\n\n      for (Group g : groups){\n\n         // a temp container for the atoms of this group\n         List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n         // flag to check if this group contains all the requested atoms.\n         boolean thisGroupAllAtoms = true;\n         for ( int i = 0 ; i < atomNames.length; i++){\n            String atomName = atomNames[i];\n            try {\n               Atom a = g.getAtom(atomName);\n               thisGroupAtoms.add(a);\n            } catch (StructureException e){\n               // this group does not have a required atom, skip it...\n               thisGroupAllAtoms = false;\n               break;\n            }\n         }\n         if ( thisGroupAllAtoms){\n            // add the atoms of this group to the array.\n            Iterator<Atom> aIter = thisGroupAtoms.iterator();\n            while(aIter.hasNext()){\n               Atom a = (Atom) aIter.next();\n               atoms.add(a);\n            }\n         }\n\n      }\n      return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n   }\n\n   /** Returns an Atom array of the CA atoms.\n    * @param c the structure object\n    * @return an Atom[] array\n    */\n   public static final Atom[] getAtomCAArray(Chain c){\n      String[] atomNames = {\" CA \" };\n      return getAtomArray(c,atomNames);\n   }\n\n   /** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n    * groups and chains. The chain will only contain groups that are part of the CA array.\n    * \n    * @param ca array of CA atoms\n    * @return Atom array\n    */\n   public static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n      Atom[] newCA = new Atom[ca.length];\n\n      List<Chain> model = new ArrayList<Chain>();\n      int apos = -1;\n      for(Atom a: ca){\n         apos++;\n         Group parentG = a.getParent();\n         Chain parentC = parentG.getParent();\n\n         Chain newChain = null;\n         for ( Chain c : model){\n            if ( c.getName().equals(parentC.getName())){\n               newChain = c;\n               break;\n            }\n         }\n         if ( newChain == null){\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n         }\n\n         Group parentN = (Group)parentG.clone();\n\n         newCA[apos] = parentN.getAtom(\" CA \");\n         newChain.addGroup(parentN);\n      }\n      return newCA;\n   }\n\n   /** Clone a set of CA Atoms, but returns the parent groups\n    *  \n    * @param ca Atom array\n    * @return Group array\n    */\n   public static Group[] cloneGroups(Atom[] ca) {\n      Group[] newGroup = new Group[ca.length]; \n\n      List<Chain> model = new ArrayList<Chain>();\n      int apos = -1;\n      for(Atom a: ca){\n         apos++;\n         Group parentG = a.getParent();\n         Chain parentC = parentG.getParent();\n\n         Chain newChain = null;\n         for ( Chain c : model){\n            if ( c.getName().equals(parentC.getName())){\n               newChain = c;\n               break;\n            }\n         }\n         if ( newChain == null){\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n         }\n\n         Group ng = (Group)parentG.clone();\n         newGroup[apos] = ng;\n         newChain.addGroup(ng);\n      }\n      return newGroup;\n   }\n\n   /** Returns an Atom array of the CA atoms.\n    * @param s the structure object\n    * @return an Atom[] array\n    */\n   public static Atom[] getAtomCAArray(Structure s){\n      String[] atomNames = {\" CA \"};\n      return getAtomArray(s,atomNames);\n   }\n\n   /** Returns an Atom array of the MainChain atoms.\n\n    * @param s the structure object\n    * @return an Atom[] array\n    */\n   public static Atom[] getBackboneAtomArray(Structure s){\n      String[] atomNames = backboneAtomNames;\n      return getAtomArray(s,atomNames);\n   }\n\n\n   /** convert three character amino acid codes into single character\n    *  e.g. convert CYS to C\n    *  @return a character\n    *  @param code3 a three character amino acid representation String\n    *  @throws IllegalSymbolException\n    */\n\n   public static final Character convert_3code_1code(String code3)\n   throws UnknownPdbAminoAcidException {\n      //\t{\n      //\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n      //\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n      //\n      //\t\treturn new Character(code1.charAt(0)) ;\n      Character code1 = null;\n      code1 = aminoAcids.get(code3);\n\n      if (code1 == null) {\n         throw new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n      } else {\n         return code1;\n      }\n\n   }\n\n   /** convert a three letter code into single character.\n    * catches for unusual characters\n    *\n    * @param groupCode3 three letter representation\n    * @return null if group is a nucleotide code\n    */\n   public static final Character get1LetterCode(String groupCode3){\n\n      Character aminoCode1 = null;\n      try {\n         // is it a standard amino acid ?\n         aminoCode1 = convert_3code_1code(groupCode3);\n      } catch (UnknownPdbAminoAcidException e){\n         // hm groupCode3 is not standard\n         // perhaps it is an nucleotide?\n         if ( isNucleotide(groupCode3) ) {\n            //System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n            aminoCode1= null;\n         } else {\n            // does not seem to be so let's assume it is\n            //  nonstandard aminoacid and label it \"X\"\n            //logger.warning(\"unknown group name \"+groupCode3 );\n            aminoCode1 = UNKNOWN_GROUP_LABEL;\n         }\n      }\n\n      return aminoCode1;\n\n   }\n\n\n   /* Test if the threelettercode of an ATOM entry corresponds to a\n    * nucleotide or to an aminoacid.\n    * @param a 3-character code for a group.\n    *\n    */\n   public static final boolean isNucleotide(String groupCode3){\n\n      String code = groupCode3.trim();\n      if ( nucleotides30.containsKey(code)){\n         return true;\n      }\n\n      if ( nucleotides23.containsKey(code)){\n         return true;\n      }\n\n      return false ;\n   }\n\n   /** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n    * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n    * \n    * @param s\n    * @param chainId\n    * @return Structure\n    * @since 3.0\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n      // since we deal here with structure alignments,\n      // only use Model 1...\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n\n      if ( chainId != null)\n         chainId = chainId.trim();\n\n      if ( chainId == null || chainId.equals(\"\")){\n         // only get model 0\n         List<Chain> model0 = s.getModel(0);\n         for (Chain c : model0){\n            newS.addChain(c);\n         }\n         return newS;\n\n      }\n\n      Chain c =  null;\n      try {\n         c = s.getChainByPDB(chainId);\n      } catch (StructureException e){\n         System.err.println(e.getMessage() + \" trying upper case Chain id...\");\n         c = s.getChainByPDB(chainId.toUpperCase());\n\n      }\n      if ( c != null)\n         newS.addChain(c);\n\n\n      return newS;\n   }\n\n\n   /** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainNr >=0 only takes the chain at that position into account.\t * \n    * @param s\n    * @param chainNr\n    * @return Structure object\n    * @since 3.0\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n      // since we deal here with structure alignments,\n      // only use Model 1...\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n      newS.setSSBonds(s.getSSBonds());\n      newS.setDBRefs(s.getDBRefs());\n      if ( chainNr < 0 ) {\n\n         // only get model 0\n         List<Chain> model0 = s.getModel(0);\n         for (Chain c : model0){\n            newS.addChain(c);\n         }\n         return newS;\n\n      }\n\n\n      Chain c =  null;\n\n      c = s.getChain(chainNr);\n\n      newS.addChain(c);\n\n\n      return newS;\n   }\n\n   /** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n    * specification:\n    *\n    * If range is null or \"\" returns the whole structure / chain.\n    * \n    * range can be surrounded by ( and ). (but will be removed).\n    * ranges are specified as\n    * PDBresnum1 : PDBresnum2\n    * \n    *  a list of ranges is separated by ,\n    *  \n    *  Example\n    *  4GCR(A:1-83)\n    *  1CDG(A:407-495,A:582-686)\n    *  \n    * \n    * \n    * @param s\n    * @param ranges\n    * @return a structure object\n    */\n   @SuppressWarnings(\"deprecation\")\n   public static final Structure getSubRanges(Structure s, String ranges ) \n   throws StructureException\n   {\n      Structure struc = getReducedStructure(s, null);\n\n      if ( ranges == null || ranges.equals(\"\"))\n         throw new IllegalArgumentException(\"ranges can't be null or empty\");\n\n      ranges = ranges.trim();\n\n      if ( ranges.startsWith(\"(\"))\n         ranges = ranges.substring(1);\n      if ( ranges.endsWith(\")\")) {\n         ranges = ranges.substring(0,ranges.length()-1);\n      }\n\n      Structure newS = new StructureImpl();\n      newS.setHeader(s.getHeader());\n      newS.setPDBCode(s.getPDBCode());\n      newS.setPDBHeader(s.getPDBHeader());\n\n      String[] rangS =ranges.split(\",\");\n\n\n      String prevChainId = null;\n\n      for ( String r: rangS){\n         String[] coords = r.split(\":\");\n         if ( coords.length != 2){\n            throw new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n         }\n\n         Chain chain = struc.getChainByPDB(coords[0]);\n\n         String[] pdbRanges = coords[1].split(\"-\");\n         if ( pdbRanges.length!= 2)\n            throw new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n         String pdbresnumStart = pdbRanges[0].trim();\n         String pdbresnumEnd   = pdbRanges[1].trim();\n\n         Group[] groups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\n         Chain c = null;\n         if ( prevChainId == null) {\n            // first chain...\n            c = new ChainImpl();\n            c.setName(chain.getName());\n            newS.addChain(c);\n         } else if ( prevChainId.equals(chain.getName())) {\n            c = newS.getChainByPDB(prevChainId);\n\n         } else {\n            try {\n               c = newS.getChainByPDB(chain.getName());\n            } catch (StructureException e){\n               // chain not in structure yet...\n               c = new ChainImpl();\n               c.setName(chain.getName());\n               newS.addChain(c);\n            }\n         }\n\n         // add the groups to the chain:\n         for ( Group g: groups) {\n            c.addGroup(g);\n         }\n\n         prevChainId = c.getName();\n      }\n\n\n      return newS;\n   }\n\n   public static final String convertAtomsToSeq(Atom[] atoms) {\n\n      StringBuffer buf = new StringBuffer();\n      Group prevGroup  = null;\n      for (Atom a : atoms){\n         Group g = a.getParent();\n         if ( prevGroup != null) {\n            if ( prevGroup.equals(g)) {\n               // we add each group only once.\n               continue;\n            }\n         }\n         String code3 = g.getPDBName();\n         try {\n            buf.append(convert_3code_1code(code3) );\n         } catch (UnknownPdbAminoAcidException e){\n            buf.append('X');\n         }\n         prevGroup = g;\n\n      }\n      return buf.toString();\n   }\n\n   /** get a PDB residue number object for this group\n    * \n    * @param g Group object\n    * @return a PDBResidueNumber object\n    */\n   public static final PDBResidueNumber getPDBResidueNumber(Group g){\n\n      PDBResidueNumber pdbResNum = new PDBResidueNumber();\n\n      Chain parent = g.getParent();\n      if ( parent != null)\n         pdbResNum.setChainId(parent.getName());\n\n      Matcher matcher = insertionCodePattern.matcher(g.getPDBCode());\n      if (matcher.find()){\n        \n        String number = matcher.group(1);\n        String insCode = matcher.group(2);\n        pdbResNum.setResidueNumber(Integer.parseInt(number));\n        if ((insCode != null) && (! insCode.equals(\"\"))){\n           pdbResNum.setInsCode(insCode);\n        }\n      } else {\n         try {\n            pdbResNum.setResidueNumber(Integer.parseInt(g.getPDBCode()));\n         } catch (NumberFormatException e){\n            \n         }\n      }\n\n      return pdbResNum;\n\n   }\n\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava.bio.structure.io.PDBFileParser;\n\nimport junit.framework.TestCase;\n\npublic class StructureToolsTest extends TestCase {\n\n    Structure structure;\n\n    protected void setUp()\n    {\n        InputStream inStream = this.getClass().getResourceAsStream(\"/5pti.pdb\");\n        assertNotNull(inStream);\n\n\n        PDBFileParser pdbpars = new PDBFileParser();\n        FileParsingParameters params = new FileParsingParameters();\n        params.setAlignSeqRes(false);\n        pdbpars.setFileParsingParameters(params);\n        \n        try {\n            structure = pdbpars.parsePDBFile(inStream) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        assertNotNull(structure);\n\n        assertEquals(\"structure does not contain one chain \", 1 ,structure.size());\n    }\n\n\n    public void testGetCAAtoms(){\n        Atom[] cas = StructureTools.getAtomCAArray(structure);\n        assertEquals(\"did not find the expected number of Atoms (58), but got \" + cas.length,58,cas.length);\n    }\n\n    public void testGetNrAtoms(){\n        int length = StructureTools.getNrAtoms(structure);\n        assertEquals(\"did not find the expected number of Atoms (1104), but got \" + length,1104,length);\n\n\n    }\n\n\n\n}\n","changedTest":"","commitMessage":"adding SSBonds and DBref to utility method\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7979 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}