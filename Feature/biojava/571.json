{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/mmtf/MmtfUtils.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/mmtf/TestMmtfUtils.java","prod_time":"2016-04-19 08:32:48","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"899389e8a9a13291a0eff2e3e7b4c9ad0e09ea39","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.FileNotFoundException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\t//\t\tCustomChemCompProvider cc = new CustomChemCompProvider();\n\t\t//\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\t//\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava. - with an extra URL\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\t//\t\tCustomChemCompProvider cc = new CustomChemCompProvider();\n\t\t//\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\t//\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to get all the atoms in the strucutre as a list.\n\t * @param bioJavaStruct the biojava structure\n\t * @return a list of all the unique atoms in the structure\n\t */\n\tpublic static List<Atom> getAllAtoms(Structure bioJavaStruct) {\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tfor(Atom a: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(a);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Function to get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\n\t/**\n\t * Function to generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\ttry{\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t}\n\t\t\tcatch(FileNotFoundException enew){\n\t\t\t}\n\t\t\tcatch(Exception bige){\n\t\t\t\tSystem.out.println(bige);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform -> chainindices it relates to\n\t * @param bioassemblyInfo\n\t * @param chainIdToIndexMap \n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t\tMap<Matrix4d, List<Integer>> matMap = new HashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\t\tMap<double[], int[]> outMap = new HashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tprivate static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Get a list of all the chains in a structure.\n\t * @param structure the input structure\n\t * @return the list of chains\n\t */\n\tpublic static List<Chain> getAllChains(Structure structure) {\n\t\tList<Chain> chainList = new ArrayList<>();\n\t\tfor (int i=0; i<structure.nrModels(); i++) {\n\t\t\tchainList.addAll(structure.getChains(i));\n\t\t}\n\t\treturn chainList;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Get the number of unique bonds in the strucutre.\n\t * @param allAtoms\n\t * @return the number of bonds\n\t */\n\tpublic static int getNumBonds(List<Atom> allAtoms) {\n\t\tint bondCount = 0;\n\t\tfor(int indexAtomOne=0;indexAtomOne<allAtoms.size();indexAtomOne++) {\n\t\t\tAtom atomOne = allAtoms.get(indexAtomOne);\n\t\t\tif(atomOne.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atomOne.getBonds()) {\n\t\t\t\tif(allAtoms.indexOf(bond.getOther(atomOne))>indexAtomOne){\n\t\t\t\t\tbondCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCount;\n\t}\t\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\t@SuppressWarnings(\"unused\")\n\t\tSecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNMENT\",getSecStructType(dsspIndex));\n\t}\n\n\n\tprivate static SecStrucType getSecStructType(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Function to get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getChainID();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.FileNotFoundException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ExperimentalTechnique;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.secstruc.DSSPParser;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucState;\nimport org.biojava.nbio.structure.secstruc.SecStrucType;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.mmtf.dataholders.DsspType;\nimport org.rcsb.mmtf.utils.CodecUtils;\n\n/**\n * A utils class of functions needed for Biojava to read and write to mmtf.\n * @author Anthony Bradley\n *\n */\npublic class MmtfUtils {\n\t/**\n\t * Set up the configuration parameters for BioJava.\n\t */\n\tpublic static AtomCache setUpBioJava() {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\tDownloadChemCompProvider cc = new DownloadChemCompProvider();\n\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\t/**\n\t * Set up the configuration parameters for BioJava. - with an extra URL\n\t */\n\tpublic static AtomCache setUpBioJava(String extraUrl) {\n\t\t// Set up the atom cache etc\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\tparams.setCreateAtomBonds(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setParseBioAssembly(true);\n\t\tparams.setUseInternalChainId(true);\n\t\t// MOVE INTO BIOJAVA IF NEED BE\n\t\t//\t\tCustomChemCompProvider cc = new CustomChemCompProvider();\n\t\t//\t\tChemCompGroupFactory.setChemCompProvider(cc);\n\t\t//\t\tcc.checkDoFirstInstall();\n\t\tcache.setFileParsingParams(params);\n\t\tStructureIO.setAtomCache(cache);\n\t\treturn cache;\n\t}\n\n\n\t/**\n\t * This sets all microheterogeneous groups \n\t * (previously alternate location groups) as separate groups.\n\t * This is required because mmtf groups cannot have multiple HET codes.\n\t * @param bioJavaStruct\n\t */\n\tpublic static void fixMicroheterogenity(Structure bioJavaStruct) {\n\t\t// Loop through the models\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\t// Then the chains\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\t// Build a new list of groups\n\t\t\t\tList<Group> outGroups = new ArrayList<>();\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tList<Group> removeList = new ArrayList<>();\n\t\t\t\t\tfor (Group altLoc : g.getAltLocs()) {\t  \n\t\t\t\t\t\t// Check if they are not equal -> microheterogenity\n\t\t\t\t\t\tif(! altLoc.getPDBName().equals(g.getPDBName())) {\n\t\t\t\t\t\t\t// Now add this group to the main list\n\t\t\t\t\t\t\tremoveList.add(altLoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Add this group\n\t\t\t\t\toutGroups.add(g);\n\t\t\t\t\t// Remove any microhet alt locs\n\t\t\t\t\tg.getAltLocs().removeAll(removeList);\n\t\t\t\t\t// Add these microhet alt locs\n\t\t\t\t\toutGroups.addAll(removeList);\n\t\t\t\t}\n\t\t\t\tc.setAtomGroups(outGroups);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Function to get all the atoms in the strucutre as a list.\n\t * @param bioJavaStruct the biojava structure\n\t * @return a list of all the unique atoms in the structure\n\t */\n\tpublic static List<Atom> getAllAtoms(Structure bioJavaStruct) {\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor (int i=0; i<bioJavaStruct.nrModels(); i++){\n\t\t\tList<Chain> chains = bioJavaStruct.getModel(i);\n\t\t\tfor (Chain c : chains) {\n\t\t\t\tfor (Group g : c.getAtomGroups()) {\n\t\t\t\t\tfor(Atom a: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(a);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\t/**\n\t * Function to get a list of atoms for a group. Only add each atom once.\n\t * @param inputGroup the Biojava Group to consider\n\t * @return the atoms for the input Biojava Group\n\t */\n\tpublic static List<Atom> getAtomsForGroup(Group inputGroup) {\n\t\tSet<Atom> uniqueAtoms = new HashSet<Atom>();\n\t\tList<Atom> theseAtoms = new ArrayList<Atom>();\n\t\tfor(Atom a: inputGroup.getAtoms()){\n\t\t\ttheseAtoms.add(a);\n\t\t\tuniqueAtoms.add(a);\n\t\t}\n\t\tList<Group> altLocs = inputGroup.getAltLocs();\n\t\tfor(Group thisG: altLocs){\n\t\t\tfor(Atom a: thisG.getAtoms()){\n\t\t\t\tif(uniqueAtoms.contains(a)){ \n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttheseAtoms.add(a);\n\t\t\t}\n\t\t}\n\t\treturn theseAtoms;\n\t}\n\n\n\t/**\n\t * Function to generate the secondary structure for a Biojava structure object.\n\t * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n\t */\n\tpublic static void calculateDsspSecondaryStructure(Structure bioJavaStruct) {\n\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\ttry{\n\t\t\tssp.calculate(bioJavaStruct, true);\n\t\t}\n\t\tcatch(StructureException e) {\n\t\t\ttry{\n\t\t\t\tDSSPParser.fetch(bioJavaStruct.getPDBCode(), bioJavaStruct, true); //download from PDB the DSSP result\n\t\t\t}\n\t\t\tcatch(FileNotFoundException enew){\n\t\t\t}\n\t\t\tcatch(Exception bige){\n\t\t\t\tSystem.out.println(bige);\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * Get the string representation of a space group.\n\t * @param spaceGroup the input SpaceGroup object\n\t * @return the space group as a string.\n\t */\n\tpublic static String getSpaceGroupAsString(SpaceGroup spaceGroup) {\n\t\tif(spaceGroup==null){\n\t\t\treturn \"NA\";\n\t\t}\n\t\telse{\n\t\t\treturn spaceGroup.getShortSymbol();\n\t\t}\n\t}\n\n\t/**\n\t * Get the length six array of the unit cell information.\n\t * @param xtalInfo the input PDBCrystallographicInfo object\n\t * @return the length six float array\n\t */\n\tpublic static float[] getUnitCellAsArray(PDBCrystallographicInfo xtalInfo) {\n\t\tCrystalCell xtalCell = xtalInfo.getCrystalCell();\n\t\tif(xtalCell==null){\n\t\t\treturn null;\n\t\t}else{\n\t\t\tfloat[] inputUnitCell = new float[6];\n\t\t\tinputUnitCell[0] = (float) xtalCell.getA();\n\t\t\tinputUnitCell[1] = (float) xtalCell.getB();\n\t\t\tinputUnitCell[2] = (float) xtalCell.getC();\n\t\t\tinputUnitCell[3] = (float) xtalCell.getAlpha();\n\t\t\tinputUnitCell[4] = (float) xtalCell.getBeta();\n\t\t\tinputUnitCell[5] = (float) xtalCell.getGamma();\n\t\t\treturn inputUnitCell;\n\t\t}\n\t}\n\n\t/**\n\t * Converts the set of experimental techniques to an array of strings.\n\t * @param experimentalTechniques the input set of experimental techniques\n\t * @return the array of strings describing the methods used.\n\t */\n\tpublic static String[] techniquesToStringArray(Set<ExperimentalTechnique> experimentalTechniques) {\n\t\tString[] outArray = new String[experimentalTechniques.size()];\n\t\tint index = 0;\n\t\tfor (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n\t\t\toutArray[index] = experimentalTechnique.getName();\n\t\t\tindex++;\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Covert a Date object to ISO time format.\n\t * @param inputDate The input date object\n\t * @return the time in ISO time format\n\t */\n\tpublic static String dateToIsoString(Date inputDate) {\n\t\tDateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\treturn dateStringFormat.format(inputDate);\n\t}\n\n\t/**\n\t * Convert a bioassembly information into a map of transform -> chainindices it relates to\n\t * @param bioassemblyInfo\n\t * @param chainIdToIndexMap \n\t * @return the bioassembly information (as primitive types).\n\t */\n\tpublic static Map<double[], int[]> getTransformMap(BioAssemblyInfo bioassemblyInfo, Map<String, Integer> chainIdToIndexMap) {\n\t\tMap<Matrix4d, List<Integer>> matMap = new HashMap<>();\n\t\tList<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n\t\tfor (BiologicalAssemblyTransformation transformation : transforms) {\n\t\t\tMatrix4d transMatrix = transformation.getTransformationMatrix();\n\t\t\tString transChainId = transformation.getChainId();\n\t\t\tif (!chainIdToIndexMap.containsKey(transChainId)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n\t\t\tif(matMap.containsKey(transMatrix)){\n\t\t\t\tmatMap.get(transMatrix).add(chainIndex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<Integer> chainIdList = new ArrayList<>();\n\t\t\t\tchainIdList.add(chainIndex);\n\t\t\t\tmatMap.put(transMatrix, chainIdList);\n\t\t\t}\n\t\t}\n\t\tMap<double[], int[]> outMap = new HashMap<>();\n\t\tfor (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n\t\t\toutMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n\t\t}\n\t\treturn outMap;\n\t}\n\n\t/**\n\t * Convert a four-d matrix to a double array. Row-packed.\n\t * @param transformationMatrix the input matrix4d object\n\t * @return the double array (16 long).\n\t */\n\tprivate static double[] convertToDoubleArray(Matrix4d transformationMatrix) {\n\t\t// Initialise the output array\n\t\tdouble[] outArray = new double[16];\n\t\t// Iterate over the matrix\n\t\tfor(int i=0; i<4; i++){\n\t\t\tfor(int j=0; j<4; j++){\n\t\t\t\t// Now set this element\n\t\t\t\toutArray[i*4+j] = transformationMatrix.getElement(i,j);\n\t\t\t}\n\t\t}\n\t\treturn outArray;\n\t}\n\n\t/**\n\t * Get a list of all the chains in a structure.\n\t * @param structure the input structure\n\t * @return the list of chains\n\t */\n\tpublic static List<Chain> getAllChains(Structure structure) {\n\t\tList<Chain> chainList = new ArrayList<>();\n\t\tfor (int i=0; i<structure.nrModels(); i++) {\n\t\t\tchainList.addAll(structure.getChains(i));\n\t\t}\n\t\treturn chainList;\n\t}\n\n\t/**\n\t * Count the total number of groups in the structure\n\t * @param structure the input structure\n\t * @return the total number of groups\n\t */\n\tpublic static int getNumGroups(Structure structure) {\n\t\tint count = 0;\n\t\tfor(int i=0; i<structure.nrModels(); i++) {\n\t\t\tfor(Chain chain : structure.getChains(i)){\n\t\t\t\tcount+= chain.getAtomGroups().size();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t/**\n\t * Get the number of unique bonds in the strucutre.\n\t * @param allAtoms\n\t * @return the number of bonds\n\t */\n\tpublic static int getNumBonds(List<Atom> allAtoms) {\n\t\tint bondCount = 0;\n\t\tfor(int indexAtomOne=0;indexAtomOne<allAtoms.size();indexAtomOne++) {\n\t\t\tAtom atomOne = allAtoms.get(indexAtomOne);\n\t\t\tif(atomOne.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atomOne.getBonds()) {\n\t\t\t\tif(allAtoms.indexOf(bond.getOther(atomOne))>indexAtomOne){\n\t\t\t\t\tbondCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCount;\n\t}\t\n\n\t/**\n\t * Find the number of bonds in a group\n\t * @param atomsInGroup the list of atoms in the group\n\t * @return the number of atoms in the group\n\t */\n\tpublic static int getNumBondsInGroup(List<Atom> atomsInGroup) {\n\t\tint bondCounter = 0;\n\t\tfor(Atom atom : atomsInGroup) { \n\t\t\tif(atom.getBonds()==null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t\t// Now set the bonding information.\n\t\t\t\tAtom other = bond.getOther(atom);\n\t\t\t\t// If both atoms are in the group\n\t\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tif (firstBondIndex<secondBondIndex){\n\t\t\t\t\t\tbondCounter++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn bondCounter;\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @return the integer index of the group type.\n\t */\n\tpublic static int getSecStructType(Group group) {\n\t\tSecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n\t\tif(props==null){\n\t\t\treturn DsspType.NULL_ENTRY.getDsspIndex();\n\t\t}\n\t\treturn DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n\t}\n\n\t/**\n\t * Get the secondary structure as defined by DSSP.\n\t * @param group the input group to be calculated\n\t * @param the integer index of the group type.\n\t */\n\tpublic static void setSecStructType(Group group, int dsspIndex) {\n\t\t@SuppressWarnings(\"unused\")\n\t\tSecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNMENT\",getSecStructType(dsspIndex));\n\t}\n\n\n\tprivate static SecStrucType getSecStructType(int dsspIndex) {\n\t\tString dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n\t\tfor(SecStrucType secStrucType : SecStrucType.values())\n\t\t{\n\t\t\tif(dsspType==secStrucType.name)\n\t\t\t{\n\t\t\t\treturn secStrucType;\n\t\t\t}\n\t\t}\n\t\t// Return a null entry.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Function to get summary information for the structure.\n\t * @param structure the structure for which to get the information.\n\t */\n\tpublic static MmtfSummaryDataBean getStructureInfo(Structure structure) {\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n\t\t// Get all the atoms\n\t\tList<Atom> theseAtoms = new ArrayList<>();\n\t\tList<Chain> allChains = new ArrayList<>();\n\t\tMap<String, Integer> chainIdToIndexMap = new HashMap<>();\n\t\tint chainCounter = 0;\n\t\tint bondCount = 0;\n\t\tmmtfSummaryDataBean.setAllAtoms(theseAtoms);\n\t\tmmtfSummaryDataBean.setAllChains(allChains);\n\t\tmmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n\t\tfor (int i=0; i<structure.nrModels(); i++){\n\t\t\tList<Chain> chains = structure.getModel(i);\n\t\t\tallChains.addAll(chains);\n\t\t\tfor (Chain chain : chains) {\n\t\t\t\tString idOne = chain.getChainID();\n\t\t\t\tif (!chainIdToIndexMap.containsKey(idOne)) { \n\t\t\t\t\tchainIdToIndexMap.put(idOne, chainCounter);\n\t\t\t\t}\n\t\t\t\tchainCounter++;\n\t\t\t\tfor (Group g : chain.getAtomGroups()) {\n\t\t\t\t\tfor(Atom atom: getAtomsForGroup(g)){\n\t\t\t\t\t\ttheseAtoms.add(atom);\t\t\n\t\t\t\t\t\t// If both atoms are in the group\n\t\t\t\t\t\tif (atom.getBonds()!=null){\n\t\t\t\t\t\t\tbondCount+=atom.getBonds().size();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Assumes all bonds are referenced twice\n\t\tmmtfSummaryDataBean.setNumBonds(bondCount/2);\n\t\treturn mmtfSummaryDataBean;\n\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.io.mmtf;\n\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.io.mmtf.MmtfUtils;\n\n/**\n * Test the MMTF utils class\n * @author Anthony Bradley\n *\n */\npublic class TestMmtfUtils {\n\t\n\t/**\n\t * Integration test to see that the microheterogenity is being dealt with correctly.\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void microHeterogenity() throws IOException, StructureException {\n\t\tMmtfUtils.setUpBioJava();\n\t\tStructure inputStructure = StructureIO.getStructure(\"4ck4\");\n\t\t// Count the number of groups\n\t\tGroup before = inputStructure.getChains().get(0).getAtomGroup(17);\n\t\tassertTrue(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t    List<Atom> totalAtoms = new ArrayList<>(MmtfUtils.getAllAtoms(inputStructure));\n\t\tint totGroups = 0;\n\t\tint totAtomsCounter = 0;\n\t\tSet<Atom> totAtoms = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroups += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounter+=g.getAtoms().size();\n\t\t\t\ttotAtoms.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsCounter+=alt.getAtoms().size();\n\t\t\t\t\ttotAtoms.addAll(alt.getAtoms());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Now \"fix\" the microheterogenity\n\t\tMmtfUtils.fixMicroheterogenity(inputStructure);\n\t\tassertEquals(before, inputStructure.getChains().get(0).getAtomGroup(17));\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n\t\tassertFalse(inputStructure.getChains().get(0).getAtomGroup(18).hasAltLoc());\n\t\tint totGroupsAfter = 0;\n\t\tint totAtomsCounterAfter = 0;\n\t\tSet<Atom> totAtomsAfter = new HashSet<>();\n\t\tfor (Chain c : inputStructure.getChains()) {\n\t\t\ttotGroupsAfter += c.getAtomGroups().size();\n\t\t\tfor (Group g: c.getAtomGroups() ){\n\t\t\t\ttotAtomsCounterAfter+=g.getAtoms().size();\n\t\t\t\ttotAtomsAfter.addAll(g.getAtoms());\n\t\t\t\tfor (Group alt : g.getAltLocs()) {\n\t\t\t\t\ttotAtomsAfter.addAll(alt.getAtoms());\n\t\t\t\t\ttotAtomsCounterAfter+=alt.getAtoms().size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Find the atoms after the fix.\n\t    List<Atom> totalAtomsAfter = new ArrayList<>(MmtfUtils.getAllAtoms(inputStructure));\n\t\t// Get all of the duplicate atoms\n\t\tSet<Atom> duplicates = findDuplicates(totalAtomsAfter);\n\t\tfor (Atom a : duplicates) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\t// There should be no duplicates\n\t\tassertEquals(duplicates.size(), 0);\n\t    assertEquals(totalAtoms.size(), totalAtomsAfter.size());\n\t\t// Check there are two more groups afterwards\n\t\tassertEquals(totGroupsAfter-2, totGroups);\n\t\t// Check there are no more atoms afterwards\n\t\tassertEquals(totAtomsAfter.size(), totAtoms.size());\n\t\t// Check the counter are the same too\n\t\tassertEquals(totAtomsCounterAfter, totAtomsCounter);\n\t\t\n\t}\n\t\n\t\n//TODO ADD TESTS FOR THESE FUNCTIONS\n//\tgetAllAtoms\n//\t\n//\tgetAtomsForGroup\n//\t\n//\tcalculateDsspSecondaryStructure\n//\t\n//\tsetHeaderInfo\n//\t\n//\tgenerateSerializableBioAssembly\n//\n//\tgetChainIdToIndexMap\n\t\n\tprivate Set<Atom> findDuplicates(List<Atom> listContainingDuplicates)\n\t{ \n\t  final Set<Atom> setToReturn = new HashSet<>(); \n\t  final Set<Atom> set1 = new HashSet<>();\n\n\t  for (Atom yourInt : listContainingDuplicates)\n\t  {\n\t   if (!set1.add(yourInt))\n\t   {\n\t    setToReturn.add(yourInt);\n\t   }\n\t  }\n\t  return setToReturn;\n\t}\n}\n\n","changedTest":"","commitMessage":"Updates to the utils to download chemcomp all at once\n","test_commitMessage":"","allZero":false}