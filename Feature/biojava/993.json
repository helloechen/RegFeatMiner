{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/util/MultipleAlignmentWriter.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/util/TestMultipleAlignmentWriter.java","prod_time":"2021-08-01 06:07:16","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"5f007ec36694513380ae0721187b95e2e001405b","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.util.PrettyXMLWriter;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.xml.MultipleAlignmentXMLConverter;\n\n/**\n * This class contains functions for the conversion of {@link MultipleAlignment}\n * to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues, Transformation Matrices,\n * XML, 3D format.\n *\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence alignment\n\t * String in FASTA format.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\n\t\t// Get the alignment sequences\n\t\tList<String> alnSequences = MultipleAlignmentTools\n\t\t\t\t.getSequenceAlignment(alignment);\n\n\t\tString fasta = \"\";\n\t\tfor (int st = 0; st < alignment.size(); st++) {\n\t\t\t// Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\" + alignment.getEnsemble().getStructureIdentifiers().get(st).getIdentifier()\n\t\t\t\t\t+ \"\\n\" + alnSequences.get(st) + \"\\n\";\n\t\t}\n\t\treturn fasta;\n\t}\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format.\n\t * Includes summary information about the alignment in the top and a\n\t * multiple sequence alignment at the bottom.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\n\t\t// Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString() + \"\\n\\n\");\n\n\t\t// Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools\n\t\t\t\t.getSequenceAlignment(alignment, mapSeqToStruct);\n\n\t\t// Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos = 0; pos < alnSequences.get(0).length(); pos++) {\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(\n\t\t\t\t\talignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) {\n\t\t\t\tblockNumbers = blockNumbers.concat(String.valueOf(blockNr + 1));\n\t\t\t} else\n\t\t\t\tblockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\n\t\t// Write the Sequence Alignment\n\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\tif (str < 9) {\n\t\t\t\tfatcat.append(\"Chain 0\" + (str + 1) + \": \"\n\t\t\t\t\t\t+ alnSequences.get(str) + \"\\n\");\n\t\t\t} else {\n\t\t\t\tfatcat.append(\"Chain \" + (str + 1) + \": \"\n\t\t\t\t\t\t+ alnSequences.get(str) + \"\\n\");\n\t\t\t}\n\t\t\tif (str != alignment.size() - 1) {\n\t\t\t\tfatcat.append(\"          \" + blockNumbers + \"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of aligned\n\t * residues. Format is one line per residue group, tab delimited:\n\t * <ul>\n\t * <li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)</li>\n\t * </ul>\n\t * Example: <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>\n\t * Note that this format loses information about blocks.\n\t *\n\t * @param multAln\n\t *            MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t// Write structure names & PDB codes\n\t\tfor (int str = 0; str < multAln.size(); str++) {\n\t\t\tresidueGroup.append(\"#Struct\" + (str + 1) + \":\\t\");\n\t\t\tresidueGroup.append(multAln.getEnsemble().getStructureIdentifiers()\n\t\t\t\t\t.get(str).getIdentifier());\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t// Whrite header for columns\n\t\tfor (int str = 0; str < multAln.size(); str++)\n\t\t\tresidueGroup.append(\"#Num\" + (str + 1) + \"\\tChain\" + (str + 1)\n\t\t\t\t\t+ \"\\tAA\" + (str + 1) + \"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\n\t\t// Write optimally aligned pairs\n\t\tfor (Block b : multAln.getBlocks()) {\n\t\t\tfor (int res = 0; res < b.length(); res++) {\n\t\t\t\tfor (int str = 0; str < multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getAtomArrays().get(str)[residue];\n\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getResidueNumber()\n\t\t\t\t\t\t\t\t.toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getChain()\n\t\t\t\t// ABradley - I'm assuming Auth Id's here 04/05/16\n\t\t\t\t\t\t\t\t.getName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String\n\t * output.\n\t *\n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++) {\n\n\t\t\tList<Matrix4d> btransforms = alignment.getBlockSet(bs)\n\t\t\t\t\t.getTransformations();\n\t\t\tif (btransforms == null || btransforms.size() < 1)\n\t\t\t\tcontinue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \");\n\t\t\t\ttxt.append(bs + 1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\n\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\tString origString = \"ref\";\n\n\t\t\t\ttxt.append(String.format(\"     X\"+(str+1)+ \" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Y\"+(str+1)+\" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(\"     Z\"+(str+1)+\" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n\n\t/**\n\t * Converts all the information of a multiple alignment ensemble into an XML\n\t * String format. Cached variables, like transformation matrices and scores,\n\t * are also converted.\n\t *\n\t * @param ensemble\n\t *            the MultipleAlignmentEnsemble to convert.\n\t * @return String XML representation of the ensemble\n\t * @throws IOException\n\t * @see MultipleAlignmentXMLConverter Helper methods for XML conversion\n\t */\n\tpublic static String toXML(MultipleAlignmentEnsemble ensemble)\n\t\t\tthrows IOException {\n\n\t\tStringWriter result = new StringWriter();\n\t\tPrintWriter writer = new PrintWriter(result);\n\t\tPrettyXMLWriter xml = new PrettyXMLWriter(writer);\n\n\t\tMultipleAlignmentXMLConverter.printXMLensemble(xml, ensemble);\n\n\t\twriter.close();\n\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Outputs a pairwise alignment in I-TASSER's 3D Format for target-template\n\t * alignment. http://zhanglab.ccmb.med.umich.edu/I-TASSER/option4.html\n\t *\n\t * <p>\n\t * The format is closely related to a standard PDB file, but contains only\n\t * CA atoms and adds two columns for specifying the alignment:\n\t *\n\t * <pre>\n\t * ATOM   2001  CA  MET     1      41.116 -30.727   6.866  129 THR\n\t * ATOM   2002  CA  ALA     2      39.261 -27.408   6.496  130 ARG\n\t * ATOM   2003  CA  ALA     3      35.665 -27.370   7.726  131 THR\n\t * ATOM   2004  CA  ARG     4      32.662 -25.111   7.172  132 ARG\n\t * ATOM   2005  CA  GLY     5      29.121 -25.194   8.602  133 ARG\n\t *\n\t * Column 1 -30: Atom & Residue records of query sequence.\n\t * Column 31-54: Coordinates of atoms in query copied from corresponding atoms in template.\n\t * Column 55-59: Corresponding residue number in template based on alignment\n\t * Column 60-64: Corresponding residue name in template\n\t * </pre>\n\t *\n\t * <p>\n\t * Note that the output is a pairwise alignment. Only the first and second\n\t * rows in the MultipleAlignment will be used, others ignored.\n\t *\n\t * <p>\n\t * This method supports topology-independent alignments. The output will\n\t * have sequence order matching the query, but include atoms from the\n\t * template.\n\t *\n\t * @param alignment\n\t *            A <em>full</em> multiple alignment between proteins\n\t * @param queryIndex\n\t *            index of the query within the multiple alignment\n\t * @param templateIndex\n\t *            index of the template within the multiple alignment\n\t * @return The file contents as a string\n\t * @throws StructureException If an error occurs parsing the alignment's structure names\n\t */\n\tpublic static String to3DFormat(MultipleAlignment alignment,\n\t\t\tint queryIndex, int templateIndex) throws StructureException {\n\t\tList<Atom[]> atomArrays = alignment.getEnsemble().getAtomArrays();\n\t\tAtom[] queryAtoms = atomArrays.get(queryIndex);\n\t\tAtom[] templateAtoms = atomArrays.get(templateIndex);\n\n\t\tList<Block> blocks = alignment.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, queryIndex);\n\n\t\tStringBuilder str = new StringBuilder();\n\n\t\t// Gather info about the template structure\n\t\tStructureIdentifier tName = alignment.getEnsemble().getStructureIdentifiers()\n\t\t\t\t.get(templateIndex);\n\t\tSubstructureIdentifier canon = tName.toCanonical();\n\t\tString tPdbId = canon.getPdbId();\n\t\tString tChain = null;\n\t\tfor(ResidueRange range : canon.getResidueRanges()) {\n\t\t\ttChain = range.getChainName();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tChain == null) {\n\t\t\t// Use the chain of the first template block\n\t\t\tfor (Integer i : blocks.get(0).getAlignRes().get(templateIndex)) {\n\t\t\t\tif (i != null) {\n\t\t\t\t\ttChain = templateAtoms[i].getGroup().getChainId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr.append(String\n\t\t\t\t.format(\"REMARK Template name:%s:%s\\n\", tPdbId, tChain));\n\t\tfor (Block block : blocks) {\n\t\t\tList<Integer> qAlign = block.getAlignRes().get(queryIndex);\n\t\t\tList<Integer> tAlign = block.getAlignRes().get(templateIndex);\n\t\t\tfor (int i = 0; i < block.length(); i++) {\n\t\t\t\tInteger qRes = qAlign.get(i);\n\t\t\t\tInteger tRes = tAlign.get(i);\n\n\t\t\t\t// skip gaps\n\t\t\t\tif (qRes == null || tRes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get PDB-format ATOM records\n\t\t\t\tString qPDB = queryAtoms[qRes].toPDB();\n\t\t\t\tString tPDB = templateAtoms[tRes].toPDB();\n\n\t\t\t\t// merge the two records into 3D format\n\t\t\t\tstr.append(qPDB.substring(0, 30)); // up through coordinates\n\t\t\t\tstr.append(tPDB.substring(30, 54)); // coordinates\n\t\t\t\tstr.append(tPDB.substring(22, 27)); // residue number\n\t\t\t\tstr.append(' ');\n\t\t\t\tstr.append(tPDB.substring(17, 20));\n\t\t\t\tstr.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn str.toString();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Locale;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.core.util.PrettyXMLWriter;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.ResidueRange;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.xml.MultipleAlignmentXMLConverter;\n\n/**\n * This class contains functions for the conversion of {@link MultipleAlignment}\n * to various String outputs.\n * <p>\n * Supported formats: FASTA, FatCat, Aligned Residues, Transformation Matrices,\n * XML, 3D format.\n *\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentWriter {\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a multiple sequence alignment\n\t * String in FASTA format.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFASTA(MultipleAlignment alignment) {\n\n\t\t// Get the alignment sequences\n\t\tList<String> alnSequences = MultipleAlignmentTools\n\t\t\t\t.getSequenceAlignment(alignment);\n\n\t\tString fasta = \"\";\n\t\tfor (int st = 0; st < alignment.size(); st++) {\n\t\t\t// Add the structure identifier as the head of the FASTA\n\t\t\tfasta += \">\" + alignment.getEnsemble().getStructureIdentifiers().get(st).getIdentifier()\n\t\t\t\t\t+ \"\\n\" + alnSequences.get(st) + \"\\n\";\n\t\t}\n\t\treturn fasta;\n\t}\n\n\t/**\n\t * Converts the {@link MultipleAlignment} into a FatCat String format.\n\t * Includes summary information about the alignment in the top and a\n\t * multiple sequence alignment at the bottom.\n\t *\n\t * @param alignment\n\t *            MultipleAlignment\n\t * @return String multiple sequence alignment in FASTA format\n\t * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n\t */\n\tpublic static String toFatCat(MultipleAlignment alignment) {\n\n\t\t// Initialize the String and put the summary information\n\t\tStringWriter fatcat = new StringWriter();\n\t\tfatcat.append(alignment.toString() + \"\\n\\n\");\n\n\t\t// Get the alignment sequences and the mapping\n\t\tList<Integer> mapSeqToStruct = new ArrayList<Integer>();\n\t\tList<String> alnSequences = MultipleAlignmentTools\n\t\t\t\t.getSequenceAlignment(alignment, mapSeqToStruct);\n\n\t\t// Get the String of the Block Numbers for Position\n\t\tString blockNumbers = \"\";\n\t\tfor (int pos = 0; pos < alnSequences.get(0).length(); pos++) {\n\t\t\tint blockNr = MultipleAlignmentTools.getBlockForSequencePosition(\n\t\t\t\t\talignment, mapSeqToStruct, pos);\n\t\t\tif (blockNr != -1) {\n\t\t\t\tblockNumbers = blockNumbers.concat(String.valueOf(blockNr + 1));\n\t\t\t} else\n\t\t\t\tblockNumbers = blockNumbers.concat(\" \");\n\t\t}\n\n\t\t// Write the Sequence Alignment\n\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\tif (str < 9) {\n\t\t\t\tfatcat.append(\"Chain 0\" + (str + 1) + \": \"\n\t\t\t\t\t\t+ alnSequences.get(str) + \"\\n\");\n\t\t\t} else {\n\t\t\t\tfatcat.append(\"Chain \" + (str + 1) + \": \"\n\t\t\t\t\t\t+ alnSequences.get(str) + \"\\n\");\n\t\t\t}\n\t\t\tif (str != alignment.size() - 1) {\n\t\t\t\tfatcat.append(\"          \" + blockNumbers + \"\\n\");\n\t\t\t}\n\t\t}\n\t\treturn fatcat.toString();\n\t}\n\n\t/**\n\t * Converts the alignment to its simplest form: a list of groups of aligned\n\t * residues. Format is one line per residue group, tab delimited:\n\t * <ul>\n\t * <li>PDB number (includes insertion code)\n\t * <li>Chain\n\t * <li>Amino Acid (three letter code)</li>\n\t * </ul>\n\t * Example: <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n\t * <p>\n\t * Note that this format loses information about blocks.\n\t *\n\t * @param multAln\n\t *            MultipleAlignment object\n\t * @return a String representation of the aligned residues.\n\t */\n\tpublic static String toAlignedResidues(MultipleAlignment multAln) {\n\t\tStringWriter residueGroup = new StringWriter();\n\n\t\t// Write structure names & PDB codes\n\t\tfor (int str = 0; str < multAln.size(); str++) {\n\t\t\tresidueGroup.append(\"#Struct\" + (str + 1) + \":\\t\");\n\t\t\tresidueGroup.append(multAln.getEnsemble().getStructureIdentifiers()\n\t\t\t\t\t.get(str).getIdentifier());\n\t\t\tresidueGroup.append(\"\\n\");\n\t\t}\n\t\t// Whrite header for columns\n\t\tfor (int str = 0; str < multAln.size(); str++)\n\t\t\tresidueGroup.append(\"#Num\" + (str + 1) + \"\\tChain\" + (str + 1)\n\t\t\t\t\t+ \"\\tAA\" + (str + 1) + \"\\t\");\n\t\tresidueGroup.append(\"\\n\");\n\n\t\t// Write optimally aligned pairs\n\t\tfor (Block b : multAln.getBlocks()) {\n\t\t\tfor (int res = 0; res < b.length(); res++) {\n\t\t\t\tfor (int str = 0; str < multAln.size(); str++) {\n\t\t\t\t\tInteger residue = b.getAlignRes().get(str).get(res);\n\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(\"-\");\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAtom atom = multAln.getAtomArrays().get(str)[residue];\n\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getResidueNumber()\n\t\t\t\t\t\t\t\t.toString());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getChain()\n\t\t\t\t// ABradley - I'm assuming Auth Id's here 04/05/16\n\t\t\t\t\t\t\t\t.getName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t\tresidueGroup.append(atom.getGroup().getPDBName());\n\t\t\t\t\t\tresidueGroup.append('\\t');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresidueGroup.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn residueGroup.toString();\n\t}\n\n\t/**\n\t * Converts the transformation Matrices of the alignment into a String\n\t * output.\n\t *\n\t * @param afpChain\n\t * @return String transformation Matrices\n\t */\n\tpublic static String toTransformMatrices(MultipleAlignment alignment) {\n\n\t\tStringBuffer txt = new StringBuffer();\n\n\t\tfor (int bs = 0; bs < alignment.getBlockSets().size(); bs++) {\n\n\t\t\tList<Matrix4d> btransforms = alignment.getBlockSet(bs)\n\t\t\t\t\t.getTransformations();\n\t\t\tif (btransforms == null || btransforms.size() < 1)\n\t\t\t\tcontinue;\n\n\t\t\tif (alignment.getBlockSets().size() > 1) {\n\t\t\t\ttxt.append(\"Operations for block \");\n\t\t\t\ttxt.append(bs + 1);\n\t\t\t\ttxt.append(\"\\n\");\n\t\t\t}\n\n\t\t\tfor (int str = 0; str < alignment.size(); str++) {\n\t\t\t\tString origString = \"ref\";\n\n\t\t\t\ttxt.append(String.format(Locale.US, \"     X\"+(str+1)+ \" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(0,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(Locale.US, \"     Y\"+(str+1)+\" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(1,3)));\n\t\t\t\ttxt.append( \"\\n\");\n\t\t\t\ttxt.append(String.format(Locale.US, \"     Z\"+(str+1)+\" = (%9.6f)*X\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Y\"+\n\t\t\t\t\t\torigString +\" + (%9.6f)*Z\"+\n\t\t\t\t\t\torigString +\" + (%12.6f)\",\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,0),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,1),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,2),\n\t\t\t\t\t\tbtransforms.get(str).getElement(2,3)));\n\t\t\t\ttxt.append(\"\\n\\n\");\n\t\t\t}\n\t\t}\n\t\treturn txt.toString();\n\t}\n\n\t/**\n\t * Converts all the information of a multiple alignment ensemble into an XML\n\t * String format. Cached variables, like transformation matrices and scores,\n\t * are also converted.\n\t *\n\t * @param ensemble\n\t *            the MultipleAlignmentEnsemble to convert.\n\t * @return String XML representation of the ensemble\n\t * @throws IOException\n\t * @see MultipleAlignmentXMLConverter Helper methods for XML conversion\n\t */\n\tpublic static String toXML(MultipleAlignmentEnsemble ensemble)\n\t\t\tthrows IOException {\n\n\t\tStringWriter result = new StringWriter();\n\t\tPrintWriter writer = new PrintWriter(result);\n\t\tPrettyXMLWriter xml = new PrettyXMLWriter(writer);\n\n\t\tMultipleAlignmentXMLConverter.printXMLensemble(xml, ensemble);\n\n\t\twriter.close();\n\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Outputs a pairwise alignment in I-TASSER's 3D Format for target-template\n\t * alignment. http://zhanglab.ccmb.med.umich.edu/I-TASSER/option4.html\n\t *\n\t * <p>\n\t * The format is closely related to a standard PDB file, but contains only\n\t * CA atoms and adds two columns for specifying the alignment:\n\t *\n\t * <pre>\n\t * ATOM   2001  CA  MET     1      41.116 -30.727   6.866  129 THR\n\t * ATOM   2002  CA  ALA     2      39.261 -27.408   6.496  130 ARG\n\t * ATOM   2003  CA  ALA     3      35.665 -27.370   7.726  131 THR\n\t * ATOM   2004  CA  ARG     4      32.662 -25.111   7.172  132 ARG\n\t * ATOM   2005  CA  GLY     5      29.121 -25.194   8.602  133 ARG\n\t *\n\t * Column 1 -30: Atom & Residue records of query sequence.\n\t * Column 31-54: Coordinates of atoms in query copied from corresponding atoms in template.\n\t * Column 55-59: Corresponding residue number in template based on alignment\n\t * Column 60-64: Corresponding residue name in template\n\t * </pre>\n\t *\n\t * <p>\n\t * Note that the output is a pairwise alignment. Only the first and second\n\t * rows in the MultipleAlignment will be used, others ignored.\n\t *\n\t * <p>\n\t * This method supports topology-independent alignments. The output will\n\t * have sequence order matching the query, but include atoms from the\n\t * template.\n\t *\n\t * @param alignment\n\t *            A <em>full</em> multiple alignment between proteins\n\t * @param queryIndex\n\t *            index of the query within the multiple alignment\n\t * @param templateIndex\n\t *            index of the template within the multiple alignment\n\t * @return The file contents as a string\n\t * @throws StructureException If an error occurs parsing the alignment's structure names\n\t */\n\tpublic static String to3DFormat(MultipleAlignment alignment,\n\t\t\tint queryIndex, int templateIndex) throws StructureException {\n\t\tList<Atom[]> atomArrays = alignment.getEnsemble().getAtomArrays();\n\t\tAtom[] queryAtoms = atomArrays.get(queryIndex);\n\t\tAtom[] templateAtoms = atomArrays.get(templateIndex);\n\n\t\tList<Block> blocks = alignment.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, queryIndex);\n\n\t\tStringBuilder str = new StringBuilder();\n\n\t\t// Gather info about the template structure\n\t\tStructureIdentifier tName = alignment.getEnsemble().getStructureIdentifiers()\n\t\t\t\t.get(templateIndex);\n\t\tSubstructureIdentifier canon = tName.toCanonical();\n\t\tString tPdbId = canon.getPdbId();\n\t\tString tChain = null;\n\t\tfor(ResidueRange range : canon.getResidueRanges()) {\n\t\t\ttChain = range.getChainName();\n\t\t\tbreak;\n\t\t}\n\n\t\tif (tChain == null) {\n\t\t\t// Use the chain of the first template block\n\t\t\tfor (Integer i : blocks.get(0).getAlignRes().get(templateIndex)) {\n\t\t\t\tif (i != null) {\n\t\t\t\t\ttChain = templateAtoms[i].getGroup().getChainId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstr.append(String\n\t\t\t\t.format(\"REMARK Template name:%s:%s\\n\", tPdbId, tChain));\n\t\tfor (Block block : blocks) {\n\t\t\tList<Integer> qAlign = block.getAlignRes().get(queryIndex);\n\t\t\tList<Integer> tAlign = block.getAlignRes().get(templateIndex);\n\t\t\tfor (int i = 0; i < block.length(); i++) {\n\t\t\t\tInteger qRes = qAlign.get(i);\n\t\t\t\tInteger tRes = tAlign.get(i);\n\n\t\t\t\t// skip gaps\n\t\t\t\tif (qRes == null || tRes == null)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Get PDB-format ATOM records\n\t\t\t\tString qPDB = queryAtoms[qRes].toPDB();\n\t\t\t\tString tPDB = templateAtoms[tRes].toPDB();\n\n\t\t\t\t// merge the two records into 3D format\n\t\t\t\tstr.append(qPDB.substring(0, 30)); // up through coordinates\n\t\t\t\tstr.append(tPDB.substring(30, 54)); // coordinates\n\t\t\t\tstr.append(tPDB.substring(22, 27)); // residue number\n\t\t\t\tstr.append(' ');\n\t\t\t\tstr.append(tPDB.substring(17, 20));\n\t\t\t\tstr.append('\\n');\n\t\t\t}\n\t\t}\n\t\treturn str.toString();\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.multiple.util;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.TestSampleGenerator;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentWriter;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of various Text outputs for {@link MultipleAlignment}s.\n * <p>\n * Currently tested:\n * <ul>\n * <li>FASTA\n * <li>FatCat format\n * <li>Aligned Residues\n * </ul>\n *\n * @author Aleix Lafita\n *\n */\npublic class TestMultipleAlignmentWriter {\n\n\tprivate MultipleAlignment alignment1;\n\tprivate MultipleAlignment alignment2;\n\n\t/**\n\t * Build the alignments in common for every writer output, so that they do\n\t * not have to be created each time.\n\t *\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic TestMultipleAlignmentWriter() throws StructureException, IOException {\n\n\t\talignment1 = TestSampleGenerator.testAlignment1();\n\t\talignment2 = TestSampleGenerator.testAlignment2();\n\t}\n\n\t@Test\n\tpublic void testFASTA1() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment1);\n\n\t\tFileReader file = new FileReader(\"src/test/resources/testMSTA1.fasta\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n\t@Test\n\tpublic void testFASTA2() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toFASTA(alignment2);\n\n\t\tFileReader file = new FileReader(\"src/test/resources/testMSTA2.fasta\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n\t@Test\n\tpublic void testFatCat1() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment1);\n\n\t\tFileReader file = new FileReader(\"src/test/resources/testMSTA1.fatcat\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n\t@Test\n\tpublic void testFatCat2() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toFatCat(alignment2);\n\n\t\tFileReader file = new FileReader(\"src/test/resources/testMSTA2.fatcat\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n\t@Test\n\tpublic void testAlignedResidues1() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment1);\n\n\t\tFileReader file = new FileReader(\n\t\t\t\t\"src/test/resources/testMSTA1_alnres.tsv\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n\t@Test\n\tpublic void testAlignedResidues2() throws IOException {\n\n\t\tString result = MultipleAlignmentWriter.toAlignedResidues(alignment2);\n\n\t\tFileReader file = new FileReader(\n\t\t\t\t\"src/test/resources/testMSTA2_alnres.tsv\");\n\t\tBufferedReader reader = new BufferedReader(file);\n\t\tString line = null;\n\t\tStringBuilder stringBuilder = new StringBuilder();\n\n\t\twhile ((line = reader.readLine()) != null) {\n\t\t\tstringBuilder.append(line);\n\t\t\tstringBuilder.append(\"\\n\");\n\t\t}\n\t\treader.close();\n\n\t\tString expected = stringBuilder.toString();\n\t\tassertEquals(expected, result);\n\t}\n\n}\n","changedTest":"","commitMessage":"Force US Locale for floats.\n\n#918 showed that locales which use commas for floating-point numbers\ncan cause problems with output formats. This commit fixes a number\nof other cases.\n\n- Force Locale.US when outputting floats to files/streams\n- Usually don't force Locale.US when outputting floats to standard out &\n  logging (would lead to more consistent logs but breaks localization)\n- Replace some `println(String.format(` calls with Java 5 `printf`","test_commitMessage":"","allZero":false}