{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/location/InsdcParser.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/location/InsdcParserTest.java","prod_time":"2023-05-21 23:40:41","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"86307e962b30dc805cf3b1476133985120600037","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.location;\n\nimport org.biojava.nbio.core.exceptions.ParserException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.location.template.AbstractLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.location.template.Point;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Parser for working with INSDC style locations. This class supports the\n * full range of location types generated by Genbank, INSDC and ENA.\n *\n * @author ayates\n * @author jgrzebyta\n * @author Paolo Pavan\n */\npublic class InsdcParser {\n\n\tprivate boolean isSequenceCircular;\n\tprivate long sequenceLength;\n\n\tprivate final DataSource dataSource;\n\n\t\t/**\n\t * parse a location. if group(1) is null than the feature is on the positive\n\t * strand, group(2) start position, group(3) end position.\n\t */\n\tprotected static final Pattern singleLocationPattern = Pattern.compile(\"(?:([A-Za-z\\\\.0-9_]*?):)?(<?)(\\\\d+)(\\\\.{2}|\\\\^)?(>?)(\\\\d+)?(>?)?\");\n\t/**\n\t * Decodes a split pattern. Split patterns are a composition of multiple\n\t * locationsString qualified by actions: join(location,location, ...\n\t * location): The indicated elements should be joined (placed end-to-end) to\n\t * form one contiguous sequence. order(location,location, ... location): The\n\t * elements can be found in the specified order (5' to 3' direction),\n\t * nothing is implied about their reasonableness\n\t * bond(location,location...location): Found in protein files. These\n\t * generally are used to describe disulfide bonds.\n\t * complement(location,location...location): consider locations in their\n\t * complement versus\n\t *\n\t * takes in input a comma split location string. The split must be done\n\t * for outer level commas group(1) is the qualifier group(2) is the location\n\t * string to getFeatures. In case of complex splits it will contain the\n\t * nested expression\n\t *\n\t * Not really sure that they are not declared obsolete but they are still in\n\t * several files.\n\t */\n\tprotected static final Pattern genbankSplitPattern = Pattern.compile(\"^\\\\s?(join|order|bond|complement|)\\\\(?([\\\\s\\\\S]+)\\\\)?\");\n\t/**\n\t * designed to recursively split a location string in tokens. Valid tokens\n\t * are those divided by coma that are not inside a bracket. I. e. split on\n\t * the comma only if that comma has zero, or an even number of quotes ahead\n\t * of it.\n\t */\n\tprotected static final String locationSplitPattern = \",(?=([^\\\\(|\\\\)]+\\\\([^\\\\(|\\\\)]+\\\\))[^\\\\(|\\\\)]+)\";\n\t/**\n\t * these variables are used to compute the global start and end of complex\n\t * features\n\t */\n\tprotected Integer featureGlobalStart, featureGlobalEnd;\n\n\tenum complexFeaturesAppendEnum {\n\n\t\tFLATTEN, HIERARCHICAL;\n\t}\n\t/**\n\t * define the mode in which complex features should be appended in FLATTEN\n\t * mode their will be appended to a single feature in HIERARCHICAL mode, the\n\t * single mother feature will have a tree of features that will reflect the\n\t * construction in genbank file\n\t */\n\tprivate complexFeaturesAppendEnum complexFeaturesAppendMode = complexFeaturesAppendEnum.HIERARCHICAL;\n\n\tpublic void setComplexFeaturesAppendMode(complexFeaturesAppendEnum complexFeaturesAppendMode) {\n\t\tthis.complexFeaturesAppendMode = complexFeaturesAppendMode;\n\t}\n\n\tpublic InsdcParser() {\n\t\tthis(DataSource.ENA);\n\t}\n\n\tpublic InsdcParser(DataSource dataSource) {\n\t\tthis.dataSource = dataSource;\n\t}\n\n\tpublic DataSource getDataSource() {\n\t\treturn dataSource;\n\t}\n\n\tpublic void setSequenceCircular(boolean sequenceCircular) {\n\t\tisSequenceCircular = sequenceCircular;\n\t}\n\n\tpublic void setSequenceLength(long sequenceLength) {\n\t\tthis.sequenceLength = sequenceLength;\n\t}\n\n\t/**\n\t * Main method for parsing a location from a String instance\n\t *\n\t * @param locationString Represents a logical location\n\t * @return The parsed location\n\t * @throws ParserException thrown in the event of any error during parsing\n\t */\n\tpublic Location parse(String locationString) throws ParserException {\n\t\tfeatureGlobalStart = Integer.MAX_VALUE;\n\t\tfeatureGlobalEnd = 1;\n\n\t\tLocation l;\n\t\tList<Location> ll = parseLocationString(locationString, 1);\n\n\t\tif (ll.size() == 1) {\n\t\t\tl = ll.get(0);\n\t\t} else {\n\t\t\tl = new SimpleLocation(\n\t\t\t\t\tnew SimplePoint(featureGlobalStart),\n\t\t\t\t\tnew SimplePoint(featureGlobalEnd),\n\t\t\t\t\tStrand.UNDEFINED,\n\t\t\t\t\tisSequenceCircular,\n\t\t\t\t\tll);\n\t\t}\n\t\treturn l;\n\t}\n\n\tprivate List<Location> parseLocationString(String string, int versus) throws ParserException {\n\t\tMatcher m;\n\t\tList<Location> boundedLocationsCollection = new ArrayList<Location>();\n\n\t\tList<String> tokens = splitString(string);\n\t\tfor (String t : tokens) {\n\t\t\tm = genbankSplitPattern.matcher(t);\n\t\t\tif (!m.find()) {\n\t\t\t\tthrow new ParserException(\"Cannot interpret split pattern \" + t\n\t\t\t\t\t\t+ \"\\nin location string:\" + string);\n\t\t\t}\n\t\t\tString splitQualifier = m.group(1);\n\t\t\tString splitString = m.group(2);\n\n\t\t\tif (!splitQualifier.isEmpty()) {\n\t\t\t\t//recursive case\n\t\t\t\tint localVersus = splitQualifier.equalsIgnoreCase(\"complement\") ? -1 : 1;\n\t\t\t\tList<Location> subLocations = parseLocationString(\n\t\t\t\t\t\tsplitString, versus * localVersus);\n\n\t\t\t\tswitch (complexFeaturesAppendMode) {\n\t\t\t\t\tcase FLATTEN:\n\t\t\t\t\t\tboundedLocationsCollection.addAll(subLocations);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HIERARCHICAL:\n\t\t\t\t\t\tif (subLocations.size() == 1) {\n\t\t\t\t\t\t\tboundedLocationsCollection.addAll(subLocations);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPoint min = Location.Tools.getMin(subLocations).getStart();\n\t\t\t\t\t\t\tPoint max = Location.Tools.getMax(subLocations).getEnd();\n\t\t\t\t\t\t\tAbstractLocation motherLocation\n\t\t\t\t\t\t\t\t\t= new SimpleLocation(\n\t\t\t\t\t\t\t\t\t\t\tmin,\n\t\t\t\t\t\t\t\t\t\t\tmax\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"join\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.GroupLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"order\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.OrderLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"bond\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.BondLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmotherLocation.setStrand(getGroupLocationStrand(subLocations));\n\t\t\t\t\t\t\tboundedLocationsCollection.add(motherLocation);\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//base case\n\t\t\t\tm = singleLocationPattern.matcher(splitString);\n\t\t\t\tif (!m.find()) {\n\t\t\t\t\tthrow new ParserException(\"Cannot interpret location pattern \" + splitString\n\t\t\t\t\t\t\t+ \"\\nin location string:\" + string);\n\t\t\t\t}\n\n\t\t\t\tString accession = m.group(1);\n\t\t\t\tStrand s = versus == 1 ? Strand.POSITIVE : Strand.NEGATIVE;\n\t\t\t\tint start = Integer.valueOf(m.group(3));\n\t\t\t\tint end = m.group(6) == null ? start : Integer.valueOf(m.group(6));\n\n\t\t\t\tif (featureGlobalStart > start) {\n\t\t\t\t\tfeatureGlobalStart = start;\n\t\t\t\t}\n\t\t\t\tif (featureGlobalEnd < end) {\n\t\t\t\t\tfeatureGlobalEnd = end;\n\t\t\t\t}\n\n\t\t\t\tAbstractLocation l;\n\t\t\t\tif (start <= end) {\n\t\t\t\t\tl = new SimpleLocation(\n\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\ts\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// in case of location spanning the end point, Location contract wants sublocations\n\t\t\t\t\tAbstractLocation l5prime = new SimpleLocation(\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\tStrand.UNDEFINED\n\t\t\t\t\t\t\t);\n\t\t\t\t\tAbstractLocation l3prime = new SimpleLocation(\n\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t(int) sequenceLength,\n\t\t\t\t\t\t\tStrand.UNDEFINED\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\tl = new InsdcLocations.GroupLocation(\n\t\t\t\t\t\t\tnew SimplePoint(start),\n\t\t\t\t\t\t\tnew SimplePoint(end),\n\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\tisSequenceCircular,\n\t\t\t\t\t\t\tl5prime, l3prime\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif(m.group(4) != null && m.group(4).equals(\"^\")) l.setBetweenCompounds(true);\n\n\t\t\t\tif (m.group(2).equals(\"<\")) {\n\t\t\t\t\tl.setPartialOn5prime(true);\n\t\t\t\t}\n\t\t\t\tif (m.group(5) != null && (m.group(5).equals(\">\") || m.group(7).equals(\">\"))) {\n\t\t\t\t\tl.setPartialOn3prime(true);\n\t\t\t\t}\n\n\t\t\t\tif (!(accession == null || \"\".equals(accession))) l.setAccession(new AccessionID(accession));\n\n\t\t\t\tboundedLocationsCollection.add(l);\n\n\t\t\t}\n\t\t}\n\n\t\treturn boundedLocationsCollection;\n\t}\n\n\n\tprivate List<String> splitString(String input) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tint start = 0;\n\t\tint openedParenthesis = 0;\n\t\tfor (int current = 0; current < input.length(); current++) {\n\t\t\tif (input.charAt(current) == '(') {\n\t\t\t\topenedParenthesis++;\n\t\t\t}\n\t\t\tif (input.charAt(current) == ')') {\n\t\t\t\topenedParenthesis--;\n\t\t\t}\n\t\t\tboolean atLastChar = (current == input.length() - 1);\n\t\t\tif (atLastChar) {\n\t\t\t\tresult.add(input.substring(start));\n\t\t\t} else if (input.charAt(current) == ',' && openedParenthesis == 0) {\n\t\t\t\tresult.add(input.substring(start, current));\n\t\t\t\tstart = current + 1;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate Strand getGroupLocationStrand(List<Location> ll){\n\t\tStrand returnStrand = null;\n\n\t\tfor (Location l: ll) {\n\t\t\tif (returnStrand == null) returnStrand = l.getStrand();\n\t\t\tif (returnStrand != l.getStrand()) return Strand.UNDEFINED;\n\t\t}\n\t\treturn returnStrand;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.location;\n\nimport org.biojava.nbio.core.exceptions.ParserException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.location.template.AbstractLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.location.template.Point;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Parser for working with INSDC style locations. This class supports the\n * full range of location types generated by Genbank, INSDC and ENA.\n *\n * @author ayates\n * @author jgrzebyta\n * @author Paolo Pavan\n */\npublic class InsdcParser {\n\n\tprivate boolean isSequenceCircular;\n\tprivate long sequenceLength;\n\n\tprivate final DataSource dataSource;\n\n\t\t/**\n\t * parse a location. if group(1) is null than the feature is on the positive\n\t * strand, group(2) start position, group(3) end position.\n\t */\n\tprotected static final Pattern singleLocationPattern = Pattern.compile(\"(?:([A-Za-z\\\\.0-9_]*?):)?(<?)(\\\\d+)(\\\\.{2}|\\\\^)?(>?)(\\\\d+)?(>?)?\");\n\t/**\n\t * Decodes a split pattern. Split patterns are a composition of multiple\n\t * locationsString qualified by actions: join(location,location, ...\n\t * location): The indicated elements should be joined (placed end-to-end) to\n\t * form one contiguous sequence. order(location,location, ... location): The\n\t * elements can be found in the specified order (5' to 3' direction),\n\t * nothing is implied about their reasonableness\n\t * bond(location,location...location): Found in protein files. These\n\t * generally are used to describe disulfide bonds.\n\t * complement(location,location...location): consider locations in their\n\t * complement versus\n\t *\n\t * takes in input a comma split location string. The split must be done\n\t * for outer level commas group(1) is the qualifier group(2) is the location\n\t * string to getFeatures. In case of complex splits it will contain the\n\t * nested expression\n\t *\n\t * Not really sure that they are not declared obsolete but they are still in\n\t * several files.\n\t */\n\tprotected static final Pattern genbankSplitPattern = Pattern.compile(\"^\\\\s?(join|order|bond|complement|)\\\\(?([\\\\s\\\\S]+)\\\\)?\");\n\t/**\n\t * designed to recursively split a location string in tokens. Valid tokens\n\t * are those divided by coma that are not inside a bracket. I. e. split on\n\t * the comma only if that comma has zero, or an even number of quotes ahead\n\t * of it.\n\t */\n\tprotected static final String locationSplitPattern = \",(?=([^\\\\(|\\\\)]+\\\\([^\\\\(|\\\\)]+\\\\))[^\\\\(|\\\\)]+)\";\n\t/**\n\t * these variables are used to compute the global start and end of complex\n\t * features\n\t */\n\tprotected Integer featureGlobalStart, featureGlobalEnd;\n\n\tenum complexFeaturesAppendEnum {\n\n\t\tFLATTEN, HIERARCHICAL;\n\t}\n\t/**\n\t * define the mode in which complex features should be appended in FLATTEN\n\t * mode their will be appended to a single feature in HIERARCHICAL mode, the\n\t * single mother feature will have a tree of features that will reflect the\n\t * construction in genbank file\n\t */\n\tprivate complexFeaturesAppendEnum complexFeaturesAppendMode = complexFeaturesAppendEnum.HIERARCHICAL;\n\n\tpublic void setComplexFeaturesAppendMode(complexFeaturesAppendEnum complexFeaturesAppendMode) {\n\t\tthis.complexFeaturesAppendMode = complexFeaturesAppendMode;\n\t}\n\n\tpublic InsdcParser() {\n\t\tthis(DataSource.ENA);\n\t}\n\n\tpublic InsdcParser(DataSource dataSource) {\n\t\tthis.dataSource = dataSource;\n\t}\n\n\tpublic DataSource getDataSource() {\n\t\treturn dataSource;\n\t}\n\n\tpublic void setSequenceCircular(boolean sequenceCircular) {\n\t\tisSequenceCircular = sequenceCircular;\n\t}\n\n\tpublic void setSequenceLength(long sequenceLength) {\n\t\tthis.sequenceLength = sequenceLength;\n\t}\n\n\t/**\n\t * Main method for parsing a location from a String instance\n\t *\n\t * @param locationString Represents a logical location\n\t * @return The parsed location\n\t * @throws ParserException thrown in the event of any error during parsing\n\t */\n\tpublic Location parse(String locationString) {\n\t\tfeatureGlobalStart = Integer.MAX_VALUE;\n\t\tfeatureGlobalEnd = 1;\n\n\t\tLocation l;\n\t\tList<Location> ll = parseLocationString(locationString, 1);\n\n\t\tif (ll.size() == 1) {\n\t\t\tl = ll.get(0);\n\t\t} else {\n\t\t\tl = new SimpleLocation(\n\t\t\t\t\tnew SimplePoint(featureGlobalStart),\n\t\t\t\t\tnew SimplePoint(featureGlobalEnd),\n\t\t\t\t\tStrand.UNDEFINED,\n\t\t\t\t\tisSequenceCircular,\n\t\t\t\t\tll);\n\t\t}\n\t\treturn l;\n\t}\n\n\tprivate List<Location> parseLocationString(String string, int versus) {\n\t\tMatcher m;\n\t\tList<Location> boundedLocationsCollection = new ArrayList<Location>();\n\n\t\tList<String> tokens = splitString(string);\n\t\tfor (String t : tokens) {\n\t\t\tm = genbankSplitPattern.matcher(t);\n\t\t\tif (!m.find()) {\n\t\t\t\tthrow new ParserException(\"Cannot interpret split pattern \" + t\n\t\t\t\t\t\t+ \"\\nin location string:\" + string);\n\t\t\t}\n\t\t\tString splitQualifier = m.group(1);\n\t\t\tString splitString = m.group(2);\n\n\t\t\tif (!splitQualifier.isEmpty()) {\n\t\t\t\t//recursive case\n\t\t\t\tint localVersus = splitQualifier.equalsIgnoreCase(\"complement\") ? -1 : 1;\n\t\t\t\tList<Location> subLocations = parseLocationString(\n\t\t\t\t\t\tsplitString, versus * localVersus);\n\n\t\t\t\tswitch (complexFeaturesAppendMode) {\n\t\t\t\t\tcase FLATTEN:\n\t\t\t\t\t\tboundedLocationsCollection.addAll(subLocations);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase HIERARCHICAL:\n\t\t\t\t\t\tif (subLocations.size() == 1) {\n\t\t\t\t\t\t\tboundedLocationsCollection.addAll(subLocations);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPoint min = Location.Tools.getMin(subLocations).getStart();\n\t\t\t\t\t\t\tPoint max = Location.Tools.getMax(subLocations).getEnd();\n\t\t\t\t\t\t\tAbstractLocation motherLocation\n\t\t\t\t\t\t\t\t\t= new SimpleLocation(\n\t\t\t\t\t\t\t\t\t\t\tmin,\n\t\t\t\t\t\t\t\t\t\t\tmax\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"join\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.GroupLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"order\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.OrderLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (splitQualifier.equalsIgnoreCase(\"bond\")) {\n\t\t\t\t\t\t\t\tmotherLocation = new InsdcLocations.BondLocation(subLocations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmotherLocation.setStrand(getGroupLocationStrand(subLocations));\n\t\t\t\t\t\t\tboundedLocationsCollection.add(motherLocation);\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//base case\n\t\t\t\tm = singleLocationPattern.matcher(splitString);\n\t\t\t\tif (!m.find()) {\n\t\t\t\t\tthrow new ParserException(\"Cannot interpret location pattern \" + splitString\n\t\t\t\t\t\t\t+ \"\\nin location string:\" + string);\n\t\t\t\t}\n\n\t\t\t\tString accession = m.group(1);\n\t\t\t\tStrand s = versus == 1 ? Strand.POSITIVE : Strand.NEGATIVE;\n\t\t\t\tint start = Integer.valueOf(m.group(3));\n\t\t\t\tint end = m.group(6) == null ? start : Integer.valueOf(m.group(6));\n\n\t\t\t\tif (featureGlobalStart > start) {\n\t\t\t\t\tfeatureGlobalStart = start;\n\t\t\t\t}\n\t\t\t\tif (featureGlobalEnd < end) {\n\t\t\t\t\tfeatureGlobalEnd = end;\n\t\t\t\t}\n\n\t\t\t\tAbstractLocation l;\n\t\t\t\tif (start <= end) {\n\t\t\t\t\tl = new SimpleLocation(\n\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\ts\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// in case of location spanning the end point, Location contract wants sublocations\n\t\t\t\t\tAbstractLocation l5prime = new SimpleLocation(\n\t\t\t\t\t\t\t1,\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\tStrand.UNDEFINED\n\t\t\t\t\t\t\t);\n\t\t\t\t\tAbstractLocation l3prime = new SimpleLocation(\n\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t(int) sequenceLength,\n\t\t\t\t\t\t\tStrand.UNDEFINED\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\tl = new InsdcLocations.GroupLocation(\n\t\t\t\t\t\t\tnew SimplePoint(start),\n\t\t\t\t\t\t\tnew SimplePoint(end),\n\t\t\t\t\t\t\ts,\n\t\t\t\t\t\t\tisSequenceCircular,\n\t\t\t\t\t\t\tl5prime, l3prime\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif(m.group(4) != null && m.group(4).equals(\"^\")) l.setBetweenCompounds(true);\n\n\t\t\t\tif (m.group(2).equals(\"<\")) {\n\t\t\t\t\tl.setPartialOn5prime(true);\n\t\t\t\t}\n\t\t\t\tif (m.group(5) != null && (m.group(5).equals(\">\") || m.group(7).equals(\">\"))) {\n\t\t\t\t\tl.setPartialOn3prime(true);\n\t\t\t\t}\n\n\t\t\t\tif (!(accession == null || \"\".equals(accession))) l.setAccession(new AccessionID(accession));\n\n\t\t\t\tboundedLocationsCollection.add(l);\n\n\t\t\t}\n\t\t}\n\n\t\treturn boundedLocationsCollection;\n\t}\n\n\n\tprivate List<String> splitString(String input) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tint start = 0;\n\t\tint openedParenthesis = 0;\n\t\tfor (int current = 0; current < input.length(); current++) {\n\t\t\tif (input.charAt(current) == '(') {\n\t\t\t\topenedParenthesis++;\n\t\t\t}\n\t\t\tif (input.charAt(current) == ')') {\n\t\t\t\topenedParenthesis--;\n\t\t\t}\n\t\t\tboolean atLastChar = (current == input.length() - 1);\n\t\t\tif (atLastChar) {\n\t\t\t\tresult.add(input.substring(start));\n\t\t\t} else if (input.charAt(current) == ',' && openedParenthesis == 0) {\n\t\t\t\tresult.add(input.substring(start, current));\n\t\t\t\tstart = current + 1;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate Strand getGroupLocationStrand(List<Location> ll){\n\t\tStrand returnStrand = null;\n\n\t\tfor (Location l: ll) {\n\t\t\tif (returnStrand == null) returnStrand = l.getStrand();\n\t\t\tif (returnStrand != l.getStrand()) return Strand.UNDEFINED;\n\t\t}\n\t\treturn returnStrand;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.location;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.location.InsdcParser.complexFeaturesAppendEnum;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n *\n * @author Jacek Grzebyta\n */\n\npublic class InsdcParserTest {\n\n\tprivate Logger log = LoggerFactory.getLogger(getClass());\n\n\t/**\n\t * Test for issue #254\n\t *\n\t * @throws Exception\n\t */\n\t@ParameterizedTest\n\t@CsvSource({ \"complement(CP001663.1:6463934..6465826),CP001663.1\",\n\t\t\t\"complement(NC_000932.1:69611..69724),NC_000932.1\" })\n\tpublic void extractAccessionTest(String data, String expected) throws Exception {\n\n\t\tInsdcParser parser = new InsdcParser(DataSource.GENBANK);\n\t\tLocation loc = parser.parse(data);\n\n\t\tif (!loc.isComplex()) {\n\t\t\tlog.info(\"simple location: {}\", data);\n\t\t\tlog.debug(\"\\taccession: '{}'  expected: '{}'\", loc.getAccession().getID(), expected);\n\t\t\tassertEquals(expected, loc.getAccession().getID());\n\t\t}\n\t}\n\n\t@ParameterizedTest\n\t@CsvSource(delimiterString = \"|\", value = { \"J00194.1:100..202|100..202(+)\", \"A00001.5:34..45|34..45(+)\",\n\t\t\t\"43..129|43..129(+)\", \"bond(55,110)|55..110(+)\", \"bond(34,35),join(56..80),complement(45,73)|34..80(.)\",\n\t\t\t\"order(complement(30,40),70..80),bond(34,35),join(56,80),complement(45..56)|30..80(.)\",\n\t\t\t\"join(join(complement(30,40),complement(70..80)),bond(34,35),join(56,80),complement(45..56))|30..80(.)\",\n\t\t\t\"complement(join(complement(2000..4000),complement(70..80)),bond(34,35),join(56,80),complement(45..56))|34..4000(.)\" })\n\tvoid testParser(String header, String parsedLocation) {\n\t\tInsdcParser p = new InsdcParser();\n\t\tp.setComplexFeaturesAppendMode(complexFeaturesAppendEnum.HIERARCHICAL);\n\t\tassertEquals(parsedLocation, p.parse(header).toString());\n\t}\n}\n","changedTest":"","commitMessage":"Fix Sonar S1130 throws declarations should not be superfluous\n","test_commitMessage":"","allZero":false}