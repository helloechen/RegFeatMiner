{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/ecod/EcodInstallation.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/ecod/EcodInstallationTest.java","prod_time":"2015-03-16 17:17:28","test_time":"2015-04-15 23:16:36","type":"RENAME","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ae8ca434f54e63d03d5fb19f87b06885f2a9ba1a","test_commitID":"0d63b65f9747049d5de3149fbb28330cfe82b469","isfound":"found test change","originPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.ecod;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides access to the Evolutionary Classification of Protein Domains (ECOD).\n * \n * The preferred mechanism for obtaining instances of this class is through the\n * {@link EcodFactory} class.\n * \n * Reference:\n * H. Cheng, R. D. Schaeffer, Y. Liao, L. N. Kinch, J. Pei, S. Shi, B. H.\\\n *   Kim, N. V. Grishin. (2014) ECOD: An evolutionary classification of protein\n *   domains. PLoS Comput Biol 10(12): e1003926.\n * http://prodata.swmed.edu/ecod/\n * \n * @author Spencer Bliven\n *\n */\npublic class EcodInstallation implements EcodDatabase {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\t// ECOD identifiers are e<pdbID><chain><domain>, where chain and domain\n\t// Chain and domain can both be multi-letter (e.g. e2q7zA10)\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"^e(....).+\\\\d+$\");\n\n\n\tprivate String cacheLocation;\n\tprivate String requestedVersion; // version requested, e.g. \"latest\". Used for the paths\n\tprivate String parsedVersion; // actual version parsed\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<String,List<EcodDomain>> domainMap;//PDB ID -> domains, lazily constructed from allDomains\n\n\tprivate String url;\n\n\t/**\n\t * Use EcodFactory to create instances. The instantiation of multiple\n\t * installations at the same path can lead to race conditions when downloading\n\t * files.\n\t * @param cacheLocation Location to save files, typically from the PDB_CACHE_DIR parameter\n\t * @param requestedVersion ECOD requestedVersion to fetch\n\t */\n\tpublic EcodInstallation(String cacheLocation, String version) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.requestedVersion = version;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\t/**\n\t * @see EcodFactory#getEcodDatabase()\n\t */\n\tEcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath(), DEFAULT_VERSION );\n\t}\n\t/**\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tthis( cacheLocation, DEFAULT_VERSION );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param pdbId\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getDomainsForPdb(String pdbId) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\n\t\t\tif(pdbId != null)\n\t\t\t\tpdbId = pdbId.toLowerCase();\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of domains within a particular level of the hierarchy\n\t * @param hierarchy A dot-separated list giving the X-group, H-group, and/or\n\t *  T-group (e.g. \"1.1\" for all members of the RIFT-related H-group)\n\t * @return\n\t * @throws IOException \n\t */\n\t@Override\n\tpublic List<EcodDomain> filterByHierarchy(String hierarchy) throws IOException {\n\t\tString[] xhtGroup = hierarchy.split(\"\\\\.\");\n\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\tList<EcodDomain> filtered = new ArrayList<EcodDomain>();\n\t\tfor(EcodDomain d: getAllDomains()) {\n\t\t\tboolean match = true;\n\t\t\tif(xhtGroup.length>0) {\n\t\t\t\tmatch = match && xGroup.equals(d.getXGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>1) {\n\t\t\t\tmatch = match && hGroup.equals(d.getHGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>2) {\n\t\t\t\tmatch = match && tGroup.equals(d.getTGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>3) {\n\t\t\t\tlogger.warn(\"Ignoring unexpected additional parts of ECOD {}\",hierarchy);\n\t\t\t}\n\t\t\tif(match) {\n\t\t\t\tfiltered.add(d);\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Get a particular ECOD domain by the domain ID (e.g. \"e4hhbA1\")\n\t * @param ecodId\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPdb(pdbId);\n\t\tif(doms == null) {\n\t\t\tlogger.debug(\"Null domains for {} from {}\",pdbId,ecodId);\n\t\t\treturn null;\n\t\t}\n\t\tlogger.debug(\"Got {} domains from {}\",doms.size(),pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get all ECOD domains\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\t/**\n\t * Return the ECOD version, as parsed from the file.\n\t * \n\t * Note that this may differ from the version requested in the constructor\n\t * for the special case of \"latest\"\n\t * @return the ECOD version\n\t * @throws IOException If an error occurs while downloading or parsing the file\n\t */\n\t@Override\n\tpublic String getVersion() throws IOException {\n\t\tensureDomainsFileInstalled();\n\n\t\tif( parsedVersion == null) {\n\t\t\treturn requestedVersion;\n\t\t}\n\t\treturn parsedVersion;\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tthis.cacheLocation = cacheLocation;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t * \n\t * This may be useful in multithreaded environments.\n\t * @throws IOException\n\t */\n\t// Populates allDomains\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\treturn f.exists() && f.length()>0;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current requestedVersion.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,requestedVersion);\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t\tparsedVersion = parser.getVersion();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap from allDomains\n\t * @throws IOException \n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<String, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tString pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = match.group(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\n\t\t/** String for unclassified F-groups */\n\t\tpublic static final String F_UNCLASSIFIED = \"F_UNCLASSIFIED\";\n\t\t/** String for single-domain assemblies */\n\t\tpublic static final String NOT_DOMAIN_ASSEMBLY = \"NOT_DOMAIN_ASSEMBLY\";\n\t\t/** Deprecated way of indicating there is an assembly. replaced by the assembly id */\n\t\tpublic static final String IS_DOMAIN_ASSEMBLY = \"IS_DOMAIN_ASSEMBLY\";\n\t\t/** Indicates a manual representative */\n\t\tpublic static final String IS_REPRESENTATIVE = \"MANUAL_REP\";\n\t\t/** Indicates not a manual representative */\n\t\tpublic static final String NOT_REPRESENTATIVE = \"AUTO_NONREP\";\n\n\t\tprivate List<EcodDomain> domains;\n\t\tprivate String version;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tversion = null;\n\t\t\tparse(reader);\n\t\t}\n\n\t\tprivate void parse(BufferedReader in) throws IOException {\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015 \n\t\t\t\tArrayList<EcodDomain> domainsList = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tPattern versionRE = Pattern.compile(\"^\\\\s*#.*ECOD\\\\s*version\\\\s+(\\\\S+).*\");\n\t\t\t\tPattern commentRE = Pattern.compile(\"^\\\\s*#.*\");\n\n\t\t\t\t// prevent too many warnings; negative numbers print all warnings\n\t\t\t\tint warnIsDomainAssembly = 1;\n\t\t\t\tint warnHierarchicalFormat = 5;\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 1;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Check for requestedVersion string\n\t\t\t\t\tMatcher match = versionRE.matcher(line);\n\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t// special requestedVersion comment\n\t\t\t\t\t\tthis.version = match.group(1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = commentRE.matcher(line);\n\t\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t\t// ignore comments\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// data line\n\t\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\t\tif( fields.length == 13 || fields.length == 14 ) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\t\t\t\t\t\t\t\t\t// Manual column may be missing\n\t\t\t\t\t\t\t\t\tBoolean manual = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 14) {\n\t\t\t\t\t\t\t\t\t\tString manualString = fields[i++];\n\t\t\t\t\t\t\t\t\t\tif(manualString.equalsIgnoreCase(IS_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = true;\n\t\t\t\t\t\t\t\t\t\t} else if(manualString.equalsIgnoreCase(NOT_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = false;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for manual field: {} in line {}\",manualString,lineNum);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// hierarchical field, e.g. \"1.1.4.1\"\n\t\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\t\tif(xhtGroup.length < 3 || 4 < xhtGroup.length) {\n\t\t\t\t\t\t\t\t\t\tif(warnHierarchicalFormat > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnHierarchicalFormat != 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}. Not printing future similar warnings.\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\t\t\t\t\t\t\t\t\tInteger fGroup = xhtGroup.length>3 ? Integer.parseInt(xhtGroup[3]) : null;\n\n\t\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\t\t\t\t\t\t\t\t\tLong assemblyId = null;\n\t\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\t\tif(assemblyStr.equals(NOT_DOMAIN_ASSEMBLY)) {\n\t\t\t\t\t\t\t\t\t\tassemblyId = uid;\n\t\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\") ) {\n\t\t\t\t\t\t\t\t\t\tif(warnIsDomainAssembly > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnIsDomainAssembly == 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}. Not printing future similar warnings.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t//assemblyId = null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tassemblyId = Long.parseLong(assemblyStr);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, fGroup,pdbId, chainId, range, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, assemblyId, ligands);\n\t\t\t\t\t\t\t\t\tdomainsList.add(domain);\n\t\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}\",lineNum);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tif(this.version == null)\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domainsList.size());\n\t\t\t\telse\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains from version {}\",domainsList.size(),this.version);\n\n\n\t\t\t\tthis.domains = Collections.unmodifiableList( domainsList );\n\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return the requestedVersion for this file, or null if none was parsed\n\t\t */\n\t\tpublic String getVersion() {\n\t\t\treturn version;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tString version = null;\n\t\ttry {\n\t\t\tversion = getVersion();\n\t\t} catch (IOException e) {\n\t\t\t// For parsing errors, use the requested version\n\t\t\tversion = requestedVersion;\n\t\t}\n\n\t\treturn \"EcodInstallation [cacheLocation=\" + cacheLocation\n\t\t\t\t+ \", version=\" + version + \"]\";\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","changedPro":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.ecod;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides access to the Evolutionary Classification of Protein Domains (ECOD).\n * \n * The preferred mechanism for obtaining instances of this class is through the\n * {@link EcodFactory} class.\n * \n * Reference:\n * H. Cheng, R. D. Schaeffer, Y. Liao, L. N. Kinch, J. Pei, S. Shi, B. H.\\\n *   Kim, N. V. Grishin. (2014) ECOD: An evolutionary classification of protein\n *   domains. PLoS Comput Biol 10(12): e1003926.\n * http://prodata.swmed.edu/ecod/\n * \n * @author Spencer Bliven\n *\n */\npublic class EcodInstallation implements EcodDatabase {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\t// ECOD identifiers are e<pdbID><chain><domain>, where chain and domain\n\t// Chain and domain can both be multi-letter (e.g. e2q7zA10)\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"^e(....).+\\\\d+$\");\n\n\n\tprivate String cacheLocation;\n\tprivate String requestedVersion; // version requested, e.g. \"latest\". Used for the paths\n\tprivate String parsedVersion; // actual version parsed\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<String,List<EcodDomain>> domainMap;//PDB ID -> domains, lazily constructed from allDomains\n\n\tprivate String url;\n\n\t/**\n\t * Use EcodFactory to create instances. The instantiation of multiple\n\t * installations at the same path can lead to race conditions when downloading\n\t * files.\n\t * @param cacheLocation Location to save files, typically from the PDB_CACHE_DIR parameter\n\t * @param requestedVersion ECOD requestedVersion to fetch\n\t */\n\tpublic EcodInstallation(String cacheLocation, String version) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.requestedVersion = version;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\t/**\n\t * @see EcodFactory#getEcodDatabase()\n\t */\n\tEcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath(), DEFAULT_VERSION );\n\t}\n\t/**\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tthis( cacheLocation, DEFAULT_VERSION );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param pdbId\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getDomainsForPdb(String pdbId) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\n\t\t\tif(pdbId != null)\n\t\t\t\tpdbId = pdbId.toLowerCase();\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get a list of domains within a particular level of the hierarchy\n\t * @param hierarchy A dot-separated list giving the X-group, H-group, and/or\n\t *  T-group (e.g. \"1.1\" for all members of the RIFT-related H-group)\n\t * @return\n\t * @throws IOException \n\t */\n\t@Override\n\tpublic List<EcodDomain> filterByHierarchy(String hierarchy) throws IOException {\n\t\tString[] xhtGroup = hierarchy.split(\"\\\\.\");\n\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\tList<EcodDomain> filtered = new ArrayList<EcodDomain>();\n\t\tfor(EcodDomain d: getAllDomains()) {\n\t\t\tboolean match = true;\n\t\t\tif(xhtGroup.length>0) {\n\t\t\t\tmatch = match && xGroup.equals(d.getXGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>1) {\n\t\t\t\tmatch = match && hGroup.equals(d.getHGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>2) {\n\t\t\t\tmatch = match && tGroup.equals(d.getTGroup());\n\t\t\t}\n\t\t\tif(xhtGroup.length>3) {\n\t\t\t\tlogger.warn(\"Ignoring unexpected additional parts of ECOD {}\",hierarchy);\n\t\t\t}\n\t\t\tif(match) {\n\t\t\t\tfiltered.add(d);\n\t\t\t}\n\t\t}\n\t\treturn filtered;\n\t}\n\n\t/**\n\t * Get a particular ECOD domain by the domain ID (e.g. \"e4hhbA1\")\n\t * @param ecodId\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPdb(pdbId);\n\t\tif(doms == null) {\n\t\t\tlogger.debug(\"Null domains for {} from {}\",pdbId,ecodId);\n\t\t\treturn null;\n\t\t}\n\t\tlogger.debug(\"Got {} domains from {}\",doms.size(),pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get all ECOD domains\n\t * @return\n\t * @throws IOException\n\t */\n\t@Override\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\t/**\n\t * Return the ECOD version, as parsed from the file.\n\t * \n\t * Note that this may differ from the version requested in the constructor\n\t * for the special case of \"latest\"\n\t * @return the ECOD version\n\t * @throws IOException If an error occurs while downloading or parsing the file\n\t */\n\t@Override\n\tpublic String getVersion() throws IOException {\n\t\tensureDomainsFileInstalled();\n\n\t\tif( parsedVersion == null) {\n\t\t\treturn requestedVersion;\n\t\t}\n\t\treturn parsedVersion;\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tthis.cacheLocation = cacheLocation;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t * \n\t * This may be useful in multithreaded environments.\n\t * @throws IOException\n\t */\n\t// Populates allDomains\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\treturn f.exists() && f.length()>0;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current requestedVersion.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,requestedVersion);\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t\tparsedVersion = parser.getVersion();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap from allDomains\n\t * @throws IOException \n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<String, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tString pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = match.group(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\n\t\t/** String for unclassified F-groups */\n\t\tpublic static final String F_UNCLASSIFIED = \"F_UNCLASSIFIED\";\n\t\t/** String for single-domain assemblies */\n\t\tpublic static final String NOT_DOMAIN_ASSEMBLY = \"NOT_DOMAIN_ASSEMBLY\";\n\t\t/** Deprecated way of indicating there is an assembly. replaced by the assembly id */\n\t\tpublic static final String IS_DOMAIN_ASSEMBLY = \"IS_DOMAIN_ASSEMBLY\";\n\t\t/** Indicates a manual representative */\n\t\tpublic static final String IS_REPRESENTATIVE = \"MANUAL_REP\";\n\t\t/** Indicates not a manual representative */\n\t\tpublic static final String NOT_REPRESENTATIVE = \"AUTO_NONREP\";\n\n\t\tprivate List<EcodDomain> domains;\n\t\tprivate String version;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tversion = null;\n\t\t\tparse(reader);\n\t\t}\n\n\t\tprivate void parse(BufferedReader in) throws IOException {\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015 \n\t\t\t\tArrayList<EcodDomain> domainsList = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tPattern versionRE = Pattern.compile(\"^\\\\s*#.*ECOD\\\\s*version\\\\s+(\\\\S+).*\");\n\t\t\t\tPattern commentRE = Pattern.compile(\"^\\\\s*#.*\");\n\n\t\t\t\t// prevent too many warnings; negative numbers print all warnings\n\t\t\t\tint warnIsDomainAssembly = 1;\n\t\t\t\tint warnHierarchicalFormat = 5;\n\t\t\t\tint warnNumberOfFields = 10;\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 1;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Check for requestedVersion string\n\t\t\t\t\tMatcher match = versionRE.matcher(line);\n\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t// special requestedVersion comment\n\t\t\t\t\t\tthis.version = match.group(1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = commentRE.matcher(line);\n\t\t\t\t\t\tif(match.matches()) {\n\t\t\t\t\t\t\t// ignore comments\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// data line\n\t\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\t\tif( fields.length == 13 || fields.length == 14 ) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\t\t\t\t\t\t\t\t\t// Manual column may be missing\n\t\t\t\t\t\t\t\t\tBoolean manual = null;\n\t\t\t\t\t\t\t\t\tif( fields.length >= 14) {\n\t\t\t\t\t\t\t\t\t\tString manualString = fields[i++];\n\t\t\t\t\t\t\t\t\t\tif(manualString.equalsIgnoreCase(IS_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = true;\n\t\t\t\t\t\t\t\t\t\t} else if(manualString.equalsIgnoreCase(NOT_REPRESENTATIVE)) {\n\t\t\t\t\t\t\t\t\t\t\tmanual = false;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for manual field: {} in line {}\",manualString,lineNum);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// hierarchical field, e.g. \"1.1.4.1\"\n\t\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\t\tif(xhtGroup.length < 3 || 4 < xhtGroup.length) {\n\t\t\t\t\t\t\t\t\t\tif(warnHierarchicalFormat > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnHierarchicalFormat != 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for hierarchical field \\\"{}\\\" in line {}. Not printing future similar warnings.\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnHierarchicalFormat--;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\t\t\t\t\t\t\t\t\tInteger fGroup = xhtGroup.length>3 ? Integer.parseInt(xhtGroup[3]) : null;\n\n\t\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\t\t\t\t\t\t\t\t\tLong assemblyId = null;\n\t\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\t\tif(assemblyStr.equals(NOT_DOMAIN_ASSEMBLY)) {\n\t\t\t\t\t\t\t\t\t\tassemblyId = uid;\n\t\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\") ) {\n\t\t\t\t\t\t\t\t\t\tif(warnIsDomainAssembly > 1) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} else if(warnIsDomainAssembly == 0) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.info(\"Deprecated 'IS_DOMAIN_ASSEMBLY' value ignored in line {}. Not printing future similar warnings.\",lineNum);\n\t\t\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\t//assemblyId = null;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tassemblyId = Long.parseLong(assemblyStr);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, fGroup,pdbId, chainId, range, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, assemblyId, ligands);\n\t\t\t\t\t\t\t\t\tdomainsList.add(domain);\n\t\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(warnNumberOfFields > 1) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}.\",lineNum);\n\t\t\t\t\t\t\t\t\twarnNumberOfFields--;\n\t\t\t\t\t\t\t\t} else if(warnNumberOfFields == 0) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}. Not printing future similar warnings\",lineNum);\n\t\t\t\t\t\t\t\t\twarnIsDomainAssembly--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tif(this.version == null)\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domainsList.size());\n\t\t\t\telse\n\t\t\t\t\tlogger.info(\"Parsed {} ECOD domains from version {}\",domainsList.size(),this.version);\n\n\n\t\t\t\tthis.domains = Collections.unmodifiableList( domainsList );\n\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return the requestedVersion for this file, or null if none was parsed\n\t\t */\n\t\tpublic String getVersion() {\n\t\t\treturn version;\n\t\t}\n\t}\n\n\n\t@Override\n\tpublic String toString() {\n\t\tString version = null;\n\t\ttry {\n\t\t\tversion = getVersion();\n\t\t} catch (IOException e) {\n\t\t\t// For parsing errors, use the requested version\n\t\t\tversion = requestedVersion;\n\t\t}\n\n\t\treturn \"EcodInstallation [cacheLocation=\" + cacheLocation\n\t\t\t\t+ \", version=\" + version + \"]\";\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","originTest":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.test.domain;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.core.util.ConcurrencyTools;\nimport org.biojava.nbio.structure.ecod.EcodDatabase;\nimport org.biojava.nbio.structure.ecod.EcodDomain;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.ecod.EcodInstallation;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallationTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallationTest.class);\n\tprivate static final String VERSION = \"develop78\";\n\n\tstatic {\n\t\t//System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\");\n\t} \n\t@Rule\n\tpublic TemporaryFolder tmpFolder = new TemporaryFolder();\n\t@Test\n\tpublic void testDownloads() throws IOException {\n\t\t// Use second installation with tmp location to avoid overwriting main cache\n\t\tEcodInstallation ecod2 = new EcodInstallation(tmpFolder.getRoot().getAbsolutePath(),VERSION);\n\t\t// Delete old VERSION\n\t\tFile domainsFile = new File(ecod2.getCacheLocation(),\"ecod.\"+VERSION+\".domains.txt\");\n\t\tif( domainsFile.exists() ) {\n\t\t\tdomainsFile.delete();\n\t\t}\n\t\t// Force download\n\t\tecod2.ensureDomainsFileInstalled();\n\t\t// Check for download\n\t\tassertTrue(\"No downloaded file at \"+domainsFile.toString(),domainsFile.exists());\n\t}\n\n\n\t@Test\n\tpublic void testAllDomains() throws IOException {\n\t\tint expected;\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> domains = ecod.getAllDomains();\n\t\texpected = 423779; //version77\n\t\texpected = 423869; //version78\n\t\tassertEquals(\"Wrong number of domains\",expected,domains.size());\n\t}\n\n\t@Test\n\tpublic void testByPDB() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString pdbId;\n\t\tString[] expectedDomains;\n\t\tList<EcodDomain> domains;\n\n\t\tpdbId = \"1lyw\";\n\t\texpectedDomains = new String[] {\"e1lyw.1\",\"e1lyw.2\",\"e1lyw.3\",\"e1lyw.4\"};\n\t\tdomains = ecod.getDomainsForPdb(pdbId);\n\n\t\tmatchNames(pdbId,expectedDomains,domains);\n\n\t}\n\n\tprivate void matchNames(String pdbId,String[] expected,List<EcodDomain> actual) {\n\t\tassertEquals(\"Wrong number of domains for \"+pdbId, expected.length, actual.size());\n\t\tSet<String> exp = new HashSet<String>(Arrays.asList(expected));\n\t\tfor(EcodDomain d : actual) {\n\t\t\tassertTrue(\"Unexpected domain \"+d.getDomainId()+\" in \"+pdbId,exp.contains(d.getDomainId()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testParsing() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString ecodId;\n\t\tEcodDomain domain,expected;\n\n\t\tecodId = \"e1lyw.1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\texpected = new EcodDomain(\n\t\t\t\t//\t\t\t\tLong uid, String domainId, Boolean manual,\n\t\t\t\t20669l, \"e1lyw.1\", false,\n\t\t\t\t//\t\t\t\tInteger xGroup, Integer hGroup, Integer tGroup, Integer fGroup, String pdbId,\n\t\t\t\t1,1,1,2,\"1lyw\",\n\t\t\t\t//\t\t\t\tString chainId, String range, String architectureName,\n\t\t\t\t\".\", \"A:3-97,B:106-346\", \"beta barrels\",\n\t\t\t\t//\t\t\t\tString xGroupName, String hGroupName, String tGroupName,\n\t\t\t\t//\t\t\t\tString fGroupName, Boolean isAssembly, List<String> ligands\n\t\t\t\t\"cradle loop barrel\", \"RIFT-related\", \"acid protease\",\n\t\t\t\t\"EF00710\",//\"UNK_F_TYPE\",\n\t\t\t\t20669l, Collections.singleton(\"EPE\")\n\t\t\t\t);\n\t\tassertEquals(ecodId,expected,domain);\n\n\t\tecodId = \"e4v4fAA1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\tassertNotNull(ecodId,domain);\n\t\tassertEquals(ecodId,ecodId,domain.getDomainId());\n\t}\n\n\t@Test\n\tpublic void testMultithreaded() throws IOException {\n\t\tfinal EcodInstallation ecod = (EcodInstallation) EcodFactory.getEcodDatabase(VERSION);\n\t\tecod.clear();\n\t\tString[] ecodIds = new String[] {\n\t\t\t\t\"e4s1gA1\", \"e4umoB1\", \"e4v0cA1\", \"e4v1af1\", \"e3j7yj1\", \"e4wfcA1\",\"e4b0jP1\",\n\t\t};\n\t\tList<Future<EcodDomain>> futureDomains = new ArrayList<Future<EcodDomain>>();\n\t\tfor(final String ecodId : ecodIds) {\n\t\t\tCallable<EcodDomain> job = new Callable<EcodDomain>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EcodDomain call() throws Exception {\n\t\t\t\t\tlogger.info(\"Running \"+ecodId);\n\t\t\t\t\tEcodDomain d = ecod.getDomainsById(ecodId);\n\t\t\t\t\tlogger.info(\"Finished \"+ecodId);\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Job fetching ECOD \"+ecodId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<EcodDomain> future = ConcurrencyTools.submit(job,ecodId);\n\t\t\tfutureDomains.add(future);\n\t\t}\n\t\tint successful = 0;\n\t\tfor(Future<EcodDomain> future : futureDomains) {\n\t\t\ttry {\n\t\t\t\tEcodDomain domain = future.get(60, TimeUnit.SECONDS);\n\t\t\t\tif(domain != null) {\n\t\t\t\t\tsuccessful++;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" interrupted\",e);\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" error\",e);\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" timed out\",e);\n\t\t\t}\n\n\t\t}\n\t\tassertEquals(ecodIds.length, successful);\n\t}\n\n\t@Test\n\tpublic void testFilterByHierarchy() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> filtered;\n\t\tSet<String> expected,actual;\n\n\t\texpected = new HashSet<String>(Arrays.asList(\n\t\t\t\t\"e4il6R1 e4pj0R1 e4pj0r1 e4ub6R1 e4ub8R1\".split(\" \") ));\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\t}\n\n\t@Test\n\tpublic void testVersion() throws IOException {\n\t\tEcodDatabase ecod3 = EcodFactory.getEcodDatabase(\"latest\");\n\t\tString version = ecod3.getVersion();\n\t\tassertNotNull(version);\n\t\tassertNotEquals(\"latest\", version);\n\t}\n\n\t/**\n\t * Parses all known versions. Only fails due to exceptions, so manually check for warnings.\n\t * Hierarchical field warnings are expected for versions prior to develop68.\n\t * @throws IOException\n\t */\n\t//@Ignore // Very slow parsing test\n\t@Test\n\tpublic void testAllVersions() throws IOException {\n\t\t// Fetch latest version\n\t\tEcodDatabase latest = EcodFactory.getEcodDatabase(\"latest\");\n\t\tString latestVersionStr = latest.getVersion();\n\t\tint latestVersion = 0;\n\t\tMatcher match = Pattern.compile(\"develop([0-9]+)\",Pattern.CASE_INSENSITIVE).matcher(latestVersionStr);\n\t\tif(match.matches())\n\t\t\tlatestVersion = Integer.parseInt(match.group(1));\n\t\tlatest = null;\n\n\t\t// List all versions\n\t\tint firstVersion = 45;\n\t\tint lastVersion = Math.max(78,latestVersion);\n\t\tList<String> versions = new ArrayList<String>();\n\t\tversions.add(\"latest\");\n\t\tfor(int version = firstVersion; version<= lastVersion;version++) {\n\t\t\tversions.add(\"develop\"+version);\n\t\t}\n\t\t\n\t\t// Parse all versions\n\t\tfor(String version : versions) {\n\t\t\tEcodInstallation ecod = (EcodInstallation)EcodFactory.getEcodDatabase(version);\n\t\t\tecod.getAllDomains();\n\t\t\tSystem.out.println(version +\" -> \"+ ecod.getVersion());\n\t\t\t\n\t\t\t// Force garbage collection of all soft references\n\t\t\t// This shouldn't be required, but without it we get\n\t\t\t// 'OutOfMemoryError: GC overhead limit exceeded'.\n\t\t\t// Probably this is due to synchronization in EcodFactory blocking\n\t\t\t// the GC during parsing. -Spencer\n\t\t\tecod = null;\n\t\t\tSystem.gc();\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tObject[] ignored = new Object[(int) Runtime.getRuntime().maxMemory()];\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// Ignore OME\n\t\t\t}\n\t\t}\n\t}\n}\n","changedTest":"/*\n * BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\npackage org.biojava.nbio.structure.test.ecod;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.core.util.ConcurrencyTools;\nimport org.biojava.nbio.structure.ecod.EcodDatabase;\nimport org.biojava.nbio.structure.ecod.EcodDomain;\nimport org.biojava.nbio.structure.ecod.EcodFactory;\nimport org.biojava.nbio.structure.ecod.EcodInstallation;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallationTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallationTest.class);\n\tprivate static final String VERSION = \"develop78\";\n\n\tstatic {\n\t\t//System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\");\n\t} \n\t@Rule\n\tpublic TemporaryFolder tmpFolder = new TemporaryFolder();\n\t@Test\n\tpublic void testDownloads() throws IOException {\n\t\t// Use second installation with tmp location to avoid overwriting main cache\n\t\tEcodInstallation ecod2 = new EcodInstallation(tmpFolder.getRoot().getAbsolutePath(),VERSION);\n\t\t// Delete old VERSION\n\t\tFile domainsFile = new File(ecod2.getCacheLocation(),\"ecod.\"+VERSION+\".domains.txt\");\n\t\tif( domainsFile.exists() ) {\n\t\t\tdomainsFile.delete();\n\t\t}\n\t\t// Force download\n\t\tecod2.ensureDomainsFileInstalled();\n\t\t// Check for download\n\t\tassertTrue(\"No downloaded file at \"+domainsFile.toString(),domainsFile.exists());\n\t}\n\n\n\t@Test\n\tpublic void testAllDomains() throws IOException {\n\t\tint expected;\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> domains = ecod.getAllDomains();\n\t\texpected = 423779; //version77\n\t\texpected = 423869; //version78\n\t\tassertEquals(\"Wrong number of domains\",expected,domains.size());\n\t}\n\n\t@Test\n\tpublic void testByPDB() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString pdbId;\n\t\tString[] expectedDomains;\n\t\tList<EcodDomain> domains;\n\n\t\tpdbId = \"1lyw\";\n\t\texpectedDomains = new String[] {\"e1lyw.1\",\"e1lyw.2\",\"e1lyw.3\",\"e1lyw.4\"};\n\t\tdomains = ecod.getDomainsForPdb(pdbId);\n\n\t\tmatchNames(pdbId,expectedDomains,domains);\n\n\t}\n\n\tprivate void matchNames(String pdbId,String[] expected,List<EcodDomain> actual) {\n\t\tassertEquals(\"Wrong number of domains for \"+pdbId, expected.length, actual.size());\n\t\tSet<String> exp = new HashSet<String>(Arrays.asList(expected));\n\t\tfor(EcodDomain d : actual) {\n\t\t\tassertTrue(\"Unexpected domain \"+d.getDomainId()+\" in \"+pdbId,exp.contains(d.getDomainId()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testParsing() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tString ecodId;\n\t\tEcodDomain domain,expected;\n\n\t\tecodId = \"e1lyw.1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\texpected = new EcodDomain(\n\t\t\t\t//\t\t\t\tLong uid, String domainId, Boolean manual,\n\t\t\t\t20669l, \"e1lyw.1\", false,\n\t\t\t\t//\t\t\t\tInteger xGroup, Integer hGroup, Integer tGroup, Integer fGroup, String pdbId,\n\t\t\t\t1,1,1,2,\"1lyw\",\n\t\t\t\t//\t\t\t\tString chainId, String range, String architectureName,\n\t\t\t\t\".\", \"A:3-97,B:106-346\", \"beta barrels\",\n\t\t\t\t//\t\t\t\tString xGroupName, String hGroupName, String tGroupName,\n\t\t\t\t//\t\t\t\tString fGroupName, Boolean isAssembly, List<String> ligands\n\t\t\t\t\"cradle loop barrel\", \"RIFT-related\", \"acid protease\",\n\t\t\t\t\"EF00710\",//\"UNK_F_TYPE\",\n\t\t\t\t20669l, Collections.singleton(\"EPE\")\n\t\t\t\t);\n\t\tassertEquals(ecodId,expected,domain);\n\n\t\tecodId = \"e4v4fAA1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\tassertNotNull(ecodId,domain);\n\t\tassertEquals(ecodId,ecodId,domain.getDomainId());\n\t}\n\n\t@Test\n\tpublic void testMultithreaded() throws IOException {\n\t\tfinal EcodInstallation ecod = (EcodInstallation) EcodFactory.getEcodDatabase(VERSION);\n\t\tecod.clear();\n\t\tString[] ecodIds = new String[] {\n\t\t\t\t\"e4s1gA1\", \"e4umoB1\", \"e4v0cA1\", \"e4v1af1\", \"e3j7yj1\", \"e4wfcA1\",\"e4b0jP1\",\n\t\t};\n\t\tList<Future<EcodDomain>> futureDomains = new ArrayList<Future<EcodDomain>>();\n\t\tfor(final String ecodId : ecodIds) {\n\t\t\tCallable<EcodDomain> job = new Callable<EcodDomain>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EcodDomain call() throws Exception {\n\t\t\t\t\tlogger.info(\"Running \"+ecodId);\n\t\t\t\t\tEcodDomain d = ecod.getDomainsById(ecodId);\n\t\t\t\t\tlogger.info(\"Finished \"+ecodId);\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Job fetching ECOD \"+ecodId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<EcodDomain> future = ConcurrencyTools.submit(job,ecodId);\n\t\t\tfutureDomains.add(future);\n\t\t}\n\t\tint successful = 0;\n\t\tfor(Future<EcodDomain> future : futureDomains) {\n\t\t\ttry {\n\t\t\t\tEcodDomain domain = future.get(60, TimeUnit.SECONDS);\n\t\t\t\tif(domain != null) {\n\t\t\t\t\tsuccessful++;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" interrupted\",e);\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" error\",e);\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" timed out\",e);\n\t\t\t}\n\n\t\t}\n\t\tassertEquals(ecodIds.length, successful);\n\t}\n\n\t@Test\n\tpublic void testFilterByHierarchy() throws IOException {\n\t\tEcodDatabase ecod = EcodFactory.getEcodDatabase(VERSION);\n\n\t\tList<EcodDomain> filtered;\n\t\tSet<String> expected,actual;\n\n\t\texpected = new HashSet<String>(Arrays.asList(\n\t\t\t\t\"e4il6R1 e4pj0R1 e4pj0r1 e4ub6R1 e4ub8R1\".split(\" \") ));\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106.1\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\n\t\tfiltered = ecod.filterByHierarchy(\"6106\");\n\t\tactual = new HashSet<String>();\n\t\tfor(EcodDomain d : filtered) {\n\t\t\tactual.add(d.getDomainId());\n\t\t}\n\t\tassertEquals(expected,actual);\n\t}\n\n\t@Test\n\tpublic void testVersion() throws IOException {\n\t\tEcodDatabase ecod3 = EcodFactory.getEcodDatabase(\"latest\");\n\t\tString version = ecod3.getVersion();\n\t\tassertNotNull(version);\n\t\tassertNotEquals(\"latest\", version);\n\t}\n\n\t/**\n\t * Parses all known versions. Only fails due to exceptions, so manually check for warnings.\n\t * Hierarchical field warnings are expected for versions prior to develop68.\n\t * @throws IOException\n\t */\n\t//@Ignore // Very slow parsing test\n\t@Test\n\tpublic void testAllVersions() throws IOException {\n\t\t// Fetch latest version\n\t\tEcodDatabase latest = EcodFactory.getEcodDatabase(\"latest\");\n\t\tString latestVersionStr = latest.getVersion();\n\t\tint latestVersion = 0;\n\t\tMatcher match = Pattern.compile(\"develop([0-9]+)\",Pattern.CASE_INSENSITIVE).matcher(latestVersionStr);\n\t\tif(match.matches())\n\t\t\tlatestVersion = Integer.parseInt(match.group(1));\n\t\tlatest = null;\n\n\t\t// List all versions\n\t\tint firstVersion = 45;\n\t\tint lastVersion = Math.max(78,latestVersion);\n\t\tList<String> versions = new ArrayList<String>();\n\t\tversions.add(\"latest\");\n\t\tfor(int version = firstVersion; version<= lastVersion;version++) {\n\t\t\tversions.add(\"develop\"+version);\n\t\t}\n\t\t\n\t\t// Parse all versions\n\t\tfor(String version : versions) {\n\t\t\tEcodInstallation ecod = (EcodInstallation)EcodFactory.getEcodDatabase(version);\n\t\t\tecod.getAllDomains();\n\t\t\tSystem.out.println(version +\" -> \"+ ecod.getVersion());\n\t\t\t\n\t\t\t// Force garbage collection of all soft references\n\t\t\t// This shouldn't be required, but without it we get\n\t\t\t// 'OutOfMemoryError: GC overhead limit exceeded'.\n\t\t\t// Probably this is due to synchronization in EcodFactory blocking\n\t\t\t// the GC during parsing. -Spencer\n\t\t\tecod = null;\n\t\t\tSystem.gc();\n\t\t\ttry {\n\t\t\t\t@SuppressWarnings(\"unused\")\n\t\t\t\tObject[] ignored = new Object[(int) Runtime.getRuntime().maxMemory()];\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// Ignore OME\n\t\t\t}\n\t\t}\n\t}\n}\n","commitMessage":"More ECOD format changes\n\nAll files now have the proper 14-field format\n","test_commitMessage":"Adding long-running ECOD test. Must be run manually.\n\nAlso moves EcodInstallationTest to the right package\n","allZero":false}