{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/internal/SequenceFunctionOrderDetector.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/internal/TestSequenceFunctionOrderDetector.java","prod_time":"2015-12-01 23:01:40","test_time":"2015-12-01 23:01:40","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"dbe75e46265ba439971c66c4b9f22fd737cb2c28","test_commitID":"dbe75e46265ba439971c66c4b9f22fd737cb2c28","isfound":"found test change","originPro":"package org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.Map;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\n\n/**\n * Calls Spencer's method for determining order.\n * This method uses the sequence alignment information\n * to guess the order of symmetry.\n * \n * @author dmyersturnbull\n * @since 4.2.0\n * \n */\npublic class SequenceFunctionOrderDetector implements OrderDetector {\n\n\tprivate int maxSymmetry = 8;\n\tprivate float minimumMetricChange = 0.4f;\n\t\n\tpublic SequenceFunctionOrderDetector() {}\n\n\tpublic SequenceFunctionOrderDetector(int maxSymmetry, float minimumMetricChange) {\n\t\tthis.maxSymmetry = maxSymmetry;\n\t\tthis.minimumMetricChange = minimumMetricChange;\n\t}\n\n\t@Override\n\tpublic int calculateOrder(AFPChain afpChain, Atom[] ca) \n\t\t\tthrows RefinerFailedException {\n\t\ttry {\n\t\t\tMap<Integer,Integer> alignment = \n\t\t\t\t\tAlignmentTools.alignmentAsMap(afpChain);\n\n\t\t\treturn AlignmentTools.getSymmetryOrder(alignment,\n\t\t\t\t\tnew AlignmentTools.IdentityMap<Integer>(), \n\t\t\t\t\tmaxSymmetry, minimumMetricChange);\n\t\t\t\n\t\t} catch (StructureException e) {\n\t\t\tthrow new RefinerFailedException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SequenceFunctionOrderDetector [maxSymmetry=\" + maxSymmetry\n\t\t\t\t+ \", minimumMetricChange=\" + minimumMetricChange + \"]\";\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.Map;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AlignmentTools;\n\n/**\n * Calls Spencer's method for determining order.\n * This method uses the sequence alignment information\n * to guess the order of symmetry.\n * \n * @author dmyersturnbull\n * @since 4.2.0\n * \n */\npublic class SequenceFunctionOrderDetector implements OrderDetector {\n\n\tprivate int maxSymmetry = 8;\n\tprivate float minimumMetricChange = 0.4f;\n\t\n\tpublic SequenceFunctionOrderDetector() {}\n\n\tpublic SequenceFunctionOrderDetector(int maxSymmetry, float minimumMetricChange) {\n\t\tthis.maxSymmetry = maxSymmetry;\n\t\tthis.minimumMetricChange = minimumMetricChange;\n\t}\n\n\t@Override\n\tpublic int calculateOrder(AFPChain afpChain, Atom[] ca) \n\t\t\tthrows RefinerFailedException {\n\t\ttry {\n\t\t\tMap<Integer,Integer> alignment = \n\t\t\t\t\tAlignmentTools.alignmentAsMap(afpChain);\n\n\t\t\treturn AlignmentTools.getSymmetryOrder(alignment,\n\t\t\t\t\tnew AlignmentTools.IdentityMap<Integer>(), \n\t\t\t\t\tmaxSymmetry, minimumMetricChange);\n\t\t\t\n\t\t} catch (StructureException e) {\n\t\t\tthrow new RefinerFailedException(e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SequenceFunctionOrderDetector [maxSymmetry=\" + maxSymmetry\n\t\t\t\t+ \", minimumMetricChange=\" + minimumMetricChange + \"]\";\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.symmetry.internal;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.RefinerFailedException;\nimport org.biojava.nbio.structure.symmetry.internal.SequenceFunctionOrderDetector;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.junit.Test;\n\n/**\n * Originally part of {@link CeSymmTest}.\n * @author Spencer Bliven\n */\npublic class TestSequenceFunctionOrderDetector {\n\n\t@Test\n\tpublic void testGetSymmetryOrder() \n\t\t\tthrows IOException, StructureException, RefinerFailedException {\n\t\t// List of alignments to try, along with proper symmetry\n\t\tMap<String,Integer> orderMap = new HashMap<String,Integer>();\n\t\torderMap.put(\"1itb.A\",3); // b-trefoil, C3\n\t\torderMap.put(\"1tim.A\",2); // tim-barrel, C8\n\t\t//orderMap.put(\"d1p9ha_\",-1); // not rotational symmetry\n\t\torderMap.put(\"3HKE.A\",2); // very questionable alignment\n\t\torderMap.put(\"d1jlya1\",3); // a very nice trefoil\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tfor(String name : orderMap.keySet()) {\n\t\t\tCeSymm ce = new CeSymm();\n\t\t\tce.getParameters().setRefineMethod(RefineMethod.NOT_REFINED);\n\t\t\tAtom[] ca1 = cache.getAtoms(name);\n\t\t\t\n\t\t\tce.analyzeLevel(ca1);\n\t\t\tAFPChain afpChain = ce.getSelfAlignments().get(0);\n\t\t\t\n\t\t\tint order = new SequenceFunctionOrderDetector().calculateOrder(afpChain, ca1);\n\t\t\t\n\t\t\tassertEquals(\"Wrong order for \"+name,orderMap.get(name).intValue(), order);\n\t\t}\n\t}\n\t\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.RefinerFailedException;\nimport org.biojava.nbio.structure.symmetry.internal.SequenceFunctionOrderDetector;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.junit.Test;\n\n/**\n * Originally part of {@link CeSymmTest}.\n * @author Spencer Bliven\n */\npublic class TestSequenceFunctionOrderDetector {\n\n\t@Test\n\tpublic void testGetSymmetryOrder() \n\t\t\tthrows IOException, StructureException, RefinerFailedException {\n\t\t// List of alignments to try, along with proper symmetry\n\t\tMap<String,Integer> orderMap = new HashMap<String,Integer>();\n\t\torderMap.put(\"1itb.A\",3); // b-trefoil, C3\n\t\torderMap.put(\"1tim.A\",2); // tim-barrel, C8\n\t\t//orderMap.put(\"d1p9ha_\",-1); // not rotational symmetry\n\t\torderMap.put(\"3HKE.A\",2); // very questionable alignment\n\t\torderMap.put(\"d1jlya1\",3); // a very nice trefoil\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tfor(String name : orderMap.keySet()) {\n\t\t\tCeSymm ce = new CeSymm();\n\t\t\tce.getParameters().setRefineMethod(RefineMethod.NOT_REFINED);\n\t\t\tAtom[] ca1 = cache.getAtoms(name);\n\t\t\t\n\t\t\tce.analyzeLevel(ca1);\n\t\t\tAFPChain afpChain = ce.getSelfAlignments().get(0);\n\t\t\t\n\t\t\tint order = new SequenceFunctionOrderDetector().calculateOrder(afpChain, ca1);\n\t\t\t\n\t\t\tassertEquals(\"Wrong order for \"+name,orderMap.get(name).intValue(), order);\n\t\t}\n\t}\n\t\n}\n","commitMessage":"Adding biojava license statements","test_commitMessage":"Adding biojava license statements","allZero":true}