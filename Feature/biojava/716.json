{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/core/Subunits.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/core/TestSubunits.java","prod_time":"2016-08-03 00:38:02","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e6eac12029d5026d1a5f81289f92aa2c50f1db51","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.core;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClustererMethod;\nimport org.biojava.nbio.structure.geometry.MomentsOfInertia;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport java.util.*;\n\n/**\n * A bean to represent information about the set of {@link Subunit} being\n * considered for symmetry detection. This class is a helper for the\n * {@link QuatSymmetryDetector} algorithm, since it calculates the\n * {@link MomentsOfInertia} and the centroids of each Subunit.\n * <p>\n * Delete public modifier when finished.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * \n */\npublic class Subunits {\n\n\tprivate List<Point3d[]> caCoords = new ArrayList<Point3d[]>();\n\tprivate List<Integer> sequenceClusterIds = new ArrayList<Integer>();\n\n\t@Deprecated\n\t// Return variable, guessed from clusters\n\tprivate List<Boolean> pseudoStoichiometry = new ArrayList<Boolean>();\n\t@Deprecated\n\t// Return variable, no longer valid\n\tprivate List<Double> minSequenceIdentity = new ArrayList<Double>();\n\t@Deprecated\n\t// Return variable, no longer valid\n\tprivate List<Double> maxSequenceIdentity = new ArrayList<Double>();\n\n\t@Deprecated\n\t// Subunits are not tied to a chain, used for coloring\n\tprivate List<String> chainIds = new ArrayList<String>();\n\t@Deprecated\n\t// Subunits are not tied to a model? used for coloring\n\tprivate List<Integer> modelNumbers = new ArrayList<Integer>();\n\n\tprivate List<Integer> folds = new ArrayList<Integer>();\n\tprivate List<Point3d> originalCenters = new ArrayList<Point3d>();\n\tprivate List<Point3d> centers = new ArrayList<Point3d>();\n\tprivate List<Vector3d> unitVectors = new ArrayList<Vector3d>();\n\n\t@Deprecated\n\t// Return variable, should be in the clusters\n\tprivate int nucleicAcidChainCount = 0;\n\t@Deprecated\n\t// This should be in QuatSymmetryResults\n\tprivate boolean pseudoSymmetric = false;\n\n\tprivate Point3d centroid;\n\tprivate MomentsOfInertia momentsOfInertia = new MomentsOfInertia();\n\n\t/**\n\t * All input Lists should contain one element per subunit.\n\t * \n\t * @param caCoords\n\t *            CA coordinates of all subunits\n\t * @param sequenceClusterIds\n\t *            ID of the cluster that each subunit belongs to\n\t * @param pseudoStoichiometry\n\t *            Whether pseudosymmetry was used when clustering the subunit\n\t * @param minSequenceIdentity\n\t *            Minimum sequence identity to other cluster members\n\t * @param maxSequenceIdentity\n\t *            Maximum sequence identity to other cluster members\n\t * @param folds\n\t *            Valid symmetry orders for this stoichiometry\n\t * @param chainIds\n\t *            Chain ID for the subunit\n\t * @param modelNumbers\n\t *            Model number for the subunit\n\t */\n\t@Deprecated\n\tpublic Subunits(List<Point3d[]> caCoords, List<Integer> sequenceClusterIds,\n\t\t\tList<Boolean> pseudoStoichiometry,\n\t\t\tList<Double> minSequenceIdentity, List<Double> maxSequenceIdentity,\n\t\t\tList<Integer> folds, List<String> chainIds,\n\t\t\tList<Integer> modelNumbers) {\n\t\tthis.caCoords = caCoords;\n\t\tthis.sequenceClusterIds = sequenceClusterIds;\n\t\tthis.pseudoStoichiometry = pseudoStoichiometry;\n\t\tthis.minSequenceIdentity = minSequenceIdentity;\n\t\tthis.maxSequenceIdentity = maxSequenceIdentity;\n\t\tthis.folds = folds;\n\t\tthis.chainIds = chainIds;\n\t\tthis.modelNumbers = modelNumbers;\n\t}\n\n\t/**\n\t * Converts the List of {@link SubunitCluster} to a Subunit object.\n\t * \n\t * @param clusters\n\t *            List of SubunitCluster\n\t */\n\tpublic Subunits(List<SubunitCluster> clusters) {\n\n\t\t// Loop through all subunits in the clusters and fill Lists\n\t\tfor (int c = 0; c < clusters.size(); c++) {\n\n\t\t\t// TODO we should remove these variables\n\t\t\tminSequenceIdentity.add(0.0);\n\t\t\tmaxSequenceIdentity.add(0.0);\n\n\t\t\t// Pseudostoichiometry means one structural cluster\n\t\t\tSubunitClustererMethod method = clusters.get(c)\n\t\t\t\t\t.getClustererMethod();\n\t\t\tboolean ps = (method == SubunitClustererMethod.STRUCTURE);\n\t\t\tps = (ps || method == SubunitClustererMethod.INTERNAL_SYMMETRY);\n\n\t\t\tfor (int s = 0; s < clusters.get(c).size(); s++) {\n\t\t\t\tsequenceClusterIds.add(c);\n\t\t\t\tpseudoStoichiometry.add(ps);\n\n\t\t\t\tAtom[] atoms = clusters.get(c).getAlignedAtomsSubunit(s);\n\n\t\t\t\t// Convert atoms to points\n\t\t\t\tPoint3d[] points = new Point3d[atoms.length];\n\t\t\t\tfor (int i = 0; i < atoms.length; i++)\n\t\t\t\t\tpoints[i] = new Point3d(atoms[i].getCoords());\n\n\t\t\t\tcaCoords.add(points);\n\n\t\t\t\t// TODO guess them chain and model (very ugly)\n\t\t\t\tChain chain = atoms[0].getGroup().getChain();\n\t\t\t\tString cid = chain.getId();\n\t\t\t\tchainIds.add(cid);\n\n\t\t\t\tint model = 0;\n\t\t\t\tfor (int m = 0; m < chain.getStructure().nrModels(); m++) {\n\t\t\t\t\tif (chain.getStructure().getModel(m).contains(chain)) {\n\t\t\t\t\t\tmodel = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodelNumbers.add(model);\n\t\t\t}\n\t\t}\n\n\t\t// Fill in the folds with the function\n\t\tList<Integer> stoichiometry = new ArrayList<Integer>(clusters.size());\n\t\tfor (int id = 0; id < clusters.size(); id++) {\n\t\t\tint size = clusters.get(id).size();\n\t\t\tstoichiometry.add(size);\n\t\t}\n\t\tfolds = getValidFolds(stoichiometry);\n\t}\n\n\tpublic List<Point3d[]> getTraces() {\n\t\treturn caCoords;\n\t}\n\n\tpublic int getSubunitCount() {\n\t\trun();\n\t\tif (centers == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn centers.size();\n\t}\n\n\tpublic List<Integer> getSequenceClusterIds() {\n\t\treturn sequenceClusterIds;\n\t}\n\n\tpublic boolean isPseudoStoichiometric() {\n\t\tfor (Boolean b : pseudoStoichiometry) {\n\t\t\tif (b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isPseudoSymmetric() {\n\t\treturn pseudoSymmetric;\n\t}\n\n\tpublic void setPseudoSymmetric(boolean pseudoSymmetric) {\n\t\tthis.pseudoSymmetric = pseudoSymmetric;\n\t}\n\n\tpublic double getMinSequenceIdentity() {\n\t\tdouble minId = 1.0;\n\t\tfor (double seqId : minSequenceIdentity) {\n\t\t\tminId = Math.min(seqId, minId);\n\t\t}\n\t\treturn minId;\n\t}\n\n\tpublic double getMaxSequenceIdentity() {\n\t\tdouble maxId = 1.0;\n\t\tfor (double seqId : maxSequenceIdentity) {\n\t\t\tmaxId = Math.min(seqId, maxId);\n\t\t}\n\t\treturn maxId;\n\t}\n\n\tpublic List<String> getChainIds() {\n\t\treturn chainIds;\n\t}\n\n\tpublic List<Integer> getModelNumbers() {\n\t\treturn modelNumbers;\n\t}\n\n\tpublic List<Integer> getFolds() {\n\t\treturn folds;\n\t}\n\n\tpublic String getStoichiometry() {\n\n\t\t// count number of members in each cluster\n\t\tMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\tfor (Integer id : sequenceClusterIds) {\n\t\t\tInteger value = map.get(id);\n\t\t\tif (value == null) {\n\t\t\t\tvalue = new Integer(1);\n\t\t\t} else {\n\t\t\t\tvalue++;\n\t\t\t}\n\t\t\tmap.put(id, value);\n\t\t}\n\n\t\tList<Integer> stoichiometries = new ArrayList<Integer>(map.size());\n\t\tfor (Integer key : map.keySet())\n\t\t\tstoichiometries.add(map.get(key));\n\t\tCollections.sort(stoichiometries);\n\t\tCollections.reverse(stoichiometries);\n\n\t\t// build formula string\n\t\tString alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\t\tStringBuilder formula = new StringBuilder();\n\t\tfor (int i = 0; i < stoichiometries.size(); i++) {\n\t\t\tString key = \"?\";\n\t\t\tif (i < alpha.length())\n\t\t\t\tkey = alpha.substring(i, i + 1);\n\n\t\t\tformula.append(key);\n\t\t\tif (stoichiometries.get(i) > 1)\n\t\t\t\tformula.append(stoichiometries.get(i));\n\t\t}\n\n\t\treturn formula.toString();\n\t}\n\n\tpublic int getCalphaCount() {\n\t\tint count = 0;\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tcount += trace.length;\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic int getLargestSubunit() {\n\t\tint index = -1;\n\t\tint maxLength = 0;\n\t\tfor (int i = 0; i < caCoords.size(); i++) {\n\t\t\tint length = caCoords.get(i).length;\n\t\t\tif (length > maxLength) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\tpublic List<Point3d> getCenters() {\n\t\trun();\n\t\treturn centers;\n\t}\n\n\tpublic List<Vector3d> getUnitVectors() {\n\t\trun();\n\t\treturn unitVectors;\n\t}\n\n\tpublic List<Point3d> getOriginalCenters() {\n\t\trun();\n\t\treturn originalCenters;\n\t}\n\n\tpublic Point3d getCentroid() {\n\t\trun();\n\t\treturn centroid;\n\t}\n\n\tpublic MomentsOfInertia getMomentsOfInertia() {\n\t\trun();\n\t\treturn momentsOfInertia;\n\t}\n\n\t/**\n\t * @return the nucleicAcidChainCount\n\t */\n\tpublic int getNucleicAcidChainCount() {\n\t\trun();\n\t\treturn nucleicAcidChainCount;\n\t}\n\n\t/**\n\t * @param nucleicAcidChainCount\n\t *            the nucleicAcidChainCount to set\n\t */\n\tpublic void setNucleicAcidChainCount(int nucleicAcidChainCount) {\n\t\tthis.nucleicAcidChainCount = nucleicAcidChainCount;\n\t}\n\n\tpublic boolean overlaps(Subunits subunits) {\n\t\tSet<String> set1 = getSignatures(this);\n\t\tSet<String> set2 = getSignatures(subunits);\n\t\tset1.retainAll(set2);\n\t\treturn set1.size() > 0;\n\t}\n\n\tpublic boolean contains(Subunits subunits) {\n\t\tSet<String> set1 = getSignatures(this);\n\t\tSet<String> set2 = getSignatures(subunits);\n\t\treturn set1.containsAll(set2);\n\t}\n\n\tprivate static Set<String> getSignatures(Subunits subunits) {\n\t\tSet<String> set = new HashSet<String>(subunits.getSubunitCount());\n\t\tfor (int i = 0; i < subunits.getSubunitCount(); i++) {\n\t\t\tset.add(subunits.getChainIds().get(i) + \"_\"\n\t\t\t\t\t+ subunits.getModelNumbers().get(i));\n\t\t}\n\t\treturn set;\n\t}\n\n\tprivate void run() {\n\t\tif (centers.size() > 0) {\n\t\t\treturn;\n\t\t}\n\t\tcalcOriginalCenters();\n\t\tcalcCentroid();\n\t\tcalcCenters();\n\t\tcalcMomentsOfIntertia();\n\t}\n\n\tprivate void calcOriginalCenters() {\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tPoint3d com = SuperPosition.centroid(trace);\n\t\t\toriginalCenters.add(com);\n\t\t}\n\t}\n\n\tprivate void calcCentroid() {\n\t\tPoint3d[] orig = originalCenters.toArray(new Point3d[originalCenters\n\t\t\t\t.size()]);\n\t\tcentroid = SuperPosition.centroid(orig);\n\t}\n\n\tprivate void calcCenters() {\n\t\tfor (Point3d p : originalCenters) {\n\t\t\tPoint3d c = new Point3d(p);\n\t\t\tc.sub(centroid);\n\t\t\tcenters.add(c);\n\t\t\tVector3d v = new Vector3d(c);\n\t\t\tv.normalize();\n\t\t\tunitVectors.add(v);\n\t\t}\n\t}\n\n\tpublic Point3d getLowerBound() {\n\t\tPoint3d lower = new Point3d();\n\t\tfor (Point3d p : centers) {\n\t\t\tif (p.x < lower.x) {\n\t\t\t\tlower.x = p.x;\n\t\t\t}\n\t\t\tif (p.y < lower.y) {\n\t\t\t\tlower.y = p.y;\n\t\t\t}\n\t\t\tif (p.z < lower.z) {\n\t\t\t\tlower.z = p.z;\n\t\t\t}\n\t\t}\n\t\treturn lower;\n\t}\n\n\tpublic Point3d getUpperBound() {\n\t\tPoint3d upper = new Point3d();\n\t\tfor (Point3d p : centers) {\n\t\t\tif (p.x > upper.x) {\n\t\t\t\tupper.x = p.x;\n\t\t\t}\n\t\t\tif (p.y > upper.y) {\n\t\t\t\tupper.y = p.y;\n\t\t\t}\n\t\t\tif (p.z > upper.z) {\n\t\t\t\tupper.z = p.z;\n\t\t\t}\n\t\t}\n\t\treturn upper;\n\t}\n\n\tprivate void calcMomentsOfIntertia() {\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tfor (Point3d p : trace) {\n\t\t\t\tmomentsOfInertia.addPoint(p, 1.0f);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each chain cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tif (stoichiometry.isEmpty())\n\t\t\treturn denominators;\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.core;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.cluster.SubunitCluster;\nimport org.biojava.nbio.structure.cluster.SubunitClustererMethod;\nimport org.biojava.nbio.structure.geometry.CalcPoint;\nimport org.biojava.nbio.structure.geometry.MomentsOfInertia;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport java.util.*;\n\n/**\n * A bean to represent information about the set of {@link Subunit} being\n * considered for symmetry detection. This class is a helper for the\n * {@link QuatSymmetryDetector} algorithm, since it calculates the\n * {@link MomentsOfInertia} and the centroids of each Subunit.\n * <p>\n * Delete public modifier when finished.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * \n */\npublic class Subunits {\n\n\tprivate List<Point3d[]> caCoords = new ArrayList<Point3d[]>();\n\tprivate List<Integer> sequenceClusterIds = new ArrayList<Integer>();\n\n\t@Deprecated\n\t// Return variable, guessed from clusters\n\tprivate List<Boolean> pseudoStoichiometry = new ArrayList<Boolean>();\n\t@Deprecated\n\t// Return variable, no longer valid\n\tprivate List<Double> minSequenceIdentity = new ArrayList<Double>();\n\t@Deprecated\n\t// Return variable, no longer valid\n\tprivate List<Double> maxSequenceIdentity = new ArrayList<Double>();\n\n\t@Deprecated\n\t// Subunits are not tied to a chain, used for coloring\n\tprivate List<String> chainIds = new ArrayList<String>();\n\t@Deprecated\n\t// Subunits are not tied to a model? used for coloring\n\tprivate List<Integer> modelNumbers = new ArrayList<Integer>();\n\n\tprivate List<Integer> folds = new ArrayList<Integer>();\n\tprivate List<Point3d> originalCenters = new ArrayList<Point3d>();\n\tprivate List<Point3d> centers = new ArrayList<Point3d>();\n\tprivate List<Vector3d> unitVectors = new ArrayList<Vector3d>();\n\n\t@Deprecated\n\t// Return variable, should be in the clusters\n\tprivate int nucleicAcidChainCount = 0;\n\t@Deprecated\n\t// This should be in QuatSymmetryResults\n\tprivate boolean pseudoSymmetric = false;\n\n\tprivate Point3d centroid;\n\tprivate MomentsOfInertia momentsOfInertia = new MomentsOfInertia();\n\n\t/**\n\t * All input Lists should contain one element per subunit.\n\t * \n\t * @param caCoords\n\t *            CA coordinates of all subunits\n\t * @param sequenceClusterIds\n\t *            ID of the cluster that each subunit belongs to\n\t * @param pseudoStoichiometry\n\t *            Whether pseudosymmetry was used when clustering the subunit\n\t * @param minSequenceIdentity\n\t *            Minimum sequence identity to other cluster members\n\t * @param maxSequenceIdentity\n\t *            Maximum sequence identity to other cluster members\n\t * @param folds\n\t *            Valid symmetry orders for this stoichiometry\n\t * @param chainIds\n\t *            Chain ID for the subunit\n\t * @param modelNumbers\n\t *            Model number for the subunit\n\t */\n\t@Deprecated\n\tpublic Subunits(List<Point3d[]> caCoords, List<Integer> sequenceClusterIds,\n\t\t\tList<Boolean> pseudoStoichiometry,\n\t\t\tList<Double> minSequenceIdentity, List<Double> maxSequenceIdentity,\n\t\t\tList<Integer> folds, List<String> chainIds,\n\t\t\tList<Integer> modelNumbers) {\n\t\tthis.caCoords = caCoords;\n\t\tthis.sequenceClusterIds = sequenceClusterIds;\n\t\tthis.pseudoStoichiometry = pseudoStoichiometry;\n\t\tthis.minSequenceIdentity = minSequenceIdentity;\n\t\tthis.maxSequenceIdentity = maxSequenceIdentity;\n\t\tthis.folds = folds;\n\t\tthis.chainIds = chainIds;\n\t\tthis.modelNumbers = modelNumbers;\n\t}\n\n\t/**\n\t * Converts the List of {@link SubunitCluster} to a Subunit object.\n\t * \n\t * @param clusters\n\t *            List of SubunitCluster\n\t */\n\tpublic Subunits(List<SubunitCluster> clusters) {\n\n\t\t// Loop through all subunits in the clusters and fill Lists\n\t\tfor (int c = 0; c < clusters.size(); c++) {\n\n\t\t\t// TODO we should remove these variables\n\t\t\tminSequenceIdentity.add(0.0);\n\t\t\tmaxSequenceIdentity.add(0.0);\n\n\t\t\t// Pseudostoichiometry means one structural cluster\n\t\t\tSubunitClustererMethod method = clusters.get(c)\n\t\t\t\t\t.getClustererMethod();\n\t\t\tboolean ps = (method == SubunitClustererMethod.STRUCTURE);\n\t\t\tps = (ps || method == SubunitClustererMethod.INTERNAL_SYMMETRY);\n\n\t\t\tfor (int s = 0; s < clusters.get(c).size(); s++) {\n\t\t\t\tsequenceClusterIds.add(c);\n\t\t\t\tpseudoStoichiometry.add(ps);\n\n\t\t\t\tAtom[] atoms = clusters.get(c).getAlignedAtomsSubunit(s);\n\n\t\t\t\t// Convert atoms to points\n\t\t\t\tPoint3d[] points = new Point3d[atoms.length];\n\t\t\t\tfor (int i = 0; i < atoms.length; i++)\n\t\t\t\t\tpoints[i] = new Point3d(atoms[i].getCoords());\n\n\t\t\t\tcaCoords.add(points);\n\n\t\t\t\t// TODO guess them chain and model (very ugly)\n\t\t\t\tChain chain = atoms[0].getGroup().getChain();\n\t\t\t\tString cid = chain.getId();\n\t\t\t\tchainIds.add(cid);\n\n\t\t\t\tint model = 0;\n\t\t\t\tfor (int m = 0; m < chain.getStructure().nrModels(); m++) {\n\t\t\t\t\tif (chain.getStructure().getModel(m).contains(chain)) {\n\t\t\t\t\t\tmodel = m;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodelNumbers.add(model);\n\t\t\t}\n\t\t}\n\n\t\t// Fill in the folds with the function\n\t\tList<Integer> stoichiometry = new ArrayList<Integer>(clusters.size());\n\t\tfor (int id = 0; id < clusters.size(); id++) {\n\t\t\tint size = clusters.get(id).size();\n\t\t\tstoichiometry.add(size);\n\t\t}\n\t\tfolds = getValidFolds(stoichiometry);\n\t}\n\n\tpublic List<Point3d[]> getTraces() {\n\t\treturn caCoords;\n\t}\n\n\tpublic int getSubunitCount() {\n\t\trun();\n\t\tif (centers == null) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn centers.size();\n\t}\n\n\tpublic List<Integer> getSequenceClusterIds() {\n\t\treturn sequenceClusterIds;\n\t}\n\n\tpublic boolean isPseudoStoichiometric() {\n\t\tfor (Boolean b : pseudoStoichiometry) {\n\t\t\tif (b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic boolean isPseudoSymmetric() {\n\t\treturn pseudoSymmetric;\n\t}\n\n\tpublic void setPseudoSymmetric(boolean pseudoSymmetric) {\n\t\tthis.pseudoSymmetric = pseudoSymmetric;\n\t}\n\n\tpublic double getMinSequenceIdentity() {\n\t\tdouble minId = 1.0;\n\t\tfor (double seqId : minSequenceIdentity) {\n\t\t\tminId = Math.min(seqId, minId);\n\t\t}\n\t\treturn minId;\n\t}\n\n\tpublic double getMaxSequenceIdentity() {\n\t\tdouble maxId = 1.0;\n\t\tfor (double seqId : maxSequenceIdentity) {\n\t\t\tmaxId = Math.min(seqId, maxId);\n\t\t}\n\t\treturn maxId;\n\t}\n\n\tpublic List<String> getChainIds() {\n\t\treturn chainIds;\n\t}\n\n\tpublic List<Integer> getModelNumbers() {\n\t\treturn modelNumbers;\n\t}\n\n\tpublic List<Integer> getFolds() {\n\t\treturn folds;\n\t}\n\n\tpublic String getStoichiometry() {\n\n\t\t// count number of members in each cluster\n\t\tMap<Integer, Integer> map = new TreeMap<Integer, Integer>();\n\t\tfor (Integer id : sequenceClusterIds) {\n\t\t\tInteger value = map.get(id);\n\t\t\tif (value == null) {\n\t\t\t\tvalue = new Integer(1);\n\t\t\t} else {\n\t\t\t\tvalue++;\n\t\t\t}\n\t\t\tmap.put(id, value);\n\t\t}\n\n\t\tList<Integer> stoichiometries = new ArrayList<Integer>(map.size());\n\t\tfor (Integer key : map.keySet())\n\t\t\tstoichiometries.add(map.get(key));\n\t\tCollections.sort(stoichiometries);\n\t\tCollections.reverse(stoichiometries);\n\n\t\t// build formula string\n\t\tString alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\t\tStringBuilder formula = new StringBuilder();\n\t\tfor (int i = 0; i < stoichiometries.size(); i++) {\n\t\t\tString key = \"?\";\n\t\t\tif (i < alpha.length())\n\t\t\t\tkey = alpha.substring(i, i + 1);\n\n\t\t\tformula.append(key);\n\t\t\tif (stoichiometries.get(i) > 1)\n\t\t\t\tformula.append(stoichiometries.get(i));\n\t\t}\n\n\t\treturn formula.toString();\n\t}\n\n\tpublic int getCalphaCount() {\n\t\tint count = 0;\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tcount += trace.length;\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic int getLargestSubunit() {\n\t\tint index = -1;\n\t\tint maxLength = 0;\n\t\tfor (int i = 0; i < caCoords.size(); i++) {\n\t\t\tint length = caCoords.get(i).length;\n\t\t\tif (length > maxLength) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\n\tpublic List<Point3d> getCenters() {\n\t\trun();\n\t\treturn centers;\n\t}\n\n\tpublic List<Vector3d> getUnitVectors() {\n\t\trun();\n\t\treturn unitVectors;\n\t}\n\n\tpublic List<Point3d> getOriginalCenters() {\n\t\trun();\n\t\treturn originalCenters;\n\t}\n\n\tpublic Point3d getCentroid() {\n\t\trun();\n\t\treturn centroid;\n\t}\n\n\tpublic MomentsOfInertia getMomentsOfInertia() {\n\t\trun();\n\t\treturn momentsOfInertia;\n\t}\n\n\t/**\n\t * @return the nucleicAcidChainCount\n\t */\n\tpublic int getNucleicAcidChainCount() {\n\t\trun();\n\t\treturn nucleicAcidChainCount;\n\t}\n\n\t/**\n\t * @param nucleicAcidChainCount\n\t *            the nucleicAcidChainCount to set\n\t */\n\tpublic void setNucleicAcidChainCount(int nucleicAcidChainCount) {\n\t\tthis.nucleicAcidChainCount = nucleicAcidChainCount;\n\t}\n\n\tpublic boolean overlaps(Subunits subunits) {\n\t\tSet<String> set1 = getSignatures(this);\n\t\tSet<String> set2 = getSignatures(subunits);\n\t\tset1.retainAll(set2);\n\t\treturn set1.size() > 0;\n\t}\n\n\tpublic boolean contains(Subunits subunits) {\n\t\tSet<String> set1 = getSignatures(this);\n\t\tSet<String> set2 = getSignatures(subunits);\n\t\treturn set1.containsAll(set2);\n\t}\n\n\tprivate static Set<String> getSignatures(Subunits subunits) {\n\t\tSet<String> set = new HashSet<String>(subunits.getSubunitCount());\n\t\tfor (int i = 0; i < subunits.getSubunitCount(); i++) {\n\t\t\tset.add(subunits.getChainIds().get(i) + \"_\"\n\t\t\t\t\t+ subunits.getModelNumbers().get(i));\n\t\t}\n\t\treturn set;\n\t}\n\n\tprivate void run() {\n\t\tif (centers.size() > 0) {\n\t\t\treturn;\n\t\t}\n\t\tcalcOriginalCenters();\n\t\tcalcCentroid();\n\t\tcalcCenters();\n\t\tcalcMomentsOfIntertia();\n\t}\n\n\tprivate void calcOriginalCenters() {\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tPoint3d com = CalcPoint.centroid(trace);\n\t\t\toriginalCenters.add(com);\n\t\t}\n\t}\n\n\tprivate void calcCentroid() {\n\t\tPoint3d[] orig = originalCenters.toArray(new Point3d[originalCenters\n\t\t\t\t.size()]);\n\t\tcentroid = CalcPoint.centroid(orig);\n\t}\n\n\tprivate void calcCenters() {\n\t\tfor (Point3d p : originalCenters) {\n\t\t\tPoint3d c = new Point3d(p);\n\t\t\tc.sub(centroid);\n\t\t\tcenters.add(c);\n\t\t\tVector3d v = new Vector3d(c);\n\t\t\tv.normalize();\n\t\t\tunitVectors.add(v);\n\t\t}\n\t}\n\n\tpublic Point3d getLowerBound() {\n\t\tPoint3d lower = new Point3d();\n\t\tfor (Point3d p : centers) {\n\t\t\tif (p.x < lower.x) {\n\t\t\t\tlower.x = p.x;\n\t\t\t}\n\t\t\tif (p.y < lower.y) {\n\t\t\t\tlower.y = p.y;\n\t\t\t}\n\t\t\tif (p.z < lower.z) {\n\t\t\t\tlower.z = p.z;\n\t\t\t}\n\t\t}\n\t\treturn lower;\n\t}\n\n\tpublic Point3d getUpperBound() {\n\t\tPoint3d upper = new Point3d();\n\t\tfor (Point3d p : centers) {\n\t\t\tif (p.x > upper.x) {\n\t\t\t\tupper.x = p.x;\n\t\t\t}\n\t\t\tif (p.y > upper.y) {\n\t\t\t\tupper.y = p.y;\n\t\t\t}\n\t\t\tif (p.z > upper.z) {\n\t\t\t\tupper.z = p.z;\n\t\t\t}\n\t\t}\n\t\treturn upper;\n\t}\n\n\tprivate void calcMomentsOfIntertia() {\n\t\tfor (Point3d[] trace : caCoords) {\n\t\t\tfor (Point3d p : trace) {\n\t\t\t\tmomentsOfInertia.addPoint(p, 1.0f);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find valid symmetry orders for a given stoichiometry. For instance, an\n\t * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n\t * decompositions.\n\t * \n\t * @param stoichiometry\n\t *            List giving the number of copies in each chain cluster\n\t * @return The common factors of the stoichiometry\n\t */\n\tpublic static List<Integer> getValidFolds(List<Integer> stoichiometry) {\n\n\t\tList<Integer> denominators = new ArrayList<Integer>();\n\n\t\tif (stoichiometry.isEmpty())\n\t\t\treturn denominators;\n\n\t\tint nChains = Collections.max(stoichiometry);\n\n\t\t// Remove duplicate stoichiometries\n\t\tSet<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n\n\t\t// find common denominators\n\t\tfor (int d = 1; d <= nChains; d++) {\n\t\t\tboolean isDivisable = true;\n\t\t\tfor (Integer n : nominators) {\n\t\t\t\tif (n % d != 0) {\n\t\t\t\t\tisDivisable = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDivisable) {\n\t\t\t\tdenominators.add(d);\n\t\t\t}\n\t\t}\n\t\treturn denominators;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.core;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Test;\n\n/**\n * Test the methods in {@link Subunits} class.\n * \n * @author Peter Rose\n * @author Aleix Lafita\n *\n */\npublic class TestSubunits {\n\n\t/**\n\t * Test {@link Subunits#getValidFolds(List)}.\n\t */\n\t@Test\n\tpublic void testValidFolds() {\n\n\t\tList<Integer> stoich;\n\t\tList<Integer> folds;\n\t\tList<Integer> expected;\n\n\t\tstoich = Arrays.asList(6, 4);\n\t\texpected = Arrays.asList(1, 2);\n\t\tfolds = Subunits.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 6);\n\t\texpected = Arrays.asList(1, 2, 3, 6);\n\t\tfolds = Subunits.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 3);\n\t\texpected = Arrays.asList(1, 3);\n\t\tfolds = Subunits.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t\tstoich = Arrays.asList(6, 5);\n\t\texpected = Arrays.asList(1);\n\t\tfolds = Subunits.getValidFolds(stoich);\n\t\tassertEquals(\"Wrong folds for \" + stoich, expected, folds);\n\n\t}\n}\n","changedTest":"","commitMessage":"Create CalcPoint Class to hold general methods with Point3d #545","test_commitMessage":"","allZero":false}