{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/SoftHashMap.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/SoftHashMapTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":3,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":3,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    PDB web development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n *\n * Created on Mar 26, 2009\n * Created by ap3\n *\n */\n\npackage org.biojava.nbio.core.util;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.AbstractMap;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** A in memory cache using soft references. (can be garbage collected)\n * This code is based on: http://java-interview-faqs.blogspot.com/2008/09/building-faster-and-efficient-cache.html\n * <p/>\n * Note that entrySet() is not implemented and therefore many methods such as keySet(),\n * containsKey(), values() etc do not work.\n * <p/>\n * This class is therefore best used as a cache simply to put and get items by a known key\n */\npublic class SoftHashMap<K, V> extends AbstractMap<K, V> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(SoftHashMap.class);\n\n\tpublic static final int DEFAULT_LIMIT = 1;\n\n\t/** The internal HashMap that stores SoftReference to actual data. */\n\tprivate final Map<K, SoftReference<V>> map = new HashMap<K, SoftReference<V>>();\n\n\t/** Maximum Number of references you dont want GC to collect. */\n\tprivate final int max_limit;\n\n\t/** The FIFO list of hard references, order of last access. */\n\tprivate final LinkedList<V> hardCache = new LinkedList<V>();\n\n\t/** Reference queue for cleared SoftReference objects. */\n\tprivate final ReferenceQueue<V> queue = new ReferenceQueue<V>();\n\n\tpublic SoftHashMap() {\n\t\tthis(1000);\n\t}\n\n\t/**\n\t * @param hardSize A maximum number of items to maintain hard references to\n\t * that will not be eligible for garbage collection\n\t */\n\tpublic SoftHashMap(int hardSize) {\n\t\tmax_limit = hardSize;\n\t}\n\n\t@Override\n\tpublic V get(Object key) {\n\n\t\tV result = null;\n\n\t\t// We get the SoftReference represented by that key\n\t\tSoftReference<V> soft_ref = map.get(key);\n\n\t\tif (soft_ref != null) {\n\t\t\ttry {\n\t\t\t\t// From the SoftReference we get the value, which can be\n\t\t\t\t// null if it was not in the map, or it was removed in\n\t\t\t\t// the clearGCCollected() method defined below\n\n\t\t\t\tresult = soft_ref.get();\n\t\t\t\tif (result == null) {\n\t\t\t\t\t// If the value has been garbage collected, remove the\n\t\t\t\t\t// entry from the HashMap.\n\t\t\t\t\tmap.remove(key);\n\t\t\t\t} else {\n\t\t\t\t\t// We now add this object to the beginning of the hard\n\t\t\t\t\t// reference queue. One reference can occur more than\n\t\t\t\t\t// once, because lookups of the FIFO queue are slow, so\n\t\t\t\t\t// we don't want to search through it each time to remove\n\t\t\t\t\t// duplicates.\n\n\t\t\t\t\tsynchronized (hardCache){\n\t\t\t\t\t\thardCache.addFirst(result);\n\t\t\t\t\t\tif (hardCache.size() > max_limit) {\n\t\t\t\t\t\t\t// Remove the last entry if list greater than MAX_LIMIT\n\t\t\t\t\t\t\thardCache.removeLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * We define our own subclass of SoftReference which contains not only the\n\t * value but also the key to make it easier to find the entry in the HashMap\n\t * after it's been garbage collected.\n\t */\n\tprivate static class SoftValue<K, V> extends SoftReference<V> {\n\n\t\tprivate final Object key; // always make data member final\n\t\t\n\t\t/**\n\t\t * Did you know that an outer class can access private data members and\n\t\t * methods of an inner class? I didn't know that! I thought it was only\n\t\t * the inner class who could access the outer class's private\n\t\t * information. An outer class can also access private members of an\n\t\t * inner class inside its inner class.\n\t\t */\n\t\tprivate SoftValue(V k, K key, ReferenceQueue<? super V> q) {\n\t\t\tsuper(k, q);\n\t\t\tthis.key = key;\n\t\t}\n\t}\n\n\t/**\n\t * Here we go through the ReferenceQueue and remove garbage collected\n\t * SoftValue objects from the HashMap by looking them up using the\n\t * SoftValue.key data member.\n\t */\n\t@SuppressWarnings(\"unchecked\") // every Reference in queue is stored as a SoftValue\n\tprivate void clearGCCollected() {\n\t\tSoftValue<K, V> sv;\n\t\twhile ((sv = (SoftValue<K, V>) queue.poll()) != null) {\n\t\t\tmap.remove(sv.key); // we can access private data!\n\t\t}\n\t}\n\n\t/**\n\t * Here we put the key, value pair into the HashMap using a SoftValue\n\t * object.\n\t */\n\t@Override\n\tpublic synchronized V put(K key, V value) {\n\t\tclearGCCollected();\n\t\tlogger.debug(\"Putting {} on cache. size: {}\", key, size());\n\t\tmap.put(key, new SoftValue<K, V>(value, key, queue));\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic V remove(Object key) {\n\t\tclearGCCollected();\n\t\tlogger.debug(\"Removing {} from cache. size: {}\", key, size());\n\t\treturn map.remove(key).get();\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tsynchronized (hardCache){\n\t\t\thardCache.clear();\n\t\t}\n\n\t\tclearGCCollected();\n\t\tlogger.debug(\"clearing cache\");\n\t\tmap.clear();\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\tclearGCCollected();\n\t\treturn map.size();\n\t}\n\n\t@Override\n\tpublic Set<Map.Entry<K, V>> entrySet() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n}\n","changedPro":"/*\n *                    PDB web development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n *\n * Created on Mar 26, 2009\n * Created by ap3\n *\n */\n\npackage org.biojava.nbio.core.util;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.AbstractMap;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/** A in memory cache using soft references. (can be garbage collected)\n * This code is based on: http://java-interview-faqs.blogspot.com/2008/09/building-faster-and-efficient-cache.html\n * <p/>\n * Note that entrySet() is not implemented and therefore many methods such as keySet(),\n * containsKey(), values() etc do not work.\n * <p/>\n * This class is therefore best used as a cache simply to put and get items by a known key\n */\npublic class SoftHashMap<K, V> extends AbstractMap<K, V> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(SoftHashMap.class);\n\n\tpublic static final int DEFAULT_LIMIT = 1;\n\n\t/** The internal HashMap that stores SoftReference to actual data. */\n\tprivate final Map<K, SoftReference<V>> map = new HashMap<>();\n\n\t/** Maximum Number of references you dont want GC to collect. */\n\tprivate final int max_limit;\n\n\t/** The FIFO list of hard references, order of last access. */\n\tprivate final LinkedList<V> hardCache = new LinkedList<>();\n\n\t/** Reference queue for cleared SoftReference objects. */\n\tprivate final ReferenceQueue<V> queue = new ReferenceQueue<>();\n\n\tpublic SoftHashMap() {\n\t\tthis(1000);\n\t}\n\n\t/**\n\t * @param hardSize A maximum number of items to maintain hard references to\n\t * that will not be eligible for garbage collection\n\t */\n\tpublic SoftHashMap(int hardSize) {\n\t\tmax_limit = hardSize;\n\t}\n\n\t@Override\n\tpublic V get(Object key) {\n\n\t\tV result = null;\n\n\t\t// We get the SoftReference represented by that key\n\t\tSoftReference<V> soft_ref = map.get(key);\n\n\t\tif (soft_ref != null) {\n\t\t\ttry {\n\t\t\t\t// From the SoftReference we get the value, which can be\n\t\t\t\t// null if it was not in the map, or it was removed in\n\t\t\t\t// the clearGCCollected() method defined below\n\n\t\t\t\tresult = soft_ref.get();\n\t\t\t\tif (result == null) {\n\t\t\t\t\t// If the value has been garbage collected, remove the\n\t\t\t\t\t// entry from the HashMap.\n\t\t\t\t\tmap.remove(key);\n\t\t\t\t} else {\n\t\t\t\t\t// We now add this object to the beginning of the hard\n\t\t\t\t\t// reference queue. One reference can occur more than\n\t\t\t\t\t// once, because lookups of the FIFO queue are slow, so\n\t\t\t\t\t// we don't want to search through it each time to remove\n\t\t\t\t\t// duplicates.\n\n\t\t\t\t\tsynchronized (hardCache){\n\t\t\t\t\t\thardCache.addFirst(result);\n\t\t\t\t\t\tif (hardCache.size() > max_limit) {\n\t\t\t\t\t\t\t// Remove the last entry if list greater than MAX_LIMIT\n\t\t\t\t\t\t\thardCache.removeLast();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception e){\n\t\t\t\tlogger.error(\"Exception: \", e);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * We define our own subclass of SoftReference which contains not only the\n\t * value but also the key to make it easier to find the entry in the HashMap\n\t * after it's been garbage collected.\n\t */\n\tprivate static class SoftValue<K, V> extends SoftReference<V> {\n\n\t\tprivate final Object key; // always make data member final\n\t\t\n\t\t/**\n\t\t * Did you know that an outer class can access private data members and\n\t\t * methods of an inner class? I didn't know that! I thought it was only\n\t\t * the inner class who could access the outer class's private\n\t\t * information. An outer class can also access private members of an\n\t\t * inner class inside its inner class.\n\t\t */\n\t\tprivate SoftValue(V k, K key, ReferenceQueue<? super V> q) {\n\t\t\tsuper(k, q);\n\t\t\tthis.key = key;\n\t\t}\n\t}\n\n\t/**\n\t * Here we go through the ReferenceQueue and remove garbage collected\n\t * SoftValue objects from the HashMap by looking them up using the\n\t * SoftValue.key data member.\n\t */\n\t@SuppressWarnings(\"unchecked\") // every Reference in queue is stored as a SoftValue\n\tprivate void clearGCCollected() {\n\t\tSoftValue<K, V> sv;\n\t\twhile ((sv = (SoftValue<K, V>) queue.poll()) != null) {\n\t\t\tmap.remove(sv.key); // we can access private data!\n\t\t}\n\t}\n\n\t/**\n\t * Here we put the key, value pair into the HashMap using a SoftValue\n\t * object.\n\t */\n\t@Override\n\tpublic synchronized V put(K key, V value) {\n\t\tclearGCCollected();\n\t\tlogger.debug(\"Putting {} on cache. size: {}\", key, size());\n\t\tmap.put(key, new SoftValue<K, V>(value, key, queue));\n\t\treturn value;\n\t}\n\n\t@Override\n\tpublic V remove(Object key) {\n\t\tclearGCCollected();\n\t\tlogger.debug(\"Removing {} from cache. size: {}\", key, size());\n\t\treturn map.remove(key).get();\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tsynchronized (hardCache){\n\t\t\thardCache.clear();\n\t\t}\n\n\t\tclearGCCollected();\n\t\tlogger.debug(\"clearing cache\");\n\t\tmap.clear();\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\tclearGCCollected();\n\t\treturn map.size();\n\t}\n\n\t@Override\n\tpublic Set<Map.Entry<K, V>> entrySet() {\n\t\tthrow new UnsupportedOperationException();\n\t}\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Map;\n\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\n/** \n * Includes a disabled test that asserts behaviour of collecting\n * SoftReferences, run using -Xmx=5M to expose this behaviour.\n */\nclass SoftHashMapTest {\n\n    static class TestObject  {\n        /*\n        *Create an object occupying negligible memory\n        */\n        static TestObject small(String name){\n            return new TestObject(name, 100);\n        }\n\n        /*\n        *Create a test object occupying significant memory(100kB)\n        */\n        static TestObject large(String name){\n            return new TestObject(name, 100_000);\n        }\n        private String name;\n        private int [] internalArray = null; \n        public TestObject(String string, int capacity) {\n            this.name=string;\n            this.internalArray = new int [capacity];\n        }\n        String getName(){\n            return name;\n        }\n        public String toString(){\n            return name;\n        }\n    }\n\n    // This test needs to be run with restricted memory in order\n    // to expose the behaviour of SoftHashMap in deleting entries \n    // when under memory pressure. By setting -Xmx=5M the test can\n    // assert that entries are deleted. We don't want to risk throwing\n    // OOM errors during normal test execution so this is disabled\n    @Test\n    @Disabled(\"requires to run in conditions nearly throwing an OOM\")\n    void softMapRemovesRefsToSaveMemory() throws InterruptedException{\n       \n        // Using a regular Map with hard references will probably\n        // cause an OOM error if running with -Xmx=5M. Uncomment this\n        // and comment out the next line to observe this.\n        // Map<String, TestObject> map =new HashMap<>(1);\n\n        // set the maximum number of hard references to 1 (minimum)\n        // to expose behaviour of soft references better. \n        Map<String, TestObject> map = new SoftHashMap<>(1);\n        int totalPuts =5;\n        for (int i = 0; i < totalPuts; i++) {\n\n            TestObject myObject = TestObject.large(\"\"+i);\n            map.put(myObject.getName(),myObject);\n            //allocate a little slowly\n            // enables GC time to work\n            Thread.sleep(10);\n        }\n        int nonNullValues = countNonNullMapReferences(map, totalPuts);\n        // some but not all references should be removed.\n        assertTrue(nonNullValues > 0 && nonNullValues < totalPuts);\n    }\n\n    private int countNonNullMapReferences(Map<String, TestObject> map, int totalPuts) {\n        try {\n            //sleep a little in case if finalizers are currently running\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        // we can't iterate over map as keySet() isn't implemented\n        int nonNullValues = 0;\n        for (int i = 0; i< totalPuts; i++) {\n            if(map.get(\"\" + i ) != null) {\n                nonNullValues++;\n            }\n        } \n        return nonNullValues;\n    }\n    \n    @Test\n    void basicMapOperations() throws InterruptedException{\n        \n        SoftHashMap<String, TestObject> map = new SoftHashMap<>(1);\n        TestObject s1= TestObject.small(\"1\");\n        TestObject s2= TestObject.small(\"2\");\n        TestObject s3= TestObject.small(\"3\");\n    \n        map.put(\"1\", s1);\n        map.put(\"2\", s2);\n        map.put(\"3\", s3);\n        assertEquals(3, map.size());\n\n        map.put(\"3\", TestObject.small(\"4\"));\n        assertEquals(3, map.size());\n\n        assertEquals(s1, map.remove(\"1\"));\n        assertEquals(2, map.size());\n\n        map.clear();\n        assertEquals(0, map.size());\n    }\n    @Test\n    void manyMapOperationsAreUnsupported() throws Exception{\n        SoftHashMap<String, TestObject> map = new SoftHashMap<>(1);\n        TestObject s1= TestObject.small(\"1\");\n        map.put(\"1\", null);\n        // these all use entrySet internally and throw USOException\n        assertThrows(UnsupportedOperationException.class, ()->map.containsValue(s1));\n        assertThrows(UnsupportedOperationException.class, ()->map.containsKey(\"1\"));\n        assertThrows(UnsupportedOperationException.class, ()->map.values().iterator());\n        assertThrows(UnsupportedOperationException.class, ()->map.getOrDefault(\"1\", TestObject.small(\"2\")));     \n    }\n        \n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":false}