{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/GenbankReader.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/GenbankReaderTest.java","prod_time":"2024-06-12 22:39:08","test_time":"2024-06-12 22:39:08","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"POSITIVE","prod_commitID":"0f4983ccc4d72289ad6439e8351167b44a39e7e7","test_commitID":"0f4983ccc4d72289ad6439e8351167b44a39e7e7","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n * @author Karl Nicholas <github:karlnicholas>\n * @author Paolo Pavan\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.TaxonomyID;\nimport org.biojava.nbio.core.sequence.features.DBReferenceInfo;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\n\n/**\n * Use {@link GenbankReaderHelper} as an example of how to use this class where {@link GenbankReaderHelper} should be the\n * primary class used to read Genbank files\n *\n */\npublic class GenbankReader<S extends AbstractSequence<C>, C extends Compound> {\n\n\tprivate SequenceCreatorInterface<C> sequenceCreator;\n\tprivate GenbankSequenceParser<S,C> genbankParser;\n\tprivate BufferedReader bufferedReader;\n\tprivate boolean closed;\n\tprivate final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n\tpublic boolean isClosed() {\n\t\treturn closed;\n\t}\n\n\t/**\n\t * If you are going to use {@link FileProxyProteinSequenceCreator} then do not use this constructor because we need details about\n\t * local file offsets for quick reads. {@link InputStream} does not give you the name of the stream to access quickly via file seek. A seek in\n\t * an {@link InputStream} is forced to read all the data so you don't gain anything.\n\t * @param is\n\t * @param headerParser\n\t * @param sequenceCreator\n\t */\n\tpublic GenbankReader(final InputStream is, final SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t\t final SequenceCreatorInterface<C> sequenceCreator) {\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\tbufferedReader = new BufferedReader(new InputStreamReader(is));\n\t\tgenbankParser = new GenbankSequenceParser<>();\n\t\tclosed = false;\n\t}\n\n\t/**\n\t * If you are going to use the FileProxyProteinSequenceCreator then you\n\t * need to use this constructor because we need details about\n\t * the location of the file.\n\t * @param file\n\t * @param headerParser\n\t * @param sequenceCreator\n\t * @throws FileNotFoundException if the file does not exist, is a directory\n\t * \trather than a regular file, or for some other reason cannot be opened\n\t * \tfor reading.\n\t * @throws SecurityException if a security manager exists and its checkRead\n\t * \tmethod denies read access to the file.\n\t */\n\tpublic GenbankReader(\n\t\t\tfinal File file,\n\t\t\tfinal SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\tfinal SequenceCreatorInterface<C> sequenceCreator\n\t\t\t) throws FileNotFoundException {\n\n\t\tthis.bufferedReader = new BufferedReader(new FileReader(file));\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\tgenbankParser = new GenbankSequenceParser<>();\n\t}\n\n\t/**\n\t * The parsing is done in this method.<br>\n\t * This method will return all the available Genbank records\n\t * in the File or InputStream, closes the underlying resource,\n\t * and return the results in {@link LinkedHashMap}.<br>\n\t * You don't need to call {@link GenbankReader#close()} after calling this method.\n\t * @see #process(int)\n\t * @return {@link HashMap} containing all the parsed Genbank records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException\n\t * @throws CompoundNotFoundException\n\t * @throws OutOfMemoryError if the input resource is larger than the allocated heap.\n\t */\n\tpublic LinkedHashMap<String,S> process() throws IOException, CompoundNotFoundException {\n\t\tLinkedHashMap<String,S> result = process(-1);\n\t\tclose();\n\t\treturn result;\n\t}\n\n\t/**\n\t * This method tries to parse maximum <code>max</code> records from\n\t * the open File or InputStream, and leaves the underlying resource open.<br>\n\t *\n\t * Subsequent calls to the same method continue parsing the rest of the file.<br>\n\t * This is particularly useful when dealing with very big data files,\n\t * (e.g. NCBI nr database), which can't fit into memory and will take long\n\t * time before the first result is available.<br>\n\t * <b>N.B.</b>\n\t * <ul>\n\t * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n\t * <li>remember to close the underlying resource when you are done.</li>\n\t * </ul>\n\t * @see #process()\n\t * @author Amr ALHOSSARY\n\t * @since 3.0.6\n\t * @param max maximum number of records to return.\n\t * @return {@link HashMap} containing maximum <code>max</code> parsed Genbank records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic LinkedHashMap<String,S> process(final int max) throws IOException, CompoundNotFoundException {\n\n\t\tif(closed){\n\t\t\tthrow new IOException(\"Cannot perform action: resource has been closed.\");\n\t\t}\n\n\t\tLinkedHashMap<String,S> sequences = new LinkedHashMap<>();\n\t\tint i=0;\n\t\twhile(true) {\n\t\t\tif(max>0 && i>=max) break;\n\t\t\ti++;\n\t\t\tString seqString = genbankParser.getSequence(bufferedReader, 0);\n\t\t\t//reached end of file?\n\t\t\tif(seqString==null) break;\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tS sequence = (S) sequenceCreator.getSequence(seqString, 0);\n\t\t\tGenericGenbankHeaderParser<S, C> genbankHeaderParser = genbankParser.getSequenceHeaderParser();\t\t\t\n\t\t\tgenbankHeaderParser.parseHeader(genbankParser.getHeader(), sequence);\t\t\t\n\t\t\tString id = genbankHeaderParser.getAccession();\n\t\t\tint version = genbankHeaderParser.getVersion();\n\t\t\tString identifier = genbankHeaderParser.getIdentifier();\n\t\t\tAccessionID accession = new AccessionID(id , DataSource.GENBANK, version, identifier);\n\t\t\tsequence.setAccession(accession);\n\t\t\t\n\t\t\t// add features to new sequence\n\t\t\tgenbankParser.getFeatures().values().stream()\n\t\t\t.flatMap(List::stream)\n\t\t\t.forEach(sequence::addFeature);\n\n\t\t\t// add taxonomy ID to new sequence\n\t\t\tList<DBReferenceInfo> dbQualifier = genbankParser.getDatabaseReferences().get(\"db_xref\");\n\t\t\tif (dbQualifier != null){\n\t\t\t\tDBReferenceInfo q = dbQualifier.get(0);\n\t\t\t\tsequence.setTaxonomy(new TaxonomyID(q.getDatabase()+\":\"+q.getId(), DataSource.GENBANK));\n\t\t\t}\n\n\t\t\tsequences.put(sequence.getAccession().getID(), sequence);\n\t\t}\n\n\t\treturn sequences;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tbufferedReader.close();\n\t\t\tthis.closed = true;\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"Couldn't close the reader.\", e);\n\t\t\tthis.closed = false;\n\t\t}\n\t}\n}\n\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n * @author Karl Nicholas <github:karlnicholas>\n * @author Paolo Pavan\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.TaxonomyID;\nimport org.biojava.nbio.core.sequence.features.DBReferenceInfo;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Use {@link GenbankReaderHelper} as an example of how to use this class where {@link GenbankReaderHelper} should be the\n * primary class used to read Genbank files\n *\n */\npublic class GenbankReader<S extends AbstractSequence<C>, C extends Compound> {\n\n\tprivate SequenceCreatorInterface<C> sequenceCreator;\n\tprivate GenbankSequenceParser<S,C> genbankParser;\n\tprivate BufferedReader bufferedReader;\n\tprivate boolean closed;\n\tprivate final Logger logger = LoggerFactory.getLogger(this.getClass());\n\n\tpublic boolean isClosed() {\n\t\treturn closed;\n\t}\n\n\t/**\n\t * If you are going to use {@link FileProxyProteinSequenceCreator} then do not use this constructor because we need details about\n\t * local file offsets for quick reads. {@link InputStream} does not give you the name of the stream to access quickly via file seek. A seek in\n\t * an {@link InputStream} is forced to read all the data so you don't gain anything.\n\t * @param is\n\t * @param headerParser\n\t * @param sequenceCreator\n\t */\n\tpublic GenbankReader(final InputStream is, final SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t\t final SequenceCreatorInterface<C> sequenceCreator) {\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\tbufferedReader = new BufferedReader(new InputStreamReader(is));\n\t\tgenbankParser = new GenbankSequenceParser<>();\n\t\tclosed = false;\n\t}\n\n\t/**\n\t * If you are going to use the FileProxyProteinSequenceCreator then you\n\t * need to use this constructor because we need details about\n\t * the location of the file.\n\t * @param file\n\t * @param headerParser\n\t * @param sequenceCreator\n\t * @throws FileNotFoundException if the file does not exist, is a directory\n\t * \trather than a regular file, or for some other reason cannot be opened\n\t * \tfor reading.\n\t * @throws SecurityException if a security manager exists and its checkRead\n\t * \tmethod denies read access to the file.\n\t */\n\tpublic GenbankReader(\n\t\t\tfinal File file,\n\t\t\tfinal SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\tfinal SequenceCreatorInterface<C> sequenceCreator\n\t\t\t) throws FileNotFoundException {\n\n\t\tthis.bufferedReader = new BufferedReader(new FileReader(file));\n\t\tthis.sequenceCreator = sequenceCreator;\n\t\tgenbankParser = new GenbankSequenceParser<>();\n\t}\n\n\t/**\n\t * The parsing is done in this method.<br>\n\t * This method will return all the available Genbank records\n\t * in the File or InputStream, closes the underlying resource,\n\t * and return the results in {@link LinkedHashMap}.<br>\n\t * You don't need to call {@link GenbankReader#close()} after calling this method.\n\t * @see #process(int)\n\t * @return {@link HashMap} containing all the parsed Genbank records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException\n\t * @throws CompoundNotFoundException\n\t * @throws OutOfMemoryError if the input resource is larger than the allocated heap.\n\t */\n\tpublic Map<String, S> process() throws IOException, CompoundNotFoundException {\n\t\tMap<String, S> result = process(-1);\n\t\tclose();\n\t\treturn result;\n\t}\n\n\t/**\n\t * This method tries to parse maximum <code>max</code> records from\n\t * the open File or InputStream, and leaves the underlying resource open.<br>\n\t *\n\t * Subsequent calls to the same method continue parsing the rest of the file.<br>\n\t * This is particularly useful when dealing with very big data files,\n\t * (e.g. NCBI nr database), which can't fit into memory and will take long\n\t * time before the first result is available.<br>\n\t * <b>N.B.</b>\n\t * <ul>\n\t * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n\t * <li>remember to close the underlying resource when you are done.</li>\n\t * </ul>\n\t * @see #process()\n\t * @author Amr ALHOSSARY\n\t * @since 3.0.6\n\t * @param max maximum number of records to return.\n\t * @return {@link HashMap} containing maximum <code>max</code> parsed Genbank records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic Map<String, S> process(final int max) throws IOException, CompoundNotFoundException {\n\n\t\tif(closed){\n\t\t\tthrow new IOException(\"Cannot perform action: resource has been closed.\");\n\t\t}\n\n\t\tMap<String, S> sequences = new LinkedHashMap<>();\n\t\tint i=0;\n\t\twhile(true) {\n\t\t\tif(max>0 && i>=max) break;\n\t\t\ti++;\n\t\t\tString seqString = genbankParser.getSequence(bufferedReader, 0);\n\t\t\t//reached end of file?\n\t\t\tif(seqString==null) break;\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tS sequence = (S) sequenceCreator.getSequence(seqString, 0);\n\t\t\tGenericGenbankHeaderParser<S, C> genbankHeaderParser = genbankParser.getSequenceHeaderParser();\t\t\t\n\t\t\tgenbankHeaderParser.parseHeader(genbankParser.getHeader(), sequence);\t\t\t\n\t\t\tString id = genbankHeaderParser.getAccession();\n\t\t\tint version = genbankHeaderParser.getVersion();\n\t\t\tString identifier = genbankHeaderParser.getIdentifier();\n\t\t\tAccessionID accession = new AccessionID(id , DataSource.GENBANK, version, identifier);\n\t\t\tsequence.setAccession(accession);\n\t\t\t\n\t\t\t// add features to new sequence\n\t\t\tgenbankParser.getFeatures().values().stream()\n\t\t\t.flatMap(List::stream)\n\t\t\t.forEach(sequence::addFeature);\n\n\t\t\t// add taxonomy ID to new sequence\n\t\t\tList<DBReferenceInfo> dbQualifier = genbankParser.getDatabaseReferences().get(\"db_xref\");\n\t\t\tif (dbQualifier != null){\n\t\t\t\tDBReferenceInfo q = dbQualifier.get(0);\n\t\t\t\tsequence.setTaxonomy(new TaxonomyID(q.getDatabase()+\":\"+q.getId(), DataSource.GENBANK));\n\t\t\t}\n\n\t\t\tsequences.put(sequence.getAccession().getID(), sequence);\n\t\t}\n\n\t\treturn sequences;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tbufferedReader.close();\n\t\t\tthis.closed = true;\n\t\t} catch (IOException e) {\n\t\t\tlogger.error(\"Couldn't close the reader.\", e);\n\t\t\tthis.closed = false;\n\t\t}\n\t}\n}\n\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.RNASequence;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.compound.*;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\nimport org.biojava.nbio.core.sequence.location.template.AbstractLocation;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.*;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n * @author Jacek Grzebyta\n * @author Philippe Soares\n */\npublic class GenbankReaderTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenbankReaderTest.class);\n\n\t/**\n\t * Test of process method, of class GenbankReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tlogger.info(\"process protein\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\");\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> genbankProtein\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\n\t\tLinkedHashMap<String, ProteinSequence> proteinSequences = genbankProtein.process();\n\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getComments().get(0),is(\n\t\t\t\t\"VALIDATED REFSEQ: This record has undergone validation or\\n\" +\n\t\t\t\t\"preliminary review. The reference sequence was derived from\\n\" +\n\t\t\t\t\"AL034370.1, X65882.1 and BE139596.1.\\n\" +\n\t\t\t\t\"Summary: NDP is the genetic locus identified as harboring mutations\\n\" +\n\t\t\t\t\"that result in Norrie disease. Norrie disease is a rare genetic\\n\" +\n\t\t\t\t\"disorder characterized by bilateral congenital blindness that is\\n\" +\n\t\t\t\t\"caused by a vascularized mass behind each lens due to a\\n\" +\n\t\t\t\t\"maldeveloped retina (pseudoglioma).\\n\" +\n\t\t\t\t\"Publication Note:  This RefSeq record includes a subset of the\\n\" +\n\t\t\t\t\"publications that are available for this gene. Please see the\\n\" +\n\t\t\t\t\"Entrez Gene record to access additional publications.\"));\n\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().size(),is(11));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(0).getAuthors(),\n\t\t\t\tis(\"Lev,D., Weigl,Y., Hasan,M., Gak,E., Davidovich,M., Vinkler,C.,\\n\" +\n\t\t\t\t\t\t\"Leshinsky-Silver,E., Lerman-Sagie,T. and Watemberg,N.\"));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(1).getTitle(),\n\t\t\t\tis(\"Novel mutations in Norrie disease gene in Japanese patients with\\n\" +\n\t\t\t\t\t\t\"Norrie disease and familial exudative vitreoretinopathy\"));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(10).getJournal(),\n\t\t\t\tis(\"Nat. Genet. 1 (3), 199-203 (1992)\"));\n\n\t\tassertNotNull(proteinSequences);\n\t\tassertEquals(1, proteinSequences.size());\n\n\t\tProteinSequence proteinSequence = proteinSequences.get(\"NP_000257\");\n\t\tassertNotNull(proteinSequences.get(\"NP_000257\"));\n\t\tassertEquals(\"NP_000257\", proteinSequence.getAccession().getID());\n\t\tassertEquals(\"4557789\", proteinSequence.getAccession().getIdentifier());\n\t\tassertEquals(\"GENBANK\", proteinSequence.getAccession().getDataSource().name());\n\t\tassertEquals(1, proteinSequence.getAccession().getVersion().intValue());\n\t\tassertTrue(genbankProtein.isClosed());\n\n\t\tlogger.info(\"process DNA\");\n\t\tinStream = this.getClass().getResourceAsStream(\"/NM_000266.gb\");\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t\t\t);\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\n\t\tDNASequence dnaSequence = dnaSequences.get(\"NM_000266\");\n\t\tassertNotNull(dnaSequences.get(\"NM_000266\"));\n\t\tassertEquals(\"NM_000266\", dnaSequence.getAccession().getID());\n\t\tassertEquals(\"223671892\", dnaSequence.getAccession().getIdentifier());\n\t\tassertEquals(\"GENBANK\", dnaSequence.getAccession().getDataSource().name());\n\t\tassertEquals(3, dnaSequence.getAccession().getVersion().intValue());\n\t\tassertTrue(genbankDNA.isClosed());\n\t}\n\n\t/**\n\t * Test the process method with a number of sequences to be read at each call.\n\t * The underlying {@link InputStream} should remain open until the last call.\n\t */\n\t@Test\n\tpublic void testPartialProcess() throws IOException, CompoundNotFoundException {\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/two-dnaseqs.gb\"));\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\tinStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t);\n\n\t\t// First call to process(1) returns the first sequence\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process(1);\n\n\t\tassertFalse(inStream.isclosed());\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\t\tassertNotNull(dnaSequences.get(\"vPetite\"));\n\n\t\t// Second call to process(1) returns the second sequence\n\t\tdnaSequences = genbankDNA.process(1);\n\t\tassertFalse(inStream.isclosed());\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\t\tassertNotNull(dnaSequences.get(\"sbFDR\"));\n\n\t\tassertFalse(genbankDNA.isClosed());\n\t\tgenbankDNA.close();\n\t\tassertTrue(genbankDNA.isClosed());\n\t\tassertTrue(inStream.isclosed());\n\t}\n\n\t@Test\n\tpublic void CDStest() throws Exception {\n\t\tlogger.info(\"CDS Test\");\n\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/BondFeature.gb\"));\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> GenbankProtein\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\t\tLinkedHashMap<String, ProteinSequence> proteinSequences = GenbankProtein.process();\n\t\tassertTrue(inStream.isclosed());\n\n\n\t\tAssert.assertEquals(1, proteinSequences.size());\n\t\tlogger.debug(\"protein sequences: {}\", proteinSequences);\n\n\t\tProteinSequence protein = new ArrayList<>(proteinSequences.values()).get(0);\n\n\t\tFeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound> cdsFeature = protein.getFeaturesByType(\"CDS\").get(0);\n\t\tString codedBy = cdsFeature.getQualifiers().get(\"coded_by\").get(0).getValue();\n\t\tMap<String, List<Qualifier>> quals = cdsFeature.getQualifiers();\n\t\tList<Qualifier> dbrefs = quals.get(\"db_xref\");\n\n\t\tAssert.assertNotNull(codedBy);\n\t\tAssert.assertFalse(codedBy.isEmpty());\n\t\tassertEquals(\"NM_000266.2:503..904\", codedBy);\n\t\tassertEquals(5, dbrefs.size());\n\n\t}\n\n\tprivate DNASequence readGenbankResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t\t\t);\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\t\treturn dnaSequences.values().iterator().next();\n\t}\n\t\n\tprivate RNASequence readGenbankRNAResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<RNASequence, NucleotideCompound> genbankRNA\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew RNASequenceCreator(RNACompoundSet.getRNACompoundSet())\n\t\t\t\t);\n\t\tLinkedHashMap<String, RNASequence> rnaSequences = genbankRNA.process();\n\t\treturn rnaSequences.values().iterator().next();\t\n\t}\n\t\n\tprivate ProteinSequence readGenbankProteinResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> genbankProtein\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\t\tLinkedHashMap<String, ProteinSequence> proteinSequences = genbankProtein.process();\n\t\treturn proteinSequences.values().iterator().next();\t\n\t}\n\t\n\tprivate AbstractSequence<?> readUnknownGenbankResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankSequenceParser<AbstractSequence<Compound>, Compound> genbankParser = new GenbankSequenceParser<>();\n\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\t\tString seqString = genbankParser.getSequence(bufferedReader, 0);\n\t\tString compoundSet = genbankParser.getCompoundType().getClass().getSimpleName();\n\n\t\tif (compoundSet.equals(\"AminoAcidCompoundSet\")) {\n\t\t\treturn readGenbankProteinResource(resource);\n\t\t} else if (compoundSet.equals(\"RNACompoundSet\")) {\n\t\t\treturn readGenbankRNAResource(resource);\n\t\t} else {\n\t\t\treturn readGenbankResource(resource);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testNcbiExpandedAccessionFormats() throws IOException, CompoundNotFoundException {\n\t\tDNASequence header0 = readGenbankResource(\"/empty_header0.gb\");\n\t\tassertEquals(\"CP032762             5868661 bp    DNA     circular BCT 15-OCT-2018\", header0.getOriginalHeader());\n\n\t\tDNASequence header1 = readGenbankResource(\"/empty_header1.gb\");\n\t\tassertEquals(\"AZZZAA02123456789 9999999999 bp    DNA     linear   PRI 15-OCT-2018\", header1.getOriginalHeader());\n\n\t\tDNASequence header2 = readGenbankResource(\"/empty_header2.gb\");\n\t\tassertEquals(\"AZZZAA02123456789 10000000000 bp    DNA     linear   PRI 15-OCT-2018\", header2.getOriginalHeader());\n\t}\n\t\n\t@Test\n\tpublic void testLegacyLocusCompatable() throws IOException, CompoundNotFoundException {\n\t\t\n\t\t// Testing opening a genbank file with uppercase units, strand and topology\n\t\tAbstractSequence<? extends Compound> header0 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io/uppercase_locus0.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DS-DNA   CIRCULAR  SYN       22-JUL-1994\", header0.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header0.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase SS strand\n\t\tAbstractSequence<? extends Compound> header1 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus1.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP SS-DNA   CIRCULAR  SYN       13-JUL-1994\", header1.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header1.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase MS strand\n\t\tAbstractSequence<? extends Compound> header2 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus2.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP MS-DNA   CIRCULAR  SYN       13-JUL-1994\", header2.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header2.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase LINEAR topology\n\t\tAbstractSequence<? extends Compound> header3 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus3.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DNA   LINEAR    SYN       22-JUL-1994\", header3.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header3.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase units with no strand or topology\n\t\tAbstractSequence<? extends Compound> header4 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus4.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP RNA             SYN       13-JUL-1994\", header4.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header4.getAccession().getID());\n\t\tassertEquals(\"RNACompoundSet\", header4.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase units with no strand, topology, division or date\n\t\tAbstractSequence<? extends Compound> header5 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus5.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DNA\", header5.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header5.getAccession().getID());\n\t\t\n\t\t// Testing uppercase units with no strand, molecule type, topology, division or date\n\t\tAbstractSequence<? extends Compound> header6 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus6.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP\", header6.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header6.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase protein units\n\t\tAbstractSequence<? extends Compound> header7 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus7.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 AA Protein\", header7.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header7.getAccession().getID());\n\t\tassertEquals(\"AminoAcidCompoundSet\", header7.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t}\n\n\t@Test\n\tpublic void readSequenceWithZeroSpanFeature() throws IOException, CompoundNotFoundException {\n\t\tlogger.info(\"make or read genbank file error when feature spans zero point of circular sequence (issue #855)\");\n\t\tfinal DNASequence seq = readGenbankResource(\"/feature-spans-zero-point-circular-sequence.gb\");\n\n\t\tassertNotNull(seq);\n\n\t\tfinal FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> f = seq.getFeatures().get(33);\n\t\tfinal AbstractLocation fLocation = f.getLocations();\n\n\t\tassertTrue(fLocation.isCircular());\n\t\tassertEquals(7028, (int)fLocation.getStart().getPosition());\n\t\tassertEquals(286, (int)fLocation.getEnd().getPosition());\n\t\tassertEquals(Strand.NEGATIVE, fLocation.getStrand());\n\t}\n\n\t/**\n\t * Biojava fails to parse anticodon and transl_except feature qualifiers when they line wrap.\n\t * https://github.com/biojava/biojava/issues/843\n\t */\n\t@Test\n\tpublic void testGithub843() throws Exception {\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/NC_018080.gb\"));\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\tinStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t);\n\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\t\tassertNotNull(dnaSequences);\n\n\t\tDNASequence dna = new ArrayList<>(dnaSequences.values()).get(0);\n\t\tassertNotNull(dna);\n\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> tRNAFeature = dna.getFeaturesByType(\"tRNA\").get(0);\n\t\tString anticodon = tRNAFeature.getQualifiers().get(\"anticodon\").get(0).getValue();\n\t\tassertEquals(\"(pos:complement(1123552..1123554),aa:Leu,seq:caa)\", anticodon);\n\t\tString transl_except = tRNAFeature.getQualifiers().get(\"transl_except\").get(0).getValue();\n\t\tassertEquals(\"(pos:complement(1123552..1123554),aa:Leu)\",transl_except);\n\t}\n\n\t/**\n\t * Helper class to be able to verify the closed state of the input stream.\n\t */\n\tprivate static class CheckableInputStream extends BufferedInputStream {\n\n\t\tprivate boolean closed;\n\n\t\tCheckableInputStream(InputStream in) {\n\t\t\tsuper(in);\n\t\t\tclosed = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() throws IOException {\n\t\t\tsuper.close();\n\t\t\tclosed = true;\n\t\t}\n\n\t\tboolean isclosed() {\n\t\t\treturn closed;\n\t\t}\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.RNASequence;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.compound.*;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\nimport org.biojava.nbio.core.sequence.location.template.AbstractLocation;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.*;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.*;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n * @author Jacek Grzebyta\n * @author Philippe Soares\n */\npublic class GenbankReaderTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenbankReaderTest.class);\n\n\t/**\n\t * Test of process method, of class GenbankReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tlogger.info(\"process protein\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\");\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> genbankProtein\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\n\t\tMap<String, ProteinSequence> proteinSequences = genbankProtein.process();\n\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getComments().get(0),is(\n\t\t\t\t\"VALIDATED REFSEQ: This record has undergone validation or\\n\" +\n\t\t\t\t\"preliminary review. The reference sequence was derived from\\n\" +\n\t\t\t\t\"AL034370.1, X65882.1 and BE139596.1.\\n\" +\n\t\t\t\t\"Summary: NDP is the genetic locus identified as harboring mutations\\n\" +\n\t\t\t\t\"that result in Norrie disease. Norrie disease is a rare genetic\\n\" +\n\t\t\t\t\"disorder characterized by bilateral congenital blindness that is\\n\" +\n\t\t\t\t\"caused by a vascularized mass behind each lens due to a\\n\" +\n\t\t\t\t\"maldeveloped retina (pseudoglioma).\\n\" +\n\t\t\t\t\"Publication Note:  This RefSeq record includes a subset of the\\n\" +\n\t\t\t\t\"publications that are available for this gene. Please see the\\n\" +\n\t\t\t\t\"Entrez Gene record to access additional publications.\"));\n\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().size(),is(11));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(0).getAuthors(),\n\t\t\t\tis(\"Lev,D., Weigl,Y., Hasan,M., Gak,E., Davidovich,M., Vinkler,C.,\\n\" +\n\t\t\t\t\t\t\"Leshinsky-Silver,E., Lerman-Sagie,T. and Watemberg,N.\"));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(1).getTitle(),\n\t\t\t\tis(\"Novel mutations in Norrie disease gene in Japanese patients with\\n\" +\n\t\t\t\t\t\t\"Norrie disease and familial exudative vitreoretinopathy\"));\n\t\tassertThat(proteinSequences.get(\"NP_000257\").getReferences().get(10).getJournal(),\n\t\t\t\tis(\"Nat. Genet. 1 (3), 199-203 (1992)\"));\n\n\t\tassertNotNull(proteinSequences);\n\t\tassertEquals(1, proteinSequences.size());\n\n\t\tProteinSequence proteinSequence = proteinSequences.get(\"NP_000257\");\n\t\tassertNotNull(proteinSequences.get(\"NP_000257\"));\n\t\tassertEquals(\"NP_000257\", proteinSequence.getAccession().getID());\n\t\tassertEquals(\"4557789\", proteinSequence.getAccession().getIdentifier());\n\t\tassertEquals(\"GENBANK\", proteinSequence.getAccession().getDataSource().name());\n\t\tassertEquals(1, proteinSequence.getAccession().getVersion().intValue());\n\t\tassertTrue(genbankProtein.isClosed());\n\n\t\tlogger.info(\"process DNA\");\n\t\tinStream = this.getClass().getResourceAsStream(\"/NM_000266.gb\");\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t\t\t);\n\t\tMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\n\t\tDNASequence dnaSequence = dnaSequences.get(\"NM_000266\");\n\t\tassertNotNull(dnaSequences.get(\"NM_000266\"));\n\t\tassertEquals(\"NM_000266\", dnaSequence.getAccession().getID());\n\t\tassertEquals(\"223671892\", dnaSequence.getAccession().getIdentifier());\n\t\tassertEquals(\"GENBANK\", dnaSequence.getAccession().getDataSource().name());\n\t\tassertEquals(3, dnaSequence.getAccession().getVersion().intValue());\n\t\tassertTrue(genbankDNA.isClosed());\n\t}\n\n\t/**\n\t * Test the process method with a number of sequences to be read at each call.\n\t * The underlying {@link InputStream} should remain open until the last call.\n\t */\n\t@Test\n\tpublic void testPartialProcess() throws IOException, CompoundNotFoundException {\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/two-dnaseqs.gb\"));\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\tinStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t);\n\n\t\t// First call to process(1) returns the first sequence\n\t\tMap<String, DNASequence> dnaSequences = genbankDNA.process(1);\n\n\t\tassertFalse(inStream.isclosed());\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\t\tassertNotNull(dnaSequences.get(\"vPetite\"));\n\n\t\t// Second call to process(1) returns the second sequence\n\t\tdnaSequences = genbankDNA.process(1);\n\t\tassertFalse(inStream.isclosed());\n\t\tassertNotNull(dnaSequences);\n\t\tassertEquals(1, dnaSequences.size());\n\t\tassertNotNull(dnaSequences.get(\"sbFDR\"));\n\n\t\tassertFalse(genbankDNA.isClosed());\n\t\tgenbankDNA.close();\n\t\tassertTrue(genbankDNA.isClosed());\n\t\tassertTrue(inStream.isclosed());\n\t}\n\n\t@Test\n\tpublic void CDStest() throws Exception {\n\t\tlogger.info(\"CDS Test\");\n\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/BondFeature.gb\"));\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> GenbankProtein\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\t\t\tinStream,\n\t\t\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\t\tMap<String, ProteinSequence> proteinSequences = GenbankProtein.process();\n\t\tassertTrue(inStream.isclosed());\n\n\n\t\tAssert.assertEquals(1, proteinSequences.size());\n\t\tlogger.debug(\"protein sequences: {}\", proteinSequences);\n\n\t\tProteinSequence protein = new ArrayList<>(proteinSequences.values()).get(0);\n\n\t\tFeatureInterface<AbstractSequence<AminoAcidCompound>, AminoAcidCompound> cdsFeature = protein.getFeaturesByType(\"CDS\").get(0);\n\t\tString codedBy = cdsFeature.getQualifiers().get(\"coded_by\").get(0).getValue();\n\t\tMap<String, List<Qualifier>> quals = cdsFeature.getQualifiers();\n\t\tList<Qualifier> dbrefs = quals.get(\"db_xref\");\n\n\t\tAssert.assertNotNull(codedBy);\n\t\tAssert.assertFalse(codedBy.isEmpty());\n\t\tassertEquals(\"NM_000266.2:503..904\", codedBy);\n\t\tassertEquals(5, dbrefs.size());\n\n\t}\n\n\tprivate DNASequence readGenbankResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t\t\t);\n\t\tMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\t\treturn dnaSequences.values().iterator().next();\n\t}\n\t\n\tprivate RNASequence readGenbankRNAResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<RNASequence, NucleotideCompound> genbankRNA\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew RNASequenceCreator(RNACompoundSet.getRNACompoundSet())\n\t\t\t\t);\n\t\tMap<String, RNASequence> rnaSequences = genbankRNA.process();\n\t\treturn rnaSequences.values().iterator().next();\t\n\t}\n\t\n\tprivate ProteinSequence readGenbankProteinResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankReader<ProteinSequence, AminoAcidCompound> genbankProtein\n\t\t= new GenbankReader<>(\n\t\t\t\tinputStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())\n\t\t\t\t);\n\t\tMap<String, ProteinSequence> proteinSequences = genbankProtein.process();\n\t\treturn proteinSequences.values().iterator().next();\t\n\t}\n\t\n\tprivate AbstractSequence<?> readUnknownGenbankResource(final String resource) throws IOException, CompoundNotFoundException {\n\t\tInputStream inputStream = getClass().getResourceAsStream(resource);\n\t\tGenbankSequenceParser<AbstractSequence<Compound>, Compound> genbankParser = new GenbankSequenceParser<>();\n\t\tBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n\t\tString seqString = genbankParser.getSequence(bufferedReader, 0);\n\t\tString compoundSet = genbankParser.getCompoundType().getClass().getSimpleName();\n\n\t\tif (compoundSet.equals(\"AminoAcidCompoundSet\")) {\n\t\t\treturn readGenbankProteinResource(resource);\n\t\t} else if (compoundSet.equals(\"RNACompoundSet\")) {\n\t\t\treturn readGenbankRNAResource(resource);\n\t\t} else {\n\t\t\treturn readGenbankResource(resource);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testNcbiExpandedAccessionFormats() throws IOException, CompoundNotFoundException {\n\t\tDNASequence header0 = readGenbankResource(\"/empty_header0.gb\");\n\t\tassertEquals(\"CP032762             5868661 bp    DNA     circular BCT 15-OCT-2018\", header0.getOriginalHeader());\n\n\t\tDNASequence header1 = readGenbankResource(\"/empty_header1.gb\");\n\t\tassertEquals(\"AZZZAA02123456789 9999999999 bp    DNA     linear   PRI 15-OCT-2018\", header1.getOriginalHeader());\n\n\t\tDNASequence header2 = readGenbankResource(\"/empty_header2.gb\");\n\t\tassertEquals(\"AZZZAA02123456789 10000000000 bp    DNA     linear   PRI 15-OCT-2018\", header2.getOriginalHeader());\n\t}\n\t\n\t@Test\n\tpublic void testLegacyLocusCompatable() throws IOException, CompoundNotFoundException {\n\t\t\n\t\t// Testing opening a genbank file with uppercase units, strand and topology\n\t\tAbstractSequence<? extends Compound> header0 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io/uppercase_locus0.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DS-DNA   CIRCULAR  SYN       22-JUL-1994\", header0.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header0.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase SS strand\n\t\tAbstractSequence<? extends Compound> header1 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus1.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP SS-DNA   CIRCULAR  SYN       13-JUL-1994\", header1.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header1.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase MS strand\n\t\tAbstractSequence<? extends Compound> header2 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus2.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP MS-DNA   CIRCULAR  SYN       13-JUL-1994\", header2.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header2.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase LINEAR topology\n\t\tAbstractSequence<? extends Compound> header3 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus3.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DNA   LINEAR    SYN       22-JUL-1994\", header3.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header3.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase units with no strand or topology\n\t\tAbstractSequence<? extends Compound> header4 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus4.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP RNA             SYN       13-JUL-1994\", header4.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header4.getAccession().getID());\n\t\tassertEquals(\"RNACompoundSet\", header4.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase units with no strand, topology, division or date\n\t\tAbstractSequence<? extends Compound> header5 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus5.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP DNA\", header5.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header5.getAccession().getID());\n\t\t\n\t\t// Testing uppercase units with no strand, molecule type, topology, division or date\n\t\tAbstractSequence<? extends Compound> header6 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus6.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 BP\", header6.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header6.getAccession().getID());\n\t\tassertEquals(\"DNACompoundSet\", header0.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t\t// Testing uppercase protein units\n\t\tAbstractSequence<? extends Compound> header7 = readUnknownGenbankResource(\"/org/biojava/nbio/core/sequence/io//uppercase_locus7.gb\");\n\t\tassertEquals(\"ABC12.3_DE   7071 AA Protein\", header7.getOriginalHeader());\n\t\tassertEquals(\"ABC12.3_DE\", header7.getAccession().getID());\n\t\tassertEquals(\"AminoAcidCompoundSet\", header7.getCompoundSet().getClass().getSimpleName());\n\t\t\n\t}\n\n\t@Test\n\tpublic void readSequenceWithZeroSpanFeature() throws IOException, CompoundNotFoundException {\n\t\tlogger.info(\"make or read genbank file error when feature spans zero point of circular sequence (issue #855)\");\n\t\tfinal DNASequence seq = readGenbankResource(\"/feature-spans-zero-point-circular-sequence.gb\");\n\n\t\tassertNotNull(seq);\n\n\t\tfinal FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> f = seq.getFeatures().get(33);\n\t\tfinal AbstractLocation fLocation = f.getLocations();\n\n\t\tassertTrue(fLocation.isCircular());\n\t\tassertEquals(7028, (int)fLocation.getStart().getPosition());\n\t\tassertEquals(286, (int)fLocation.getEnd().getPosition());\n\t\tassertEquals(Strand.NEGATIVE, fLocation.getStrand());\n\t}\n\n\t/**\n\t * Biojava fails to parse anticodon and transl_except feature qualifiers when they line wrap.\n\t * https://github.com/biojava/biojava/issues/843\n\t */\n\t@Test\n\tpublic void testGithub843() throws Exception {\n\t\tCheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/NC_018080.gb\"));\n\t\tassertNotNull(inStream);\n\n\t\tGenbankReader<DNASequence, NucleotideCompound> genbankDNA\n\t\t\t\t= new GenbankReader<>(\n\t\t\t\tinStream,\n\t\t\t\tnew GenericGenbankHeaderParser<>(),\n\t\t\t\tnew DNASequenceCreator(DNACompoundSet.getDNACompoundSet())\n\t\t);\n\n\t\tMap<String, DNASequence> dnaSequences = genbankDNA.process();\n\t\tassertNotNull(dnaSequences);\n\n\t\tDNASequence dna = new ArrayList<>(dnaSequences.values()).get(0);\n\t\tassertNotNull(dna);\n\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> tRNAFeature = dna.getFeaturesByType(\"tRNA\").get(0);\n\t\tString anticodon = tRNAFeature.getQualifiers().get(\"anticodon\").get(0).getValue();\n\t\tassertEquals(\"(pos:complement(1123552..1123554),aa:Leu,seq:caa)\", anticodon);\n\t\tString transl_except = tRNAFeature.getQualifiers().get(\"transl_except\").get(0).getValue();\n\t\tassertEquals(\"(pos:complement(1123552..1123554),aa:Leu)\",transl_except);\n\t}\n\n\t/**\n\t * Helper class to be able to verify the closed state of the input stream.\n\t */\n\tprivate static class CheckableInputStream extends BufferedInputStream {\n\n\t\tprivate boolean closed;\n\n\t\tCheckableInputStream(InputStream in) {\n\t\t\tsuper(in);\n\t\t\tclosed = false;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() throws IOException {\n\t\t\tsuper.close();\n\t\t\tclosed = true;\n\t\t}\n\n\t\tboolean isclosed() {\n\t\t\treturn closed;\n\t\t}\n\t}\n}\n","commitMessage":"Fix issue s1319 Declarations should use Java collection interfaces on biojava-core and dependencies\n","test_commitMessage":"Fix issue s1319 Declarations should use Java collection interfaces on biojava-core and dependencies\n","allZero":false}