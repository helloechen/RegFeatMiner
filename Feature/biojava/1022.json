{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/URLIdentifier.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestURLIdentifier.java","prod_time":"2021-10-30 05:42:41","test_time":"2021-10-30 05:42:41","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"POSITIVE","prod_commitID":"12d348d0ad2a4f252276d8e64cf46ace04fc37b0","test_commitID":"12d348d0ad2a4f252276d8e64cf46ace04fc37b0","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.cif.CifStructureConverter;\nimport org.biojava.nbio.structure.io.StructureFiletype;\nimport org.biojava.nbio.structure.io.mmtf.MmtfActions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Represents a structure loaded from a URL (including a file URL)\n *\n * A few custom query parameters are supported:\n *\n * <ul>\n * <li><tt>format=[pdb|cif]</tt> Specify the file format (will otherwise be\n *     guessed from the extension)\n * <li><tt>pdbId=[String]</tt> Specify the PDB ID (also guessed from the filename)\n * <li><tt>chainID=[String]</tt> A single chain from the structure\n * <li><tt>residues=[String]</tt> Residue ranges, in a form understood by\n *     {@link SubstructureIdentifier}\n * </ul>\n * @author Spencer Bliven\n *\n */\npublic class URLIdentifier implements StructureIdentifier {\n\tprivate static final long serialVersionUID = -5161230822868926035L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(URLIdentifier.class);\n\n\t// Used for guessing the PDB ID from the filename\n\tprivate static final Pattern PDBID_REGEX = Pattern.compile(\"^([0-9][a-z0-9]{3})([._-]|\\\\s).*\", Pattern.CASE_INSENSITIVE);\n\n\t/** URL parameter specifying the file format (PDB or CIF) */\n\tpublic static final String FORMAT_PARAM = \"format\";\n\t/** URL parameter specifying the PDB ID */\n\tpublic static final String PDBID_PARAM = \"pdbid\";\n\t/** URL parameter specifying a single chain to include; overridden by residues */\n\n\t//TODO: should this get renamed to chainname or asymid?\n\tpublic static final String CHAINID_PARAM = \"chainid\";\n\t/**\n\t * URL parameter specifying residue ranges to include, e.g. <tt>residues=A:1-70</tt>\n\t * @see SubstructureIdentifier\n\t */\n\tpublic static final String RESIDUES_PARAM = \"residues\";\n\n\tfinal private URL url;\n\tpublic URLIdentifier(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic URLIdentifier(String url) throws MalformedURLException {\n\t\tthis(new URL(url));\n\t}\n\n\tpublic URL getURL() {\n\t\treturn url;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn url.toString();\n\t}\n\n\t/**\n\t * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n\t */\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() {\n\t\tString pdbId = null;\n\t\tList<ResidueRange> ranges = Collections.emptyList();\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(PDBID_PARAM)) {\n\t\t\t\tpdbId = params.get(PDBID_PARAM);\n\t\t\t}\n\t\t\tif (params.containsKey(RESIDUES_PARAM)) {\n\t\t\t\tranges = ResidueRange.parseMultiple(params.get(RESIDUES_PARAM));\n\t\t\t} else if (params.containsKey(CHAINID_PARAM)) {\n\t\t\t\tranges = Collections.singletonList(new ResidueRange(params.get(CHAINID_PARAM), (ResidueNumber) null, (ResidueNumber) null));\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\t\tif (pdbId == null) {\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = guessPDBID(path.substring(path.lastIndexOf(\"/\") + 1));\n\t\t}\n\t\treturn new SubstructureIdentifier(pdbId, ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t/**\n\t * Load the structure from the URL\n\t * @return null\n\t */\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException, IOException {\n\t\tStructureFiletype format = StructureFiletype.UNKNOWN;\n\n\t\t// Use user-specified format\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(FORMAT_PARAM)) {\n\t\t\t\tString formatStr = params.get(FORMAT_PARAM);\n\t\t\t\tformat = StructureIO.guessFiletype(\".\" + formatStr);\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\n\t\t// Guess format from extension\n\t\tif (format == StructureFiletype.UNKNOWN) {\n\t\t\tformat = StructureIO.guessFiletype(url.getPath());\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase CIF: case BCIF:\n\t\t\t\treturn CifStructureConverter.fromURL(url, cache.getFileParsingParams());\n\t\t\tcase MMTF:\n\t\t\t\treturn MmtfActions.readFromInputStream(url.openStream());\n\t\t\tdefault: case PDB:\n\t\t\t\t// pdb file based parsing\n\t\t\t\tPDBFileReader reader = new PDBFileReader(cache.getPath());\n\t\t\t\treader.setFetchBehavior(cache.getFetchBehavior());\n\t\t\t\treader.setObsoleteBehavior(cache.getObsoleteBehavior());\n\t\t\t\treader.setFileParsingParameters(cache.getFileParsingParams());\n\t\t\t\treturn reader.getStructure(url);\n\t\t}\n\t}\n\n\t/**\n\t * Recognizes PDB IDs that occur at the beginning of name followed by some\n\t * delimiter.\n\t * @param name Input filename\n\t * @return A 4-character id-like string, or null if none is found\n\t */\n\tpublic static String guessPDBID(String name) {\n\t\tMatcher match = PDBID_REGEX.matcher(name);\n\t\tif (match.matches()) {\n\t\t\treturn match.group(1).toUpperCase();\n\t\t} else {\n\t\t\t// Give up if doesn't match\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Parses URL parameters into a map. Keys are stored lower-case.\n\t *\n\t * @param url\n\t * @return\n\t * @throws UnsupportedEncodingException\n\t */\n\tprivate static Map<String,String> parseQuery(URL url) throws UnsupportedEncodingException {\n\t\tMap<String,String> params = new LinkedHashMap<>();\n\t\tString query = url.getQuery();\n\t\tif (query == null || query.isEmpty()) {\n\t\t\t// empty query\n\t\t\treturn params;\n\t\t}\n\t\tString[] pairs = url.getQuery().split(\"&\");\n\t\tfor (String pair : pairs) {\n\t\t\tint i = pair.indexOf(\"=\");\n\t\t\tString key = pair;\n\t\t\tif (i > 0) {\n\t\t\t\tkey = URLDecoder.decode(pair.substring(0, i), \"UTF-8\");\n\t\t\t}\n\t\t\tString value = null;\n\t\t\tif(i > 0 && pair.length() > i + 1) {\n\t\t\t\tvalue = URLDecoder.decode(pair.substring(i + 1), \"UTF-8\");\n\t\t\t}\n\t\t\t// note that this uses the last instance if a parameter is specified multiple times\n\t\t\tparams.put(key.toLowerCase(), value);\n\t\t}\n\t\treturn params;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.structure.io.cif.CifStructureConverter;\nimport org.biojava.nbio.structure.io.StructureFiletype;\nimport org.biojava.nbio.structure.io.mmtf.MmtfActions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Represents a structure loaded from a URL (including a file URL)\n *\n * A few custom query parameters are supported:\n *\n * <ul>\n * <li><tt>format=[pdb|cif]</tt> Specify the file format (will otherwise be\n *     guessed from the extension)\n * <li><tt>pdbId=[String]</tt> Specify the PDB ID (also guessed from the filename)\n * <li><tt>chainID=[String]</tt> A single chain from the structure\n * <li><tt>residues=[String]</tt> Residue ranges, in a form understood by\n *     {@link SubstructureIdentifier}\n * </ul>\n * @author Spencer Bliven\n *\n */\npublic class URLIdentifier implements StructureIdentifier {\n\tprivate static final long serialVersionUID = -5161230822868926035L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(URLIdentifier.class);\n\n\t// Used for guessing the PDB ID from the filename\n\t//UPDATE: It seems that this RegEx rarely succeeded , because the file\n\t//name is most of the time in the format pdbxxxx.EXT not xxxx.EXT.\n\tprivate static final Pattern PDBID_REGEX = Pattern.compile(\"^(?:pdb)?([0-9][a-z0-9]{3})([._-]|\\\\s).*\", Pattern.CASE_INSENSITIVE);\n//\tprivate static final Pattern PDBID_REGEX = Pattern.compile(\"^(?:pdb)?((PDB_[0-9]{4})?[0-9][a-z0-9]{3})([._-]|\\\\s).*\", Pattern.CASE_INSENSITIVE);\n\t\n\t/** URL parameter specifying the file format (PDB or CIF) */\n\tpublic static final String FORMAT_PARAM = \"format\";\n\t/** URL parameter specifying the PDB ID */\n\tpublic static final String PDBID_PARAM = \"pdbid\";\n\t/** URL parameter specifying a single chain to include; overridden by residues */\n\n\t//TODO: should this get renamed to chainname or asymid?\n\tpublic static final String CHAINID_PARAM = \"chainid\";\n\t/**\n\t * URL parameter specifying residue ranges to include, e.g. <tt>residues=A:1-70</tt>\n\t * @see SubstructureIdentifier\n\t */\n\tpublic static final String RESIDUES_PARAM = \"residues\";\n\n\tfinal private URL url;\n\tpublic URLIdentifier(URL url) {\n\t\tthis.url = url;\n\t}\n\n\tpublic URLIdentifier(String url) throws MalformedURLException {\n\t\tthis(new URL(url));\n\t}\n\n\tpublic URL getURL() {\n\t\treturn url;\n\t}\n\n\t@Override\n\tpublic String getIdentifier() {\n\t\treturn url.toString();\n\t}\n\n\t/**\n\t * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n\t */\n\t@Override\n\tpublic SubstructureIdentifier toCanonical() throws StructureException{\n\t\tString pdbId = null;\n\t\tList<ResidueRange> ranges = Collections.emptyList();\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(PDBID_PARAM)) {\n\t\t\t\tpdbId = params.get(PDBID_PARAM);\n\t\t\t}\n\t\t\tif (params.containsKey(RESIDUES_PARAM)) {\n\t\t\t\tranges = ResidueRange.parseMultiple(params.get(RESIDUES_PARAM));\n\t\t\t} else if (params.containsKey(CHAINID_PARAM)) {\n\t\t\t\tranges = Collections.singletonList(new ResidueRange(params.get(CHAINID_PARAM), (ResidueNumber) null, (ResidueNumber) null));\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\t\tif (pdbId == null) {\n\t\t\tString path = url.getPath();\n\t\t\tpdbId = guessPDBID(path.substring(path.lastIndexOf(\"/\") + 1));\n\t\t}\n\t\treturn new SubstructureIdentifier(new PdbId(pdbId), ranges);\n\t}\n\n\t@Override\n\tpublic Structure reduce(Structure input) throws StructureException {\n\t\treturn toCanonical().reduce(input);\n\t}\n\n\t/**\n\t * Load the structure from the URL\n\t * @return null\n\t */\n\t@Override\n\tpublic Structure loadStructure(AtomCache cache) throws StructureException, IOException {\n\t\tStructureFiletype format = StructureFiletype.UNKNOWN;\n\n\t\t// Use user-specified format\n\t\ttry {\n\t\t\tMap<String, String> params = parseQuery(url);\n\t\t\tif (params.containsKey(FORMAT_PARAM)) {\n\t\t\t\tString formatStr = params.get(FORMAT_PARAM);\n\t\t\t\tformat = StructureIO.guessFiletype(\".\" + formatStr);\n\t\t\t}\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tlogger.error(\"Unable to decode URL {}\", url, e);\n\t\t}\n\n\t\t// Guess format from extension\n\t\tif (format == StructureFiletype.UNKNOWN) {\n\t\t\tformat = StructureIO.guessFiletype(url.getPath());\n\t\t}\n\n\t\tswitch(format) {\n\t\t\tcase CIF: case BCIF:\n\t\t\t\treturn CifStructureConverter.fromURL(url, cache.getFileParsingParams());\n\t\t\tcase MMTF:\n\t\t\t\treturn MmtfActions.readFromInputStream(url.openStream());\n\t\t\tdefault: case PDB:\n\t\t\t\t// pdb file based parsing\n\t\t\t\tPDBFileReader reader = new PDBFileReader(cache.getPath());\n\t\t\t\treader.setFetchBehavior(cache.getFetchBehavior());\n\t\t\t\treader.setObsoleteBehavior(cache.getObsoleteBehavior());\n\t\t\t\treader.setFileParsingParameters(cache.getFileParsingParams());\n\t\t\t\treturn reader.getStructure(url);\n\t\t}\n\t}\n\n\t/**\n\t * Recognizes PDB IDs that occur at the beginning of name followed by some\n\t * delimiter.\n\t * @param name Input filename\n\t * @return A 4-character id-like string, or null if none is found\n\t */\n\tpublic static String guessPDBID(String name) {\n\t\tMatcher match = PDBID_REGEX.matcher(name);\n\t\tif (match.matches()) {\n\t\t\treturn match.group(1).toUpperCase();\n\t\t}\n\t\t// Give up if doesn't match\n\t\treturn null;\n\t}\n\n\t/**\n\t * Parses URL parameters into a map. Keys are stored lower-case.\n\t *\n\t * @param url\n\t * @return\n\t * @throws UnsupportedEncodingException\n\t */\n\tprivate static Map<String,String> parseQuery(URL url) throws UnsupportedEncodingException {\n\t\tMap<String,String> params = new LinkedHashMap<>();\n\t\tString query = url.getQuery();\n\t\tif (query == null || query.isEmpty()) {\n\t\t\t// empty query\n\t\t\treturn params;\n\t\t}\n\t\tString[] pairs = url.getQuery().split(\"&\");\n\t\tfor (String pair : pairs) {\n\t\t\tint i = pair.indexOf(\"=\");\n\t\t\tString key = pair;\n\t\t\tif (i > 0) {\n\t\t\t\tkey = URLDecoder.decode(pair.substring(0, i), \"UTF-8\");\n\t\t\t}\n\t\t\tString value = null;\n\t\t\tif(i > 0 && pair.length() > i + 1) {\n\t\t\t\tvalue = URLDecoder.decode(pair.substring(i + 1), \"UTF-8\");\n\t\t\t}\n\t\t\t// note that this uses the last instance if a parameter is specified multiple times\n\t\t\tparams.put(key.toLowerCase(), value);\n\t\t}\n\t\treturn params;\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class TestURLIdentifier {\n\tprivate static final Logger logger = LoggerFactory.getLogger(TestURLIdentifier.class);\n\t@Test\n\tpublic void testFileIdentifiers() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\turl = getClass().getResource(\"/2pos.pdb\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"PDB file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t\turl = getClass().getResource(\"/4hhb.cif.gz\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"CIF file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t}\n\n\t@Test\n\tpublic void testURLParameters() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\tString base = getClass().getResource(\"/2pos.pdb\").getPath();\n\n\t\turl = new URL(\"file://\" + base + \"?format=PDB\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\tassertEquals(\"2POS\",id.toCanonical().getPdbId());\n//\t\tassertEquals(\"2POS\",full.getName()); // What should this get set to with identifiers?\n\n\t\turl = new URL(\"file://\" + base + \"?residues=A:1-5\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for residues=A:1-5\",\"2POS.A_1-5\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for residues=A:1-5\", 5, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\turl = new URL(\"file://\" + base + \"?chainId=A\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for chainId=A\",\"2POS.A\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for chainName=A\", 94, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\ttry {\n\t\t\turl = new URL(\"https://files.rcsb.org/download/1B8G.pdb.gz\");\n\t\t\tid = new URLIdentifier(url);\n\n\t\t\tfull = id.loadStructure(cache);\n\t\t\tassertNotNull(full);\n\t\t\tassertEquals(\"1B8G\",id.toCanonical().getPdbId());\n\t\t} catch(UnknownHostException e) {\n\t\t\tlogger.error(\"Unable to connect to rcsb.org\");\n\t\t\t// still pass\n\t\t}\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.UnknownHostException;\nimport java.util.Arrays;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class TestURLIdentifier {\n\tprivate static final Logger logger = LoggerFactory.getLogger(TestURLIdentifier.class);\n\t@Test\n\tpublic void testFileIdentifiers() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\turl = getClass().getResource(\"/2pos.pdb\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"PDB file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t\turl = getClass().getResource(\"/4hhb.cif.gz\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(\"CIF file didn't work\",full);\n\n\t\treduced = id.reduce(full);\n\t\tassertTrue(Arrays.deepEquals(StructureTools.getAllAtomArray(full),\n\t\t\t\tStructureTools.getAllAtomArray(reduced)));\n\n\t}\n\n\t@Test\n\tpublic void testURLParameters() throws StructureException, IOException {\n\t\tAtomCache cache = new AtomCache();\n\n\t\tURL url;\n\t\tStructure full, reduced;\n\t\tURLIdentifier id;\n\n\t\tString base = getClass().getResource(\"/2pos.pdb\").getPath();\n\n\t\turl = new URL(\"file://\" + base + \"?format=PDB\");\n\t\tid = new URLIdentifier(url);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\tassertEquals(new PdbId(\"2POS\"), id.toCanonical().getPdbId());\n//\t\tassertEquals(\"2POS\",full.getName()); // What should this get set to with identifiers?\n\n\t\turl = new URL(\"file://\" + base + \"?residues=A:1-5\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for residues=A:1-5\",\"2POS.A_1-5\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for residues=A:1-5\", 5, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\turl = new URL(\"file://\" + base + \"?chainId=A\");\n\t\tid = new URLIdentifier(url);\n\t\tassertEquals(\"wrong canonical for chainId=A\",\"2POS.A\",id.toCanonical().toString());\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertNotNull(full);\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"wrong length for chainName=A\", 94, StructureTools.getRepresentativeAtomArray(reduced).length);\n\n\t\ttry {\n\t\t\turl = new URL(\"https://files.rcsb.org/download/1B8G.pdb.gz\");\n\t\t\tid = new URLIdentifier(url);\n\n\t\t\tfull = id.loadStructure(cache);\n\t\t\tassertNotNull(full);\n\t\t\tassertEquals(new PdbId(\"1B8G\"), id.toCanonical().getPdbId());\n\t\t} catch(UnknownHostException e) {\n\t\t\tlogger.error(\"Unable to connect to rcsb.org\");\n\t\t\t// still pass\n\t\t}\n\t}\n}\n","commitMessage":"Support extended pdbid (#950)\n\n* Support for extended PDBID PDB_nnnnNXXX\r\n\r\nCreated a new class PDBId, and removed old deprecated methods.\r\nMost of the changes are in Structure, StructureImpl, and PDBFileParser\r\nclasses.\r\n\r\n* Some deprecated functions removal\r\n\r\n* Fix typo\r\n\r\n* Targeted most of Spencer's comments\r\n\r\n* Fixed a bug in PDBId.equals() method\r\n\r\n* Changing PDBID in SCOP record to lower case\r\n\r\nto match the expected String\r\n\r\n* public static PDBId field XXXX\r\n\r\n* Behavior is now an enum\r\n\r\n* Expose Pattern objects instead of Strings\r\n\r\n* ID stored internally in a reduced format (without initial \"PDB_\" prefix)\r\n\r\nOnly the ID proper is stored (in upper case).\r\ne.g. for 1abc we store 00001ABC.\r\n\r\nThis format is the trade off between storing short/extended format and\r\nall extended format.\r\nstoring the ID proper allows direct comparison and fast ordering of\r\nPDBId objects with uniform names in the format \\d{4}[1-9][0-9A-Z]{3}.\r\n\r\n* Enhancements and bug fix\r\n\r\n* Added BDBId Unit test\r\n\r\n* Added @Deprecated codeTag\r\n\r\n* Adding more TODOs\r\n\r\n* more replacement of deprecated methods\r\n\r\n* Removed PDBIdException\r\n\r\nI replaced the PDBException with IllegalArgumentException or\r\nStructureException:\r\n- Constant literal extraction\r\n- Inlined short private methods\r\n- Renamed isShortPDBId() and isExtendedPDBID() to isValidShortPDBID()\r\nand isValidExtendedPDBID()\r\n\r\nAdditional modifications:\r\n- Organized imports\r\n\r\n* review and untouch regular expressions\r\n\r\n* Un-deprecate, copy javadoc, and remove @author on methods\r\n\r\n* Remove NullPointerException\r\n\r\nI will write the full class javadoc later\r\n\r\n* Bug fix\r\n\r\n* clean commented out code\r\n\r\n* Update CHANGELOG\r\n\r\nMentioned that getReducedStructure() is removed from StructureTools\r\n\r\n* Fix unit test\r\n\r\nI accident.y found that the test case is not written as it should be.\r\n\r\n* PdbPair does not accept null\r\n\r\nIt also considers an object and its reverse equal\r\n\r\n* Addressing reviewer's comments\r\n\r\n* Change capitalization state\r\n\r\n- Class name: changed into PdbId\r\n- methods name: changed into getPdbId(), setPdbId(PdbId)\r\n- field name: pdbId\r\n\r\n* Fix probable NPE + keep consistent PdbId method naming convention\r\n\r\n* Addressed some of the reviewer's comments.\r\n\r\n* Use JUnit 5\r\n\r\n* PdbId class Documentation\r\n\r\n* JavaDoc style update\r\n\r\n* Minor updates\r\n\r\n* Reverting a wrong optimization\r\n\r\nIt introduced a new bug. Reverting it.\r\n\r\n* Adding BioJava development code\r\n\r\n* Javadoc\r\n\r\n* XXXX PdbId objects are not equal unless they are the same object\r\n\r\n* No more XXXX. ANY malformed PdbId gracefully set to null\r\n\r\n* Addressing Reviewer's comments\r\n\r\n* Removing TODOs","test_commitMessage":"Support extended pdbid (#950)\n\n* Support for extended PDBID PDB_nnnnNXXX\r\n\r\nCreated a new class PDBId, and removed old deprecated methods.\r\nMost of the changes are in Structure, StructureImpl, and PDBFileParser\r\nclasses.\r\n\r\n* Some deprecated functions removal\r\n\r\n* Fix typo\r\n\r\n* Targeted most of Spencer's comments\r\n\r\n* Fixed a bug in PDBId.equals() method\r\n\r\n* Changing PDBID in SCOP record to lower case\r\n\r\nto match the expected String\r\n\r\n* public static PDBId field XXXX\r\n\r\n* Behavior is now an enum\r\n\r\n* Expose Pattern objects instead of Strings\r\n\r\n* ID stored internally in a reduced format (without initial \"PDB_\" prefix)\r\n\r\nOnly the ID proper is stored (in upper case).\r\ne.g. for 1abc we store 00001ABC.\r\n\r\nThis format is the trade off between storing short/extended format and\r\nall extended format.\r\nstoring the ID proper allows direct comparison and fast ordering of\r\nPDBId objects with uniform names in the format \\d{4}[1-9][0-9A-Z]{3}.\r\n\r\n* Enhancements and bug fix\r\n\r\n* Added BDBId Unit test\r\n\r\n* Added @Deprecated codeTag\r\n\r\n* Adding more TODOs\r\n\r\n* more replacement of deprecated methods\r\n\r\n* Removed PDBIdException\r\n\r\nI replaced the PDBException with IllegalArgumentException or\r\nStructureException:\r\n- Constant literal extraction\r\n- Inlined short private methods\r\n- Renamed isShortPDBId() and isExtendedPDBID() to isValidShortPDBID()\r\nand isValidExtendedPDBID()\r\n\r\nAdditional modifications:\r\n- Organized imports\r\n\r\n* review and untouch regular expressions\r\n\r\n* Un-deprecate, copy javadoc, and remove @author on methods\r\n\r\n* Remove NullPointerException\r\n\r\nI will write the full class javadoc later\r\n\r\n* Bug fix\r\n\r\n* clean commented out code\r\n\r\n* Update CHANGELOG\r\n\r\nMentioned that getReducedStructure() is removed from StructureTools\r\n\r\n* Fix unit test\r\n\r\nI accident.y found that the test case is not written as it should be.\r\n\r\n* PdbPair does not accept null\r\n\r\nIt also considers an object and its reverse equal\r\n\r\n* Addressing reviewer's comments\r\n\r\n* Change capitalization state\r\n\r\n- Class name: changed into PdbId\r\n- methods name: changed into getPdbId(), setPdbId(PdbId)\r\n- field name: pdbId\r\n\r\n* Fix probable NPE + keep consistent PdbId method naming convention\r\n\r\n* Addressed some of the reviewer's comments.\r\n\r\n* Use JUnit 5\r\n\r\n* PdbId class Documentation\r\n\r\n* JavaDoc style update\r\n\r\n* Minor updates\r\n\r\n* Reverting a wrong optimization\r\n\r\nIt introduced a new bug. Reverting it.\r\n\r\n* Adding BioJava development code\r\n\r\n* Javadoc\r\n\r\n* XXXX PdbId objects are not equal unless they are the same object\r\n\r\n* No more XXXX. ANY malformed PdbId gracefully set to null\r\n\r\n* Addressing Reviewer's comments\r\n\r\n* Removing TODOs","allZero":false}