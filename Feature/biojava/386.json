{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/Bond.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestBond.java","prod_time":"2015-08-15 05:04:24","test_time":"2016-01-26 06:24:05","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":1,"del_call_line":5,"del_classname_line":1,"del_condition_line":3,"del_field_line":4,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":7,"label":"NEGATIVE","prod_commitID":"1b363093a5b3fa912edf117257ebd8288a829c16","test_commitID":"23aa68edb9bc097c4742011853188b116cddedb7","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage org.biojava.nbio.structure;\r\n\r\nimport java.io.Serializable;\n\r\n/**\r\n * A simple bond -- it stores information about two atoms as well as information\r\n * about its bond order.\r\n * \r\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\r\n * @author Ulysse Carion\r\n */\r\npublic class Bond implements Serializable {\r\n\r\n\tprivate static final long serialVersionUID = 8836120946858134380L;\r\n\tprivate Atom atomA;\r\n\tprivate Atom atomB;\r\n\tprivate int bondOrder;\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * <p>\r\n\t * Note that by forming a bond between atoms 'A' and 'B' with this\r\n\t * constructor, atoms 'A' and 'B' will be updated to have this bond in their\r\n\t * list of bonds. If you do not want this automatic updating, instead use\r\n\t * {@link #Bond(Atom, Atom, int, boolean)} with the\r\n\t * <code>addSelfToAtoms</code> flag set to <code>false</code>.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\r\n\t\tthis(atomA, atomB, bondOrder, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t * @param addSelfToAtoms\r\n\t *            if set to true, this bond, once created, will automatically\r\n\t *            add itself to atomA and atomB's bond lists. (If this argument\r\n\t *            is set to false, the list returned from\r\n\t *            {@link Atom#getBonds()} will not contain this bond.)\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\r\n\t\tthis.atomA = atomA;\r\n\t\tthis.atomB = atomB;\r\n\t\tthis.bondOrder = bondOrder;\r\n\r\n\t\tif (addSelfToAtoms) {\r\n\t\t\taddSelfToAtoms();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\r\n\t * then the list returned from calling {@link Atom#getBonds()} will not\r\n\t * include this bond.\r\n\t * <p>\r\n\t * If you created your Bond with the constructor\r\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\r\n\t * you and should not be called again.\r\n\t */\r\n\t// TODO first check if those bonds haven't been made already\r\n\tpublic void addSelfToAtoms() {\r\n\t\tatomA.addBond(this);\r\n\t\tatomB.addBond(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomB()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomA() {\r\n\t\treturn atomA;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomA()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomB() {\r\n\t\treturn atomB;\r\n\t}\r\n\r\n\t/**\r\n\t * A utility method to get the other atom in a bond, given one of its atoms.\r\n\t * If the atom passed is one of the atoms in this bond, then this method is\r\n\t * essentially equivalent to saying\r\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\r\n\t * <p>\r\n\t * <i>Note:</i> Comparison of atoms in this method is done with\r\n\t * <code>==</code>, not <code>equals</code>.\r\n\t * \r\n\t * @param exclude\r\n\t *            the atom of the bond to not return\r\n\t * @throws IllegalArgumentException\r\n\t *             if the passed atom is not in this bond\r\n\t * @return the atom in this bond that was not passed as an argument\r\n\t */\r\n\tpublic Atom getOther(Atom exclude) {\r\n\t\tif (exclude != atomA && exclude != atomB) {\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\r\n\t\t}\r\n\r\n\t\tif (exclude == atomA) {\r\n\t\t\treturn atomB;\r\n\t\t} else {\r\n\t\t\treturn atomA;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\r\n\t * single bond, '2' to a double bond, etc.\r\n\t * \r\n\t * @return this bond's bond order\r\n\t */\r\n\tpublic int getBondOrder() {\r\n\t\treturn bondOrder;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance between the two atoms of this bond.\r\n\t * <p>\r\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\r\n\t * this method will suppress the empty threat of a\r\n\t * {@link StructureException} that method makes.\r\n\t * \r\n\t * @return the distance between the two atoms of this bond.\r\n\t */\r\n\tpublic double getLength() {\r\n\r\n\t\treturn Calc.getDistance(atomA, atomB);\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\r\n\t\t\t\t+ bondOrder + \"]\";\r\n\t}\r\n}\r\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\n/**\n * A simple bond -- it stores information about two atoms as well as information\n * about its bond order.\n *\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\n * @author Ulysse Carion\n */\npublic interface Bond {\n    /**\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\n\t * then the list returned from calling {@link Atom#getBonds()} will not\n\t * include this bond.\n\t * <p>\n\t * If you created your Bond with the constructor\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\n\t * you and should not be called again.\n\t */\n\tpublic void addSelfToAtoms();\n\n\t/**\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomB()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomA();\n\n\t/**\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomA()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomB();\n\n\t/**\n\t * A utility method to get the other atom in a bond, given one of its atoms.\n\t * If the atom passed is one of the atoms in this bond, then this method is\n\t * essentially equivalent to saying\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\n\t * <p>\n\t * <i>Note:</i> Comparison of atoms in this method is done with\n\t * <code>==</code>, not <code>equals</code>.\n\t * \n\t * @param exclude\n\t *            the atom of the bond to not return\n\t * @throws IllegalArgumentException\n\t *             if the passed atom is not in this bond\n\t * @return the atom in this bond that was not passed as an argument\n\t */\n\tpublic Atom getOther(Atom exclude);\n\n\t/**\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\n\t * single bond, '2' to a double bond, etc.\n\t * \n\t * @return this bond's bond order\n\t */\n\tpublic int getBondOrder();\n\n\t/**\n\t * Gets the distance between the two atoms of this bond.\n\t * <p>\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\n\t * this method will suppress the empty threat of a\n\t * {@link StructureException} that method makes.\n\t * \n\t * @return the distance between the two atoms of this bond.\n\t */\n\tpublic double getLength();\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport junit.framework.TestCase;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.junit.Before;\n\nimport java.io.IOException;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\n\t@Override\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\n\t\tcache.setUseMmCif(false);\n\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\n\t\tStructureIO.setAtomCache(cache);\n\n\n\t}\n\n\tpublic void testIntraResidueBonds() throws StructureException, IOException {\n\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\n\n\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testPeptideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\n\tpublic void testLINKBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\t\n\t\tGroup g1 = s.getChainByPDB(\"A\").getSeqResGroup(50);\n\t\tassertNotNull(g1);\n\t\t\n\t\tassertTrue(g1 instanceof AminoAcid);\n\n\t\tAminoAcid aa = (AminoAcid)g1;\n\t\tassertTrue(aa.getRecordType().equals(AminoAcid.ATOMRECORD));\n\n\t\tAtom atom1 = g1.getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testDisulfideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testLigandBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.junit.Before;\n\nimport junit.framework.TestCase;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\n\t@Override\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\n\t\tcache.setUseMmCif(false);\n\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\n\t\tparams.setAlignSeqRes(false);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\n\t\tStructureIO.setAtomCache(cache);\n\n\n\t}\n\n\tpublic void testIntraResidueBonds() throws StructureException, IOException {\n\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\n\n\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testPeptideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\n\tpublic void testLINKBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\t\n\t\tGroup g1 = s.getChainByPDB(\"A\").getSeqResGroup(50);\n\t\tassertNotNull(g1);\n\t\t\n\t\tassertTrue(g1 instanceof AminoAcid);\n\n\t\tAminoAcid aa = (AminoAcid)g1;\n\t\tassertTrue(aa.getRecordType().equals(AminoAcid.ATOMRECORD));\n\n\t\tAtom atom1 = g1.getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testDisulfideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testLigandBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","commitMessage":"Bond and SSBond now implemented as interfaces backed by BondImpl and SSBondImpl, respectively.\n","test_commitMessage":"Issue 343: header-only parsing of SEQRES\n * FileParsingParameters.storeEmptySeqRes option is dropped.\n * FileParsingParameters.alignSeqRes is true by default.  When false, it behaves will store seqres that has been parsed, but without aligning to replace with AtomGroups (behaviour previously of storeEmptySeqRes).\n * FileParsingParameters.headerOnly when true will still parse SEQRES since this would belong to the header.\n * PDBFileParser and SimpleMMcifConsumer were updated for matching behaviors to the options.\n * Existing unit tests were updated for this change.\n * Added a new unit test to specifically test the setHeaderOnly() option and parsing of SEQRES.\n","allZero":false}