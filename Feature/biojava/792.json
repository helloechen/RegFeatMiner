{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/alignment/SimpleAlignedSequence.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/alignment/SimpleAlignedSequenceTest.java","prod_time":"2017-07-06 02:52:09","test_time":"","type":"","proType":"EDIT","add_annotation_line":8,"add_call_line":13,"add_classname_line":0,"add_condition_line":9,"add_field_line":3,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":9,"del_annotation_line":2,"del_call_line":0,"del_classname_line":0,"del_condition_line":2,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"a3edf549cf4353fd52f72b0b3ceffe977a32f1ce","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n * @author Paolo Pavan\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.location.template.Point;\nimport org.biojava.nbio.core.sequence.template.*;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<S extends Sequence<C>, C extends Compound> implements Serializable, AlignedSequence<S, C> {\n\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String gap = \"-\";\n\n\t// always stored\n\tprivate AlignedSequence<S, C> prev;\n\tprivate S original;\n\tprivate int length, numBefore, numAfter;\n\tprivate Location location;\n\n\t// cached (lazily initialized)\n\tprivate int numGaps = -1;\n\tprivate int[] alignmentFromSequence, sequenceFromAlignment;\n\n\t/**\n\t * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n\t *\n\t * @param original the original {@link Sequence} before alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(S original, List<Step> steps) {\n\t\tthis(original, steps, 0, 0);\n\t}\n\n\t/**\n\t * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n\t *\n\t * @param original the original {@link Sequence} before alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param numBefore number of {@link Compound}s before a local alignment\n\t * @param numAfter number of {@link Compound}s after a local alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(S original, List<Step> steps, int numBefore, int numAfter) {\n\t\tthis.original = original;\n\t\tthis.numBefore = numBefore;\n\t\tthis.numAfter = numAfter;\n\t\tlength = steps.size();\n\t\tsetLocation(steps);\n\t}\n\n\t/**\n\t * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a global alignment.\n\t *\n\t * @param prev the previous {@link AlignedSequence} before this alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps) {\n\t\tthis(prev, steps, 0, 0);\n\t}\n\n\t/**\n\t * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a local alignment.\n\t *\n\t * @param prev the previous {@link AlignedSequence} before this alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param numBefore number of {@link Compound}s before a local alignment\n\t * @param numAfter number of {@link Compound}s after a local alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps, int numBefore, int numAfter) {\n\t\tthis.prev = prev;\n\t\tthis.original = prev.getOriginalSequence();\n\t\tthis.numBefore = numBefore;\n\t\tthis.numAfter = numAfter;\n\t\tif (prev instanceof SimpleAlignedSequence<?, ?>) {\n\t\t\tSimpleAlignedSequence<?, ?> p = (SimpleAlignedSequence<?, ?>) prev;\n\t\t\tthis.numBefore += p.numBefore;\n\t\t\tthis.numAfter += p.numAfter;\n\t\t}\n\t\tlength = steps.size();\n\t\tsetLocation(steps);\n\t}\n\n\t// methods for AlignedSequence\n\n\t@Override\n\tpublic void clearCache() {\n\t\talignmentFromSequence = null;\n\t\tsequenceFromAlignment = null;\n\t}\n\n\t@Override\n\tpublic int getAlignmentIndexAt(int sequenceIndex) {\n\t\tif (alignmentFromSequence == null) {\n\t\t\talignmentFromSequence = new int[original.getLength()];\n\t\t\tint s = 1, a = 1;\n\t\t\tfor (int i = 0; i < numBefore; i++, s++) {\n\t\t\t\talignmentFromSequence[s - 1] = a;\n\t\t\t}\n\t\t\tfor (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n\t\t\t\twhile (a <= length && isGap(a)) {\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\talignmentFromSequence[s - 1] = a;\n\t\t\t}\n\t\t\ta--;\n\t\t\tfor (int i = 0; i < numAfter; i++, s++) {\n\t\t\t\talignmentFromSequence[s - 1] = a;\n\t\t\t}\n\t\t}\n\t\treturn alignmentFromSequence[sequenceIndex - 1];\n\t}\n\n\t@Override\n\tpublic Point getEnd() {\n\t\treturn location.getEnd();\n\t}\n\n\t@Override\n\tpublic Location getLocationInAlignment() {\n\t\treturn location;\n\t}\n\n\t@Override\n\tpublic int getNumGaps() {\n\t\tif (numGaps == -1) {\n\t\t\tnumGaps = 0;\n\t\t\tC cGap = getCompoundSet().getCompoundForString(gap);\n\t\t\tboolean inGap = false;\n\t\t\tfor (C compound : getAsList()) {\n\t\t\t\tif (compound == null || compound.equalsIgnoreCase(cGap)) {\n\t\t\t\t\tif (!inGap) {\n\t\t\t\t\t\tnumGaps++;\n\t\t\t\t\t\tinGap = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinGap = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn numGaps;\n\t}\n\n\t@Override\n\tpublic S getOriginalSequence() {\n\t\treturn original;\n\t}\n\n\t@Override\n\tpublic int getOverlapCount() {\n\t\t// TODO handle circular alignments\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic int getSequenceIndexAt(int alignmentIndex) {\n\t\tif (sequenceFromAlignment == null) {\n\t\t\tsequenceFromAlignment = new int[length];\n\t\t\tint a = 1, s = numBefore + 1;\n\t\t\tfor (int i = 0; i < getStart().getPosition(); i++, a++) {\n\t\t\t\tsequenceFromAlignment[a - 1] = s;\n\t\t\t}\n\t\t\tfor (; a <= length; a++) {\n\t\t\t\tif (!isGap(a)) {\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t\tsequenceFromAlignment[a - 1] = s;\n\t\t\t}\n\t\t}\n\t\treturn sequenceFromAlignment[alignmentIndex - 1];\n\t}\n\n\t@Override\n\tpublic Point getStart() {\n\t\treturn location.getStart();\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\treturn location.isCircular();\n\t}\n\n\t@Override\n\tpublic boolean isGap(int alignmentIndex) {\n\t\tif (getStart().getPosition() <= alignmentIndex && alignmentIndex <= getEnd().getPosition()) {\n\t\t\tif (!location.isComplex()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Location sublocation : location) {\n\t\t\t\tif (sublocation.getStart().getPosition() <= alignmentIndex &&\n\t\t\t\t\t\talignmentIndex <= sublocation.getEnd().getPosition()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// methods for Sequence\n\n\t@Override\n\tpublic int countCompounds(C... compounds) {\n\t\tint count = 0;\n\t\tList<C> search = Arrays.asList(compounds);\n\t\tfor (C compound : getAsList()) {\n\t\t\tif (search.contains(compound)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t@Override\n\tpublic AccessionID getAccession() {\n\t\treturn original.getAccession();\n\t}\n\n\t@Override\n\tpublic List<C> getAsList() {\n\t\tList<C> compounds = new ArrayList<C>();\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tcompounds.add(getCompoundAt(i));\n\t\t}\n\t\treturn compounds;\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int alignmentIndex) {\n\t\treturn alignmentIndex >= 1 && alignmentIndex <= length && isGap(alignmentIndex) ?\n\t\t\t\tgetCompoundSet().getCompoundForString(gap) :\n\t\t\t\toriginal.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn original.getCompoundSet();\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (compound.equals(getCompoundAt(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (compound.equals(getCompoundAt(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic String getSequenceAsString() {\n\t\treturn SequenceMixin.toString(this);\n\t}\n\n\t@Override\n\tpublic SequenceView<C> getSubSequence(Integer start, Integer end) {\n\t\treturn SequenceMixin.createSubSequence(this, start, end);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<C> iterator() {\n\t\treturn getAsList().iterator();\n\t}\n\n\t// method from Object\n\n\t/**\n\t * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getSequenceAsString();\n\t}\n\n\t// helper method to initialize the location\n\tprivate void setLocation(List<Step> steps) {\n\t\tList<Location> sublocations = new ArrayList<Location>();\n\t\tint start = 0, step = 0, oStep = numBefore+numAfter, oMax = this.original.getLength(), pStep = 0, pMax =\n\t\t\t\t(prev == null) ? 0 : prev.getLength();\n\t\tboolean inGap = true;\n\n\t\t// build sublocations: pieces of sequence separated by gaps\n\t\tfor (; step < length; step++) {\n\t\t\tboolean isGapStep = (steps.get(step) == Step.GAP),\n\t\t\t\t\tisGapPrev = (pStep < pMax && prev.isGap(pStep + 1));\n\t\t\tif (!isGapStep && !isGapPrev) {\n\t\t\t\toStep++;\n\t\t\t\tif (inGap) {\n\t\t\t\t\tinGap = false;\n\t\t\t\t\tstart = step + 1;\n\t\t\t\t}\n\t\t\t} else if (!inGap) {\n\t\t\t\tinGap = true;\n\t\t\t\tsublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n\t\t\t}\n\t\t\tif (prev != null && !isGapStep) {\n\t\t\t\tpStep++;\n\t\t\t}\n\t\t}\n\t\tif (!inGap) {\n\t\t\tsublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n\t\t}\n\n\t\t// combine sublocations into 1 Location\n\t\tif (sublocations.size() == 0) {\n\t\t\tlocation = null;\n\t\t} else if (sublocations.size() == 1) {\n\t\t\tlocation = sublocations.get(0);\n\t\t} else {\n\t\t\tlocation = new SimpleLocation(sublocations.get(0).getStart(), sublocations.get(sublocations.size() - 1).getEnd(),\n\t\t\t\t\tStrand.UNDEFINED,\n\t\t\t\t\tfalse, sublocations);\n\t\t}\n\t\t// TODO handle circular alignments\n\n\t\t// check that alignment has correct number of compounds in it to fit original sequence\n\t\tif (step != length || oStep != oMax || pStep != pMax) {\n\t\t\tthrow new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n\t\t}\n\t}\n\n\t@Override\n\t//TODO Needs to implements\n\tpublic SequenceView<C> getInverse() {\n\t\tthrow new UnsupportedOperationException(\"Not supported yet.\");\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n * @author Paolo Pavan\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.location.template.Point;\nimport org.biojava.nbio.core.sequence.template.*;\nimport org.biojava.nbio.core.util.Equals;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * Implements a data structure for a {@link Sequence} within an alignment.\n *\n * @author Mark Chapman\n * @param <C> each element of the {@link Sequence} is a {@link Compound} of type C\n */\npublic class SimpleAlignedSequence<S extends Sequence<C>, C extends Compound> implements Serializable, AlignedSequence<S, C> {\n\n\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final String gap = \"-\";\n\n\t// always stored\n\tprivate AlignedSequence<S, C> prev;\n\tprivate S original;\n\tprivate int length, numBefore, numAfter;\n\tprivate Location location;\n\n\t// cached (lazily initialized)\n\tprivate int numGaps = -1;\n\tprivate int numGapPositions = -1;\n\n\tprivate int[] alignmentFromSequence;\n\tprivate int[] sequenceFromAlignment;\n\n\t/**\n\t * Creates an {@link AlignedSequence} for the given {@link Sequence} in a global alignment.\n\t *\n\t * @param original the original {@link Sequence} before alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(S original, List<Step> steps) {\n\t\tthis(original, steps, 0, 0);\n\t}\n\n\t/**\n\t * Creates an {@link AlignedSequence} for the given {@link Sequence} in a local alignment.\n\t *\n\t * @param original the original {@link Sequence} before alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param numBefore number of {@link Compound}s before a local alignment\n\t * @param numAfter number of {@link Compound}s after a local alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(S original, List<Step> steps, int numBefore, int numAfter) {\n\t\tthis.original = original;\n\t\tthis.numBefore = numBefore;\n\t\tthis.numAfter = numAfter;\n\t\tlength = steps.size();\n\t\tsetLocation(steps);\n\t}\n\n\t/**\n\t * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a global alignment.\n\t *\n\t * @param prev the previous {@link AlignedSequence} before this alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps) {\n\t\tthis(prev, steps, 0, 0);\n\t}\n\n\t/**\n\t * Creates a new {@link AlignedSequence} for the given {@link AlignedSequence} in a local alignment.\n\t *\n\t * @param prev the previous {@link AlignedSequence} before this alignment\n\t * @param steps lists whether the sequence aligns a {@link Compound} or gap at each index of the alignment\n\t * @param numBefore number of {@link Compound}s before a local alignment\n\t * @param numAfter number of {@link Compound}s after a local alignment\n\t * @throws IllegalArgumentException if given sequence does not fit in alignment\n\t */\n\tpublic SimpleAlignedSequence(AlignedSequence<S, C> prev, List<Step> steps, int numBefore, int numAfter) {\n\t\tthis.prev = prev;\n\t\tthis.original = prev.getOriginalSequence();\n\t\tthis.numBefore = numBefore;\n\t\tthis.numAfter = numAfter;\n\t\tif (prev instanceof SimpleAlignedSequence<?, ?>) {\n\t\t\tSimpleAlignedSequence<?, ?> p = (SimpleAlignedSequence<?, ?>) prev;\n\t\t\tthis.numBefore += p.numBefore;\n\t\t\tthis.numAfter += p.numAfter;\n\t\t}\n\t\tlength = steps.size();\n\t\tsetLocation(steps);\n\t}\n\n\t// methods for AlignedSequence\n\n\t@Override\n\tpublic void clearCache() {\n\t\talignmentFromSequence = null;\n\t\tsequenceFromAlignment = null;\n\t}\n\n\tprivate void setAlignmentFromSequence() {\n\t\talignmentFromSequence = new int[original.getLength()];\n\t\tint s = 1, a = 1;\n\t\tfor (int i = 0; i < numBefore; i++, s++) {\n\t\t\talignmentFromSequence[s - 1] = a;\n\t\t}\n\t\tfor (; s <= alignmentFromSequence.length && a <= length; s++, a++) {\n\t\t\twhile (a <= length && isGap(a)) {\n\t\t\t\ta++;\n\t\t\t}\n\t\t\talignmentFromSequence[s - 1] = a;\n\t\t}\n\t\ta--;\n\t\tfor (int i = 0; i < numAfter; i++, s++) {\n\t\t\talignmentFromSequence[s - 1] = a;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int[] getAlignmentFromSequence() {\n\t\tif (alignmentFromSequence == null)\n\t\t\tsetAlignmentFromSequence();\n\t\treturn alignmentFromSequence;\n\t}\n\n\t@Override\n\tpublic int getAlignmentIndexAt(int sequenceIndex) {\n\t\tif (alignmentFromSequence == null)\n\t\t\tsetAlignmentFromSequence();\n\t\treturn alignmentFromSequence[sequenceIndex - 1];\n\t}\n\n\t@Override\n\tpublic Point getEnd() {\n\t\treturn location.getEnd();\n\t}\n\n\t@Override\n\tpublic Location getLocationInAlignment() {\n\t\treturn location;\n\t}\n\n\t@Override\n\tpublic int getNumGaps() {\n\t\tif (numGaps == -1) {\n\t\t\tnumGaps = 0;\n\t\t\tnumGapPositions = 0;\n\t\t\tC cGap = getCompoundSet().getCompoundForString(gap);\n\t\t\tboolean inGap = false;\n\t\t\tfor (C compound : getAsList()) {\n\t\t\t\tif (compound == null || compound.equalsIgnoreCase(cGap)) {\n\t\t\t\t\tif (!inGap) {\n\t\t\t\t\t\tnumGaps++;\n\t\t\t\t\t\tinGap = true;\n\t\t\t\t\t}\n\t\t\t\t\tnumGapPositions++;\n\t\t\t\t} else {\n\t\t\t\t\tinGap = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn numGaps;\n\t}\n\n\t@Override\n\tpublic S getOriginalSequence() {\n\t\treturn original;\n\t}\n\n\t@Override\n\tpublic int getOverlapCount() {\n\t\t// TODO handle circular alignments\n\t\treturn 1;\n\t}\n\n\tprivate void setSequenceFromAlignment() {\n\t\tsequenceFromAlignment = new int[length];\n\t\tint a = 1, s = numBefore + 1;\n\t\tfor (int i = 0; i < getStart().getPosition(); i++, a++) {\n\t\t\tsequenceFromAlignment[a - 1] = s;\n\t\t}\n\t\tfor (; a <= length; a++) {\n\t\t\tif (!isGap(a)) {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tsequenceFromAlignment[a - 1] = s;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int[] getSequenceFromAlignment() {\n\t\tif (sequenceFromAlignment == null)\n\t\t\tsetSequenceFromAlignment();\n\t\treturn sequenceFromAlignment;\n\t}\n\n\t@Override\n\tpublic int getSequenceIndexAt(int alignmentIndex) {\n\t\tif (sequenceFromAlignment == null)\n\t\t\tsetSequenceFromAlignment();\n\t\treturn sequenceFromAlignment[alignmentIndex - 1];\n\t}\n\n\t@Override\n\tpublic Point getStart() {\n\t\treturn location.getStart();\n\t}\n\n\t@Override\n\tpublic boolean isCircular() {\n\t\treturn location.isCircular();\n\t}\n\n\t@Override\n\tpublic boolean isGap(int alignmentIndex) {\n\t\tif (getStart().getPosition() <= alignmentIndex && alignmentIndex <= getEnd().getPosition()) {\n\t\t\tif (!location.isComplex()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (Location sublocation : location) {\n\t\t\t\tif (sublocation.getStart().getPosition() <= alignmentIndex &&\n\t\t\t\t\t\talignmentIndex <= sublocation.getEnd().getPosition()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// methods for Sequence\n\n\t@Override\n\tpublic int countCompounds(C... compounds) {\n\t\tint count = 0;\n\t\tList<C> search = Arrays.asList(compounds);\n\t\tfor (C compound : getAsList()) {\n\t\t\tif (search.contains(compound)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\t@Override\n\tpublic AccessionID getAccession() {\n\t\treturn original.getAccession();\n\t}\n\n\t@Override\n\tpublic List<C> getAsList() {\n\t\tList<C> compounds = new ArrayList<C>();\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tcompounds.add(getCompoundAt(i));\n\t\t}\n\t\treturn compounds;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object o){\n\n\t\tif(! Equals.classEqual(this, o)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tSequence<C> other = (Sequence<C>)o;\n\t\tif ( original.getAsList().size() != other.getAsList().size())\n\t\t\treturn false;\n\n\t\tfor ( int i = 0 ; i< original.getAsList().size() ; i++){\n\t\t\tif ( ! original.getAsList().get(i).equalsIgnoreCase(other.getAsList().get(i)))\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int hashCode(){\n\t\tString s = getSequenceAsString();\n\t\treturn s.hashCode();\n\t}\n\n\t@Override\n\tpublic C getCompoundAt(int alignmentIndex) {\n\t\treturn alignmentIndex >= 1 && alignmentIndex <= length && isGap(alignmentIndex) ?\n\t\t\t\tgetCompoundSet().getCompoundForString(gap) :\n\t\t\t\toriginal.getCompoundAt(getSequenceIndexAt(alignmentIndex));\n\t}\n\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn original.getCompoundSet();\n\t}\n\n\t@Override\n\tpublic int getIndexOf(C compound) {\n\t\tfor (int i = 1; i <= length; i++) {\n\t\t\tif (compound.equals(getCompoundAt(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLastIndexOf(C compound) {\n\t\tfor (int i = length; i >= 1; i--) {\n\t\t\tif (compound.equals(getCompoundAt(i))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t@Override\n\tpublic String getSequenceAsString() {\n\t\treturn SequenceMixin.toString(this);\n\t}\n\n\t@Override\n\tpublic SequenceView<C> getSubSequence(Integer start, Integer end) {\n\t\treturn SequenceMixin.createSubSequence(this, start, end);\n\t}\n\n\t// method for Iterable\n\n\t@Override\n\tpublic Iterator<C> iterator() {\n\t\treturn getAsList().iterator();\n\t}\n\n\t// method from Object\n\n\t/**\n\t * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getSequenceAsString();\n\t}\n\n\t// helper method to initialize the location\n\tprivate void setLocation(List<Step> steps) {\n\t\tList<Location> sublocations = new ArrayList<Location>();\n\t\tint start = 0, step = 0, oStep = numBefore+numAfter, oMax = this.original.getLength(), pStep = 0, pMax =\n\t\t\t\t(prev == null) ? 0 : prev.getLength();\n\t\tboolean inGap = true;\n\n\t\t// build sublocations: pieces of sequence separated by gaps\n\t\tfor (; step < length; step++) {\n\t\t\tboolean isGapStep = (steps.get(step) == Step.GAP),\n\t\t\t\t\tisGapPrev = (pStep < pMax && prev.isGap(pStep + 1));\n\t\t\tif (!isGapStep && !isGapPrev) {\n\t\t\t\toStep++;\n\t\t\t\tif (inGap) {\n\t\t\t\t\tinGap = false;\n\t\t\t\t\tstart = step + 1;\n\t\t\t\t}\n\t\t\t} else if (!inGap) {\n\t\t\t\tinGap = true;\n\t\t\t\tsublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n\t\t\t}\n\t\t\tif (prev != null && !isGapStep) {\n\t\t\t\tpStep++;\n\t\t\t}\n\t\t}\n\t\tif (!inGap) {\n\t\t\tsublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n\t\t}\n\n\t\t// combine sublocations into 1 Location\n\t\tif (sublocations.size() == 0) {\n\t\t\tlocation = null;\n\t\t} else if (sublocations.size() == 1) {\n\t\t\tlocation = sublocations.get(0);\n\t\t} else {\n\t\t\tlocation = new SimpleLocation(sublocations.get(0).getStart(), sublocations.get(sublocations.size() - 1).getEnd(),\n\t\t\t\t\tStrand.UNDEFINED,\n\t\t\t\t\tfalse, sublocations);\n\t\t}\n\t\t// TODO handle circular alignments\n\n\t\t// check that alignment has correct number of compounds in it to fit original sequence\n\t\tif (step != length || oStep != oMax || pStep != pMax) {\n\t\t\tthrow new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n\t\t}\n\t}\n\n\t@Override\n\t//TODO Needs to implements\n\tpublic SequenceView<C> getInverse() {\n\t\tthrow new UnsupportedOperationException(\"Not supported yet.\");\n\t}\n\n\t@Override\n\tpublic int getNumGapPositions() {\n\t\tif (numGapPositions == -1)\n\t\t\tgetNumGaps();\n\t\treturn numGapPositions;\n\t}\n\n\t@Override\n\tpublic double getCoverage() {\n\t\t\n\t\tdouble coverage = getLength() - getNumGapPositions();\n\t\treturn coverage / getOriginalSequence().getLength();\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.alignment;\n\nimport org.biojava.nbio.core.alignment.template.AlignedSequence;\nimport org.biojava.nbio.core.alignment.template.AlignedSequence.Step;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport java.util.Arrays;\n\nimport static org.junit.Assert.*;\n\npublic class SimpleAlignedSequenceTest {\n\n\tprivate ProteinSequence go, lo;\n\tprivate AlignedSequence<ProteinSequence, AminoAcidCompound> global, local, local2;\n\tprivate AminoAcidCompoundSet cs;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tgo = new ProteinSequence(\"ARND\");\n\t\tlo = new ProteinSequence(\"CEQGHILKM\");\n\t\tglobal = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n\t\t\t\tStep.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n\t\tlocal = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND,\n\t\t\t\tStep.COMPOUND}), 1, 3);\n\t\tlocal2 = new SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.COMPOUND}), 1, 0);\n\t\tcs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n\t}\n\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void testSimpleAlignedSequenceLocal() {\n\t\tnew SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(lo, Arrays.asList(new Step[] {Step.COMPOUND,\n\t\t\t\tStep.COMPOUND, Step.GAP, Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n\t}\n\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void testSimpleAlignedSequenceLong() {\n\t\tnew SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}));\n\t}\n\n\t@Test(expected=IllegalArgumentException.class)\n\tpublic void testSimpleAlignedSequenceShort() {\n\t\tnew SimpleAlignedSequence<ProteinSequence, AminoAcidCompound>(go, Arrays.asList(new Step[] {Step.GAP,\n\t\t\t\tStep.COMPOUND, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.GAP}));\n\t}\n\n\t@Test\n\tpublic void testGetAlignmentIndexAt() {\n\t\tassertEquals(global.getAlignmentIndexAt(1), 2);\n\t\tassertEquals(global.getAlignmentIndexAt(2), 3);\n\t\tassertEquals(global.getAlignmentIndexAt(3), 5);\n\t\tassertEquals(global.getAlignmentIndexAt(4), 6);\n\t\tassertEquals(local.getAlignmentIndexAt(1), 1);\n\t\tassertEquals(local.getAlignmentIndexAt(2), 1);\n\t\tassertEquals(local.getAlignmentIndexAt(3), 2);\n\t\tassertEquals(local.getAlignmentIndexAt(4), 5);\n\t\tassertEquals(local.getAlignmentIndexAt(5), 7);\n\t\tassertEquals(local.getAlignmentIndexAt(6), 8);\n\t\tassertEquals(local.getAlignmentIndexAt(7), 8);\n\t\tassertEquals(local.getAlignmentIndexAt(8), 8);\n\t\tassertEquals(local.getAlignmentIndexAt(9), 8);\n\t\tassertEquals(local2.getAlignmentIndexAt(1), 1);\n\t\tassertEquals(local2.getAlignmentIndexAt(2), 1);\n\t\tassertEquals(local2.getAlignmentIndexAt(3), 2);\n\t\tassertEquals(local2.getAlignmentIndexAt(4), 3);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignmentIndexAtOutOfBounds() {\n\t\tglobal.getAlignmentIndexAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignmentIndexAtOutOfBounds2() {\n\t\tglobal.getAlignmentIndexAt(5);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignmentIndexAtOutOfBounds3() {\n\t\tlocal.getAlignmentIndexAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetAlignmentIndexAtOutOfBounds4() {\n\t\tlocal.getAlignmentIndexAt(10);\n\t}\n\n\t@Test\n\tpublic void testGetEnd() {\n\t\tassertEquals(global.getEnd().getPosition(), Integer.valueOf(6));\n\t\tassertEquals(local.getEnd().getPosition(), Integer.valueOf(8));\n\t\tassertEquals(local2.getEnd().getPosition(), Integer.valueOf(3));\n\t}\n\n\t@Test\n\tpublic void testGetLocationInAlignment() {\n\t\tassertEquals(global.getLocationInAlignment(), new SimpleLocation(2, 6, Strand.UNDEFINED,\n\t\t\t\tnew SimpleLocation(2, 3, Strand.UNDEFINED), new SimpleLocation(5, 6, Strand.UNDEFINED)));\n\t\tassertEquals(local.getLocationInAlignment(), new SimpleLocation(1, 8, Strand.UNDEFINED,\n\t\t\t\tnew SimpleLocation(1, 2, Strand.UNDEFINED), new SimpleLocation(5, 5, Strand.UNDEFINED),\n\t\t\t\tnew SimpleLocation(7, 8, Strand.UNDEFINED)));\n\t\tassertEquals(local2.getLocationInAlignment(), new SimpleLocation(1, 3, Strand.UNDEFINED));\n\t}\n\n\t@Test\n\tpublic void testGetNumGaps() {\n\t\tassertEquals(global.getNumGaps(), 3);\n\t\tassertEquals(local.getNumGaps(), 2);\n\t\tassertEquals(local2.getNumGaps(), 0);\n\t}\n\n\t@Test\n\tpublic void testGetOriginalSequence() {\n\t\tassertEquals(global.getOriginalSequence(), go);\n\t\tassertEquals(local.getOriginalSequence(), lo);\n\t\tassertEquals(local2.getOriginalSequence(), go);\n\t}\n\n\t@Test\n\tpublic void testGetOverlapCount() {\n\t\tassertEquals(global.getOverlapCount(), 1);\n\t\tassertEquals(local.getOverlapCount(), 1);\n\t\tassertEquals(local2.getOverlapCount(), 1);\n\t}\n\n\t@Test\n\tpublic void testGetSequenceIndexAt() {\n\t\tassertEquals(global.getSequenceIndexAt(1), 1);\n\t\tassertEquals(global.getSequenceIndexAt(2), 1);\n\t\tassertEquals(global.getSequenceIndexAt(3), 2);\n\t\tassertEquals(global.getSequenceIndexAt(4), 2);\n\t\tassertEquals(global.getSequenceIndexAt(5), 3);\n\t\tassertEquals(global.getSequenceIndexAt(6), 4);\n\t\tassertEquals(global.getSequenceIndexAt(7), 4);\n\t\tassertEquals(local.getSequenceIndexAt(1), 2);\n\t\tassertEquals(local.getSequenceIndexAt(2), 3);\n\t\tassertEquals(local.getSequenceIndexAt(3), 3);\n\t\tassertEquals(local.getSequenceIndexAt(4), 3);\n\t\tassertEquals(local.getSequenceIndexAt(5), 4);\n\t\tassertEquals(local.getSequenceIndexAt(6), 4);\n\t\tassertEquals(local.getSequenceIndexAt(7), 5);\n\t\tassertEquals(local.getSequenceIndexAt(8), 6);\n\t\tassertEquals(local2.getSequenceIndexAt(1), 2);\n\t\tassertEquals(local2.getSequenceIndexAt(2), 3);\n\t\tassertEquals(local2.getSequenceIndexAt(3), 4);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetSequenceIndexAtOutOfBounds() {\n\t\tglobal.getSequenceIndexAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetSequenceIndexAtOutOfBounds2() {\n\t\tglobal.getSequenceIndexAt(8);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetSequenceIndexAtOutOfBounds3() {\n\t\tlocal.getSequenceIndexAt(0);\n\t}\n\n\t@Test(expected=IndexOutOfBoundsException.class)\n\tpublic void testGetSequenceIndexAtOutOfBounds4() {\n\t\tlocal.getSequenceIndexAt(9);\n\t}\n\n\t@Test\n\tpublic void testGetStart() {\n\t\tassertEquals(global.getStart().getPosition(), Integer.valueOf(2));\n\t\tassertEquals(local.getStart().getPosition(), Integer.valueOf(1));\n\t\tassertEquals(local2.getStart().getPosition(), Integer.valueOf(1));\n\t}\n\n\t@Test\n\tpublic void testIsCircular() {\n\t\tassertFalse(global.isCircular());\n\t\tassertFalse(local.isCircular());\n\t\tassertFalse(local2.isCircular());\n\t}\n\n\t@Test\n\tpublic void testCountCompounds() {\n\t\tassertEquals(global.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n\t\t\t\tcs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 3);\n\t\tassertEquals(local.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n\t\t\t\tcs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 1);\n\t\tassertEquals(local2.countCompounds(cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"N\"),\n\t\t\t\tcs.getCompoundForString(\"A\"), cs.getCompoundForString(\"E\"), cs.getCompoundForString(\"D\")), 2);\n\t}\n\n\t@Test\n\tpublic void testGetAccession() {\n\t\tassertNull(global.getAccession());\n\t\tassertNull(local.getAccession());\n\t\tassertNull(local2.getAccession());\n\t}\n\n\t@Test\n\tpublic void testGetAsList() {\n\t\tassertArrayEquals(global.getAsList().toArray(new AminoAcidCompound[7]), new AminoAcidCompound[] {\n\t\t\tcs.getCompoundForString(\"-\"), cs.getCompoundForString(\"A\"), cs.getCompoundForString(\"R\"),\n\t\t\tcs.getCompoundForString(\"-\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\"),\n\t\t\tcs.getCompoundForString(\"-\")});\n\t\tassertArrayEquals(local.getAsList().toArray(new AminoAcidCompound[8]), new AminoAcidCompound[] {\n\t\t\tcs.getCompoundForString(\"E\"), cs.getCompoundForString(\"Q\"), cs.getCompoundForString(\"-\"),\n\t\t\tcs.getCompoundForString(\"-\"), cs.getCompoundForString(\"G\"), cs.getCompoundForString(\"-\"),\n\t\t\tcs.getCompoundForString(\"H\"), cs.getCompoundForString(\"I\")});\n\t\tassertArrayEquals(local2.getAsList().toArray(new AminoAcidCompound[3]), new AminoAcidCompound[] {\n\t\t\tcs.getCompoundForString(\"R\"), cs.getCompoundForString(\"N\"), cs.getCompoundForString(\"D\")});\n\t}\n\n\t@Test\n\tpublic void testGetCompoundAt() {\n\t\tassertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(global.getCompoundAt(2), cs.getCompoundForString(\"A\"));\n\t\tassertEquals(global.getCompoundAt(3), cs.getCompoundForString(\"R\"));\n\t\tassertEquals(global.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(global.getCompoundAt(5), cs.getCompoundForString(\"N\"));\n\t\tassertEquals(global.getCompoundAt(6), cs.getCompoundForString(\"D\"));\n\t\tassertEquals(global.getCompoundAt(7), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(global.getCompoundAt(1), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(local.getCompoundAt(1), cs.getCompoundForString(\"E\"));\n\t\tassertEquals(local.getCompoundAt(2), cs.getCompoundForString(\"Q\"));\n\t\tassertEquals(local.getCompoundAt(3), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(local.getCompoundAt(4), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(local.getCompoundAt(5), cs.getCompoundForString(\"G\"));\n\t\tassertEquals(local.getCompoundAt(6), cs.getCompoundForString(\"-\"));\n\t\tassertEquals(local.getCompoundAt(7), cs.getCompoundForString(\"H\"));\n\t\tassertEquals(local.getCompoundAt(8), cs.getCompoundForString(\"I\"));\n\t\tassertEquals(local2.getCompoundAt(1), cs.getCompoundForString(\"R\"));\n\t\tassertEquals(local2.getCompoundAt(2), cs.getCompoundForString(\"N\"));\n\t\tassertEquals(local2.getCompoundAt(3), cs.getCompoundForString(\"D\"));\n\t}\n\n\t@Test\n\tpublic void testGetCompoundSet() {\n\t\tassertEquals(global.getCompoundSet(), cs);\n\t\tassertEquals(local.getCompoundSet(), cs);\n\t\tassertEquals(local2.getCompoundSet(), cs);\n\t}\n\n\t@Test\n\tpublic void testGetIndexOf() {\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"R\")), 3);\n\t\tassertEquals(global.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n\t\tassertEquals(local.getIndexOf(cs.getCompoundForString(\"-\")), 3);\n\t\tassertEquals(local2.getIndexOf(cs.getCompoundForString(\"N\")), 2);\n\t\tassertEquals(local2.getIndexOf(cs.getCompoundForString(\"-\")), -1);\n\t}\n\n\t@Test\n\tpublic void testGetLastIndexOf() {\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"R\")), 3);\n\t\tassertEquals(global.getLastIndexOf(cs.getCompoundForString(\"-\")), 7);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n\t\tassertEquals(local.getLastIndexOf(cs.getCompoundForString(\"-\")), 6);\n\t\tassertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"N\")), 2);\n\t\tassertEquals(local2.getLastIndexOf(cs.getCompoundForString(\"-\")), -1);\n\t}\n\n\t@Test\n\tpublic void testGetLength() {\n\t\tassertEquals(global.getLength(), 7);\n\t\tassertEquals(local.getLength(), 8);\n\t\tassertEquals(local2.getLength(), 3);\n\t}\n\n\t@Test\n\tpublic void testGetSequenceAsString() {\n\t\tassertEquals(global.getSequenceAsString(), \"-AR-ND-\");\n\t\tassertEquals(local.getSequenceAsString(), \"EQ--G-HI\");\n\t\tassertEquals(local2.getSequenceAsString(), \"RND\");\n\t}\n\n\t@Test\n\tpublic void testGetSequenceAsStringIntegerIntegerStrand() {\n\t\tassertEquals(global.getSubSequence(2, 5).getSequenceAsString(), \"AR-N\");\n\t\tassertEquals(local.getSubSequence(2, 6).getSequenceAsString(), \"Q--G-\");\n\t\tassertEquals(local2.getSubSequence(2, 3).getSequenceAsString(), \"ND\");\n\t}\n\n\t@Ignore // TODO SimpleAlignedSequence.getSubSequence(Integer, Integer)\n\t@Test\n\tpublic void testGetSubSequence() {\n\t\tfail(\"Not yet implemented\");\n\t}\n\n\t@Test\n\tpublic void testIterator() {\n\t\tfor (AminoAcidCompound c : global) {\n\t\t\tassertNotNull(cs.getStringForCompound(c));\n\t\t}\n\t\tfor (AminoAcidCompound c : local) {\n\t\t\tassertNotNull(cs.getStringForCompound(c));\n\t\t}\n\t\tfor (AminoAcidCompound c : local2) {\n\t\t\tassertNotNull(cs.getStringForCompound(c));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testToString() {\n\t\tassertEquals(global.toString(), \"-AR-ND-\");\n\t\tassertEquals(local.toString(), \"EQ--G-HI\");\n\t\tassertEquals(local2.toString(), \"RND\");\n\t}\n\n}\n","changedTest":"","commitMessage":"Cherry-pick the c5fa135 commit\n","test_commitMessage":"","allZero":false}