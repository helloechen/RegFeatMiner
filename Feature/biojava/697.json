{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/cluster/SubunitCluster.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/cluster/TestSubunitCluster.java","prod_time":"2016-07-20 22:12:44","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":10,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":7,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":2,"del_annotation_line":0,"del_call_line":6,"del_classname_line":0,"del_condition_line":2,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"d5c4a730bbb0935f99118a7d155d8376d89a5d8d","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.alignment.Alignments;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava.nbio.alignment.SimpleGapPenalty;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceAligner;\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.StructureAlignment;\nimport org.biojava.nbio.structure.align.StructureAlignmentFactory;\nimport org.biojava.nbio.structure.align.ce.CeMain;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.symmetry.core.Subunits;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\n\n/**\n * A SubunitCluster contains a set of equivalent {@link Subunits}, the set of\n * equivalent residues (EQR) between {@link Subunit} and a {@link Subunit}\n * representative. It also stores the method used for clustering.\n * <p>\n * This class allows the comparison and merging of SubunitClusters.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitCluster {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitCluster.class);\n\n\tprivate List<Subunit> subunits = new ArrayList<Subunit>();\n\tprivate List<List<Integer>> subunitEQR = new ArrayList<List<Integer>>();\n\tprivate int representative = -1;\n\tprivate SubunitClustererMethod method = SubunitClustererMethod.IDENTITY;\n\n\t/**\n\t * A SubunitCluster is always initialized with a single Subunit.\n\t * \n\t * @param subunit\n\t *            initial Subunit\n\t */\n\tpublic SubunitCluster(Subunit subunit) {\n\n\t\tsubunits.add(subunit);\n\n\t\tList<Integer> identity = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < subunit.size(); i++)\n\t\t\tidentity.add(i);\n\t\tsubunitEQR.add(identity);\n\n\t\trepresentative = 0;\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by String equality of their residue one-letter sequences.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalTo(SubunitCluster other) {\n\t\tString thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\tString otherSequence = other.subunits.get(other.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\treturn thisSequence.equals(otherSequence);\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by {@link #isIdenticalTo(SubunitCluster)}.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdentical(SubunitCluster other) {\n\n\t\tif (!isIdenticalTo(other))\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are identical\");\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The other SubunitCluster is equivalent to this one if their\n\t * representatives sequences are similar (higher sequence identity and\n\t * coverage than the thresholds).\n\t * <p>\n\t * The sequence alignment is performed using Smith Waterman, default linear\n\t * {@link SimpleGapPenalty} and BLOSUM62 as scoring matrix.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param minSeqid\n\t *            sequence identity threshold. Value in [0,1]. Values lower than\n\t *            0.7 are not recommended. Use {@link #mergeStructure} for lower\n\t *            values.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic boolean isSequenceEq(SubunitCluster other, double minSeqid,\n\t\t\tdouble minCoverage) throws CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform a Smith-Waterman alignment with BLOSUM62\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence,\n\t\t\t\t\t\tPairwiseSequenceAlignerType.LOCAL,\n\t\t\t\t\t\tnew SimpleGapPenalty(),\n\t\t\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\n\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\tdouble coverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble seqid = aligner.getPair().getPercentageOfIdentity();\n\n\t\tif (seqid < minSeqid)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are similar in sequence with {} sequence \"\n\t\t\t\t+ \"identity and {} coverage\", seqid, coverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (higher sequence identity and coverage than the\n\t * thresholds).\n\t * <p>\n\t * The sequence alignment is performed using Smith Waterman, default linear\n\t * {@link SimpleGapPenalty} and BLOSUM62 as scoring matrix.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param minSeqid\n\t *            sequence identity threshold. Value in [0,1]. Values lower than\n\t *            0.7 are not recommended. Use {@link #mergeStructure} for lower\n\t *            values.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic boolean mergeSequence(SubunitCluster other, double minSeqid,\n\t\t\tdouble minCoverage) throws CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform a Smith-Waterman alignment with BLOSUM62\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence,\n\t\t\t\t\t\tPairwiseSequenceAlignerType.LOCAL,\n\t\t\t\t\t\tnew SimpleGapPenalty(),\n\t\t\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\n\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\tdouble coverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble seqid = aligner.getPair().getPercentageOfIdentity();\n\n\t\tif (seqid < minSeqid)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are similar in sequence with {} sequence \"\n\t\t\t\t+ \"identity and {} coverage\", seqid, coverage);\n\n\t\t// If coverage and sequence identity sufficient, merge other and this\n\t\tList<Integer> thisAligned = new ArrayList<Integer>();\n\t\tList<Integer> otherAligned = new ArrayList<Integer>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 1; p < aligner.getPair().getLength() + 1; p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (aligner.getPair().getAlignedSequence(1).isGap(p))\n\t\t\t\tcontinue;\n\t\t\tif (aligner.getPair().getAlignedSequence(2).isGap(p))\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = aligner.getPair().getIndexInQueryAt(p) - 1;\n\t\t\tint otherIndex = aligner.getPair().getIndexInTargetAt(p) - 1;\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<Integer>();\n\t\tList<Integer> otherRemove = new ArrayList<Integer>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative)\n\t\t\t\t\t.get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(\n\t\t\t\t\tother.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(\n\t\t\t\tother.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\tthis.method = SubunitClustererMethod.SEQUENCE;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The other SubunitCluster is equivalent to this one if their\n\t * representative Atoms are structurally similar (lower RMSD and higher\n\t * coverage than the thresholds).\n\t * <p>\n\t * The structure alignment is performed using FatCatRigid, with default\n\t * parameters.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param maxRmsd\n\t *            RMSD threshold.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean isStructureEq(SubunitCluster other, double maxRmsd,\n\t\t\tdouble minCoverage) throws StructureException {\n\n\t\t// Perform a FatCat alignment with default parameters\n\t\tStructureAlignment algorithm = StructureAlignmentFactory\n\t\t\t\t.getAlgorithm(CeMain.algorithmName);\n\n\t\tAFPChain afp = algorithm.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convinience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble coverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (rmsd > maxRmsd)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are structurally similar with {} RMSD \"\n\t\t\t\t+ \"and {} coverage\", rmsd, coverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representative\n\t * Atoms are structurally similar (lower RMSD and higher coverage than the\n\t * thresholds).\n\t * <p>\n\t * The structure alignment is performed using FatCatRigid, with default\n\t * parameters.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param maxRmsd\n\t *            RMSD threshold.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean mergeStructure(SubunitCluster other, double maxRmsd,\n\t\t\tdouble minCoverage) throws StructureException {\n\n\t\t// Perform a FatCat alignment with default parameters\n\t\tStructureAlignment algorithm = StructureAlignmentFactory\n\t\t\t\t.getAlgorithm(CeMain.algorithmName);\n\n\t\tAFPChain afp = algorithm.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convinience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble coverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (rmsd > maxRmsd)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are structurally similar with {} RMSD \"\n\t\t\t\t+ \"and {} coverage\", rmsd, coverage);\n\n\t\t// If RMSD is low and coverage sufficient merge clusters\n\t\tList<List<Integer>> alignedRes = msa.getBlock(0).getAlignRes();\n\t\tList<Integer> thisAligned = new ArrayList<Integer>();\n\t\tList<Integer> otherAligned = new ArrayList<Integer>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 0; p < msa.length(); p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (alignedRes.get(0).get(p) == null)\n\t\t\t\tcontinue;\n\t\t\tif (alignedRes.get(1).get(p) == null)\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = alignedRes.get(0).get(p);\n\t\t\tint otherIndex = alignedRes.get(1).get(p);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<Integer>();\n\t\tList<Integer> otherRemove = new ArrayList<Integer>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative)\n\t\t\t\t\t.get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(\n\t\t\t\t\tother.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(\n\t\t\t\tother.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\tthis.method = SubunitClustererMethod.STRUCTURE;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Analyze the internal symmetry of the SubunitCluster and divide its\n\t * {@link Subunit} into the internal repeats (domains) if they are\n\t * internally symmetric.\n\t * \n\t * @param coverageThreshold\n\t *            the minimum coverage of all repeats in the Subunit\n\t * @param rmsdThreshold\n\t *            the maximum allowed RMSD between the repeats\n\t * @param minSequenceLength\n\t *            the minimum length of the repeating units\n\t * @return true if the cluster was internally symmetric, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean divideInternally(double coverageThreshold,\n\t\t\tdouble rmsdThreshold, int minSequenceLength)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters params = new CESymmParameters();\n\t\tparams.setMinCoreLength(minSequenceLength);\n\t\tparams.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > rmsdThreshold)\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < coverageThreshold)\n\t\t\treturn false;\n\n\t\tlogger.info(\n\t\t\t\t\"SubunitCluster is internally symmetric with {} repeats, {} RMSD \"\n\t\t\t\t\t\t+ \"and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<List<Integer>>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<Integer>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.INTERNAL_SYMMETRY;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return the number of Subunits in the cluster\n\t */\n\tpublic int size() {\n\t\treturn subunits.size();\n\t}\n\n\t/**\n\t * @return the number of aligned residues between Subunits of the cluster\n\t */\n\tpublic int length() {\n\t\treturn subunitEQR.get(representative).size();\n\t}\n\n\t/**\n\t * @return the {@link SubunitClustererMethod} used for clustering the\n\t *         Subunits\n\t */\n\tpublic SubunitClustererMethod getClustererMethod() {\n\t\treturn method;\n\t}\n\n\t/**\n\t * @return A List of size {@link #size()} of Atom arrays of length\n\t *         {@link #length()} with the aligned Atoms for each Subunit in the\n\t *         cluster\n\t */\n\tpublic List<Atom[]> getAlignedAtomsSubunits() {\n\n\t\tList<Atom[]> alignedAtoms = Collections.emptyList();\n\n\t\t// Loop through all subunits and add only the aligned positions\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tAtom[] aligned = new Atom[length()];\n\t\t\tfor (int p = 0; p < length(); p++) {\n\t\t\t\taligned[p] = subunits.get(s).getRepresentativeAtoms()[subunitEQR\n\t\t\t\t\t\t.get(s).get(p)];\n\t\t\t}\n\t\t\talignedAtoms.add(aligned);\n\t\t}\n\n\t\treturn alignedAtoms;\n\t}\n\n\t/**\n\t * @return An Atom array of length {@link #length()} with the aligned Atoms\n\t *         from the selected Subunit in the cluster\n\t */\n\tpublic Atom[] getAlignedAtomsSubunit(int index) {\n\n\t\tAtom[] aligned = new Atom[subunitEQR.get(index).size()];\n\t\tfor (int p = 0; p < subunitEQR.get(index).size(); p++) {\n\t\t\taligned[p] = subunits.get(index).getRepresentativeAtoms()[subunitEQR\n\t\t\t\t\t.get(index).get(p)];\n\t\t}\n\n\t\treturn aligned;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubunitCluster [Size=\" + size() + \", Length=\" + length()\n\t\t\t\t+ \", Representative=\" + representative + \", Method=\" + method\n\t\t\t\t+ \"]\";\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport org.biojava.nbio.alignment.Alignments;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceAlignerType;\nimport org.biojava.nbio.alignment.SimpleGapPenalty;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceAligner;\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.StructureAlignment;\nimport org.biojava.nbio.structure.align.StructureAlignmentFactory;\nimport org.biojava.nbio.structure.align.ce.CeMain;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.multiple.util.ReferenceSuperimposer;\nimport org.biojava.nbio.structure.symmetry.core.Subunits;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymmResult;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * A SubunitCluster contains a set of equivalent {@link Subunits}, the set of\n * equivalent residues (EQR) between {@link Subunit} and a {@link Subunit}\n * representative. It also stores the method used for clustering.\n * <p>\n * This class allows the comparison and merging of SubunitClusters.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n * \n */\npublic class SubunitCluster {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SubunitCluster.class);\n\n\tprivate List<Subunit> subunits = new ArrayList<Subunit>();\n\tprivate List<List<Integer>> subunitEQR = new ArrayList<List<Integer>>();\n\tprivate int representative = -1;\n\tprivate SubunitClustererMethod method = SubunitClustererMethod.IDENTITY;\n\n\t/**\n\t * A SubunitCluster is always initialized with a single Subunit. To obtain a\n\t * SubunitCluster with multiple Subunits, initialize different\n\t * SubunitClusters and merge them.\n\t * \n\t * @param subunit\n\t *            initial Subunit\n\t */\n\tpublic SubunitCluster(Subunit subunit) {\n\n\t\tsubunits.add(subunit);\n\n\t\tList<Integer> identity = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < subunit.size(); i++)\n\t\t\tidentity.add(i);\n\t\tsubunitEQR.add(identity);\n\n\t\trepresentative = 0;\n\t}\n\n\t/**\n\t * Subunits contained in the SubunitCluster.\n\t * \n\t * @return an unmodifiable view of the original List\n\t */\n\tpublic List<Subunit> getSubunits() {\n\t\treturn Collections.unmodifiableList(subunits);\n\t}\n\n\t/**\n\t * Tells whether the other SubunitCluster contains exactly the same Subunit.\n\t * This is checked by String equality of their residue one-letter sequences.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters are identical, false otherwise\n\t */\n\tpublic boolean isIdenticalTo(SubunitCluster other) {\n\t\tString thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\tString otherSequence = other.subunits.get(other.representative)\n\t\t\t\t.getProteinSequenceString();\n\t\treturn thisSequence.equals(otherSequence);\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if it contains exactly the\n\t * same Subunit. This is checked by {@link #isIdenticalTo(SubunitCluster)}.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t */\n\tpublic boolean mergeIdentical(SubunitCluster other) {\n\n\t\tif (!isIdenticalTo(other))\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are identical\");\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The other SubunitCluster is equivalent to this one if their\n\t * representatives sequences are similar (higher sequence identity and\n\t * coverage than the thresholds).\n\t * <p>\n\t * The sequence alignment is performed using Smith Waterman, default linear\n\t * {@link SimpleGapPenalty} and BLOSUM62 as scoring matrix.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param minSeqid\n\t *            sequence identity threshold. Value in [0,1]. Values lower than\n\t *            0.7 are not recommended. Use {@link #mergeStructure} for lower\n\t *            values.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic boolean isSequenceEq(SubunitCluster other, double minSeqid,\n\t\t\tdouble minCoverage) throws CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform a Smith-Waterman alignment with BLOSUM62\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence,\n\t\t\t\t\t\tPairwiseSequenceAlignerType.LOCAL,\n\t\t\t\t\t\tnew SimpleGapPenalty(),\n\t\t\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\n\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\tdouble coverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble seqid = aligner.getPair().getPercentageOfIdentity();\n\n\t\tif (seqid < minSeqid)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are similar in sequence with {} sequence \"\n\t\t\t\t+ \"identity and {} coverage\", seqid, coverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representatives\n\t * sequences are similar (higher sequence identity and coverage than the\n\t * thresholds).\n\t * <p>\n\t * The sequence alignment is performed using Smith Waterman, default linear\n\t * {@link SimpleGapPenalty} and BLOSUM62 as scoring matrix.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param minSeqid\n\t *            sequence identity threshold. Value in [0,1]. Values lower than\n\t *            0.7 are not recommended. Use {@link #mergeStructure} for lower\n\t *            values.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic boolean mergeSequence(SubunitCluster other, double minSeqid,\n\t\t\tdouble minCoverage) throws CompoundNotFoundException {\n\n\t\t// Extract the protein sequences as BioJava alignment objects\n\t\tProteinSequence thisSequence = this.subunits.get(this.representative)\n\t\t\t\t.getProteinSequence();\n\t\tProteinSequence otherSequence = other.subunits\n\t\t\t\t.get(other.representative).getProteinSequence();\n\n\t\t// Perform a Smith-Waterman alignment with BLOSUM62\n\t\tPairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> aligner = Alignments\n\t\t\t\t.getPairwiseAligner(thisSequence, otherSequence,\n\t\t\t\t\t\tPairwiseSequenceAlignerType.LOCAL,\n\t\t\t\t\t\tnew SimpleGapPenalty(),\n\t\t\t\t\t\tSubstitutionMatrixHelper.getBlosum62());\n\n\t\t// Calculate real coverage (subtract gaps in both sequences)\n\t\tdouble gaps1 = aligner.getPair().getAlignedSequence(1)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble gaps2 = aligner.getPair().getAlignedSequence(2)\n\t\t\t\t.getNumGapPositions();\n\t\tdouble lengthAlignment = aligner.getPair().getLength();\n\t\tdouble lengthThis = aligner.getQuery().getLength();\n\t\tdouble lengthOther = aligner.getTarget().getLength();\n\t\tdouble coverage = (lengthAlignment - gaps1 - gaps2)\n\t\t\t\t/ Math.max(lengthThis, lengthOther);\n\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble seqid = aligner.getPair().getPercentageOfIdentity();\n\n\t\tif (seqid < minSeqid)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are similar in sequence with {} sequence \"\n\t\t\t\t+ \"identity and {} coverage\", seqid, coverage);\n\n\t\t// If coverage and sequence identity sufficient, merge other and this\n\t\tList<Integer> thisAligned = new ArrayList<Integer>();\n\t\tList<Integer> otherAligned = new ArrayList<Integer>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 1; p < aligner.getPair().getLength() + 1; p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (aligner.getPair().getAlignedSequence(1).isGap(p))\n\t\t\t\tcontinue;\n\t\t\tif (aligner.getPair().getAlignedSequence(2).isGap(p))\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = aligner.getPair().getIndexInQueryAt(p) - 1;\n\t\t\tint otherIndex = aligner.getPair().getIndexInTargetAt(p) - 1;\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<Integer>();\n\t\tList<Integer> otherRemove = new ArrayList<Integer>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative)\n\t\t\t\t\t.get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(\n\t\t\t\t\tother.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(\n\t\t\t\tother.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\tthis.method = SubunitClustererMethod.SEQUENCE;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * The other SubunitCluster is equivalent to this one if their\n\t * representative Atoms are structurally similar (lower RMSD and higher\n\t * coverage than the thresholds).\n\t * <p>\n\t * The structure alignment is performed using FatCatRigid, with default\n\t * parameters.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param maxRmsd\n\t *            RMSD threshold.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean isStructureEq(SubunitCluster other, double maxRmsd,\n\t\t\tdouble minCoverage) throws StructureException {\n\n\t\t// Perform a FatCat alignment with default parameters\n\t\tStructureAlignment algorithm = StructureAlignmentFactory\n\t\t\t\t.getAlgorithm(CeMain.algorithmName);\n\n\t\tAFPChain afp = algorithm.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convinience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble coverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (rmsd > maxRmsd)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are structurally similar with {} RMSD \"\n\t\t\t\t+ \"and {} coverage\", rmsd, coverage);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Merges the other SubunitCluster into this one if their representative\n\t * Atoms are structurally similar (lower RMSD and higher coverage than the\n\t * thresholds).\n\t * <p>\n\t * The structure alignment is performed using FatCatRigid, with default\n\t * parameters.\n\t * \n\t * @param other\n\t *            SubunitCluster\n\t * @param maxRmsd\n\t *            RMSD threshold.\n\t * @param minCoverage\n\t *            coverage (alignment fraction) threshold. Value in [0,1].\n\t * @return true if the SubunitClusters were merged, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean mergeStructure(SubunitCluster other, double maxRmsd,\n\t\t\tdouble minCoverage) throws StructureException {\n\n\t\t// Perform a FatCat alignment with default parameters\n\t\tStructureAlignment algorithm = StructureAlignmentFactory\n\t\t\t\t.getAlgorithm(CeMain.algorithmName);\n\n\t\tAFPChain afp = algorithm.align(this.subunits.get(this.representative)\n\t\t\t\t.getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms());\n\n\t\t// Convert AFPChain to MultipleAlignment for convinience\n\t\tMultipleAlignment msa = new MultipleAlignmentEnsembleImpl(\n\t\t\t\tafp,\n\t\t\t\tthis.subunits.get(this.representative).getRepresentativeAtoms(),\n\t\t\t\tother.subunits.get(other.representative)\n\t\t\t\t\t\t.getRepresentativeAtoms(), false)\n\t\t\t\t.getMultipleAlignment(0);\n\n\t\tdouble coverage = Math.min(msa.getCoverages().get(0), msa\n\t\t\t\t.getCoverages().get(1));\n\t\tif (coverage < minCoverage)\n\t\t\treturn false;\n\n\t\tdouble rmsd = afp.getTotalRmsdOpt();\n\t\tif (rmsd > maxRmsd)\n\t\t\treturn false;\n\n\t\tlogger.info(\"SubunitClusters are structurally similar with {} RMSD \"\n\t\t\t\t+ \"and {} coverage\", rmsd, coverage);\n\n\t\t// If RMSD is low and coverage sufficient merge clusters\n\t\tList<List<Integer>> alignedRes = msa.getBlock(0).getAlignRes();\n\t\tList<Integer> thisAligned = new ArrayList<Integer>();\n\t\tList<Integer> otherAligned = new ArrayList<Integer>();\n\n\t\t// Extract the aligned residues of both Subunit\n\t\tfor (int p = 0; p < msa.length(); p++) {\n\n\t\t\t// Skip gaps in any of the two sequences\n\t\t\tif (alignedRes.get(0).get(p) == null)\n\t\t\t\tcontinue;\n\t\t\tif (alignedRes.get(1).get(p) == null)\n\t\t\t\tcontinue;\n\n\t\t\tint thisIndex = alignedRes.get(0).get(p);\n\t\t\tint otherIndex = alignedRes.get(1).get(p);\n\n\t\t\t// Only consider residues that are part of the SubunitCluster\n\t\t\tif (this.subunitEQR.get(this.representative).contains(thisIndex)\n\t\t\t\t\t&& other.subunitEQR.get(other.representative).contains(\n\t\t\t\t\t\t\totherIndex)) {\n\t\t\t\tthisAligned.add(thisIndex);\n\t\t\t\totherAligned.add(otherIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Do a List intersection to find out which EQR columns to remove\n\t\tList<Integer> thisRemove = new ArrayList<Integer>();\n\t\tList<Integer> otherRemove = new ArrayList<Integer>();\n\n\t\tfor (int t = 0; t < this.subunitEQR.get(this.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!thisAligned.contains(this.subunitEQR.get(this.representative)\n\t\t\t\t\t.get(t)))\n\t\t\t\tthisRemove.add(t);\n\t\t}\n\n\t\tfor (int t = 0; t < other.subunitEQR.get(other.representative).size(); t++) {\n\t\t\t// If the index is aligned do nothing, otherwise mark as removing\n\t\t\tif (!otherAligned.contains(other.subunitEQR.get(\n\t\t\t\t\tother.representative).get(t)))\n\t\t\t\totherRemove.add(t);\n\t\t}\n\n\t\t// Now remove unaligned columns, from end to start\n\t\tCollections.sort(thisRemove);\n\t\tCollections.reverse(thisRemove);\n\t\tCollections.sort(otherRemove);\n\t\tCollections.reverse(otherRemove);\n\n\t\tfor (int t = 0; t < thisRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : this.subunitEQR) {\n\t\t\t\tint column = thisRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < otherRemove.size(); t++) {\n\t\t\tfor (List<Integer> eqr : other.subunitEQR) {\n\t\t\t\tint column = otherRemove.get(t);\n\t\t\t\teqr.remove(column);\n\t\t\t}\n\t\t}\n\n\t\t// The representative is the longest sequence\n\t\tif (this.subunits.get(this.representative).size() < other.subunits.get(\n\t\t\t\tother.representative).size())\n\t\t\tthis.representative = other.representative + subunits.size();\n\n\t\tthis.subunits.addAll(other.subunits);\n\t\tthis.subunitEQR.addAll(other.subunitEQR);\n\n\t\tthis.method = SubunitClustererMethod.STRUCTURE;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Analyze the internal symmetry of the SubunitCluster and divide its\n\t * {@link Subunit} into the internal repeats (domains) if they are\n\t * internally symmetric.\n\t * \n\t * @param coverageThreshold\n\t *            the minimum coverage of all repeats in the Subunit\n\t * @param rmsdThreshold\n\t *            the maximum allowed RMSD between the repeats\n\t * @param minSequenceLength\n\t *            the minimum length of the repeating units\n\t * @return true if the cluster was internally symmetric, false otherwise\n\t * @throws StructureException\n\t */\n\tpublic boolean divideInternally(double coverageThreshold,\n\t\t\tdouble rmsdThreshold, int minSequenceLength)\n\t\t\tthrows StructureException {\n\n\t\tCESymmParameters params = new CESymmParameters();\n\t\tparams.setMinCoreLength(minSequenceLength);\n\t\tparams.setGaps(false); // We want no gaps between the repeats\n\n\t\t// Analyze the internal symmetry of the representative subunit\n\t\tCeSymmResult result = CeSymm.analyze(subunits.get(representative)\n\t\t\t\t.getRepresentativeAtoms(), params);\n\n\t\tif (!result.isSignificant())\n\t\t\treturn false;\n\n\t\tdouble rmsd = result.getMultipleAlignment().getScore(\n\t\t\t\tMultipleAlignmentScorer.RMSD);\n\t\tif (rmsd > rmsdThreshold)\n\t\t\treturn false;\n\n\t\tdouble coverage = result.getMultipleAlignment().getCoverages().get(0)\n\t\t\t\t* result.getNumRepeats();\n\t\tif (coverage < coverageThreshold)\n\t\t\treturn false;\n\n\t\tlogger.info(\n\t\t\t\t\"SubunitCluster is internally symmetric with {} repeats, {} RMSD \"\n\t\t\t\t\t\t+ \"and {} coverage\", result.getNumRepeats(), rmsd,\n\t\t\t\tcoverage);\n\n\t\t// Divide if symmety was significant with RMSD and coverage sufficient\n\t\tList<List<Integer>> alignedRes = result.getMultipleAlignment()\n\t\t\t\t.getBlock(0).getAlignRes();\n\n\t\tList<List<Integer>> columns = new ArrayList<List<Integer>>();\n\t\tfor (int s = 0; s < alignedRes.size(); s++)\n\t\t\tcolumns.add(new ArrayList<Integer>(alignedRes.get(s).size()));\n\n\t\t// Extract the aligned columns of each repeat in the Subunit\n\t\tfor (int col = 0; col < alignedRes.get(0).size(); col++) {\n\n\t\t\t// Check that all aligned residues are part of the Cluster\n\t\t\tboolean missing = false;\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tif (!subunitEQR.get(representative).contains(\n\t\t\t\t\t\talignedRes.get(s).get(col))) {\n\t\t\t\t\tmissing = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip the column if any residue was not part of the cluster\n\t\t\tif (missing)\n\t\t\t\tcontinue;\n\n\t\t\tfor (int s = 0; s < alignedRes.size(); s++) {\n\t\t\t\tcolumns.get(s).add(\n\t\t\t\t\t\tsubunitEQR.get(representative).indexOf(\n\t\t\t\t\t\t\t\talignedRes.get(s).get(col)));\n\t\t\t}\n\t\t}\n\n\t\t// Divide the Subunits in their repeats\n\t\tList<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size()\n\t\t\t\t* columns.size());\n\t\tList<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(\n\t\t\t\tsubunits.size() * columns.size());\n\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tfor (int r = 0; r < columns.size(); r++) {\n\n\t\t\t\t// Calculate start and end residues of the new Subunit\n\t\t\t\tint start = subunitEQR.get(s).get(columns.get(r).get(0));\n\t\t\t\tint end = subunitEQR.get(s).get(\n\t\t\t\t\t\tcolumns.get(r).get(columns.get(r).size() - 1));\n\n\t\t\t\tAtom[] reprAtoms = Arrays.copyOfRange(subunits.get(s)\n\t\t\t\t\t\t.getRepresentativeAtoms(), start, end + 1);\n\n\t\t\t\tnewSubunits.add(new Subunit(reprAtoms));\n\n\t\t\t\t// Recalculate equivalent residues\n\t\t\t\tList<Integer> eqr = new ArrayList<Integer>();\n\t\t\t\tfor (int p = 0; p < columns.get(r).size(); p++) {\n\t\t\t\t\teqr.add(subunitEQR.get(s).get(columns.get(r).get(p))\n\t\t\t\t\t\t\t- start);\n\t\t\t\t}\n\t\t\t\tnewSubunitEQR.add(eqr);\n\t\t\t}\n\t\t}\n\n\t\tsubunits = newSubunits;\n\t\tsubunitEQR = newSubunitEQR;\n\n\t\t// Update representative\n\t\tfor (int s = 0; s < subunits.size(); s++) {\n\t\t\tif (subunits.get(s).size() > subunits.get(representative).size())\n\t\t\t\trepresentative = s;\n\t\t}\n\n\t\tmethod = SubunitClustererMethod.INTERNAL_SYMMETRY;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @return the number of Subunits in the cluster\n\t */\n\tpublic int size() {\n\t\treturn subunits.size();\n\t}\n\n\t/**\n\t * @return the number of aligned residues between Subunits of the cluster\n\t */\n\tpublic int length() {\n\t\treturn subunitEQR.get(representative).size();\n\t}\n\n\t/**\n\t * @return the {@link SubunitClustererMethod} used for clustering the\n\t *         Subunits\n\t */\n\tpublic SubunitClustererMethod getClustererMethod() {\n\t\treturn method;\n\t}\n\n\t/**\n\t * @return A List of size {@link #size()} of Atom arrays of length\n\t *         {@link #length()} with the aligned Atoms for each Subunit in the\n\t *         cluster\n\t */\n\tpublic List<Atom[]> getAlignedAtomsSubunits() {\n\n\t\tList<Atom[]> alignedAtoms = Collections.emptyList();\n\n\t\t// Loop through all subunits and add the aligned positions\n\t\tfor (int s = 0; s < subunits.size(); s++)\n\t\t\talignedAtoms.add(getAlignedAtomsSubunit(s));\n\n\t\treturn alignedAtoms;\n\t}\n\n\t/**\n\t * @param index\n\t *            Subunit index in the Cluster\n\t * @return An Atom array of length {@link #length()} with the aligned Atoms\n\t *         from the selected Subunit in the Cluster\n\t */\n\tpublic Atom[] getAlignedAtomsSubunit(int index) {\n\n\t\tAtom[] aligned = new Atom[subunitEQR.get(index).size()];\n\n\t\t// Add only the aligned positions of the Subunit in the Cluster\n\t\tfor (int p = 0; p < subunitEQR.get(index).size(); p++) {\n\t\t\taligned[p] = subunits.get(index).getRepresentativeAtoms()[subunitEQR\n\t\t\t\t\t.get(index).get(p)];\n\t\t}\n\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * The multiple alignment is calculated from the equivalent residues in the\n\t * SubunitCluster. The alignment is recalculated every time the method is\n\t * called (no caching).\n\t * \n\t * @return MultipleAlignment representation of the aligned residues in this\n\t *         Subunit Cluster\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment getMultipleAlignment() throws StructureException {\n\n\t\t// Create a multiple alignment with the atom arrays of the Subunits\n\t\tMultipleAlignment msa = new MultipleAlignmentImpl();\n\t\tmsa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n\t\tmsa.getEnsemble().setAtomArrays(\n\t\t\t\tsubunits.stream().map(s -> s.getRepresentativeAtoms())\n\t\t\t\t\t\t.collect(Collectors.toList()));\n\n\t\t// Fill in the alignment information\n\t\tBlockSet bs = new BlockSetImpl(msa);\n\t\tBlock b = new BlockImpl(bs);\n\t\tb.setAlignRes(subunitEQR);\n\n\t\t// Fill in the transformation matrices\n\t\tnew ReferenceSuperimposer(representative).superimpose(msa);\n\n\t\t// Calculate some scores\n\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\treturn msa;\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubunitCluster [Size=\" + size() + \", Length=\" + length()\n\t\t\t\t+ \", Representative=\" + representative + \", Method=\" + method\n\t\t\t\t+ \"]\";\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.cluster;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\n/**\n * Test the {@link SubunitCluster} merge and divide methods, one test specific\n * for each method.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSubunitCluster {\n\n\t/**\n\t * Test {@link SubunitCluster#mergeIdentical(SubunitCluster)}.\n\t */\n\t@Test\n\tpublic void testMergeIdentical() {\n\n\t\t// Create an Atom Array of ploy-alanine\n\t\tList<Atom> atoms = new ArrayList<Atom>(10);\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"ALA\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms.add(a);\n\t\t}\n\t\tAtom[] reprAtoms = atoms.toArray(new Atom[atoms.size()]);\n\n\t\t// Create two identical SubunitCluster\n\t\tSubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms));\n\t\tSubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms));\n\n\t\tboolean merged = sc1.mergeIdentical(sc2);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 1);\n\t\tassertEquals(sc1.length(), 10);\n\n\t\t// Create an Atom Array of poly-glycine\n\t\tList<Atom> atoms2 = new ArrayList<Atom>(10);\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"GLY\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms2.add(a);\n\t\t}\n\t\tAtom[] reprAtoms2 = atoms2.toArray(new Atom[atoms2.size()]);\n\n\t\tSubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2));\n\n\t\tmerged = sc1.mergeIdentical(sc3);\n\n\t\t// Merged have to be false, and Clusters result inmodified\n\t\tassertFalse(merged);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 1);\n\t\tassertEquals(sc1.length(), 10);\n\n\t}\n\n\t/**\n\t * Test {@link SubunitCluster#mergeSequence(SubunitCluster, double, double)}\n\t * \n\t * @throws CompoundNotFoundException\n\t */\n\t@Test\n\tpublic void testMergeSequence() throws CompoundNotFoundException {\n\n\t\t// Create an Atom Array of ploy-alanine\n\t\tList<Atom> atoms = new ArrayList<Atom>(100);\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"ALA\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms.add(a);\n\t\t}\n\t\tAtom[] reprAtoms = atoms.toArray(new Atom[atoms.size()]);\n\n\t\t// Create two identical SubunitCluster\n\t\tSubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms));\n\t\tSubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms));\n\n\t\tboolean merged = sc1.mergeSequence(sc2, 0.9, 0.9);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 1);\n\t\tassertEquals(sc1.length(), 100);\n\n\t\t// Create an Atom Array of poly-glycine\n\t\tList<Atom> atoms2 = new ArrayList<Atom>(100);\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"GLY\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms2.add(a);\n\t\t}\n\t\tAtom[] reprAtoms2 = atoms2.toArray(new Atom[atoms2.size()]);\n\n\t\tSubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2));\n\n\t\tmerged = sc1.mergeSequence(sc3, 0.9, 0.9);\n\n\t\t// Merged have to be false, and Clusters result inmodified\n\t\tassertFalse(merged);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 1);\n\t\tassertEquals(sc1.length(), 100);\n\n\t\t// Create an Atom Array of 9 glycine and 91 alanine\n\t\tList<Atom> atoms3 = new ArrayList<Atom>(100);\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"GLY\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms3.add(a);\n\t\t}\n\t\tfor (int i = 0; i < 91; i++) {\n\t\t\tGroup g = new AminoAcidImpl();\n\t\t\tg.setPDBName(\"ALA\");\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setName(StructureTools.CA_ATOM_NAME);\n\t\t\tg.addAtom(a);\n\t\t\tatoms3.add(a);\n\t\t}\n\t\tAtom[] reprAtoms3 = atoms3.toArray(new Atom[atoms3.size()]);\n\n\t\tSubunitCluster sc4 = new SubunitCluster(new Subunit(reprAtoms3));\n\n\t\tmerged = sc1.mergeSequence(sc4, 0.9, 0.9);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 3);\n\t\tassertEquals(sc2.size(), 1);\n\t\tassertEquals(sc1.length(), 91);\n\n\t}\n\n\t/**\n\t * Test\n\t * {@link SubunitCluster#mergeStructure(SubunitCluster, double, double)}\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testMergeStructure() throws StructureException, IOException {\n\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tStructure s = cache.getStructure(\"4hhb\");\n\n\t\t// Create one SubunitCluster for each chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0))));\n\t\tSubunitCluster sc2 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(1))));\n\t\tSubunitCluster sc3 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(2))));\n\t\tSubunitCluster sc4 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(3))));\n\n\t\t// Clusters 1 and 3 and 2 and 4 are identical\n\t\tboolean merged13 = sc1.mergeStructure(sc3, 3.0, 0.9);\n\t\tboolean merged24 = sc2.mergeStructure(sc4, 3.0, 0.9);\n\n\t\t// Merged have to be true, and the merged SubunitCluster is sc1\n\t\tassertTrue(merged13);\n\t\tassertTrue(merged24);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertEquals(sc2.size(), 2);\n\t\tassertEquals(sc1.length(), 141);\n\t\tassertEquals(sc2.length(), 146);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t\tassertEquals(sc2.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc2.getAlignedAtomsSubunit(1).length);\n\n\t\t// Now test for pseudosymmetry\n\t\tboolean merged = sc1.mergeStructure(sc2, 3.0, 0.9);\n\n\t\tassertTrue(merged);\n\t\tassertEquals(sc1.size(), 4);\n\t\tassertEquals(sc1.length(), 140, 2);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(2).length);\n\t\t\n\n\t}\n\n\t/**\n\t * Test {@link SubunitCluster#divideInternally(double, double, int)}\n\t * \n\t * @throws StructureException\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testDivideInternally() throws StructureException, IOException {\n\n\t\tAtomCache cache = new AtomCache();\n\t\tcache.setUseMmCif(true);\n\t\tStructure s = cache.getStructure(\"4e3e\");\n\n\t\t// Create a SubunitCluster for the chain\n\t\tSubunitCluster sc1 = new SubunitCluster(\n\t\t\t\tnew Subunit(StructureTools.getRepresentativeAtomArray(s\n\t\t\t\t\t\t.getChainByIndex(0))));\n\n\t\t// Clusters should be merged by identity\n\t\tboolean divided = sc1.divideInternally(0.8, 3.0, 20);\n\n\t\t// Divided has to be true, and Subunit length shorter than half\n\t\tassertTrue(divided);\n\t\tassertEquals(sc1.size(), 2);\n\t\tassertTrue(sc1.length() < 178);\n\t\tassertEquals(sc1.getAlignedAtomsSubunit(0).length,\n\t\t\t\tsc1.getAlignedAtomsSubunit(1).length);\n\t}\n}\n","changedTest":"","commitMessage":"New methods for SubunitCluster\n\nThe subunits and their multiple alignment can now be accessed.","test_commitMessage":"","allZero":false}