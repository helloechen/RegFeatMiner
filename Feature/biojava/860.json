{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/search/io/blast/BlastTabularParser.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/search/io/blast/BlastTabularParserTest.java","prod_time":"2018-05-08 02:26:54","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ff538b5c5e0ad7b500d6cce5815b96219809b512","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.LineNumberReader;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.logging.Logger;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n * @author Paolo Pavan\n */\n\npublic class BlastTabularParser implements ResultFactory {\n\tprivate final String blastReference =\n\t\t\t\"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\";\n\t/**\n\t * Tries to define a different level of consistency during parsing.\n\t * LITERAL is intended a strict parsing much tight to the report.\n\t * IMPROVED consistency tries to import data much tight to the data model\n\t * (I hope you got the idea, if not, have a look to the code.\n\t * I suggest to use improved unless you have reasons to do not)\n\t */\n\tprivate enum PARSING_CONSISTENCY {\n\t\tIMPROVED,\n\t\tLITERAL\n\t}\n\tprivate static final Logger log = Logger.getLogger(BlastTabularParser.class.getName());\n\n\n\tprivate File targetFile;\n\tprivate int fileLinesCount;\n\tprivate PARSING_CONSISTENCY parsingConsistency = PARSING_CONSISTENCY.IMPROVED;\n\n\n\t// data imported private:\n\tint queryIdNumber = 0;\n\tHashMap<String,String> queryIdMapping = new HashMap<String,String>();\n\tString programName=null, queryName = null, databaseFile = null;\n\tprivate String queryId      ;\n\tprivate String subjectId    ;\n\tprivate String percIdentity ;\n\tprivate String alnLength    ;\n\tprivate String mismatchCount;\n\tprivate String gapOpenCount ;\n\tprivate String queryStart   ;\n\tprivate String queryEnd     ;\n\tprivate String subjectStart ;\n\tprivate String subjectEnd   ;\n\tprivate String evalue       ;\n\tprivate String bitScore     ;\n\n\n\t@Override\n\tpublic List<String> getFileExtensions() {\n\t\tList<String> l = new ArrayList<String>();\n\t\tl.add(\"blasttabular\");\n\t\tl.add(\"blasttxt\");\n\t\treturn l;\n\t}\n\n\t@Override\n\tpublic void setFile(File f) {\n\t\ttargetFile = f;\n\t}\n\n\t@Override\n\tpublic List<Result> createObjects(double maxEScore) throws IOException, ParseException {\n\t\tList<Result> results = new ArrayList<Result>();\n\n\t\tlog.info(\"Query for hits\");\n\t\tLineNumberReader  lnr = new LineNumberReader(new FileReader(targetFile));\n\t\tlnr.skip(Long.MAX_VALUE);\n\t\tfileLinesCount = lnr.getLineNumber();\n\t\tlog.info(fileLinesCount + \" hits approximately in all results\");\n\t\tlnr.close();\n\n\t\tFileInputStream fileInputStream = new FileInputStream(targetFile);\n\t\tScanner scanner = new Scanner(fileInputStream);\n\n\t\tString line = fetchData(scanner);\n\t\tint lineNumber=0;\n\t\twhile (lineNumber < fileLinesCount){\n\t\t\ttry {\n\t\t\t\tBlastResultBuilder resultBuilder = new BlastResultBuilder();\n\t\t\t\tresultBuilder\n\t\t\t\t\t\t.setQueryID(queryId)\n\t\t\t\t\t\t.setDbFile(databaseFile)\n\t\t\t\t\t\t.setProgram(programName)\n\t\t\t\t\t\t.setQueryDef(queryName)\n\t\t\t\t\t\t.setReference(blastReference);\n\n\t\t\t\tList<Hit> hits = new ArrayList<Hit>();\n\n\t\t\t\tString currentQueryId = queryId;\n\t\t\t\twhile (currentQueryId.equals(queryId) && lineNumber < fileLinesCount){\n\t\t\t\t\tBlastHitBuilder hitBuilder = new BlastHitBuilder();\n\n\t\t\t\t\tList<Hsp> hsps = new ArrayList<Hsp>();\n\n\t\t\t\t\tString currentSubjectId=subjectId;\n\t\t\t\t\twhile (currentSubjectId.equals(subjectId) && lineNumber < fileLinesCount){\n\t\t\t\t\t\tif (new Double(evalue) > maxEScore) {\n\t\t\t\t\t\t\tline = fetchData(scanner);\n\t\t\t\t\t\t\tlineNumber++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBlastHspBuilder hspBuilder = new BlastHspBuilder();\n\t\t\t\t\t\thspBuilder\n\t\t\t\t\t\t\t.setHspAlignLen(new Integer(alnLength))\n\t\t\t\t\t\t\t.setHspGaps(new Integer(gapOpenCount))\n\t\t\t\t\t\t\t.setHspQueryFrom(new Integer(queryStart))\n\t\t\t\t\t\t\t.setHspQueryTo(new Integer(queryEnd))\n\t\t\t\t\t\t\t.setHspHitFrom(new Integer(subjectStart))\n\t\t\t\t\t\t\t.setHspHitTo(new Integer(subjectEnd))\n\t\t\t\t\t\t\t.setHspEvalue(new Double(evalue))\n\t\t\t\t\t\t\t.setHspBitScore(new Double(bitScore))\n\t\t\t\t\t\t\t.setPercentageIdentity(new Double(percIdentity)/100)\n\t\t\t\t\t\t\t.setMismatchCount(new Integer(mismatchCount));\n\t\t\t\t\t\thsps.add(hspBuilder.createBlastHsp());\n\t\t\t\t\t\tif (scanner.hasNext()) line = fetchData(scanner);\n\t\t\t\t\t\tlineNumber++;\n\t\t\t\t\t}\n\t\t\t\t\thits.add(hitBuilder.setHsps(hsps).createBlastHit());\n\t\t\t\t}\n\t\t\t\tresults.add(resultBuilder.setHits(hits).createBlastResult());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new ParseException(\"Invalid numeric value met at line \"+ lineNumber+\" in:\\n\"+line,0);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate String fetchData(Scanner scanner){\n\t\tString line;\n\t\tString[] split;\n\n\t\tline = scanner.nextLine();\n\t\twhile (line.startsWith(\"#\")){\n\t\t\t// blast tabular with header options contains some more informations\n\t\t\tif (line.matches(\"#\\\\s.?BLAST.+\")) programName = line.replace(\"#\\\\s\",\"\");\n\t\t\tif (line.startsWith(\"# Query:\")) queryName = line.replace(\"# Query: \",\"\");\n\t\t\tif (line.startsWith(\"# Database:\")) databaseFile = line.replace(\"# Database: \",\"\");\n\n\t\t\t// needed because blast report can end with a comment...\n\t\t\tif (!scanner.hasNext()) return null;\n\t\t\tline = scanner.nextLine();\n\t\t}\n\n\t\t// Here, programName != null checks if there was a header in the file\n\t\tboolean headerFound = programName != null;\n\n\t\tsplit = line.split(\"\\\\t\");\n\t\tqueryId      =split[0];\n\t\tsubjectId    =split[1];\n\t\tpercIdentity =split[2];\n\t\talnLength    =split[3];\n\t\tmismatchCount=split[4];\n\t\tgapOpenCount =split[5];\n\t\tqueryStart   =split[6];\n\t\tqueryEnd     =split[7];\n\t\tsubjectStart =split[8];\n\t\tsubjectEnd   =split[9];\n\t\tevalue       =split[10];\n\t\tbitScore     =split[11];\n\n\t\t// blast tabular reports only the first word of the query name.\n\t\t// If it was specified in the header it is better to use that definition\n\t\tif (parsingConsistency == PARSING_CONSISTENCY.IMPROVED && headerFound) {\n\t\t\tif (queryIdMapping.get(queryId)==null) {\n\t\t\t\tqueryIdNumber ++;\n\t\t\t\tqueryIdMapping.put(queryId,\"Query_\" + queryIdNumber);\n\t\t\t}\n\t\t\t// If a complete definition of the query name was readed, than we can use\n\t\t\t// a queryID schema that is consistent with blast xml report\n\t\t\tqueryId = queryIdMapping.get(queryId);\n\t\t}\n\t\tif (!headerFound) queryName = queryId;\n\n\t\treturn line;\n\t}\n\n\t@Override\n\tpublic void storeObjects(List<Result> results) throws IOException, ParseException {\n\t\tthrow new UnsupportedOperationException(\"Not supported yet.\");\n\t}\n\n\t/**\n\t * Intended for use with run module.\n\t * Although possible, does not make a lot of sense to have it with limited\n\t * information such those in tabular report\n\t * @param sequences\n\t */\n\t@Override\n\tpublic void setQueryReferences(List<Sequence> sequences) {\n\t\tthrow new UnsupportedOperationException(\"Not supported for this parser.\");\n\t}\n\t/**\n\t * Intended for use with run module.\n\t * Although possible, does not make a lot of sense to have it with limited\n\t * information such those in tabular report\n\t * @param sequences\n\t */\n\t@Override\n\tpublic void setDatabaseReferences(List<Sequence> sequences) {\n\t\tthrow new UnsupportedOperationException(\"Not supported for this parser.\");\n\t}\n\t /**\n\t * Tries to define a different level of consistency during parsing.\n\t * LITERAL is intended a strict parsing much tight to the report.\n\t * IMPROVED consistency tries to import data much tight to the data model\n\t * (I hope you got the idea, if not, have a look to the code.\n\t * I suggest to use improved unless you have reasons to do not)\n\t */\n\tpublic void setParsingConsistency(PARSING_CONSISTENCY parsingConsistency) {\n\t\tthis.parsingConsistency = parsingConsistency;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.LineNumberReader;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Scanner;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.biojava.nbio.core.search.io.ResultFactory;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n * @author Paolo Pavan\n */\n\npublic class BlastTabularParser implements ResultFactory {\n\tprivate final String blastReference =\n\t\t\t\"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\";\n\t/**\n\t * Tries to define a different level of consistency during parsing.\n\t * LITERAL is intended a strict parsing much tight to the report.\n\t * IMPROVED consistency tries to import data much tight to the data model\n\t * (I hope you got the idea, if not, have a look to the code.\n\t * I suggest to use improved unless you have reasons to do not)\n\t */\n\tprivate enum PARSING_CONSISTENCY {\n\t\tIMPROVED,\n\t\tLITERAL\n\t}\n\tprivate static final Logger log = LoggerFactory.getLogger(BlastTabularParser.class);\n\n\n\tprivate File targetFile;\n\tprivate int fileLinesCount;\n\tprivate PARSING_CONSISTENCY parsingConsistency = PARSING_CONSISTENCY.IMPROVED;\n\n\n\t// data imported private:\n\tint queryIdNumber = 0;\n\tHashMap<String,String> queryIdMapping = new HashMap<String,String>();\n\tString programName=null, queryName = null, databaseFile = null;\n\tprivate String queryId      ;\n\tprivate String subjectId    ;\n\tprivate String percIdentity ;\n\tprivate String alnLength    ;\n\tprivate String mismatchCount;\n\tprivate String gapOpenCount ;\n\tprivate String queryStart   ;\n\tprivate String queryEnd     ;\n\tprivate String subjectStart ;\n\tprivate String subjectEnd   ;\n\tprivate String evalue       ;\n\tprivate String bitScore     ;\n\n\n\t@Override\n\tpublic List<String> getFileExtensions() {\n\t\tList<String> l = new ArrayList<String>();\n\t\tl.add(\"blasttabular\");\n\t\tl.add(\"blasttxt\");\n\t\treturn l;\n\t}\n\n\t@Override\n\tpublic void setFile(File f) {\n\t\ttargetFile = f;\n\t}\n\n\t@Override\n\tpublic List<Result> createObjects(double maxEScore) throws IOException, ParseException {\n\t\tList<Result> results = new ArrayList<Result>();\n\n\t\tlog.info(\"Query for hits\");\n\t\tLineNumberReader  lnr = new LineNumberReader(new FileReader(targetFile));\n\t\tlnr.skip(Long.MAX_VALUE);\n\t\tfileLinesCount = lnr.getLineNumber();\n\t\tlog.info(fileLinesCount + \" hits approximately in all results\");\n\t\tlnr.close();\n\n\t\tFileInputStream fileInputStream = new FileInputStream(targetFile);\n\t\tScanner scanner = new Scanner(fileInputStream);\n\n\t\tString line = fetchData(scanner);\n\t\tint lineNumber=0;\n\t\twhile (lineNumber < fileLinesCount){\n\t\t\ttry {\n\t\t\t\tBlastResultBuilder resultBuilder = new BlastResultBuilder();\n\t\t\t\tresultBuilder\n\t\t\t\t\t\t.setQueryID(queryId)\n\t\t\t\t\t\t.setDbFile(databaseFile)\n\t\t\t\t\t\t.setProgram(programName)\n\t\t\t\t\t\t.setQueryDef(queryName)\n\t\t\t\t\t\t.setReference(blastReference);\n\n\t\t\t\tList<Hit> hits = new ArrayList<Hit>();\n\n\t\t\t\tString currentQueryId = queryId;\n\t\t\t\twhile (currentQueryId.equals(queryId) && lineNumber < fileLinesCount){\n\t\t\t\t\tBlastHitBuilder hitBuilder = new BlastHitBuilder();\n\n\t\t\t\t\tList<Hsp> hsps = new ArrayList<Hsp>();\n\n\t\t\t\t\tString currentSubjectId=subjectId;\n\t\t\t\t\twhile (currentSubjectId.equals(subjectId) && lineNumber < fileLinesCount){\n\t\t\t\t\t\tif (new Double(evalue) > maxEScore) {\n\t\t\t\t\t\t\tline = fetchData(scanner);\n\t\t\t\t\t\t\tlineNumber++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tBlastHspBuilder hspBuilder = new BlastHspBuilder();\n\t\t\t\t\t\thspBuilder\n\t\t\t\t\t\t\t.setHspAlignLen(new Integer(alnLength))\n\t\t\t\t\t\t\t.setHspGaps(new Integer(gapOpenCount))\n\t\t\t\t\t\t\t.setHspQueryFrom(new Integer(queryStart))\n\t\t\t\t\t\t\t.setHspQueryTo(new Integer(queryEnd))\n\t\t\t\t\t\t\t.setHspHitFrom(new Integer(subjectStart))\n\t\t\t\t\t\t\t.setHspHitTo(new Integer(subjectEnd))\n\t\t\t\t\t\t\t.setHspEvalue(new Double(evalue))\n\t\t\t\t\t\t\t.setHspBitScore(new Double(bitScore))\n\t\t\t\t\t\t\t.setPercentageIdentity(new Double(percIdentity)/100)\n\t\t\t\t\t\t\t.setMismatchCount(new Integer(mismatchCount));\n\t\t\t\t\t\thsps.add(hspBuilder.createBlastHsp());\n\t\t\t\t\t\tif (scanner.hasNext()) line = fetchData(scanner);\n\t\t\t\t\t\tlineNumber++;\n\t\t\t\t\t}\n\t\t\t\t\thits.add(hitBuilder.setHsps(hsps).createBlastHit());\n\t\t\t\t}\n\t\t\t\tresults.add(resultBuilder.setHits(hits).createBlastResult());\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new ParseException(\"Invalid numeric value met at line \"+ lineNumber+\" in:\\n\"+line,0);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate String fetchData(Scanner scanner){\n\t\tString line;\n\t\tString[] split;\n\n\t\tline = scanner.nextLine();\n\t\twhile (line.startsWith(\"#\")){\n\t\t\t// blast tabular with header options contains some more informations\n\t\t\tif (line.matches(\"#\\\\s.?BLAST.+\")) programName = line.replace(\"#\\\\s\",\"\");\n\t\t\tif (line.startsWith(\"# Query:\")) queryName = line.replace(\"# Query: \",\"\");\n\t\t\tif (line.startsWith(\"# Database:\")) databaseFile = line.replace(\"# Database: \",\"\");\n\n\t\t\t// needed because blast report can end with a comment...\n\t\t\tif (!scanner.hasNext()) return null;\n\t\t\tline = scanner.nextLine();\n\t\t}\n\n\t\t// Here, programName != null checks if there was a header in the file\n\t\tboolean headerFound = programName != null;\n\n\t\tsplit = line.split(\"\\\\t\");\n\t\tqueryId      =split[0];\n\t\tsubjectId    =split[1];\n\t\tpercIdentity =split[2];\n\t\talnLength    =split[3];\n\t\tmismatchCount=split[4];\n\t\tgapOpenCount =split[5];\n\t\tqueryStart   =split[6];\n\t\tqueryEnd     =split[7];\n\t\tsubjectStart =split[8];\n\t\tsubjectEnd   =split[9];\n\t\tevalue       =split[10];\n\t\tbitScore     =split[11];\n\n\t\t// blast tabular reports only the first word of the query name.\n\t\t// If it was specified in the header it is better to use that definition\n\t\tif (parsingConsistency == PARSING_CONSISTENCY.IMPROVED && headerFound) {\n\t\t\tif (queryIdMapping.get(queryId)==null) {\n\t\t\t\tqueryIdNumber ++;\n\t\t\t\tqueryIdMapping.put(queryId,\"Query_\" + queryIdNumber);\n\t\t\t}\n\t\t\t// If a complete definition of the query name was readed, than we can use\n\t\t\t// a queryID schema that is consistent with blast xml report\n\t\t\tqueryId = queryIdMapping.get(queryId);\n\t\t}\n\t\tif (!headerFound) queryName = queryId;\n\n\t\treturn line;\n\t}\n\n\t@Override\n\tpublic void storeObjects(List<Result> results) throws IOException, ParseException {\n\t\tthrow new UnsupportedOperationException(\"Not supported yet.\");\n\t}\n\n\t/**\n\t * Intended for use with run module.\n\t * Although possible, does not make a lot of sense to have it with limited\n\t * information such those in tabular report\n\t * @param sequences\n\t */\n\t@Override\n\tpublic void setQueryReferences(List<Sequence> sequences) {\n\t\tthrow new UnsupportedOperationException(\"Not supported for this parser.\");\n\t}\n\t/**\n\t * Intended for use with run module.\n\t * Although possible, does not make a lot of sense to have it with limited\n\t * information such those in tabular report\n\t * @param sequences\n\t */\n\t@Override\n\tpublic void setDatabaseReferences(List<Sequence> sequences) {\n\t\tthrow new UnsupportedOperationException(\"Not supported for this parser.\");\n\t}\n\t /**\n\t * Tries to define a different level of consistency during parsing.\n\t * LITERAL is intended a strict parsing much tight to the report.\n\t * IMPROVED consistency tries to import data much tight to the data model\n\t * (I hope you got the idea, if not, have a look to the code.\n\t * I suggest to use improved unless you have reasons to do not)\n\t */\n\tpublic void setParsingConsistency(PARSING_CONSISTENCY parsingConsistency) {\n\t\tthis.parsingConsistency = parsingConsistency;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io.blast;\n\nimport java.io.File;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.biojava.nbio.core.search.io.Hit;\nimport org.biojava.nbio.core.search.io.Hsp;\nimport org.biojava.nbio.core.search.io.Result;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n *\n * @author Paolo Pavan\n */\npublic class BlastTabularParserTest {\n\n\tpublic BlastTabularParserTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of getFileExtensions method, of class BlastTabularParser.\n\t */\n\t@Test\n\tpublic void testGetFileExtensions() {\n\t\tSystem.out.println(\"getFileExtensions\");\n\t\tBlastTabularParser instance = new BlastTabularParser();\n\n\t\tList<String> expResult = new ArrayList<String>();\n\t\texpResult.add(\"blasttabular\");\n\t\texpResult.add(\"blasttxt\");\n\n\t\tList<String> result = instance.getFileExtensions();\n\t\tassertEquals(expResult, result);\n\t}\n\n\t/**\n\t * Test of setFile method, of class BlastTabularParser.\n\t */\n\t@Test\n\tpublic void testSetFile() {\n\t\tSystem.out.println(\"setFile\");\n\t\tFile f = null;\n\t\tBlastTabularParser instance = new BlastTabularParser();\n\t\tinstance.setFile(f);\n\t}\n\n\n\tprotected  File getFileForResource(String resource){\n\t\tURL resourceURL = this.getClass().getResource(resource);\n\t\tString filepath = resourceURL.getFile();\n\t\tfilepath = filepath.replaceAll(\"%20\",\" \");\n\n\t\tFile file = new File(filepath);\n\n\t\treturn file;\n\t}\n\n\t/**\n\t * Test of createObjects method, of class BlastTabularParser.\n\t */\n\t@Test\n\tpublic void testCreateObjects() throws Exception {\n\t\tSystem.out.println(\"createObjects\");\n\t\tResult expRes1;\n\t\tHit expHit1res1;\n\t\tHsp expHsp1hit1res1;\n\n\t\tString resource = \"/org/biojava/nbio/core/search/io/blast/small-blastreport.blasttxt\";\n\t\tFile file = getFileForResource(resource);\n\n\t\tBlastTabularParser instance = new BlastTabularParser();\n\t\tinstance.setFile(file);\n\n\t\tList<Result> results = instance.createObjects(1e-10);\n\n\t\tBlastHsp hsp1Hit1Res1 = new BlastHspBuilder()\n\t\t\t\t.setHspNum(1)\n\t\t\t\t.setPercentageIdentity(100.0/100)\n\t\t\t\t.setHspAlignLen(1567)\n\t\t\t\t.setMismatchCount(0)\n\t\t\t\t.setHspGaps(0)\n\t\t\t\t.setHspQueryFrom(1)\n\t\t\t\t.setHspQueryTo(1567)\n\t\t\t\t.setHspHitFrom(616309)\n\t\t\t\t.setHspQueryTo(617875)\n\t\t\t\t.setHspEvalue(0)\n\t\t\t\t.setHspBitScore(2894)\n\t\t\t\t.createBlastHsp();\n\n\t\tBlastHsp hsp1Hit1Res2 = new BlastHspBuilder()\n\t\t\t\t.setHspNum(1)\n\t\t\t\t.setPercentageIdentity(100.0/100)\n\t\t\t\t.setHspAlignLen(1567)\n\t\t\t\t.setMismatchCount(0)\n\t\t\t\t.setHspGaps(0)\n\t\t\t\t.setHspQueryFrom(1)\n\t\t\t\t.setHspQueryTo(1567)\n\t\t\t\t.setHspHitFrom(1278699)\n\t\t\t\t.setHspQueryTo(1277133)\n\t\t\t\t.setHspEvalue(0)\n\t\t\t\t.setHspBitScore(2894)\n\t\t\t\t.createBlastHsp();\n\n\t\tList<Hsp> hsplist = new ArrayList<Hsp>();\n\t\thsplist.add(hsp1Hit1Res1);\n\t\thsplist.add(hsp1Hit1Res2);\n\n\t\tBlastHit hit1Res1 = new BlastHitBuilder()\n\t\t\t\t.setHitDef(\"CP000411\")\n\t\t\t\t.setHsps(hsplist)\n\t\t\t\t.createBlastHit();\n\t\tList<Hit> hitlist = new ArrayList<Hit>();\n\t\thitlist.add(hit1Res1);\n\n\t\tBlastResult res1 = new BlastResultBuilder()\n\t\t\t\t.setQueryID(\"CP000411_-_16S_rRNA\")\n\t\t\t\t.setQueryDef(\"CP000411_-_16S_rRNA\")\n\t\t\t\t.setHits(hitlist)\n\t\t\t\t.createBlastResult();\n\n\t\texpRes1 = results.get(0);\n\t\texpHit1res1 = expRes1.iterator().next();\n\t\texpHsp1hit1res1 = expHit1res1.iterator().next();\n\n\t\t// results test\n\t\tassertEquals(expRes1, res1);\n\t\t// hit test\n\t\tassertEquals(expHit1res1, hit1Res1);\n\t\t// hsp test\n\t\tassertEquals(expHsp1hit1res1, hsp1Hit1Res1);\n\n\n\t\tString resource2 = \"/org/biojava/nbio/core/search/io/blast/testBlastTabularReport.txt\";\n\n\t\tFile file2 = getFileForResource(resource2);\n\n\t\tBlastTabularParser instance2 = new BlastTabularParser();\n\t\tinstance2.setFile(file2);\n\n\t\tList<Result> results2 = instance2.createObjects(1e-10);\n\t\texpRes1 = results2.get(0);\n\t\texpHit1res1 = expRes1.iterator().next();\n\t\texpHsp1hit1res1 = expHit1res1.iterator().next();\n\n\t\thsp1Hit1Res1 = new BlastHspBuilder()\n\t\t\t\t.setPercentageIdentity(100.00/100)\n\t\t\t\t.setHspAlignLen(48)\n\t\t\t\t.setMismatchCount(0)\n\t\t\t\t.setHspGaps(0)\n\t\t\t\t.setHspQueryFrom(1)\n\t\t\t\t.setHspQueryTo(48)\n\t\t\t\t.setHspHitFrom(344)\n\t\t\t\t.setHspHitTo(391)\n\t\t\t\t.setHspEvalue(4e-19)\n\t\t\t\t.setHspBitScore(95.6)\n\t\t\t\t.createBlastHsp();\n\n\t\t// results test\n\t\tassertEquals(expRes1.getQueryID(), \"1_759_906_F3\");\n\t\tassertEquals(results2.size(), 298);\n\t\t// only one hsp test\n\t\tassertEquals(expHsp1hit1res1, hsp1Hit1Res1);\n\t}\n\n\n\n}\n","changedTest":"","commitMessage":"Using slf4j logger instead of java logging\n","test_commitMessage":"","allZero":false}