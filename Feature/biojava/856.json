{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/SuperPosition.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestSuperPosition.java","prod_time":"2018-03-14 23:28:01","test_time":"2018-03-14 23:28:01","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"0e8c081c44098127953112c08bb39c01982b468f","test_commitID":"0e8c081c44098127953112c08bb39c01982b468f","isfound":"found test change","originPro":"package org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\n\n/**\n * The SuperPosition interface defines and documents the required methods for\n * any superpostion algorithm implementation, so that the input and expected\n * output are uniform.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic interface SuperPosition {\n\n\t/**\n\t * Obtain the superposition matrix that minimizes the RMSD between two\n\t * arrays of equivalent points.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param fixed\n\t *            point array as reference, onto which the other point array is\n\t *            superposed. Original coordinates will not be modified.\n\t * @param moved\n\t *            point array to which the resulting transformation matrix is\n\t *            applied. Original coordinates will not be modified.\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superpose(Point3d[] fixed, Point3d[] moved);\n\n\t/**\n\t * Transform an array of points so that the coordinates of its points\n\t * minimize the RMSD to the other array of equivalent points, and return the\n\t * transformation matrix applied.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param fixed\n\t *            point array as reference, onto which the other point array is\n\t *            superposed. Original coordinates will not be modified.\n\t * @param moved\n\t *            point array to which the resulting transformation matrix is\n\t *            applied. Original coordinates will be transformed.\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superposeAndTransform(Point3d[] fixed, Point3d[] moved);\n\n\t/**\n\t * Calculate the RMSD between two arrays of equivalent points that are not\n\t * superposed.\n\t * <p>\n\t * This is equivalent to first superposing the point arrays with\n\t * {@link SuperPosition#superposeAndTransform(Point3d[], Point3d[])} and\n\t * then calculating the RMSD of the superposed point arrays with\n\t * {@link CalcPoint#rmsd(Point3d[], Point3d[])}, but it will be faster when\n\t * the transformation matrix is not needed.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param x\n\t *            an array of points. Original coordinates will not be modified.\n\t * @param y\n\t *            an array of points. Original coordinates will not be modified.\n\t * @return the minimum RMSD between the equivalent point arrays (after\n\t *         superposition)\n\t */\n\tpublic double getRmsd(Point3d[] x, Point3d[] y);\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\n\n/**\n * The SuperPosition interface defines and documents the required methods for\n * any superpostion algorithm implementation, so that the input and expected\n * output are uniform.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic interface SuperPosition {\n\n\t/**\n\t * Obtain the superposition matrix that minimizes the RMSD between two\n\t * arrays of equivalent points.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param fixed\n\t *            point array as reference, onto which the other point array is\n\t *            superposed. Original coordinates will not be modified.\n\t * @param moved\n\t *            point array to which the resulting transformation matrix is\n\t *            applied. Original coordinates will not be modified.\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superpose(Point3d[] fixed, Point3d[] moved);\n\n\t/**\n\t * Transform an array of points so that the coordinates of its points\n\t * minimize the RMSD to the other array of equivalent points, and return the\n\t * transformation matrix applied.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param fixed\n\t *            point array as reference, onto which the other point array is\n\t *            superposed. Original coordinates will not be modified.\n\t * @param moved\n\t *            point array to which the resulting transformation matrix is\n\t *            applied. Original coordinates will be transformed.\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superposeAndTransform(Point3d[] fixed, Point3d[] moved);\n\n\t/**\n\t * Calculate the RMSD between two arrays of equivalent points that are not\n\t * superposed.\n\t * <p>\n\t * This is equivalent to first superposing the point arrays with\n\t * {@link SuperPosition#superposeAndTransform(Point3d[], Point3d[])} and\n\t * then calculating the RMSD of the superposed point arrays with\n\t * {@link CalcPoint#rmsd(Point3d[], Point3d[])}, but it will be faster when\n\t * the transformation matrix is not needed.\n\t * <p>\n\t * The two point arrays have to be of the same length and the order of\n\t * points have to be the same, so that a specific position in the one array\n\t * is equivalent to the same position in the other array.\n\t * \n\t * @param x\n\t *            an array of points. Original coordinates will not be modified.\n\t * @param y\n\t *            an array of points. Original coordinates will not be modified.\n\t * @return the minimum RMSD between the equivalent point arrays (after\n\t *         superposition)\n\t */\n\tpublic double getRmsd(Point3d[] x, Point3d[] y);\n\n}\n","originTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.geometry.SuperPositionQuat;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test and compare the different superposition methods implemented in BioJava.\n * \n * @author Aleix Lafita\n * @author Jose Duarte\n * @since 5.0.0\n *\n */\npublic class TestSuperPosition {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(TestSuperPosition.class);\n\n\tprivate static List<Point3d[]> cloud1;\n\tprivate static List<Point3d[]> cloud2;\n\n\t// the transformation to apply to cloud points 1 that needs to be recovered by the superposition code\n\tprivate static final AxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\tprivate static final Vector3d translation = new Vector3d(0.345, 2.453, 5.324);;\n\tprivate static Matrix4d transform;\n\t\t\n\t// a translation to apply to cloud point 2 for the rmsd test only\n\tprivate static final Vector3d translation2 = new Vector3d(1.32, -1.03, 6.28);\n\n\t/**\n\t * Generate two clouds of random points of different sizes to test\n\t * correctness and performance of superposition algorithms.\n\t * \n\t * @throws StructureException\n\t */\n\t@Before\n\tpublic void setUp() throws StructureException {\n\n\t\tcloud1 = new ArrayList<Point3d[]>(5);\n\t\tcloud2 = new ArrayList<Point3d[]>(5);\n\n\t\tRandom rnd = new Random(0);\n\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\n\t\tList<Integer> sizes = Arrays.asList(5, 50, 500, 5000, 50000, 500000);\n\n\t\tfor (Integer size : sizes) {\n\n\t\t\tPoint3d[] c1 = new Point3d[size];\n\t\t\tPoint3d[] c2 = new Point3d[size];\n\n\t\t\tfor (int p = 0; p < size; p++) {\n\n\t\t\t\tPoint3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50),\n\t\t\t\t\t\trnd.nextInt(150));\n\t\t\t\tc1[p] = a;\n\n\t\t\t\t// Add some noise\n\t\t\t\tPoint3d b = new Point3d(a.x + rnd.nextDouble(), a.y\n\t\t\t\t\t\t+ rnd.nextDouble(), a.z + rnd.nextDouble());\n\t\t\t\tc2[p] = b;\n\t\t\t}\n\n\t\t\tCalcPoint.center(c1);\n\t\t\tCalcPoint.center(c2);\n\n\t\t\tCalcPoint.transform(transform, c1);\t\t\t\n\n\t\t\tcloud1.add(c1);\n\t\t\tcloud2.add(c2);\n\t\t\t\t\t\n\t\t\tPoint3d centroid1 = CalcPoint. centroid(c1);\n\t\t\tPoint3d centroid2 = CalcPoint. centroid(c2);\n\t\t\tLOGGER.debug(\"Centroid c1 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid1.x, centroid1.y, centroid1.z);\n\t\t\tLOGGER.debug(\"Centroid c2 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid2.x, centroid2.y, centroid2.z);\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the transformation matrix from superpositions.\n\t */\n\t@Test\n\tpublic void testSuperposition() {\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\n\t\t\t// Use SVD superposition\n\t\t\tSuperPosition svd = new SuperPositionSVD(false);\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tMatrix4d svdTransform = svd.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\t// Use quaternion superposition\n\t\t\tSuperPosition quat = new SuperPositionQuat(false);\n\t\t\tlong quatStart = System.nanoTime();\n\t\t\tMatrix4d quatTransform = quat.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong quatTime = (System.nanoTime() - quatStart) / 1000;\n\n\t\t\t// Use QCP algorithm\n\t\t\tSuperPosition qcp = new SuperPositionQCP(false);\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tMatrix4d qcpTransform = qcp.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tLOGGER.info(String.format(\"Transformation Matrix %d points: \"\n\t\t\t\t\t+ \"SVD time %d us, SP time: %d us, QCP time: %d us\",\n\t\t\t\t\tcloud1.get(c).length, svdTime, quatTime, qcpTime));\n\n\t\t\t// Check that the transformation matrix was recovered\n\t\t\tassertTrue(transform.epsilonEquals(svdTransform, 0.05));\n\t\t\tassertTrue(transform.epsilonEquals(quatTransform, 0.05));\n\t\t\tassertTrue(transform.epsilonEquals(qcpTransform, 0.05));\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the RMSD of a superposition.\n\t */\n\t@Test\n\tpublic void testRMSD() {\n\t\t\n\t\t// for the rmsd test we first make sure that both cloud points are not centered in origin so that the centering is tested too\n\t\t// first cloud points are already centered, we translate cloud2 only\n\t\tfor (int c=0; c<cloud2.size(); c++) {\n\t\t\tCalcPoint.translate(translation2, cloud2.get(c));\n\t\t\t\n\t\t\tPoint3d centroid2 = CalcPoint. centroid(cloud2.get(c));\t\t\t\n\t\t\tLOGGER.debug(\"Centroid c2 (index %d): (%.2f, %.2f, %.2f)\\n\", c, centroid2.x, centroid2.y, centroid2.z);\n\t\t}\n\t\t\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\n\t\t\t// Use SVD superposition\n\t\t\tSuperPosition svd = new SuperPositionSVD(false);\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tdouble svdrmsd = svd.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\t// Use quaternion superposition\n\t\t\tSuperPosition quat = new SuperPositionQuat(false);\n\t\t\tlong quatStart = System.nanoTime();\n\t\t\tdouble quatrmsd = quat.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong quatTime = (System.nanoTime() - quatStart) / 1000;\n\n\t\t\t// Use QCP algorithm\n\t\t\tSuperPosition qcp = new SuperPositionQCP(false);\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tdouble qcprmsd = qcp.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tLOGGER.info(String.format(\"RMSD %d points: SVD time %d us, \"\n\t\t\t\t\t+ \"Quat time: %d us, QCP time: %d us\", cloud1.get(c).length,\n\t\t\t\t\tsvdTime, quatTime, qcpTime));\n\n\t\t\t// Check that the returned RMSDs are equal\n\t\t\tassertEquals(quatrmsd, qcprmsd, 0.001);\n\t\t\tassertEquals(svdrmsd, quatrmsd, 0.001);\n\t\t\tassertEquals(svdrmsd, qcprmsd, 0.001);\n\t\t}\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.geometry.SuperPositionQuat;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test and compare the different superposition methods implemented in BioJava.\n * \n * @author Aleix Lafita\n * @author Jose Duarte\n * @since 5.0.0\n *\n */\npublic class TestSuperPosition {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(TestSuperPosition.class);\n\n\tprivate static List<Point3d[]> cloud1;\n\tprivate static List<Point3d[]> cloud2;\n\n\t// the transformation to apply to cloud points 1 that needs to be recovered by the superposition code\n\tprivate static final AxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\tprivate static final Vector3d translation = new Vector3d(0.345, 2.453, 5.324);;\n\tprivate static Matrix4d transform;\n\t\t\n\t// a translation to apply to cloud point 2 for the rmsd test only\n\tprivate static final Vector3d translation2 = new Vector3d(1.32, -1.03, 6.28);\n\n\t/**\n\t * Generate two clouds of random points of different sizes to test\n\t * correctness and performance of superposition algorithms.\n\t * \n\t * @throws StructureException\n\t */\n\t@Before\n\tpublic void setUp() throws StructureException {\n\n\t\tcloud1 = new ArrayList<Point3d[]>(5);\n\t\tcloud2 = new ArrayList<Point3d[]>(5);\n\n\t\tRandom rnd = new Random(0);\n\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\n\t\tList<Integer> sizes = Arrays.asList(5, 50, 500, 5000, 50000, 500000);\n\n\t\tfor (Integer size : sizes) {\n\n\t\t\tPoint3d[] c1 = new Point3d[size];\n\t\t\tPoint3d[] c2 = new Point3d[size];\n\n\t\t\tfor (int p = 0; p < size; p++) {\n\n\t\t\t\tPoint3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50),\n\t\t\t\t\t\trnd.nextInt(150));\n\t\t\t\tc1[p] = a;\n\n\t\t\t\t// Add some noise\n\t\t\t\tPoint3d b = new Point3d(a.x + rnd.nextDouble(), a.y\n\t\t\t\t\t\t+ rnd.nextDouble(), a.z + rnd.nextDouble());\n\t\t\t\tc2[p] = b;\n\t\t\t}\n\n\t\t\tCalcPoint.center(c1);\n\t\t\tCalcPoint.center(c2);\n\n\t\t\tCalcPoint.transform(transform, c1);\t\t\t\n\n\t\t\tcloud1.add(c1);\n\t\t\tcloud2.add(c2);\n\t\t\t\t\t\n\t\t\tPoint3d centroid1 = CalcPoint. centroid(c1);\n\t\t\tPoint3d centroid2 = CalcPoint. centroid(c2);\n\t\t\tLOGGER.debug(\"Centroid c1 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid1.x, centroid1.y, centroid1.z);\n\t\t\tLOGGER.debug(\"Centroid c2 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid2.x, centroid2.y, centroid2.z);\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the transformation matrix from superpositions.\n\t */\n\t@Test\n\tpublic void testSuperposition() {\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\n\t\t\t// Use SVD superposition\n\t\t\tSuperPosition svd = new SuperPositionSVD(false);\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tMatrix4d svdTransform = svd.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\t// Use quaternion superposition\n\t\t\tSuperPosition quat = new SuperPositionQuat(false);\n\t\t\tlong quatStart = System.nanoTime();\n\t\t\tMatrix4d quatTransform = quat.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong quatTime = (System.nanoTime() - quatStart) / 1000;\n\n\t\t\t// Use QCP algorithm\n\t\t\tSuperPosition qcp = new SuperPositionQCP(false);\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tMatrix4d qcpTransform = qcp.superpose(cloud1.get(c), cloud2.get(c));\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tLOGGER.info(String.format(\"Transformation Matrix %d points: \"\n\t\t\t\t\t+ \"SVD time %d us, SP time: %d us, QCP time: %d us\",\n\t\t\t\t\tcloud1.get(c).length, svdTime, quatTime, qcpTime));\n\n\t\t\t// Check that the transformation matrix was recovered\n\t\t\tassertTrue(transform.epsilonEquals(svdTransform, 0.05));\n\t\t\tassertTrue(transform.epsilonEquals(quatTransform, 0.05));\n\t\t\tassertTrue(transform.epsilonEquals(qcpTransform, 0.05));\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the RMSD of a superposition.\n\t */\n\t@Test\n\tpublic void testRMSD() {\n\t\t\n\t\t// for the rmsd test we first make sure that both cloud points are not centered in origin so that the centering is tested too\n\t\t// first cloud points are already centered, we translate cloud2 only\n\t\tfor (int c=0; c<cloud2.size(); c++) {\n\t\t\tCalcPoint.translate(translation2, cloud2.get(c));\n\t\t\t\n\t\t\tPoint3d centroid2 = CalcPoint. centroid(cloud2.get(c));\t\t\t\n\t\t\tLOGGER.debug(\"Centroid c2 (index %d): (%.2f, %.2f, %.2f)\\n\", c, centroid2.x, centroid2.y, centroid2.z);\n\t\t}\n\t\t\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\n\t\t\t// Use SVD superposition\n\t\t\tSuperPosition svd = new SuperPositionSVD(false);\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tdouble svdrmsd = svd.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\t// Use quaternion superposition\n\t\t\tSuperPosition quat = new SuperPositionQuat(false);\n\t\t\tlong quatStart = System.nanoTime();\n\t\t\tdouble quatrmsd = quat.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong quatTime = (System.nanoTime() - quatStart) / 1000;\n\n\t\t\t// Use QCP algorithm\n\t\t\tSuperPosition qcp = new SuperPositionQCP(false);\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tdouble qcprmsd = qcp.getRmsd(cloud1.get(c), cloud2.get(c));\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tLOGGER.info(String.format(\"RMSD %d points: SVD time %d us, \"\n\t\t\t\t\t+ \"Quat time: %d us, QCP time: %d us\", cloud1.get(c).length,\n\t\t\t\t\tsvdTime, quatTime, qcpTime));\n\n\t\t\t// Check that the returned RMSDs are equal\n\t\t\tassertEquals(quatrmsd, qcprmsd, 0.001);\n\t\t\tassertEquals(svdrmsd, quatrmsd, 0.001);\n\t\t\tassertEquals(svdrmsd, qcprmsd, 0.001);\n\t\t}\n\t}\n\n}\n","commitMessage":"Add license to all files\n\nran `development/addlicense.sh`","test_commitMessage":"Add license to all files\n\nran `development/addlicense.sh`","allZero":true}