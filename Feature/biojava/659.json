{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/internal/SymmetryAxes.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/internal/TestSymmetryAxes.java","prod_time":"2016-06-14 17:32:27","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":12,"add_classname_line":0,"add_condition_line":10,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":2,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b61555a14c08b2d1bf47e7298db1911d2547b658","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.util.RotationAxis;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\n\n/**\n * Data Structure that stores all the symmetry axis that describe\n * the symmetry of a structure. Generalizes to all types of symmetry,\n * the classic ones (Cn, Dn) and any hierarchical or local symmetries.\n * <p>\n * Hierarchical symmetry can be visualized as a tree, where each level\n * has a fixed branching factor. Each level of the tree is associated\n * with a transformation operator, whose order determines the degree of\n * nodes at that level of the tree. Leaves of the tree implicitly\n * represent aligned repeats (indexed 0 to n-1), so care must be taken to\n * keep external references to the repeats (e.g. rows of a\n * {@link MultipleAlignment} in the same order implied by the tree.\n * <p>\n * Each node of the tree specifies an alignment between those repeats\n * below each of its children. It is also associated with a symmetry axis,\n * which is calculated based on the associated operator as well as any parent\n * operators.\n * It also stores the parts of the structure (symmetric units) involved\n * in each axis, in addition to the way to calculate them.\n * <p>\n * This is intended to provide a general axis support for the multiple\n * repeat alignment optimization and the axis display in Jmol. This\n * object is related to a MultipleAlignment object that defines the\n * symmetric units.\n *\n * @author Aleix Lafita\n * @since 4.2.0\n *\n */\npublic class SymmetryAxes {\n\t/*\n\t * Implementation note: The tree is a nice explanation and a good image\n\t * for developing algorithms, but it is not constructed explicitly.\n\t * Instead, we just store one elementary axis for each level and reconstruct\n\t * which operators apply to a particular leaf based on that leaf's index.\n\t */\n\t\n\t/**\n\t * Represents an axis of symmetry\n\t * @author Spencer Bliven\n\t *\n\t */\n\tpublic static class Axis {\n\t\tprivate Matrix4d operator;\n\t\tprivate int order;\n\t\tprivate SymmetryType symmType;\n\t\tprivate int level;\n\t\t//private int indexInLevel;\n\t\tprivate int firstRepeat;\n\t\tprivate RotationAxis rotAxis;\n\n\t\tpublic Axis(Matrix4d operator, int order, SymmetryType type, int level, int firstRepeat) {\n\t\t\tif (order < 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"A symmetry axis should divide a structure in > 2 parts\");\n\t\t\t}\n\t\t\tif(type != SymmetryType.OPEN && type != SymmetryType.CLOSED) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid symmetry type. Only OPEN and CLOSED are allowed\");\n\t\t\t}\n\n\t\t\tthis.operator = operator;\n\t\t\tthis.order = order;\n\t\t\tthis.symmType = type;\n\t\t\tsetLevel(level);\n\t\t\tsetFirstRepeat(firstRepeat);\n\t\t\trotAxis = null;\n\t\t}\n\t\t/**\n\t\t * Get the transformation operator for this axis as an homogeneous matrix\n\t\t * @return the transformation operator\n\t\t */\n\t\tpublic Matrix4d getOperator() {\n\t\t\treturn operator;\n\t\t}\n\t\tpublic void setOperator(Matrix4d op) {\n\t\t\tthis.operator = op;\n\t\t}\n\t\t/**\n\t\t * Get the order of this axis (closed symm) or the number of repeats\n\t\t * (open symm)\n\t\t * @return the order\n\t\t */\n\t\tpublic int getOrder() {\n\t\t\treturn order;\n\t\t}\n\t\t/**\n\t\t * @return the symmType (OPEN or CLOSED only)\n\t\t */\n\t\tpublic SymmetryType getSymmType() {\n\t\t\treturn symmType;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Get the transformation operator as a rotation axis. For open\n\t\t * symmetry this will have a non-zero screw component.\n\t\t * @return a RotationAxis for this Axis\n\t\t */\n\t\tpublic RotationAxis getRotationAxis() {\n\t\t\tif( rotAxis == null) {\n\t\t\t\trotAxis = new RotationAxis(operator);\n\t\t\t}\n\t\t\treturn rotAxis;\n\t\t}\n\t\t/**\n\t\t * @return The level of this axis within it's parent hierarchy, or -1 if unset\n\t\t */\n\t\tpublic int getLevel() {\n\t\t\treturn level;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param level The level of this axis within it's parent hierarchy. Must be positive\n\t\t */\n\t\tpublic void setLevel(int level) {\n\t\t\tif(level < 0) throw new IndexOutOfBoundsException(\"Level must be positive\");\n\t\t\tthis.level = level;\n\t\t}\n//\t\t/**\n//\t\t * Each level can contain multiple equivalent axes. This index is\n//\t\t * used to distinguish them.\n//\t\t * @return the index of this axis relative to others at the same level\n//\t\t */\n//\t\tpublic int getIndexInLevel() {\n//\t\t\treturn indexInLevel;\n//\t\t}\n//\t\t/**\n//\t\t * \n//\t\t * @param indexInLevel the index of this axis relative to others at the same level\n//\t\t */\n//\t\tpublic void setIndexInLevel(int indexInLevel) {\n//\t\t\tif( indexInLevel < 0 || getOrder() <= indexInLevel )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Invalid index for order \"+getOrder());\n//\t\t\tthis.indexInLevel = indexInLevel;\n//\t\t}\n\t\t/**\n\t\t * Get the index of the first repeat used by this axis\n\t\t * @return the firstRepeat\n\t\t */\n\t\tpublic int getFirstRepeat() {\n\t\t\treturn firstRepeat;\n\t\t}\n\t\t/**\n\t\t * @param firstRepeat the index of the first repeat used by this axis\n\t\t */\n\t\tpublic void setFirstRepeat(int firstRepeat) {\n\t\t\tthis.firstRepeat = firstRepeat;\n\t\t}\n\t}\n\t\n\t/**\n\t * List of all symmetry axis. They are sorted from higher to lower\n\t * in the symmetry hierarchy, where higher means that they apply\n\t * more globally and lower means that they apply to a local region\n\t * of the higher axis division.\n\t */\n\tprivate final List<Axis> axes;\n\n\t/**\n\t * Constructor.\n\t * Initializes variables only.\n\t */\n\tpublic SymmetryAxes(){\n\t\taxes = new ArrayList<>();\n\t}\n\n\t/**\n\t * Adds a new axis of symmetry.\n\t * The repeats that participate in this axis and their superposition\n\t * relation should also be indicated.\n\t *\n\t * @param axis the new axis of symmetry found\n\t * @param superposition repeats participating and superposition relation\n\t * @param repeats number of times the transformation is applied to every\n\t * \t\t\trepeat. index1=repeat, index2=times.\n\t * @param division number of parts that this axis divides the structure in\n\t *\n\t * @throws IllegalArgumentException if the repeat relation is in the\n\t * \t\t\twrong format: should be double List of equal sizes.\n\t * @deprecated Use {@link #addAxis(Matrix4d, int, SymmetryType)} instead.\n\t *  Repeats and Superposition are now inferred automatically.\n\t */\n\t@Deprecated\n\tpublic void addAxis(Matrix4d axis, List<List<Integer>> superposition,\n\t\t\tList<Integer> repeats, Integer division) {\n\n\t\t//Check correct format of repeat relations\n\t\tif (superposition.size() != 2){\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Wrong superposition format: should be double List.\");\n\t\t} else if (superposition.get(0).size() != superposition.get(1).size()){\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Wrong superposition format: not equal List sizes.\");\n\t\t}\n\t\t// Now ignores superposition & repeats except to guess symmetry type\n\t\tSymmetryType type;\n\t\t// Closed if superposition has a circular permutation\n\t\tList<Integer> superPos1 = superposition.get(1);\n\t\tif(superPos1.get(0) > superPos1.get(superPos1.size()-1)) {\n\t\t\ttype = SymmetryType.CLOSED;\n\t\t} else {\n\t\t\ttype = SymmetryType.OPEN;\n\t\t}\n\t\tthis.addAxis(axis,division,type);\n\t}\n\t/**\n\t * Adds a new axis of symmetry to the bottom level of the tree\n\t *\n\t * @param axis the new axis of symmetry found\n\t * @param order number of parts that this axis divides the structure in\n\t * @param type indicates whether the axis has OPEN or CLOSED symmetry\n\t */\n\tpublic void addAxis(Matrix4d axis, int order, SymmetryType type) {\n\t\taxes.add(new Axis(axis,order,type,axes.size(),0));\n\t}\n\n\t/**\n\t * Return a list giving the number of times each axis must be applied\n\t * to generate the given repeat.\n\t * <P>\n\t * For instance, for a D3 case <tt>getAxisCounts(4)</tt> would return [2,0],\n\t * indicating that repeat 4 is generated by two applications of the 3-fold\n\t * axis followed by 0 applications of the two-fold axis.\n\t * \n\t * @param repeat Index of the desired repeat\n\t * @return array of the same length as axes giving the number of times\n\t *  to apply each axis.\n\t */\n\tprivate int[] getAxisCounts(int repeat) {\n\t\tint[] counts = new int[getNumLevels()];\n\t\t\n\t\tfor(int i = counts.length-1; i >= 0; i--) {\n\t\t\tint d = axes.get(i).getOrder();\n\t\t\tcounts[i] = repeat % d;\n\t\t\trepeat /= d;\n\t\t}\n\t\tassert repeat == 0 : \"Invalid repeat index\";\n\t\treturn counts;\n\t}\n\n//\t/**\n//\t * Inverse of {@link #getAxisCounts(int)}; Calculates the repeat for a\n//\t * particular number of applications of each axis\n//\t * @param counts Number of times to apply each axis\n//\t * @return Repeat index\n//\t */\n//\tprivate int getRepeatIndex(int[] counts) {\n//\t\tint repeat = 0;\n//\t\tfor(int i = 0; i< counts.length; i++) {\n//\t\t\trepeat += counts[i]*axes.get(i).getOrder();\n//\t\t}\n//\t\treturn repeat;\n//\t}\n\t/**\n\t * Updates an axis of symmetry, after the superposition changed.\n\t *\n\t * @param index old axis index\n\t * @param newAxis\n\t */\n\tpublic void updateAxis(Integer index, Matrix4d newAxis){\n\t\taxes.get(index).setOperator(newAxis);\n\t}\n\n\t/**\n\t * Return the operator for all elementary axes of symmetry of the structure, that is,\n\t * the axes stored in the List as unique and from which all the symmetry\n\t * axes are constructed.\n\t *\n\t * @return axes elementary axes of symmetry.\n\t */\n\tpublic List<Matrix4d> getElementaryAxes(){\n\t\tList<Matrix4d> ops = new ArrayList<Matrix4d>(getNumLevels());\n\t\tfor(Axis axis : axes) {\n\t\t\tops.add(axis.getOperator());\n\t\t}\n\t\treturn ops;\n\t}\n\t\n\t/**\n\t * Return all elementary axes of symmetry of the structure, that is,\n\t * the axes stored in the List as unique and from which all the symmetry\n\t * axes are constructed.\n\t *\n\t * @return axes elementary axes of symmetry.\n\t */\n\tpublic List<Axis> getElementaryAxesObjects() {\n\t\treturn axes;\n\t}\n\n\t/**\n\t * Get the indices of participating repeats in Cauchy two-line form.\n\t * <p>\n\t * Returns two lists of the same length.\n\t * The first gives a list of all repeat indices which are aligned\n\t * at the specified level of symmetry (e.g. 0 through the degree of this level).\n\t * The second list gives the corresponding repeats after applying the\n\t * operator once.\n\t *\n\t * @param level the axis index\n\t * @return the double List of repeat relations, or null if the\n\t * \t\t\tlevel is invalid\n\t * @see #getRepeatsCyclicForm(int, int) for an equivalent specification with half the memory\n\t */\n\tpublic List<List<Integer>> getRepeatRelation(int level){\n\t\treturn getRepeatRelation(level,0);\n\t}\n\n\tpublic List<List<Integer>> getRepeatRelation(Axis axis){\n\t\treturn getRepeatRelation(axis.getLevel(),axis.getFirstRepeat());\n\t}\n\n\tpublic List<List<Integer>> getRepeatRelation(int level, int firstRepeat) {\n\t\tAxis axis = axes.get(level);\n\t\tint m = getNumRepeats(level+1);//size of the children\n\t\tint d = axis.getOrder(); // degree of this node\n\t\tint n = m*d; // number of repeats included\n\t\tif(firstRepeat % n != 0) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Repeat %d cannot start a block at level %s of this tree\",firstRepeat,level));\n\t\t}\n\t\tif(axis.getSymmType() == SymmetryType.OPEN) {\n\t\t\tn -= m; // leave off last child for open symm\n\t\t}\n\t\tList<Integer> repeats = new ArrayList<>(n);\n\t\tList<Integer> equiv = new ArrayList<>(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\trepeats.add(i+firstRepeat);\n\t\t\tequiv.add( (i+m)%(m*d)+firstRepeat );\n\t\t}\n\t\treturn Arrays.asList(repeats,equiv);\n\n\t}\n\n\t/**\n\t * Get the indices of participating repeats in cyclic form.\n\t * <p>\n\t * Each inner list gives a set of equivalent repeats and should have length\n\t * equal to the order of the axis' operator. \n\t * @param level\n\t * @param firstRepeat\n\t * @return\n\t */\n\tpublic List<List<Integer>> getRepeatsCyclicForm(int level, int firstRepeat) {\n\t\tAxis axis = axes.get(level);\n\t\tint m = getNumRepeats(level+1);//size of the children\n\t\tint d = axis.getOrder(); // degree of this node\n\t\tint n = m*d; // number of repeats included\n\t\tif(firstRepeat % n != 0) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Repeat %d cannot start a block at level %s of this tree\",firstRepeat,level));\n\t\t}\n\t\tif(axis.getSymmType() == SymmetryType.OPEN) {\n\t\t\tn -= m; // leave off last child for open symm\n\t\t}\n\t\t\n\t\tList<List<Integer>> repeats = new ArrayList<>(m);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tList<Integer> cycle = new ArrayList<>(d);\n\t\t\tfor(int j=0;j<d;j++) {\n\t\t\t\tcycle.add(firstRepeat+i+j*m);\n\t\t\t}\n\t\t\trepeats.add(cycle);\n\t\t}\n\t\treturn repeats;\n\t}\n\tpublic List<List<Integer>> getRepeatsCyclicForm(Axis axis) {\n\t\treturn getRepeatsCyclicForm(axis.getLevel(),axis.getFirstRepeat());\n\t}\n\tpublic List<List<Integer>> getRepeatsCyclicForm(int level) {\n\t\treturn getRepeatsCyclicForm(level,0);\n\t}\n\tpublic String getRepeatsCyclicForm(Axis axis, List<?> repeats) {\n\t\tif(repeats.size() != getNumRepeats()) {\n\t\t\tthrow new IllegalArgumentException(\"Mismatch in the number of repeats\");\n\t\t}\n\t\treturn getRepeatsCyclicForm(getRepeatsCyclicForm(axis), repeats);\n\t}\n\tpublic static String getRepeatsCyclicForm(List<List<Integer>> cycleForm, List<?> repeats) {\n\t\tStringBuilder str = new StringBuilder();\n\t\tfor(List<Integer> cycle : cycleForm) {\n\t\t\tstr.append(\"(\");\n\t\t\tIterator<Integer> cycleIt = cycle.iterator();\n\t\t\tstr.append(repeats.get(cycleIt.next())); //should be at least one\n\t\t\twhile(cycleIt.hasNext()) {\n\t\t\t\tstr.append(\";\")\n\t\t\t\t.append(repeats.get( cycleIt.next() ));\n\t\t\t}\n\t\t\tstr.append(\")\");\n\t\t}\n\t\treturn str.toString();\n\t}\n\t/**\n\t * Return the transformation that needs to be applied to a\n\t * repeat in order to superimpose onto repeat 0.\n\t *\n\t * @param repeat the repeat index\n\t * @return transformation matrix for the repeat\n\t */\n\tpublic Matrix4d getRepeatTransform(int repeat){\n\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.setIdentity();\n\n\t\tint[] counts = getAxisCounts(repeat);\n\n\t\tfor(int t = counts.length-1; t>=0; t--) {\n\t\t\tif( counts[t] == 0 )\n\t\t\t\tcontinue;\n\t\t\tMatrix4d axis = new Matrix4d(axes.get(t).getOperator());\n\t\t\tfor(int i=0;i<counts[t];i++) {\n\t\t\t\ttransform.mul(axis);\n\t\t\t}\n\t\t}\n\t\treturn transform;\n\t}\n\n\t/**\n\t * Return all symmetry axes of of the structure: the set of axes that\n\t * describe all parts of the structure. This combines the elementary\n\t * axes to generate all possible axes. The axes are returned in the repeat\n\t * degrees.\n\t * @return axes all symmetry axes of the structure.\n\t */\n\tpublic List<Axis> getSymmetryAxes(){\n\n\t\tList<Axis> symmAxes = new ArrayList<>();\n\n\t\tMatrix4d prior = new Matrix4d();\n\t\tprior.setIdentity();\n\t\t\n\t\tgetSymmetryAxes(symmAxes,prior,0,0);\n\t\t\n\t\t\n\t\treturn symmAxes;\n\t}\n\t/**\n\t * Recursive helper\n\t * @param symmAxes output list\n\t * @param prior transformation aligning the first repeat of this axis with the first overall\n\t * @param level current level\n\t */\n\tprivate void getSymmetryAxes(List<Axis> symmAxes, Matrix4d prior, int level, int firstRepeat) {\n\t\tif(level >= getNumLevels() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tAxis elem = axes.get(level);\n\t\tMatrix4d elemOp = elem.getOperator();\n\n\t\t// Current axis:\n\t\t// elementary maps B -> A\n\t\t// prior maps I -> A and J -> B\n\t\t// want J -> I = J -> B -> A <- I= inv(prior) * elementary * prior\n\t\tMatrix4d currAxisOp = new Matrix4d(prior);\n\t\tcurrAxisOp.invert();\n\t\tcurrAxisOp.mul(elemOp);\n\t\tcurrAxisOp.mul(prior);\n\t\tAxis currAxis = new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);\n\t\tsymmAxes.add(currAxis);\n\t\t\n\t\t//Remember that all degrees are at least 2\n\t\tgetSymmetryAxes(symmAxes,prior,level+1,0);\n\t\t//New prior is elementary^d*prior\n\t\tMatrix4d newPrior = new Matrix4d(elemOp);\n\t\tnewPrior.mul(prior);\n\t\tint childSize = getNumRepeats(level+1);\n\t\tgetSymmetryAxes(symmAxes,newPrior,level+1,childSize);\n\t\tfor(int d=2;d<elem.getOrder();d++) {\n\t\t\tnewPrior.mul(elemOp,newPrior);\n\t\t\tgetSymmetryAxes(symmAxes,newPrior,level+1,childSize*d);\n\t\t}\n\t}\n\t\n\t\n//\tpublic Matrix4d getSymmetryAxis(int level, int axisNum) {\n//\t\tif(level == 0) {\n//\t\t\tif( axisNum != 0 )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Axis number out of bounds\");\n//\t\t\treturn axes.get(0);\n//\t\t} else {\n//\t\t\tif( axisNum >= degrees.get(level-1) )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Axis number out of bounds\");\n//\t\t\t// Convert axisNum into a count of \n//\t\t\n//\t}\n\t/**\n\t * Get the number of repeats. This is equal to the product of all degrees.\n\t * @return Number of repeats (leaves of the tree).\n\t */\n\tpublic int getNumRepeats() {\n\t\treturn getNumRepeats(0);\n\t}\n\n\t/**\n\t * Get the number of leaves from a node at the specified level. This is\n\t * equal to the product of all degrees at or below the level.\n\t * @param level level of the tree to cut at\n\t * @return Number of repeats (leaves of the tree).\n\t */\n\tprivate int getNumRepeats(int level) {\n\t\tint size = 1;\n\t\t// Return 1 for illegally high level\n\t\tif(level < getNumLevels()) {\n\t\t\tfor(Axis axis : axes.subList(level, getNumLevels())) {\n\t\t\t\tsize *= axis.getOrder();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\n\tpublic Axis getElementaryAxis(int level) {\n\t\treturn axes.get(level);\n\t}\n\n\tpublic int getNumLevels() {\n\t\treturn axes.size();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.util.RotationAxis;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\n\n/**\n * Data Structure that stores all the symmetry axis that describe\n * the symmetry of a structure. Generalizes to all types of symmetry,\n * the classic ones (Cn, Dn) and any hierarchical or local symmetries.\n * <p>\n * Hierarchical symmetry can be visualized as a tree, where each level\n * has a fixed branching factor. Each level of the tree is associated\n * with a transformation operator, whose order determines the degree of\n * nodes at that level of the tree. Leaves of the tree implicitly\n * represent aligned repeats (indexed 0 to n-1), so care must be taken to\n * keep external references to the repeats (e.g. rows of a\n * {@link MultipleAlignment} in the same order implied by the tree.\n * <p>\n * Each node of the tree specifies an alignment between those repeats\n * below each of its children. It is also associated with a symmetry axis,\n * which is calculated based on the associated operator as well as any parent\n * operators.\n * It also stores the parts of the structure (symmetric units) involved\n * in each axis, in addition to the way to calculate them.\n * <p>\n * This is intended to provide a general axis support for the multiple\n * repeat alignment optimization and the axis display in Jmol. This\n * object is related to a MultipleAlignment object that defines the\n * symmetric units.\n *\n * @author Aleix Lafita\n * @since 4.2.0\n *\n */\npublic class SymmetryAxes {\n\t/*\n\t * Implementation note: The tree is a nice explanation and a good image\n\t * for developing algorithms, but it is not constructed explicitly.\n\t * Instead, we just store one elementary axis for each level and reconstruct\n\t * which operators apply to a particular leaf based on that leaf's index.\n\t */\n\t\n\t/**\n\t * Represents an axis of symmetry\n\t * @author Spencer Bliven\n\t *\n\t */\n\tpublic static class Axis {\n\t\tprivate Matrix4d operator;\n\t\tprivate int order;\n\t\tprivate SymmetryType symmType;\n\t\tprivate int level;\n\t\t//private int indexInLevel;\n\t\tprivate int firstRepeat;\n\t\tprivate RotationAxis rotAxis;\n\n\t\tpublic Axis(Matrix4d operator, int order, SymmetryType type, int level, int firstRepeat) {\n\t\t\tif (order < 2) {\n\t\t\t\tthrow new IllegalArgumentException(\"A symmetry axis should divide a structure in > 2 parts\");\n\t\t\t}\n\t\t\tif(type != SymmetryType.OPEN && type != SymmetryType.CLOSED) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid symmetry type. Only OPEN and CLOSED are allowed\");\n\t\t\t}\n\n\t\t\tthis.operator = operator;\n\t\t\tthis.order = order;\n\t\t\tthis.symmType = type;\n\t\t\tsetLevel(level);\n\t\t\tsetFirstRepeat(firstRepeat);\n\t\t\trotAxis = null;\n\t\t}\n\t\t/**\n\t\t * Get the transformation operator for this axis as an homogeneous matrix\n\t\t * @return the transformation operator\n\t\t */\n\t\tpublic Matrix4d getOperator() {\n\t\t\treturn operator;\n\t\t}\n\t\tpublic void setOperator(Matrix4d op) {\n\t\t\tthis.operator = op;\n\t\t}\n\t\t/**\n\t\t * Get the order of this axis (closed symm) or the number of repeats\n\t\t * (open symm)\n\t\t * @return the order\n\t\t */\n\t\tpublic int getOrder() {\n\t\t\treturn order;\n\t\t}\n\t\t/**\n\t\t * @return the symmType (OPEN or CLOSED only)\n\t\t */\n\t\tpublic SymmetryType getSymmType() {\n\t\t\treturn symmType;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Get the transformation operator as a rotation axis. For open\n\t\t * symmetry this will have a non-zero screw component.\n\t\t * @return a RotationAxis for this Axis\n\t\t */\n\t\tpublic RotationAxis getRotationAxis() {\n\t\t\tif( rotAxis == null) {\n\t\t\t\trotAxis = new RotationAxis(operator);\n\t\t\t}\n\t\t\treturn rotAxis;\n\t\t}\n\t\t/**\n\t\t * @return The level of this axis within it's parent hierarchy, or -1 if unset\n\t\t */\n\t\tpublic int getLevel() {\n\t\t\treturn level;\n\t\t}\n\t\t/**\n\t\t * \n\t\t * @param level The level of this axis within it's parent hierarchy. Must be positive\n\t\t */\n\t\tpublic void setLevel(int level) {\n\t\t\tif(level < 0) throw new IndexOutOfBoundsException(\"Level must be positive\");\n\t\t\tthis.level = level;\n\t\t}\n//\t\t/**\n//\t\t * Each level can contain multiple equivalent axes. This index is\n//\t\t * used to distinguish them.\n//\t\t * @return the index of this axis relative to others at the same level\n//\t\t */\n//\t\tpublic int getIndexInLevel() {\n//\t\t\treturn indexInLevel;\n//\t\t}\n//\t\t/**\n//\t\t * \n//\t\t * @param indexInLevel the index of this axis relative to others at the same level\n//\t\t */\n//\t\tpublic void setIndexInLevel(int indexInLevel) {\n//\t\t\tif( indexInLevel < 0 || getOrder() <= indexInLevel )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Invalid index for order \"+getOrder());\n//\t\t\tthis.indexInLevel = indexInLevel;\n//\t\t}\n\t\t/**\n\t\t * Get the index of the first repeat used by this axis\n\t\t * @return the firstRepeat\n\t\t */\n\t\tpublic int getFirstRepeat() {\n\t\t\treturn firstRepeat;\n\t\t}\n\t\t/**\n\t\t * @param firstRepeat the index of the first repeat used by this axis\n\t\t */\n\t\tpublic void setFirstRepeat(int firstRepeat) {\n\t\t\tthis.firstRepeat = firstRepeat;\n\t\t}\n\t}\n\t\n\t/**\n\t * List of all symmetry axis. They are sorted from higher to lower\n\t * in the symmetry hierarchy, where higher means that they apply\n\t * more globally and lower means that they apply to a local region\n\t * of the higher axis division.\n\t */\n\tprivate final List<Axis> axes;\n\n\t/**\n\t * Constructor.\n\t * Initializes variables only.\n\t */\n\tpublic SymmetryAxes(){\n\t\taxes = new ArrayList<>();\n\t}\n\n\t/**\n\t * Adds a new axis of symmetry.\n\t * The repeats that participate in this axis and their superposition\n\t * relation should also be indicated.\n\t *\n\t * @param axis the new axis of symmetry found\n\t * @param superposition repeats participating and superposition relation\n\t * @param repeats number of times the transformation is applied to every\n\t * \t\t\trepeat. index1=repeat, index2=times.\n\t * @param division number of parts that this axis divides the structure in\n\t *\n\t * @throws IllegalArgumentException if the repeat relation is in the\n\t * \t\t\twrong format: should be double List of equal sizes.\n\t * @deprecated Use {@link #addAxis(Matrix4d, int, SymmetryType)} instead.\n\t *  Repeats and Superposition are now inferred automatically.\n\t */\n\t@Deprecated\n\tpublic void addAxis(Matrix4d axis, List<List<Integer>> superposition,\n\t\t\tList<Integer> repeats, Integer division) {\n\n\t\t//Check correct format of repeat relations\n\t\tif (superposition.size() != 2){\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Wrong superposition format: should be double List.\");\n\t\t} else if (superposition.get(0).size() != superposition.get(1).size()){\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Wrong superposition format: not equal List sizes.\");\n\t\t}\n\t\t// Now ignores superposition & repeats except to guess symmetry type\n\t\tSymmetryType type;\n\t\t// Closed if superposition has a circular permutation\n\t\tList<Integer> superPos1 = superposition.get(1);\n\t\tif(superPos1.get(0) > superPos1.get(superPos1.size()-1)) {\n\t\t\ttype = SymmetryType.CLOSED;\n\t\t} else {\n\t\t\ttype = SymmetryType.OPEN;\n\t\t}\n\t\tthis.addAxis(axis,division,type);\n\t}\n\t/**\n\t * Adds a new axis of symmetry to the bottom level of the tree\n\t *\n\t * @param axis the new axis of symmetry found\n\t * @param order number of parts that this axis divides the structure in\n\t * @param type indicates whether the axis has OPEN or CLOSED symmetry\n\t */\n\tpublic void addAxis(Matrix4d axis, int order, SymmetryType type) {\n\t\taxes.add(new Axis(axis,order,type,axes.size(),0));\n\t}\n\n\t/**\n\t * Return a list giving the number of times each axis must be applied\n\t * to generate the given repeat.\n\t * <P>\n\t * For instance, for a D3 case <tt>getAxisCounts(4)</tt> would return [2,0],\n\t * indicating that repeat 4 is generated by two applications of the 3-fold\n\t * axis followed by 0 applications of the two-fold axis.\n\t * \n\t * @param repeat Index of the desired repeat\n\t * @return array of the same length as axes giving the number of times\n\t *  to apply each axis.\n\t */\n\tprivate int[] getAxisCounts(int repeat) {\n\t\tint[] counts = new int[getNumLevels()];\n\t\t\n\t\tfor(int i = counts.length-1; i >= 0; i--) {\n\t\t\tint d = axes.get(i).getOrder();\n\t\t\tcounts[i] = repeat % d;\n\t\t\trepeat /= d;\n\t\t}\n\t\tassert repeat == 0 : \"Invalid repeat index\";\n\t\treturn counts;\n\t}\n\n//\t/**\n//\t * Inverse of {@link #getAxisCounts(int)}; Calculates the repeat for a\n//\t * particular number of applications of each axis\n//\t * @param counts Number of times to apply each axis\n//\t * @return Repeat index\n//\t */\n//\tprivate int getRepeatIndex(int[] counts) {\n//\t\tint repeat = 0;\n//\t\tfor(int i = 0; i< counts.length; i++) {\n//\t\t\trepeat += counts[i]*axes.get(i).getOrder();\n//\t\t}\n//\t\treturn repeat;\n//\t}\n\t/**\n\t * Updates an axis of symmetry, after the superposition changed.\n\t *\n\t * @param index old axis index\n\t * @param newAxis\n\t */\n\tpublic void updateAxis(Integer index, Matrix4d newAxis){\n\t\taxes.get(index).setOperator(newAxis);\n\t}\n\n\t/**\n\t * Return the operator for all elementary axes of symmetry of the structure, that is,\n\t * the axes stored in the List as unique and from which all the symmetry\n\t * axes are constructed.\n\t *\n\t * @return axes elementary axes of symmetry.\n\t */\n\tpublic List<Matrix4d> getElementaryAxes(){\n\t\tList<Matrix4d> ops = new ArrayList<Matrix4d>(getNumLevels());\n\t\tfor(Axis axis : axes) {\n\t\t\tops.add(axis.getOperator());\n\t\t}\n\t\treturn ops;\n\t}\n\t\n\t/**\n\t * Return all elementary axes of symmetry of the structure, that is,\n\t * the axes stored in the List as unique and from which all the symmetry\n\t * axes are constructed.\n\t *\n\t * @return axes elementary axes of symmetry.\n\t */\n\tpublic List<Axis> getElementaryAxesObjects() {\n\t\treturn axes;\n\t}\n\n\t/**\n\t * Get the indices of participating repeats in Cauchy two-line form.\n\t * <p>\n\t * Returns two lists of the same length.\n\t * The first gives a list of all repeat indices which are aligned\n\t * at the specified level of symmetry (e.g. 0 through the degree of this level).\n\t * The second list gives the corresponding repeats after applying the\n\t * operator once.\n\t *\n\t * @param level the axis index\n\t * @return the double List of repeat relations, or null if the\n\t * \t\t\tlevel is invalid\n\t * @see #getRepeatsCyclicForm(int, int) for an equivalent specification with half the memory\n\t */\n\tpublic List<List<Integer>> getRepeatRelation(int level){\n\t\treturn getRepeatRelation(level,0);\n\t}\n\n\tpublic List<List<Integer>> getRepeatRelation(Axis axis){\n\t\treturn getRepeatRelation(axis.getLevel(),axis.getFirstRepeat());\n\t}\n\n\tpublic List<List<Integer>> getRepeatRelation(int level, int firstRepeat) {\n\t\tAxis axis = axes.get(level);\n\t\tint m = getNumRepeats(level+1);//size of the children\n\t\tint d = axis.getOrder(); // degree of this node\n\t\tint n = m*d; // number of repeats included\n\t\tif(firstRepeat % n != 0)\n\t\t\tthrow new IllegalArgumentException(String.format(\"Repeat %d cannot start a block at level %s of this tree\",firstRepeat,level));\n\t\tif(axis.getSymmType() == SymmetryType.OPEN) {\n\t\t\tn -= m; // leave off last child for open symm\n\t\t}\n\t\tList<Integer> repeats = new ArrayList<>(n);\n\t\tList<Integer> equiv = new ArrayList<>(n);\n\t\tfor(int i=0;i<n;i++) {\n\t\t\trepeats.add(i+firstRepeat);\n\t\t\tequiv.add( (i+m)%(m*d)+firstRepeat );\n\t\t}\n\t\treturn Arrays.asList(repeats,equiv);\n\n\t}\n\n\t/**\n\t * Get the indices of participating repeats in cyclic form.\n\t * <p>\n\t * Each inner list gives a set of equivalent repeats and should have length\n\t * equal to the order of the axis' operator. \n\t * @param level\n\t * @param firstRepeat\n\t * @return\n\t */\n\tpublic List<List<Integer>> getRepeatsCyclicForm(int level, int firstRepeat) {\n\t\tAxis axis = axes.get(level);\n\t\tint m = getNumRepeats(level+1);//size of the children\n\t\tint d = axis.getOrder(); // degree of this node\n\t\tint n = m*d; // number of repeats included\n\t\tif(firstRepeat % n != 0) {\n\t\t\tthrow new IllegalArgumentException(String.format(\"Repeat %d cannot start a block at level %s of this tree\",firstRepeat,level));\n\t\t}\n\t\tif(axis.getSymmType() == SymmetryType.OPEN) {\n\t\t\tn -= m; // leave off last child for open symm\n\t\t}\n\t\t\n\t\tList<List<Integer>> repeats = new ArrayList<>(m);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tList<Integer> cycle = new ArrayList<>(d);\n\t\t\tfor(int j=0;j<d;j++) {\n\t\t\t\tcycle.add(firstRepeat+i+j*m);\n\t\t\t}\n\t\t\trepeats.add(cycle);\n\t\t}\n\t\treturn repeats;\n\t}\n\tpublic List<List<Integer>> getRepeatsCyclicForm(Axis axis) {\n\t\treturn getRepeatsCyclicForm(axis.getLevel(),axis.getFirstRepeat());\n\t}\n\tpublic List<List<Integer>> getRepeatsCyclicForm(int level) {\n\t\treturn getRepeatsCyclicForm(level,0);\n\t}\n\tpublic String getRepeatsCyclicForm(Axis axis, List<?> repeats) {\n\t\tif(repeats.size() != getNumRepeats()) {\n\t\t\tthrow new IllegalArgumentException(\"Mismatch in the number of repeats\");\n\t\t}\n\t\treturn getRepeatsCyclicForm(getRepeatsCyclicForm(axis), repeats);\n\t}\n\tpublic static String getRepeatsCyclicForm(List<List<Integer>> cycleForm, List<?> repeats) {\n\t\tStringBuilder str = new StringBuilder();\n\t\tfor(List<Integer> cycle : cycleForm) {\n\t\t\tstr.append(\"(\");\n\t\t\tIterator<Integer> cycleIt = cycle.iterator();\n\t\t\tstr.append(repeats.get(cycleIt.next())); //should be at least one\n\t\t\twhile(cycleIt.hasNext()) {\n\t\t\t\tstr.append(\";\")\n\t\t\t\t.append(repeats.get( cycleIt.next() ));\n\t\t\t}\n\t\t\tstr.append(\")\");\n\t\t}\n\t\treturn str.toString();\n\t}\n\t\n\t/**\n\t * Return the transformation that needs to be applied to a\n\t * repeat in order to superimpose onto repeat 0.\n\t *\n\t * @param repeat the repeat index\n\t * @return transformation matrix for the repeat\n\t */\n\tpublic Matrix4d getRepeatTransform(int repeat){\n\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.setIdentity();\n\n\t\tint[] counts = getAxisCounts(repeat);\n\n\t\tfor(int t = counts.length-1; t>=0; t--) {\n\t\t\tif( counts[t] == 0 )\n\t\t\t\tcontinue;\n\t\t\tMatrix4d axis = new Matrix4d(axes.get(t).getOperator());\n\t\t\tfor(int i=0;i<counts[t];i++) {\n\t\t\t\ttransform.mul(axis);\n\t\t\t}\n\t\t}\n\t\treturn transform;\n\t}\n\t\n\t/**\n\t * Return the transformation that needs to be applied to\n\t * repeat x in order to superimpose onto repeat y.\n\t *\n\t * @param x the first repeat index (transformed)\n\t * @param y the second repeat index (fixed)\n\t * @return transformation matrix for the repeat x\n\t */\n\tpublic Matrix4d getRepeatTransform(int x, int y){\n\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.setIdentity();\n\n\t\tint[] iCounts = getAxisCounts(x);\n\t\tint[] jCounts = getAxisCounts(y);\n\t\t\n\t\tint[] counts = new int[iCounts.length];\n\t\tfor (int k = 0; k < iCounts.length; k++)\n\t\t\tcounts[k] = iCounts[k] - jCounts[k];\n\t\t\n\t\tfor(int t = counts.length-1; t>=0; t--) {\n\t\t\tif(counts[t] == 0)\n\t\t\t\tcontinue;\n\t\t\tif (counts[t] > 0) {\n\t\t\t\tMatrix4d axis = new Matrix4d(axes.get(t).getOperator());\n\t\t\t\tfor(int i=0;i<counts[t];i++)\n\t\t\t\t\ttransform.mul(axis);\n\t\t\t} else if (counts[t] < 0) {\n\t\t\t\tMatrix4d axis = new Matrix4d(axes.get(t).getOperator());\n\t\t\t\taxis.invert();\n\t\t\t\tfor(int i=0;i<counts[t];i++)\n\t\t\t\t\ttransform.mul(axis);\n\t\t\t}\n\t\t}\n\t\treturn transform;\n\t}\n\n\t/**\n\t * Return all symmetry axes of of the structure: the set of axes that\n\t * describe all parts of the structure. This combines the elementary\n\t * axes to generate all possible axes. The axes are returned in the repeat\n\t * degrees.\n\t * @return axes all symmetry axes of the structure.\n\t */\n\tpublic List<Axis> getSymmetryAxes(){\n\n\t\tList<Axis> symmAxes = new ArrayList<>();\n\n\t\tMatrix4d prior = new Matrix4d();\n\t\tprior.setIdentity();\n\t\t\n\t\tgetSymmetryAxes(symmAxes,prior,0,0);\n\t\t\n\t\t\n\t\treturn symmAxes;\n\t}\n\t/**\n\t * Recursive helper\n\t * @param symmAxes output list\n\t * @param prior transformation aligning the first repeat of this axis with the first overall\n\t * @param level current level\n\t */\n\tprivate void getSymmetryAxes(List<Axis> symmAxes, Matrix4d prior, int level, int firstRepeat) {\n\t\tif(level >= getNumLevels() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tAxis elem = axes.get(level);\n\t\tMatrix4d elemOp = elem.getOperator();\n\n\t\t// Current axis:\n\t\t// elementary maps B -> A\n\t\t// prior maps I -> A and J -> B\n\t\t// want J -> I = J -> B -> A <- I= inv(prior) * elementary * prior\n\t\tMatrix4d currAxisOp = new Matrix4d(prior);\n\t\tcurrAxisOp.invert();\n\t\tcurrAxisOp.mul(elemOp);\n\t\tcurrAxisOp.mul(prior);\n\t\tAxis currAxis = new Axis(currAxisOp,elem.getOrder(),elem.getSymmType(),level,firstRepeat);\n\t\tsymmAxes.add(currAxis);\n\t\t\n\t\t//Remember that all degrees are at least 2\n\t\tgetSymmetryAxes(symmAxes,prior,level+1,0);\n\t\t//New prior is elementary^d*prior\n\t\tMatrix4d newPrior = new Matrix4d(elemOp);\n\t\tnewPrior.mul(prior);\n\t\tint childSize = getNumRepeats(level+1);\n\t\tgetSymmetryAxes(symmAxes,newPrior,level+1,childSize);\n\t\tfor(int d=2;d<elem.getOrder();d++) {\n\t\t\tnewPrior.mul(elemOp,newPrior);\n\t\t\tgetSymmetryAxes(symmAxes,newPrior,level+1,childSize*d);\n\t\t}\n\t}\n\t\n\t\n//\tpublic Matrix4d getSymmetryAxis(int level, int axisNum) {\n//\t\tif(level == 0) {\n//\t\t\tif( axisNum != 0 )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Axis number out of bounds\");\n//\t\t\treturn axes.get(0);\n//\t\t} else {\n//\t\t\tif( axisNum >= degrees.get(level-1) )\n//\t\t\t\tthrow new IndexOutOfBoundsException(\"Axis number out of bounds\");\n//\t\t\t// Convert axisNum into a count of \n//\t\t\n//\t}\n\t/**\n\t * Get the number of repeats. This is equal to the product of all degrees.\n\t * @return Number of repeats (leaves of the tree).\n\t */\n\tpublic int getNumRepeats() {\n\t\treturn getNumRepeats(0);\n\t}\n\n\t/**\n\t * Get the number of leaves from a node at the specified level. This is\n\t * equal to the product of all degrees at or below the level.\n\t * @param level level of the tree to cut at\n\t * @return Number of repeats (leaves of the tree).\n\t */\n\tprivate int getNumRepeats(int level) {\n\t\tint size = 1;\n\t\t// Return 1 for illegally high level\n\t\tif(level < getNumLevels()) {\n\t\t\tfor(Axis axis : axes.subList(level, getNumLevels())) {\n\t\t\t\tsize *= axis.getOrder();\n\t\t\t}\n\t\t}\n\t\treturn size;\n\t}\n\t\n\t/**\n\t * Get the first repeat index of each axis of a specified level.\n\t * @param level level of the tree to cut at\n\t * @return List of first Repeats of each index, sorted in ascending order\n\t */\n\tpublic List<Integer> getFirstRepeats(int level) {\n\t\tList<Integer> firstRepeats = new ArrayList<Integer>();\n\t\tif (level == 0)\n\t\t\tfirstRepeats.add(0); // No top level present\n\t\telse {\n\t\t\tint m = getNumRepeats(level);//size of the level\n\t\t\tint d = axes.get(level).getOrder(); // degree of this node\n\t\t\tfor (int firstRepeat = 0; firstRepeat < m*d; firstRepeat+=d)\n\t\t\t\tfirstRepeats.add(firstRepeat);\n\t\t}\n\t\treturn firstRepeats;\n\t}\n\n\tpublic Axis getElementaryAxis(int level) {\n\t\treturn axes.get(level);\n\t}\n\n\tpublic int getNumLevels() {\n\t\treturn axes.size();\n\t}\n\n}\n","originTest":"package org.biojava.nbio.structure.symmetry.internal;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\nimport org.biojava.nbio.structure.symmetry.internal.SymmetryAxes.Axis;\nimport org.junit.Test;\n\n\npublic class TestSymmetryAxes {\n\n\t@Test\n\tpublic void testClosedCase() {\n\t\t// D4 case\n\t\tSymmetryAxes axes = new SymmetryAxes();\n\n\t\t// Level 1 is C4 along Z\n\t\tMatrix4d r90 = new Matrix4d();\n\t\tr90.set(new AxisAngle4d(0, 0, 1, -Math.PI/2));\n\t\taxes.addAxis(r90, 4, SymmetryType.CLOSED);\n\t\t\n\t\t// Level 2 is C2 along X\n\t\tMatrix4d r180 = new Matrix4d();\n\t\tr180.set(new AxisAngle4d(1, 0, 0, Math.PI));\n\t\taxes.addAxis(r180, 2, SymmetryType.CLOSED);\n\n\t\tassertEquals(2,axes.getElementaryAxes().size());\n\n\t\tMatrix4d expectedEven = new Matrix4d();\n\t\texpectedEven.setIdentity();\n\t\tMatrix4d expectedOdd = new Matrix4d(r180);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(0));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(1));\n\t\texpectedEven.mul(r90);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(2));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(3));\n\t\texpectedEven.mul(r90);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(4));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(5));\n\t\texpectedEven.mul(r90);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(6));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(7));\n\n\t\t// Test Cauchy Form\n\t\tList<List<Integer>> relation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1,2,3,4,5,6,7),\n\t\t\t\tArrays.asList(2,3,4,5,6,7,0,1)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(0));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1),\n\t\t\t\tArrays.asList(1,0)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(1));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(2,3),\n\t\t\t\tArrays.asList(3,2)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(1,2));\n\t\ttry {\n\t\t\taxes.getRepeatRelation(2);\n\t\t\tfail(\"Invalid level\");\n\t\t} catch(IndexOutOfBoundsException e) {}\n\t\ttry {\n\t\t\taxes.getRepeatRelation(1,1);\n\t\t\tfail(\"Invalid firstRepeat\");\n\t\t} catch(IllegalArgumentException e) {}\n\t\t\n\t\t// Test Cyclic Form\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,2,4,6),\n\t\t\t\tArrays.asList(1,3,5,7)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(0));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(1));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(2,3)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(1,2));\n\t\ttry {\n\t\t\taxes.getRepeatsCyclicForm(2);\n\t\t\tfail(\"Invalid level\");\n\t\t} catch(IndexOutOfBoundsException e) {}\n\t\ttry {\n\t\t\taxes.getRepeatsCyclicForm(1,1);\n\t\t\tfail(\"Invalid firstRepeat\");\n\t\t} catch(IllegalArgumentException e) {}\n\n\t\t\n\t\t// Expected location of each repeat\n\t\tPoint3d[] repeats = new Point3d[] {\n\t\t\t\tnew Point3d(1,1,1),\n\t\t\t\tnew Point3d(1,-1,-1),\n\t\t\t\tnew Point3d(-1,1,1),\n\t\t\t\tnew Point3d(1,1,-1),\n\t\t\t\tnew Point3d(-1,-1,1),\n\t\t\t\tnew Point3d(-1,1,-1),\n\t\t\t\tnew Point3d(1,-1,1),\n\t\t\t\tnew Point3d(-1,-1,-1)\n\t\t};\n\t\t// Inverse of (1,1,1) should give above points\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tMatrix4d m = axes.getRepeatTransform(i);\n\t\t\tm.invert();\n\t\t\tPoint3d x = new Point3d(repeats[0]);\n\t\t\tm.transform(x);\n\t\t\tassertTrue(\"Transformation \"+i+\"^-1 of \"+repeats[0]+ \"=\"+x+\" not \"+repeats[i],x.epsilonEquals(repeats[i], 1e-5));\n\t\t}\n\t\t// Forward should map the above points onto the first one\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tMatrix4d m = axes.getRepeatTransform(i);\n\t\t\tPoint3d x = new Point3d(repeats[i]);\n\t\t\tm.transform(x);\n\t\t\tassertTrue(\"Transformation \"+i+\" of \"+repeats[i]+ \"=\"+x+\" not 1,1,1\",x.epsilonEquals(repeats[0], 1e-5));\n\t\t}\n\t\t\n\t\tPoint3d x;\n\t\t\n\t\tList<Axis> symmetryAxes = axes.getSymmetryAxes();\n\t\tassertEquals(5,symmetryAxes.size());\n\t\tint axisNum = 0;\n\t\t// Repeat 2 -> 0 (90 deg around z)\n\t\tx = new Point3d(repeats[2]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0], 1e-5));\n\t\tassertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());\n\t\taxisNum++;\n\t\t// Repeat 1 -> 0 (180 deg around x)\n\t\tx = new Point3d(repeats[1]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0], 1e-5));\n\t\tassertEquals(0,symmetryAxes.get(axisNum).getFirstRepeat());\n\t\taxisNum++;\n\t\t// Repeat 3 -> 2 (180 deg around y)\n\t\tx = new Point3d(repeats[3]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2], 1e-5));\n\t\tassertEquals(2,symmetryAxes.get(axisNum).getFirstRepeat());\n\t\taxisNum++;\n\t\t// Repeat 5 -> 4 (180 deg around x)\n\t\tx = new Point3d(repeats[5]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4], 1e-5));\n\t\tassertEquals(4,symmetryAxes.get(axisNum).getFirstRepeat());\n\t\taxisNum++;\n\t\t// Repeat 7 -> 6 (180 deg around y)\n\t\tx = new Point3d(repeats[7]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6], 1e-5));\n\t\tassertEquals(6,symmetryAxes.get(axisNum).getFirstRepeat());\n\t\taxisNum++;\n\t}\n\tprivate static Point3d round(Point3d p) {\n\t\treturn new Point3d(Math.round(p.x*100)/100.,Math.round(p.y*100)/100.,Math.round(p.z*100)/100.);\n\t}\n\n\t@Test\n\tpublic void testOpenCase() {\n\t\t// D4 case\n\t\tSymmetryAxes axes = new SymmetryAxes();\n\n\t\t// Level 1 is R4 along X\n\t\tMatrix4d t10 = new Matrix4d();\n\t\tt10.set(1,new Vector3d(-10,0,0));\n\t\taxes.addAxis(t10, 4, SymmetryType.OPEN);\n\n\t\t// Level 2 is C2 along X\n\t\tMatrix4d r180 = new Matrix4d();\n\t\tr180.set(new AxisAngle4d(1, 0, 0, Math.PI));\n\t\taxes.addAxis(r180, 2, SymmetryType.CLOSED);\n\n\t\tassertEquals(2,axes.getElementaryAxes().size());\n\n\t\tMatrix4d expectedEven = new Matrix4d();\n\t\texpectedEven.setIdentity();\n\t\tMatrix4d expectedOdd = new Matrix4d(r180);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(0));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(1));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(2));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(3));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(4));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(5));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(6));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(7));\n\n\t\t// Test Cauchy Form\n\t\tList<List<Integer>> relation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1,2,3,4,5),\n\t\t\t\tArrays.asList(2,3,4,5,6,7)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(0));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1),\n\t\t\t\tArrays.asList(1,0)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(1));\n\t\ttry {\n\t\t\taxes.getRepeatRelation(2);\n\t\t\tfail(\"Invalid level\");\n\t\t} catch(IndexOutOfBoundsException e) {}\n\t\t\n\t\t// Test Cyclic Form\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,2,4,6),\n\t\t\t\tArrays.asList(1,3,5,7)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(0));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(1));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(2,3)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatsCyclicForm(1,2));\n\t\ttry {\n\t\t\taxes.getRepeatsCyclicForm(2);\n\t\t\tfail(\"Invalid level\");\n\t\t} catch(IndexOutOfBoundsException e) {}\n\t\ttry {\n\t\t\taxes.getRepeatsCyclicForm(1,1);\n\t\t\tfail(\"Invalid firstRepeat\");\n\t\t} catch(IllegalArgumentException e) {}\n\n\t\t\n\t\t// Expected location of each repeat\n\t\tPoint3d[] repeats = new Point3d[] {\n\t\t\t\tnew Point3d(-15,1,1),\n\t\t\t\tnew Point3d(-15,-1,-1),\n\t\t\t\tnew Point3d( -5,1,1),\n\t\t\t\tnew Point3d( -5,-1,-1),\n\t\t\t\tnew Point3d(  5,1,1),\n\t\t\t\tnew Point3d(  5,-1,-1),\n\t\t\t\tnew Point3d( 15,1,1),\n\t\t\t\tnew Point3d( 15,-1,-1),\n\n\t\t};\n\t\t// Inverse of first point should give above points\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tMatrix4d m = axes.getRepeatTransform(i);\n\t\t\tm.invert();\n\t\t\tPoint3d x = new Point3d(repeats[0]);\n\t\t\tm.transform(x);\n\t\t\tassertTrue(\"Transformation \"+i+\"^-1 of \"+repeats[0]+ \"=\"+x+\" not \"+repeats[i],x.epsilonEquals(repeats[i], 1e-5));\n\t\t}\n\t\t// Forward should map the above points onto the first one\n\t\tfor(int i=0;i<8;i++) {\n\t\t\tMatrix4d m = axes.getRepeatTransform(i);\n\t\t\tPoint3d x = new Point3d(repeats[i]);\n\t\t\tm.transform(x);\n\t\t\tassertTrue(\"Transformation \"+i+\" of \"+repeats[i]+ \"=\"+x+\" not \"+repeats[0],x.epsilonEquals(repeats[0], 1e-5));\n\t\t}\n\t\t\n\t\tPoint3d x;\n\t\t\n\t\tList<Axis> symmetryAxes = axes.getSymmetryAxes();\n\t\tassertEquals(5,symmetryAxes.size());\n\t\tint axisNum = 0;\n\t\t// Repeat 2 -> 0 (shift 1)\n\t\tx = new Point3d(repeats[2]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[2]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0], 1e-5));\n\t\taxisNum++;\n\t\t// All of these are actually equivalent\n\t\t// Repeat 1 -> 0 (180 deg around x)\n\t\tx = new Point3d(repeats[1]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[1]),round(x),round(repeats[0])),x.epsilonEquals(repeats[0], 1e-5));\n\t\taxisNum++;\n\t\t// Repeat 3 -> 2 (180 deg around x)\n\t\tx = new Point3d(repeats[3]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[3]),round(x),round(repeats[2])),x.epsilonEquals(repeats[2], 1e-5));\n\t\taxisNum++;\n\t\t// Repeat 5 -> 4 (180 deg around x)\n\t\tx = new Point3d(repeats[5]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[5]),round(x),round(repeats[4])),x.epsilonEquals(repeats[4], 1e-5));\n\t\taxisNum++;\n\t\t// Repeat 7 -> 6 (180 deg around x)\n\t\tx = new Point3d(repeats[7]);\n\t\tsymmetryAxes.get(axisNum).getOperator().transform(x);\n\t\tassertTrue(String.format(\"SymmAxis %d of %s=%s not %s\",axisNum,round(repeats[7]),round(x),round(repeats[6])),x.epsilonEquals(repeats[6], 1e-5));\n\t\taxisNum++;\n\t}\n\t/**\n\t * Test that the deprecated addAxis still works\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\t@Test\n\tpublic void testOpenCaseOld() {\n\t\t// D4 case\n\t\tSymmetryAxes axes = new SymmetryAxes();\n\n\t\t// Level 1 is R4 along X\n\t\tMatrix4d t10 = new Matrix4d();\n\t\tt10.set(1,new Vector3d(1,0,0));\n\t\tList<Integer> repeats = Arrays.asList(0,0,1,1,2,2,3,3);\n\t\tList<List<Integer>> superposition = Arrays.asList(\n\t\t\t\tArrays.asList(0,1,2,3,4,5),\n\t\t\t\tArrays.asList(2,3,4,5,6,7));\n\t\taxes.addAxis(t10, superposition, repeats, 4);\n\n\t\t// Level 2 is C2 along X\n\t\tMatrix4d r180 = new Matrix4d();\n\t\tr180.set(new AxisAngle4d(1, 0, 0, Math.PI));\n\t\trepeats = Arrays.asList(0,1,0,1,0,1,0,1);\n\t\tsuperposition = Arrays.asList(\n\t\t\t\tArrays.asList(0,1),\n\t\t\t\tArrays.asList(1,0));\n\t\taxes.addAxis(r180, superposition, repeats, 2);\n\n\n\t\tassertEquals(2,axes.getElementaryAxes().size());\n\n\t\tMatrix4d expectedEven = new Matrix4d();\n\t\texpectedEven.setIdentity();\n\t\tMatrix4d expectedOdd = new Matrix4d(r180);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(0));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(1));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(2));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(3));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(4));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(5));\n\t\texpectedEven.mul(t10);\n\t\texpectedOdd.mul(r180,expectedEven);\n\t\tassertEquals(expectedEven, axes.getRepeatTransform(6));\n\t\tassertEquals(expectedOdd, axes.getRepeatTransform(7));\n\n\t\tList<List<Integer>> relation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1,2,3,4,5),\n\t\t\t\tArrays.asList(2,3,4,5,6,7)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(0));\n\t\trelation = Arrays.asList(\n\t\t\t\tArrays.asList(0,1),\n\t\t\t\tArrays.asList(1,0)\n\t\t\t\t);\n\t\tassertEquals(relation,axes.getRepeatRelation(1));\n\t\ttry {\n\t\t\taxes.getRepeatRelation(2);\n\t\t\tfail(\"Invalid level\");\n\t\t} catch(IndexOutOfBoundsException e) {}\n\n\t}\n}\n","changedTest":"","commitMessage":"Commit local changes","test_commitMessage":"","allZero":false}