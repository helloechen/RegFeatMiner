{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/Bond.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/TestBond.java","prod_time":"2014-10-03 12:26:12","test_time":"2014-12-15 20:13:27","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":1,"add_condition_line":0,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":1,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"cec97952d4ad6780315f87cff6e7fe8f55de545b","test_commitID":"d8687f0b0b33628550398c334f64669bcf484fa0","isfound":"found test change","originPro":"/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage org.biojava.bio.structure;\r\n\r\n/**\r\n * A simple bond -- it stores information about two atoms as well as information\r\n * about its bond order.\r\n * \r\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\r\n * @author Ulysse Carion\r\n */\r\npublic class Bond {\r\n\tprivate Atom atomA;\r\n\tprivate Atom atomB;\r\n\tprivate int bondOrder;\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * <p>\r\n\t * Note that by forming a bond between atoms 'A' and 'B' with this\r\n\t * constructor, atoms 'A' and 'B' will be updated to have this bond in their\r\n\t * list of bonds. If you do not want this automatic updating, instead use\r\n\t * {@link #Bond(Atom, Atom, int, boolean)} with the\r\n\t * <code>addSelfToAtoms</code> flag set to <code>false</code>.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\r\n\t\tthis(atomA, atomB, bondOrder, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t * @param addSelfToAtoms\r\n\t *            if set to true, this bond, once created, will automatically\r\n\t *            add itself to atomA and atomB's bond lists. (If this argument\r\n\t *            is set to false, the list returned from\r\n\t *            {@link Atom#getBonds()} will not contain this bond.)\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\r\n\t\tthis.atomA = atomA;\r\n\t\tthis.atomB = atomB;\r\n\t\tthis.bondOrder = bondOrder;\r\n\r\n\t\tif (addSelfToAtoms) {\r\n\t\t\taddSelfToAtoms();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\r\n\t * then the list returned from calling {@link Atom#getBonds()} will not\r\n\t * include this bond.\r\n\t * <p>\r\n\t * If you created your Bond with the constructor\r\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\r\n\t * you and should not be called again.\r\n\t */\r\n\t// TODO first check if those bonds haven't been made already\r\n\tpublic void addSelfToAtoms() {\r\n\t\tatomA.addBond(this);\r\n\t\tatomB.addBond(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomB()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomA() {\r\n\t\treturn atomA;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomA()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomB() {\r\n\t\treturn atomB;\r\n\t}\r\n\r\n\t/**\r\n\t * A utility method to get the other atom in a bond, given one of its atoms.\r\n\t * If the atom passed is one of the atoms in this bond, then this method is\r\n\t * essentially equivalent to saying\r\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\r\n\t * <p>\r\n\t * <i>Note:</i> Comparison of atoms in this method is done with\r\n\t * <code>==</code>, not <code>equals</code>.\r\n\t * \r\n\t * @param exclude\r\n\t *            the atom of the bond to not return\r\n\t * @throws IllegalArgumentException\r\n\t *             if the passed atom is not in this bond\r\n\t * @return the atom in this bond that was not passed as an argument\r\n\t */\r\n\tpublic Atom getOther(Atom exclude) {\r\n\t\tif (exclude != atomA && exclude != atomB) {\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\r\n\t\t}\r\n\r\n\t\tif (exclude == atomA) {\r\n\t\t\treturn atomB;\r\n\t\t} else {\r\n\t\t\treturn atomA;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\r\n\t * single bond, '2' to a double bond, etc.\r\n\t * \r\n\t * @return this bond's bond order\r\n\t */\r\n\tpublic int getBondOrder() {\r\n\t\treturn bondOrder;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance between the two atoms of this bond.\r\n\t * <p>\r\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\r\n\t * this method will suppress the empty threat of a\r\n\t * {@link StructureException} that method makes.\r\n\t * \r\n\t * @return the distance between the two atoms of this bond.\r\n\t */\r\n\tpublic double getLength() {\r\n\r\n\t\treturn Calc.getDistance(atomA, atomB);\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\r\n\t\t\t\t+ bondOrder + \"]\";\r\n\t}\r\n}\r\n","changedPro":"/*\r\n * To change this template, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\npackage org.biojava.bio.structure;\r\n\r\nimport java.io.Serializable;\r\n\r\n/**\r\n * A simple bond -- it stores information about two atoms as well as information\r\n * about its bond order.\r\n * \r\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\r\n * @author Ulysse Carion\r\n */\r\npublic class Bond implements Serializable {\r\n\r\n\tprivate static final long serialVersionUID = 8836120946858134380L;\r\n\tprivate Atom atomA;\r\n\tprivate Atom atomB;\r\n\tprivate int bondOrder;\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * <p>\r\n\t * Note that by forming a bond between atoms 'A' and 'B' with this\r\n\t * constructor, atoms 'A' and 'B' will be updated to have this bond in their\r\n\t * list of bonds. If you do not want this automatic updating, instead use\r\n\t * {@link #Bond(Atom, Atom, int, boolean)} with the\r\n\t * <code>addSelfToAtoms</code> flag set to <code>false</code>.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\r\n\t\tthis(atomA, atomB, bondOrder, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\r\n\t * between them.\r\n\t * \r\n\t * @param atomA\r\n\t *            one of the atoms in this bond\r\n\t * @param atomB\r\n\t *            the other atom in this bond\r\n\t * @param bondOrder\r\n\t *            the bond order of this bond\r\n\t * @param addSelfToAtoms\r\n\t *            if set to true, this bond, once created, will automatically\r\n\t *            add itself to atomA and atomB's bond lists. (If this argument\r\n\t *            is set to false, the list returned from\r\n\t *            {@link Atom#getBonds()} will not contain this bond.)\r\n\t */\r\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\r\n\t\tthis.atomA = atomA;\r\n\t\tthis.atomB = atomB;\r\n\t\tthis.bondOrder = bondOrder;\r\n\r\n\t\tif (addSelfToAtoms) {\r\n\t\t\taddSelfToAtoms();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\r\n\t * then the list returned from calling {@link Atom#getBonds()} will not\r\n\t * include this bond.\r\n\t * <p>\r\n\t * If you created your Bond with the constructor\r\n\t * {@link #Bond(Atom, Atom, int)}, this method has already been called for\r\n\t * you and should not be called again.\r\n\t */\r\n\t// TODO first check if those bonds haven't been made already\r\n\tpublic void addSelfToAtoms() {\r\n\t\tatomA.addBond(this);\r\n\t\tatomB.addBond(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomB()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomA() {\r\n\t\treturn atomA;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\r\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\r\n\t * which they are passed to this class's constructor.\r\n\t * \r\n\t * @see #getAtomA()\r\n\t * @return one of the two atoms in this bond\r\n\t */\r\n\tpublic Atom getAtomB() {\r\n\t\treturn atomB;\r\n\t}\r\n\r\n\t/**\r\n\t * A utility method to get the other atom in a bond, given one of its atoms.\r\n\t * If the atom passed is one of the atoms in this bond, then this method is\r\n\t * essentially equivalent to saying\r\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\r\n\t * <p>\r\n\t * <i>Note:</i> Comparison of atoms in this method is done with\r\n\t * <code>==</code>, not <code>equals</code>.\r\n\t * \r\n\t * @param exclude\r\n\t *            the atom of the bond to not return\r\n\t * @throws IllegalArgumentException\r\n\t *             if the passed atom is not in this bond\r\n\t * @return the atom in this bond that was not passed as an argument\r\n\t */\r\n\tpublic Atom getOther(Atom exclude) {\r\n\t\tif (exclude != atomA && exclude != atomB) {\r\n\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\r\n\t\t}\r\n\r\n\t\tif (exclude == atomA) {\r\n\t\t\treturn atomB;\r\n\t\t} else {\r\n\t\t\treturn atomA;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\r\n\t * single bond, '2' to a double bond, etc.\r\n\t * \r\n\t * @return this bond's bond order\r\n\t */\r\n\tpublic int getBondOrder() {\r\n\t\treturn bondOrder;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the distance between the two atoms of this bond.\r\n\t * <p>\r\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\r\n\t * this method will suppress the empty threat of a\r\n\t * {@link StructureException} that method makes.\r\n\t * \r\n\t * @return the distance between the two atoms of this bond.\r\n\t */\r\n\tpublic double getLength() {\r\n\r\n\t\treturn Calc.getDistance(atomA, atomB);\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\r\n\t\t\t\t+ bondOrder + \"]\";\r\n\t}\r\n}\r\n","originTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Before;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\n\t\tcache.setUseMmCif(false);\n\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\n\t\tStructureIO.setAtomCache(cache);\n\n\n\t}\n\n\tpublic void testIntraResidueBonds() throws StructureException, IOException {\n\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\n\n\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testPeptideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\n\tpublic void testLINKBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\t\n\t\tGroup g1 = s.getChainByPDB(\"A\").getSeqResGroup(50);\n\t\tassertNotNull(g1);\n\t\t\n\t\tassertTrue(g1 instanceof AminoAcid);\n\n\t\tAminoAcid aa = (AminoAcid)g1;\n\t\tassertTrue(aa.getRecordType().equals(AminoAcid.ATOMRECORD));\n\n\t\tAtom atom1 = g1.getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testDisulfideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testLigandBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","changedTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Before;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\n\t@Override\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\n\t\tcache.setUseMmCif(false);\n\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\n\t\tStructureIO.setAtomCache(cache);\n\n\n\t}\n\n\tpublic void testIntraResidueBonds() throws StructureException, IOException {\n\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\n\n\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void testPeptideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\n\tpublic void testLINKBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\t\n\t\tGroup g1 = s.getChainByPDB(\"A\").getSeqResGroup(50);\n\t\tassertNotNull(g1);\n\t\t\n\t\tassertTrue(g1 instanceof AminoAcid);\n\n\t\tAminoAcid aa = (AminoAcid)g1;\n\t\tassertTrue(aa.getRecordType().equals(AminoAcid.ATOMRECORD));\n\n\t\tAtom atom1 = g1.getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\tassertNotNull(atom1);\n\t\tassertNotNull(atom2);\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testDisulfideBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\n\tpublic void testLigandBonds() throws StructureException, IOException {\n\t\tif ( s == null) {\n\t\t\tsetUp();\n\t\t\ts = StructureIO.getStructure(\"1kh9\");\n\t\t}\n\t\tAtom phosphateP = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"P\");\n\t\tAtom phosphateO = s.getChainByPDB(\"A\").getAtomGroup(447).getAtom(\"O1\");\n\n\t\tassertTrue(areBonded(phosphateP, phosphateO));\n\t}\n\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/*\n\t * Each of the following PDB IDs used to make formBonds() crash.\n\t */\n\n\tpublic void test145D() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"145D\");\n\t}\n\n\tpublic void test1APJ() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1APJ\");\n\t}\n\n\tpublic void test1BDX() throws IOException, StructureException {\n\t\tStructureIO.getStructure(\"1BDX\");\n\t}\n}\n","commitMessage":"AtomImpl (serialized class) has member variable class Bond that is not\nserialized. Bond class serialized.","test_commitMessage":"Adding @Override and @Deprecated tags where applicable\n\nMost were added automatically using Eclipse ","allZero":false}