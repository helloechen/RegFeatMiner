{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/SecStruc.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestSecStruc.java","prod_time":"2015-09-23 00:05:10","test_time":"2015-09-23 00:05:10","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":1,"add_field_line":7,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":1,"del_field_line":7,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"POSITIVE","prod_commitID":"124f12c4c8bf8f68b8ac00cf43ee91bf1b3e81d7","test_commitID":"124f12c4c8bf8f68b8ac00cf43ee91bf1b3e81d7","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n * @since 1.5\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/** \n * Calculate and assign the secondary structure (SS) to the AminoAcid \n * Groups of a Structure object.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>. \n * Some parts are also taken from: T.E.Creighton, Proteins - \n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n * \n * @author Andreas Prlic\n * @author Aleix Lafita\n * \n */\npublic class SecStruc {\n\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(SecStruc.class);\n\n\t/** the minimal distance between two residues */\n\tpublic static double MINDIST = 0.5;\n\n\t/** the minimal distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static int CA_MIN_DIST = 9;\n\n\t/** Minimal H-bond energy in cal / mol */\n\tpublic static int HBONDLOWENERGY  = -9900   ;\n\n\t/** higher limit for H-bond energy */\n\tpublic static double HBONDHIGHENERGY = -500.0     ;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t * \t     f  *   q1 *   q2 * scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\n\tpublic static double Q = -27888.0;\n\t//public static double Q = ( -332 * 0.42 * 0.2 * 1000 ); // -27888.0\n\n\tprivate SecStrucGroup[] groups;\n\n\tList<DistEn> distVsEnergy;\n\tList<Ladder> ladders;\n\n\tpublic SecStruc(){\n\t\tdistVsEnergy = new ArrayList<DistEn>();\n\t\tladders = new ArrayList<Ladder>();\n\t}\n\n\t/** assigns the secondary structure to the groups in this Structure object\n\t * and set the results in the group properties.\n\t *\n\t * @param s\n\t */\n\tpublic void assign(Structure s)\n\t\t\tthrows StructureException {\n\n\t\tgroups = initGroupArray(s);\n\n\t\tif ( groups.length < 5) {\n\t\t\t// not enough groups to do anything\n\t\t\tthrow new StructureException(\"not enough groups in structure to calculate secondary structure (\"+ groups.length+\")\" );\n\t\t}\n\n\n\t\tcalculateHAtoms();\n\n\t\t/*for (int j=0 ; j<3;j++ ) {\n         Group g = groups[j];\n         System.out.println(g);\n         for (int i=0 ; i< g.size();i++){\n            Atom a = g.getAtom(i);\n            System.out.println(a);\n         }\n      }*/\n\n\t\tcalculateHBonds();\n\t\tcalculateTurns();\n\t\tcalculateDihedralAngles();\n\t\tbuildHelices();\n\n\t\tdetectBends();\n\t\tdetectStrands();\n\n\n\t}\n\n\tprivate void detectStrands() {\n\n\t\tfor (int i =1 ; i < groups.length -1 ;i++){\n\t\t\ttestBridge(i);\n\t\t}\n\n\t\t// detect beta bulges\n\t\tconnectLadders();\n\n\t\t// and store results for Sheets and Strands\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void updateSheets() {\n\t\tlogger.debug(\" got \"  +ladders.size() + \"  ladders!\");\n\t\tfor (Ladder ladder : ladders){\n\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\tlcount <= ladder.to;\n\t\t\t\t\tlcount++  ) {\n\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getSecStruc();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getSecStruc();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\tif ( ! stype.isHelixType())\n\t\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\n\t\t\t\t\tif ( ! stype2.isHelixType()){\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.extended);\n\t\t\t\t\t}\t\t\t    \t  \t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( ! stype.isHelixType() && \n\t\t\t\t\t\t\t( ! stype.equals(SecStrucType.extended))) {\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended))) {\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'  \n\n\t\t\tif ( ladder.connectedTo == 0) \n\t\t\t\tcontinue;\n\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif ( ladder.getBtype().equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate void testSetExtendedSecStrucState(int lcount) {\n\t\tSecStrucState state = getSecStrucState(lcount);\n\t\tSecStrucType stype = state.getSecStruc();\n\t\tif ( ! stype.isHelixType()){\n\t\t\tsetSecStrucType(lcount,SecStrucType.extended);\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor ( int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size() ; j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif ( hasBulge(l1,l2) ) {\n\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\t//\t\t\t\t\tSystem.out.println(\"BUlge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\t\tboolean bulge =  ( (l1.getBtype().equals(l2.getBtype()) ) &&\n\t\t\t\t( l2.from - l1.to < 6) &&\n\t\t\t\t( l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0) );\n\n\t\t//\t    \t\t ( ( ladder1->type == ladder2->type) &&\n\t\t//\t  \t       ( ladder2->from - ladder1->to < 6 ) &&\n\t\t//\t  \t       ( ladder1->to < ladder2->from) &&\n\t\t//\t  \t       ( ladder2->conto == 0 ) ) ;\n\n\t\tif ( ! bulge )\n\t\t\treturn bulge;\n\n\t\tif ( l1.getBtype().equals(BridgeType.parallel)) {\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\t\t\t//case parallel:\n\t\t\t//\t\t\t bulge = ( ( ladder2->lfrom - ladder1->lto > 0 ) &&\n\t\t\t//\t\t\t\t   ((( ladder2->lfrom - ladder1->lto < 6 ) &&\n\t\t\t//\t\t\t\t    ( ladder2->from  - ladder1->to  < 3 )) ||\n\t\t\t//\t\t\t\t   ( ladder2->lfrom - ladder1->lto < 3 )) );\n\t\t\t//\t\t\t break;\n\t\t} else {\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to <3  )) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3))\n\t\t\t\t\t);\n\t\t}\n\t\treturn bulge;\n\n\n\t\t//\t       case antiparallel:\n\t\t//\t\t bulge = ( ( ladder1->lfrom - ladder2->lto > 0 ) &&\n\t\t//\t\t\t   ((( ladder1->lfrom - ladder2->lto < 6 ) &&\n\t\t//\t\t\t     ( ladder2->from - ladder1->to  < 3 )) ||\n\t\t//\t\t\t    ( ladder1->lfrom - ladder2->lto < 3 ))   );\n\t\t//\t\t break;\n\t\t//\t       }\n\t\t//\t     }\n\n\t}\n\n\tprivate void registerBridge(int start, int end, BridgeType btype){\n\t\tif ( start > end)\n\t\t\treturn;\n\n\t\tboolean found = false;\n\t\tfor (Ladder ladder : ladders){\n\t\t\tif (shouldExtendLadder(ladder, start,end,btype)) {\n\t\t\t\t// extend laddder\n\t\t\t\tfound = true;\n\t\t\t\tladder.to++;\n\t\t\t\tif ( btype.equals(BridgeType.parallel)) {\n\t\t\t\t\tladder.lto++;\n\t\t\t\t} else {\n\t\t\t\t\tladder.lfrom--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t\tif ( ! found){\n\t\t\t// create new ladder!\n\t\t\tLadder l = new Ladder();\n\t\t\tl.setFrom(start);\n\t\t\tl.setTo(end);\n\t\t\tl.setBtype(btype);\n\t\t\tl.setLfrom(start);\n\t\t\tl.setLto(end);\n\t\t\tladders.add(l);\n\t\t}\n\n\t}\n\n\tprivate boolean shouldExtendLadder(Ladder ladder, int start, int end,\n\t\t\tBridgeType btype) {\n\n\t\treturn ( (btype.equals(ladder.getBtype()) ) &&\n\t\t\t\t( start  == ladder.getTo() +1) &&\n\t\t\t\t(\n\t\t\t\t\t\t(( end == ladder.getLto() + 1) &&\n\t\t\t\t\t\t\t\t( btype.equals(BridgeType.parallel) )) ||\n\t\t\t\t\t\t\t\t(( end == ladder.getLfrom() - 1 ) &&\n\t\t\t\t\t\t\t\t\t\t(btype.equals(BridgeType.parallel) ))\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t) );\n\t}\n\n\tprivate void testBridge(int i) {\n\n\t\tint currpos = i + 3;\n\t\tfor ( int foundNrBridges = 0 ; foundNrBridges < 2 && ( currpos < groups.length-1); currpos++){\n\n\n\n\t\t\tBridgeType btype = null;\n\n\t\t\tif ( (isBonded(i+1, currpos) && isBonded(currpos, i-1) ) ||\n\t\t\t\t\t( isBonded(currpos +1 , i) && isBonded(i, currpos-1)) ) {\n\t\t\t\t// parallel\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ( (isBonded(i, currpos) && isBonded(currpos, i)) ||\n\t\t\t\t\t(isBonded(i+1, currpos -1 ) && (isBonded(currpos + 1 , i - 1)))) {\n\t\t\t\t// antiparallel\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tfoundNrBridges++;\n\t\t\t\tregisterBridge(i, currpos, btype);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void detectBends() {\n\t\tif ( groups.length < 5)\n\t\t\treturn;\n\n\t\tfor (int i =2 ; i < groups.length -2 ;i++){\n\n\t\t\t/* Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i +2 ) */\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle    = Calc.angle(caminus2,caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i); \n\n\t\t\tstate.setKappa((float)angle);\n\n\t\t\tif (angle > 70.0) {\n\t\t\t\tif ( state.getSecStruc().equals(SecStrucType.coil)) \n\t\t\t\t\tstate.setSecStruc(SecStrucType.bend);\n\n\t\t\t\tstate.setBend(true);\n\t\t\t\t//d[i].bend = 'S';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles() throws StructureException {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState) a.getProperty(\"secstruc\");\n\t\t\tSecStrucState state2 = (SecStrucState) b.getProperty(\"secstruc\");\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\n\t\t}\n\n\t}\n\n\t/*\n\t *\n\t * (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     N-H-->O    O-->H-N    N-H-->O    O-->H-N    TCO  KAPPA ALPHA  PHI     PSI     Omega    X-CA   Y-CA   Z-CA \");\n\t\tbuf.append(nl);\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tGroup g = groups[i];\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\t\t\t//\tSystem.out.println(\"XX\"+i+\" \"+g.getResidueNumber().toString() + \" \" + g.getPDBName() + iter.getCurrentChain().getName() + \" \" + state);\n\t\t\tbuf.append(i + 1).append(\" \");\n\t\t\tbuf.append(g.getChainId()).append(\" \");\n\t\t\tbuf.append(g.getPDBName()).append(\" \");\n\t\t\tbuf.append(g.getResidueNumber().toString()).append(\"\\t\");\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tfor (int t=0;t<3;t++){\n\t\t\t\tif (turns[t]) {\n\t\t\t\t\tbuf.append('>');\n\t\t\t\t} else {\n\t\t\t\t\tbuf.append(' ');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// tmp filler\n\t\t\tbuf.append(state.getSecStruc().type);\n\t\t\tbuf.append(\" \");\n\t\t\tif ( state.isBend())\n\t\t\t\tbuf.append('S');\n\t\t\telse \n\t\t\t\tbuf.append(\" \");\n\t\t\tbuf.append(\"                 \");\n\n\t\t\tint p1 = state.getAccept1().getPartner();\n\t\t\tif ( p1 != 0)\n\t\t\t\tp1 -= i;\n\t\t\tdouble e1 =  (state.getAccept1().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p1,e1));\n\n\t\t\tint p2 = state.getDonor1().getPartner();\n\t\t\tif ( p2 != 0)\n\t\t\t\tp2 -= i;\n\t\t\tdouble e2 = (state.getDonor1().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p2,e2 ));\n\n\t\t\tint p3 = state.getAccept1().getPartner() ;\n\t\t\tif ( p3 != 0)\n\t\t\t\tp3 -= i;\n\t\t\tdouble e3 =  (state.getAccept2().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p3,e3));\n\n\t\t\tint p4 = state.getDonor2().getPartner();\n\t\t\tif ( p4 != 0)\n\t\t\t\tp4 -= i;\n\t\t\tdouble e4 = (state.getDonor2().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p4,e4 ));\n\n\t\t\tdouble kappa = state.getKappa();\n\n\t\t\tdouble phi = state.getPhi();\n\t\t\tdouble psi = state.getPsi();\n\t\t\tdouble omega = state.getOmega();\n\t\t\tbuf.append(\"        \");\n\t\t\tbuf.append(String.format(\"%6.1f\",kappa));\n\t\t\tbuf.append(\"       \");\n\n\t\t\tbuf.append(String.format(\"%6.1f %6.1f %6.1f\", phi,psi, omega));\n\n\t\t\tbuf.append(nl);\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t//GroupIterator iter = new GroupIterator(s);\n\t\tfor ( Chain c : s.getChains()){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\t\t\t\t//System.out.println(g);\n\t\t\t\t//\t\t\t we can also calc secstruc if hetatom is a modified amino acid.\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\t\t\t\t\t// create H in calc_H\n\n\n\n\n\t\t\t\t\tSecStrucState state = new SecStrucState();\n\t\t\t\t\tMap<String,Object> m = sg.getProperties();\n\t\t\t\t\tif ( m == null) {\n\t\t\t\t\t\tm = new HashMap<String, Object>();\n\t\t\t\t\t\tsg.setProperties(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tm.put(\"secstruc\",state);\n\n\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t} else {\n\t\t\t\t\t//System.out.println(\"not an amino group\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/** calculate the coordinates for the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location\n\t */\n\tprivate  void calculateHAtoms()\n\t\t\tthrows StructureException\n\t{\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( ! b.hasAtom(\"H\") ) {\n\n\t\t\t\t//System.out.println(cur);\n\t\t\t\t// calculate the coordinate for the H atom\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\n\t\t\t\t// alternative:\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(),b.getN());\n\n\t\t\t\tb.setH(H);\n\n\t\t\t\t/*System.out.println(\"added H for \" + i + \" \" + H);\n            for ( int aa = 0 ; aa < b.size() ; aa++){\n               Atom at = b.getAtom(aa);\n               System.out.println(aa + \" \" + at.getFullName() + \" \"+ Calc.getDistance(at,H));\n            }*/\n\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/** calculate the HBonds between different groups ...\n\t * see Creighton page 147 f\n\t *\n\t */\n\tprivate void calculateHBonds()\n\t\t\tthrows StructureException\n\t{\n\t\t//System.out.println(\"groups length: \" + groups.length);\n\n\t\tif ( groups.length < 5)\n\t\t\treturn;\n\n\t\t// skip the first residue , unable to calc H for it ...\n\t\tfor (int i=1 ; i < groups.length ;  i++){\n\n\t\t\tSecStrucGroup one = groups[i];\n\n\t\t\tif ( ! one.hasAtom(\"H\")) {\n\t\t\t\tSystem.out.println(\" no H at \" + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor ( int j = i+1 ; j < groups.length ; j++){\n\n\t\t\t\tSecStrucGroup two = groups[j];\n\n\t\t\t\t// check if distance is  too large.\n\t\t\t\t// if too big - for sure no HBonds ...\n\t\t\t\tdouble dist = Calc.getDistance(one.getCA(),two.getCA());\n\n\t\t\t\t// speed up...\n\t\t\t\tif ( dist >= CA_MIN_DIST  )\n\t\t\t\t\tcontinue;\n\t\t\t\t//System.out.println(\"calc \" + i + \" \" + j + \" \"+  dist);\n\n\t\t\t\tcheckAddHBond(i,j);\n\n\t\t\t\t// \"backwards\" hbonds are not allowed\n\t\t\t\tif ( j != (i+1) ) {\n\n\t\t\t\t\tcheckAddHBond(j,i);\n\n\t\t\t\t}\n\t\t\t\t//System.out.println(\" \");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"     ignore: PRO \" +     one.getResidueNumber().toString());\n\t\t\treturn ;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\t\tif ( ! two.hasAtom(\"H\")) {\n\t\t\tSystem.err.println(\"two has no H \" + j);\n\t\t\treturn;\n\t\t}\n\n\n\n\t\tdouble energy = 0;\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t\t//System.out.println(\" \" + energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/** calculate HBond energy of two groups in cal/mol ...\n\t * see Creighton page 147 f\n\t *\n\t * Jeffrey, George A., An introduction to hydrogen bonding, Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t *  Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t *\n\t */\n\tpublic  double calculateHBondEnergy(SecStrucGroup one, SecStrucGroup two )\n\t\t\tthrows StructureException{\n\n\t\t//System.out.println(\"calcHBondEnergy\" + one + \"|\" + two);\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber().toString() + \" \" + one.getPDBName() + \" \" +two.getResidueNumber().toString() + \" \" + two.getPDBName() +\n\t\t\t\t\tString.format(\" O (\"+O.getPDBserial()+\")..N (\"+ N.getPDBserial()+\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \" , dno,dho,dhc,dnc,dno));\n\n\t\t//logger.debug( cn > ch && oh < 3.0f);\n\n\t\tdouble contact = MINDIST ;\n\n\t\t//\t\t there seems to be a contact!\n\t\tif ( (dno < contact) || (dhc < contact) || (dnc < contact) || (dno < contact)) {\n\t\t\t//System.out.println(\"!!! contact \" + one + \" \" + two);\n\t\t\treturn HBONDLOWENERGY ;\n\t\t}\n\n\t\tdouble e1 = Q / dho  - Q / dhc ;\n\t\tdouble e2 = Q / dnc  - Q / dno ;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",N.getPDBserial(),O.getPDBserial(), (float)dno , energy));\n\n\t\t// bond too weak\n\t\t//if ( energy > HBONDHIGHENERGY)\n\t\t//\treturn energy;\n\n\t\t// test to avoid bond too strong\n\t\tif ( energy > HBONDLOWENERGY)\n\t\t\treturn energy;\n\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t * @throws StructureException ...\n\t */\n\tpublic static BigDecimal getPreciseDistance(Atom a, Atom b)\n\t\t\tthrows StructureException\n\t{\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\t\tBigSqrt sqrt = new BigSqrt();\n\t\tBigDecimal d = new BigDecimal(s);\n\t\tBigDecimal dist = sqrt.sqrt(d);\n\n\t\treturn dist ;\n\t}\n\n\t/** store Hbonds inamino acids\n\t * DSSP allows two HBonds / aminoacids to allow bifurcated bonds ...\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tGroup one = groups[i];\n\t\tGroup two = groups[j];\n\n\t\tif ( one.getPDBName().equals(\"PRO\"))\n\t\t\treturn;\n\n\t\tSecStrucState stateOne = (SecStrucState) one.getProperty(\"secstruc\");\n\t\tSecStrucState stateTwo = (SecStrucState) two.getProperty(\"secstruc\");\n\n\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\t//if ( energy < 0)\n\t\t//   System.out.println(\"--- tracking Hbond \" + i + \" \" + j + \" \" + energy + \" (accept: \" + acc1e + \" \" + acc2e +\") (donor: \"+don1e + \" \" + don2e+\")\");\n\n\t\tif (energy <  acc1e) {\n\t\t\t//System.out.println(energy +\"<\"+acc1e) ;\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\t//System.out.println(energy +\"<\"+acc2e) ;\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\t\t// and now the other side of the bond ..\n\n\n\t\tif (energy <  don1e) {\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\n\t\t\t//System.out.println(energy +\"<\"+don2e) ;\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\n\t\t}\n\n\t\t//System.out.println(stateOne);\n\t\t//one.setProperty(\"secstruc\", stateOne);\n\t\t//two.setProperty(\"secstruc\", stateTwo);\n\t\t/*groups[i] = one;\n      groups[j] = two;\n\t\t */\n\t}\n\n\t/** detect helical turn patterns\n\t *\n\t *\n\t */\n\tprivate void calculateTurns(){\n\n\t\tint l = groups.length;\n\t\tfor (int i = 0 ; i< l ; i++){\n\n\t\t\tfor ( int turn = 3; turn <= 5 ; turn++ ) {\n\t\t\t\tif (i+turn >= l)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( isBonded(i+turn, i)){\n\t\t\t\t\t//System.out.println(\"is bondend \" + (i+turn) + i );\n\t\t\t\t\tfor ( int j=i;j<i+turn+1;j++){\n\t\t\t\t\t\t//System.out.println(\"turn at i:\" + i + \" j:\" + j + \" turn\" + turn);\n\t\t\t\t\t\tSecStrucGroup group = groups[j];\n\t\t\t\t\t\tSecStrucState state = (SecStrucState) group.getProperty(\"secstruc\");\n\t\t\t\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\t\t\tturns[turn-3] = true;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** test if two groups are forming an H-Bond\n\t * DSSP defines H-Bonds if the energy < -500 cal /mol\n\t * @param one group one\n\t * @param two group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tGroup one = groups[i];\n\t\t//Group two = groups[j];\n\n\t\tSecStrucState stateOne = (SecStrucState)one.getProperty(\"secstruc\");\n\t\t//SecStrucState stateTwo = (SecStrucState)two.getProperty(\"secstruc\");\n\n\t\t//System.out.println(\"*** bonded? \" + i + \" \" + j + \" \" + stateOne);\n\t\tdouble acc1e    = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e    = stateOne.getAccept2().getEnergy();\n\n\t\tint partnerAcc1 = stateOne.getAccept1().getPartner();\n\t\tint partnerAcc2 = stateOne.getAccept2().getPartner();\n\n\t\tif (\n\t\t\t\t( ( partnerAcc1 == j ) && (acc1e < HBONDHIGHENERGY) )\n\t\t\t\t||\n\t\t\t\t( ( partnerAcc2 == j ) && (acc2e < HBONDHIGHENERGY) )\n\t\t\t\t) {\n\t\t\t//System.out.println(\"*** yes is bonded \" + i + \" \" + j);\n\t\t\treturn true ;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * see also:\n\t * @link{http://openbioinformatics.blogspot.com/2009/08/how-to-calculate-h-atoms-for-nitrogens.html}\n\t *\n\t *\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException\n\t{\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U     = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c,Atom o, Atom n) throws StructureException{\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tpublic SecStrucGroup[] getGroups(){\n\t\treturn groups;\n\t}\n\n\tprivate void buildHelices(){\n\n\n\n\t\t// check for minimum size\n\n\t\tif ( groups.length < 5 )\n\n\t\t\treturn;\n\n\n\n\n\t\t/** test if two groups are forming an H-Bond\n\n\t\t * DSSP defines H-Bonds if the energy < -500 cal /mol\n\n\t\t * @param one group one\n\n\t\t * @param two group two\n\n\t\t * @return flag if the two are forming an Hbond\n\n\t\t */\n\n\n\t\t// Alpha Helix (i+4)\n\n\n\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\n\t}\n\n\tprivate void checkSetTurns() {\n\t\tfor (int i =0 ; i < groups.length -3 ;i++){\n\n\t\t\tGroup g = groups[i];\n\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\n\t\t\tSecStrucType type = state.getSecStruc();\n\n\t\t\tif ( type.isHelixType() )\n\t\t\t\tcontinue;\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tfor ( int t = 0 ; t < 3 ; t ++){\n\t\t\t\tif ( turns[t])\n\t\t\t\t{\n\n\t\t\t\t\tfor ( int l = i+1 ; l < i+t+3; l++) {\n\t\t\t\t\t\t//System.out.println(\"turn: \" + i + \" \" + type);\n\t\t\t\t\t\tif ( l >= groups.length)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tSecStrucType typel =getSecStrucType(l);\n\t\t\t\t\t\tif ( typel.equals(SecStrucType.coil))\n\t\t\t\t\t\t\tsetSecStrucType(l, SecStrucType.turn);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkSetHelix( int prange,SecStrucType type){\n\n\t\tint range = prange - 3;\n\t\t//System.out.println(\"set helix \" + type + \" \" + prange + \" \" + range);\n\t\tfor (int i =1 ; i < groups.length -range -1 ;i++){\n\n\t\t\tGroup g = groups[i];\n\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\n\n\t\t\tGroup prevG = groups[i-1];\n\n\t\t\tSecStrucState prevState = (SecStrucState) prevG.getProperty(\"secstruc\");\n\n\t\t\tGroup nextG = groups[i+1];\n\n\t\t\tSecStrucState nextState = (SecStrucState) nextG.getProperty(\"secstruc\");\n\n\t\t\tboolean[] turns = state.getTurn();\n\n\t\t\tboolean[] pturns = prevState.getTurn();\n\n\t\t\tboolean[] nturns = nextState.getTurn();\n\n\t\t\t// DSSP sets helices one amino acid too short....\n\n\t\t\tif ( turns[range] && pturns[range] && nturns[range]) {\n\n\t\t\t\t//Check if no secstruc assigned\n\n\t\t\t\tboolean empty = true;\n\n\t\t\t\tfor ( int curr =i; curr <= i+range ;curr++){\n\t\t\t\t\t//System.out.println(\"   \" + i + \" range: \" + prange + \" \" + range);\n\t\t\t\t\tSecStrucType cstate = getSecStrucType(curr);\n\n\t\t\t\t\tif (cstate.isHelixType()){\n\n\t\t\t\t\t\tempty = false;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// none is assigned yet, set to helix type\n\n\t\t\t\tif ( empty ) {\n\n\t\t\t\t\tfor ( int curr =i; curr <= i+range ;curr++){\n\n\t\t\t\t\t\tsetSecStrucType(curr,type);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setSecStrucType(int pos, SecStrucType state){\n\n\t\tGroup g = groups[pos];\n\t\tSecStrucState s= (SecStrucState) g.getProperty(\"secstruc\");\n\t\ts.setSecStruc(state);\n\t}\n\n\tprivate SecStrucType getSecStrucType(int pos){\n\n\t\tSecStrucState s = getSecStrucState(pos);\n\t\treturn s.getSecStruc();\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\t\treturn state;\n\t}\n\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n * @since 1.5\n *\n */\npackage org.biojava.nbio.structure.secstruc;\n\nimport org.biojava.nbio.structure.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/** \n * Calculate and assign the secondary structure (SS) to the AminoAcid \n * Groups of a Structure object.\n * <p>\n * The rules for SS calculation are the ones defined by DSSP:\n * Kabsch,W. and Sander,C. (1983) Biopolymers 22, 2577-2637.\n * original DSSP article see at:\n * <a href=\"http://www.cmbi.kun.nl/gv/dssp/dssp.pdf\">dssp.pdf</a>. \n * Some parts are also taken from: T.E.Creighton, Proteins - \n * Structure and Molecular Properties, 2nd Edition, Freeman 1994.\n * \n * @author Andreas Prlic\n * @author Aleix Lafita\n * \n */\npublic class SecStruc {\n\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(SecStruc.class);\n\n\t/** the minimal distance between two residues */\n\tpublic static final double MINDIST = 0.5;\n\n\t/** the minimal distance of two CA atoms if H-bonds are allowed to form */\n\tpublic static final int CA_MIN_DIST = 9;\n\n\t/** Minimal H-bond energy in cal / mol */\n\tpublic static final int HBONDLOWENERGY  = -9900   ;\n\n\t/** higher limit for H-bond energy */\n\tpublic static final double HBONDHIGHENERGY = -500.0     ;\n\n\t/** constant for electrostatic energy\n\t * <pre>\n\t * \t     f  *   q1 *   q2 * scale\n\t * Q = -332 * 0.42 * 0.20 * 1000.0\n\t *</pre>\n\t *\n\t * q1 and q2 are partial charges which are placed on the C,O\n\t * (+q1,-q1) and N,H (-q2,+q2)\n\t */\n\tpublic static final double Q = -27888.0;\n\t//public static double Q = ( -332 * 0.42 * 0.2 * 1000 ); // -27888.0\n\n\tprivate SecStrucGroup[] groups;\n\tprivate List<DistEn> distVsEnergy;\n\tprivate List<Ladder> ladders;\n\n\tpublic SecStruc(){\n\t\tdistVsEnergy = new ArrayList<DistEn>();\n\t\tladders = new ArrayList<Ladder>();\n\t}\n\n\t/** \n\t * Assigns the secondary structure to the groups in this Structure object\n\t * and sets the results in the Group properties.\n\t *\n\t * @param s Structure to assign the SS\n\t */\n\tpublic void assign(Structure s)\n\t\t\tthrows StructureException {\n\n\t\tgroups = initGroupArray(s);\n\n\t\tif ( groups.length < 5) {\n\t\t\t// not enough groups to do anything\n\t\t\tthrow new StructureException(\"not enough groups in structure to calculate secondary structure (\"+ groups.length+\")\" );\n\t\t}\n\n\n\t\tcalculateHAtoms();\n\n\t\t/*for (int j=0 ; j<3;j++ ) {\n         Group g = groups[j];\n         System.out.println(g);\n         for (int i=0 ; i< g.size();i++){\n            Atom a = g.getAtom(i);\n            System.out.println(a);\n         }\n      }*/\n\n\t\tcalculateHBonds();\n\t\tcalculateTurns();\n\t\tcalculateDihedralAngles();\n\t\tbuildHelices();\n\n\t\tdetectBends();\n\t\tdetectStrands();\n\n\n\t}\n\n\tprivate void detectStrands() {\n\n\t\tfor (int i =1 ; i < groups.length -1 ;i++){\n\t\t\ttestBridge(i);\n\t\t}\n\n\t\t// detect beta bulges\n\t\tconnectLadders();\n\n\t\t// and store results for Sheets and Strands\n\t\tupdateSheets();\n\t}\n\n\n\tprivate void updateSheets() {\n\t\tlogger.debug(\" got \"  +ladders.size() + \"  ladders!\");\n\t\tfor (Ladder ladder : ladders){\n\n\t\t\tlogger.debug(ladder.toString());\n\n\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\tlcount <= ladder.to;\n\t\t\t\t\tlcount++  ) {\n\n\n\t\t\t\tSecStrucState state = getSecStrucState(lcount);\n\t\t\t\tSecStrucType stype = state.getSecStruc();\n\n\t\t\t\tint diff = ladder.from - lcount;\n\t\t\t\tint l2count = ladder.lfrom - diff ;\n\n\t\t\t\tSecStrucState state2 = getSecStrucState(l2count);\n\t\t\t\tSecStrucType stype2 = state2.getSecStruc();\n\n\t\t\t\tif ( ladder.from != ladder.to ) {\n\t\t\t\t\tif ( ! stype.isHelixType())\n\t\t\t\t\t\tsetSecStrucType(lcount, SecStrucType.extended);\n\n\t\t\t\t\tif ( ! stype2.isHelixType()){\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.extended);\n\t\t\t\t\t}\t\t\t    \t  \t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( ! stype.isHelixType() && \n\t\t\t\t\t\t\t( ! stype.equals(SecStrucType.extended))) {\n\t\t\t\t\t\tsetSecStrucType(lcount,SecStrucType.bridge);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! stype2.isHelixType() &&\n\t\t\t\t\t\t\t(! stype2.equals(SecStrucType.extended))) {\n\t\t\t\t\t\tsetSecStrucType(l2count,SecStrucType.bridge);\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if two ladders are connected. both sides are 'E'  \n\n\t\t\tif ( ladder.connectedTo == 0) \n\t\t\t\tcontinue;\n\n\t\t\tLadder conladder = ladders.get(ladder.connectedTo);\n\n\t\t\tif ( ladder.getBtype().equals(BridgeType.antiparallel)) {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor (int lcount = conladder.lto;\n\t\t\t\t\t\tlcount <= ladder.lfrom;\n\t\t\t\t\t\tlcount++) {\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t/* set one side */\n\t\t\t\tfor ( int lcount = ladder.from;\n\t\t\t\t\t\tlcount <= conladder.to;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\t\t\t\t/* set other side */\n\t\t\t\tfor ( int lcount =  ladder.lfrom;\n\t\t\t\t\t\tlcount <= conladder.lto;\n\t\t\t\t\t\tlcount++) {\n\n\t\t\t\t\ttestSetExtendedSecStrucState(lcount);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tprivate void testSetExtendedSecStrucState(int lcount) {\n\t\tSecStrucState state = getSecStrucState(lcount);\n\t\tSecStrucType stype = state.getSecStruc();\n\t\tif ( ! stype.isHelixType()){\n\t\t\tsetSecStrucType(lcount,SecStrucType.extended);\n\t\t}\n\t}\n\n\tprivate void connectLadders() {\n\n\t\tfor ( int i = 0 ; i < ladders.size(); i++) {\n\t\t\tfor ( int j = i ; j < ladders.size() ; j++){\n\t\t\t\tLadder l1 = ladders.get(i);\n\t\t\t\tLadder l2 = ladders.get(j);\n\t\t\t\tif ( hasBulge(l1,l2) ) {\n\n\t\t\t\t\tl1.connectedTo = j;\n\t\t\t\t\tl2.connectedFrom = i;\n\t\t\t\t\t//\t\t\t\t\tSystem.out.println(\"BUlge from \" + i + \" to \" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprivate boolean hasBulge(Ladder l1, Ladder l2) {\n\t\tboolean bulge =  ( (l1.getBtype().equals(l2.getBtype()) ) &&\n\t\t\t\t( l2.from - l1.to < 6) &&\n\t\t\t\t( l1.to < l2.from) &&\n\t\t\t\t(l2.connectedTo == 0) );\n\n\t\t//\t    \t\t ( ( ladder1->type == ladder2->type) &&\n\t\t//\t  \t       ( ladder2->from - ladder1->to < 6 ) &&\n\t\t//\t  \t       ( ladder1->to < ladder2->from) &&\n\t\t//\t  \t       ( ladder2->conto == 0 ) ) ;\n\n\t\tif ( ! bulge )\n\t\t\treturn bulge;\n\n\t\tif ( l1.getBtype().equals(BridgeType.parallel)) {\n\t\t\tbulge = ( (l2.lfrom - l1.lto > 0) &&\n\t\t\t\t\t((( l2.lfrom -l1.lto < 6) &&\n\t\t\t\t\t\t\t(l2.from - l1.to < 3)) ||\n\t\t\t\t\t\t\t( l2.lfrom - l1.lto <3)));\n\t\t\t//case parallel:\n\t\t\t//\t\t\t bulge = ( ( ladder2->lfrom - ladder1->lto > 0 ) &&\n\t\t\t//\t\t\t\t   ((( ladder2->lfrom - ladder1->lto < 6 ) &&\n\t\t\t//\t\t\t\t    ( ladder2->from  - ladder1->to  < 3 )) ||\n\t\t\t//\t\t\t\t   ( ladder2->lfrom - ladder1->lto < 3 )) );\n\t\t\t//\t\t\t break;\n\t\t} else {\n\t\t\tbulge = ( (l1.lfrom - l2.lto > 0) &&\n\t\t\t\t\t(((l1.lfrom -l2.lto < 6) &&\n\t\t\t\t\t\t\t( l2.from - l1.to <3  )) ||\n\t\t\t\t\t\t\t(l1.lfrom - l2.lto < 3))\n\t\t\t\t\t);\n\t\t}\n\t\treturn bulge;\n\n\n\t\t//\t       case antiparallel:\n\t\t//\t\t bulge = ( ( ladder1->lfrom - ladder2->lto > 0 ) &&\n\t\t//\t\t\t   ((( ladder1->lfrom - ladder2->lto < 6 ) &&\n\t\t//\t\t\t     ( ladder2->from - ladder1->to  < 3 )) ||\n\t\t//\t\t\t    ( ladder1->lfrom - ladder2->lto < 3 ))   );\n\t\t//\t\t break;\n\t\t//\t       }\n\t\t//\t     }\n\n\t}\n\n\tprivate void registerBridge(int start, int end, BridgeType btype){\n\t\tif ( start > end)\n\t\t\treturn;\n\n\t\tboolean found = false;\n\t\tfor (Ladder ladder : ladders){\n\t\t\tif (shouldExtendLadder(ladder, start,end,btype)) {\n\t\t\t\t// extend laddder\n\t\t\t\tfound = true;\n\t\t\t\tladder.to++;\n\t\t\t\tif ( btype.equals(BridgeType.parallel)) {\n\t\t\t\t\tladder.lto++;\n\t\t\t\t} else {\n\t\t\t\t\tladder.lfrom--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t\tif ( ! found){\n\t\t\t// create new ladder!\n\t\t\tLadder l = new Ladder();\n\t\t\tl.setFrom(start);\n\t\t\tl.setTo(end);\n\t\t\tl.setBtype(btype);\n\t\t\tl.setLfrom(start);\n\t\t\tl.setLto(end);\n\t\t\tladders.add(l);\n\t\t}\n\n\t}\n\n\tprivate boolean shouldExtendLadder(Ladder ladder, int start, int end,\n\t\t\tBridgeType btype) {\n\n\t\treturn ( (btype.equals(ladder.getBtype()) ) &&\n\t\t\t\t( start  == ladder.getTo() +1) &&\n\t\t\t\t(\n\t\t\t\t\t\t(( end == ladder.getLto() + 1) &&\n\t\t\t\t\t\t\t\t( btype.equals(BridgeType.parallel) )) ||\n\t\t\t\t\t\t\t\t(( end == ladder.getLfrom() - 1 ) &&\n\t\t\t\t\t\t\t\t\t\t(btype.equals(BridgeType.parallel) ))\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t) );\n\t}\n\n\tprivate void testBridge(int i) {\n\n\t\tint currpos = i + 3;\n\t\tfor ( int foundNrBridges = 0 ; foundNrBridges < 2 && ( currpos < groups.length-1); currpos++){\n\n\n\n\t\t\tBridgeType btype = null;\n\n\t\t\tif ( (isBonded(i+1, currpos) && isBonded(currpos, i-1) ) ||\n\t\t\t\t\t( isBonded(currpos +1 , i) && isBonded(i, currpos-1)) ) {\n\t\t\t\t// parallel\n\t\t\t\tbtype = BridgeType.parallel;\n\t\t\t}\n\t\t\telse if ( (isBonded(i, currpos) && isBonded(currpos, i)) ||\n\t\t\t\t\t(isBonded(i+1, currpos -1 ) && (isBonded(currpos + 1 , i - 1)))) {\n\t\t\t\t// antiparallel\n\t\t\t\tbtype = BridgeType.antiparallel;\n\t\t\t}\n\t\t\tif (btype != null){\n\t\t\t\tfoundNrBridges++;\n\t\t\t\tregisterBridge(i, currpos, btype);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate void detectBends() {\n\t\tif ( groups.length < 5)\n\t\t\treturn;\n\n\t\tfor (int i =2 ; i < groups.length -2 ;i++){\n\n\t\t\t/* Create vectors ( Ca i to Ca i-2 ) ; ( Ca i to CA i +2 ) */\n\n\t\t\tSecStrucGroup im2 = groups[i-2];\n\t\t\tSecStrucGroup g = groups[i];\n\t\t\tSecStrucGroup ip2 = groups[i+2];\n\n\n\t\t\tAtom caim2 = im2.getCA();\n\t\t\tAtom cag   = g.getCA();\n\t\t\tAtom caip2 = ip2.getCA();\n\n\t\t\tAtom caminus2 = Calc.subtract(caim2,cag);\n\n\t\t\tAtom caplus2  = Calc.subtract(cag,caip2);\n\n\t\t\tdouble angle    = Calc.angle(caminus2,caplus2);\n\n\t\t\tSecStrucState state = getSecStrucState(i); \n\n\t\t\tstate.setKappa((float)angle);\n\n\t\t\tif (angle > 70.0) {\n\t\t\t\tif ( state.getSecStruc().equals(SecStrucType.coil)) \n\t\t\t\t\tstate.setSecStruc(SecStrucType.bend);\n\n\t\t\t\tstate.setBend(true);\n\t\t\t\t//d[i].bend = 'S';\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void calculateDihedralAngles() throws StructureException {\n\n\t\t// dihedral angles\n\t\t// phi: C-N-CA-C\n\t\t// psi: N-CA-C-N\n\t\t// Chi1: N-CA-CB-CG, N-CA-CB-OG(SER),N-CA-CB-OG1(Thr),\n\t\t// N-CA-CB-CG1(ILE/VAL), N-CA-CB-SG(CYS)\n\t\t// Omega: CA-C-N-CA\n\n\t\tfor (int i=0 ; i < groups.length-1 ;  i++){\n\n\t\t\tSecStrucGroup a = groups[i];\n\n\t\t\tSecStrucGroup b = groups[i+1];\n\n\n\t\t\tAtom a_N   = a.getN();\n\t\t\tAtom a_CA  = a.getCA();\n\t\t\tAtom a_C  = a.getC();\n\n\t\t\tAtom b_N  = b.getN();\n\t\t\tAtom b_CA = b.getCA();\n\t\t\tAtom b_C  = b.getC();\n\n\t\t\tdouble phi = Calc.torsionAngle(a_C,b_N,b_CA,b_C);\n\n\t\t\tdouble psi = Calc.torsionAngle(a_N,a_CA,a_C,b_N);\n\n\t\t\tdouble omega = Calc.torsionAngle(a_CA,a_C,b_N,b_CA);\n\n\t\t\tSecStrucState state1 = (SecStrucState) a.getProperty(\"secstruc\");\n\t\t\tSecStrucState state2 = (SecStrucState) b.getProperty(\"secstruc\");\n\t\t\tstate2.setPhi(phi);\n\t\t\tstate1.setPsi(psi);\n\t\t\tstate1.setOmega(omega);\n\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\tbuf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     N-H-->O    O-->H-N    N-H-->O    O-->H-N    TCO  KAPPA ALPHA  PHI     PSI     Omega    X-CA   Y-CA   Z-CA \");\n\t\tbuf.append(nl);\n\n\t\tfor (int i =0 ; i < groups.length ;i++){\n\t\t\tGroup g = groups[i];\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\t\t\t//\tSystem.out.println(\"XX\"+i+\" \"+g.getResidueNumber().toString() + \" \" + g.getPDBName() + iter.getCurrentChain().getName() + \" \" + state);\n\t\t\tbuf.append(i + 1).append(\" \");\n\t\t\tbuf.append(g.getChainId()).append(\" \");\n\t\t\tbuf.append(g.getPDBName()).append(\" \");\n\t\t\tbuf.append(g.getResidueNumber().toString()).append(\"\\t\");\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tfor (int t=0;t<3;t++){\n\t\t\t\tif (turns[t]) {\n\t\t\t\t\tbuf.append('>');\n\t\t\t\t} else {\n\t\t\t\t\tbuf.append(' ');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// tmp filler\n\t\t\tbuf.append(state.getSecStruc().type);\n\t\t\tbuf.append(\" \");\n\t\t\tif ( state.isBend())\n\t\t\t\tbuf.append('S');\n\t\t\telse \n\t\t\t\tbuf.append(\" \");\n\t\t\tbuf.append(\"                 \");\n\n\t\t\tint p1 = state.getAccept1().getPartner();\n\t\t\tif ( p1 != 0)\n\t\t\t\tp1 -= i;\n\t\t\tdouble e1 =  (state.getAccept1().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p1,e1));\n\n\t\t\tint p2 = state.getDonor1().getPartner();\n\t\t\tif ( p2 != 0)\n\t\t\t\tp2 -= i;\n\t\t\tdouble e2 = (state.getDonor1().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p2,e2 ));\n\n\t\t\tint p3 = state.getAccept1().getPartner() ;\n\t\t\tif ( p3 != 0)\n\t\t\t\tp3 -= i;\n\t\t\tdouble e3 =  (state.getAccept2().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p3,e3));\n\n\t\t\tint p4 = state.getDonor2().getPartner();\n\t\t\tif ( p4 != 0)\n\t\t\t\tp4 -= i;\n\t\t\tdouble e4 = (state.getDonor2().getEnergy() / 1000.0);\n\t\t\tbuf.append(String.format( \"%6d,%4.1f\",p4,e4 ));\n\n\t\t\tdouble kappa = state.getKappa();\n\n\t\t\tdouble phi = state.getPhi();\n\t\t\tdouble psi = state.getPsi();\n\t\t\tdouble omega = state.getOmega();\n\t\t\tbuf.append(\"        \");\n\t\t\tbuf.append(String.format(\"%6.1f\",kappa));\n\t\t\tbuf.append(\"       \");\n\n\t\t\tbuf.append(String.format(\"%6.1f %6.1f %6.1f\", phi,psi, omega));\n\n\t\t\tbuf.append(nl);\n\t\t}\n\n\t\treturn buf.toString();\n\t}\n\n\tprivate static SecStrucGroup[] initGroupArray(Structure s) {\n\t\tList<SecStrucGroup> groupList = new ArrayList<SecStrucGroup>();\n\t\t//GroupIterator iter = new GroupIterator(s);\n\t\tfor ( Chain c : s.getChains()){\n\n\t\t\tfor (Group g : c.getAtomGroups()){\n\t\t\t\t//System.out.println(g);\n\t\t\t\t//\t\t\t we can also calc secstruc if hetatom is a modified amino acid.\n\t\t\t\tif ( g.hasAminoAtoms()) {\n\n\t\t\t\t\tSecStrucGroup sg = new SecStrucGroup();\n\t\t\t\t\tsg.setResidueNumber(g.getResidueNumber());\n\t\t\t\t\tsg.setPDBFlag(true);\n\t\t\t\t\tsg.setPDBName(g.getPDBName());\n\t\t\t\t\tsg.setChain(g.getChain());\n\n\n\t\t\t\t\tAtom N = g.getAtom(StructureTools.N_ATOM_NAME);\n\t\t\t\t\tAtom CA =  g.getAtom(StructureTools.CA_ATOM_NAME);\n\t\t\t\t\tAtom C = g.getAtom(StructureTools.C_ATOM_NAME);\n\t\t\t\t\tAtom O =  g.getAtom(StructureTools.O_ATOM_NAME);\n\t\t\t\t\tif ( N == null || CA == null || C == null || O == null)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tsg.setN((Atom)   N.clone());\n\t\t\t\t\tsg.setCA((Atom) CA.clone());\n\t\t\t\t\tsg.setC((Atom)   C.clone());\n\t\t\t\t\tsg.setO((Atom)  O.clone());\n\t\t\t\t\tsg.setOriginal(g);\n\t\t\t\t\t// create H in calc_H\n\n\n\n\n\t\t\t\t\tSecStrucState state = new SecStrucState();\n\t\t\t\t\tMap<String,Object> m = sg.getProperties();\n\t\t\t\t\tif ( m == null) {\n\t\t\t\t\t\tm = new HashMap<String, Object>();\n\t\t\t\t\t\tsg.setProperties(m);\n\t\t\t\t\t}\n\n\t\t\t\t\tm.put(\"secstruc\",state);\n\n\n\t\t\t\t\tgroupList.add(sg);\n\t\t\t\t} else {\n\t\t\t\t\t//System.out.println(\"not an amino group\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn groupList.toArray(new SecStrucGroup[groupList.size()]);\n\t}\n\n\t/** calculate the coordinates for the H atoms. They are usually\n\t * missing in the PDB files as only few experimental methods allow\n\t * to resolve their location\n\t */\n\tprivate  void calculateHAtoms()\n\t\t\tthrows StructureException\n\t{\n\n\t\tfor ( int i = 0 ; i < groups.length-1  ; i++) {\n\n\t\t\tSecStrucGroup a  = groups[i];\n\t\t\tSecStrucGroup b  = groups[i+1];\n\n\t\t\tif ( ! b.hasAtom(\"H\") ) {\n\n\t\t\t\t//System.out.println(cur);\n\t\t\t\t// calculate the coordinate for the H atom\n\t\t\t\t//Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n\n\t\t\t\t// alternative:\n\t\t\t\tAtom H = calcSimple_H(a.getC(), a.getO(),b.getN());\n\n\t\t\t\tb.setH(H);\n\n\t\t\t\t/*System.out.println(\"added H for \" + i + \" \" + H);\n            for ( int aa = 0 ; aa < b.size() ; aa++){\n               Atom at = b.getAtom(aa);\n               System.out.println(aa + \" \" + at.getFullName() + \" \"+ Calc.getDistance(at,H));\n            }*/\n\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/** calculate the HBonds between different groups ...\n\t * see Creighton page 147 f\n\t *\n\t */\n\tprivate void calculateHBonds()\n\t\t\tthrows StructureException\n\t{\n\t\t//System.out.println(\"groups length: \" + groups.length);\n\n\t\tif ( groups.length < 5)\n\t\t\treturn;\n\n\t\t// skip the first residue , unable to calc H for it ...\n\t\tfor (int i=1 ; i < groups.length ;  i++){\n\n\t\t\tSecStrucGroup one = groups[i];\n\n\t\t\tif ( ! one.hasAtom(\"H\")) {\n\t\t\t\tSystem.out.println(\" no H at \" + i);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor ( int j = i+1 ; j < groups.length ; j++){\n\n\t\t\t\tSecStrucGroup two = groups[j];\n\n\t\t\t\t// check if distance is  too large.\n\t\t\t\t// if too big - for sure no HBonds ...\n\t\t\t\tdouble dist = Calc.getDistance(one.getCA(),two.getCA());\n\n\t\t\t\t// speed up...\n\t\t\t\tif ( dist >= CA_MIN_DIST  )\n\t\t\t\t\tcontinue;\n\t\t\t\t//System.out.println(\"calc \" + i + \" \" + j + \" \"+  dist);\n\n\t\t\t\tcheckAddHBond(i,j);\n\n\t\t\t\t// \"backwards\" hbonds are not allowed\n\t\t\t\tif ( j != (i+1) ) {\n\n\t\t\t\t\tcheckAddHBond(j,i);\n\n\t\t\t\t}\n\t\t\t\t//System.out.println(\" \");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkAddHBond(int i, int j){\n\t\tSecStrucGroup one = groups[i];\n\n\t\tif (one.getPDBName().equals(\"PRO\")){\n\t\t\tlogger.debug(\"     ignore: PRO \" +     one.getResidueNumber().toString());\n\t\t\treturn ;\n\t\t}\n\n\t\tSecStrucGroup two = groups[j];\n\t\tif ( ! two.hasAtom(\"H\")) {\n\t\t\tSystem.err.println(\"two has no H \" + j);\n\t\t\treturn;\n\t\t}\n\n\n\n\t\tdouble energy = 0;\n\t\ttry {\n\t\t\tenergy = calculateHBondEnergy(one,two);\n\t\t} catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t\t//System.out.println(\" \" + energy);\n\n\t\ttrackHBondEnergy(i,j,energy);\n\t}\n\n\t/** calculate HBond energy of two groups in cal/mol ...\n\t * see Creighton page 147 f\n\t *\n\t * Jeffrey, George A., An introduction to hydrogen bonding, Oxford University Press, 1997.\n\t * categorizes hbonds with donor-acceptor distances of\n\t * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n\t * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n\t * 3.2-4.0 &aring; as \"weak, electrostatic\".\n\t *  Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n\t *\n\t */\n\tpublic  double calculateHBondEnergy(SecStrucGroup one, SecStrucGroup two )\n\t\t\tthrows StructureException{\n\n\t\t//System.out.println(\"calcHBondEnergy\" + one + \"|\" + two);\n\n\t\tAtom N = one.getN();\n\t\tAtom H = one.getH();\n\n\t\tAtom O = two.getO();\n\t\tAtom C = two.getC();\n\n\t\tdouble dno = Calc.getDistance(O,N);\n\t\tdouble dhc = Calc.getDistance(C,H);\n\t\tdouble dho = Calc.getDistance(O,H);\n\t\tdouble dnc = Calc.getDistance(C,N);\n\n\t\tlogger.debug(\"     cccc: \" + one.getResidueNumber().toString() + \" \" + one.getPDBName() + \" \" +two.getResidueNumber().toString() + \" \" + two.getPDBName() +\n\t\t\t\t\tString.format(\" O (\"+O.getPDBserial()+\")..N (\"+ N.getPDBserial()+\"):%4.1f  |  ho:%4.1f - hc:%4.1f + nc:%4.1f - no:%4.1f \" , dno,dho,dhc,dnc,dno));\n\n\t\t//logger.debug( cn > ch && oh < 3.0f);\n\n\t\tdouble contact = MINDIST ;\n\n\t\t//\t\t there seems to be a contact!\n\t\tif ( (dno < contact) || (dhc < contact) || (dnc < contact) || (dno < contact)) {\n\t\t\t//System.out.println(\"!!! contact \" + one + \" \" + two);\n\t\t\treturn HBONDLOWENERGY ;\n\t\t}\n\n\t\tdouble e1 = Q / dho  - Q / dhc ;\n\t\tdouble e2 = Q / dnc  - Q / dno ;\n\n\t\tdouble energy = e1 + e2;\n\n\t\tlogger.debug(String.format(\"      N (%d) O(%d): %4.1f : %4.2f \",N.getPDBserial(),O.getPDBserial(), (float)dno , energy));\n\n\t\t// bond too weak\n\t\t//if ( energy > HBONDHIGHENERGY)\n\t\t//\treturn energy;\n\n\t\t// test to avoid bond too strong\n\t\tif ( energy > HBONDLOWENERGY)\n\t\t\treturn energy;\n\n\n\t\treturn HBONDLOWENERGY ;\n\t}\n\n\t/**\n\t * calculate distance between two atoms.\n\t *\n\t * @param a  an Atom object\n\t * @param b  an Atom object\n\t * @return a double\n\t * @throws StructureException ...\n\t */\n\tpublic static BigDecimal getPreciseDistance(Atom a, Atom b)\n\t\t\tthrows StructureException\n\t{\n\t\tdouble x = a.getX() - b.getX();\n\t\tdouble y = a.getY() - b.getY();\n\t\tdouble z = a.getZ() - b.getZ();\n\n\t\tdouble s  = x * x  + y * y + z * z;\n\t\tBigSqrt sqrt = new BigSqrt();\n\t\tBigDecimal d = new BigDecimal(s);\n\t\tBigDecimal dist = sqrt.sqrt(d);\n\n\t\treturn dist ;\n\t}\n\n\t/** store Hbonds inamino acids\n\t * DSSP allows two HBonds / aminoacids to allow bifurcated bonds ...\n\t */\n\tprivate  void trackHBondEnergy(int i, int j, double energy) {\n\n\t\tGroup one = groups[i];\n\t\tGroup two = groups[j];\n\n\t\tif ( one.getPDBName().equals(\"PRO\"))\n\t\t\treturn;\n\n\t\tSecStrucState stateOne = (SecStrucState) one.getProperty(\"secstruc\");\n\t\tSecStrucState stateTwo = (SecStrucState) two.getProperty(\"secstruc\");\n\n\n\n\t\tdouble acc1e = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e = stateOne.getAccept2().getEnergy();\n\n\t\tdouble don1e = stateTwo.getDonor1().getEnergy();\n\t\tdouble don2e = stateTwo.getDonor2().getEnergy();\n\n\t\t//if ( energy < 0)\n\t\t//   System.out.println(\"--- tracking Hbond \" + i + \" \" + j + \" \" + energy + \" (accept: \" + acc1e + \" \" + acc2e +\") (donor: \"+don1e + \" \" + don2e+\")\");\n\n\t\tif (energy <  acc1e) {\n\t\t\t//System.out.println(energy +\"<\"+acc1e) ;\n\t\t\tstateOne.setAccept2(stateOne.getAccept1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept1(bond);\n\n\t\t} else if ( energy < acc2e ) {\n\t\t\t//System.out.println(energy +\"<\"+acc2e) ;\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(j);\n\n\t\t\tstateOne.setAccept2(bond);\n\t\t}\n\n\t\t// and now the other side of the bond ..\n\n\n\t\tif (energy <  don1e) {\n\t\t\tstateTwo.setDonor2(stateTwo.getDonor1());\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor1(bond);\n\n\t\t} else if ( energy < don2e ) {\n\n\t\t\t//System.out.println(energy +\"<\"+don2e) ;\n\n\t\t\tHBond bond = new HBond();\n\t\t\tbond.setEnergy(energy);\n\t\t\tbond.setPartner(i);\n\n\t\t\tstateTwo.setDonor2(bond);\n\n\t\t}\n\n\t\t//System.out.println(stateOne);\n\t\t//one.setProperty(\"secstruc\", stateOne);\n\t\t//two.setProperty(\"secstruc\", stateTwo);\n\t\t/*groups[i] = one;\n      groups[j] = two;\n\t\t */\n\t}\n\n\t/** detect helical turn patterns\n\t *\n\t *\n\t */\n\tprivate void calculateTurns(){\n\n\t\tint l = groups.length;\n\t\tfor (int i = 0 ; i< l ; i++){\n\n\t\t\tfor ( int turn = 3; turn <= 5 ; turn++ ) {\n\t\t\t\tif (i+turn >= l)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( isBonded(i+turn, i)){\n\t\t\t\t\t//System.out.println(\"is bondend \" + (i+turn) + i );\n\t\t\t\t\tfor ( int j=i;j<i+turn+1;j++){\n\t\t\t\t\t\t//System.out.println(\"turn at i:\" + i + \" j:\" + j + \" turn\" + turn);\n\t\t\t\t\t\tSecStrucGroup group = groups[j];\n\t\t\t\t\t\tSecStrucState state = (SecStrucState) group.getProperty(\"secstruc\");\n\t\t\t\t\t\tboolean[] turns = state.getTurn();\n\t\t\t\t\t\tturns[turn-3] = true;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** test if two groups are forming an H-Bond\n\t * DSSP defines H-Bonds if the energy < -500 cal /mol\n\t * @param one group one\n\t * @param two group two\n\t * @return flag if the two are forming an Hbond\n\t */\n\n\tprivate boolean isBonded(int i, int j) {\n\n\t\tGroup one = groups[i];\n\t\t//Group two = groups[j];\n\n\t\tSecStrucState stateOne = (SecStrucState)one.getProperty(\"secstruc\");\n\t\t//SecStrucState stateTwo = (SecStrucState)two.getProperty(\"secstruc\");\n\n\t\t//System.out.println(\"*** bonded? \" + i + \" \" + j + \" \" + stateOne);\n\t\tdouble acc1e    = stateOne.getAccept1().getEnergy();\n\t\tdouble acc2e    = stateOne.getAccept2().getEnergy();\n\n\t\tint partnerAcc1 = stateOne.getAccept1().getPartner();\n\t\tint partnerAcc2 = stateOne.getAccept2().getPartner();\n\n\t\tif (\n\t\t\t\t( ( partnerAcc1 == j ) && (acc1e < HBONDHIGHENERGY) )\n\t\t\t\t||\n\t\t\t\t( ( partnerAcc2 == j ) && (acc2e < HBONDHIGHENERGY) )\n\t\t\t\t) {\n\t\t\t//System.out.println(\"*** yes is bonded \" + i + \" \" + j);\n\t\t\treturn true ;\n\t\t}\n\t\treturn false ;\n\t}\n\n\t/**\n\t * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n\t * substract it from N.\n\t * C coordinates are from amino acid i-1\n\t * N, CA atoms from amino acid i\n\t *\n\t * see also:\n\t * @link{http://openbioinformatics.blogspot.com/2009/08/how-to-calculate-h-atoms-for-nitrogens.html}\n\t *\n\t *\n\t */\n\t@SuppressWarnings(\"unused\")\n\tprivate static Atom calc_H(Atom C, Atom N, Atom CA)\n\t\t\tthrows StructureException\n\t{\n\n\t\tAtom nc  = Calc.subtract(N,C);\n\t\tAtom nca = Calc.subtract(N,CA);\n\n\t\tAtom u_nc  = Calc.unitVector(nc)   ;\n\t\tAtom u_nca = Calc.unitVector(nca);\n\n\t\tAtom added = Calc.add(u_nc,u_nca);\n\n\t\tAtom U     = Calc.unitVector(added);\n\n\t\t// according to Creighton distance N-H is 1.03 +/- 0.02A\n\t\tAtom H = Calc.add(N,U);\n\n\t\tH.setName(\"H\");\n\t\t// this atom does not have a pdbserial number ...\n\t\treturn H;\n\n\t}\n\n\tprivate static Atom calcSimple_H(Atom c,Atom o, Atom n) throws StructureException{\n\n\t\tAtom h = Calc.subtract(c,o);\n\t\tdouble dist = Calc.getDistance(o,c);\n\t\t//System.out.println(dist);\n\t\tdouble x = n.getX() + h.getX() / dist;\n\t\tdouble y = n.getY() + h.getY() / dist;\n\t\tdouble z = n.getZ() + h.getZ() / dist;\n\n\t\th.setX(x);\n\t\th.setY(y);\n\t\th.setZ(z);\n\n\t\th.setName(\"H\");\n\t\treturn h;\n\t}\n\n\tpublic SecStrucGroup[] getGroups(){\n\t\treturn groups;\n\t}\n\n\tprivate void buildHelices(){\n\n\t\t// check for minimum size\n\t\tif ( groups.length < 5 ) return;\n\n\t\t/** test if two groups are forming an H-Bond\n\n\t\t * DSSP defines H-Bonds if the energy < -500 cal /mol\n\n\t\t * @param one group one\n\n\t\t * @param two group two\n\n\t\t * @return flag if the two are forming an Hbond\n\n\t\t */\n\n\t\t// Alpha Helix (i+4)\n\t\tcheckSetHelix(4, SecStrucType.helix4);\n\t\tcheckSetHelix(3, SecStrucType.helix3);\n\t\tcheckSetHelix(5, SecStrucType.helix5);\n\n\t\tcheckSetTurns();\n\n\t}\n\n\tprivate void checkSetTurns() {\n\t\tfor (int i =0 ; i < groups.length -3 ;i++){\n\n\t\t\tGroup g = groups[i];\n\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\n\t\t\tSecStrucType type = state.getSecStruc();\n\n\t\t\tif ( type.isHelixType() )\n\t\t\t\tcontinue;\n\n\t\t\tboolean[] turns = state.getTurn();\n\t\t\tfor ( int t = 0 ; t < 3 ; t ++){\n\t\t\t\tif ( turns[t])\n\t\t\t\t{\n\n\t\t\t\t\tfor ( int l = i+1 ; l < i+t+3; l++) {\n\t\t\t\t\t\t//System.out.println(\"turn: \" + i + \" \" + type);\n\t\t\t\t\t\tif ( l >= groups.length)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tSecStrucType typel =getSecStrucType(l);\n\t\t\t\t\t\tif ( typel.equals(SecStrucType.coil))\n\t\t\t\t\t\t\tsetSecStrucType(l, SecStrucType.turn);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkSetHelix( int prange,SecStrucType type){\n\n\t\tint range = prange - 3;\n\t\t//System.out.println(\"set helix \" + type + \" \" + prange + \" \" + range);\n\t\tfor (int i =1 ; i < groups.length -range -1 ;i++){\n\n\t\t\tGroup g = groups[i];\n\n\t\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\n\n\t\t\tGroup prevG = groups[i-1];\n\n\t\t\tSecStrucState prevState = (SecStrucState) prevG.getProperty(\"secstruc\");\n\n\t\t\tGroup nextG = groups[i+1];\n\n\t\t\tSecStrucState nextState = (SecStrucState) nextG.getProperty(\"secstruc\");\n\n\t\t\tboolean[] turns = state.getTurn();\n\n\t\t\tboolean[] pturns = prevState.getTurn();\n\n\t\t\tboolean[] nturns = nextState.getTurn();\n\n\t\t\t// DSSP sets helices one amino acid too short....\n\n\t\t\tif ( turns[range] && pturns[range] && nturns[range]) {\n\n\t\t\t\t//Check if no secstruc assigned\n\n\t\t\t\tboolean empty = true;\n\n\t\t\t\tfor ( int curr =i; curr <= i+range ;curr++){\n\t\t\t\t\t//System.out.println(\"   \" + i + \" range: \" + prange + \" \" + range);\n\t\t\t\t\tSecStrucType cstate = getSecStrucType(curr);\n\n\t\t\t\t\tif (cstate.isHelixType()){\n\n\t\t\t\t\t\tempty = false;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// none is assigned yet, set to helix type\n\n\t\t\t\tif ( empty ) {\n\n\t\t\t\t\tfor ( int curr =i; curr <= i+range ;curr++){\n\n\t\t\t\t\t\tsetSecStrucType(curr,type);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setSecStrucType(int pos, SecStrucType state){\n\n\t\tGroup g = groups[pos];\n\t\tSecStrucState s= (SecStrucState) g.getProperty(\"secstruc\");\n\t\ts.setSecStruc(state);\n\t}\n\n\tprivate SecStrucType getSecStrucType(int pos){\n\n\t\tSecStrucState s = getSecStrucState(pos);\n\t\treturn s.getSecStruc();\n\t}\n\n\tprivate SecStrucState getSecStrucState(int pos){\n\t\tGroup g = groups[pos];\n\t\tSecStrucState state = (SecStrucState) g.getProperty(\"secstruc\");\n\t\treturn state;\n\t}\n\n}","originTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of the DSSP implementation for calculating the\n * secondary structure of a Structure object.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSecStruc {\n\n\t@Test\n\tpublic void testDSSP() throws IOException, StructureException {\n\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tcache.getFileParsingParams().setParseSecStruc(true);\n\t\t\tStructure s = cache.getStructure(\"5pti\");\n\n\t\t\tSecStruc sec = new SecStruc();\n\t\t\tsec.assign(s);\n\t\t\t\n\t\t\tString actual = sec.toString();\n\t\t\tString expected = \"\";\n\t\t\t\n\t\t\tassertEquals(expected, actual);\n\t}\n}\n","changedTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test the correctness of the DSSP implementation for calculating the\n * secondary structure of a Structure object.\n * \n * @author Aleix Lafita\n *\n */\npublic class TestSecStruc {\n\n\t@Test\n\tpublic void testDSSP() throws IOException, StructureException {\n\t\t\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tcache.getFileParsingParams().setParseSecStruc(true);\n\t\t\tcache.setUseMmCif(false);\n\t\t\tStructure s = cache.getStructure(\"5pti\");\n\n\t\t\tSecStruc sec = new SecStruc();\n\t\t\tsec.assign(s);\n\t\t\t\n\t\t\tString actual = sec.toString();\n\t\t\tString expected = \"\";\n\t\t\t\n\t\t\tassertEquals(expected, actual);\n\t}\n}\n","commitMessage":"Add a class to represent Secondary Structure Elements","test_commitMessage":"Add a class to represent Secondary Structure Elements","allZero":false}