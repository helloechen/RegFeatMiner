{"repository":"biojava","prod_path":"biojava3-sequencing/src/main/java/org/biojava3/sequencing/io/fastq/FastqVariant.java","test_path":"biojava3-sequencing/src/test/java/org/biojava3/sequencing/io/fastq/FastqVariantTest.java","prod_time":"2013-04-20 04:59:12","test_time":"2013-04-20 04:59:12","type":"EDIT","proType":"EDIT","add_annotation_line":3,"add_call_line":6,"add_classname_line":0,"add_condition_line":6,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":4,"add_return_line":3,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"56d4582925931b7f5d122480b6e48f5e24bde30b","test_commitID":"56d4582925931b7f5d122480b6e48f5e24bde30b","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * FASTQ sequence format variant.\n *\n * @since 3.0.3\n */\npublic enum FastqVariant\n{\n    /** Sanger FASTQ sequence format variant. */\n    FASTQ_SANGER(\"Original or Sanger format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return 0;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 93;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 33;\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            return Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n        }\n    },\n\n    /** Solexa FASTQ sequence format variant. */\n    FASTQ_SOLEXA(\"Solexa and early Illumina format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return -5;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 62;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 64;\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            double q = Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n            return q / (1 + q);\n        }\n    },\n\n    /** Illumina FASTQ sequence format variant. */\n    FASTQ_ILLUMINA(\"Illumina 1.3+ format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return 0;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 62;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 64;\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            return Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n        }\n    };\n\n\n    /** Map of FASTQ sequence format variants keyed by name and lowercase-with-dashes name. */\n    private static final Map<String, FastqVariant> FASTQ_VARIANTS = new HashMap<String, FastqVariant>(6);\n\n    static\n    {\n        for (FastqVariant fastqVariant : values())\n        {\n            FASTQ_VARIANTS.put(fastqVariant.name(), fastqVariant);\n            FASTQ_VARIANTS.put(fastqVariant.lowercaseName(), fastqVariant);\n        }\n    }\n\n    /** Description of this FASTQ sequence format variant. */\n    private final String description;\n\n\n    /**\n     * Create a new FASTQ sequence format variant with the specified description.\n     *\n     * @param description description of this FASTQ sequence format variant, must not be null\n     */\n    private FastqVariant(final String description)\n    {\n        if (description == null)\n        {\n            throw new IllegalArgumentException(\"description must not be null\");\n        }\n        this.description = description;\n    }\n\n\n    /**\n     * Return the description of this FASTQ sequence format variant.\n     * The description will not be null.\n     *\n     * @return the description of this FASTQ sequence format variant\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}\n     */\n    public boolean isSanger()\n    {\n        return (this == FASTQ_SANGER);\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}\n     */\n    public boolean isSolexa()\n    {\n        return (this == FASTQ_SOLEXA);\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}\n     */\n    public boolean isIllumina()\n    {\n        return (this == FASTQ_ILLUMINA);\n    }\n\n    /**\n     * Return the minimum quality score for this FASTQ sequence format variant.\n     *\n     * @return the minimum quality score for this FASTQ sequence format variant.\n     */\n    public abstract int minimumQualityScore();\n\n    /**\n     * Return the maximum quality score for this FASTQ sequence format variant.\n     *\n     * @return the maximum quality score for this FASTQ sequence format variant.\n     */\n    public abstract int maximumQualityScore();\n\n    /**\n     * Convert the specified quality in ASCII format to a quality score.\n     *\n     * @param c quality in ASCII format\n     * @return the specified quality in ASCII format converted to a quality score\n     */\n    public abstract int qualityScore(char c);\n\n    /**\n     * Convert the specified quality in ASCII format to an error probability.\n     *\n     * @param c quality in ASCII format\n     * @return the specified quality in ASCII format converted to an error probability\n     */\n    public double errorProbability(char c)\n    {\n        return errorProbability(qualityScore(c));\n    }\n\n    /**\n     * Calculate the error probability given the specified quality score.\n     *\n     * @param qualityScore quality score\n     * @return the error probability given the specified quality score\n     */\n    public abstract double errorProbability(int qualityScore);\n\n    /**\n     * Return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style.\n     *\n     * @return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style\n     */\n    public String lowercaseName()\n    {\n        return name().toLowerCase().replace('_', '-');\n    }\n\n\n    /**\n     * Return the FASTQ sequence format variant with the specified name, if any.  The name may\n     * be specified in either <code>UPPERCASE_WITH_UNDERSCORES</code>\n     * or <code>lowercase-with-dashes</code> style.\n     *\n     * @param name name\n     * @return the FASTQ sequence format variant with the specified name, or <code>null</code>\n     *    if no such FASTQ sequence format variant exists\n     */\n    public static FastqVariant parseFastqVariant(final String name)\n    {\n        return FASTQ_VARIANTS.get(name);\n    }\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.sequencing.io.fastq;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * FASTQ sequence format variant.\n *\n * @since 3.0.3\n */\npublic enum FastqVariant\n{\n    /** Sanger FASTQ sequence format variant. */\n    FASTQ_SANGER(\"Original or Sanger format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return 0;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 93;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 33;\n        }\n\n        @Override\n        public char quality(final int qualityScore)\n        {\n            if (qualityScore < minimumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n            }\n            if (qualityScore > maximumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n            }\n            return (char) (qualityScore + 33);\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            return Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n        }\n    },\n\n    /** Solexa FASTQ sequence format variant. */\n    FASTQ_SOLEXA(\"Solexa and early Illumina format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return -5;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 62;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 64;\n        }\n\n        @Override\n        public char quality(final int qualityScore)\n        {\n            if (qualityScore < minimumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n            }\n            if (qualityScore > maximumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n            }\n            return (char) (qualityScore + 64);\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            double q = Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n            return q / (1 + q);\n        }\n    },\n\n    /** Illumina FASTQ sequence format variant. */\n    FASTQ_ILLUMINA(\"Illumina 1.3+ format\")\n    {\n        @Override\n        public int minimumQualityScore()\n        {\n            return 0;\n        }\n\n        @Override\n        public int maximumQualityScore()\n        {\n            return 62;\n        }\n\n        @Override\n        public int qualityScore(final char c)\n        {\n            return ((int) c) - 64;\n        }\n\n        @Override\n        public char quality(final int qualityScore)\n        {\n            if (qualityScore < minimumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be greater than or equal to minimumQualityScore()\");\n            }\n            if (qualityScore > maximumQualityScore())\n            {\n                throw new IllegalArgumentException(\"qualityScore must be less than or equal to maximumQualityScore()\");\n            }\n            return (char) (qualityScore + 64);\n        }\n\n        @Override\n        public double errorProbability(final int qualityScore)\n        {\n            return Math.pow(10.0d, ((double) qualityScore) / -10.0d);\n        }\n    };\n\n\n    /** Map of FASTQ sequence format variants keyed by name and lowercase-with-dashes name. */\n    private static final Map<String, FastqVariant> FASTQ_VARIANTS = new HashMap<String, FastqVariant>(6);\n\n    static\n    {\n        for (FastqVariant fastqVariant : values())\n        {\n            FASTQ_VARIANTS.put(fastqVariant.name(), fastqVariant);\n            FASTQ_VARIANTS.put(fastqVariant.lowercaseName(), fastqVariant);\n        }\n    }\n\n    /** Description of this FASTQ sequence format variant. */\n    private final String description;\n\n\n    /**\n     * Create a new FASTQ sequence format variant with the specified description.\n     *\n     * @param description description of this FASTQ sequence format variant, must not be null\n     */\n    private FastqVariant(final String description)\n    {\n        if (description == null)\n        {\n            throw new IllegalArgumentException(\"description must not be null\");\n        }\n        this.description = description;\n    }\n\n\n    /**\n     * Return the description of this FASTQ sequence format variant.\n     * The description will not be null.\n     *\n     * @return the description of this FASTQ sequence format variant\n     */\n    public String getDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_SANGER}\n     */\n    public boolean isSanger()\n    {\n        return (this == FASTQ_SANGER);\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_SOLEXA}\n     */\n    public boolean isSolexa()\n    {\n        return (this == FASTQ_SOLEXA);\n    }\n\n    /**\n     * Return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}.\n     *\n     * @return true if this FASTQ sequence format variant is {@link #FASTQ_ILLUMINA}\n     */\n    public boolean isIllumina()\n    {\n        return (this == FASTQ_ILLUMINA);\n    }\n\n    /**\n     * Return the minimum quality score for this FASTQ sequence format variant.\n     *\n     * @return the minimum quality score for this FASTQ sequence format variant.\n     */\n    public abstract int minimumQualityScore();\n\n    /**\n     * Return the maximum quality score for this FASTQ sequence format variant.\n     *\n     * @return the maximum quality score for this FASTQ sequence format variant.\n     */\n    public abstract int maximumQualityScore();\n\n    /**\n     * Convert the specified quality in ASCII format to a quality score.\n     *\n     * @param c quality in ASCII format\n     * @return the specified quality in ASCII format converted to a quality score\n     */\n    public abstract int qualityScore(char c);\n\n    /**\n     * Convert the specified quality score to a quality in ASCII format.\n     *\n     * @since 3.0.6\n     * @param qualityScore quality score, must be <code>&gt;= minimumQualityScore()</code>\n     *    and <code>&lt;= maximumQualityScore()</code>\n     * @return the quality in ASCII format converted from the specified quality score\n     */\n    public abstract char quality(int qualityScore);\n\n    /**\n     * Convert the specified quality in ASCII format to an error probability.\n     *\n     * @param c quality in ASCII format\n     * @return the specified quality in ASCII format converted to an error probability\n     */\n    public double errorProbability(char c)\n    {\n        return errorProbability(qualityScore(c));\n    }\n\n    /**\n     * Calculate the error probability given the specified quality score.\n     *\n     * @param qualityScore quality score\n     * @return the error probability given the specified quality score\n     */\n    public abstract double errorProbability(int qualityScore);\n\n    /**\n     * Return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style.\n     *\n     * @return the name of this FASTQ sequence format variant in <code>lowercase-with-dashes</code> style\n     */\n    public String lowercaseName()\n    {\n        return name().toLowerCase().replace('_', '-');\n    }\n\n\n    /**\n     * Return the FASTQ sequence format variant with the specified name, if any.  The name may\n     * be specified in either <code>UPPERCASE_WITH_UNDERSCORES</code>\n     * or <code>lowercase-with-dashes</code> style.\n     *\n     * @param name name\n     * @return the FASTQ sequence format variant with the specified name, or <code>null</code>\n     *    if no such FASTQ sequence format variant exists\n     */\n    public static FastqVariant parseFastqVariant(final String name)\n    {\n        return FASTQ_VARIANTS.get(name);\n    }\n}","originTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\npackage org.biojava3.sequencing.io.fastq;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport static org.biojava3.sequencing.io.fastq.FastqVariant.*;\r\n\r\n/**\r\n * Unit test for FastqVariant.\r\n */\r\npublic final class FastqVariantTest\r\n    extends TestCase\r\n{\r\n\r\n    public void testDescription()\r\n    {\r\n        for (FastqVariant variant : values())\r\n        {\r\n            assertNotNull(variant.getDescription());\r\n        }\r\n    }\r\n\r\n    public void testIsSanger()\r\n    {\r\n        assertTrue(FASTQ_SANGER.isSanger());\r\n        assertFalse(FASTQ_SOLEXA.isSanger());\r\n        assertFalse(FASTQ_ILLUMINA.isSanger());\r\n    }\r\n\r\n    public void testIsSolexa()\r\n    {\r\n        assertFalse(FASTQ_SANGER.isSolexa());\r\n        assertTrue(FASTQ_SOLEXA.isSolexa());\r\n        assertFalse(FASTQ_ILLUMINA.isSolexa());\r\n    }\r\n\r\n    public void testIsIllumina()\r\n    {\r\n        assertFalse(FASTQ_SANGER.isIllumina());\r\n        assertFalse(FASTQ_SOLEXA.isIllumina());\r\n        assertTrue(FASTQ_ILLUMINA.isIllumina());\r\n    }\r\n\r\n    public void testParseFastqVariant()\r\n    {\r\n        assertEquals(null, parseFastqVariant(null));\r\n        assertEquals(null, parseFastqVariant(\"\"));\r\n        assertEquals(null, parseFastqVariant(\"not a valid FASTQ variant\"));\r\n        assertEquals(FASTQ_SANGER, parseFastqVariant(\"FASTQ_SANGER\"));\r\n        assertEquals(FASTQ_SANGER, parseFastqVariant(\"fastq-sanger\"));\r\n    }\r\n}","changedTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n */\r\npackage org.biojava3.sequencing.io.fastq;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport static org.biojava3.sequencing.io.fastq.FastqVariant.*;\r\n\r\n/**\r\n * Unit test for FastqVariant.\r\n */\r\npublic final class FastqVariantTest\r\n    extends TestCase\r\n{\r\n\r\n    public void testDescription()\r\n    {\r\n        for (FastqVariant variant : values())\r\n        {\r\n            assertNotNull(variant.getDescription());\r\n        }\r\n    }\r\n\r\n    public void testIsSanger()\r\n    {\r\n        assertTrue(FASTQ_SANGER.isSanger());\r\n        assertFalse(FASTQ_SOLEXA.isSanger());\r\n        assertFalse(FASTQ_ILLUMINA.isSanger());\r\n    }\r\n\r\n    public void testIsSolexa()\r\n    {\r\n        assertFalse(FASTQ_SANGER.isSolexa());\r\n        assertTrue(FASTQ_SOLEXA.isSolexa());\r\n        assertFalse(FASTQ_ILLUMINA.isSolexa());\r\n    }\r\n\r\n    public void testIsIllumina()\r\n    {\r\n        assertFalse(FASTQ_SANGER.isIllumina());\r\n        assertFalse(FASTQ_SOLEXA.isIllumina());\r\n        assertTrue(FASTQ_ILLUMINA.isIllumina());\r\n    }\r\n\r\n    public void testParseFastqVariant()\r\n    {\r\n        assertEquals(null, parseFastqVariant(null));\r\n        assertEquals(null, parseFastqVariant(\"\"));\r\n        assertEquals(null, parseFastqVariant(\"not a valid FASTQ variant\"));\r\n        assertEquals(FASTQ_SANGER, parseFastqVariant(\"FASTQ_SANGER\"));\r\n        assertEquals(FASTQ_SANGER, parseFastqVariant(\"fastq-sanger\"));\r\n    }\r\n\r\n    public void testQualityLessThanMinimumQualityScore()\r\n    {\r\n        for (FastqVariant variant : values())\r\n        {\r\n            try\r\n            {\r\n                variant.quality(variant.minimumQualityScore() - 1);\r\n                fail(\"expected IllegalArgumentException\");\r\n            }\r\n            catch (IllegalArgumentException e)\r\n            {\r\n                // expected\r\n            }\r\n        }\r\n    }\r\n\r\n    public void testQualityMoreThanMaximumQualityScore()\r\n    {\r\n        for (FastqVariant variant : values())\r\n        {\r\n            try\r\n            {\r\n                variant.quality(variant.maximumQualityScore() + 1);\r\n                fail(\"expected IllegalArgumentException\");\r\n            }\r\n            catch (IllegalArgumentException e)\r\n            {\r\n                // expected\r\n            }\r\n        }\r\n    }\r\n\r\n    public void testQualityQualityScoreRoundTrip()\r\n    {\r\n        for (FastqVariant variant : values())\r\n        {\r\n            for (int i = variant.minimumQualityScore(); i < (variant.maximumQualityScore() + 1); i++)\r\n            {\r\n                assertEquals(i, variant.qualityScore(variant.quality(i)));\r\n            }\r\n        }\r\n    }\r\n}","commitMessage":"adding quality method to fastq variant\n","test_commitMessage":"adding quality method to fastq variant\n","allZero":false}