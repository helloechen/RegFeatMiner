{"repository":"biojava","prod_path":"alignment/src/main/java/org/biojava/bio/alignment/FlexibleAlignment.java","test_path":"alignment/src/test/java/org/biojava/bio/alignment/FlexibleAlignmentTest.java","prod_time":"2010-03-24 18:21:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"468b6e5d123d6d1b07d496f43c2027defa45e244","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Edit;\nimport org.biojava.bio.symbol.GappedSymbolList;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.RangeLocation;\nimport org.biojava.bio.symbol.SimpleGappedSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeEvent;\nimport org.biojava.utils.ChangeSupport;\nimport org.biojava.utils.ChangeVetoException;\n\n/**\n * <p>\n * FlexibleAlignment is a class which implements UnequalLengthAlignment,\n * ARAlignment and EditableAlignment <b>It places no restriction on where any\n * sequence can be in the alignment so there could be gaps in the alignment. You\n * tell it where to put the sequence, it will do it. I think I will be adding an\n * Exception NonContinuousAlignmentException. STILL UNDER CONSTRUCTION.\n * seqString does not work because there it does not seem to support\n * tokenization 'token' this is true for SimpleAlignment too.</b>\n * \n * @author David Waring\n * @author Matthew Pocock\n */\npublic class FlexibleAlignment extends AbstractULAlignment implements\n\t\tARAlignment, EditableAlignment {\n\n\tprotected Map<Object, AlignmentElement> data;\n\tprotected List<String> labelOrder;\n\tprotected Location alignmentRange;\n\tList<Alphabet> alphaList = new ArrayList<Alphabet>();\n\n\t/**\n\t * construct this object with the reference sequence which can either be a\n\t * gappedSymbolList or not label in all cases refers to an object that holds\n\t * the display name (generally just a String). since more than one sequence\n\t * in an alignment could have the same name this works as long as the labels\n\t * are different objects even though they may hold the same name.\n\t */\n\n\tpublic FlexibleAlignment(List<AlignmentElement> seqList)\n\t\t\tthrows BioException {\n\t\tdata = new Hashtable<Object, AlignmentElement>();\n\t\tlabelOrder = new Vector<String>();\n\t\talignmentRange = new RangeLocation(1, 1);\n\n\t\tint k = 0;\n\t\t// go through the list make sure that all seqs are GappedSymbolLists\n\t\tfor (Iterator<AlignmentElement> i = seqList.iterator(); i.hasNext();) {\n\t\t\tAlignmentElement ae = i.next();\n\t\t\tString label = ae.getLabel();\n\t\t\tLocation loc = ae.getLoc();\n\t\t\tSymbolList seq = ae.getSymbolList();\n\t\t\talphaList.add(seq.getAlphabet());\n\t\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t\t}\n\t\t\tdata.put(label, ae);\n\t\t\tlabelOrder.add(label);\n\t\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\t\talignmentRange = new RangeLocation(min, max);\n\t\t\tk++;\n\t\t}\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\ttry {\n\t\t\tresetRange();\n\t\t} catch (ChangeVetoException e) {\n\t\t\tthrow new BioError(\"Should not have a problem here\");\n\t\t}\n\n\t}\n\n\tprivate int getOrder(Object label) throws Exception {\n\t\tfor (int i = 0; i < labelOrder.size(); i++) {\n\t\t\tif (labelOrder.get(i).equals(label))\n\t\t\t\treturn i;\n\t\t}\n\t\tthrow new Exception(\"did not find label\");\n\t}\n\n\t/**\n\t * add a new a alignment usings a location to the reference sequence. This\n\t * should either contain no gaps or it should be relative to a reference\n\t * sequence that already has the gaps added\n\t */\n\n\tpublic synchronized void addSequence(AlignmentElement ae)\n\t\t\tthrows ChangeVetoException, BioException {\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\tString label = ae.getLabel();\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation loc = ae.getLoc();\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.ADD_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.ADD_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t}\n\t\tdata.put(label, ae);\n\t\tlabelOrder.add(label);\n\t\talphaList.add(seq.getAlphabet());\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\n\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tresetRange();\n\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\tpublic synchronized void removeSequence(Object label)\n\t\t\tthrows ChangeVetoException {\n\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.REMOVE_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.REMOVE_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\ttry {\n\t\t\talphaList.remove(getOrder(label));\n\t\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tdata.remove(label);\n\t\tlabelOrder.remove(label);\n\t\tresetRange();\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface UnequalLengthAlignment\n\t// ///////////////////////\n\n\t/**\n\t * The location of an individual SymbolList relative to overall Alignment\n\t */\n\tpublic Location locInAlignment(Object label) throws NoSuchElementException {\n\t\treturn getAE(label).getLoc();\n\t}\n\n\tpublic List<Object> getLabelsAt(int column)\n\t\t\tthrows IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length())\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\tList<Object> labelList = new ArrayList<Object>();\n\t\tLocation loc;\n\t\tObject label;\n\t\tfor (Iterator<Object> labelIterator = data.keySet().iterator(); labelIterator\n\t\t\t\t.hasNext();) {\n\t\t\tlabel = labelIterator.next();\n\t\t\tloc = getAE(label).getLoc();\n\t\t\tif (loc.contains(column))\n\t\t\t\tlabelList.add(label);\n\t\t}\n\t\treturn labelList;\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface Alignment\n\t// //////////////////////\n\n\tpublic synchronized int length() {\n\t\treturn alignmentRange.getMax() - alignmentRange.getMin() + 1;\n\t}\n\n\tpublic Alphabet getAlphabet() {\n\t\treturn alphabet;\n\t}\n\n\t/**\n\t * getLabels will return a list of labels in left to right order\n\t */\n\n\tpublic synchronized List<String> getLabels() {\n\t\tTreeSet<String> sorted = new TreeSet<String>(\n\t\t\t\tnew LeftRightLocationComparator<String>());\n\t\tsorted.addAll(labelOrder);\n\t\treturn new Vector<String>(sorted);\n\t}\n\n\t/**\n\t * This gets the symbol for an individual sequence at position in the\n\t * overall alignment If the sequence is not aligned at that location it\n\t * returns null\n\t */\n\n\tpublic synchronized Symbol symbolAt(String label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\n\t\tSymbolList seq = symbolListForLabel(label);\n\t\tint cloc = posInSeq(label, column);\n\t\tSymbol symbol = null;\n\t\t// debug (label.toString() + \" \" + column + \":\" + cloc);\n\t\tif (seq == null) {\n\t\t\t// debug(\"seq is null\");\n\t\t}\n\n\t\ttry {\n\t\t\tsymbol = seq.symbolAt(cloc);\n\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t// leave symbol == null\n\t\t}\n\t\treturn symbol;\n\t}\n\n\tpublic synchronized SymbolList symbolListForLabel(Object label)\n\t\t\tthrows NoSuchElementException {\n\t\treturn getAE(label).getSymbolList();\n\t}\n\n\t// methods from interface EditableAlignment\n\n\tpublic synchronized void edit(Object label, Edit edit)\n\t\t\tthrows ChangeVetoException {\n\t\tthrow new BioError(\"Not implemented yet\");\n\t}\n\n\t/**\n\t * loc in this case is the Alignment Location\n\t */\n\tpublic synchronized void shiftAtAlignmentLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tLocation sourceLoc = locInSeq(label, loc);\n\t\tshiftAtSequenceLoc(label, sourceLoc, offset);\n\n\t}\n\n\t/**\n\t * loc in this case is the SymbolList Location\n\t */\n\tpublic synchronized void shiftAtSequenceLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tChangeSupport csgap;\n\t\tChangeEvent cegap;\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tcegap = new ChangeEvent(this, EditableAlignment.GAPS, label);\n\t\tcsgap = getChangeSupport(EditableAlignment.GAPS);\n\n\t\tint caseValue = 0;\n\t\tint absOffset = Math.abs(offset);\n\t\tLocation seqLoc = locInAlignment(label);\n\t\tAlignmentElement ae = getAE(label);\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation newLoc;\n\t\tint min = loc.getMin();\n\t\tint max = loc.getMax();\n\t\tif (min < 1 || max > seq.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (offset == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (offset > 1)\n\t\t\tcaseValue += 1;\n\t\tif (min == 1)\n\t\t\tcaseValue += 2;\n\t\tif (max == seq.length())\n\t\t\tcaseValue += 4;\n\n\t\tswitch (caseValue) {\n\n\t\tcase 0: // internal shift to left\n\t\t\tif (!allGaps(seq, min + offset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 1: // internal shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 2: // left end shift to left\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() - absOffset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 3: // left end shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() + offset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 4: // right end shift to left\n\t\t\tif (!allGaps(seq, min - absOffset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 5: // right end shift to right\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 6: // whole seq shift to left\n\t\t\tdebug(\"Shifting all to left \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tcase 7: // whole seq shift to right\n\t\t\tdebug(\"Shifting all to right \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdebug(\"OOOPS something is wrong \" + loc.toString() + \" \"\n\t\t\t\t\t+ absOffset);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * because there is a bug in GappedSymbolList\n\t */\n\n\tpublic synchronized void removeGaps(GappedSymbolList seq, int start,\n\t\t\tint length) {\n\t\ttry {\n\t\t\t// seq.removeGaps (start , length);\n\t\t\t// because there is a bug in GappedSymbolList we do it one at a time\n\t\t\tfor (int i = 1; i <= length; i++) {\n\t\t\t\tseq.removeGap(start);\n\t\t\t}\n\t\t} catch (IllegalSymbolException e) {\n\t\t\tthrow new BioError(\"We should have tested for this already\");\n\t\t}\n\t}\n\n\t/**\n\t * make sure that all Symbols in this range are gaps\n\t */\n\n\tprotected synchronized boolean allGaps(SymbolList seq, int start, int end) {\n\n\t\tSymbol gs = seq.getAlphabet().getGapSymbol();\n\t\tfor (int i = start; i <= end; i++) {\n\t\t\tif (!(seq.symbolAt(i).equals(gs))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * check that begining is at 1 otherwise shift everything over\n\t */\n\tprotected synchronized void resetRange() throws ChangeVetoException {\n\n\t\tint min = 0;// just for the compiler\n\t\tint max = 0;// just for the compiler\n\t\tint lMin;\n\t\tint lMax;\n\t\tint count = 1;\n\t\t// get the current range from all labels\n\t\tfor (Iterator<String> i = getLabels().iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tlMin = locInAlignment(label).getMin();\n\t\t\tlMax = locInAlignment(label).getMax();\n\t\t\tif (count == 1) {\n\t\t\t\tmin = lMin;\n\t\t\t} else {\n\t\t\t\tmin = lesser(min, lMin);\n\t\t\t}\n\t\t\tif (count == 1) {\n\t\t\t\tmax = lMax;\n\t\t\t} else {\n\t\t\t\tmax = greater(max, lMax);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tif (min != 1) {\n\t\t\tint offset = 1 - alignmentRange.getMin();\n\t\t\tshiftAll(offset);\n\t\t\talignmentRange = new RangeLocation(\n\t\t\t\t\talignmentRange.getMin() + offset, alignmentRange.getMax()\n\t\t\t\t\t\t\t+ offset);\n\t\t}\n\t}\n\n\tprotected synchronized void shiftAll(int offset) throws ChangeVetoException {\n\t\tList<String> lList = getLabels();\n\t\tfor (Iterator<String> i = lList.iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tshift(label, offset);\n\t\t}\n\t}\n\n\t/**\n\t * moves the whole sequence\n\t */\n\n\tprotected synchronized void shift(Object label, int offset)\n\t\t\tthrows ChangeVetoException {\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tLocation oLoc = locInAlignment(label);\n\t\tLocation nLoc = new RangeLocation(oLoc.getMin() + offset, oLoc.getMax()\n\t\t\t\t+ offset);\n\t\tcsloc.firePreChangeEvent(celoc);\n\t\tdebug(\"shifting \" + label.toString());\n\t\tgetAE(label).setLoc(nLoc);\n\t\tresetRange();\n\t\tdebug(\"shifted \" + label);\n\t\tcsloc.firePostChangeEvent(celoc);\n\t}\n\n\t// utility methods\n\tprotected int greater(int x, int y) {\n\t\tint greatest = (x > y) ? x : y;\n\t\treturn greatest;\n\t}\n\n\tprotected int lesser(int x, int y) {\n\t\tint least = (x < y) ? x : y;\n\t\treturn least;\n\t}\n\n\tprotected AlignmentElement getAE(Object label)\n\t\t\tthrows NoSuchElementException {\n\t\tif (!(data.containsKey(label)))\n\t\t\t;\n\t\treturn data.get(label);\n\t}\n\n\t/**\n\t * get the position in the sequence corresponding to the postion within the\n\t * alignment\n\t */\n\n\tprotected synchronized int posInSeq(Object label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tLocation loc = locInAlignment(label);\n\t\treturn (column - loc.getMin() + 1);\n\t}\n\n\tprotected synchronized Location locInSeq(Object label, Location viewLoc)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tint min = posInSeq(label, viewLoc.getMin());\n\t\tint max = posInSeq(label, viewLoc.getMax());\n\t\treturn new RangeLocation(min, max);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Edit;\nimport org.biojava.bio.symbol.GappedSymbolList;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.RangeLocation;\nimport org.biojava.bio.symbol.SimpleGappedSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeEvent;\nimport org.biojava.utils.ChangeSupport;\nimport org.biojava.utils.ChangeVetoException;\n\n/**\n * <p>\n * FlexibleAlignment is a class which implements UnequalLengthAlignment,\n * ARAlignment and EditableAlignment <b>It places no restriction on where any\n * sequence can be in the alignment so there could be gaps in the alignment. You\n * tell it where to put the sequence, it will do it. I think I will be adding an\n * Exception NonContinuousAlignmentException. STILL UNDER CONSTRUCTION.\n * seqString does not work because there it does not seem to support\n * tokenization 'token' this is true for SimpleAlignment too.</b>\n * \n * @author David Waring\n * @author Matthew Pocock\n */\npublic class FlexibleAlignment extends AbstractULAlignment implements\n\t\tARAlignment, EditableAlignment {\n\n\tprotected Map<Object, AlignmentElement> data;\n\tprotected List<String> labelOrder;\n\tprotected Location alignmentRange;\n\tList<Alphabet> alphaList = new ArrayList<Alphabet>();\n\n\t/**\n\t * construct this object with the reference sequence which can either be a\n\t * gappedSymbolList or not label in all cases refers to an object that holds\n\t * the display name (generally just a String). since more than one sequence\n\t * in an alignment could have the same name this works as long as the labels\n\t * are different objects even though they may hold the same name.\n\t */\n\n\tpublic FlexibleAlignment(List<AlignmentElement> seqList)\n\t\t\tthrows BioException {\n\t\tdata = new Hashtable<Object, AlignmentElement>();\n\t\tlabelOrder = new Vector<String>();\n\t\talignmentRange = new RangeLocation(1, 1);\n\n\t\tint k = 0;\n\t\t// go through the list make sure that all seqs are GappedSymbolLists\n\t\tfor (Iterator<AlignmentElement> i = seqList.iterator(); i.hasNext();) {\n\t\t\tAlignmentElement ae = i.next();\n\t\t\tString label = ae.getLabel();\n\t\t\tLocation loc = ae.getLoc();\n\t\t\tSymbolList seq = ae.getSymbolList();\n\t\t\talphaList.add(seq.getAlphabet());\n\t\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t\t}\n\t\t\tdata.put(label, ae);\n\t\t\tlabelOrder.add(label);\n\t\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\t\talignmentRange = new RangeLocation(min, max);\n\t\t\tk++;\n\t\t}\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\ttry {\n\t\t\tresetRange();\n\t\t} catch (ChangeVetoException e) {\n\t\t\tthrow new BioError(\"Should not have a problem here\");\n\t\t}\n\n\t}\n\n\tprivate int getOrder(Object label) throws Exception {\n\t\tfor (int i = 0; i < labelOrder.size(); i++) {\n\t\t\tif (labelOrder.get(i).equals(label))\n\t\t\t\treturn i;\n\t\t}\n\t\tthrow new Exception(\"did not find label\");\n\t}\n\n\t/**\n\t * add a new a alignment usings a location to the reference sequence. This\n\t * should either contain no gaps or it should be relative to a reference\n\t * sequence that already has the gaps added\n\t */\n\n\tpublic synchronized void addSequence(AlignmentElement ae)\n\t\t\tthrows ChangeVetoException, BioException {\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\tString label = ae.getLabel();\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation loc = ae.getLoc();\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.ADD_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.ADD_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t}\n\t\tdata.put(label, ae);\n\t\tlabelOrder.add(label);\n\t\talphaList.add(seq.getAlphabet());\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\n\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tresetRange();\n\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\tpublic synchronized void removeSequence(Object label)\n\t\t\tthrows ChangeVetoException {\n\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.REMOVE_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.REMOVE_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\ttry {\n\t\t\talphaList.remove(getOrder(label));\n\t\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tdata.remove(label);\n\t\tlabelOrder.remove(label);\n\t\tresetRange();\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface UnequalLengthAlignment\n\t// ///////////////////////\n\n\t/**\n\t * The location of an individual SymbolList relative to overall Alignment\n\t */\n\tpublic Location locInAlignment(Object label) throws NoSuchElementException {\n\t\treturn getAE(label).getLoc();\n\t}\n\n\tpublic List<Object> getLabelsAt(int column)\n\t\t\tthrows IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length())\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\tList<Object> labelList = new ArrayList<Object>();\n\t\tLocation loc;\n\t\tObject label;\n\t\tfor (Iterator<Object> labelIterator = data.keySet().iterator(); labelIterator\n\t\t\t\t.hasNext();) {\n\t\t\tlabel = labelIterator.next();\n\t\t\tloc = getAE(label).getLoc();\n\t\t\tif (loc.contains(column))\n\t\t\t\tlabelList.add(label);\n\t\t}\n\t\treturn labelList;\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface Alignment\n\t// //////////////////////\n\n\tpublic synchronized int length() {\n\t\treturn alignmentRange.getMax() - alignmentRange.getMin() + 1;\n\t}\n\n\tpublic Alphabet getAlphabet() {\n\t\treturn alphabet;\n\t}\n\n\t/**\n\t * getLabels will return a list of labels in left to right order\n\t */\n\n\tpublic synchronized List<String> getLabels() {\n\t\tTreeSet<String> sorted = new TreeSet<String>(\n\t\t\t\tnew LeftRightLocationComparator<String>());\n\t\tsorted.addAll(labelOrder);\n\t\treturn new Vector<String>(sorted);\n\t}\n\n\t/**\n\t * This gets the symbol for an individual sequence at position in the\n\t * overall alignment If the sequence is not aligned at that location it\n\t * returns null\n\t */\n\n\tpublic synchronized Symbol symbolAt(String label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\n\t\tSymbolList seq = symbolListForLabel(label);\n\t\tint cloc = posInSeq(label, column);\n\t\tSymbol symbol = null;\n\t\t// debug (label.toString() + \" \" + column + \":\" + cloc);\n\t\tif (seq == null) {\n\t\t\t// debug(\"seq is null\");\n\t\t}\n\n\t\ttry {\n\t\t\tsymbol = seq.symbolAt(cloc);\n\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t// leave symbol == null\n\t\t}\n\t\treturn symbol;\n\t}\n\n\t/**\n\t * \n\t * @param label\n\t * @return\n\t * @throws NoSuchElementException\n\t */\n\tpublic synchronized SymbolList symbolListForLabel(String label)\n\t\t\tthrows NoSuchElementException {\n\t\treturn getAE(label).getSymbolList();\n\t}\n\n\t// methods from interface EditableAlignment\n\n\tpublic synchronized void edit(Object label, Edit edit)\n\t\t\tthrows ChangeVetoException {\n\t\tthrow new BioError(\"Not implemented yet\");\n\t}\n\n\t/**\n\t * loc in this case is the Alignment Location\n\t */\n\tpublic synchronized void shiftAtAlignmentLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tLocation sourceLoc = locInSeq(label, loc);\n\t\tshiftAtSequenceLoc(label, sourceLoc, offset);\n\n\t}\n\n\t/**\n\t * loc in this case is the SymbolList Location\n\t */\n\tpublic synchronized void shiftAtSequenceLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tChangeSupport csgap;\n\t\tChangeEvent cegap;\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tcegap = new ChangeEvent(this, EditableAlignment.GAPS, label);\n\t\tcsgap = getChangeSupport(EditableAlignment.GAPS);\n\n\t\tint caseValue = 0;\n\t\tint absOffset = Math.abs(offset);\n\t\tLocation seqLoc = locInAlignment(label);\n\t\tAlignmentElement ae = getAE(label);\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation newLoc;\n\t\tint min = loc.getMin();\n\t\tint max = loc.getMax();\n\t\tif (min < 1 || max > seq.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (offset == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (offset > 1)\n\t\t\tcaseValue += 1;\n\t\tif (min == 1)\n\t\t\tcaseValue += 2;\n\t\tif (max == seq.length())\n\t\t\tcaseValue += 4;\n\n\t\tswitch (caseValue) {\n\n\t\tcase 0: // internal shift to left\n\t\t\tif (!allGaps(seq, min + offset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 1: // internal shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 2: // left end shift to left\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() - absOffset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 3: // left end shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() + offset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 4: // right end shift to left\n\t\t\tif (!allGaps(seq, min - absOffset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 5: // right end shift to right\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 6: // whole seq shift to left\n\t\t\tdebug(\"Shifting all to left \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tcase 7: // whole seq shift to right\n\t\t\tdebug(\"Shifting all to right \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdebug(\"OOOPS something is wrong \" + loc.toString() + \" \"\n\t\t\t\t\t+ absOffset);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * because there is a bug in GappedSymbolList\n\t */\n\n\tpublic synchronized void removeGaps(GappedSymbolList seq, int start,\n\t\t\tint length) {\n\t\ttry {\n\t\t\t// seq.removeGaps (start , length);\n\t\t\t// because there is a bug in GappedSymbolList we do it one at a time\n\t\t\tfor (int i = 1; i <= length; i++) {\n\t\t\t\tseq.removeGap(start);\n\t\t\t}\n\t\t} catch (IllegalSymbolException e) {\n\t\t\tthrow new BioError(\"We should have tested for this already\");\n\t\t}\n\t}\n\n\t/**\n\t * make sure that all Symbols in this range are gaps\n\t */\n\n\tprotected synchronized boolean allGaps(SymbolList seq, int start, int end) {\n\n\t\tSymbol gs = seq.getAlphabet().getGapSymbol();\n\t\tfor (int i = start; i <= end; i++) {\n\t\t\tif (!(seq.symbolAt(i).equals(gs))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * check that begining is at 1 otherwise shift everything over\n\t */\n\tprotected synchronized void resetRange() throws ChangeVetoException {\n\n\t\tint min = 0;// just for the compiler\n\t\tint max = 0;// just for the compiler\n\t\tint lMin;\n\t\tint lMax;\n\t\tint count = 1;\n\t\t// get the current range from all labels\n\t\tfor (Iterator<String> i = getLabels().iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tlMin = locInAlignment(label).getMin();\n\t\t\tlMax = locInAlignment(label).getMax();\n\t\t\tif (count == 1) {\n\t\t\t\tmin = lMin;\n\t\t\t} else {\n\t\t\t\tmin = lesser(min, lMin);\n\t\t\t}\n\t\t\tif (count == 1) {\n\t\t\t\tmax = lMax;\n\t\t\t} else {\n\t\t\t\tmax = greater(max, lMax);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tif (min != 1) {\n\t\t\tint offset = 1 - alignmentRange.getMin();\n\t\t\tshiftAll(offset);\n\t\t\talignmentRange = new RangeLocation(\n\t\t\t\t\talignmentRange.getMin() + offset, alignmentRange.getMax()\n\t\t\t\t\t\t\t+ offset);\n\t\t}\n\t}\n\n\tprotected synchronized void shiftAll(int offset) throws ChangeVetoException {\n\t\tList<String> lList = getLabels();\n\t\tfor (Iterator<String> i = lList.iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tshift(label, offset);\n\t\t}\n\t}\n\n\t/**\n\t * moves the whole sequence\n\t */\n\n\tprotected synchronized void shift(Object label, int offset)\n\t\t\tthrows ChangeVetoException {\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tLocation oLoc = locInAlignment(label);\n\t\tLocation nLoc = new RangeLocation(oLoc.getMin() + offset, oLoc.getMax()\n\t\t\t\t+ offset);\n\t\tcsloc.firePreChangeEvent(celoc);\n\t\tdebug(\"shifting \" + label.toString());\n\t\tgetAE(label).setLoc(nLoc);\n\t\tresetRange();\n\t\tdebug(\"shifted \" + label);\n\t\tcsloc.firePostChangeEvent(celoc);\n\t}\n\n\t// utility methods\n\tprotected int greater(int x, int y) {\n\t\tint greatest = (x > y) ? x : y;\n\t\treturn greatest;\n\t}\n\n\tprotected int lesser(int x, int y) {\n\t\tint least = (x < y) ? x : y;\n\t\treturn least;\n\t}\n\n\tprotected AlignmentElement getAE(Object label)\n\t\t\tthrows NoSuchElementException {\n\t\tif (!(data.containsKey(label)))\n\t\t\t;\n\t\treturn data.get(label);\n\t}\n\n\t/**\n\t * get the position in the sequence corresponding to the postion within the\n\t * alignment\n\t */\n\n\tprotected synchronized int posInSeq(Object label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tLocation loc = locInAlignment(label);\n\t\treturn (column - loc.getMin() + 1);\n\t}\n\n\tprotected synchronized Location locInSeq(Object label, Location viewLoc)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tint min = posInSeq(label, viewLoc.getMin());\n\t\tint max = posInSeq(label, viewLoc.getMax());\n\t\treturn new RangeLocation(min, max);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.GappedSequence;\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.LocationTools;\n\n/* @author Lachlan Coin */\npublic class FlexibleAlignmentTest extends TestCase {\n\n  public FlexibleAlignmentTest(String name){\n    super(name);\n  }\n\n    //public static void main(String[] args) throws Exception{\n    //\tFlexibleAlignmentTest aat = new FlexibleAlignmentTest();\n    //\taat.setUp();\n    //\taat.testDNA();\n    //\taat.testProtein();\n    //}\n\n\n    final static String[] alignment = new String[] {\"A-C\",\n                                       \"AGC\",\n                                       \"A-A\"};\n\n\n    final static String[] names = new String[] {\"MOUSE\", \"HUMAN\",\"SCHPO\"};\n\n    final static FlexibleAlignment alignDNA = parse(names, alignment, true);\n    final static FlexibleAlignment alignProt = parse(names, alignment, false);\n\n    protected void setUp() throws Exception{\n\n    }\n\n\n  public void testDNA()\n      throws Exception\n  {\n      List syms = ((BasisSymbol) alignDNA.symbolAt(2)).getSymbols();\n      assertEquals(syms.get(0), DNATools.getDNA().getGapSymbol());\n      assertEquals(syms.get(1), DNATools.g());\n  }\n\n\n  public void testProtein()\n      throws Exception\n  {\n      List syms = ((BasisSymbol) alignProt.symbolAt(2)).getSymbols();\n      assertEquals(syms.get(0), ProteinTools.getAlphabet().getGapSymbol());\n  }\n\n\n\n    private static FlexibleAlignment parse(String[] names, String[] alignment, boolean dna)\n    {\n        try\n        {\n            List sequences = new ArrayList();\n            for(int i=0; i<alignment.length; i++)\n            {\n                GappedSequence seq;\n                if(dna)\n                    seq = DNATools.createGappedDNASequence(alignment[i],names[i]);\n                else\n                    seq = ProteinTools.createGappedProteinSequence(alignment[i],names[i]);\n                AlignmentElement ae = new SimpleAlignmentElement(names[i], seq, LocationTools.makeLocation(1, alignment[i].length()));\n                //         System.out.println(seq.seqString());\n                sequences.add(ae);\n            }\n            FlexibleAlignment al = new FlexibleAlignment(sequences);\n            return al;\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n            //System.exit(0);\n            return null;\n        }\n    }\n\n\n\n}\n","changedTest":"","commitMessage":"Improved Alignment classes: Now we have an alignment object that contains all information about the alignment instead of simply having a String output. This formatation algorithm has also been improved and should now be much faster and has become much simpler. Furthermore, many generic type attributes have been added. However, additional tests are necessary to make the new framework run properly.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7595 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}