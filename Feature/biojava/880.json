{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/util/AtomCache.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/util/AtomCacheTest.java","prod_time":"2019-04-25 09:36:30","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":16,"add_classname_line":0,"add_condition_line":8,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":5,"add_return_line":12,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":9,"del_field_line":2,"del_import_line":4,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":3,"label":"NEGATIVE","prod_commitID":"9f60663232f10b513c1f4a9a87dba1406ee361d9","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.client.StructureName;\nimport org.biojava.nbio.structure.cath.CathDatabase;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.io.FileParsingParameters;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.structure.io.MMCIFFileReader;\nimport org.biojava.nbio.structure.io.MMTFFileReader;\nimport org.biojava.nbio.structure.io.PDBFileReader;\nimport org.biojava.nbio.core.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.scop.CachedRemoteScopInstallation;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDescription;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility class that provides easy access to Structure objects. If you are running a script that is frequently\n * re-using the same PDB structures, the AtomCache keeps an in-memory cache of the files for quicker access. The cache\n * is a soft-cache, this means it won't cause out of memory exceptions, but garbage collects the data if the Java\n * virtual machine needs to free up space. The AtomCache is thread-safe.\n *\n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Peter Rose\n * @since 3.0\n */\npublic class AtomCache {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomCache.class);\n\n\t/**\n\t * The default output bioassembly style: if true the bioassemblies are multimodel,\n\t * if false the bioassemblies are flat with renamed chains for symmetry-partners.\n\t */\n\tpublic static final boolean DEFAULT_BIOASSEMBLY_STYLE = false;\n\n\tpublic static final String BIOL_ASSEMBLY_IDENTIFIER = \"BIO:\";\n\tpublic static final String CHAIN_NR_SYMBOL = \":\";\n\tpublic static final String CHAIN_SPLIT_SYMBOL = \".\";\n\n\tpublic static final String PDP_DOMAIN_IDENTIFIER = \"PDP:\";\n\n\tpublic static final String UNDERSCORE = \"_\";\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\tprotected FileParsingParameters params;\n\tprotected PDPProvider pdpprovider;\n\n\tprivate FetchBehavior fetchBehavior;\n\tprivate ObsoleteBehavior obsoleteBehavior;\n\n\tprivate String cachePath;\n\n\t// make sure IDs are loaded uniquely\n\tprivate Collection<String> currentlyLoading = Collections.synchronizedCollection(new TreeSet<String>());\n\n\tprivate String path;\n\n\tprivate boolean useMmCif;\n\tprivate boolean useMmtf;\n\n\t/**\n\t * Default AtomCache constructor.\n\t *\n\t * Usually stores files in a temp directory, but this can be overriden by setting the PDB_DIR variable at runtime.\n\t *\n\t * @see UserConfiguration#UserConfiguration()\n\t */\n\tpublic AtomCache() {\n\t\tthis(new UserConfiguration());\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system. It will use the same value for pdbFilePath and cachePath.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t */\n\tpublic AtomCache(String pdbFilePath) {\n\t\tthis(pdbFilePath,pdbFilePath);\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t * @param cachePath\n\t */\n\tpublic AtomCache(String pdbFilePath, String cachePath) {\n\n\t\tlogger.debug(\"Initialising AtomCache with pdbFilePath={}, cachePath={}\",pdbFilePath, cachePath);\n\n\t\tif (!pdbFilePath.endsWith(FILE_SEPARATOR)) {\n\t\t\tpdbFilePath += FILE_SEPARATOR;\n\t\t}\n\n\t\t// we are caching the binary files that contain the PDBs gzipped\n\t\t// that is the most memory efficient way of caching...\n\t\t// set the input stream provider to caching mode\n\t\tSystem.setProperty(InputStreamProvider.CACHE_PROPERTY, \"true\");\n\n\t\tsetPath(pdbFilePath);\n\n\t\tthis.cachePath = cachePath;\n\n\t\tfetchBehavior = FetchBehavior.DEFAULT;\n\t\tobsoleteBehavior = ObsoleteBehavior.DEFAULT;\n\n\t\tcurrentlyLoading.clear();\n\t\tparams = new FileParsingParameters();\n\n\t\tsetUseMmCif(false);\n\t\tsetUseMmtf(true);\n\n\t}\n\n\t/**\n\t * Creates a new AtomCache object based on the provided UserConfiguration.\n\t *\n\t * @param config\n\t *            the UserConfiguration to use for this cache.\n\t */\n\tpublic AtomCache(UserConfiguration config) {\n\t\tthis(config.getPdbFilePath(), config.getCacheFilePath());\n\t\tfetchBehavior = config.getFetchBehavior();\n\t\tobsoleteBehavior = config.getObsoleteBehavior();\n\t\tuseMmCif = config.getFileFormat().equals( UserConfiguration.MMCIF_FORMAT );\n\n\t\tif ( useMmCif)\n\t\t\tuseMmtf = false;\n\n\t}\n\n\t/**\n\t * Returns the CA atoms for the provided name. See {@link #getStructure(String)} for supported naming conventions.\n\t * <p>\n\t * This method only works with protein chains. Use {@link #getRepresentativeAtoms(String)}\n\t * for a more general solution.\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getAtoms(String name) throws IOException, StructureException {\n\t\treturn getAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\t// System.out.println(\"loading \" + name);\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getAtomCAArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Returns the representative atoms for the provided name.\n\t * See {@link #getStructure(String)} for supported naming conventions.\n\t *\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getRepresentativeAtoms(String name) throws IOException, StructureException {\n\t\treturn getRepresentativeAtoms(new StructureName(name));\n\t}\n\n\tpublic Atom[] getRepresentativeAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getRepresentativeAtomArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\n\t/**\n\t * Returns the biological assembly for a given PDB ID and bioAssemblyId, by building the\n\t * assembly from the biounit annotations found in {@link Structure#getPDBHeader()}\n\t * <p>\n\t * Note, the number of available biological unit files\n\t * varies. Many entries don't have a biological assembly specified (e.g. NMR structures), many entries have only one\n\t * biological assembly (bioAssemblyId=1), and some structures have multiple biological assemblies.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException if biassemblyId < 0 or other problems while loading structure\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, int bioAssemblyId, boolean multiModel)\n\t\t\tthrows StructureException, IOException {\n\n\t\tif (bioAssemblyId < 0) {\n\t\t\tthrow new StructureException(\"bioAssemblyID must be nonnegative: \" + pdbId + \" bioAssemblyId \"\n\t\t\t\t\t+ bioAssemblyId);\n\t\t}\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as biological assembly\", pdbId);\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\t// 0 ... asym unit\n\t\tif ( bioAssemblyId == 0) {\n\t\t\tlogger.info(\"Requested biological assembly 0 for PDB id \"+pdbId+\", returning asymmetric unit\");\n\t\t\treturn asymUnit;\n\t\t}\n\t\t// does it exist?\n\t\tif (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(bioAssemblyId)) {\n\t\t\tthrow new StructureException(\"No biological assembly available for biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\t\t}\n\n\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\n\t\t}\n\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\tboolean useAsymIds = false;\n\t\tif (useMmCif) useAsymIds = true;\n\t\tif (useMmtf) useAsymIds = true;\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\n\t}\n\n\t/**\n\t * Returns the default biological unit (bioassemblyId=1, known in PDB as pdb1.gz). If it is not available,\n\t * the asymmetric unit will be returned, e.g. for NMR structures.\n\t *\n\t * <p>Biological assemblies can also be accessed using\n\t * <tt>getStructure(\"BIO:<i>[pdbId]</i>\")</tt>\n\t * @param pdbId the PDB id\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, boolean multiModel) throws StructureException, IOException {\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as biological assembly\", pdbId);\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\tint bioAssemblyId = 1;\n\n\t\t// does it exist?\n\t\tif (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(bioAssemblyId)) {\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\n\t\t}\n\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\tboolean useAsymIds = false;\n\t\tif (useMmCif) useAsymIds = true;\n\t\tif (useMmtf) useAsymIds = true;\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\n\t}\n\n\t/**\n\t * Returns all biological assemblies for given PDB id.\n\t * @param pdbId\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return\n\t * @throws StructureException\n\t * @throws IOException\n\t * @since 5.0\n\t */\n\tpublic List<Structure> getBiologicalAssemblies(String pdbId, boolean multiModel) throws StructureException, IOException {\n\n\t\tList<Structure> assemblies = new ArrayList<>();\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as the only biological assembly\", pdbId);\n\t\t\tassemblies.add(asymUnit);\n\t\t\treturn assemblies;\n\t\t}\n\n\n\t\tfor (int bioAssemblyId : asymUnit.getPDBHeader().getBioAssemblies().keySet()) {\n\t\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\t\tlogger.info(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId+\". Assembly id will be missing in biological assemblies.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\t\tboolean useAsymIds = false;\n\t\t\tif (useMmCif) useAsymIds = true;\n\t\t\tif (useMmtf) useAsymIds = true;\n\t\t\tStructure s = builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\t\t\tassemblies.add(s);\n\t\t}\n\t\treturn assemblies;\n\t}\n\n\t/**\n\t * Returns the path that contains the caching file for utility data, such as domain definitions.\n\t *\n\t * @return\n\t */\n\tpublic String getCachePath() {\n\t\treturn cachePath;\n\t}\n\n\tpublic FileParsingParameters getFileParsingParams() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * Get the path that is used to cache PDB files.\n\t *\n\t * @return path to a directory\n\t */\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic PDPProvider getPdpprovider() {\n\t\treturn pdpprovider;\n\t}\n\n\t/**\n\t * Request a Structure based on a <i>name</i>.\n\t *\n\t * <pre>\n\t * \t\tFormal specification for how to specify the <i>name</i>:\n\t *\n\t * \t\tname     := pdbID\n\t * \t\t               | pdbID '.' chainID\n\t * \t\t               | pdbID '.' range\n\t * \t\t               | scopID\n\t * \t\trange         := '('? range (',' range)? ')'?\n\t * \t\t               | chainID\n\t * \t\t               | chainID '_' resNum '-' resNum\n\t * \t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t * \t\tchainID       := [a-zA-Z0-9]\n\t * \t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t * \t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\t *\n\t *\n\t * \t\tExample structures:\n\t * \t\t1TIM     #whole structure\n\t * \t\t4HHB.C     #single chain\n\t * \t\t4GCR.A_1-83     #one domain, by residue number\n\t * \t\t3AA0.A,B     #two chains treated as one structure\n\t * \t\td2bq6a1     #scop domain\n\t * </pre>\n\t *\n\t * With the additional set of rules:\n\t *\n\t * <ul>\n\t * <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model\n\t * only (for NMR).\n\t * <li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A</li>\n\t * <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names,\n\t * see {@link #setStrictSCOP(boolean)}</li>\n\t * <li>URLs are accepted as well</li>\n\t * </ul>\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException\n\t *             The PDB file cannot be cached due to IO errors\n\t * @throws StructureException\n\t *             The name appeared valid but did not correspond to a structure. Also thrown by some submethods upon\n\t *             errors, eg for poorly formatted subranges.\n\t */\n\tpublic Structure getStructure(String name) throws IOException, StructureException {\n\t\tStructureName structureName = new StructureName(name);\n\n\t\treturn getStructure(structureName);\n\t}\n\n\t/**\n\t * Get the structure corresponding to the given {@link StructureIdentifier}.\n\t * Equivalent to calling {@link StructureIdentifier#loadStructure(AtomCache)}\n\t * followed by {@link StructureIdentifier#reduce(Structure)}.\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param strucId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructure(StructureIdentifier strucId) throws IOException, StructureException {\n\t\tStructure s = strucId.loadStructure(this);\n\t\tStructure r = strucId.reduce(s);\n\t\tr.setStructureIdentifier(strucId);\n\t\treturn r;\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain) throws IOException, StructureException {\n\t\treturn getStructureForDomain(domain, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\treturn getStructureForDomain(domain, scopDatabase, false);\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @param strictLigandHandling\n\t *            If set to false, hetero-atoms are included if and only if they belong to a chain to which the SCOP\n\t *            domain belongs; if set to true, hetero-atoms are included if and only if they are strictly within the\n\t *            definition (residue numbers) of the SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase, boolean strictLigandHandling)\n\t\t\tthrows IOException, StructureException {\n\n\t\tString pdbId = domain.getPdbId();\n\t\tStructure fullStructure = getStructureForPdbId(pdbId);\n\t\tStructure structure = domain.reduce(fullStructure);\n\n\t\t// TODO It would be better to move all of this into the reduce method,\n\t\t// but that would require ligand handling properties in StructureIdentifiers\n\n\t\t// because ligands sometimes occur after TER records in PDB files, we may need to add some ligands back in\n\t\t// specifically, we add a ligand if and only if it occurs within the domain\n\t\tAtomPositionMap map = null;\n\t\tList<ResidueRangeAndLength> rrs = null;\n\t\tif (strictLigandHandling) {\n\t\t\tmap = new AtomPositionMap(StructureTools.getAllAtomArray(fullStructure), AtomPositionMap.ANYTHING_MATCHER);\n\t\t\trrs = ResidueRangeAndLength.parseMultiple(domain.getRanges(), map);\n\t\t}\n\t\tfor (Chain chain : fullStructure.getNonPolyChains()) {\n\n\t\t\tif (!structure.hasPdbChain(chain.getName())) {\n\t\t\t\tcontinue; // we can't do anything with a chain our domain\n\t\t\t}\n\n\t\t\tChain newChain;\n\t\t\tif (! structure.hasNonPolyChain(chain.getId())) {\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setId(chain.getId());\n\t\t\t\tnewChain.setName(chain.getName());\n\t\t\t\tnewChain.setEntityInfo(chain.getEntityInfo());\n\t\t\t\tstructure.addChain(newChain);\n\t\t\t} else {\n\t\t\t\tnewChain = structure.getNonPolyChain(chain.getId());\n\t\t\t}\n\t\t\tList<Group> ligands = StructureTools.filterLigands(chain.getAtomGroups());\n\t\t\tfor (Group group : ligands) {\n\t\t\t\tboolean shouldContain = true;\n\t\t\t\tif (strictLigandHandling) {\n\t\t\t\t\tshouldContain = false; // whether the ligand occurs within the domain\n\t\t\t\t\tfor (ResidueRange rr : rrs) {\n\t\t\t\t\t\tif (rr.contains(group.getResidueNumber(), map)) {\n\t\t\t\t\t\t\tshouldContain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean alreadyContains = newChain.getAtomGroups().contains(group); // we don't want to add duplicate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ligands\n\t\t\t\tif (shouldContain && !alreadyContains) {\n\n\t\t\t\t\tnewChain.addGroup(group);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build a more meaningful description for the new structure\n\t\tStringBuilder header = new StringBuilder();\n\t\theader.append(domain.getClassificationId());\n\t\tif (scopDatabase != null) {\n\t\t\tint sf = domain.getSuperfamilyId();\n\t\t\tScopDescription description = scopDatabase.getScopDescriptionBySunid(sf);\n\t\t\tif (description != null) {\n\t\t\t\theader.append(\" | \");\n\t\t\t\theader.append(description.getDescription());\n\t\t\t}\n\t\t}\n\t\tstructure.getPDBHeader().setDescription(header.toString());\n\n\t\treturn structure;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId) throws IOException, StructureException {\n\t\treturn getStructureForDomain(scopId, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\tScopDomain domain = scopDatabase.getDomainByScopID(scopId);\n\t\treturn getStructureForDomain(domain, scopDatabase);\n\t}\n\n\t/**\n\t * Send a signal to the cache that the system is shutting down. Notifies underlying SerializableCache instances to\n\t * flush themselves...\n\t */\n\tpublic void notifyShutdown() {\n\t\t// System.out.println(\" AtomCache got notify shutdown..\");\n\t\tif (pdpprovider != null) {\n\t\t\tif (pdpprovider instanceof RemotePDPProvider) {\n\t\t\t\tRemotePDPProvider remotePDP = (RemotePDPProvider) pdpprovider;\n\t\t\t\tremotePDP.flushCache();\n\t\t\t}\n\t\t}\n\n\t\t// todo: use a SCOP implementation that is backed by SerializableCache\n\t\tScopDatabase scopInstallation = ScopFactory.getSCOP();\n\t\tif (scopInstallation != null) {\n\t\t\tif (scopInstallation instanceof CachedRemoteScopInstallation) {\n\t\t\t\tCachedRemoteScopInstallation cacheScop = (CachedRemoteScopInstallation) scopInstallation;\n\t\t\t\tcacheScop.flushCache();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * set the location at which utility data should be cached.\n\t *\n\t * @param cachePath\n\t */\n\tpublic void setCachePath(String cachePath) {\n\t\tthis.cachePath = cachePath;\n\t}\n\n\tpublic void setFileParsingParams(FileParsingParameters params) {\n\t\tthis.params = params;\n\t}\n\n\n\t/**\n\t * <b>[Optional]</b> This method changes the behavior when obsolete entries\n\t * are requested. Current behaviors are:\n\t * <ul>\n\t * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n\t *   Throw a {@link StructureException} (the default)\n\t * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n\t *   Load the requested ID from the PDB's obsolete repository\n\t * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n\t *   Load the most recent version of the requested structure\n\t *\n\t * <p>This setting may be silently ignored by implementations which do not have\n\t * access to the server to determine whether an entry is obsolete, such as\n\t * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n\t * returned even this is FETCH_CURRENT if the entry is found locally.\n\t *\n\t * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n\t * @see #setFetchCurrent(boolean)\n\t * @since 4.0.0\n\t */\n\tpublic void setObsoleteBehavior(ObsoleteBehavior behavior) {\n\t\tobsoleteBehavior = behavior;\n\t}\n\n\t/**\n\t * Returns how this instance deals with obsolete entries. Note that this\n\t * setting may be ignored by some implementations or in some situations,\n\t * such as when {@link #isAutoFetch()} is false.\n\t *\n\t * <p>For most implementations, the default value is\n\t * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n\t *\n\t * @return The ObsoleteBehavior\n\t * @since 4.0.0\n\t */\n\tpublic ObsoleteBehavior getObsoleteBehavior() {\n\t\treturn obsoleteBehavior;\n\t}\n\n\t/**\n\t * Get the behavior for fetching files from the server\n\t * @return\n\t */\n\tpublic FetchBehavior getFetchBehavior() {\n\t\treturn fetchBehavior;\n\t}\n\t/**\n\t * Set the behavior for fetching files from the server\n\t * @param fetchBehavior\n\t */\n\tpublic void setFetchBehavior(FetchBehavior fetchBehavior) {\n\t\tthis.fetchBehavior = fetchBehavior;\n\t}\n\n\t/**\n\t * Set the path that is used to cache PDB files.\n\t *\n\t * @param path\n\t *            to a directory\n\t */\n\tpublic void setPath(String path) {\n\t\tthis.path = FileDownloadUtils.expandUserHome(path);\n\t}\n\n\tpublic void setPdpprovider(PDPProvider pdpprovider) {\n\t\tthis.pdpprovider = pdpprovider;\n\t}\n\n\t/**\n\t * @return the useMmCif\n\t */\n\tpublic boolean isUseMmCif() {\n\t\treturn useMmCif;\n\t}\n\n\t/**\n\t * @param useMmCif\n\t *            the useMmCif to set\n\t */\n\tpublic void setUseMmCif(boolean useMmCif) {\n\t\tthis.useMmCif = useMmCif;\n\t\t// Either way the user wants to use PDB or MMCIF\n\t\tthis.useMmtf = false;\n\t}\n\n\t/**\n\t * Set whether to use mmtf.\n\t * @param useMmtf the input boolean to set\n\t */\n\tpublic void setUseMmtf(boolean useMmtf) {\n\t\tthis.useMmtf = useMmtf;\n\t\tif(useMmtf){\n\t\t\tuseMmCif=false;\n\t\t}\n\n\t}\n\n\t/** Returns useMmtf flag\n\t *\n\t * @return true if will load data via mmtf file format\n\t */\n\tpublic boolean isUseMmtf(){\n\t\treturn this.useMmtf;\n\t}\n\n\tprivate boolean checkLoading(String name) {\n\t\treturn currentlyLoading.contains(name);\n\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the the {@link CathDatabase}\n\t * at {@link CathFactory#getCathDatabase()}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName) throws IOException, StructureException {\n\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the specified {@link CathDatabase}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName, CathDatabase cathInstall) throws IOException, StructureException {\n\n\t\tCathDomain cathDomain = cathInstall.getDomainByCathId(structureName.getIdentifier());\n\n\t\tStructure s = getStructureForPdbId(cathDomain.getIdentifier());\n\t\tStructure n = cathDomain.reduce(s);\n\n\t\t// add the ligands of the chain...\n\n\t\tChain newChain = n.getPolyChainByPDB(structureName.getChainId());\n\t\tList<Chain> origChains = s.getNonPolyChainsByPDB(structureName.getChainId());\n\t\tfor ( Chain origChain : origChains) {\n\t\t\tList<Group> ligands = origChain.getAtomGroups();\n\n\t\t\tfor (Group g : ligands) {\n\t\t\t\tif (!newChain.getAtomGroups().contains(g)) {\n\t\t\t\t\tnewChain.addGroup(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn n;\n\t}\n\n\tprotected void flagLoading(String name) {\n\t\tif (!currentlyLoading.contains(name)) {\n\n\t\t\tcurrentlyLoading.add(name);\n\t\t}\n\t}\n\n\tprotected void flagLoadingFinished(String name) {\n\n\t\tcurrentlyLoading.remove(name);\n\t}\n\n\t/**\n\t * Loads a structure directly by PDB ID\n\t * @param pdbId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {\n\t\tif(pdbId == null)\n\t\t\treturn null;\n\t\tif(pdbId.length() != 4) {\n\t\t\tthrow new StructureException(\"Unrecognized PDB ID: \"+pdbId);\n\t\t}\n\t\twhile (checkLoading(pdbId)) {\n\t\t\t// waiting for loading to be finished...\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(e.getMessage());\n\t\t\t}\n\n\t\t}\n\n\t\tStructure s;\n\t\tif (useMmtf) {\n\t\t\tlogger.debug(\"loading from mmtf\");\n\t\t\ts = loadStructureFromMmtfByPdbId(pdbId);\n\t\t}\n\t\telse if (useMmCif) {\n\t\t\tlogger.debug(\"loading from mmcif\");\n\t\t\ts = loadStructureFromCifByPdbId(pdbId);\n\t\t} else {\n\t\t\tlogger.debug(\"loading from pdb\");\n\t\t\ts = loadStructureFromPdbByPdbId(pdbId);\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * Load a {@link Structure} from MMTF either from the local file system.\n\t * @param pdbId the input PDB id\n\t * @return the {@link Structure} object of the parsed structure\n\t * @throws IOException error reading from Web or file system\n\t */\n\tprivate Structure loadStructureFromMmtfByPdbId(String pdbId) throws IOException {\n\t\tlogger.debug(\"Loading structure {} from mmtf file.\", pdbId);\n\t\tMMTFFileReader reader = new MMTFFileReader();\n\t\treader.setFetchBehavior(fetchBehavior);\n\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\tStructure structure = reader.getStructureById(pdbId.toLowerCase());\n\t\treturn structure;\n\t}\n\n\tprotected Structure loadStructureFromCifByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tlogger.debug(\"Loading structure {} from mmCIF file {}.\", pdbId, path);\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tMMCIFFileReader reader = new MMCIFFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\t\treader.setFileParsingParameters(params);\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprotected Structure loadStructureFromPdbByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tlogger.debug(\"Loading structure {} from PDB file {}.\", pdbId, path);\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tPDBFileReader reader = new PDBFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.TreeSet;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.align.client.StructureName;\nimport org.biojava.nbio.structure.cath.CathDatabase;\nimport org.biojava.nbio.structure.cath.CathDomain;\nimport org.biojava.nbio.structure.cath.CathFactory;\nimport org.biojava.nbio.structure.domain.PDPProvider;\nimport org.biojava.nbio.structure.domain.RemotePDPProvider;\nimport org.biojava.nbio.structure.io.*;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.core.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.nbio.structure.quaternary.BiologicalAssemblyTransformation;\nimport org.biojava.nbio.structure.scop.CachedRemoteScopInstallation;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopDescription;\nimport org.biojava.nbio.structure.scop.ScopDomain;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility class that provides easy access to Structure objects. If you are running a script that is frequently\n * re-using the same PDB structures, the AtomCache keeps an in-memory cache of the files for quicker access. The cache\n * is a soft-cache, this means it won't cause out of memory exceptions, but garbage collects the data if the Java\n * virtual machine needs to free up space. The AtomCache is thread-safe.\n *\n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Peter Rose\n * @since 3.0\n */\npublic class AtomCache {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(AtomCache.class);\n\n\t/**\n\t * The default output bioassembly style: if true the bioassemblies are multimodel,\n\t * if false the bioassemblies are flat with renamed chains for symmetry-partners.\n\t */\n\tpublic static final boolean DEFAULT_BIOASSEMBLY_STYLE = false;\n\n\tpublic static final String BIOL_ASSEMBLY_IDENTIFIER = \"BIO:\";\n\tpublic static final String CHAIN_NR_SYMBOL = \":\";\n\tpublic static final String CHAIN_SPLIT_SYMBOL = \".\";\n\n\tpublic static final String PDP_DOMAIN_IDENTIFIER = \"PDP:\";\n\n\tpublic static final String UNDERSCORE = \"_\";\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\tprotected FileParsingParameters params;\n\tprotected PDPProvider pdpprovider;\n\n\tprivate FetchBehavior fetchBehavior;\n\tprivate ObsoleteBehavior obsoleteBehavior;\n\n\tprivate String cachePath;\n\n\t// make sure IDs are loaded uniquely\n\tprivate Collection<String> currentlyLoading = Collections.synchronizedCollection(new TreeSet<String>());\n\n\tprivate String path;\n\n\t/**\n\t * The format for structure data to use.\n\t */\n\tprivate Format format;\n\tenum Format {\n\t\tPDB,\n\t\tMMCIF,\n\t\tMMTF,\n\t\tCIF,\n\t\tBCIF\n\t}\n\n\t/**\n\t * Default AtomCache constructor.\n\t *\n\t * Usually stores files in a temp directory, but this can be overriden by setting the PDB_DIR variable at runtime.\n\t *\n\t * @see UserConfiguration#UserConfiguration()\n\t */\n\tpublic AtomCache() {\n\t\tthis(new UserConfiguration());\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system. It will use the same value for pdbFilePath and cachePath.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t */\n\tpublic AtomCache(String pdbFilePath) {\n\t\tthis(pdbFilePath,pdbFilePath);\n\t}\n\n\t/**\n\t * Creates an instance of an AtomCache that is pointed to the a particular path in the file system.\n\t *\n\t * @param pdbFilePath\n\t *            a directory in the file system to use as a location to cache files.\n\t * @param cachePath\n\t */\n\tpublic AtomCache(String pdbFilePath, String cachePath) {\n\n\t\tlogger.debug(\"Initialising AtomCache with pdbFilePath={}, cachePath={}\",pdbFilePath, cachePath);\n\n\t\tif (!pdbFilePath.endsWith(FILE_SEPARATOR)) {\n\t\t\tpdbFilePath += FILE_SEPARATOR;\n\t\t}\n\n\t\t// we are caching the binary files that contain the PDBs gzipped\n\t\t// that is the most memory efficient way of caching...\n\t\t// set the input stream provider to caching mode\n\t\tSystem.setProperty(InputStreamProvider.CACHE_PROPERTY, \"true\");\n\n\t\tsetPath(pdbFilePath);\n\n\t\tthis.cachePath = cachePath;\n\n\t\tfetchBehavior = FetchBehavior.DEFAULT;\n\t\tobsoleteBehavior = ObsoleteBehavior.DEFAULT;\n\n\t\tcurrentlyLoading.clear();\n\t\tparams = new FileParsingParameters();\n\n\t\tsetUseMmtf(true);\n\t}\n\n\t/**\n\t * Creates a new AtomCache object based on the provided UserConfiguration.\n\t *\n\t * @param config\n\t *            the UserConfiguration to use for this cache.\n\t */\n\tpublic AtomCache(UserConfiguration config) {\n\t\tthis(config.getPdbFilePath(), config.getCacheFilePath());\n\t\tfetchBehavior = config.getFetchBehavior();\n\t\tobsoleteBehavior = config.getObsoleteBehavior();\n\n\t\tif (config.getFileFormat().equals(UserConfiguration.MMCIF_FORMAT)) {\n\t\t\tformat = Format.MMCIF;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the CA atoms for the provided name. See {@link #getStructure(String)} for supported naming conventions.\n\t * <p>\n\t * This method only works with protein chains. Use {@link #getRepresentativeAtoms(String)}\n\t * for a more general solution.\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getAtoms(String name) throws IOException, StructureException {\n\t\treturn getAtoms(new StructureName(name));\n\t}\n\tpublic Atom[] getAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\t// System.out.println(\"loading \" + name);\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getAtomCAArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\t/**\n\t * Returns the representative atoms for the provided name.\n\t * See {@link #getStructure(String)} for supported naming conventions.\n\t *\n\t * @param name\n\t * @return an array of Atoms.\n\t * @throws IOException\n\t * @throws StructureException\n\t * @see\n\t */\n\tpublic Atom[] getRepresentativeAtoms(String name) throws IOException, StructureException {\n\t\treturn getRepresentativeAtoms(new StructureName(name));\n\t}\n\n\tpublic Atom[] getRepresentativeAtoms(StructureIdentifier name) throws IOException, StructureException {\n\n\t\tAtom[] atoms = null;\n\n\t\tStructure s = getStructure(name);\n\n\t\tatoms = StructureTools.getRepresentativeAtomArray(s);\n\n\t\t/*\n\t\t * synchronized (cache){ cache.put(name, atoms); }\n\t\t */\n\n\t\treturn atoms;\n\t}\n\n\t/**\n\t * Returns the biological assembly for a given PDB ID and bioAssemblyId, by building the\n\t * assembly from the biounit annotations found in {@link Structure#getPDBHeader()}\n\t * <p>\n\t * Note, the number of available biological unit files\n\t * varies. Many entries don't have a biological assembly specified (e.g. NMR structures), many entries have only one\n\t * biological assembly (bioAssemblyId=1), and some structures have multiple biological assemblies.\n\t *\n\t * @param pdbId\n\t *            the PDB ID\n\t * @param bioAssemblyId\n\t *            the 1-based index of the biological assembly (0 gets the asymmetric unit)\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException if biassemblyId < 0 or other problems while loading structure\n\t * @author Peter Rose\n\t * @since 3.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, int bioAssemblyId, boolean multiModel)\n\t\t\tthrows StructureException, IOException {\n\n\t\tif (bioAssemblyId < 0) {\n\t\t\tthrow new StructureException(\"bioAssemblyID must be nonnegative: \" + pdbId + \" bioAssemblyId \"\n\t\t\t\t\t+ bioAssemblyId);\n\t\t}\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as biological assembly\", pdbId);\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\t// 0 ... asym unit\n\t\tif ( bioAssemblyId == 0) {\n\t\t\tlogger.info(\"Requested biological assembly 0 for PDB id \"+pdbId+\", returning asymmetric unit\");\n\t\t\treturn asymUnit;\n\t\t}\n\t\t// does it exist?\n\t\tif (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(bioAssemblyId)) {\n\t\t\tthrow new StructureException(\"No biological assembly available for biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\t\t}\n\n\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\n\t\t}\n\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\tboolean useAsymIds = false;\n\t\tif (format != Format.PDB) useAsymIds = true;\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\n\t}\n\n\t/**\n\t * Returns the default biological unit (bioassemblyId=1, known in PDB as pdb1.gz). If it is not available,\n\t * the asymmetric unit will be returned, e.g. for NMR structures.\n\t *\n\t * <p>Biological assemblies can also be accessed using\n\t * <tt>getStructure(\"BIO:<i>[pdbId]</i>\")</tt>\n\t * @param pdbId the PDB id\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return a structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t * @since 4.2\n\t */\n\tpublic Structure getBiologicalAssembly(String pdbId, boolean multiModel) throws StructureException, IOException {\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as biological assembly\", pdbId);\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\tint bioAssemblyId = 1;\n\n\t\t// does it exist?\n\t\tif (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(bioAssemblyId)) {\n\t\t\treturn asymUnit;\n\t\t}\n\n\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n\n\t\t}\n\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\tboolean useAsymIds = false;\n\t\tif (format != Format.PDB) useAsymIds = true;\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\n\t}\n\n\t/**\n\t * Returns all biological assemblies for given PDB id.\n\t * @param pdbId\n\t * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n\t * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n\t * @return\n\t * @throws StructureException\n\t * @throws IOException\n\t * @since 5.0\n\t */\n\tpublic List<Structure> getBiologicalAssemblies(String pdbId, boolean multiModel) throws StructureException, IOException {\n\n\t\tList<Structure> assemblies = new ArrayList<>();\n\n\t\tboolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n\n\t\tif (!getFileParsingParams().isParseBioAssembly()) {\n\t\t\tgetFileParsingParams().setParseBioAssembly(true);\n\t\t}\n\n\t\tStructure asymUnit = getStructureForPdbId(pdbId);\n\n\t\tgetFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n\n\n\t\tif (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies()==null) {\n\t\t\tlogger.info(\"No bioassembly information found for {}, returning asymmetric unit as the only biological assembly\", pdbId);\n\t\t\tassemblies.add(asymUnit);\n\t\t\treturn assemblies;\n\t\t}\n\n\n\t\tfor (int bioAssemblyId : asymUnit.getPDBHeader().getBioAssemblies().keySet()) {\n\t\t\tList<BiologicalAssemblyTransformation> transformations =\n\t\t\t\t\tasymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n\n\n\t\t\tif ( transformations == null || transformations.size() == 0){\n\n\t\t\t\tlogger.info(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId+\". Assembly id will be missing in biological assemblies.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\t\t// if we use mmcif or mmtf, then we need to pass useAsymIds=true\n\t\t\tboolean useAsymIds = false;\n\t\t\tif (format != Format.PDB) useAsymIds = true;\n\t\t\tStructure s = builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n\t\t\tassemblies.add(s);\n\t\t}\n\t\treturn assemblies;\n\t}\n\n\t/**\n\t * Returns the path that contains the caching file for utility data, such as domain definitions.\n\t *\n\t * @return\n\t */\n\tpublic String getCachePath() {\n\t\treturn cachePath;\n\t}\n\n\tpublic FileParsingParameters getFileParsingParams() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * Get the path that is used to cache PDB files.\n\t *\n\t * @return path to a directory\n\t */\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic PDPProvider getPdpprovider() {\n\t\treturn pdpprovider;\n\t}\n\n\t/**\n\t * Request a Structure based on a <i>name</i>.\n\t *\n\t * <pre>\n\t * \t\tFormal specification for how to specify the <i>name</i>:\n\t *\n\t * \t\tname     := pdbID\n\t * \t\t               | pdbID '.' chainID\n\t * \t\t               | pdbID '.' range\n\t * \t\t               | scopID\n\t * \t\trange         := '('? range (',' range)? ')'?\n\t * \t\t               | chainID\n\t * \t\t               | chainID '_' resNum '-' resNum\n\t * \t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t * \t\tchainID       := [a-zA-Z0-9]\n\t * \t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t * \t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\t *\n\t *\n\t * \t\tExample structures:\n\t * \t\t1TIM     #whole structure\n\t * \t\t4HHB.C     #single chain\n\t * \t\t4GCR.A_1-83     #one domain, by residue number\n\t * \t\t3AA0.A,B     #two chains treated as one structure\n\t * \t\td2bq6a1     #scop domain\n\t * </pre>\n\t *\n\t * With the additional set of rules:\n\t *\n\t * <ul>\n\t * <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model\n\t * only (for NMR).\n\t * <li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A</li>\n\t * <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names,\n\t * see {@link #setStrictSCOP(boolean)}</li>\n\t * <li>URLs are accepted as well</li>\n\t * </ul>\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException\n\t *             The PDB file cannot be cached due to IO errors\n\t * @throws StructureException\n\t *             The name appeared valid but did not correspond to a structure. Also thrown by some submethods upon\n\t *             errors, eg for poorly formatted subranges.\n\t */\n\tpublic Structure getStructure(String name) throws IOException, StructureException {\n\t\tStructureName structureName = new StructureName(name);\n\n\t\treturn getStructure(structureName);\n\t}\n\n\t/**\n\t * Get the structure corresponding to the given {@link StructureIdentifier}.\n\t * Equivalent to calling {@link StructureIdentifier#loadStructure(AtomCache)}\n\t * followed by {@link StructureIdentifier#reduce(Structure)}.\n\t *\n\t * <p>Note that this method should not be used in StructureIdentifier\n\t * implementations to avoid circular calls.\n\t * @param strucId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructure(StructureIdentifier strucId) throws IOException, StructureException {\n\t\tStructure s = strucId.loadStructure(this);\n\t\tStructure r = strucId.reduce(s);\n\t\tr.setStructureIdentifier(strucId);\n\t\treturn r;\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain) throws IOException, StructureException {\n\t\treturn getStructureForDomain(domain, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\treturn getStructureForDomain(domain, scopDatabase, false);\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param domain\n\t *            a SCOP domain\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @param strictLigandHandling\n\t *            If set to false, hetero-atoms are included if and only if they belong to a chain to which the SCOP\n\t *            domain belongs; if set to true, hetero-atoms are included if and only if they are strictly within the\n\t *            definition (residue numbers) of the SCOP domain\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(ScopDomain domain, ScopDatabase scopDatabase, boolean strictLigandHandling)\n\t\t\tthrows IOException, StructureException {\n\n\t\tString pdbId = domain.getPdbId();\n\t\tStructure fullStructure = getStructureForPdbId(pdbId);\n\t\tStructure structure = domain.reduce(fullStructure);\n\n\t\t// TODO It would be better to move all of this into the reduce method,\n\t\t// but that would require ligand handling properties in StructureIdentifiers\n\n\t\t// because ligands sometimes occur after TER records in PDB files, we may need to add some ligands back in\n\t\t// specifically, we add a ligand if and only if it occurs within the domain\n\t\tAtomPositionMap map = null;\n\t\tList<ResidueRangeAndLength> rrs = null;\n\t\tif (strictLigandHandling) {\n\t\t\tmap = new AtomPositionMap(StructureTools.getAllAtomArray(fullStructure), AtomPositionMap.ANYTHING_MATCHER);\n\t\t\trrs = ResidueRangeAndLength.parseMultiple(domain.getRanges(), map);\n\t\t}\n\t\tfor (Chain chain : fullStructure.getNonPolyChains()) {\n\n\t\t\tif (!structure.hasPdbChain(chain.getName())) {\n\t\t\t\tcontinue; // we can't do anything with a chain our domain\n\t\t\t}\n\n\t\t\tChain newChain;\n\t\t\tif (! structure.hasNonPolyChain(chain.getId())) {\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setId(chain.getId());\n\t\t\t\tnewChain.setName(chain.getName());\n\t\t\t\tnewChain.setEntityInfo(chain.getEntityInfo());\n\t\t\t\tstructure.addChain(newChain);\n\t\t\t} else {\n\t\t\t\tnewChain = structure.getNonPolyChain(chain.getId());\n\t\t\t}\n\t\t\tList<Group> ligands = StructureTools.filterLigands(chain.getAtomGroups());\n\t\t\tfor (Group group : ligands) {\n\t\t\t\tboolean shouldContain = true;\n\t\t\t\tif (strictLigandHandling) {\n\t\t\t\t\tshouldContain = false; // whether the ligand occurs within the domain\n\t\t\t\t\tfor (ResidueRange rr : rrs) {\n\t\t\t\t\t\tif (rr.contains(group.getResidueNumber(), map)) {\n\t\t\t\t\t\t\tshouldContain = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean alreadyContains = newChain.getAtomGroups().contains(group); // we don't want to add duplicate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ligands\n\t\t\t\tif (shouldContain && !alreadyContains) {\n\n\t\t\t\t\tnewChain.addGroup(group);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build a more meaningful description for the new structure\n\t\tStringBuilder header = new StringBuilder();\n\t\theader.append(domain.getClassificationId());\n\t\tif (scopDatabase != null) {\n\t\t\tint sf = domain.getSuperfamilyId();\n\t\t\tScopDescription description = scopDatabase.getScopDescriptionBySunid(sf);\n\t\t\tif (description != null) {\n\t\t\t\theader.append(\" | \");\n\t\t\t\theader.append(description.getDescription());\n\t\t\t}\n\t\t}\n\t\tstructure.getPDBHeader().setDescription(header.toString());\n\n\t\treturn structure;\n\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId) throws IOException, StructureException {\n\t\treturn getStructureForDomain(scopId, ScopFactory.getSCOP());\n\t}\n\n\t/**\n\t * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n\t *\n\t * @param scopId\n\t *            a SCOP Id\n\t * @param scopDatabase\n\t *            A {@link ScopDatabase} to use\n\t * @return a Structure object\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForDomain(String scopId, ScopDatabase scopDatabase) throws IOException,\n\t\t\tStructureException {\n\t\tScopDomain domain = scopDatabase.getDomainByScopID(scopId);\n\t\treturn getStructureForDomain(domain, scopDatabase);\n\t}\n\n\t/**\n\t * Send a signal to the cache that the system is shutting down. Notifies underlying SerializableCache instances to\n\t * flush themselves...\n\t */\n\tpublic void notifyShutdown() {\n\t\t// System.out.println(\" AtomCache got notify shutdown..\");\n\t\tif (pdpprovider != null) {\n\t\t\tif (pdpprovider instanceof RemotePDPProvider) {\n\t\t\t\tRemotePDPProvider remotePDP = (RemotePDPProvider) pdpprovider;\n\t\t\t\tremotePDP.flushCache();\n\t\t\t}\n\t\t}\n\n\t\t// todo: use a SCOP implementation that is backed by SerializableCache\n\t\tScopDatabase scopInstallation = ScopFactory.getSCOP();\n\t\tif (scopInstallation != null) {\n\t\t\tif (scopInstallation instanceof CachedRemoteScopInstallation) {\n\t\t\t\tCachedRemoteScopInstallation cacheScop = (CachedRemoteScopInstallation) scopInstallation;\n\t\t\t\tcacheScop.flushCache();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/**\n\t * set the location at which utility data should be cached.\n\t *\n\t * @param cachePath\n\t */\n\tpublic void setCachePath(String cachePath) {\n\t\tthis.cachePath = cachePath;\n\t}\n\n\tpublic void setFileParsingParams(FileParsingParameters params) {\n\t\tthis.params = params;\n\t}\n\n\n\t/**\n\t * <b>[Optional]</b> This method changes the behavior when obsolete entries\n\t * are requested. Current behaviors are:\n\t * <ul>\n\t * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n\t *   Throw a {@link StructureException} (the default)\n\t * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n\t *   Load the requested ID from the PDB's obsolete repository\n\t * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n\t *   Load the most recent version of the requested structure\n\t *\n\t * <p>This setting may be silently ignored by implementations which do not have\n\t * access to the server to determine whether an entry is obsolete, such as\n\t * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n\t * returned even this is FETCH_CURRENT if the entry is found locally.\n\t *\n\t * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n\t * @see #setFetchCurrent(boolean)\n\t * @since 4.0.0\n\t */\n\tpublic void setObsoleteBehavior(ObsoleteBehavior behavior) {\n\t\tobsoleteBehavior = behavior;\n\t}\n\n\t/**\n\t * Returns how this instance deals with obsolete entries. Note that this\n\t * setting may be ignored by some implementations or in some situations,\n\t * such as when {@link #isAutoFetch()} is false.\n\t *\n\t * <p>For most implementations, the default value is\n\t * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n\t *\n\t * @return The ObsoleteBehavior\n\t * @since 4.0.0\n\t */\n\tpublic ObsoleteBehavior getObsoleteBehavior() {\n\t\treturn obsoleteBehavior;\n\t}\n\n\t/**\n\t * Get the behavior for fetching files from the server\n\t * @return\n\t */\n\tpublic FetchBehavior getFetchBehavior() {\n\t\treturn fetchBehavior;\n\t}\n\t/**\n\t * Set the behavior for fetching files from the server\n\t * @param fetchBehavior\n\t */\n\tpublic void setFetchBehavior(FetchBehavior fetchBehavior) {\n\t\tthis.fetchBehavior = fetchBehavior;\n\t}\n\n\t/**\n\t * Set the path that is used to cache PDB files.\n\t *\n\t * @param path\n\t *            to a directory\n\t */\n\tpublic void setPath(String path) {\n\t\tthis.path = FileDownloadUtils.expandUserHome(path);\n\t}\n\n\tpublic void setPdpprovider(PDPProvider pdpprovider) {\n\t\tthis.pdpprovider = pdpprovider;\n\t}\n\n\t/**\n\t * @return the useMmCif\n\t */\n\tpublic boolean isUseMmCif() {\n\t\treturn format == Format.MMCIF;\n\t}\n\n\t/**\n\t * @param useMmCif\n\t *            the useMmCif to set\n\t */\n\tpublic void setUseMmCif(boolean useMmCif) {\n\t\tif (useMmCif) {\n\t\t\tthis.format = Format.MMCIF;\n\t\t}\n\t}\n\n\t/**\n\t * Set whether to use mmtf.\n\t * @param useMmtf the input boolean to set\n\t */\n\tpublic void setUseMmtf(boolean useMmtf) {\n\t\tif (useMmtf) {\n\t\t\tthis.format = Format.MMTF;\n\t\t}\n\t}\n\n\t/** Returns useMmtf flag\n\t *\n\t * @return true if will load data via mmtf file format\n\t */\n\tpublic boolean isUseMmtf(){\n\t\treturn this.format == Format.MMTF;\n\t}\n\n\t/**\n\t * The PDB flag.\n\t * @return true if legacy PDB parsing will be employed\n\t */\n\tpublic boolean isUsePdb() {\n\t\treturn this.format == Format.PDB;\n\t}\n\n\t/**\n\t * The experimental Bcif flag.\n\t * @return true if experimental Bcif parsing will be employed\n\t */\n\tpublic boolean isUseBcif() {\n\t\treturn this.format == Format.BCIF;\n\t}\n\n\t/**\n\t * The experimental Cif flag.\n\t * @return true if experimental Cif parsing will be employed\n\t */\n\tpublic boolean isUseCif() {\n\t\treturn this.format == Format.CIF;\n\t}\n\n\t/**\n\t * Use the experimental Bcif parser to acquire structure data.\n\t * @param useBcif use?\n\t */\n\tpublic void setUseBcif(boolean useBcif) {\n\t\tif (useBcif) {\n\t\t\tthis.format = Format.BCIF;\n\t\t}\n\t}\n\n\t/**\n\t * Use the experimental Cif parser to acquire structure data.\n\t * @param useCif use?\n\t */\n\tpublic void setUseCif(boolean useCif) {\n\t\tif (useCif) {\n\t\t\tthis.format = Format.CIF;\n\t\t}\n\t}\n\n\t/**\n\t * Use the legacy PDB format to acquire structure data.\n\t * @param usePdb use?\n\t */\n\tpublic void usePdb(boolean usePdb) {\n\t\tif (usePdb) {\n\t\t\tthis.format = Format.PDB;\n\t\t}\n\t}\n\n\tprivate boolean checkLoading(String name) {\n\t\treturn currentlyLoading.contains(name);\n\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the the {@link CathDatabase}\n\t * at {@link CathFactory#getCathDatabase()}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName) throws IOException, StructureException {\n\t\treturn getStructureForCathDomain(structureName, CathFactory.getCathDatabase());\n\t}\n\n\t/**\n\t * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the specified {@link CathDatabase}.\n\t */\n\tpublic Structure getStructureForCathDomain(StructureName structureName, CathDatabase cathInstall) throws IOException, StructureException {\n\n\t\tCathDomain cathDomain = cathInstall.getDomainByCathId(structureName.getIdentifier());\n\n\t\tStructure s = getStructureForPdbId(cathDomain.getIdentifier());\n\t\tStructure n = cathDomain.reduce(s);\n\n\t\t// add the ligands of the chain...\n\n\t\tChain newChain = n.getPolyChainByPDB(structureName.getChainId());\n\t\tList<Chain> origChains = s.getNonPolyChainsByPDB(structureName.getChainId());\n\t\tfor ( Chain origChain : origChains) {\n\t\t\tList<Group> ligands = origChain.getAtomGroups();\n\n\t\t\tfor (Group g : ligands) {\n\t\t\t\tif (!newChain.getAtomGroups().contains(g)) {\n\t\t\t\t\tnewChain.addGroup(g);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn n;\n\t}\n\n\tprotected void flagLoading(String name) {\n\t\tif (!currentlyLoading.contains(name)) {\n\n\t\t\tcurrentlyLoading.add(name);\n\t\t}\n\t}\n\n\tprotected void flagLoadingFinished(String name) {\n\n\t\tcurrentlyLoading.remove(name);\n\t}\n\n\t/**\n\t * Loads a structure directly by PDB ID\n\t * @param pdbId\n\t * @return\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\tpublic Structure getStructureForPdbId(String pdbId) throws IOException, StructureException {\n\t\tif(pdbId == null)\n\t\t\treturn null;\n\t\tif(pdbId.length() != 4) {\n\t\t\tthrow new StructureException(\"Unrecognized PDB ID: \"+pdbId);\n\t\t}\n\t\twhile (checkLoading(pdbId)) {\n\t\t\t// waiting for loading to be finished...\n\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(e.getMessage());\n\t\t\t}\n\n\t\t}\n\n\t\tswitch (format) {\n\t\t\tcase MMTF:\n\t\t\t\tlogger.debug(\"loading from mmtf\");\n\t\t\t\treturn loadStructureFromMmtfByPdbId(pdbId);\n\t\t\tcase MMCIF:\n\t\t\t\tlogger.debug(\"loading from mmcif\");\n\t\t\t\treturn loadStructureFromCifByPdbId(pdbId);\n\t\t\tcase CIF:\n\t\t\t\tlogger.debug(\"loading from experimental cif\");\n\t\t\t\treturn loadStructureFromExperimentalCifByPdbId(pdbId);\n\t\t\tcase PDB:\n\t\t\t\tlogger.debug(\"loading from pdb\");\n\t\t\t\treturn loadStructureFromPdbByPdbId(pdbId);\n\t\t\tcase BCIF:\n\t\t\t\tlogger.debug(\"loading from bcif\");\n\t\t\t\treturn loadStructureFromBcifByPdbId(pdbId);\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"no strategy implemented for format \" + format);\n\t\t}\n\t}\n\n\t/**\n\t * Load a {@link Structure} from MMTF either from the local file system.\n\t * @param pdbId the input PDB id\n\t * @return the {@link Structure} object of the parsed structure\n\t * @throws IOException error reading from Web or file system\n\t */\n\tprivate Structure loadStructureFromMmtfByPdbId(String pdbId) throws IOException {\n\t\tlogger.debug(\"Loading structure {} from mmtf file.\", pdbId);\n\t\tMMTFFileReader reader = new MMTFFileReader();\n\t\treader.setFetchBehavior(fetchBehavior);\n\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\tStructure structure = reader.getStructureById(pdbId.toLowerCase());\n\t\treturn structure;\n\t}\n\n\tprivate Structure loadStructureFromBcifByPdbId(String pdbId) throws IOException {\n\t\tlogger.debug(\"Loading structure {} from Bcif file.\", pdbId);\n\t\tBcifFileReader reader = new BcifFileReader();\n\t\treader.setFetchBehavior(fetchBehavior);\n\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\treturn reader.getStructureById(pdbId.toLowerCase());\n\t}\n\n\tprivate Structure loadStructureFromExperimentalCifByPdbId(String pdbId) throws IOException {\n\t\tlogger.debug(\"Loading structure {} experimentally from Cif file.\", pdbId);\n\t\tCifFileReader reader = new CifFileReader();\n\t\treader.setFetchBehavior(fetchBehavior);\n\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\treturn reader.getStructureById(pdbId.toLowerCase());\n\t}\n\n\tprotected Structure loadStructureFromCifByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tlogger.debug(\"Loading structure {} from mmCIF file {}.\", pdbId, path);\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tMMCIFFileReader reader = new MMCIFFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\t\t\treader.setFileParsingParameters(params);\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tprotected Structure loadStructureFromPdbByPdbId(String pdbId) throws IOException, StructureException {\n\n\t\tlogger.debug(\"Loading structure {} from PDB file {}.\", pdbId, path);\n\t\tStructure s;\n\t\tflagLoading(pdbId);\n\t\ttry {\n\t\t\tPDBFileReader reader = new PDBFileReader(path);\n\t\t\treader.setFetchBehavior(fetchBehavior);\n\t\t\treader.setObsoleteBehavior(obsoleteBehavior);\n\n\t\t\treader.setFileParsingParameters(params);\n\n\t\t\ts = reader.getStructureById(pdbId.toLowerCase());\n\n\t\t} finally {\n\t\t\tflagLoadingFinished(pdbId);\n\t\t}\n\n\t\treturn s;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.biojava.nbio.core.util.FileDownloadUtils;\nimport org.biojava.nbio.structure.AtomPositionMap;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueRangeAndLength;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.StructureIdentifier;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.SubstructureIdentifier;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.FetchBehavior;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory.ObsoleteBehavior;\nimport org.biojava.nbio.structure.io.MMCIFFileReader;\nimport org.biojava.nbio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.nbio.structure.io.mmcif.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.biojava.nbio.structure.test.util.GlobalsHelper;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * A test for {@link AtomCache}.\n * @author dmyerstu\n * @since 3.0.6\n */\npublic class AtomCacheTest {\n\n\tprivate static Logger logger = LoggerFactory.getLogger(AtomCacheTest.class);\n\tprivate AtomCache cache;\n\n\t@Before\n\tpublic void setUp() {\n\t\tGlobalsHelper.pushState();\n\n\t\tcache = new AtomCache();\n\t\tcache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n\t\tStructureIO.setAtomCache(cache);\n\n\t\t// Use a fixed SCOP version for stability\n\t\tScopFactory.setScopDatabase(ScopFactory.VERSION_1_75B);\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t\tGlobalsHelper.restoreState();\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with no ligands but an explicit range (not whole-chain).\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain1() throws IOException, StructureException {\n\t\tString ranges = \"A:328-396,B:518-527\";\n\t\tStructure whole = cache.getStructure(\"1h6w\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthA = rrs.get(0).getLength();\n\t\tint expectedLengthB = rrs.get(1).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1h6w.2\");\n\t\tassertEquals(2, structure.getPolyChains().size());\n\t\tChain a = structure.getPolyChainByPDB(\"A\");\n\t\tChain b = structure.getPolyChainByPDB(\"B\");\n\t\tassertEquals(expectedLengthA, a.getAtomGroups().size());\n\t\tassertEquals(expectedLengthB, b.getAtomGroups().size());\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with two zinc ligands that occurs after the TER. The ligands are in chains E and F, so they should not be included in the domain.\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain2() throws IOException, StructureException {\n\t\tString ranges = \"A:,B:\";\n\t\tStructure whole = cache.getStructure(\"1I3O\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthA = rrs.get(0).getLength();\n\t\tint expectedLengthB = rrs.get(1).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1i3o.1\");\n\t\tassertEquals(2, structure.getPolyChains().size());\n\t\tChain a = structure.getPolyChainByPDB(\"A\");\n\t\tChain b = structure.getPolyChainByPDB(\"B\");\n\t\t// since biojava 5.0 we have no ligand or water molecules in the polymer chains, we have to subtract the 3 water molecules\n\t\tassertEquals(expectedLengthA - 3, a.getAtomGroups().size());\n\t\t// since biojava 5.0 we have no ligand or water molecules in the polymer chains, we have to subtract the 4 water molecules\n\t\tassertEquals(expectedLengthB - 4, b.getAtomGroups().size());\n\t\tList<Group> ligandsA = StructureTools.filterLigands(b.getAtomGroups());\n\t\tassertEquals(0, ligandsA.size());\n\t\tList<Group> ligandsB = StructureTools.filterLigands(b.getAtomGroups());\n\t\tassertEquals(0, ligandsB.size());\n\t}\n\n\t/**\n\t * Tests {@link AtomCache#getStructureForDomain(String)} on a single-chain domain with two zinc ligands that occurs after the TER.\n\t */\n\t@Test\n\tpublic void testGetStructureForDomain3() throws IOException, StructureException {\n\t\tString ranges = \"E:\";\n\t\tStructure whole = cache.getStructure(\"1I3O\");\n\t\tAtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n\t\tList<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n\t\tint expectedLengthE = rrs.get(0).getLength();\n\t\tStructure structure = cache.getStructureForDomain(\"d1i3oe_\");\n\t\tassertEquals(1, structure.getPolyChains().size());\n\t\tChain e = structure.getPolyChainByPDB(\"E\");\n\t\t// since biojava 5.0 we have no ligand molecules in the polymer chains, we have to subtract the 2 zinc molecules\n\t\tassertEquals(expectedLengthE - 2, e.getAtomGroups().size());\n\n\t\tChain eligands = structure.getNonPolyChainsByPDB(\"E\").get(0);\n\t\tList<Group> ligandsE = StructureTools.filterLigands(eligands.getAtomGroups());\n\t\tassertEquals(1, ligandsE.size());\n\t}\n\n\t/**\n\t * Test parsing of chain-less ranges (present in SCOP < 1.73)\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testGetStructureForChainlessDomains() throws IOException, StructureException {\n\t\tScopDatabase scop = ScopFactory.getSCOP(ScopFactory.VERSION_1_71); // Uses the range '1-135' without a chain\n\t\tStructure structure = cache.getStructureForDomain(\"d1hcy_1\",scop);\n\n\t\t//System.out.println(cache.getStructure(\"1hcy\"));\n\t\t//System.out.println(structure);\n\t\tassertEquals(1, structure.getPolyChains().size());\n\t\tChain a = structure.getPolyChainByPDB(\"A\");\n\t\tint expectedLengthA = 135;\n\t\tassertEquals(expectedLengthA, a.getAtomGroups().size());\n\n\n\t\tassertTrue(structure.hasNonPolyChain(\"G\"));\n\t\tassertTrue(structure.hasNonPolyChain(\"H\"));\n\n\t\tChain copper  = structure.getNonPolyChain(\"I\");\n\t\tassertEquals(1,copper.getAtomGroups().size());\n\n\t}\n\n\t@Test\n\tpublic void testSetPath_withTilde() throws Exception {\n\t\tcache.setPath(\"~\" + File.separator);\n\n\t\tassertEquals(System.getProperty(\"user.home\") + File.separator, cache.getPath());\n\t}\n\n\t@Test\n\tpublic void testNewInstanceWithTilder() throws Exception {\n\t\tAtomCache cache1 = new AtomCache(\"~\" + File.separator);\n\n\t\tassertEquals(System.getProperty(\"user.home\") + File.separator, cache1.getPath());\n\t}\n\n\t@Test\n\tpublic void testFetchBehavior() throws IOException, ParseException {\n\t\t// really more of a LocalPDBDirectory test, but throw it in with AtomCache\n\t\tString pdbId = \"1hh0\"; // A small structure, since we download it multiple times\n\t\tLocalPDBDirectory reader = new MMCIFFileReader(cache.getPath());\n\n\t\t// delete\n\t\treader.deleteStructure(pdbId);\n\t\tassertNull(\"Failed to delete previous version\",reader.getLocalFile(pdbId));\n\n\t\t// LOCAL_ONLY fails\n\t\treader.setFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\tStructure s;\n\t\ttry {\n\t\t\ts = reader.getStructureById(pdbId);\n\t\t\tfail(\"LOCAL_ONLY shouldn't download files\");\n\t\t} catch(IOException e) {\n\t\t\tassertTrue(\"Wrong IOException reason\", e.getMessage().contains(\"configured not to download\"));\n\t\t}\n\n\t\t// delete\n\t\treader.deleteStructure(pdbId);\n\t\tassertNull(\"Failed to delete previous version\",reader.getLocalFile(pdbId));\n\n\t\t// fetch from server\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_FILES);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tFile location = reader.getLocalFile(pdbId);\n\n\t\tlong prerem = LocalPDBDirectory.LAST_REMEDIATION_DATE-1000*60*60*25; // 25 hours before the remediation\n\t\tlocation.setLastModified(prerem);\n\t\tassertEquals(prerem,location.lastModified()); //sanity check\n\n\t\t// force refetching\n\t\treader.setFetchBehavior(FetchBehavior.FORCE_DOWNLOAD);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tlong currMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod > prerem);\n\n\t\t// Now LOCAL_ONLY should work\n\t\treader.setFetchBehavior(FetchBehavior.LOCAL_ONLY);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\n\t\t// Check remediation\n\t\tlocation.setLastModified(prerem);\n\n\t\t// Shouldn't re-fetch\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_FILES);\n\t\ts = reader.getStructureById(pdbId);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tassertEquals(\"Falsely re-downloaded\", prerem,location.lastModified());\n\n\t\t// Now should re-fetch\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_REMEDIATED);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tassertTrue(location.exists());\n\t\tcurrMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod > prerem);\n\n\t\t// test FETCH_IF_OUTDATED: change existing file timestamp to 2000 and try refetching (the file is from March 2009)\n\t\tSimpleDateFormat formatter = new SimpleDateFormat(\"yyyy/MM/dd\", Locale.US);\n\t\tDate d = formatter.parse(\"2000/01/01\");\n\t\tlocation.setLastModified(d.getTime());\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_IF_OUTDATED);\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertNotNull(\"Failed to fetch structure\",s);\n\t\tcurrMod = location.lastModified();\n\t\tassertTrue(\"Not re-downloaded\", currMod>d.getTime());\n\n\t\t// try again: should not download\n\t\treader.setFetchBehavior(FetchBehavior.FETCH_IF_OUTDATED);\n\t\tlocation = reader.getLocalFile(pdbId);\n\t\tcurrMod = location.lastModified();\n\t\ts = reader.getStructureById(pdbId);\n\t\tassertEquals(\"Falsely re-downloaded\", currMod, location.lastModified());\n\n\t}\n\n\t@Test\n\tpublic void testSeqRes() throws StructureException, IOException {\n\t\tString name;\n\t\tStructureIdentifier id;\n\t\tStructure full, reduced;\n\t\tChain chain;\n\t\tList<Group> seqres;\n\n\t\t// normal structure\n\t\tname = \"1hh0\";\n\t\tid = new SubstructureIdentifier(name);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\n\t\t// single chain\n\t\tname = \"1hh0.A\";\n\t\tid = new SubstructureIdentifier(name);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\n\t\t// subrange\n\t\tname = \"1hh0.A:10-20\";\n\t\tid = new SubstructureIdentifier(name);\n\n\t\tfull = id.loadStructure(cache);\n\t\tassertEquals(\"Wrong number of models in full \"+name,1,full.nrModels());\n\t\tassertEquals(\"Wrong number of chains in full \"+name,1,full.getChains().size());\n\t\tchain = full.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in full \"+name,46,seqres.size());\n\t\tassertEquals(\"Wrong SeqNum at first group in full\",1,(int)chain.getAtomGroup(0).getResidueNumber().getSeqNum());\n\n\t\treduced = id.reduce(full);\n\t\tassertEquals(\"Wrong number of models in reduced \"+name,1,reduced.nrModels());\n\t\tassertEquals(\"Wrong number of chains in reduced \"+name,1,reduced.getChains().size());\n\t\tchain = reduced.getChainByIndex(0);\n\t\tseqres = chain.getSeqResGroups();\n\t\tassertEquals(\"Wrong seqres length in reduced \"+name,46,seqres.size());\n\n\t\tassertEquals(\"Wrong SeqNum at first group in reduced\",10,(int)chain.getAtomGroup(0).getResidueNumber().getSeqNum());\n\n\t}\n\n\t/**\n\t * Test for #703 - Chemical component cache poisoning\n\t *\n\t * Handle empty CIF files\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testEmptyChemComp() throws IOException, StructureException {\n\t\tPath tmpCache = Paths.get(System.getProperty(\"java.io.tmpdir\"),\"BIOJAVA_TEST_CACHE\");\n\t\tlogger.info(\"Testing AtomCache at {}\", tmpCache.toString());\n\t\tSystem.setProperty(UserConfiguration.PDB_DIR, tmpCache.toString());\n\t\tSystem.setProperty(UserConfiguration.PDB_CACHE_DIR, tmpCache.toString());\n\n\t\tFileDownloadUtils.deleteDirectory(tmpCache);\n\t\tFiles.createDirectory(tmpCache);\n\t\ttry {\n\t\t\tcache.setPath(tmpCache.toString());\n\t\t\tcache.setCachePath(tmpCache.toString());\n\t\t\tcache.setUseMmCif(true);\n\t\t\tChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider(tmpCache.toString()));\n\n\t\t\t// Create an empty chemcomp\n\t\t\tPath chemCompCif = tmpCache.resolve(Paths.get(\"chemcomp\", \"ATP.cif.gz\"));\n\t\t\tFiles.createDirectories(chemCompCif.getParent());\n\t\t\tFiles.createFile(chemCompCif);\n\t\t\tassertTrue(Files.exists(chemCompCif));\n\t\t\tassertEquals(0, Files.size(chemCompCif));\n\n\t\t\t// Copy stub file into place\n\t\t\tPath testCif = tmpCache.resolve(Paths.get(\"data\", \"structures\", \"divided\", \"mmCIF\", \"ab\",\"1abc.cif.gz\"));\n\t\t\tFiles.createDirectories(testCif.getParent());\n\t\t\tURL resource = AtomCacheTest.class.getResource(\"/atp.cif.gz\");\n\t\t\tFile src = new File(resource.getPath());\n\t\t\tFileDownloadUtils.copy(src, testCif.toFile());\n\n\t\t\t// Load structure\n\t\t\tStructure s = cache.getStructure(\"1ABC\");\n\n\t\t\t// Should have re-downloaded the file\n\t\t\tassertTrue(Files.size(chemCompCif) > LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n\n\t\t\t// Structure should have valid ChemComp now\n\t\t\tassertNotNull(s);\n\n\t\t\tGroup g = s.getChain(\"A\").getAtomGroup(0);\n\t\t\tassertTrue(g.getPDBName().equals(\"ATP\"));\n\n\t\t\t// should be unknown\n\t\t\tChemComp chem = g.getChemComp();\n\t\t\tassertNotNull(chem);\n\t\t\tassertTrue(chem.getAtoms().size() > 0);\n\t\t\tassertEquals(\"NON-POLYMER\", chem.getType());\n\t\t} finally {\n\t\t\tFileDownloadUtils.deleteDirectory(tmpCache);\n\t\t}\n\t}\n\n\t/**\n\t * Test for #703 - Chemical component cache poisoning\n\t *\n\t * Handle empty CIF files\n\t * @throws IOException\n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testEmptyGZChemComp() throws IOException, StructureException {\n\n\t\tPath tmpCache = Paths.get(System.getProperty(\"java.io.tmpdir\"),\"BIOJAVA_TEST_CACHE\");\n\t\tlogger.info(\"Testing AtomCache at {}\", tmpCache.toString());\n\t\tSystem.setProperty(UserConfiguration.PDB_DIR, tmpCache.toString());\n\t\tSystem.setProperty(UserConfiguration.PDB_CACHE_DIR, tmpCache.toString());\n\n\t\tFileDownloadUtils.deleteDirectory(tmpCache);\n\t\tFiles.createDirectory(tmpCache);\n\t\ttry {\n\t\t\tcache.setPath(tmpCache.toString());\n\t\t\tcache.setCachePath(tmpCache.toString());\n\t\t\tcache.setUseMmCif(true);\n\t\t\tChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider(tmpCache.toString()));\n\n\n\t\t\t// Create an empty chemcomp\n\t\t\tPath sub = tmpCache.resolve(Paths.get(\"chemcomp\", \"ATP.cif.gz\"));\n\t\t\tFiles.createDirectories(sub.getParent());\n\t\t\ttry(GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(sub.toFile()))) {\n\t\t\t\t// don't write anything\n\t\t\t\tout.flush();\n\t\t\t}\n\t\t\tassertTrue(Files.exists(sub));\n\t\t\tassertTrue(0 < Files.size(sub) && Files.size(sub) < LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n\n\t\t\t// Copy stub file into place\n\t\t\tPath testCif = tmpCache.resolve(Paths.get(\"data\", \"structures\", \"divided\", \"mmCIF\", \"ab\",\"1abc.cif.gz\"));\n\t\t\tFiles.createDirectories(testCif.getParent());\n\t\t\tURL resource = AtomCacheTest.class.getResource(\"/atp.cif.gz\");\n\t\t\tFile src = new File(resource.getPath());\n\t\t\tFileDownloadUtils.copy(src, testCif.toFile());\n\n\t\t\t// Load structure\n\t\t\tStructure s = cache.getStructure(\"1ABC\");\n\n\t\t\t// Should have re-downloaded the file\n\t\t\tassertTrue(Files.size(sub) > LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n\n\t\t\t// Structure should have valid ChemComp\n\t\t\tassertNotNull(s);\n\n\t\t\tGroup g = s.getChain(\"A\").getAtomGroup(0);\n\t\t\tassertTrue(g.getPDBName().equals(\"ATP\"));\n\n\t\t\t// should be unknown\n\t\t\tChemComp chem = g.getChemComp();\n\t\t\tassertNotNull(chem);\n\t\t\tassertTrue(chem.getAtoms().size() > 0);\n\t\t\tassertEquals(\"NON-POLYMER\", chem.getType());\n\t\t} finally {\n\t\t\tFileDownloadUtils.deleteDirectory(tmpCache);\n\t\t}\n\t}\n\n}\n","changedTest":"","commitMessage":"reading and writing of Cif/Bcif files, integration\n","test_commitMessage":"","allZero":false}