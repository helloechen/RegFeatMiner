{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/XMLHelper.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/XMLHelperTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.XMLConstants;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.util.ArrayList;\n\nimport static org.biojava.nbio.core.sequence.io.util.IOUtils.close;\nimport static org.biojava.nbio.core.sequence.io.util.IOUtils.openFile;\n\n/**\n * Helper methods to simplify boilerplate XML parsing code for  {@code}org.w3c.dom{@code} XML objects\n * @author Scooter\n */\npublic class XMLHelper {\n\n\t/**\n\t * Creates a new element called {@code}elementName{@code} and adds it to {@code}parentElement{@code}\n\t * @param parentElement\n\t * @param elementName\n\t * @return the new child element\n\t */\n\tpublic static Element addChildElement(Element parentElement, String elementName) {\n\t\tElement childElement = parentElement.getOwnerDocument().createElement(elementName);\n\t\tparentElement.appendChild(childElement);\n\t\treturn childElement;\n\t}\n\n\t/**\n\t * Create a new, empty {@code}org.w3c.dom.Document{@code}\n\t * @return a new {@code}org.w3c.dom.Document{@code}\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document getNewDocument() throws ParserConfigurationException  {\n\n\t\t//Create instance of DocumentBuilderFactory\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t//Get the DocumentBuilder\n\t\tDocumentBuilder docBuilder = factory.newDocumentBuilder();\n\t\t//Create blank DOM Document\n\t\tDocument doc = docBuilder.newDocument();\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Given a path to an XML file, parses into an {@code}org.w3c.dom.Document{@code} \n\t * @param fileName path to a readable XML file\n\t * @return\n\t * @throws SAXException\n\t * @throws IOException\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document loadXML(String fileName) throws SAXException, IOException, ParserConfigurationException  {\n\t\tInputStream is = openFile(new File(fileName));\n\t\tDocument doc = inputStreamToDocument(new BufferedInputStream(is));\n\t\tclose(is);\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Creates an {@code}org.w3c.dom.Document{@code} from the content of the {@code}inputStream{@code}\n\t * @param inputStream\n\t * @return a {@code}Document{@code}\n\t * @throws SAXException\n\t * @throws IOException\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document inputStreamToDocument(InputStream inputStream) throws SAXException, IOException, ParserConfigurationException  {\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n\t\tdbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n\t\tDocument doc = db.parse(inputStream);\n\t\tdoc.getDocumentElement().normalize();\n\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Given an {@code}org.w3c.dom.Document{@code}, writes it to the given {@code}outputStream{@code}\n\t * @param document\n\t * @param outputStream\n\t * @throws TransformerException\n\t */\n\tpublic static void outputToStream(Document document, OutputStream outputStream) throws TransformerException {\n\t\t// Use a Transformer for output\n\t\tTransformerFactory tFactory = TransformerFactory.newInstance();\n\t\tTransformer transformer = tFactory.newTransformer();\n\t\t//    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n\t\tDOMSource source = new DOMSource(document);\n\t\tStreamResult result = new StreamResult(outputStream);\n\t\ttransformer.transform(source, result);\n\t}\n\n\t//static XPath xpath = XPathFactory.newInstance().newXPath();\n\n\t/**\n\t * Given an element, searches upwards through ancestor Elements till the first Element\n\t * matching the requests {@code}parentName{@code} is found.\n\t * @param element The starting element\n\t * @param parentName The tag name of the requested Element.\n\t * @return The found element, or {@code}null{@code} if no matching element is found,\n\t */\n\tpublic static Element selectParentElement(Element element, String parentName) {\n\t\t\n\t    Node parentNode =  element.getParentNode();\n\t\tif (parentNode == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// check that parent is actually an element, else return null\n\t\t// this is to prevent ClassCastExceptions if element's parent is not an Element.\n\t\tElement parentElement = null;\n\t\tif (Node.ELEMENT_NODE == parentNode.getNodeType()){\n\t\t\tparentElement = (Element)parentNode;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tif (parentElement.getTagName().equals(parentName)) {\n\t\t\treturn parentElement;\n\t\t}\n\t\treturn selectParentElement(parentElement, parentName);\n\t}\n\n\t/**\n\t * If {@code}xpathExpression{@code} is a plain string with no '/' characterr, this is \n\t * interpreted as a child element name to search for. \n\t * <b/>\n\t * If {@code}xpathExpression{@code} is an XPath expression, this is evaluated and is assumed\n\t * to identify a single element.\n\t * @param element\n\t * @param xpathExpression\n\t * @return A single element or null if no match or the 1st match if matches more than 1\n\t * @throws XPathExpressionException\n\t */\n\tpublic static Element selectSingleElement(Element element, String xpathExpression) throws XPathExpressionException {\n\t\tif (element == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (xpathExpression.indexOf(\"/\") == -1) {\n\t\t\tNodeList nodeList = element.getChildNodes();\n\t\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n\t\t\t\t\treturn (Element) node;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//  NodeList nodes = element.getElementsByTagName(xpathExpression);\n\t\t\t//  if (nodes.getLength() > 0) {\n\t\t\t//      return (Element) nodes.item(0);\n\t\t\t//  } else {\n\t\t\treturn null;\n\t\t\t//  }\n\t\t} else {\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tElement node = (Element) xpath.evaluate(xpathExpression, element, XPathConstants.NODE);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a list of elements matching {@code}xpathExpression{@code}. If xpathExpression lacks\n\t * a '/' character, only immediate children o {@code}element{@code} are searched over.\n\t * <br/>\n\t * If {@code}xpathExpression{@code} contains an '/' character, a full XPath search is made\n\t * @param element\n\t * @param xpathExpression\n\t * @return A possibly empty but non-null {@code}ArrayList{@code}\n\t * @throws XPathExpressionException\n\t */\n\tpublic static ArrayList<Element> selectElements(Element element, String xpathExpression) throws XPathExpressionException {\n\t\tArrayList<Element> resultVector = new ArrayList<Element>();\n\t\tif (element == null) {\n\t\t\treturn resultVector;\n\t\t}\n\t\tif (xpathExpression.indexOf(\"/\") == -1) {\n\t\t\tNodeList nodeList = element.getChildNodes();\n\t\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n\t\t\t\t\tresultVector.add((Element) node);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(xpathExpression, element, XPathConstants.NODESET);\n\n\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n\t\t\t\tNode node = nodes.item(i);\n\t\t\t\tresultVector.add((Element) node);\n\t\t\t}\n\t\t}\n\t\treturn resultVector;\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.util;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.XMLConstants;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.*;\nimport java.util.ArrayList;\n\nimport static org.biojava.nbio.core.sequence.io.util.IOUtils.close;\nimport static org.biojava.nbio.core.sequence.io.util.IOUtils.openFile;\n\n/**\n * Helper methods to simplify boilerplate XML parsing code for  {@code}org.w3c.dom{@code} XML objects\n * @author Scooter\n */\npublic class XMLHelper {\n\n\t/**\n\t * Creates a new element called {@code}elementName{@code} and adds it to {@code}parentElement{@code}\n\t * @param parentElement\n\t * @param elementName\n\t * @return the new child element\n\t */\n\tpublic static Element addChildElement(Element parentElement, String elementName) {\n\t\tElement childElement = parentElement.getOwnerDocument().createElement(elementName);\n\t\tparentElement.appendChild(childElement);\n\t\treturn childElement;\n\t}\n\n\t/**\n\t * Create a new, empty {@code}org.w3c.dom.Document{@code}\n\t * @return a new {@code}org.w3c.dom.Document{@code}\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document getNewDocument() throws ParserConfigurationException  {\n\n\t\t//Create instance of DocumentBuilderFactory\n\t\tDocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n\t\t//Get the DocumentBuilder\n\t\tDocumentBuilder docBuilder = factory.newDocumentBuilder();\n\t\t//Create blank DOM Document\n\t\tDocument doc = docBuilder.newDocument();\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Given a path to an XML file, parses into an {@code}org.w3c.dom.Document{@code} \n\t * @param fileName path to a readable XML file\n\t * @return\n\t * @throws SAXException\n\t * @throws IOException\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document loadXML(String fileName) throws SAXException, IOException, ParserConfigurationException  {\n\t\tInputStream is = openFile(new File(fileName));\n\t\tDocument doc = inputStreamToDocument(new BufferedInputStream(is));\n\t\tclose(is);\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Creates an {@code}org.w3c.dom.Document{@code} from the content of the {@code}inputStream{@code}\n\t * @param inputStream\n\t * @return a {@code}Document{@code}\n\t * @throws SAXException\n\t * @throws IOException\n\t * @throws ParserConfigurationException\n\t */\n\tpublic static Document inputStreamToDocument(InputStream inputStream) throws SAXException, IOException, ParserConfigurationException  {\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\n\t\tDocumentBuilder db = dbf.newDocumentBuilder();\n\t\tdbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n\t\tDocument doc = db.parse(inputStream);\n\t\tdoc.getDocumentElement().normalize();\n\n\t\treturn doc;\n\t}\n\n\t/**\n\t * Given an {@code}org.w3c.dom.Document{@code}, writes it to the given {@code}outputStream{@code}\n\t * @param document\n\t * @param outputStream\n\t * @throws TransformerException\n\t */\n\tpublic static void outputToStream(Document document, OutputStream outputStream) throws TransformerException {\n\t\t// Use a Transformer for output\n\t\tTransformerFactory tFactory = TransformerFactory.newInstance();\n\t\tTransformer transformer = tFactory.newTransformer();\n\t\t//    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\n\t\tDOMSource source = new DOMSource(document);\n\t\tStreamResult result = new StreamResult(outputStream);\n\t\ttransformer.transform(source, result);\n\t}\n\n\t//static XPath xpath = XPathFactory.newInstance().newXPath();\n\n\t/**\n\t * Given an element, searches upwards through ancestor Elements till the first Element\n\t * matching the requests {@code}parentName{@code} is found.\n\t * @param element The starting element\n\t * @param parentName The tag name of the requested Element.\n\t * @return The found element, or {@code}null{@code} if no matching element is found,\n\t */\n\tpublic static Element selectParentElement(Element element, String parentName) {\n\t\t\n\t    Node parentNode =  element.getParentNode();\n\t\tif (parentNode == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// check that parent is actually an element, else return null\n\t\t// this is to prevent ClassCastExceptions if element's parent is not an Element.\n\t\tElement parentElement = null;\n\t\tif (Node.ELEMENT_NODE == parentNode.getNodeType()){\n\t\t\tparentElement = (Element)parentNode;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tif (parentElement.getTagName().equals(parentName)) {\n\t\t\treturn parentElement;\n\t\t}\n\t\treturn selectParentElement(parentElement, parentName);\n\t}\n\n\t/**\n\t * If {@code}xpathExpression{@code} is a plain string with no '/' characterr, this is \n\t * interpreted as a child element name to search for. \n\t * <b/>\n\t * If {@code}xpathExpression{@code} is an XPath expression, this is evaluated and is assumed\n\t * to identify a single element.\n\t * @param element\n\t * @param xpathExpression\n\t * @return A single element or null if no match or the 1st match if matches more than 1\n\t * @throws XPathExpressionException\n\t */\n\tpublic static Element selectSingleElement(Element element, String xpathExpression) throws XPathExpressionException {\n\t\tif (element == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (xpathExpression.indexOf(\"/\") == -1) {\n\t\t\tNodeList nodeList = element.getChildNodes();\n\t\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n\t\t\t\t\treturn (Element) node;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//  NodeList nodes = element.getElementsByTagName(xpathExpression);\n\t\t\t//  if (nodes.getLength() > 0) {\n\t\t\t//      return (Element) nodes.item(0);\n\t\t\t//  } else {\n\t\t\treturn null;\n\t\t\t//  }\n\t\t} else {\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tElement node = (Element) xpath.evaluate(xpathExpression, element, XPathConstants.NODE);\n\t\t\treturn node;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a list of elements matching {@code}xpathExpression{@code}. If xpathExpression lacks\n\t * a '/' character, only immediate children o {@code}element{@code} are searched over.\n\t * <br/>\n\t * If {@code}xpathExpression{@code} contains an '/' character, a full XPath search is made\n\t * @param element\n\t * @param xpathExpression\n\t * @return A possibly empty but non-null {@code}ArrayList{@code}\n\t * @throws XPathExpressionException\n\t */\n\tpublic static ArrayList<Element> selectElements(Element element, String xpathExpression) throws XPathExpressionException {\n\t\tArrayList<Element> resultVector = new ArrayList<>();\n\t\tif (element == null) {\n\t\t\treturn resultVector;\n\t\t}\n\t\tif (xpathExpression.indexOf(\"/\") == -1) {\n\t\t\tNodeList nodeList = element.getChildNodes();\n\t\t\tfor (int i = 0; i < nodeList.getLength(); i++) {\n\t\t\t\tNode node = nodeList.item(i);\n\t\t\t\tif (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n\t\t\t\t\tresultVector.add((Element) node);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(xpathExpression, element, XPathConstants.NODESET);\n\n\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++) {\n\t\t\t\tNode node = nodes.item(i);\n\t\t\t\tresultVector.add((Element) node);\n\t\t\t}\n\t\t}\n\t\treturn resultVector;\n\t}\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.xpath.XPathExpressionException;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\nclass XMLHelperTest {\n\n    // simple XML used in most of the tests:\n    final String TEST_XML = \"<root><list><a id=\\\"1\\\"/> <a id=\\\"2\\\"/> </list></root>\";\n\n    @Test\n    @DisplayName(\"Create empty w3dom Document\")\n    void getNewDocument() throws ParserConfigurationException {\n        Document d = XMLHelper.getNewDocument();\n        assertNotNull(d);\n        assertFalse(d.hasChildNodes());\n        assertNull(d.getInputEncoding());\n    }\n\n    @Test\n    @DisplayName(\"Create empty w3dom Document\")\n    void addChildDocument() throws ParserConfigurationException, DOMException {\n\n        Document d = createDocumentWithRootElement();\n        Element root = (Element) d.getChildNodes().item(0);\n\n        Element added = XMLHelper.addChildElement(root, \"myelement\");\n        assertNotNull(added);\n        assertEquals(root, added.getParentNode());\n        assertEquals(added, root.getChildNodes().item(0));\n    }\n\n    @Test\n    void inputStreamToDocument() throws SAXException, IOException, ParserConfigurationException {\n        Document doc = readTestDoc();\n        assertParsedDocument(doc);\n    }\n\n    Document readTestDoc() throws SAXException, IOException, ParserConfigurationException {\n        ByteArrayInputStream bArrayInputStream = new ByteArrayInputStream(TEST_XML.getBytes());\n        return XMLHelper.inputStreamToDocument(bArrayInputStream);\n    }\n\n    @Test\n    void fileToDocument() throws IOException, SAXException, ParserConfigurationException {\n        File tmpFile = Files.createTempFile(\"xml\", \".xml\").toFile();\n        Files.write(Paths.get(tmpFile.getAbsolutePath()), TEST_XML.getBytes());\n        Document doc = XMLHelper.loadXML(tmpFile.getAbsolutePath());\n        assertParsedDocument(doc);\n    }\n\n    @Test\n    void documentToOutputStream() throws SAXException, IOException, ParserConfigurationException, TransformerException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream(100);\n        Document doc = readTestDoc();\n        XMLHelper.outputToStream(doc, baos);\n        assertEquals(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\" + TEST_XML,\n                new String(baos.toByteArray()));\n    }\n\n    @Test\n    void selectParentElement() throws SAXException, IOException, ParserConfigurationException {\n        Document doc = readTestDoc();\n        \n        // get a a grandchild element\n        NodeList nodes = doc.getElementsByTagName(\"a\");\n        \n        // can get root node\n        Element el = (Element) nodes.item(0);\n        Element root = XMLHelper.selectParentElement(el, \"root\");\n        assertNotNull(root);\n        \n        // non-existing element or if is root node returns null\n        assertNull(XMLHelper.selectParentElement(el, \"notexisting\"));\n        assertNull(XMLHelper.selectParentElement(root, \"notexisting\"));\n    }\n\n    @Nested\n    class SelectSingleElement {\n        @Test\n        void selectSingleElement()\n                throws SAXException, IOException, ParserConfigurationException, XPathExpressionException {\n            Document doc = readTestDoc();\n            Element root = (Element) doc.getElementsByTagName(\"root\").item(0);\n\n            // not direct child\n            assertNull(XMLHelper.selectSingleElement(root, \"a\"));\n\n            // direct child\n            assertNotNull(XMLHelper.selectSingleElement(root, \"list\"));\n\n            // xpath match\n            Element found = XMLHelper.selectSingleElement(root, \"/root/list/a[@id = \\\"2\\\"]\");\n            assertNotNull(found);\n            assertEquals(\"2\", found.getAttribute(\"id\"));\n\n            // xpath no match\n            Element Notfound = XMLHelper.selectSingleElement(root, \"/root/list/a[@id = \\\"45\\\"]\");\n            assertNull(Notfound);\n\n            // xpath returning multiple elements returns 1st element\n            Element mult = XMLHelper.selectSingleElement(root, \"/root/list/a\");\n            assertNotNull(mult);\n        }\n\n        @Test\n        void invalidInput() throws XPathExpressionException {\n            assertNull(XMLHelper.selectSingleElement(null, \"root\"));\n        }\n    }\n\n    @Nested\n    class SelectElements {\n\n       private Document doc = null;\n       private Element root = null;\n\n        @BeforeEach\n        void before() throws SAXException, IOException, ParserConfigurationException {\n             doc = readTestDoc();\n             root = (Element) doc.getElementsByTagName(\"root\").item(0);\n        }\n\n        @Test\n        void selectMultipleElementsWithXPath()\n                throws  XPathExpressionException {\n            ArrayList<Element> selected = XMLHelper.selectElements(root, \"/root/list/a\");\n            assertEquals(2, selected.size());\n        }\n\n        @Test\n        void selectMultipleElementsWithXPathSearchesWholeTree()\n                throws  XPathExpressionException {\n            Element a1  = (Element) doc.getElementsByTagName(\"a\").item(0);\n            \n            ArrayList<Element> selected = XMLHelper.selectElements(a1, \"/root\");\n            assertEquals(1, selected.size());\n            assertEquals(\"root\", selected.get(0).getTagName());\n        }\n\n        @Test\n        void selectBySimpleTagName() throws XPathExpressionException {\n            // search by simple name doesn't search past children\n            assertEquals(0, XMLHelper.selectElements(root, \"a\").size());\n            Element list = (Element) doc.getElementsByTagName(\"list\").item(0);\n\n            // 'list' is immediate parent of 'a'\n            assertEquals(2, XMLHelper.selectElements(list, \"a\").size());\n        }\n\n        @Test\n        void invalidInputtoSelectElements() throws XPathExpressionException {\n            assertEquals(0, XMLHelper.selectElements(null, \"root\").size());\n        }\n    }\n\n    void assertParsedDocument(Document doc) {\n        assertNotNull(doc);\n        assertEquals(2, doc.getElementsByTagName(\"a\").getLength());\n        assertEquals(1, doc.getElementsByTagName(\"list\").getLength());\n    }\n\n    Document createDocumentWithRootElement() throws ParserConfigurationException {\n        Document doc = XMLHelper.getNewDocument();\n        Element root = doc.createElement(\"root\");\n        doc.appendChild(root);\n        return doc;\n    }\n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":true}