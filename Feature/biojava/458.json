{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/internal/CeSymm.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/internal/TestCeSymm.java","prod_time":"2016-01-09 02:58:20","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"d4597c48c59ea0821b5643860d33d39640bac5f4","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.ce.CeCPMain;\nimport org.biojava.nbio.structure.align.ce.MatrixListener;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.util.AFPChainScorer;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.secstruc.SecStrucPred;\nimport org.biojava.nbio.structure.secstruc.SecStrucTools;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\nimport org.biojava.nbio.structure.symmetry.utils.SymmetryTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Identify the symmetries in a structure by running an alignment of the\n * structure against itself disabling the diagonal of the identity alignment.\n * <p>\n * Iterating recursively over all results and disabling the diagonal of each\n * previous result can also be done with this implementation, which will\n * generate a set of self-alignments.\n * <p>\n * The alignment is then refined to obtain a consistent alignment among all\n * residues of the structure and organized into different parts, called\n * symmetric subunits. After refinement of the initial alignment, an\n * optimization step can be used to improve the overall score of the subunit\n * multiple alignment.\n * \n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class CeSymm {\n\n\t/**\n\t * Version History:\n\t * <p>\n\t * <ul>\n\t * <li>1.0 - initial implementation of CE-Symm.\n\t * <li>1.1 - enable multiple CE-Symm runs to calculate all self-alignments.\n\t * <li>2.0 - refine the alignment for consistency of subunit definition.\n\t * <li>2.1 - optimize the alignment to improve the score.\n\t * <li>2.2 - run multiple symmetry levels recursively to find PG and\n\t * hierarchical symmetries.\n\t * </ul>\n\t * </li>\n\t */\n\tpublic static final String version = \"2.2\";\n\tpublic static final String algorithmName = \"jCE-symm\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(CeSymm.class);\n\n\tprivate MultipleAlignment msa;\n\tprivate List<AFPChain> selfAlignments;\n\tprivate SymmetryAxes axes;\n\tprivate boolean refined;\n\n\tprivate CESymmParameters params = new CESymmParameters();\n\n\tpublic CeSymm() {\n\t\treset();\n\t}\n\n\tprivate static Matrix align(AFPChain afpChain, Atom[] ca1, Atom[] ca2,\n\t\t\tCESymmParameters params, Matrix origM, CECalculator calculator,\n\t\t\tint counter) throws StructureException {\n\n\t\tint fragmentLength = params.getWinSize();\n\t\tAtom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tint blankWindowSize = fragmentLength;\n\t\tif (origM == null) {\n\n\t\t\t// Build alignment ca1 to ca2-ca2\n\t\t\tafpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, null, blankWindowSize);\n\n\t\t} else {\n\t\t\t// we are doing an iteration on a previous alignment\n\t\t\t// mask the previous alignment\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, origM, blankWindowSize);\n\t\t}\n\n\t\tMatrix clone = (Matrix) origM.clone();\n\n\t\t// that's the matrix to run the alignment on..\n\t\tcalculator.setMatMatrix(clone.getArray());\n\n\t\tcalculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n\n\t\tfinal Matrix origMfinal = (Matrix) origM.clone();\n\t\t// Add a matrix listener to keep the blacked zones in max.\n\t\tcalculator.addMatrixListener(new MatrixListener() {\n\n\t\t\t@Override\n\t\t\tpublic double[][] matrixInOptimizer(double[][] max) {\n\n\t\t\t\t// Check every entry of origM for blacked out regions\n\t\t\t\tfor (int i = 0; i < max.length; i++) {\n\t\t\t\t\tfor (int j = 0; j < max[i].length; j++) {\n\t\t\t\t\t\tif (origMfinal.getArray()[i][j] > 1e9) {\n\t\t\t\t\t\t\tmax[i][j] = -origMfinal.getArray()[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean[][] initializeBreakFlag(boolean[][] brkFlag) {\n\n\t\t\t\treturn brkFlag;\n\t\t\t}\n\t\t});\n\n\t\tcalculator.nextStep(afpChain, ca1, ca2clone);\n\n\t\tafpChain.setAlgorithmName(algorithmName);\n\t\tafpChain.setVersion(version);\n\n\t\tafpChain.setDistanceMatrix(origM);\n\n\t\treturn origMfinal;\n\n\t}\n\n\tprotected AFPChain align(Atom[] ca1) throws StructureException {\n\n\t\t// STEP 1: prepare all the information for the symmetry alignment\n\t\tAtom[] ca2 = StructureTools.duplicateCA2(ca1);\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\tif (rows == 0 || cols == 0) {\n\t\t\tthrow new StructureException(\"Aligning empty structure\");\n\t\t}\n\n\t\tMatrix origM = null;\n\t\tAFPChain myAFP = new AFPChain();\n\t\tCECalculator calculator = new CECalculator(params);\n\n\t\t// Set multiple to true if multiple alignments are needed for refinement\n\t\tboolean multiple = (params.getRefineMethod() == RefineMethod.MULTIPLE);\n\t\tMatrix lastMatrix = null;\n\n\t\t// STEP 2: perform the self-alignments of the structure with CECP\n\t\tint i = 0;\n\t\tdo {\n\n\t\t\tif (origM != null) {\n\t\t\t\tmyAFP.setDistanceMatrix((Matrix) origM.clone());\n\t\t\t}\n\t\t\torigM = align(myAFP, ca1, ca2, params, origM, calculator, i);\n\n\t\t\tdouble tmScore2 = AFPChainScorer.getTMScore(myAFP, ca1, ca2);\n\t\t\tmyAFP.setTMScore(tmScore2);\n\n\t\t\t// Clone the AFPChain\n\t\t\tAFPChain newAFP = (AFPChain) myAFP.clone();\n\n\t\t\t// Post process the alignment\n\t\t\tnewAFP = CeCPMain\n\t\t\t\t\t.postProcessAlignment(newAFP, ca1, ca2, calculator);\n\n\t\t\t// Calculate and set the TM score for the newAFP alignment\n\t\t\tdouble tmScore3 = AFPChainScorer.getTMScore(newAFP, ca1, ca2);\n\t\t\tnewAFP.setTMScore(tmScore3);\n\t\t\tlogger.debug(\"Alignment \" + (i + 1) + \" score: \"\n\t\t\t\t\t+ newAFP.getTMScore());\n\t\t\t// Determine if the alignment is significant, stop if true\n\t\t\tif (tmScore3 < params.getScoreThreshold()) {\n\t\t\t\tlogger.debug(\"Not symmetric alignment with TM score: \"\n\t\t\t\t\t\t+ newAFP.getTMScore());\n\t\t\t\t// If it is the first alignment save it anyway\n\t\t\t\tif (i == 0)\n\t\t\t\t\tselfAlignments.add(newAFP);\n\t\t\t\t// store final matrix &\n\t\t\t\tlastMatrix = newAFP.getDistanceMatrix().copy();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If it is a symmetric alignment add it to the allAlignments list\n\t\t\tselfAlignments.add(newAFP);\n\n\t\t\ti++;\n\n\t\t} while (i < params.getMaxSymmOrder() && multiple);\n\n\t\tif (lastMatrix == null && selfAlignments.size() > 1) {\n\t\t\t// We reached the maximum order, so blank out the final alignment\n\t\t\tAFPChain last = selfAlignments.get(selfAlignments.size() - 1);\n\t\t\tlastMatrix = SymmetryTools.blankOutPreviousAlignment(last, ca2,\n\t\t\t\t\tlast.getCa1Length(), last.getCa2Length(), calculator,\n\t\t\t\t\torigM, params.getWinSize());\n\t\t\tlastMatrix = lastMatrix.getMatrix(0, last.getCa1Length() - 1, 0,\n\t\t\t\t\tlast.getCa2Length() - 1);\n\t\t}\n\n\t\t// Extract the optimal alignment\n\t\tAFPChain optimalAFP = selfAlignments.get(0);\n\t\tif (ca1.length != 0 && ca1[0].getGroup().getChain() != null\n\t\t\t\t&& ca1[0].getGroup().getChain().getStructure() != null) {\n\t\t\tString name = ca1[0].getGroup().getChain().getStructure().getName();\n\t\t\toptimalAFP.setName1(name);\n\t\t\toptimalAFP.setName2(name);\n\t\t}\n\n\t\tif (params.getRefineMethod() == RefineMethod.NOT_REFINED) {\n\t\t\treturn optimalAFP;\n\t\t}\n\n\t\t// Determine the symmetry Type or get the one in params\n\t\tSymmetryType type = params.getSymmType();\n\t\tif (type == SymmetryType.AUTO) {\n\t\t\tif (optimalAFP.getBlockNum() == 1) {\n\t\t\t\ttype = SymmetryType.OPEN;\n\t\t\t\tlogger.info(\"Open Symmetry detected\");\n\t\t\t} else {\n\t\t\t\ttype = SymmetryType.CLOSE;\n\t\t\t\tlogger.info(\"Close Symmetry detected\");\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: symmetry refinement, apply consistency in the subunit\n\t\t// residues\n\t\tRefiner refiner = null;\n\t\tint order = 1;\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\tcase CLOSE:\n\t\t\t\tOrderDetector orderDetector = null;\n\t\t\t\tswitch (params.getOrderDetectorMethod()) {\n\t\t\t\tcase SEQUENCE_FUNCTION:\n\t\t\t\t\torderDetector = new SequenceFunctionOrderDetector(\n\t\t\t\t\t\t\tparams.getMaxSymmOrder(), 0.4f);\n\t\t\t\t\torder = orderDetector.calculateOrder(optimalAFP, ca1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USER_INPUT:\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trefiner = new SingleRefiner();\n\t\t\t\tbreak;\n\t\t\tdefault: // case OPEN\n\t\t\t\trefiner = new OpenRefiner();\n\t\t\t\torder = params.getUserOrder();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toptimalAFP = refiner.refine(selfAlignments, ca1, order);\n\t\t\trefined = true;\n\n\t\t} catch (RefinerFailedException e) {\n\t\t\tlogger.info(\"Refinement failed: \" + e.getMessage());\n\t\t\treturn optimalAFP;\n\t\t}\n\n\t\t// STEP4: determine the symmetry axis and its subunit dependencies\n\t\torder = optimalAFP.getBlockNum();\n\t\tMatrix rot = optimalAFP.getBlockRotationMatrix()[0];\n\t\tAtom shift = optimalAFP.getBlockShiftVector()[0];\n\t\tMatrix4d axis = Calc.getTransformation(rot, shift);\n\n\t\tList<List<Integer>> superposition = new ArrayList<List<Integer>>();\n\t\tList<Integer> chain1 = new ArrayList<Integer>();\n\t\tList<Integer> chain2 = new ArrayList<Integer>();\n\t\tsuperposition.add(chain1);\n\t\tsuperposition.add(chain2);\n\t\tList<Integer> subunitTrans = new ArrayList<Integer>();\n\n\t\tswitch (type) {\n\t\tcase CLOSE:\n\n\t\t\tfor (int bk = 0; bk < order; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add((bk + 1) % order);\n\t\t\t\tsubunitTrans.add(bk);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\n\t\tdefault: // case OPEN:\n\n\t\t\tsubunitTrans.add(0);\n\t\t\tfor (int bk = 0; bk < order - 1; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add(bk + 1);\n\t\t\t\tsubunitTrans.add(bk + 1);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn optimalAFP;\n\t}\n\n\tpublic CESymmParameters getParameters() {\n\t\treturn params;\n\t}\n\n\tpublic void setParameters(CESymmParameters parameters) {\n\t\tparams = parameters;\n\t}\n\n\tpublic String getAlgorithmName() {\n\t\treturn algorithmName;\n\t}\n\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic boolean isSignificant() throws StructureException {\n\t\tdouble symmetryThreshold = params.getScoreThreshold();\n\t\treturn SymmetryTools.isSignificant(msa, symmetryThreshold);\n\t}\n\n\t/**\n\t * Get the list of all self-alignments.\n\t * \n\t * @return List of AFPChain self-alignments\n\t */\n\tpublic List<AFPChain> getSelfAlignments() {\n\t\treturn selfAlignments;\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the DEFAULT or\n\t * previously set parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyze(Atom[] atoms) throws StructureException {\n\n\t\tif (params == null)\n\t\t\tparams = new CESymmParameters();\n\t\treturn analyze(atoms, params);\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the provided\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @param param\n\t *            CeSymm Parameter bean\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyze(Atom[] atoms, CESymmParameters param)\n\t\t\tthrows StructureException {\n\n\t\treset();\n\t\tif (atoms.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\t\t}\n\t\tthis.params = param;\n\t\t\n\t\t// If the SSE information is needed, we calculate it if the user did not\n\t\tif (params.getSSEThreshold() > 0) {\n\t\t\tStructure s = atoms[0].getGroup().getChain().getStructure();\n\t\t\tif (SecStrucTools.getSecStrucInfo(s).isEmpty()){\n\t\t\t\tSecStrucPred ssp = new SecStrucPred();\n\t\t\t\tssp.predict(s, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCeSymmIterative iter = new CeSymmIterative(param);\n\t\tmsa = iter.execute(atoms);\n\t\taxes = iter.getSymmetryAxes();\n\t\t\n\t\tif (SymmetryTools.isRefined(msa)) {\n\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// Optimize the global alignment once more (as final step)\n\t\t\tif (this.params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(msa, axes,\n\t\t\t\t\t\t\tparams, params.getRndSeed());\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.info(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsa.putScore(\"isRefined\", 1.0);\n\t\t}\n\t\treturn msa;\n\t}\n\n\t/**\n\t * Analyze a single level of symmetry.\n\t * \n\t * @param atoms\n\t *            Atom array of the current level\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyzeLevel(Atom[] atoms) throws StructureException {\n\n\t\t// Reset all the variables from previous calls\n\t\treset();\n\n\t\tif (atoms.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\t\t}\n\n\t\tAFPChain selfAFP = align(atoms);\n\n\t\tif (refined) {\n\t\t\tmsa = SymmetryTools.fromAFP(selfAFP, atoms);\n\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// STEP 5: symmetry alignment optimization\n\t\t\tif (this.params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(msa, axes,\n\t\t\t\t\t\t\tparams, params.getRndSeed());\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.debug(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsa.putScore(\"isRefined\", 1.0);\n\t\t} else {\n\t\t\t// Convert the optimal pairwise alignment to MSA\n\t\t\tMultipleAlignmentEnsemble e = new MultipleAlignmentEnsembleImpl(\n\t\t\t\t\tselfAFP, atoms, atoms, false);\n\t\t\tmsa = e.getMultipleAlignment(0);\n\t\t\tlogger.debug(\"Returning optimal self-alignment\");\n\t\t\tmsa.putScore(\"isRefined\", 0.0);\n\t\t}\n\t\treturn msa;\n\t}\n\n\tpublic SymmetryAxes getSymmetryAxes() {\n\t\treturn axes;\n\t}\n\n\t/**\n\t * Set the object to its construction state. This method resets all the\n\t * member variables and sets the parameters to the default ones.\n\t */\n\tprivate void reset() {\n\t\trefined = false;\n\t\tmsa = null;\n\t\tselfAlignments = new ArrayList<AFPChain>();\n\t\taxes = new SymmetryAxes();\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.ce.CeCPMain;\nimport org.biojava.nbio.structure.align.ce.MatrixListener;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsemble;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentEnsembleImpl;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.util.AFPChainScorer;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucTools;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\nimport org.biojava.nbio.structure.symmetry.utils.SymmetryTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Identify the symmetries in a structure by running an alignment of the\n * structure against itself disabling the diagonal of the identity alignment.\n * <p>\n * Iterating recursively over all results and disabling the diagonal of each\n * previous result can also be done with this implementation, which will\n * generate a set of self-alignments.\n * <p>\n * The alignment is then refined to obtain a consistent alignment among all\n * residues of the structure and organized into different parts, called\n * symmetric subunits. After refinement of the initial alignment, an\n * optimization step can be used to improve the overall score of the subunit\n * multiple alignment.\n * \n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class CeSymm {\n\n\t/**\n\t * Version History:\n\t * <p>\n\t * <ul>\n\t * <li>1.0 - initial implementation of CE-Symm.\n\t * <li>1.1 - enable multiple CE-Symm runs to calculate all self-alignments.\n\t * <li>2.0 - refine the alignment for consistency of subunit definition.\n\t * <li>2.1 - optimize the alignment to improve the score.\n\t * <li>2.2 - run multiple symmetry levels recursively to find PG and\n\t * hierarchical symmetries.\n\t * </ul>\n\t * </li>\n\t */\n\tpublic static final String version = \"2.2\";\n\tpublic static final String algorithmName = \"jCE-symm\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(CeSymm.class);\n\n\tprivate MultipleAlignment msa;\n\tprivate List<AFPChain> selfAlignments;\n\tprivate SymmetryAxes axes;\n\tprivate boolean refined;\n\n\tprivate CESymmParameters params = new CESymmParameters();\n\n\tpublic CeSymm() {\n\t\treset();\n\t}\n\n\tprivate static Matrix align(AFPChain afpChain, Atom[] ca1, Atom[] ca2,\n\t\t\tCESymmParameters params, Matrix origM, CECalculator calculator,\n\t\t\tint counter) throws StructureException {\n\n\t\tint fragmentLength = params.getWinSize();\n\t\tAtom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tint blankWindowSize = fragmentLength;\n\t\tif (origM == null) {\n\n\t\t\t// Build alignment ca1 to ca2-ca2\n\t\t\tafpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, null, blankWindowSize);\n\n\t\t} else {\n\t\t\t// we are doing an iteration on a previous alignment\n\t\t\t// mask the previous alignment\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, origM, blankWindowSize);\n\t\t}\n\n\t\tMatrix clone = (Matrix) origM.clone();\n\n\t\t// that's the matrix to run the alignment on..\n\t\tcalculator.setMatMatrix(clone.getArray());\n\n\t\tcalculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n\n\t\tfinal Matrix origMfinal = (Matrix) origM.clone();\n\t\t// Add a matrix listener to keep the blacked zones in max.\n\t\tcalculator.addMatrixListener(new MatrixListener() {\n\n\t\t\t@Override\n\t\t\tpublic double[][] matrixInOptimizer(double[][] max) {\n\n\t\t\t\t// Check every entry of origM for blacked out regions\n\t\t\t\tfor (int i = 0; i < max.length; i++) {\n\t\t\t\t\tfor (int j = 0; j < max[i].length; j++) {\n\t\t\t\t\t\tif (origMfinal.getArray()[i][j] > 1e9) {\n\t\t\t\t\t\t\tmax[i][j] = -origMfinal.getArray()[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean[][] initializeBreakFlag(boolean[][] brkFlag) {\n\n\t\t\t\treturn brkFlag;\n\t\t\t}\n\t\t});\n\n\t\tcalculator.nextStep(afpChain, ca1, ca2clone);\n\n\t\tafpChain.setAlgorithmName(algorithmName);\n\t\tafpChain.setVersion(version);\n\n\t\tafpChain.setDistanceMatrix(origM);\n\n\t\treturn origMfinal;\n\n\t}\n\n\tprotected AFPChain align(Atom[] ca1) throws StructureException {\n\n\t\t// STEP 1: prepare all the information for the symmetry alignment\n\t\tAtom[] ca2 = StructureTools.duplicateCA2(ca1);\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\tif (rows == 0 || cols == 0) {\n\t\t\tthrow new StructureException(\"Aligning empty structure\");\n\t\t}\n\n\t\tMatrix origM = null;\n\t\tAFPChain myAFP = new AFPChain();\n\t\tCECalculator calculator = new CECalculator(params);\n\n\t\t// Set multiple to true if multiple alignments are needed for refinement\n\t\tboolean multiple = (params.getRefineMethod() == RefineMethod.MULTIPLE);\n\t\tMatrix lastMatrix = null;\n\n\t\t// STEP 2: perform the self-alignments of the structure with CECP\n\t\tint i = 0;\n\t\tdo {\n\n\t\t\tif (origM != null) {\n\t\t\t\tmyAFP.setDistanceMatrix((Matrix) origM.clone());\n\t\t\t}\n\t\t\torigM = align(myAFP, ca1, ca2, params, origM, calculator, i);\n\n\t\t\tdouble tmScore2 = AFPChainScorer.getTMScore(myAFP, ca1, ca2);\n\t\t\tmyAFP.setTMScore(tmScore2);\n\n\t\t\t// Clone the AFPChain\n\t\t\tAFPChain newAFP = (AFPChain) myAFP.clone();\n\n\t\t\t// Post process the alignment\n\t\t\tnewAFP = CeCPMain\n\t\t\t\t\t.postProcessAlignment(newAFP, ca1, ca2, calculator);\n\n\t\t\t// Calculate and set the TM score for the newAFP alignment\n\t\t\tdouble tmScore3 = AFPChainScorer.getTMScore(newAFP, ca1, ca2);\n\t\t\tnewAFP.setTMScore(tmScore3);\n\t\t\tlogger.debug(\"Alignment \" + (i + 1) + \" score: \"\n\t\t\t\t\t+ newAFP.getTMScore());\n\t\t\t// Determine if the alignment is significant, stop if true\n\t\t\tif (tmScore3 < params.getScoreThreshold()) {\n\t\t\t\tlogger.debug(\"Not symmetric alignment with TM score: \"\n\t\t\t\t\t\t+ newAFP.getTMScore());\n\t\t\t\t// If it is the first alignment save it anyway\n\t\t\t\tif (i == 0)\n\t\t\t\t\tselfAlignments.add(newAFP);\n\t\t\t\t// store final matrix &\n\t\t\t\tlastMatrix = newAFP.getDistanceMatrix().copy();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If it is a symmetric alignment add it to the allAlignments list\n\t\t\tselfAlignments.add(newAFP);\n\n\t\t\ti++;\n\n\t\t} while (i < params.getMaxSymmOrder() && multiple);\n\n\t\tif (lastMatrix == null && selfAlignments.size() > 1) {\n\t\t\t// We reached the maximum order, so blank out the final alignment\n\t\t\tAFPChain last = selfAlignments.get(selfAlignments.size() - 1);\n\t\t\tlastMatrix = SymmetryTools.blankOutPreviousAlignment(last, ca2,\n\t\t\t\t\tlast.getCa1Length(), last.getCa2Length(), calculator,\n\t\t\t\t\torigM, params.getWinSize());\n\t\t\tlastMatrix = lastMatrix.getMatrix(0, last.getCa1Length() - 1, 0,\n\t\t\t\t\tlast.getCa2Length() - 1);\n\t\t}\n\n\t\t// Extract the optimal alignment\n\t\tAFPChain optimalAFP = selfAlignments.get(0);\n\t\tif (ca1.length != 0 && ca1[0].getGroup().getChain() != null\n\t\t\t\t&& ca1[0].getGroup().getChain().getStructure() != null) {\n\t\t\tString name = ca1[0].getGroup().getChain().getStructure().getName();\n\t\t\toptimalAFP.setName1(name);\n\t\t\toptimalAFP.setName2(name);\n\t\t}\n\n\t\tif (params.getRefineMethod() == RefineMethod.NOT_REFINED) {\n\t\t\treturn optimalAFP;\n\t\t}\n\n\t\t// Determine the symmetry Type or get the one in params\n\t\tSymmetryType type = params.getSymmType();\n\t\tif (type == SymmetryType.AUTO) {\n\t\t\tif (optimalAFP.getBlockNum() == 1) {\n\t\t\t\ttype = SymmetryType.OPEN;\n\t\t\t\tlogger.info(\"Open Symmetry detected\");\n\t\t\t} else {\n\t\t\t\ttype = SymmetryType.CLOSE;\n\t\t\t\tlogger.info(\"Close Symmetry detected\");\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: symmetry refinement, apply consistency in the subunit\n\t\t// residues\n\t\tRefiner refiner = null;\n\t\tint order = 1;\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\tcase CLOSE:\n\t\t\t\tOrderDetector orderDetector = null;\n\t\t\t\tswitch (params.getOrderDetectorMethod()) {\n\t\t\t\tcase SEQUENCE_FUNCTION:\n\t\t\t\t\torderDetector = new SequenceFunctionOrderDetector(\n\t\t\t\t\t\t\tparams.getMaxSymmOrder(), 0.4f);\n\t\t\t\t\torder = orderDetector.calculateOrder(optimalAFP, ca1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USER_INPUT:\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trefiner = new SingleRefiner();\n\t\t\t\tbreak;\n\t\t\tdefault: // case OPEN\n\t\t\t\trefiner = new OpenRefiner();\n\t\t\t\torder = params.getUserOrder();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\toptimalAFP = refiner.refine(selfAlignments, ca1, order);\n\t\t\trefined = true;\n\n\t\t} catch (RefinerFailedException e) {\n\t\t\tlogger.info(\"Refinement failed: \" + e.getMessage());\n\t\t\treturn optimalAFP;\n\t\t}\n\n\t\t// STEP4: determine the symmetry axis and its subunit dependencies\n\t\torder = optimalAFP.getBlockNum();\n\t\tMatrix rot = optimalAFP.getBlockRotationMatrix()[0];\n\t\tAtom shift = optimalAFP.getBlockShiftVector()[0];\n\t\tMatrix4d axis = Calc.getTransformation(rot, shift);\n\n\t\tList<List<Integer>> superposition = new ArrayList<List<Integer>>();\n\t\tList<Integer> chain1 = new ArrayList<Integer>();\n\t\tList<Integer> chain2 = new ArrayList<Integer>();\n\t\tsuperposition.add(chain1);\n\t\tsuperposition.add(chain2);\n\t\tList<Integer> subunitTrans = new ArrayList<Integer>();\n\n\t\tswitch (type) {\n\t\tcase CLOSE:\n\n\t\t\tfor (int bk = 0; bk < order; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add((bk + 1) % order);\n\t\t\t\tsubunitTrans.add(bk);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\n\t\tdefault: // case OPEN:\n\n\t\t\tsubunitTrans.add(0);\n\t\t\tfor (int bk = 0; bk < order - 1; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add(bk + 1);\n\t\t\t\tsubunitTrans.add(bk + 1);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn optimalAFP;\n\t}\n\n\tpublic CESymmParameters getParameters() {\n\t\treturn params;\n\t}\n\n\tpublic void setParameters(CESymmParameters parameters) {\n\t\tparams = parameters;\n\t}\n\n\tpublic String getAlgorithmName() {\n\t\treturn algorithmName;\n\t}\n\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\n\tpublic boolean isSignificant() throws StructureException {\n\t\tdouble symmetryThreshold = params.getScoreThreshold();\n\t\treturn SymmetryTools.isSignificant(msa, symmetryThreshold);\n\t}\n\n\t/**\n\t * Get the list of all self-alignments.\n\t * \n\t * @return List of AFPChain self-alignments\n\t */\n\tpublic List<AFPChain> getSelfAlignments() {\n\t\treturn selfAlignments;\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the DEFAULT or\n\t * previously set parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyze(Atom[] atoms) throws StructureException {\n\n\t\tif (params == null)\n\t\t\tparams = new CESymmParameters();\n\t\treturn analyze(atoms, params);\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the provided\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @param param\n\t *            CeSymm Parameter bean\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyze(Atom[] atoms, CESymmParameters param)\n\t\t\tthrows StructureException {\n\n\t\treset();\n\t\tif (atoms.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\t\t}\n\t\tthis.params = param;\n\t\t\n\t\t// If the SSE information is needed, we calculate it if the user did not\n\t\tif (params.getSSEThreshold() > 0) {\n\t\t\tStructure s = atoms[0].getGroup().getChain().getStructure();\n\t\t\tif (SecStrucTools.getSecStrucInfo(s).isEmpty()){\n\t\t\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\t\t\tssp.calculate(s, true);\n\t\t\t}\n\t\t}\n\t\t\n\t\tCeSymmIterative iter = new CeSymmIterative(param);\n\t\tmsa = iter.execute(atoms);\n\t\taxes = iter.getSymmetryAxes();\n\t\t\n\t\tif (SymmetryTools.isRefined(msa)) {\n\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// Optimize the global alignment once more (as final step)\n\t\t\tif (this.params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(msa, axes,\n\t\t\t\t\t\t\tparams, params.getRndSeed());\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.info(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsa.putScore(\"isRefined\", 1.0);\n\t\t}\n\t\treturn msa;\n\t}\n\n\t/**\n\t * Analyze a single level of symmetry.\n\t * \n\t * @param atoms\n\t *            Atom array of the current level\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic MultipleAlignment analyzeLevel(Atom[] atoms) throws StructureException {\n\n\t\t// Reset all the variables from previous calls\n\t\treset();\n\n\t\tif (atoms.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\t\t}\n\n\t\tAFPChain selfAFP = align(atoms);\n\n\t\tif (refined) {\n\t\t\tmsa = SymmetryTools.fromAFP(selfAFP, atoms);\n\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\n\t\t\t// STEP 5: symmetry alignment optimization\n\t\t\tif (this.params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(msa, axes,\n\t\t\t\t\t\t\tparams, params.getRndSeed());\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.debug(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\tmsa.putScore(\"isRefined\", 1.0);\n\t\t} else {\n\t\t\t// Convert the optimal pairwise alignment to MSA\n\t\t\tMultipleAlignmentEnsemble e = new MultipleAlignmentEnsembleImpl(\n\t\t\t\t\tselfAFP, atoms, atoms, false);\n\t\t\tmsa = e.getMultipleAlignment(0);\n\t\t\tlogger.debug(\"Returning optimal self-alignment\");\n\t\t\tmsa.putScore(\"isRefined\", 0.0);\n\t\t}\n\t\treturn msa;\n\t}\n\n\tpublic SymmetryAxes getSymmetryAxes() {\n\t\treturn axes;\n\t}\n\n\t/**\n\t * Set the object to its construction state. This method resets all the\n\t * member variables and sets the parameters to the default ones.\n\t */\n\tprivate void reset() {\n\t\trefined = false;\n\t\tmsa = null;\n\t\tselfAlignments = new ArrayList<AFPChain>();\n\t\taxes = new SymmetryAxes();\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.io.IOException;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.junit.Test;\n\n/**\n * Test for the old bug of non-independent CeSymm runs.\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * \n */\npublic class TestCeSymm {\n\n\t@Test\n\tpublic void testIndependence() throws IOException, StructureException {\n\n\t\t// Only instantiate one CeSymm class\n\t\tCeSymm ce = new CeSymm();\n\t\tString name;\n\t\tAtom[] atoms;\n\n\t\tname = \"1MER.A\";\n\t\tatoms = StructureTools.getRepresentativeAtomArray(StructureTools\n\t\t\t\t.getStructure(name));\n\t\tce.analyze(atoms);\n\n\t\tname = \"1ijq.A:377-641\";\n\t\tatoms = StructureTools.getRepresentativeAtomArray(StructureTools\n\t\t\t\t.getStructure(name));\n\t\t// This was causing an assertion error if runs are dependent\n\t\tce.analyze(atoms);\n\t}\n\n}\n","changedTest":"","commitMessage":"#360 improving class and method names\n","test_commitMessage":"","allZero":false}