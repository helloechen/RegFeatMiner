{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava3/structure/StructureIO.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/StructureIOTest.java","prod_time":"2012-06-30 04:54:44","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":6,"add_classname_line":0,"add_condition_line":3,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":5,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"9c36d31dd068bc4bbbb1cde4f3755cdaf513619f","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava3.structure;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.ce.AbstractUserArgumentProcessor;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.mmcif.model.PdbxStructAssembly;\nimport org.biojava.bio.structure.io.mmcif.model.PdbxStructAssemblyGen;\nimport org.biojava.bio.structure.io.mmcif.model.PdbxStructOperList;\nimport org.biojava.bio.structure.quaternary.ModelTransformationMatrix;\nimport org.biojava.bio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.bio.structure.quaternary.io.BioUnitDataProvider;\nimport org.biojava.bio.structure.quaternary.io.MmCifBiolAssemblyProvider;\nimport org.biojava.bio.structure.quaternary.io.MmCifPDBBiolAssemblyProvider;\nimport org.biojava.bio.structure.quaternary.io.PDBBioUnitDataProvider;\nimport org.biojava.bio.structure.quaternary.io.BioUnitDataProviderFactory;\n\n/** A class that provides static access methods for easy lookup of protein structure related components\n * \n * @author Andreas Prlic\n *\n * @since 3.0.5\n */\npublic class StructureIO {\n\n\n\tprivate static AtomCache cache ;\n\n\n\t/** Loads a structure based on a name. Supported naming conventions are:\n\t * \n\t *  * <pre>\n\t\tFormal specification for how to specify the <i>name</i>:\n\n\t\tname     := pdbID\n\t\t               | pdbID '.' chainID\n\t\t               | pdbID '.' range\n\t\t               | scopID\n\t\trange         := '('? range (',' range)? ')'?\n\t\t               | chainID\n\t\t               | chainID '_' resNum '-' resNum\n\t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t\tchainID       := [a-zA-Z0-9]\n\t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\n\n\t\tExample structures:\n\t\t1TIM     #whole structure - asym unit\n\t\t4HHB.C     #single chain\n\t\t4GCR.A_1-83     #one domain, by residue number\n\t\t3AA0.A,B     #two chains treated as one structure\n\t\td2bq6a1     #scop domain\n\t\t</pre>\n\t * \n\t * With the additional set of rules:\n\t *  \n\t *  <ul>\n\t *  <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model only (for NMR).\n\t *\t<li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A </li>\n\t *  <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names, see {@link #setStrictSCOP(boolean)}</li>\n\t *  <li>URLs are accepted as well</li>\n\t *  </ul>\n\t *  \n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException The PDB file cannot be cached due to IO errors\n\t * @throws StructureException The name appeared valid but did not correspond to a structure.\n\t * \tAlso thrown by some submethods upon errors, eg for poorly formatted subranges.\n\t */\n\tpublic static Structure getStructure(String name) throws IOException, StructureException{\n\n\t\tcheckInitAtomCache();\n\n\t\t// delegate this functionality to AtomCache...\n\n\t\treturn cache.getStructure(name);\n\n\t}\n\n\n\tprivate static void checkInitAtomCache() {\n\t\tif ( cache == null){\n\t\t\tcache = new AtomCache();\n\t\t}\n\n\t}\n\n\n\t/** Returns the first biologicalAssembly that is available for a protein structure. For more documentation on quaternary structures see:\n\t * {@link http://www.pdb.org/pdb/101/static101.do?p=education_discussion/Looking-at-Structures/bioassembly_tutorial.html}\n\t * \n\t * \n\t * @param pdbId\n\t * @return a Structure object or null if that assembly is not available\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\tpublic static Structure getBiologicalAssembly(String pdbId) throws IOException, StructureException{\n\t\treturn getBiologicalAssembly(pdbId,0);\n\t}\n\n\t/** By default the getStructure method loads asym units. This access method allows to recreate the quaternary structure for a protein if it is available.\n\t * \n\t * @param pdbId\n\t * @param biolAssemblyNr - the ith biological assembly that is available for a PDB ID (we start counting at 0).\n\t * @return a Structure object or null if that assembly is not available\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\tpublic static Structure getBiologicalAssembly(String pdbId, int biolAssemblyNr) throws IOException, StructureException {\n\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\t\tList<ModelTransformationMatrix> transformations = provider.getBioUnitTransformationList(pdbId, biolAssemblyNr);\n\n\t\tif ( transformations == null || transformations.size() == 0){\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly nr \" + biolAssemblyNr + \" of \" + pdbId);\n\t\t}\n\n\t\tStructure asymUnit = null;\n\n\t\tif ( provider instanceof MmCifBiolAssemblyProvider ) {\n\t\t\tMmCifBiolAssemblyProvider mmcifprov = (MmCifBiolAssemblyProvider) provider;\n\t\t\tasymUnit = mmcifprov.getAsymUnit(pdbId);\n\t\t} else {\n\t\t\tasymUnit = getStructure(pdbId);\n\t\t}\n\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations);\n\n\n\t}\n\n\t/** Does the provider PDB ID have a biological assembly?\n\t * \n\t * @param pdbId\n\t * @return flag if one or more biological assemblies are available\n\t */\n\tpublic static boolean hasBiologicalAssembly(String pdbId){\n\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\n\t\treturn provider.hasBiolAssembly(pdbId);\n\n\t}\n\n\tpublic static int getNrBiologicalAssemblies(String pdbId){\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\n\n\t\treturn provider.getNrBiolAssemblies(pdbId);\n\t}\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\t/** Utility method to set the location where PDB files can be found\n\t * \n\t * @param pathToPDBFiles\n\t */\n\tpublic static void setPdbPath(String pathToPDBFiles){\n\n\t\tif ( ! pathToPDBFiles.endsWith(FILE_SEPARATOR))\n\t\t\tpathToPDBFiles += FILE_SEPARATOR;\n\t\tSystem.setProperty(AbstractUserArgumentProcessor.PDB_DIR,pathToPDBFiles);\n\t}\n}\n","changedPro":"package org.biojava3.structure;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.ce.AbstractUserArgumentProcessor;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.quaternary.ModelTransformationMatrix;\nimport org.biojava.bio.structure.quaternary.BiologicalAssemblyBuilder;\nimport org.biojava.bio.structure.quaternary.io.BioUnitDataProvider;\nimport org.biojava.bio.structure.quaternary.io.MmCifBiolAssemblyProvider;\nimport org.biojava.bio.structure.quaternary.io.PDBBioUnitDataProvider;\nimport org.biojava.bio.structure.quaternary.io.BioUnitDataProviderFactory;\n\n/** A class that provides static access methods for easy lookup of protein structure related components\n * \n * @author Andreas Prlic\n *\n * @since 3.0.5\n */\npublic class StructureIO {\n\n\n\tprivate static AtomCache cache ;\n\n\n\t/** Loads a structure based on a name. Supported naming conventions are:\n\t * \n\t *  * <pre>\n\t\tFormal specification for how to specify the <i>name</i>:\n\n\t\tname     := pdbID\n\t\t               | pdbID '.' chainID\n\t\t               | pdbID '.' range\n\t\t               | scopID\n\t\trange         := '('? range (',' range)? ')'?\n\t\t               | chainID\n\t\t               | chainID '_' resNum '-' resNum\n\t\tpdbID         := [0-9][a-zA-Z0-9]{3}\n\t\tchainID       := [a-zA-Z0-9]\n\t\tscopID        := 'd' pdbID [a-z_][0-9_]\n\t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n\n\n\t\tExample structures:\n\t\t1TIM     #whole structure - asym unit\n\t\t4HHB.C     #single chain\n\t\t4GCR.A_1-83     #one domain, by residue number\n\t\t3AA0.A,B     #two chains treated as one structure\n\t\td2bq6a1     #scop domain\n\t\t</pre>\n\t * \n\t * With the additional set of rules:\n\t *  \n\t *  <ul>\n\t *  <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model only (for NMR).\n\t *\t<li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A </li>\n\t *  <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names, see {@link #setStrictSCOP(boolean)}</li>\n\t *  <li>URLs are accepted as well</li>\n\t *  </ul>\n\t *  \n\t * @param name\n\t * @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n\t * @throws IOException The PDB file cannot be cached due to IO errors\n\t * @throws StructureException The name appeared valid but did not correspond to a structure.\n\t * \tAlso thrown by some submethods upon errors, eg for poorly formatted subranges.\n\t */\n\tpublic static Structure getStructure(String name) throws IOException, StructureException{\n\n\t\tcheckInitAtomCache();\n\n\t\t// delegate this functionality to AtomCache...\n\n\t\treturn cache.getStructure(name);\n\n\t}\n\n\n\tprivate static void checkInitAtomCache() {\n\t\tif ( cache == null){\n\t\t\tcache = new AtomCache();\n\t\t}\n\n\t}\n\n\n\t/** Returns the first biologicalAssembly that is available for a protein structure. For more documentation on quaternary structures see:\n\t * {@link http://www.pdb.org/pdb/101/static101.do?p=education_discussion/Looking-at-Structures/bioassembly_tutorial.html}\n\t * \n\t * \n\t * @param pdbId\n\t * @return a Structure object or null if that assembly is not available\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\tpublic static Structure getBiologicalAssembly(String pdbId) throws IOException, StructureException{\n\t\treturn getBiologicalAssembly(pdbId,0);\n\t}\n\n\t/** By default the getStructure method loads asym units. This access method allows to recreate the quaternary structure for a protein if it is available.\n\t * \n\t * @param pdbId\n\t * @param biolAssemblyNr - the ith biological assembly that is available for a PDB ID (we start counting at 1, 0 represents the asym unit).\n\t * @return a Structure object or null if that assembly is not available\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\tpublic static Structure getBiologicalAssembly(String pdbId, int biolAssemblyNr) throws IOException, StructureException {\n\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\t\tStructure asymUnit = null;\n\n\t\tif ( provider instanceof MmCifBiolAssemblyProvider ) {\n\t\t\tMmCifBiolAssemblyProvider mmcifprov = (MmCifBiolAssemblyProvider) provider;\n\t\t\tasymUnit = mmcifprov.getAsymUnit(pdbId);\n\t\n\t\t\tmmcifprov.setAsymUnit(null);\n\t\t\t\n\t\t} else if ( provider instanceof PDBBioUnitDataProvider ){\n\t\t\tPDBBioUnitDataProvider pdbprov= (PDBBioUnitDataProvider) provider;\n\t\t\tpdbprov.loadPDB(pdbId);\n\t\t\t//System.out.println(asymUnit.getPDBHeader().getBioUnitTranformations());\n\t\t\tasymUnit = pdbprov.getAsymUnit();\n\t\t\tpdbprov.setAsymUnit(null);\n\t\t\t\n\t\t} else {\n\t\t\tasymUnit = getStructure(pdbId);\n\t\t\t\n\t\t}\n\t\t\n\t\t// 0 ... asym unit\n\t\tif ( biolAssemblyNr == 0) {\n\t\t\treturn asymUnit;\n\t\t}\n\t\t\n\t\t//List<ModelTransformationMatrix> transformations = provider.getBioUnitTransformationList(pdbId, biolAssemblyNr -1);\n\t\tList<ModelTransformationMatrix> transformations = asymUnit.getPDBHeader().getBioUnitTranformationMap().get(biolAssemblyNr );\n\t\tif ( transformations == null || transformations.size() == 0){\n\t\t\t\n\t\t\tthrow new StructureException(\"Could not load transformations to recreate biological assembly nr \" + biolAssemblyNr + \" of \" + pdbId);\n\t\t}\n\t\t\n\t\tBiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n\n\t\treturn builder.rebuildQuaternaryStructure(asymUnit, transformations);\n\n\n\t}\n\n\t/** Does the provider PDB ID have a biological assembly?\n\t * \n\t * @param pdbId\n\t * @return flag if one or more biological assemblies are available\n\t */\n\tpublic static boolean hasBiologicalAssembly(String pdbId){\n\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\n\t\treturn provider.hasBiolAssembly(pdbId);\n\n\t}\n\n\tpublic static int getNrBiologicalAssemblies(String pdbId){\n\t\tBioUnitDataProvider provider = BioUnitDataProviderFactory.getBioUnitDataProvider();\n\n\n\n\t\treturn provider.getNrBiolAssemblies(pdbId);\n\t}\n\n\tprivate static final String FILE_SEPARATOR = System.getProperty(\"file.separator\");\n\n\t/** Utility method to set the location where PDB files can be found\n\t * \n\t * @param pathToPDBFiles\n\t */\n\tpublic static void setPdbPath(String pathToPDBFiles){\n\n\t\tif ( ! pathToPDBFiles.endsWith(FILE_SEPARATOR))\n\t\t\tpathToPDBFiles += FILE_SEPARATOR;\n\t\tSystem.setProperty(AbstractUserArgumentProcessor.PDB_DIR,pathToPDBFiles);\n\t}\n}\n","originTest":"package org.biojava.bio.structure;\n\nimport junit.framework.TestCase;\n\nimport org.biojava3.structure.StructureIO;\n\npublic class StructureIOTest extends TestCase {\n\tpublic void testStructureIO(){\n\t\t\n\t\tString pdbId = \"1gav\";\n\t\t\n\t\tint nrAssembls = StructureIO.getNrBiologicalAssemblies(pdbId);\n\t\tassertEquals(1,nrAssembls);\n\t\t\n\t\tpdbId = \"1hv4\";\n\t\tnrAssembls = StructureIO.getNrBiologicalAssemblies(pdbId);\n\t\tassertEquals(2,nrAssembls);\n\t\t\n\t}\n}\n","changedTest":"","commitMessage":"major improvements to parsing of biological assembly / REMARK 350 records\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@9738 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}