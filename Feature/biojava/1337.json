{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/PDBStatus.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/PDBStatusTest.java","prod_time":"2011-04-26 02:01:58","test_time":"2011-04-26 02:01:58","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":23,"add_classname_line":0,"add_condition_line":2,"add_field_line":1,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":3,"del_annotation_line":0,"del_call_line":16,"del_classname_line":0,"del_condition_line":2,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":4,"label":"POSITIVE","prod_commitID":"ef5be99bfba7915433ee57be8062e18f8e58c11b","test_commitID":"ef5be99bfba7915433ee57be8062e18f8e58c11b","isfound":"found test change","originPro":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n * \n * All methods query the PDB website.\n * \n * <p><b>TODO</b> Keep a small cache of queries around, to reduce server load\n * \n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatus {\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\t\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tUNKNOWN;\n\t\t\n\t\t\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tif(statusStr.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse {\n\t\t\t\tstatus = null;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the status of the PDB in question.\n\t * \n\t * <p>Possible return values are:\n\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tList<Attributes> attrList = getStatusIdRecords(new String[] {pdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+pdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tAttributes attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.getValue(\"structureId\");\n\t\tif(id == null || !id.equals(pdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.getValue(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn status;\n\t}\n\t\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to calling\n\t * {@link #getReplacement(String,boolean) getReplacement(oldPdbId,true)}\n\t * \n\t * @param oldPdbId\n\t * @return \n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\treturn getReplacement(oldPdbId,true);\n\t}\n\t\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT ids, this will\n\t * be itself.\n\t * \n\t * @param oldPdbId A pdb ID\n\t * @param recurse If true, return the most current version of oldPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB.\n\t */\n\tpublic static String getReplacement(String oldPdbId, boolean recurse) {\n\t\tList<Attributes> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+oldPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tAttributes attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.getValue(\"structureId\");\n\t\tif(id == null || !id.equals(oldPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.getValue(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// If we're current, just return\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\treturn oldPdbId;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacement = attrs.getValue(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\tSystem.err.format(\"Error: %s is OBSOLETE but lacks a replacedBy attribute.\\n\",oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Return the replacement.\n\t\t\t\tif(recurse) {\n\t\t\t\t\treturn PDBStatus.getReplacement(replacement, recurse);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn replacement;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacement = attrs.getValue(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, assume at the root.\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\treturn oldPdbId;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn replacement;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * Equivalent to {@link #getReplaces(String,boolean) getReplaces(newPdbId, false)}\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @return The ID of the direct ancestor of newPdbId, or <tt>null</tt> if \n\t * \t\t<tt>newPdbId</tt> is the original structure.\n\t */\n\tpublic static String getReplaces(String newPdbId) {\n\t\treturn getReplaces(newPdbId, false);\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return the most oldest version of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return The ID of the direct ancestor of newPdbId, or <tt>null</tt> if \n\t * \t\t<tt>newPdbId</tt> is the original structure.\n\t */\n\tpublic static String getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Attributes> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO is it possible to have multiple results? If so, should return String[] rather than null\n\t\t\tSystem.err.println(\"Error getting Status for \"+newPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tAttributes attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.getValue(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+newPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tString replaced = attrs.getValue(\"replaces\");\n\t\tif(replaced == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\tString root = PDBStatus.getReplaces(replaced, recurse);\n\t\t\tif(root == null) {\n\t\t\t\t//replaced was already root\n\t\t\t\treturn replaced;\n\t\t\t} else {\n\t\t\t\treturn root;\n\t\t\t}\n\t\t} else {\n\t\t\treturn replaced;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t * \n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t * \n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t * \n\t * @param pdbIDs\n\t * @return\n\t */\n\tprivate static List<Attributes> getStatusIdRecords(String[] pdbIDs) {\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse \n\t\t\tSystem.out.format(\"Got System property %s=%s\\n\",PDB_SERVER_PROPERTY,serverName);\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=%s\",serverName,pdbIDs[0]);\n\t\tfor(int i=1;i<pdbIDs.length;i++) {\n\t\t\turlStr += \",\" + pdbIDs[i];\n\t\t}\n\t\t\n\t\t//System.out.println(\"Fetching \" + urlStr);\n\n\t\ttry {\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\t\t\t\n\t\t\t/* // Print file directly\n\t\t\tBufferedReader r = new BufferedReader(new InputStreamReader(uStream));\n\t\t\tString line = r.readLine();\n\t\t\twhile(line != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t\tline = r.readLine();\n\t\t\t}\n\t\t\tr.close();\n\t\t\t\n\t\t\tuStream = url.openStream();\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\t\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\t\t\t\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\t\t\t\n\t\t\treturn handler.getRecords();\n\t\t} catch (Exception e){\n\t\t\tSystem.err.println(\"Problem getting status for \" + pdbIDs.toString() + \" from PDB server.\" );\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t * \n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Attributes> records;\n\t\t\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Attributes>();\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t\t\tAttributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\trecords.add(attributes);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\t\t\n\t\tpublic List<Attributes> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n}","changedPro":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n * \n * All methods query the PDB website.\n * \n * <p><b>TODO</b> Keep a small cache of queries around, to reduce server load\n * \n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatus {\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\t\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tUNKNOWN;\n\t\t\n\t\t\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tif(statusStr.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse {\n\t\t\t\tstatus = null;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the status of the PDB in question.\n\t * \n\t * <p>Possible return values are:\n\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {pdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+pdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(pdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn status;\n\t}\n\t\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to calling\n\t * {@link #getReplacement(String,boolean) getReplacement(oldPdbId,true)}\n\t * \n\t * @param oldPdbId\n\t * @return \n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\treturn getReplacement(oldPdbId,true);\n\t}\n\t\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT ids, this will\n\t * be itself.\n\t * \n\t * @param oldPdbId A pdb ID\n\t * @param recurse If true, return the most current version of oldPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB.\n\t */\n\tpublic static String getReplacement(String oldPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+oldPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(oldPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// If we're current, just return\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\treturn oldPdbId;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacement = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\tSystem.err.format(\"Error: %s is OBSOLETE but lacks a replacedBy attribute.\\n\",oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Return the replacement.\n\t\t\t\tif(recurse) {\n\t\t\t\t\treturn PDBStatus.getReplacement(replacement, recurse);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn replacement;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacement = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, assume at the root.\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\treturn oldPdbId;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn replacement;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * Equivalent to {@link #getReplaces(String,boolean) getReplaces(newPdbId, false)}\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @return A (possibly empty) list of ID(s) of the direct ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId) {\n\t\treturn getReplaces(newPdbId, false);\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimeted 'replaces'\n\t\t\tSystem.err.println(\"Error getting Status for \"+newPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+newPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\t\t\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = Arrays.asList(directDescendents);\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tallDescendents.addAll(roots);\n\t\t\t}\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t * \n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t * \n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t * \n\t * @param pdbIDs\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) {\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse \n\t\t\tSystem.out.format(\"Got System property %s=%s\\n\",PDB_SERVER_PROPERTY,serverName);\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=%s\",serverName,pdbIDs[0]);\n\t\tfor(int i=1;i<pdbIDs.length;i++) {\n\t\t\turlStr += \",\" + pdbIDs[i];\n\t\t}\n\t\t\n\t\t//System.out.println(\"Fetching \" + urlStr);\n\n\t\ttry {\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\t\t\t\n\t\t\t/* // Print file directly\n\t\t\tBufferedReader r = new BufferedReader(new InputStreamReader(uStream));\n\t\t\tString line = r.readLine();\n\t\t\twhile(line != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t\tline = r.readLine();\n\t\t\t}\n\t\t\tr.close();\n\t\t\t\n\t\t\tuStream = url.openStream();\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\t\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\t\t\t\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\t\t\t\n\t\t\treturn handler.getRecords();\n\t\t} catch (Exception e){\n\t\t\tSystem.err.println(\"Problem getting status for \" + pdbIDs.toString() + \" from PDB server.\" );\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t * \n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Map<String,String>> records;\n\t\t\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Map<String,String>>();\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t\t\tAttributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\t//Convert attributes into a Map, as it should have been.\n\t\t\t\t//Important since SAX reuses Attributes objects for different calls\n\t\t\t\tMap<String,String> attrMap = new HashMap<String,String>(attributes.getLength()*2);\n\t\t\t\tfor(int i=0;i<attributes.getLength();i++) {\n\t\t\t\t\tattrMap.put(attributes.getQName(i), attributes.getValue(i));\n\t\t\t\t}\n\t\t\t\trecords.add(attrMap);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\t\t\n\t\tpublic List<Map<String, String>> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n}","originTest":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\n\t *4HHB    CURRENT\n\t *3HHB    CURRENT\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getReplacement(\"1HHB\",false));\n\t\tassertEquals(\"3HHB\",PDBStatus.getReplacement(\"3HHB\",false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"1HHB\",PDBStatus.getReplaces(\"4HHB\"));\n\t\tassertEquals(\"1HHB\",PDBStatus.getReplaces(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getReplaces(\"1HHB\"));\n\t}\n\t\n}\n","changedTest":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getReplacement(\"1HHB\",false));\n\t\tassertEquals(\"3HHB\",PDBStatus.getReplacement(\"3HHB\",false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tassertEquals(\"3ENI\",PDBStatus.getCurrent(\"1KSA\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(new ArrayList<String>(), Arrays.asList(new String[] {}));\n\t\t\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"4HHB\"));\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"3HHB\"));\n\t\tassertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\"));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",true));\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\t\t\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"4HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replaces\",\"1HHB\",attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\t\n}\n","commitMessage":"Changed PDBStatus.\n\n * Changed signature to getReplaces methods to allow multiple values to be returned.\n * Fixed an internal bug involving object reuse that might have been a problem in the future.\n * Updated test cases.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8892 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Changed PDBStatus.\n\n * Changed signature to getReplaces methods to allow multiple values to be returned.\n * Fixed an internal bug involving object reuse that might have been a problem in the future.\n * Updated test cases.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8892 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}