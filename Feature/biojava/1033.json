{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/GenericFastaHeaderParser.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/GenericFastaHeaderParserTest.java","prod_time":"2021-11-15 16:33:52","test_time":"2021-11-15 16:33:52","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":44,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"POSITIVE","prod_commitID":"c6404639a2c32bb28e5598f9d428fcfa1041e8d4","test_commitID":"c6404639a2c32bb28e5598f9d428fcfa1041e8d4","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence.AnnotationType;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\n\n/**\n * The default fasta header parser where some headers are well defined based on the source\n * database which allows us to set the source of the protein sequence and the identifier\n * that can be used in future implementations to load features from external sources\n *\n * If the user has a custom header with local data then they can create their own implementation\n * of a FastaHeaderParserInterface\n *<pre>\n * GenBank                           gi|gi-number|gb|accession|locus\n * ENA Data Library                  gi|gi-number|emb|accession|locus\n * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n * NBRF PIR                          pir||entry\n * Protein Research Foundation       prf||name\n * SWISS-PROT                        sp|accession|name\n * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n * Patents                           pat|country|number\n * GenInfo Backbone Id               bbs|number\n * General database identifier       gnl|database|identifier\n * NCBI Reference Sequence           ref|accession|locus\n * Local Sequence identifier         lcl|identifier\n *</pre>\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParser<S extends AbstractSequence<C>, C extends Compound> implements SequenceHeaderParserInterface<S,C> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParser.class);\n\n\t/**\n\t * Parse out the components where some have a | and others do not\n\t * @param header\n\t * @return\n\t */\n\tprivate String[] getHeaderValues(String header) {\n\t\tString[] data = new String[0];\n\t\tArrayList<String> values = new ArrayList<String>();\n\t\tStringBuffer sb = new StringBuffer();\n\t\t//commented out 1/11/2012 to resolve an issue where headers do contain a length= at the end that are not recognized\n\t\t//if(header.indexOf(\"length=\") != -1){\n\t\t//    data = new String[1];\n\t\t//    int index = header.indexOf(\"length=\");\n\t\t//    data[0] = header.substring(0, index).trim();\n\t//        logger.debug(\"accession=\" + data[0]);\n\t\t//    return data;\n\t\t//} else\n\t\t if (!header.startsWith(\"PDB:\")) {\n\t\t\tfor (int i = 0; i < header.length(); i++) {\n\t\t\t\tif (header.charAt(i) == '|') {\n\t\t\t\t\tvalues.add(sb.toString());\n\t\t\t\t\tsb.setLength(0);//faster than  = new StringBuffer();\n\t\t\t\t} else if (i == header.length() - 1) {\n\t\t\t\t\tsb.append(header.charAt(i));\n\t\t\t\t\tvalues.add(sb.toString());\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(header.charAt(i));\n\t\t\t\t}\n\n\t\t\t\tdata = new String[values.size()];\n\t\t\t\tvalues.toArray(data);\n\t\t\t}\n\t\t} else {\n\t\t\tdata = header.split(\" \");\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Parse the header and set the values in the sequence\n\t * @param header\n\t * @param sequence\n\t */\n\t@Override\n\tpublic void parseHeader(String header, S sequence) {\n\t\t//uniptrot\n\t\t// tr|Q0TET7|Q0TET7_ECOL5 Putative uncharacterized protein OS=Escherichia coli O6:K15:H31 (strain 536 / UPEC) GN=ECP_2553 PE=4 SV=1\n\t\tsequence.setOriginalHeader(header);\n\t\tString[] data = getHeaderValues(header);\n\n\t\tif (data.length == 1) {\n\t\t\tsequence.setAccession(new AccessionID(data[0]));\n\t\t} else  if (data[0].equalsIgnoreCase(\"sp\") || data[0].equalsIgnoreCase(\"tr\")) {\n\t\t\tif (data[0].equalsIgnoreCase(\"sp\")) {\n\t\t\t\tsequence.setAnnotationType(AnnotationType.CURATED);\n\t\t\t} else {\n\t\t\t\tsequence.setAnnotationType(AnnotationType.PREDICTED);\n\t\t\t}\n\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.UNIPROT));\n\t\t\tif (data.length > 2) {\n\t\t\t\tsequence.setDescription(data[2]);\n\t\t\t}\n\n\t\t} else if (data[0].equalsIgnoreCase(\"gi\")) {\n\t\t\tDataSource giSource = DataSource.UNKNOWN;\n\t\t\tif (data.length >= 3) {\n\t\t\t\tif (data[2].equalsIgnoreCase(\"gb\")) {\n\t\t\t\t\tgiSource = DataSource.GENBANK;\n\t\t\t\t} else if (data[2].equalsIgnoreCase(\"emb\")) {\n\t\t\t\t\tgiSource = DataSource.ENA;\n\t\t\t\t} else if (data[2].equalsIgnoreCase(\"dbj\")) {\n\t\t\t\t\tgiSource = DataSource.DDBJ;\n\t\t\t\t}\n\t\t\t\tsequence.setAccession(new AccessionID(data[3], giSource));\n\t\t\t} else {\n\t\t\t\tsequence.setAccession(new AccessionID(header, giSource));\n\t\t\t}\n\t\t} else if (data[0].equalsIgnoreCase(\"pir\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.NBRF));\n\t\t} else if (data[0].equalsIgnoreCase(\"prf\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.PRF));\n\t\t} else if (data[0].equalsIgnoreCase(\"pdb\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1] + \":\" + data[2], DataSource.PDB1));\n\t\t} else if (data[0].startsWith(\"PDB\")) {\n\t\t\tString[] pdbe = data[0].split(\" \");\n\t\t\tString[] pdbaccession = pdbe[0].split(\":\");\n\t\t\tsequence.setAccession(new AccessionID(pdbaccession[1], DataSource.PDBe));\n\t\t} else if (data[0].indexOf(\":\") != -1 && data.length > 1 && data[1].equals(\"PDBID\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[0], DataSource.PDB2));\n\t\t} else if (data[0].equalsIgnoreCase(\"pat\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.PATENTS));\n\t\t} else if (data[0].equalsIgnoreCase(\"bbs\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.GENINFO));\n\t\t} else if (data[0].equalsIgnoreCase(\"gnl\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.GENERAL));\n\t\t} else if (data[0].equalsIgnoreCase(\"ref\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.NCBI));\n\t\t} else if (data[0].equalsIgnoreCase(\"lcl\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.LOCAL));\n\t\t} else {\n\t\t\tsequence.setAccession(new AccessionID(data[0])); // avoid the common problem of picking up all the comments original header in getOriginalHeader\n\t\t}\n\n\n\t}\n\n\t/**\n\t *\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\n\t\tlogger.info(\"parseHeader\");\n\t\tString header = \"\";\n\t\tProteinSequence sequence = null;\n\t\ttry {\n\t\t\tsequence = new ProteinSequence(\"\");\n\t\t} catch (CompoundNotFoundException e) {\n\t\t\t// this should not happen, in case it does we log error\n\t\t\tlogger.error(\"Could not create empty protein sequence. Error: {}. This is most likely a bug.\",e.getMessage());\n\t\t}\n\t\tGenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance =\n\t\t  new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n\t\theader = \"gi|gi-number|gb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"accession = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n\t\theader = \"gi|gi-number|emb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"accession = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.ENA);\n\n\t\theader = \"gi|gi-number|dbj|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"accession = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n\t\theader = \"pir||entry\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"entry = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n\t\theader = \"prf||name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"name = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PRF);\n\n\t\theader = \"sp|accession|name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"accession = \", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n\t\theader = \"pdb|entry|chain\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"entry:chain = \", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n\t\theader = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"entry:chain = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB2);\n\n\t\theader = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"1ECY_A = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n\t\theader = \"pat|country|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"number = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n\t\theader = \"bbs|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"number = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n\t\theader = \"gnl|database|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"identifier = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n\t\theader = \"ref|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"accession = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n\t\theader = \"lcl|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tlogger.info(\"identifier = {}\", sequence.getAccession());\n\t\tlogger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.LOCAL);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence.AnnotationType;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\n\n/**\n * The default fasta header parser where some headers are well defined based on the source\n * database which allows us to set the source of the protein sequence and the identifier\n * that can be used in future implementations to load features from external sources\n *\n * If the user has a custom header with local data then they can create their own implementation\n * of a FastaHeaderParserInterface\n *<pre>\n * GenBank                           gi|gi-number|gb|accession|locus\n * ENA Data Library                  gi|gi-number|emb|accession|locus\n * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n * NBRF PIR                          pir||entry\n * Protein Research Foundation       prf||name\n * SWISS-PROT                        sp|accession|name\n * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n * Patents                           pat|country|number\n * GenInfo Backbone Id               bbs|number\n * General database identifier       gnl|database|identifier\n * NCBI Reference Sequence           ref|accession|locus\n * Local Sequence identifier         lcl|identifier\n *</pre>\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParser<S extends AbstractSequence<C>, C extends Compound> implements SequenceHeaderParserInterface<S,C> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParser.class);\n\n\t/**\n\t * Parse out the components where some have a | and others do not\n\t * @param header\n\t * @return\n\t */\n\tprivate String[] getHeaderValues(String header) {\n\t\tString[] data = new String[0];\n\t\tArrayList<String> values = new ArrayList<String>();\n\t\tStringBuffer sb = new StringBuffer();\n\t\t//commented out 1/11/2012 to resolve an issue where headers do contain a length= at the end that are not recognized\n\t\t//if(header.indexOf(\"length=\") != -1){\n\t\t//    data = new String[1];\n\t\t//    int index = header.indexOf(\"length=\");\n\t\t//    data[0] = header.substring(0, index).trim();\n\t//        logger.debug(\"accession=\" + data[0]);\n\t\t//    return data;\n\t\t//} else\n\t\t if (!header.startsWith(\"PDB:\")) {\n\t\t\tfor (int i = 0; i < header.length(); i++) {\n\t\t\t\tif (header.charAt(i) == '|') {\n\t\t\t\t\tvalues.add(sb.toString());\n\t\t\t\t\tsb.setLength(0);//faster than  = new StringBuffer();\n\t\t\t\t} else if (i == header.length() - 1) {\n\t\t\t\t\tsb.append(header.charAt(i));\n\t\t\t\t\tvalues.add(sb.toString());\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(header.charAt(i));\n\t\t\t\t}\n\n\t\t\t\tdata = new String[values.size()];\n\t\t\t\tvalues.toArray(data);\n\t\t\t}\n\t\t} else {\n\t\t\tdata = header.split(\" \");\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Parse the header and set the values in the sequence\n\t * @param header\n\t * @param sequence\n\t */\n\t@Override\n\tpublic void parseHeader(String header, S sequence) {\n\t\t//uniptrot\n\t\t// tr|Q0TET7|Q0TET7_ECOL5 Putative uncharacterized protein OS=Escherichia coli O6:K15:H31 (strain 536 / UPEC) GN=ECP_2553 PE=4 SV=1\n\t\tsequence.setOriginalHeader(header);\n\t\tString[] data = getHeaderValues(header);\n\n\t\tif (data.length == 1) {\n\t\t\tsequence.setAccession(new AccessionID(data[0]));\n\t\t} else  if (data[0].equalsIgnoreCase(\"sp\") || data[0].equalsIgnoreCase(\"tr\")) {\n\t\t\tif (data[0].equalsIgnoreCase(\"sp\")) {\n\t\t\t\tsequence.setAnnotationType(AnnotationType.CURATED);\n\t\t\t} else {\n\t\t\t\tsequence.setAnnotationType(AnnotationType.PREDICTED);\n\t\t\t}\n\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.UNIPROT));\n\t\t\tif (data.length > 2) {\n\t\t\t\tsequence.setDescription(data[2]);\n\t\t\t}\n\n\t\t} else if (data[0].equalsIgnoreCase(\"gi\")) {\n\t\t\tDataSource giSource = DataSource.UNKNOWN;\n\t\t\tif (data.length >= 3) {\n\t\t\t\tif (data[2].equalsIgnoreCase(\"gb\")) {\n\t\t\t\t\tgiSource = DataSource.GENBANK;\n\t\t\t\t} else if (data[2].equalsIgnoreCase(\"emb\")) {\n\t\t\t\t\tgiSource = DataSource.ENA;\n\t\t\t\t} else if (data[2].equalsIgnoreCase(\"dbj\")) {\n\t\t\t\t\tgiSource = DataSource.DDBJ;\n\t\t\t\t}\n\t\t\t\tsequence.setAccession(new AccessionID(data[3], giSource));\n\t\t\t} else {\n\t\t\t\tsequence.setAccession(new AccessionID(header, giSource));\n\t\t\t}\n\t\t} else if (data[0].equalsIgnoreCase(\"pir\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.NBRF));\n\t\t} else if (data[0].equalsIgnoreCase(\"prf\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.PRF));\n\t\t} else if (data[0].equalsIgnoreCase(\"pdb\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1] + \":\" + data[2], DataSource.PDB1));\n\t\t} else if (data[0].startsWith(\"PDB\")) {\n\t\t\tString[] pdbe = data[0].split(\" \");\n\t\t\tString[] pdbaccession = pdbe[0].split(\":\");\n\t\t\tsequence.setAccession(new AccessionID(pdbaccession[1], DataSource.PDBe));\n\t\t} else if (data[0].indexOf(\":\") != -1 && data.length > 1 && data[1].equals(\"PDBID\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[0], DataSource.PDB2));\n\t\t} else if (data[0].equalsIgnoreCase(\"pat\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.PATENTS));\n\t\t} else if (data[0].equalsIgnoreCase(\"bbs\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.GENINFO));\n\t\t} else if (data[0].equalsIgnoreCase(\"gnl\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[2], DataSource.GENERAL));\n\t\t} else if (data[0].equalsIgnoreCase(\"ref\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.NCBI));\n\t\t} else if (data[0].equalsIgnoreCase(\"lcl\")) {\n\t\t\tsequence.setAccession(new AccessionID(data[1], DataSource.LOCAL));\n\t\t} else {\n\t\t\tsequence.setAccession(new AccessionID(data[0])); // avoid the common problem of picking up all the comments original header in getOriginalHeader\n\t\t}\n\n\n\t}\n\n\t\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParserTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParserTest.class);\n\n\tpublic GenericFastaHeaderParserTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws Exception {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() throws Exception {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * GenBank                           gi|gi-number|gb|accession|locus\n\t * ENA Data Library                 gi|gi-number|emb|accession|locus\n\t * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n\t * NBRF PIR                          pir||entry\n\t * Protein Research Foundation       prf||name\n\t * SWISS-PROT                        sp|accession|name\n\t * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n\t * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n\t * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n\t * Patents                           pat|country|number\n\t * GenInfo Backbone Id               bbs|number\n\t * General database identifier       gnl|database|identifier\n\t * NCBI Reference Sequence           ref|accession|locus\n\t * Local Sequence identifier         lcl|identifier\n\t *\n\t * @author Scooter Willis <willishf at gmail dot com>\n\t */\n\t@Test\n\tpublic void testParseHeader() throws CompoundNotFoundException {\n\t\tlogger.info(\"parseHeader\");\n\t\tString header = \"\";\n\t\tProteinSequence sequence = new ProteinSequence(\"\");\n\t\tGenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance = new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n\t\theader = \"gi|gi-number|gb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n\t\theader = \"gi|gi-number|emb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.ENA);\n\n\t\theader = \"gi|gi-number|dbj|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n\t\theader = \"pir||entry\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n\t\theader = \"prf||name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"name\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PRF);\n\n\t\theader = \"sp|accession|name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n\t\theader = \"pdb|entry|chain\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry:chain\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n\t\theader = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry:chain\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDB2);\n\t\theader = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"1ECY_A\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n\t\theader = \"pat|country|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"number\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n\t\theader = \"bbs|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"number\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n\t\theader = \"gnl|database|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"identifier\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n\t\theader = \"ref|accession|locus\";\n\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n\t\theader = \"lcl|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"identifier\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.LOCAL);\n\t\t// TODO review the generated test code and remove the default call to fail.\n\t\t//fail(\"The test case is a prototype.\");\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DataSource;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParserTest {\n\n\t/**\n\t * GenBank                           gi|gi-number|gb|accession|locus\n\t * ENA Data Library                 gi|gi-number|emb|accession|locus\n\t * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n\t * NBRF PIR                          pir||entry\n\t * Protein Research Foundation       prf||name\n\t * SWISS-PROT                        sp|accession|name\n\t * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n\t * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n\t * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n\t * Patents                           pat|country|number\n\t * GenInfo Backbone Id               bbs|number\n\t * General database identifier       gnl|database|identifier\n\t * NCBI Reference Sequence           ref|accession|locus\n\t * Local Sequence identifier         lcl|identifier\n\t *\n\t * @author Scooter Willis <willishf at gmail dot com>\n\t */\n\t@Test\n\tpublic void testParseHeader() throws CompoundNotFoundException {\n\t\tString header = \"\";\n\t\tProteinSequence sequence = new ProteinSequence(\"\");\n\t\tGenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance = new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n\t\theader = \"gi|gi-number|gb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n\t\theader = \"gi|gi-number|emb|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.ENA);\n\n\t\theader = \"gi|gi-number|dbj|accession|locus\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n\t\theader = \"pir||entry\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n\t\theader = \"prf||name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"name\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PRF);\n\n\t\theader = \"sp|accession|name\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n\t\theader = \"pdb|entry|chain\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry:chain\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n\t\theader = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"entry:chain\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDB2);\n\t\theader = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"1ECY_A\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n\t\theader = \"pat|country|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"number\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n\t\theader = \"bbs|number\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"number\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n\t\theader = \"gnl|database|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"identifier\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n\t\theader = \"ref|accession|locus\";\n\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"accession\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n\t\theader = \"lcl|identifier\";\n\t\tinstance.parseHeader(header, sequence);\n\t\tassertEquals(\"identifier\", sequence.getAccession().getID());\n\t\tassertEquals(sequence.getAccession().getDataSource(), DataSource.LOCAL);\n\t\t\n\t}\n}\n","commitMessage":"remove GenericFastaHeaderParser  main- duplicate of unit test\n","test_commitMessage":"remove GenericFastaHeaderParser  main- duplicate of unit test\n","allZero":false}