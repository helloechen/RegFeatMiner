{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/domain/EcodInstallation.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/domain/EcodInstallationTest.java","prod_time":"2015-03-10 18:18:19","test_time":"2015-03-10 18:21:48","type":"RENAME","proType":"EDIT","add_annotation_line":0,"add_call_line":32,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"a26fd9b261e3c99160ea00034f026853e6e1f7f0","test_commitID":"3946214c51da93e03897bcc7cc07196d74267e97","isfound":"found test change","originPro":"package org.biojava.nbio.structure.domain;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class EcodInstallation {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"e(....)(.)(.)\");\n\n\n\tprivate String cacheLocation;\n\tprivate String version;\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<String,List<EcodDomain>> domainMap;//PDB ID -> domains\n\n\tprivate String url;\n\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.version = DEFAULT_VERSION;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\tpublic EcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath() );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param pdbId\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\tpublic List<EcodDomain> getDomainsForPDB(String pdbId) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t}\n\n\t\t\tif(pdbId != null)\n\t\t\t\tpdbId = pdbId.toLowerCase();\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPDB(pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tdomainsFileLock.readLock().lock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();;\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\tpublic void setVersion(String version) {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tif(version.equals(this.version)) {\n\t\t\t\treturn; //no change\n\t\t\t}\n\t\t} finally {\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// update version and force reparsing\n\t\tdomainsFileLock.writeLock().lock();\n\t\ttry {\n\t\t\tthis.version = version;\n\t\t\tthis.clear();\n\t\t} finally {\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tthis.cacheLocation = cacheLocation;\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t * \n\t * This may be useful in multithreaded environments\n\t * @throws IOException\n\t */\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\treturn f.exists() && f.length()>0;\n\t\t} finally {\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current version.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,getVersion());\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t} finally {\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap\n\t * @throws IOException \n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<String, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tString pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = match.group(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\n\t\tprivate final List<EcodDomain> domains;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tdomains =Collections.unmodifiableList( parse(reader) );\n\t\t}\n\n\t\tprivate static List<EcodDomain> parse(BufferedReader in) throws IOException {\n\t\t\tArrayList<EcodDomain> domains = null;\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015 \n\t\t\t\tdomains = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 0;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Ignore comments\n\t\t\t\t\tif( line.charAt(0) != '#' ) {\n\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\tif( fields.length == 13 ) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\t\t\t\t\t\t\t\tBoolean manual = null;\n\n\t\t\t\t\t\t\t\t// heirarchical field, e.g. \"1.1.4\"\n\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\tif(xhtGroup.length != 3) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for heirarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\t\t\t\t\t\t\t\tBoolean isAssembly = null;\n\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\tif(assemblyStr.equals(\"NOT_DOMAIN_ASSEMBLY\")) {\n\t\t\t\t\t\t\t\t\tisAssembly = false;\n\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\")) {\n\t\t\t\t\t\t\t\t\tisAssembly = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for assembly field \\\"{}\\\" in line {}\",assemblyStr,lineNum);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, pdbId, chainId, range, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, isAssembly, ligands);\n\t\t\t\t\t\t\t\tdomains.add(domain);\n\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}\",lineNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domains.size());\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.domain;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class EcodInstallation {\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallation.class);\n\n\tpublic static final String DEFAULT_VERSION = \"latest\";\n\tprivate static final String DOMAINS_FILENAME_FORMAT = \"ecod.%s.domains.txt\";\n\n\tpublic static final String ECOD_URL = \"http://prodata.swmed.edu\";\n\tpublic static final String DOMAINS_PATH = \"/ecod/distributions/\";\n\n\tpublic static final Pattern ECOD_RE = Pattern.compile(\"e(....)(.)(.)\");\n\n\n\tprivate String cacheLocation;\n\tprivate String version;\n\n\t// lock to prevent multiple threads from downloading simultaneously\n\t// Should hold the lock when reading/writing allDomains or domainMap\n\tprivate ReadWriteLock domainsFileLock;\n\tprivate List<EcodDomain> allDomains;\n\tprivate Map<String,List<EcodDomain>> domainMap;//PDB ID -> domains\n\n\tprivate String url;\n\n\tpublic EcodInstallation(String cacheLocation) {\n\t\tdomainsFileLock = new ReentrantReadWriteLock();\n\n\t\tthis.cacheLocation = cacheLocation;\n\n\t\tthis.version = DEFAULT_VERSION;\n\t\tthis.url = ECOD_URL;\n\n\t\tallDomains = null; // null signals it needs to be parsed\n\t\tdomainMap = null; // null signals it needs to be constructed from allDomains\n\t}\n\n\tpublic EcodInstallation() {\n\t\tthis( new UserConfiguration().getCacheFilePath() );\n\t}\n\n\t/**\n\t * Get a list of all ECOD domains for a particular PDB ID\n\t * @param pdbId\n\t * @return the list of domains, or null if no matching domains were found\n\t * @throws IOException\n\t */\n\tpublic List<EcodDomain> getDomainsForPDB(String pdbId) throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\ttry {\n\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\twhile( domainMap == null ) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tindexDomains();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\n\t\t\tif(pdbId != null)\n\t\t\t\tpdbId = pdbId.toLowerCase();\n\t\t\tList<EcodDomain> doms = domainMap.get(pdbId);\n\t\t\tif(doms == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Deep clone\n\t\t\tList<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n\t\t\tfor(EcodDomain d : doms) {\n\t\t\t\tclonedDoms.add( new EcodDomain(d) );\n\t\t\t}\n\t\t\treturn clonedDoms;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\tpublic EcodDomain getDomainsById(String ecodId) throws IOException {\n\t\tif(ecodId == null || ecodId.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\n\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\tString pdbId = null;\n\t\tif( match.matches() )\n\t\t\tpdbId = match.group(1);\n\t\tList<EcodDomain> doms = getDomainsForPDB(pdbId);\n\t\tif(doms == null) {\n\t\t\tlogger.debug(\"Null domains for {} from {}\",pdbId,ecodId);\n\t\t\treturn null;\n\t\t}\n\t\tlogger.debug(\"Got {} domains from {}\",doms.size(),pdbId);\n\t\tfor(EcodDomain d: doms) {\n\t\t\tif(ecodId.equals(d.getDomainId())) {\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic List<EcodDomain> getAllDomains() throws IOException {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\twhile( allDomains == null) {\n\t\t\t\t// unlock to allow ensureDomainsFileInstalled to get the write lock\n\t\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\t\tdomainsFileLock.readLock().unlock();\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t\tdomainsFileLock.readLock().lock();\n\t\t\t\tlogger.trace(\"LOCK readlock\");\n\t\t\t}\n\t\t\treturn allDomains;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t}\n\n\t/**\n\t * Clears all domains, requiring the file to be reparsed for subsequent accesses\n\t */\n\tpublic void clear() {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tallDomains = null;\n\t\tdomainMap = null;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\tpublic String getVersion() {\n\t\treturn version;\n\t}\n\tpublic void setVersion(String version) {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif(version.equals(this.version)) {\n\t\t\t\treturn; //no change\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// update version and force reparsing\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tthis.version = version;\n\t\t\tthis.clear();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n\t * @return the url to the ecod server\n\t */\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\n\t/**\n\t * Specify a different mirror for the ECOD server.\n\t * @param urlFormat the urlFormat to set\n\t */\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\n\t/**\n\t * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n\t * property). ECOD files will be downloaded to this directory\n\t * @return\n\t */\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\t/**\n\t * Set an alternate download location for files\n\t * @param cacheLocation\n\t */\n\tpublic void setCacheLocation(String cacheLocation) {\n\t\tif(cacheLocation.equals(this.cacheLocation)) {\n\t\t\treturn; //no change\n\t\t}\n\t\t// update location\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\tthis.cacheLocation = cacheLocation;\n\t\tlogger.trace(\"UNLOCK writelock\");\n\t\tdomainsFileLock.writeLock().unlock();\n\t}\n\n\t/**\n\t * Blocks until ECOD domains file has been downloaded and parsed.\n\t * \n\t * This may be useful in multithreaded environments\n\t * @throws IOException\n\t */\n\tpublic void ensureDomainsFileInstalled() throws IOException{\n\t\t// Quick check for availability\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tif( allDomains != null ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\n\t\t// Download domains\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( !domainsAvailable() ) {\n\t\t\t\tdownloadDomains();\n\t\t\t}\n\t\t\tparseDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Checks that the domains file has been downloaded\n\t * @return\n\t */\n\tprivate boolean domainsAvailable() {\n\t\tdomainsFileLock.readLock().lock();\n\t\tlogger.trace(\"LOCK readlock\");\n\t\ttry {\n\t\t\tFile f = getDomainFile();\n\n\t\t\treturn f.exists() && f.length()>0;\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK readlock\");\n\t\t\tdomainsFileLock.readLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Downloads the domains file, overwriting any existing file\n\t * @throws IOException\n\t */\n\tprivate void downloadDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tURL domainsURL = new URL( url + DOMAINS_PATH + getDomainFilename());\n\t\t\tFile localFile = getDomainFile();\n\n\t\t\tlogger.info(\"Downloading {} to: {}\",domainsURL, localFile);\n\t\t\tFileDownloadUtils.downloadFile(domainsURL, localFile);\n\t\t} catch (MalformedURLException e) {\n\t\t\tlogger.error(\"Malformed url: \"+ url + DOMAINS_PATH + getDomainFilename(),e);\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Basename for the domains file with the current version.\n\t * @return\n\t */\n\tprivate String getDomainFilename() {\n\t\treturn  String.format(DOMAINS_FILENAME_FORMAT,getVersion());\n\t}\n\n\t/**\n\t * Local location for the domain file\n\t * @return\n\t */\n\tprivate File getDomainFile() {\n\t\treturn new File(getCacheLocation(),getDomainFilename());\n\t}\n\n\t/**\n\t * Parses the domains from the local file\n\t * @throws IOException\n\t */\n\tprivate void parseDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(getDomainFile());\n\t\t\tallDomains = parser.getDomains();\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\t}\n\n\t/**\n\t * Populates domainMap\n\t * @throws IOException \n\t */\n\tprivate void indexDomains() throws IOException {\n\t\tdomainsFileLock.writeLock().lock();\n\t\tlogger.trace(\"LOCK writelock\");\n\t\ttry {\n\t\t\tif( allDomains == null) {\n\t\t\t\tensureDomainsFileInstalled();\n\t\t\t}\n\n\t\t\t// Leave enough space for all PDBs as of 2015\n\t\t\tdomainMap = new HashMap<String, List<EcodDomain>>((int) (150000/.85),.85f);\n\n\t\t\t// Index with domainMap\n\t\t\tfor(EcodDomain d : allDomains) {\n\t\t\t\t// Get the PDB ID, either directly or from the domain ID\n\t\t\t\tString pdbId = d.getPdbId();\n\t\t\t\tif( pdbId == null ) {\n\t\t\t\t\tString ecodId = d.getDomainId();\n\t\t\t\t\tif( ecodId != null && !ecodId.isEmpty() ) {\n\t\t\t\t\t\tMatcher match = ECOD_RE.matcher(ecodId);\n\t\t\t\t\t\tpdbId = match.group(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Add current domain to the map\n\t\t\t\tList<EcodDomain> currDomains;\n\t\t\t\tif( domainMap.containsKey(pdbId) ) {\n\t\t\t\t\tcurrDomains = domainMap.get(pdbId);\n\t\t\t\t} else {\n\t\t\t\t\tcurrDomains = new LinkedList<EcodDomain>();\n\t\t\t\t\tdomainMap.put(pdbId,currDomains);\n\t\t\t\t}\n\t\t\t\tcurrDomains.add(d);\n\t\t\t}\n\t\t} finally {\n\t\t\tlogger.trace(\"UNLOCK writelock\");\n\t\t\tdomainsFileLock.writeLock().unlock();\n\t\t}\n\n\t}\n\n\n\tpublic static class EcodParser {\n\n\t\tprivate final List<EcodDomain> domains;\n\n\t\tpublic EcodParser(String filename) throws IOException {\n\t\t\tthis(new File(filename));\n\t\t}\n\t\tpublic EcodParser(File file) throws IOException {\n\t\t\tthis(new FileReader(file));\n\t\t}\n\t\tpublic EcodParser(Reader reader) throws IOException {\n\t\t\tthis(new BufferedReader(reader));\n\t\t}\n\t\tpublic EcodParser(BufferedReader reader) throws IOException {\n\t\t\tdomains =Collections.unmodifiableList( parse(reader) );\n\t\t}\n\n\t\tprivate static List<EcodDomain> parse(BufferedReader in) throws IOException {\n\t\t\tArrayList<EcodDomain> domains = null;\n\t\t\ttry {\n\t\t\t\t// Allocate plenty of space for ECOD as of 2015 \n\t\t\t\tdomains = new ArrayList<EcodDomain>(500000);\n\n\t\t\t\tString line = in.readLine();\n\t\t\t\tint lineNum = 0;\n\t\t\t\twhile( line != null ) {\n\t\t\t\t\t// Ignore comments\n\t\t\t\t\tif( line.charAt(0) != '#' ) {\n\t\t\t\t\t\tString[] fields = line.split(\"\\t\");\n\t\t\t\t\t\tif( fields.length == 13 ) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tint i = 0; // field number, to allow future insertion of fields\n\n\t\t\t\t\t\t\t\tLong uid = Long.parseLong(fields[i++]);\n\t\t\t\t\t\t\t\tString domainId = fields[i++];\n\t\t\t\t\t\t\t\tBoolean manual = null;\n\n\t\t\t\t\t\t\t\t// heirarchical field, e.g. \"1.1.4\"\n\t\t\t\t\t\t\t\tString[] xhtGroup = fields[i++].split(\"\\\\.\");\n\t\t\t\t\t\t\t\tif(xhtGroup.length != 3) {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected format for heirarchical field \\\"{}\\\" in line {}\",fields[i-1],lineNum);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tInteger xGroup = xhtGroup.length>0 ? Integer.parseInt(xhtGroup[0]) : null;\n\t\t\t\t\t\t\t\tInteger hGroup = xhtGroup.length>1 ? Integer.parseInt(xhtGroup[1]) : null;\n\t\t\t\t\t\t\t\tInteger tGroup = xhtGroup.length>2 ? Integer.parseInt(xhtGroup[2]) : null;\n\n\t\t\t\t\t\t\t\tString pdbId = fields[i++];\n\t\t\t\t\t\t\t\tString chainId = fields[i++];\n\t\t\t\t\t\t\t\tString range = fields[i++];\n\n\t\t\t\t\t\t\t\t// Intern strings likely to be shared by many domains\n\t\t\t\t\t\t\t\tString architectureName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString xGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString hGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString tGroupName = fields[i++].intern();\n\t\t\t\t\t\t\t\tString fGroupName = fields[i++].intern();\n\n\t\t\t\t\t\t\t\tBoolean isAssembly = null;\n\t\t\t\t\t\t\t\tString assemblyStr = fields[i++];\n\t\t\t\t\t\t\t\tif(assemblyStr.equals(\"NOT_DOMAIN_ASSEMBLY\")) {\n\t\t\t\t\t\t\t\t\tisAssembly = false;\n\t\t\t\t\t\t\t\t} else if(assemblyStr.equals(\"IS_DOMAIN_ASSEMBLY\")) {\n\t\t\t\t\t\t\t\t\tisAssembly = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlogger.warn(\"Unexpected value for assembly field \\\"{}\\\" in line {}\",assemblyStr,lineNum);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tString ligandStr = fields[i++];\n\t\t\t\t\t\t\t\tSet<String> ligands = null;\n\t\t\t\t\t\t\t\tif( ligandStr.equals(\"NO_LIGANDS_4A\") || ligandStr.isEmpty() ) {\n\t\t\t\t\t\t\t\t\tligands = Collections.emptySet();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tString[] ligSplit = ligandStr.split(\",\");\n\t\t\t\t\t\t\t\t\tligands = new LinkedHashSet<String>(ligSplit.length);\n\t\t\t\t\t\t\t\t\tfor(String s : ligSplit) {\n\t\t\t\t\t\t\t\t\t\tligands.add(s.intern());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\tEcodDomain domain = new EcodDomain(uid, domainId, manual, xGroup, hGroup, tGroup, pdbId, chainId, range, architectureName, xGroupName, hGroupName, tGroupName, fGroupName, isAssembly, ligands);\n\t\t\t\t\t\t\t\tdomains.add(domain);\n\t\t\t\t\t\t\t} catch(NumberFormatException e) {\n\t\t\t\t\t\t\t\tlogger.warn(\"Error in ECOD parsing at line \"+lineNum,e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warn(\"Unexpected number of fields in line {}\",lineNum);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\tlineNum++;\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Parsed {} ECOD domains\",domains.size());\n\t\t\t} finally {\n\t\t\t\tif(in != null) {\n\t\t\t\t\tin.close();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domains;\n\t\t}\n\n\t\t/**\n\t\t * @return a list of all EcodDomains\n\t\t */\n\t\tpublic List<EcodDomain> getDomains() {\n\t\t\treturn domains;\n\t\t}\n\t}\n\n\n\tpublic static void main(String[] args) {\n\t\tif( args.length!= 1) {\n\t\t\tSystem.out.println(\"usage: ecod_domains.txt\");\n\t\t\tSystem.exit(1); return;\n\t\t}\n\n\t\tString filename = args[0];\n\n\t\ttry {\n\t\t\tEcodParser parser = new EcodParser(filename);\n\n\t\t\tList<EcodDomain> domains = parser.getDomains();\n\n\t\t\tSystem.out.format(\"Found %d ECOD domains.%n\",domains.size());\n\n\t\t\tSystem.out.println(\"First 10 domains:\");\n\t\t\tint i = 0;\n\t\t\tfor(EcodDomain d: domains) {\n\t\t\t\tif( i>10) break;\n\n\t\t\t\tSystem.out.println(d.getDomainId());\n\t\t\t\ti++;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n","originTest":"/**\n * \n */\npackage org.biojava.nbio.structure.domain;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.biojava.nbio.core.util.ConcurrencyTools;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class EcodDomainTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodDomainTest.class);\n\tprivate static EcodInstallation ecod;\n\tprivate static final String VERSION = \"develop77\";\n\n\t// Set up static ecod singleton\n\tstatic {\n\t\tecod = new EcodInstallation();\n\t\tecod.setVersion(VERSION);\n\t}\n\n\tstatic {\n\t\t//System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\");\n\t\t} \n\t@Rule\n\tpublic TemporaryFolder tmpFolder = new TemporaryFolder();\n\t@Test\n\tpublic void testDownloads() throws IOException {\n\t\t// Use second installation with tmp location to avoid overwriting main cache\n\t\tEcodInstallation ecod2 = new EcodInstallation(tmpFolder.getRoot().getAbsolutePath());\n\t\tecod2.setVersion(VERSION);\n\t\t// Delete old VERSION\n\t\tFile domainsFile = new File(ecod2.getCacheLocation(),\"ecod.\"+VERSION+\".domains.txt\");\n\t\tif( domainsFile.exists() ) {\n\t\t\tdomainsFile.delete();\n\t\t}\n\t\t// Force download\n\t\tecod2.ensureDomainsFileInstalled();\n\t\t// Check for download\n\t\tassertTrue(\"No downloaded file at \"+domainsFile.toString(),domainsFile.exists());\n\t}\n\n\t@Test\n\tpublic void testAllDomains() throws IOException {\n\t\tList<EcodDomain> domains = ecod.getAllDomains();\n\t\tassertEquals(\"Wrong number of domains\",423779,domains.size());\n\t}\n\n\t@Test\n\tpublic void testByPDB() throws IOException {\n\t\tString pdbId;\n\t\tString[] expectedDomains;\n\t\tList<EcodDomain> domains;\n\n\t\tpdbId = \"1lyw\";\n\t\texpectedDomains = new String[] {\"e1lyw.1\",\"e1lyw.2\",\"e1lyw.3\",\"e1lyw.4\"};\n\t\tdomains = ecod.getDomainsForPDB(pdbId);\n\n\t\tmatchNames(pdbId,expectedDomains,domains);\n\n\t}\n\n\tprivate void matchNames(String pdbId,String[] expected,List<EcodDomain> actual) {\n\t\tassertEquals(\"Wrong number of domains for \"+pdbId, expected.length, actual.size());\n\t\tSet<String> exp = new HashSet<String>(Arrays.asList(expected));\n\t\tfor(EcodDomain d : actual) {\n\t\t\tassertTrue(\"Unexpected domain \"+d.getDomainId()+\" in \"+pdbId,exp.contains(d.getDomainId()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testParsing() throws IOException {\n\t\tString ecodId;\n\t\tEcodDomain domain,expected;\n\n\t\tecodId = \"e1lyw.1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\texpected = new EcodDomain(\n\t\t\t\t//\t\t\t\tLong uid, String domainId, Boolean manual,\n\t\t\t\t20669l, \"e1lyw.1\", null,\n\t\t\t\t//\t\t\t\tInteger xGroup, Integer hGroup, Integer tGroup, String pdbId,\n\t\t\t\t1,1,1,\"1lyw\",\n\t\t\t\t//\t\t\t\tString chainId, String range, String architectureName,\n\t\t\t\t\".\", \"A:3-97,B:106-346\", \"beta barrels\",\n\t\t\t\t//\t\t\t\tString xGroupName, String hGroupName, String tGroupName,\n\t\t\t\t//\t\t\t\tString fGroupName, Boolean isAssembly, List<String> ligands\n\t\t\t\t\"cradle loop barrel\", \"RIFT-related\", \"acid protease\",\n\t\t\t\t\"UNK_F_TYPE\", false, Collections.singleton(\"EPE\")\n\t\t\t\t);\n\t\tassertEquals(ecodId,expected,domain);\n\n\t}\n\n\t@Test\n\tpublic void testMultithreaded() throws IOException {\n\t\tecod.clear();\n\t\tString[] ecodIds = new String[] {\n\t\t\t\t\"e4s1gA1\", \"e4umoB1\", \"e4v0cA1\", \"e4v1af1\", \"e3j7yj1\", \"e4wfcA1\",\"e4b0jP1\",\n\t\t};\n\t\tList<Future<EcodDomain>> futureDomains = new ArrayList<Future<EcodDomain>>();\n\t\tfor(final String ecodId : ecodIds) {\n\t\t\tCallable<EcodDomain> job = new Callable<EcodDomain>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EcodDomain call() throws Exception {\n\t\t\t\t\tlogger.info(\"Running \"+ecodId);\n\t\t\t\t\tEcodDomain d = ecod.getDomainsById(ecodId);\n\t\t\t\t\tlogger.info(\"Finished \"+ecodId);\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Job fetching ECOD \"+ecodId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<EcodDomain> future = ConcurrencyTools.submit(job,ecodId);\n\t\t\tfutureDomains.add(future);\n\t\t}\n\t\tint successful = 0;\n\t\tfor(Future<EcodDomain> future : futureDomains) {\n\t\t\ttry {\n\t\t\t\tEcodDomain domain = future.get(60, TimeUnit.SECONDS);\n\t\t\t\tif(domain != null) {\n\t\t\t\t\tsuccessful++;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" interrupted\",e);\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" error\",e);\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" timed out\",e);\n\t\t\t}\n\n\t\t}\n\t\tassertEquals(ecodIds.length, successful);\n\t}\n}\n","changedTest":"/**\n * \n */\npackage org.biojava.nbio.structure.test.domain;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\nimport org.biojava.nbio.core.util.ConcurrencyTools;\nimport org.biojava.nbio.structure.domain.EcodDomain;\nimport org.biojava.nbio.structure.domain.EcodInstallation;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author Spencer Bliven\n *\n */\npublic class EcodInstallationTest {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(EcodInstallationTest.class);\n\tprivate static EcodInstallation ecod;\n\tprivate static final String VERSION = \"develop77\";\n\n\t// Set up static ecod singleton\n\tstatic {\n\t\tecod = new EcodInstallation();\n\t\tecod.setVersion(VERSION);\n\t}\n\n\tstatic {\n\t\t//System.setProperty(\"Log4jContextSelector\", \"org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\");\n\t\t} \n\t@Rule\n\tpublic TemporaryFolder tmpFolder = new TemporaryFolder();\n\t@Test\n\tpublic void testDownloads() throws IOException {\n\t\t// Use second installation with tmp location to avoid overwriting main cache\n\t\tEcodInstallation ecod2 = new EcodInstallation(tmpFolder.getRoot().getAbsolutePath());\n\t\tecod2.setVersion(VERSION);\n\t\t// Delete old VERSION\n\t\tFile domainsFile = new File(ecod2.getCacheLocation(),\"ecod.\"+VERSION+\".domains.txt\");\n\t\tif( domainsFile.exists() ) {\n\t\t\tdomainsFile.delete();\n\t\t}\n\t\t// Force download\n\t\tecod2.ensureDomainsFileInstalled();\n\t\t// Check for download\n\t\tassertTrue(\"No downloaded file at \"+domainsFile.toString(),domainsFile.exists());\n\t}\n\n\t@Test\n\tpublic void testAllDomains() throws IOException {\n\t\tList<EcodDomain> domains = ecod.getAllDomains();\n\t\tassertEquals(\"Wrong number of domains\",423779,domains.size());\n\t}\n\n\t@Test\n\tpublic void testByPDB() throws IOException {\n\t\tString pdbId;\n\t\tString[] expectedDomains;\n\t\tList<EcodDomain> domains;\n\n\t\tpdbId = \"1lyw\";\n\t\texpectedDomains = new String[] {\"e1lyw.1\",\"e1lyw.2\",\"e1lyw.3\",\"e1lyw.4\"};\n\t\tdomains = ecod.getDomainsForPDB(pdbId);\n\n\t\tmatchNames(pdbId,expectedDomains,domains);\n\n\t}\n\n\tprivate void matchNames(String pdbId,String[] expected,List<EcodDomain> actual) {\n\t\tassertEquals(\"Wrong number of domains for \"+pdbId, expected.length, actual.size());\n\t\tSet<String> exp = new HashSet<String>(Arrays.asList(expected));\n\t\tfor(EcodDomain d : actual) {\n\t\t\tassertTrue(\"Unexpected domain \"+d.getDomainId()+\" in \"+pdbId,exp.contains(d.getDomainId()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testParsing() throws IOException {\n\t\tString ecodId;\n\t\tEcodDomain domain,expected;\n\n\t\tecodId = \"e1lyw.1\";\n\t\tdomain = ecod.getDomainsById(ecodId);\n\t\texpected = new EcodDomain(\n\t\t\t\t//\t\t\t\tLong uid, String domainId, Boolean manual,\n\t\t\t\t20669l, \"e1lyw.1\", null,\n\t\t\t\t//\t\t\t\tInteger xGroup, Integer hGroup, Integer tGroup, String pdbId,\n\t\t\t\t1,1,1,\"1lyw\",\n\t\t\t\t//\t\t\t\tString chainId, String range, String architectureName,\n\t\t\t\t\".\", \"A:3-97,B:106-346\", \"beta barrels\",\n\t\t\t\t//\t\t\t\tString xGroupName, String hGroupName, String tGroupName,\n\t\t\t\t//\t\t\t\tString fGroupName, Boolean isAssembly, List<String> ligands\n\t\t\t\t\"cradle loop barrel\", \"RIFT-related\", \"acid protease\",\n\t\t\t\t\"UNK_F_TYPE\", false, Collections.singleton(\"EPE\")\n\t\t\t\t);\n\t\tassertEquals(ecodId,expected,domain);\n\n\t}\n\n\t@Test\n\tpublic void testMultithreaded() throws IOException {\n\t\tecod.clear();\n\t\tString[] ecodIds = new String[] {\n\t\t\t\t\"e4s1gA1\", \"e4umoB1\", \"e4v0cA1\", \"e4v1af1\", \"e3j7yj1\", \"e4wfcA1\",\"e4b0jP1\",\n\t\t};\n\t\tList<Future<EcodDomain>> futureDomains = new ArrayList<Future<EcodDomain>>();\n\t\tfor(final String ecodId : ecodIds) {\n\t\t\tCallable<EcodDomain> job = new Callable<EcodDomain>() {\n\t\t\t\t@Override\n\t\t\t\tpublic EcodDomain call() throws Exception {\n\t\t\t\t\tlogger.info(\"Running \"+ecodId);\n\t\t\t\t\tEcodDomain d = ecod.getDomainsById(ecodId);\n\t\t\t\t\tlogger.info(\"Finished \"+ecodId);\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic String toString() {\n\t\t\t\t\treturn \"Job fetching ECOD \"+ecodId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<EcodDomain> future = ConcurrencyTools.submit(job,ecodId);\n\t\t\tfutureDomains.add(future);\n\t\t}\n\t\tint successful = 0;\n\t\tfor(Future<EcodDomain> future : futureDomains) {\n\t\t\ttry {\n\t\t\t\tEcodDomain domain = future.get(60, TimeUnit.SECONDS);\n\t\t\t\tif(domain != null) {\n\t\t\t\t\tsuccessful++;\n\t\t\t\t}\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" interrupted\",e);\n\t\t\t} catch (ExecutionException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" error\",e);\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\tlogger.error(\"Job \"+future+\" timed out\",e);\n\t\t\t}\n\n\t\t}\n\t\tassertEquals(ecodIds.length, successful);\n\t}\n}\n","commitMessage":"Fix multithreading bug in EcodInstallation\n\nAdd additional tests and logging messages for debugging\n","test_commitMessage":"Moving EcodInstallationTest to integrationtest package\n","allZero":false}