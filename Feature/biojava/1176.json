{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/program/phred/PhredTools.java","test_path":"core/src/test/java/org/biojava/bio/program/phred/PhredToolsTest.java","prod_time":"2010-03-25 14:10:57","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"fcfff41a3d56d284b2531db7a9b1251ca88b53f8","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.program.phred;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.dist.Distribution;\nimport org.biojava.bio.dist.DistributionFactory;\nimport org.biojava.bio.dist.DistributionTools;\nimport org.biojava.bio.dist.DistributionTrainerContext;\nimport org.biojava.bio.dist.SimpleDistributionTrainerContext;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.SequenceIterator;\nimport org.biojava.bio.seq.db.HashSequenceDB;\nimport org.biojava.bio.seq.db.IDMaker;\nimport org.biojava.bio.seq.db.SequenceDB;\nimport org.biojava.bio.seq.impl.SimpleSequence;\nimport org.biojava.bio.seq.io.FastaDescriptionLineParser;\nimport org.biojava.bio.seq.io.FastaFormat;\nimport org.biojava.bio.seq.io.SeqIOTools;\nimport org.biojava.bio.seq.io.SequenceBuilderFactory;\nimport org.biojava.bio.seq.io.SimpleSequenceBuilder;\nimport org.biojava.bio.seq.io.StreamReader;\nimport org.biojava.bio.seq.io.StreamWriter;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.IntegerAlphabet;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.AssertionFailure;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.ListTools;\n\n/**\n * <p>PhredTools contains static methods for working with phred\n * quality data.</p>\n *\n * <p>Copyright (c) 2001</p>\n * <p>Company:      AgResearch</p>\n *\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @since 1.1\n *\n * Note that Phred is a copyright of CodonCode Corporation.\n */\n\npublic final class PhredTools {\n\n   static{\n     try {\n       List l = new ArrayList(2);\n       l.add(DNATools.getDNA());\n       l.add(IntegerAlphabet.getSubAlphabet(0,99));\n       AlphabetManager.getCrossProductAlphabet(l, \"PHRED\");\n     } catch (IllegalAlphabetException iae) {\n       throw new BioError( \"Could not create the Phred alphabet\", iae);\n     }\n   }\n\n  /**\n   * Retrieves the PHRED alphabet from the AlphabetManager. The Phred alphabet\n   * is a cross product of a subset of the IntegerAlphabet from 0...99 and the\n   * DNA alphabet. The Phred alphabet is finite.\n   *\n   * The Phred Alphabet contains 400 BasisSymbols named, for example, (guanine 47).\n   * The BasisSymbols can be fragmented into their component AtomicSymbols using\n   * the <code>getSymbols()</code> method of BasisSymbol.\n   */\n  public static final FiniteAlphabet getPhredAlphabet(){\n    return (FiniteAlphabet)AlphabetManager.alphabetForName(\"PHRED\");\n  }\n\n  /**\n   * Retrives the DNA symbol component of the Phred BasisSymbol from the\n   * PHRED alphabet.\n   * @throws IllegalSymbolException if the provided symbol is not from the\n   * PHRED alphabet.\n   */\n  public static final Symbol dnaSymbolFromPhred(Symbol phredSym)\n    throws IllegalSymbolException{\n    //validate the symbol\n    getPhredAlphabet().validate(phredSym);\n    //get the DNA component of the Phred Symbol\n    List l = ((BasisSymbol)phredSym).getSymbols();\n    //the first symbol should be DNA\n    return (Symbol) l.get(0);\n  }\n\n  /**\n   * Retrives the IntegerSymbol component of the Phred BasisSymbol from the\n   * PHRED alphabet.\n   * @throws IllegalSymbolException if the provided symbol is not from the\n   * PHRED alphabet.\n   */\n  public static final IntegerAlphabet.IntegerSymbol integerSymbolFromPhred(Symbol phredSym)\n    throws IllegalSymbolException{\n    //validate the symbol\n    getPhredAlphabet().validate(phredSym);\n    //get the IntegerSymbol component of the Phred Symbol\n    List l = ((BasisSymbol)phredSym).getSymbols();\n    //the second symbol should be the IntegerSymbol\n    return (IntegerAlphabet.IntegerSymbol)(l.get(1));\n  }\n\n  /**\n   * Merges a Symbol List from the DNA alphabet with a SymbolList from the\n   * [0..99] subset of the IntegerAlphabet into a SymbolList from\n   * the PHRED alphabet.\n   * @throws IllegalAlphabetException if the alphabets are not of the required alphabets\n   * @throws IllegalArgumentException if the two SymbolLists are not of equal length.\n   * @throws IllegalSymbolException if a combination of Symbols cannot be represented by\n   * the PHRED alphabet.\n   */\n  public static SymbolList createPhred(SymbolList dna, SymbolList quality)\n    throws IllegalArgumentException, IllegalAlphabetException, IllegalSymbolException{\n    //perform initial checks\n    if(dna.length() != quality.length()){\n      throw new IllegalArgumentException(\"SymbolLists must be of equal length \"+\n        dna.length()+\" : \"+quality.length());\n    }\n    if(dna.getAlphabet() != DNATools.getDNA()){\n      throw new IllegalAlphabetException(\n        \"Expecting SymbolList 'dna' to use the DNA alphabet, uses \"\n        +dna.getAlphabet().getName());\n    }\n    Alphabet subint = IntegerAlphabet.getSubAlphabet(0,99);\n    if(quality.getAlphabet() != subint && quality.getAlphabet() != IntegerAlphabet.getInstance()){\n      throw new IllegalAlphabetException(\n        \"Expecting SymbolList quality to use the \"+subint.getName()+\" alphabet\"+\n        \"or IntegerAlphabet instead uses \"+\n        quality.getAlphabet().getName());\n    }\n\n    //build the symbollist\n    SimpleSymbolList sl = new SimpleSymbolList(getPhredAlphabet());\n\n    for(int i = 1; i <= dna.length(); i++){\n      Symbol d = dna.symbolAt(i);\n      Symbol q = quality.symbolAt(i);\n      try{\n        sl.addSymbol(getPhredSymbol(d,q));\n      }catch(ChangeVetoException e){\n        throw new AssertionFailure(e);\n      }\n    }\n\n    return sl;\n  }\n\n  /**\n   * Creates a symbol from the PHRED alphabet by combining a Symbol from the\n   * DNA alphabet and a Symbol from the IntegerAlphabet (or one of its subsets).\n   * @throws IllegalSymbolException if there is no Symbol in the PHRED alphabet\n   * that represents the two arguments.\n   */\n  public static final Symbol getPhredSymbol(Symbol dna, Symbol integer)\n    throws IllegalSymbolException{\n    return getPhredAlphabet().getSymbol(new ListTools.Doublet(dna, integer));\n  }\n\n  /**\n   * Writes Phred quality data in a Fasta type format.\n   * @param db a bunch of PhredSequence objects\n   * @param qual the OutputStream to write the quality data to.\n   * @param seq the OutputStream to write the sequence data to.\n   * @since 1.2\n   */\n   public static void writePhredQuality(OutputStream qual, OutputStream seq, SequenceDB db)\n    throws IOException, BioException{\n      StreamWriter qualw = new StreamWriter(qual,new PhredFormat());\n      StreamWriter seqw = new StreamWriter(seq, new FastaFormat());\n      SequenceDB qualDB = new HashSequenceDB(IDMaker.byName);\n      //Get the quality SymbolLists and add them to a SeqDB\n      for(SequenceIterator i = db.sequenceIterator(); i.hasNext();){\n        Sequence p = i.nextSequence();\n        if(p instanceof PhredSequence){\n          PhredSequence ps = (PhredSequence)p;\n          SymbolList ql = ps.getQuality();\n          try{\n            qualDB.addSequence( new SimpleSequence(ql,p.getURN(),p.getName(),p.getAnnotation()));\n          }catch(ChangeVetoException cve){\n            throw new AssertionFailure(\"Cannot Add Quality Sequences to Database\", cve);\n          }\n        }\n        else{\n          throw new BioException(\"Expecting PhredSequence, got \" + p.getClass().getName());\n        }\n      }\n      qualw.writeStream(qualDB.sequenceIterator());\n      seqw.writeStream(db.sequenceIterator());//this works as sequence methods act on the underlying SimpleSequence\n   }\n\n  /**\n   * Constructs a StreamReader to read in Phred quality data in FASTA format.\n   * The data is converted into sequences consisting of Symbols from the IntegerAlphabet.\n   */\n  public static StreamReader readPhredQuality(BufferedReader br){\n    return new StreamReader(br,\n      new PhredFormat(),\n      getQualityParser(),\n      getFastaBuilderFactory());\n  }\n\n\n\n  /**\n   * Calls SeqIOTools.readFastaDNA(br), added here for convinience.\n   */\n  public static StreamReader readPhredSequence(BufferedReader br){\n    return (StreamReader)SeqIOTools.readFastaDNA(br);\n  }\n\n\n  private static SequenceBuilderFactory _fastaBuilderFactory;\n\n    /**\n     * Get a default SequenceBuilderFactory for handling FASTA\n     * files.\n     */\n  private static SequenceBuilderFactory getFastaBuilderFactory() {\n      if (_fastaBuilderFactory == null) {\n          _fastaBuilderFactory = new FastaDescriptionLineParser.Factory(SimpleSequenceBuilder.FACTORY);\n      }\n      return _fastaBuilderFactory;\n  }\n\n  /**\n   * returns the IntegerAlphabet parser\n   */\n  private static SymbolTokenization getQualityParser() {\n    return IntegerAlphabet.getInstance().getTokenization(\"token\");\n  }\n\n  /**\n   * The quality value is related to the base call error probability\n   * by the formula  QV = - 10 * log_10( P_e )\n   * where P_e is the probability that the base call is an error.\n   * @return a <code>double</code> value, note that for most Phred scores this will be rounded\n   * to the nearest <code>int</code>\n   */\n   public static double qualityFromP(double probOfError){\n     return (-10 * (Math.log(probOfError)/Math.log(10.0)));\n   }\n\n   /**\n    * Calculates the probability of an error from the quality score via the formula\n    *  P_e = 10**(QV/-10)\n    */\n    public static double pFromQuality(double quality){\n      return Math.pow(10.0,(quality/-10.0));\n    }\n\n    /**\n     * Calculates the probability of an error from the quality score via the formula\n     *  P_e = 10**(QV/-10)\n     */\n    public static double pFromQuality(int quality){\n      return pFromQuality((double)quality);\n    }\n\n    /**\n     * Calculates the probability of an error from the quality score via the formula\n     *  P_e = 10**(QV/-10)\n     */\n    public static double pFromQuality(IntegerAlphabet.IntegerSymbol quality){\n      return pFromQuality(quality.intValue());\n    }\n\n    /**\n     * Converts a Phred sequence to an array of distributions. Essentially a fuzzy sequence\n     * Assumes that all of the non called bases are equiprobable\n     */\n    public static Distribution[] phredToDistArray(PhredSequence s){\n      Distribution[] pos = new Distribution[s.length()];\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n\n      for (int i = 0; i < s.length(); i++) {// for each symbol in the phred sequence\n        Symbol qual = s.getQualityAt(i);\n        Symbol base = s.getDNAAt(i);\n        double pBase = pFromQuality((IntegerAlphabet.IntegerSymbol)qual);\n        double pOthers = (1.0 - pBase)/3;\n\n        try{\n          pos[i] = DistributionFactory.DEFAULT.createDistribution(DNATools.getDNA());\n          dtc.registerDistribution(pos[i]);\n\n          for(Iterator iter = (DNATools.getDNA().iterator()); iter.hasNext();){\n            Symbol sym = (Symbol)iter.next();\n            if(sym.equals(base)) pos[i].setWeight(sym,pBase);\n            else pos[i].setWeight(sym,pOthers);\n          }\n\n          dtc.train();\n        }catch(IllegalAlphabetException iae){\n          throw new AssertionFailure(\"Sequence \"+s.getName()+\" contains an illegal alphabet\", iae);\n        }catch(ChangeVetoException cve){\n          throw new AssertionFailure(\"The Distribution has become locked\", cve);\n        }catch(IllegalSymbolException ise){\n          throw new AssertionFailure(\"Sequence \"+s.getName()+\" contains an illegal symbol\", ise);\n        }\n      }\n      return pos;\n    }\n\n    /**\n     * converts an Alignment of PhredSequences to a Distribution[] where each position is the average\n     * distribution of the underlying column of the alignment.\n     * @throws ClassCastException if the sequences in the alignment are not instances of PhredSequence\n     */\n    public static Distribution[] phredAlignmentToDistArray(Alignment a){\n      List labels = a.getLabels();\n      Distribution [] average = new Distribution[a.length()];\n\n      Distribution[][] matrix = new Distribution[labels.size()][];\n      for(int y = 0; y < a.length(); y++){// for eaxh position\n        for(Iterator i = labels.iterator(); i.hasNext();){\n          SymbolList sl = a.symbolListForLabel(i.next());\n          matrix[y] = phredToDistArray((PhredSequence)sl);\n        }\n        average[y] = DistributionTools.average(matrix[y]);\n      }\n\n      return average;\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.program.phred;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.dist.Distribution;\nimport org.biojava.bio.dist.DistributionFactory;\nimport org.biojava.bio.dist.DistributionTools;\nimport org.biojava.bio.dist.DistributionTrainerContext;\nimport org.biojava.bio.dist.SimpleDistributionTrainerContext;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.SequenceIterator;\nimport org.biojava.bio.seq.db.HashSequenceDB;\nimport org.biojava.bio.seq.db.IDMaker;\nimport org.biojava.bio.seq.db.SequenceDB;\nimport org.biojava.bio.seq.impl.SimpleSequence;\nimport org.biojava.bio.seq.io.FastaDescriptionLineParser;\nimport org.biojava.bio.seq.io.FastaFormat;\nimport org.biojava.bio.seq.io.SeqIOTools;\nimport org.biojava.bio.seq.io.SequenceBuilderFactory;\nimport org.biojava.bio.seq.io.SimpleSequenceBuilder;\nimport org.biojava.bio.seq.io.StreamReader;\nimport org.biojava.bio.seq.io.StreamWriter;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.IntegerAlphabet;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.AssertionFailure;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.ListTools;\n\n/**\n * <p>PhredTools contains static methods for working with phred\n * quality data.</p>\n *\n * <p>Copyright (c) 2001</p>\n * <p>Company:      AgResearch</p>\n *\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @since 1.1\n *\n * Note that Phred is a copyright of CodonCode Corporation.\n */\n\npublic final class PhredTools {\n\n   static{\n     try {\n       List l = new ArrayList(2);\n       l.add(DNATools.getDNA());\n       l.add(IntegerAlphabet.getSubAlphabet(0,99));\n       AlphabetManager.getCrossProductAlphabet(l, \"PHRED\");\n     } catch (IllegalAlphabetException iae) {\n       throw new BioError( \"Could not create the Phred alphabet\", iae);\n     }\n   }\n\n  /**\n   * Retrieves the PHRED alphabet from the AlphabetManager. The Phred alphabet\n   * is a cross product of a subset of the IntegerAlphabet from 0...99 and the\n   * DNA alphabet. The Phred alphabet is finite.\n   *\n   * The Phred Alphabet contains 400 BasisSymbols named, for example, (guanine 47).\n   * The BasisSymbols can be fragmented into their component AtomicSymbols using\n   * the <code>getSymbols()</code> method of BasisSymbol.\n   */\n  public static final FiniteAlphabet getPhredAlphabet(){\n    return (FiniteAlphabet)AlphabetManager.alphabetForName(\"PHRED\");\n  }\n\n  /**\n   * Retrives the DNA symbol component of the Phred BasisSymbol from the\n   * PHRED alphabet.\n   * @throws IllegalSymbolException if the provided symbol is not from the\n   * PHRED alphabet.\n   */\n  public static final Symbol dnaSymbolFromPhred(Symbol phredSym)\n    throws IllegalSymbolException{\n    //validate the symbol\n    getPhredAlphabet().validate(phredSym);\n    //get the DNA component of the Phred Symbol\n    List l = ((BasisSymbol)phredSym).getSymbols();\n    //the first symbol should be DNA\n    return (Symbol) l.get(0);\n  }\n\n  /**\n   * Retrives the IntegerSymbol component of the Phred BasisSymbol from the\n   * PHRED alphabet.\n   * @throws IllegalSymbolException if the provided symbol is not from the\n   * PHRED alphabet.\n   */\n  public static final IntegerAlphabet.IntegerSymbol integerSymbolFromPhred(Symbol phredSym)\n    throws IllegalSymbolException{\n    //validate the symbol\n    getPhredAlphabet().validate(phredSym);\n    //get the IntegerSymbol component of the Phred Symbol\n    List l = ((BasisSymbol)phredSym).getSymbols();\n    //the second symbol should be the IntegerSymbol\n    return (IntegerAlphabet.IntegerSymbol)(l.get(1));\n  }\n\n  /**\n   * Merges a Symbol List from the DNA alphabet with a SymbolList from the\n   * [0..99] subset of the IntegerAlphabet into a SymbolList from\n   * the PHRED alphabet.\n   * @throws IllegalAlphabetException if the alphabets are not of the required alphabets\n   * @throws IllegalArgumentException if the two SymbolLists are not of equal length.\n   * @throws IllegalSymbolException if a combination of Symbols cannot be represented by\n   * the PHRED alphabet.\n   */\n  public static SymbolList createPhred(SymbolList dna, SymbolList quality)\n    throws IllegalArgumentException, IllegalAlphabetException, IllegalSymbolException{\n    //perform initial checks\n    if(dna.length() != quality.length()){\n      throw new IllegalArgumentException(\"SymbolLists must be of equal length \"+\n        dna.length()+\" : \"+quality.length());\n    }\n    if(dna.getAlphabet() != DNATools.getDNA()){\n      throw new IllegalAlphabetException(\n        \"Expecting SymbolList 'dna' to use the DNA alphabet, uses \"\n        +dna.getAlphabet().getName());\n    }\n    Alphabet subint = IntegerAlphabet.getSubAlphabet(0,99);\n    if(quality.getAlphabet() != subint && quality.getAlphabet() != IntegerAlphabet.getInstance()){\n      throw new IllegalAlphabetException(\n        \"Expecting SymbolList quality to use the \"+subint.getName()+\" alphabet\"+\n        \"or IntegerAlphabet instead uses \"+\n        quality.getAlphabet().getName());\n    }\n\n    //build the symbollist\n    SimpleSymbolList sl = new SimpleSymbolList(getPhredAlphabet());\n\n    for(int i = 1; i <= dna.length(); i++){\n      Symbol d = dna.symbolAt(i);\n      Symbol q = quality.symbolAt(i);\n      try{\n        sl.addSymbol(getPhredSymbol(d,q));\n      }catch(ChangeVetoException e){\n        throw new AssertionFailure(e);\n      }\n    }\n\n    return sl;\n  }\n\n  /**\n   * Creates a symbol from the PHRED alphabet by combining a Symbol from the\n   * DNA alphabet and a Symbol from the IntegerAlphabet (or one of its subsets).\n   * @throws IllegalSymbolException if there is no Symbol in the PHRED alphabet\n   * that represents the two arguments.\n   */\n  public static final Symbol getPhredSymbol(Symbol dna, Symbol integer)\n    throws IllegalSymbolException{\n    return getPhredAlphabet().getSymbol(new ListTools.Doublet(dna, integer));\n  }\n\n  /**\n   * Writes Phred quality data in a Fasta type format.\n   * @param db a bunch of PhredSequence objects\n   * @param qual the OutputStream to write the quality data to.\n   * @param seq the OutputStream to write the sequence data to.\n   * @since 1.2\n   */\n   public static void writePhredQuality(OutputStream qual, OutputStream seq, SequenceDB db)\n    throws IOException, BioException{\n      StreamWriter qualw = new StreamWriter(qual,new PhredFormat());\n      StreamWriter seqw = new StreamWriter(seq, new FastaFormat());\n      SequenceDB qualDB = new HashSequenceDB(IDMaker.byName);\n      //Get the quality SymbolLists and add them to a SeqDB\n      for(SequenceIterator i = db.sequenceIterator(); i.hasNext();){\n        Sequence p = i.nextSequence();\n        if(p instanceof PhredSequence){\n          PhredSequence ps = (PhredSequence)p;\n          SymbolList ql = ps.getQuality();\n          try{\n            qualDB.addSequence( new SimpleSequence(ql,p.getURN(),p.getName(),p.getAnnotation()));\n          }catch(ChangeVetoException cve){\n            throw new AssertionFailure(\"Cannot Add Quality Sequences to Database\", cve);\n          }\n        }\n        else{\n          throw new BioException(\"Expecting PhredSequence, got \" + p.getClass().getName());\n        }\n      }\n      qualw.writeStream(qualDB.sequenceIterator());\n      seqw.writeStream(db.sequenceIterator());//this works as sequence methods act on the underlying SimpleSequence\n   }\n\n  /**\n   * Constructs a StreamReader to read in Phred quality data in FASTA format.\n   * The data is converted into sequences consisting of Symbols from the IntegerAlphabet.\n   */\n  public static StreamReader readPhredQuality(BufferedReader br){\n    return new StreamReader(br,\n      new PhredFormat(),\n      getQualityParser(),\n      getFastaBuilderFactory());\n  }\n\n\n\n  /**\n   * Calls SeqIOTools.readFastaDNA(br), added here for convinience.\n   */\n  public static StreamReader readPhredSequence(BufferedReader br){\n    return (StreamReader)SeqIOTools.readFastaDNA(br);\n  }\n\n\n  private static SequenceBuilderFactory _fastaBuilderFactory;\n\n    /**\n     * Get a default SequenceBuilderFactory for handling FASTA\n     * files.\n     */\n  private static SequenceBuilderFactory getFastaBuilderFactory() {\n      if (_fastaBuilderFactory == null) {\n          _fastaBuilderFactory = new FastaDescriptionLineParser.Factory(SimpleSequenceBuilder.FACTORY);\n      }\n      return _fastaBuilderFactory;\n  }\n\n  /**\n   * returns the IntegerAlphabet parser\n   */\n  private static SymbolTokenization getQualityParser() {\n    return IntegerAlphabet.getInstance().getTokenization(\"token\");\n  }\n\n  /**\n   * The quality value is related to the base call error probability\n   * by the formula  QV = - 10 * log_10( P_e )\n   * where P_e is the probability that the base call is an error.\n   * @return a <code>double</code> value, note that for most Phred scores this will be rounded\n   * to the nearest <code>int</code>\n   */\n   public static double qualityFromP(double probOfError){\n     return (-10 * (Math.log(probOfError)/Math.log(10.0)));\n   }\n\n   /**\n    * Calculates the probability of an error from the quality score via the formula\n    *  P_e = 10**(QV/-10)\n    */\n    public static double pFromQuality(double quality){\n      return Math.pow(10.0,(quality/-10.0));\n    }\n\n    /**\n     * Calculates the probability of an error from the quality score via the formula\n     *  P_e = 10**(QV/-10)\n     */\n    public static double pFromQuality(int quality){\n      return pFromQuality((double)quality);\n    }\n\n    /**\n     * Calculates the probability of an error from the quality score via the formula\n     *  P_e = 10**(QV/-10)\n     */\n    public static double pFromQuality(IntegerAlphabet.IntegerSymbol quality){\n      return pFromQuality(quality.intValue());\n    }\n\n    /**\n     * Converts a Phred sequence to an array of distributions. Essentially a fuzzy sequence\n     * Assumes that all of the non called bases are equiprobable\n     */\n    public static Distribution[] phredToDistArray(PhredSequence s){\n      Distribution[] pos = new Distribution[s.length()];\n      DistributionTrainerContext dtc = new SimpleDistributionTrainerContext();\n\n      for (int i = 0; i < s.length(); i++) {// for each symbol in the phred sequence\n        Symbol qual = s.getQualityAt(i);\n        Symbol base = s.getDNAAt(i);\n        double pBase = pFromQuality((IntegerAlphabet.IntegerSymbol)qual);\n        double pOthers = (1.0 - pBase)/3;\n\n        try{\n          pos[i] = DistributionFactory.DEFAULT.createDistribution(DNATools.getDNA());\n          dtc.registerDistribution(pos[i]);\n\n          for(Iterator iter = (DNATools.getDNA().iterator()); iter.hasNext();){\n            Symbol sym = (Symbol)iter.next();\n            if(sym.equals(base)) pos[i].setWeight(sym,pBase);\n            else pos[i].setWeight(sym,pOthers);\n          }\n\n          dtc.train();\n        }catch(IllegalAlphabetException iae){\n          throw new AssertionFailure(\"Sequence \"+s.getName()+\" contains an illegal alphabet\", iae);\n        }catch(ChangeVetoException cve){\n          throw new AssertionFailure(\"The Distribution has become locked\", cve);\n        }catch(IllegalSymbolException ise){\n          throw new AssertionFailure(\"Sequence \"+s.getName()+\" contains an illegal symbol\", ise);\n        }\n      }\n      return pos;\n    }\n\n    /**\n     * converts an Alignment of PhredSequences to a Distribution[] where each position is the average\n     * distribution of the underlying column of the alignment.\n     * @throws ClassCastException if the sequences in the alignment are not instances of PhredSequence\n     */\n    public static Distribution[] phredAlignmentToDistArray(Alignment a){\n      List<String> labels = a.getLabels();\n      Distribution [] average = new Distribution[a.length()];\n\n      Distribution[][] matrix = new Distribution[labels.size()][];\n      for(int y = 0; y < a.length(); y++){// for eaxh position\n        for(Iterator<String> i = labels.iterator(); i.hasNext();){\n          SymbolList sl = a.symbolListForLabel(i.next());\n          matrix[y] = phredToDistArray((PhredSequence)sl);\n        }\n        average[y] = DistributionTools.average(matrix[y]);\n      }\n\n      return average;\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.program.phred;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.IntegerAlphabet;\nimport org.biojava.utils.AssertionFailure;\n\n/**\n * @author Matthew Pocock\n */\npublic class PhredToolsTest\nextends TestCase {\n  public PhredToolsTest(String name) {\n    super(name);\n  }\n  \n  public void testGetPhredSymbol() {\n    try {\n      PhredTools.getPhredSymbol(DNATools.a(), IntegerAlphabet.getInstance().getSymbol(1));\n      PhredTools.getPhredSymbol(DNATools.g(), IntegerAlphabet.getInstance().getSymbol(2));\n      PhredTools.getPhredSymbol(DNATools.c(), IntegerAlphabet.getInstance().getSymbol(3));\n      PhredTools.getPhredSymbol(DNATools.t(), IntegerAlphabet.getInstance().getSymbol(4));\n    } catch (IllegalSymbolException ise) {\n      throw new AssertionFailure(ise);\n    }\n  }\n  \n  public void testGetPhredSymbolAmbiguous() {\n    try {\n      PhredTools.getPhredSymbol(DNATools.n(), IntegerAlphabet.getInstance().getSymbol(5));\n    } catch (IllegalSymbolException ise) {\n      throw new AssertionFailure(ise);\n    }\n  }\n}\n","changedTest":"","commitMessage":"The alignment algorithms NeedlemanWunsch and SmithWaterman have been revised and are now based on a Alignment data structure that strongly eases using the result.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7598 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}