{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/basepairs/BasePairParameters.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/basepairs/TestBasePairParameters.java","prod_time":"2017-07-31 08:38:48","test_time":"2017-07-31 08:38:48","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":8,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":7,"del_classname_line":0,"del_condition_line":8,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"a182c8db783d3853adafd653e93172f5d47c8df8","test_commitID":"a182c8db783d3853adafd653e93172f5d47c8df8","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n *\n */\npackage org.biojava.nbio.structure.basepairs;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.biojava.nbio.structure.io.PDBFileReader;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.lang.Math.sin;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.atan2;\nimport static java.lang.Math.acos;\nimport static java.lang.Math.PI;\n\n/**\n * Contributed to BioJava under its LGPL\n * This module calculates the el Hassan-Calladine Base Pairing and Base-pair Step Parameters\n * Citation: https://www.ncbi.nlm.nih.gov/pubmed/11601858\n *\n * The method that is usually overridden is findPairs(), this implementation is used for a large-scale\n * analysis of the most proper helical regions in almost 4000 protein-DNA structures, almost\n * 2000 structures containing only DNA, or almost 1300 structures containing only RNA. (as of 7/2017).\n * Those who study tertiary structures for RNA folding should try using the TertiaryBasePairParameters,\n * because this base class is only looking for base pairs between separate strands that exactly line up.\n * To relax the lining up policy and allow for non-canonical base pairs, use the MismatchedBasePairParameters\n * class.\n *\n * @author Luke Czapla\n * @since 5.0.0\n *\n */\npublic class BasePairParameters implements Serializable {\n\n    private static final long serialVersionUID = 6214502385L;\n    private static Logger log = LoggerFactory.getLogger(BasePairParameters.class);\n\n    // See URL http://ndbserver.rutgers.edu/ndbmodule/archives/reports/tsukuba/Table1.html\n    // and the paper cited at the top of this class (also as Table 1).\n    // These are hard-coded to avoid problems with resource paths.\n    public static final String[] STANDARD_BASES = new String[] {\n            \"SEQRES   1 A    1  A\\n\" +\n                    \"ATOM      2  N9    A A   1      -1.291   4.498   0.000\\n\" +\n                    \"ATOM      3  C8    A A   1       0.024   4.897   0.000\\n\" +\n                    \"ATOM      4  N7    A A   1       0.877   3.902   0.000\\n\" +\n                    \"ATOM      5  C5    A A   1       0.071   2.771   0.000\\n\" +\n                    \"ATOM      6  C6    A A   1       0.369   1.398   0.000\\n\" +\n                    \"ATOM      8  N1    A A   1      -0.668   0.532   0.000\\n\" +\n                    \"ATOM      9  C2    A A   1      -1.912   1.023   0.000\\n\" +\n                    \"ATOM     10  N3    A A   1      -2.320   2.290   0.000\\n\" +\n                    \"ATOM     11  C4    A A   1      -1.267   3.124   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  G\\n\" +\n                    \"ATOM      2  N9    G A   1      -1.289   4.551   0.000\\n\" +\n                    \"ATOM      3  C8    G A   1       0.023   4.962   0.000\\n\" +\n                    \"ATOM      4  N7    G A   1       0.870   3.969   0.000\\n\" +\n                    \"ATOM      5  C5    G A   1       0.071   2.833   0.000\\n\" +\n                    \"ATOM      6  C6    G A   1       0.424   1.460   0.000\\n\" +\n                    \"ATOM      8  N1    G A   1      -0.700   0.641   0.000\\n\" +\n                    \"ATOM      9  C2    G A   1      -1.999   1.087   0.000\\n\" +\n                    \"ATOM     11  N3    G A   1      -2.342   2.364   0.001\\n\" +\n                    \"ATOM     12  C4    G A   1      -1.265   3.177   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  T\\n\" +\n                    \"ATOM      2  N1    T A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    T A   1      -1.462   3.135   0.000\\n\" +\n                    \"ATOM      5  N3    T A   1      -0.298   2.407   0.000\\n\" +\n                    \"ATOM      6  C4    T A   1       0.994   2.897   0.000\\n\" +\n                    \"ATOM      8  C5    T A   1       1.106   4.338   0.000\\n\" +\n                    \"ATOM     10  C6    T A   1      -0.024   5.057   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  C\\n\" +\n                    \"ATOM      2  N1    C A   1      -1.285   4.542   0.000\\n\" +\n                    \"ATOM      3  C2    C A   1      -1.472   3.158   0.000\\n\" +\n                    \"ATOM      5  N3    C A   1      -0.391   2.344   0.000\\n\" +\n                    \"ATOM      6  C4    C A   1       0.837   2.868   0.000\\n\" +\n                    \"ATOM      8  C5    C A   1       1.056   4.275   0.000\\n\" +\n                    \"ATOM      9  C6    C A   1      -0.023   5.068   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  U\\n\" +\n                    \"ATOM      2  N1    U A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    U A   1      -1.462   3.131   0.000\\n\" +\n                    \"ATOM      5  N3    U A   1      -0.302   2.397   0.000\\n\" +\n                    \"ATOM      6  C4    U A   1       0.989   2.884   0.000\\n\" +\n                    \"ATOM      8  C5    U A   1       1.089   4.311   0.000\\n\" +\n                    \"ATOM      9  C6    U A   1      -0.024   5.053   0.000\\n\"\n    };\n\n    // this is also hard-coded data about standard WC base pairs for both DNA and RNA\n    protected static final String[] BASE_LIST_DNA = {\"A\", \"G\", \"T\", \"C\"};\n    protected static final String[] BASE_LIST_RNA = {\"A\", \"G\", \"U\", \"C\"};\n    protected static final Map<String, Integer> BASE_MAP;\n   // private static List<String> RNAspecific = Arrays.asList(\"U\", \"URA\"),\n   //        DNAspecific = Arrays.asList(\"DC\", \"C\", \"CYT\");\n    protected static final Map<Integer, List<String>> RING_MAP;\n    static {\n        BASE_MAP = new HashMap<>();\n        BASE_MAP.put(\"DA\", 0); BASE_MAP.put(\"ADE\", 0); BASE_MAP.put(\"A\", 0);\n        BASE_MAP.put(\"DG\", 1); BASE_MAP.put(\"GUA\", 1); BASE_MAP.put(\"G\", 1);\n        BASE_MAP.put(\"DT\", 2); BASE_MAP.put(\"THY\", 2); BASE_MAP.put(\"T\", 2); BASE_MAP.put(\"U\", 2); BASE_MAP.put(\"URA\", 2);\n        BASE_MAP.put(\"DC\", 3); BASE_MAP.put(\"CYT\", 3); BASE_MAP.put(\"C\", 3);\n\n        RING_MAP = new HashMap<>();\n        RING_MAP.put(0, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        RING_MAP.put(1, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        RING_MAP.put(2, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n        RING_MAP.put(3, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n   }\n\n    protected transient Structure structure;\n    protected boolean canonical = true;\n    protected boolean useRNA = false;\n    protected boolean nonredundant = false;\n    protected double[] pairParameters;\n\n    // this is the main data that you want to get back out from the procedure.\n    protected String pairSequence = \"\";\n    protected double[][] pairingParameters;\n    protected double[][] stepParameters;\n    protected List<String> pairingNames = new ArrayList<>();\n    protected List<Matrix4d> referenceFrames = new ArrayList<>();\n\n\n    /**\n     * Constructor takes a Structure object, finds base pair and base-pair step parameters\n     * for double-helical regions within the structure.\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA whether to look for canonical RNA pairs.  By default (false) it analyzes DNA.\n     * @param removeDups whether to only look for base-pair parameters for each unique sequence in\n     *  the structure (if set to <i>true</i>)\n     * @param canonical Whether to consider only Watson-Crick base pairs\n     */\n    public BasePairParameters(Structure structure, boolean useRNA, boolean removeDups, boolean canonical) {\n        this.structure = structure;\n        this.useRNA = useRNA;\n        this.canonical = canonical;\n        this.nonredundant = removeDups;\n\n    }\n\n    /**\n     * Constructor takes a Structure object, whether to use RNA, and whether to remove duplicate sequences.\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA if true, the RNA standard bases will be used.  Otherwise, if false, it will work on standard DNA bases.\n     * @param removeDups if true, duplicate sequences will not be considered.  This is for the analysis of X-ray structures from\n     *                   RCSB, where there may be identical or similar units.\n     */\n    public BasePairParameters(Structure structure, boolean useRNA, boolean removeDups) {\n        this(structure, useRNA, removeDups, false);\n    }\n\n    /**\n     * Constructor takes a Structure object, and whether to use the RNA standard bases\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA if true, the RNA standard bases will be used.  Otherwise, if false, it will work on standard DNA bases.\n     */\n    public BasePairParameters(Structure structure, boolean useRNA) {\n        this(structure, useRNA, false, false);\n    }\n\n    /**\n     * Constructor takes a Structure object, finds base pair and base-pair step parameters\n     * for double-helical regions within the structure for only canonical DNA pairs.\n     * @param structure The already-loaded structure to analyze.\n     */\n    public BasePairParameters(Structure structure) {\n        this(structure, false, false, true);\n    }\n\n\n    /**\n     * This is the main function call to extract all step parameters, pairing parameters, and sequence\n     * information from the Structure object provided to the constructor.\n     * @return This same object with the populated data, convenient for output\n     *  (e.g. <i>log.info(new BasePairParameters(structure).analyze());</i>)\n     */\n    public BasePairParameters analyze() {\n        if (structure == null) {\n            pairingParameters = null;\n            stepParameters = null;\n            return this;\n        }\n        List<Chain> nucleics = this.getNucleicChains(nonredundant);\n        List<Pair<Group>> pairs = this.findPairs(nucleics);\n        this.pairingParameters = new double[pairs.size()][6];\n        this.stepParameters = new double[pairs.size()][6];\n        Matrix4d lastStep;\n        Matrix4d currentStep = null;\n        for (int i = 0; i < pairs.size(); i++) {\n            lastStep = currentStep;\n            currentStep = this.basePairReferenceFrame(pairs.get(i));\n            referenceFrames.add((Matrix4d)currentStep.clone());\n            for (int j = 0; j < 6; j++) pairingParameters[i][j] = pairParameters[j];\n            if (i != 0) {\n                lastStep.invert();\n                lastStep.mul(currentStep);\n                double[] sparms = calculateTp(lastStep);\n                for (int j = 0; j < 6; j++) stepParameters[i][j] = sparms[j];\n            }\n        }\n        return this;\n    }\n\n\n\n    /**\n     * Returns the total number of base pairs that were found, after the call to analyze()\n     * @return An integer value, number of base pairs\n     */\n    public int getLength() {\n        if (structure == null || pairParameters == null) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters.length;\n    }\n\n\n    /**\n     * This reports all the pair parameters, in the order of:\n     * buckle, propeller, opening (in degrees), shear, stagger, stretch (in Å).\n     * @return A double[][] with length equal to number of base pairs for rows, and 6 columns\n     */\n    public double[][] getPairingParameters() {\n        return pairingParameters;\n    }\n\n    /**\n     * This reports all the base-pair step parameters, in the order of:\n     * tilt, roll, twist (in degrees), shift, slide, rise (in Å).\n     * @return A double[][] with length equal to number of base pairs (the first row 0 has no step\n     *  and therefore is six zeroes), and 6 columns.\n     */\n    public double[][] getStepParameters() {\n        return stepParameters;\n    }\n\n\n    /**\n     * This returns the primary strand's sequence where parameters were found.\n     * There are spaces in the string anywhere there was a break in the helix or when\n     * it goes from one helix to another helix in the structure. (the \"step\" is still returned)\n     * @return String of primary sequence with spaces between gaps and new helices.\n     */\n    public String getPairSequence() {\n        return pairSequence;\n    }\n\n\n    /**\n     * This returns the names of the pairs in terms of A, G, T/U, and C for each base pair group in the\n     * list.  The first character is the leading strand base and the second character is the complementary base\n     * @return\n     */\n    public List<String> getPairingNames() {\n        return pairingNames;\n    }\n\n    public List<Matrix4d> getReferenceFrames() {\n        return referenceFrames;\n    }\n\n\n    /**\n     * Return the buckle in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getBuckle(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][0];\n    }\n\n    /**\n     * Return the propeller (\"propeller-twist\") in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getPropeller(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][1];\n    }\n\n    /**\n     * Return the opening in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getOpening(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][2];\n    }\n\n    /**\n     * Return the shear in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getShear(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][3];\n    }\n\n    /**\n     * Return the stretch in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getStretch(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][4];\n    }\n\n    /**\n     * Return the stagger in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getStagger(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return pairingParameters[bp][5];\n    }\n\n    /**\n     * Return the tilt for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getTilt(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][0];\n    }\n\n    /**\n     * Return the roll for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getRoll(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][1];\n    }\n\n    /**\n     * Return the twist for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getTwist(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][2];\n    }\n\n    /**\n     * Return the shift for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getShift(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][3];\n    }\n\n    /**\n     * Return the slide for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getSlide(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][4];\n    }\n\n    /**\n     * Return the rise for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getRise(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][5];\n    }\n\n\n    /**\n     * This reports all the nucleic acid chains and has an option to remove duplicates if you\n     * are considering an analysis of only unique DNA or RNA helices in the Structure.\n     * @param removeDups If true, it will ignore duplicate chains\n     * @return A list of all the nucleic acid chains in order of the Structure\n     */\n    public List<Chain> getNucleicChains(boolean removeDups) {\n        if (structure == null) return new ArrayList<>();\n        List<Chain> chains = structure.getChains();\n        List<Chain> result = new ArrayList<>();\n        for (Chain c: chains) {\n            if (c.isNucleicAcid()) {\n                result.add(c);\n            }\n        }\n        if (removeDups) for (int i = 0; i < result.size(); i++) {\n            for (int j = i+2; j < result.size(); j++) {\n                // remove duplicate sequences (structures with two or more identical units)\n                if (result.get(i).getAtomSequence().equals(result.get(j).getAtomSequence())) {\n                    result.remove(j);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * This performs a search for base pairs in the structure.  The criteria is alignment of\n     * sequences and the canonical base pairs of DNA or RNA. Use MismatchedBasePairParameters\n     * or TertiaryBasePairParameters for finding higher-order associations.\n     * @param chains The list of chains already found to be nucleic acids\n     * @return The list of corresponding Watson-Crick groups as pairs, as a Pair of nucleic acid Groups\n     */\n    public List<Pair<Group>> findPairs(List<Chain> chains) {\n        List<Pair<Group>> result = new ArrayList<>();\n        for (int i = 0; i < chains.size(); i++) {\n            Chain c = chains.get(i);\n            for (int j = i+1; j < chains.size(); j++) {\n                String complement = complement(chains.get(j).getAtomSequence(), useRNA);\n                String match = longestCommonSubstring(c.getAtomSequence(), complement);\n                if (log.isDebugEnabled()) {\n                    log.debug(c.getAtomSequence() + \" \" + chains.get(j).getAtomSequence() + \" \" + match);\n                }\n                int index1 = c.getAtomSequence().indexOf(match);\n                int index2 = complement.length() - complement.indexOf(match) - 1;\n                for (int k = 0; k < match.length(); k++) {\n                    Group g1 = c.getAtomGroup(index1+k);\n                    Group g2 = chains.get(j).getAtomGroup(index2-k);\n                    Integer type1 = BASE_MAP.get(g1.getPDBName());\n                    Integer type2 = BASE_MAP.get(g2.getPDBName());\n                    if (type1 == null || type2 == null) {\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    Atom a1 = g1.getAtom(RING_MAP.get(type1).get(0));\n                    Atom a2 = g2.getAtom(RING_MAP.get(type2).get(0));\n\n                    if (a1 == null) {\n                        log.info(\"Error processing \" + g1.getPDBName());\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    if (a2 == null) {\n                        log.info(\"Error processing \" + g2.getPDBName());\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n\n                    double dx = a1.getX()-a2.getX();\n                    double dy = a1.getY()-a2.getY();\n                    double dz = a1.getZ()-a2.getZ();\n                    double distance = Math.sqrt(dx*dx+dy*dy+dz*dz);\n                    //log.info(\"C8-C6 Distance (Å): \" + distance);\n                    // could be a base pair\n                    if (Math.abs(distance-10.0) < 4.0) {\n                        boolean valid = true;\n                        for (String atomname : RING_MAP.get(type1)) {\n                            Atom a = g1.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) for (String atomname: RING_MAP.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) {\n                            result.add(new Pair<Group>(g1, g2));\n                            pairingNames.add((useRNA ? BASE_LIST_RNA[type1]+ BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1]+ BASE_LIST_DNA[type2]));\n                            pairSequence += c.getAtomSequence().charAt(index1 + k);\n                        } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                }\n                if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n            }\n            //log.info();\n        }\n        log.info(\"Matched: \" + pairSequence);\n        return result;\n    }\n\n\n    /**\n     * Calculate the central frame (4x4 transformation matrix) of a single base pair.\n     * @param pair An array of the two groups that make a hypothetical pair\n     * @return The middle frame of the center of the base-pair formed\n     */\n    public Matrix4d basePairReferenceFrame(Pair<Group> pair) {\n        Integer type1 = BASE_MAP.get(pair.getFirst().getPDBName());\n        Integer type2 = BASE_MAP.get(pair.getSecond().getPDBName());\n        SuperPosition sp = new SuperPositionQCP(true);\n        if (type1 == null || type2 == null) return null;\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        Structure s1, s2;\n        try {\n            s1 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type1].getBytes()));\n            s2 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type2].getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        Group std1 = s1.getChain(\"A\").getAtomGroup(0);\n        Group std2 = s2.getChain(\"A\").getAtomGroup(0);\n\n        Point3d[] pointref = new Point3d[std1.getAtoms().size()];\n        Point3d[] pointact = new Point3d[std1.getAtoms().size()];\n        int count = 0;\n\n        for (Atom a : std1.getAtoms()) {\n            if (pair.getFirst().getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair.getFirst().getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std1.getAtoms().size();\n        Matrix4d ref1 = (Matrix4d)sp.superposeAndTransform(pointact, pointref).clone();\n\n        pointref = new Point3d[std2.getAtoms().size()];\n        pointact = new Point3d[std2.getAtoms().size()];\n\n        count = 0;\n        for (Atom a : std2.getAtoms()) {\n            if (pair.getSecond().getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair.getSecond().getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std2.getAtoms().size();\n\n        Matrix4d temp = (Matrix4d)ref1.clone();\n        Matrix4d temp2 = (Matrix4d)temp.clone();\n        Matrix4d ref2 = sp.superposeAndTransform(pointact, pointref);\n\n        double[][] v = new double[3][4];\n        double[] y3 = new double[4];\n        double[] z3 = new double[4];\n        ref2.getColumn(1, y3);\n        ref2.getColumn(2, z3);\n        double[] z31 = new double[4];\n        ref1.getColumn(2, z31);\n        if (z3[0]*z31[0]+z3[1]*z31[1]+z3[2]*z31[2] < 0.0) {\n            for (int i = 0; i < 3; i++) {\n                y3[i] *= -1.0;\n                z3[i] *= -1.0;\n            }\n        }\n        ref2.setColumn(1, y3);\n        ref2.setColumn(2, z3);\n\n        temp.add(ref2);\n        temp.mul(0.5);\n        double[] x3 = new double[4];\n        temp.getColumn(0, x3);\n        temp.getColumn(1, y3);\n        temp.getColumn(2, z3);\n        x3 = removeComponent(x3, z3);\n        x3 = removeComponent(x3, y3);\n        y3 = removeComponent(y3, z3);\n        temp.setColumn(0, x3);\n        temp.setColumn(1, y3);\n        temp.setColumn(2, z3);\n\n        // normalize the short, long, and normal axes\n        for (int i = 0; i < 3; i++) {\n            temp.getColumn(i, v[i]);\n            double r = Math.sqrt(v[i][0] * v[i][0] + v[i][1] * v[i][1] + v[i][2] * v[i][2]);\n            for (int j = 0; j < 3; j++) {\n                v[i][j] /= r;\n            }\n            temp.setColumn(i, v[i]);\n        }\n\n        // calculate pairing parameters: buckle, propeller, opening, shear, stretch, stagger\n        temp2.invert();\n        temp2.mul(ref2);\n        pairParameters = calculateTp(temp2);\n        for (int i = 0; i < 6; i++) pairParameters[i] *= -1;\n\n        // return the central frame of the base pair\n        return temp;\n\n    }\n\n\n    @Override\n    public String toString() {\n        if (getPairingParameters() == null) return \"No data\";\n        StringBuilder result = new StringBuilder(10000);\n        result.append(pairingParameters.length + \" base pairs\\n\");\n        result.append(\"bp: buckle propeller opening shear stretch stagger tilt roll twist shift slide rise\\n\");\n        for (int i = 0; i < pairingParameters.length; i++) {\n            result.append(pairingNames.get(i)+\": \");\n            for (int j = 0; j < 6; j++)\n                result.append(String.format(\"%5.4f\", pairingParameters[i][j]) + \" \");\n            for (int j = 0; j < 6; j++)\n                result.append(String.format(\"%5.4f\", stepParameters[i][j]) + \" \");\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n\n    // The following methods are just helper classes for the rapid analyze of base-pair geometry.\n    /**\n     * This method calculates pairing and step parameters from 4x4 transformation matrices (used internally)\n     * that come out as Matrix4d;\n     * @param input the 4x4 matrix representing the transformation from strand II -> strand I or pair i to pair i+1\n     * @return Six parameters as double[6]\n     */\n    public static double[] calculateTp(Matrix4d input) {\n\n        double[][] A = new double[4][4];\n        for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) {\n            A[i][j] = input.getElement(i, j);\n        }\n        double[] M = new double[6];\n\n        double cosgamma, gamma, phi, omega, sgcp, omega2_minus_phi,\n                sm, cm, sp, cp, sg, cg;\n\n        cosgamma = A[2][2];\n        if (cosgamma > 1.0) cosgamma = 1.0;\n        else if (cosgamma < -1.0) cosgamma = -1.0;\n\n        gamma = acos(cosgamma);\n\n        sgcp = A[1][1]*A[0][2]-A[0][1]*A[1][2];\n\n        if (gamma == 0.0) omega = -atan2(A[0][1],A[1][1]);\n        else omega = atan2(A[2][1]*A[0][2]+sgcp*A[1][2],sgcp*A[0][2]-A[2][1]*A[1][2]);\n\n        omega2_minus_phi = atan2(A[1][2],A[0][2]);\n\n        phi = omega/2.0 - omega2_minus_phi;\n\n        M[0] = gamma*sin(phi)*180.0/PI;\n        M[1] = gamma*cos(phi)*180.0/PI;\n        M[2] = omega*180.0/PI;\n\n        sm = sin(omega/2.0-phi);\n        cm = cos(omega/2.0-phi);\n        sp = sin(phi);\n        cp = cos(phi);\n        sg = sin(gamma/2.0);\n        cg = cos(gamma/2.0);\n\n        M[3] = (cm*cg*cp-sm*sp)*A[0][3]+(sm*cg*cp+cm*sp)*A[1][3]-sg*cp*A[2][3];\n        M[4] = (-cm*cg*sp-sm*cp)*A[0][3]+(-sm*cg*sp+cm*cp)*A[1][3]+sg*sp*A[2][3];\n        M[5] = (cm*sg)*A[0][3]+(sm*sg)*A[1][3]+cg*A[2][3];\n\n        return M;\n\n    }\n\n    /**\n     * Return the complement of a base (used internally)\n     * @param base The letter of the base\n     * @param RNA Whether it is RNA (if false, it is DNA)\n     * @return The character representing the complement of the base\n     */\n    protected static char complementBase(char base, boolean RNA) {\n        if (base == 'A' && RNA) return 'U';\n        if (base == 'A') return 'T';\n        if (base == 'T' && !RNA) return 'A';\n        if (base == 'U' && RNA) return 'A';\n        if (base == 'C') return 'G';\n        if (base == 'G') return 'C';\n        return ' ';\n    }\n\n    /**\n     * Simple helper method for quickly checking the complement of a sequence, see also DNASequence nad RNASequence classes\n     * for more extensively useful functions not used in this narrow context of structural biology of base pairs.  (Used internally)\n     */\n    private static String complement(String sequence, boolean RNA) {\n        String result = \"\";\n        for (int i = sequence.length() - 1; i >= 0; i--) {\n            result += complementBase(sequence.charAt(i), RNA);\n        }\n        return result;\n    }\n\n    /**\n     * 3D Vector cross product of two vectors as double arrays (used internally)\n     *\n     * @param a An array of length 3 or 4 (4th component is ignored)\n     * @param b An array of length 3 or 4 (4th component is ignored)\n     * @return The cross product of the vectors (just the first three components\n     */\n    private static double[] cross(double[] a, double[] b) {\n        assert a.length >= 3 && b.length >= 3;\n        double[] result = new double[4];\n        result[0] = a[1]*b[2]-a[2]*b[1];\n        result[1] = a[2]*b[0]-a[0]*b[2];\n        result[2] = a[0]*b[1]-a[1]*b[0];\n        return result;\n    }\n\n    /**\n     * Remove any component of vector a that is along vector b (used internally)\n     * @param a The array (vector) to remove component from\n     * @param b The component array (vector) to remove from the first\n     * @return The original array a with any component along b removed from it.\n     */\n    private static double[] removeComponent(double[] a, double[] b) {\n        double dot = 0;\n        double[] result = new double[4];\n        for (int i = 0; i < 3; i++) {\n            dot += a[i]*b[i];\n        }\n        for (int i = 0; i < 3; i++) {\n            result[i] = a[i]-dot*b[i];\n        }\n        return result;\n\n    }\n\n    /**\n     * Finds the longest common substring between two strings (used internally)\n     * @param s1 The first string\n     * @param s2 The second string\n     * @return The substring itself\n     */\n    private static String longestCommonSubstring(String s1, String s2) {\n        int start = 0;\n        int max = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            for (int j = 0; j < s2.length(); j++) {\n                int x = 0;\n                while (s1.charAt(i + x) == s2.charAt(j + x)) {\n                    x++;\n                    if (((i + x) >= s1.length()) || ((j + x) >= s2.length())) break;\n                }\n                if (x > max) {\n                    max = x;\n                    start = i;\n                }\n            }\n        }\n        return s1.substring(start, (start + max));\n    }\n\n    /**\n     * Return true if a is the complement of b (used internally)\n     * @param a First letter\n     * @param b Potential matching letter\n     * @param RNA Whether it is RNA (if false, DNA rules are used)\n     * @return True if the bases are complementary.\n     */\n    protected static boolean match(char a, char b, boolean RNA) {\n        if (a == 'A' && b == 'T' && !RNA) return true;\n        if (a == 'A' && b == 'U' && RNA) return true;\n        if (a == 'T' && b == 'A' && !RNA) return true;\n        if (a == 'U' && b == 'A' && RNA) return true;\n        if (a == 'G' && b == 'C') return true;\n        if (a == 'C' && b == 'G') return true;\n        return false;\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n *\n */\npackage org.biojava.nbio.structure.basepairs;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.biojava.nbio.structure.io.PDBFileReader;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static java.lang.Math.sin;\nimport static java.lang.Math.cos;\nimport static java.lang.Math.atan2;\nimport static java.lang.Math.acos;\nimport static java.lang.Math.PI;\n\n/**\n * This module calculates the el Hassan-Calladine Base Pairing and Base-pair Step Parameters for any nucleic\n * acid containing structure that has the information about the core base-pair rings.\n * Citation: https://www.ncbi.nlm.nih.gov/pubmed/11601858\n *\n * The method that is usually overridden is findPairs(), this base implementation is used for a large-scale\n * analysis of the most proper helical regions in almost 4000 protein-DNA structures, almost\n * 2000 structures containing only DNA, or almost 1300 structures containing only RNA. (as of 7/2017).\n * Those who study tertiary structures for RNA folding should use the TertiaryBasePairParameters,\n * because this base class is only looking for base pairs between separate strands that exactly line up.\n * To relax the lining up policy and allow for non-canonical base pairs, use the MismatchedBasePairParameters\n * class, which will not consider intra-strand base pairing.\n *\n * @author Luke Czapla\n * @since 5.0.0\n *\n */\npublic class BasePairParameters implements Serializable {\n\n    private static final long serialVersionUID = 6214502385L;\n    private static Logger log = LoggerFactory.getLogger(BasePairParameters.class);\n\n    // See URL http://ndbserver.rutgers.edu/ndbmodule/archives/reports/tsukuba/Table1.html\n    // and the paper cited at the top of this class (also as Table 1).\n    // These are hard-coded to avoid problems with resource paths.\n    public static final String[] STANDARD_BASES = new String[] {\n            \"SEQRES   1 A    1  A\\n\" +\n                    \"ATOM      2  N9    A A   1      -1.291   4.498   0.000\\n\" +\n                    \"ATOM      3  C8    A A   1       0.024   4.897   0.000\\n\" +\n                    \"ATOM      4  N7    A A   1       0.877   3.902   0.000\\n\" +\n                    \"ATOM      5  C5    A A   1       0.071   2.771   0.000\\n\" +\n                    \"ATOM      6  C6    A A   1       0.369   1.398   0.000\\n\" +\n                    \"ATOM      8  N1    A A   1      -0.668   0.532   0.000\\n\" +\n                    \"ATOM      9  C2    A A   1      -1.912   1.023   0.000\\n\" +\n                    \"ATOM     10  N3    A A   1      -2.320   2.290   0.000\\n\" +\n                    \"ATOM     11  C4    A A   1      -1.267   3.124   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  G\\n\" +\n                    \"ATOM      2  N9    G A   1      -1.289   4.551   0.000\\n\" +\n                    \"ATOM      3  C8    G A   1       0.023   4.962   0.000\\n\" +\n                    \"ATOM      4  N7    G A   1       0.870   3.969   0.000\\n\" +\n                    \"ATOM      5  C5    G A   1       0.071   2.833   0.000\\n\" +\n                    \"ATOM      6  C6    G A   1       0.424   1.460   0.000\\n\" +\n                    \"ATOM      8  N1    G A   1      -0.700   0.641   0.000\\n\" +\n                    \"ATOM      9  C2    G A   1      -1.999   1.087   0.000\\n\" +\n                    \"ATOM     11  N3    G A   1      -2.342   2.364   0.001\\n\" +\n                    \"ATOM     12  C4    G A   1      -1.265   3.177   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  T\\n\" +\n                    \"ATOM      2  N1    T A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    T A   1      -1.462   3.135   0.000\\n\" +\n                    \"ATOM      5  N3    T A   1      -0.298   2.407   0.000\\n\" +\n                    \"ATOM      6  C4    T A   1       0.994   2.897   0.000\\n\" +\n                    \"ATOM      8  C5    T A   1       1.106   4.338   0.000\\n\" +\n                    \"ATOM     10  C6    T A   1      -0.024   5.057   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  C\\n\" +\n                    \"ATOM      2  N1    C A   1      -1.285   4.542   0.000\\n\" +\n                    \"ATOM      3  C2    C A   1      -1.472   3.158   0.000\\n\" +\n                    \"ATOM      5  N3    C A   1      -0.391   2.344   0.000\\n\" +\n                    \"ATOM      6  C4    C A   1       0.837   2.868   0.000\\n\" +\n                    \"ATOM      8  C5    C A   1       1.056   4.275   0.000\\n\" +\n                    \"ATOM      9  C6    C A   1      -0.023   5.068   0.000\\n\" +\n                    \"END\",\n            \"SEQRES   1 A    1  U\\n\" +\n                    \"ATOM      2  N1    U A   1      -1.284   4.500   0.000\\n\" +\n                    \"ATOM      3  C2    U A   1      -1.462   3.131   0.000\\n\" +\n                    \"ATOM      5  N3    U A   1      -0.302   2.397   0.000\\n\" +\n                    \"ATOM      6  C4    U A   1       0.989   2.884   0.000\\n\" +\n                    \"ATOM      8  C5    U A   1       1.089   4.311   0.000\\n\" +\n                    \"ATOM      9  C6    U A   1      -0.024   5.053   0.000\\n\"\n    };\n\n    // this is also hard-coded data about standard WC base pairs for both DNA and RNA\n    protected static final String[] BASE_LIST_DNA = {\"A\", \"G\", \"T\", \"C\"};\n    protected static final String[] BASE_LIST_RNA = {\"A\", \"G\", \"U\", \"C\"};\n    protected static final Map<String, Integer> BASE_MAP;\n   // private static List<String> RNAspecific = Arrays.asList(\"U\", \"URA\"),\n   //        DNAspecific = Arrays.asList(\"DC\", \"C\", \"CYT\");\n    protected static final Map<Integer, List<String>> RING_MAP;\n    static {\n        BASE_MAP = new HashMap<>();\n        BASE_MAP.put(\"DA\", 0); BASE_MAP.put(\"ADE\", 0); BASE_MAP.put(\"A\", 0);\n        BASE_MAP.put(\"DG\", 1); BASE_MAP.put(\"GUA\", 1); BASE_MAP.put(\"G\", 1);\n        BASE_MAP.put(\"DT\", 2); BASE_MAP.put(\"THY\", 2); BASE_MAP.put(\"T\", 2); BASE_MAP.put(\"U\", 2); BASE_MAP.put(\"URA\", 2);\n        BASE_MAP.put(\"DC\", 3); BASE_MAP.put(\"CYT\", 3); BASE_MAP.put(\"C\", 3);\n\n        RING_MAP = new HashMap<>();\n        RING_MAP.put(0, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        RING_MAP.put(1, Arrays.asList(\"C8\", \"C2\", \"N3\", \"C4\", \"C5\", \"C6\", \"N7\", \"N1\", \"N9\"));\n        RING_MAP.put(2, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n        RING_MAP.put(3, Arrays.asList(\"C6\", \"C2\", \"N3\", \"C4\", \"C5\", \"N1\"));\n   }\n\n    protected transient Structure structure;\n    protected boolean canonical = true;\n    protected boolean useRNA = false;\n    protected boolean nonredundant = false;\n    protected double[] pairParameters;\n\n    // this is the main data that the user wants to get back out from the procedure.\n    protected String pairSequence = \"\";\n    protected double[][] pairingParameters;\n    protected double[][] stepParameters;\n    protected List<String> pairingNames = new ArrayList<>();\n    protected List<Matrix4d> referenceFrames = new ArrayList<>();\n\n\n    /**\n     * This constructor takes a Structure object, finds base pair and base-pair step parameters\n     * for double-helical regions within the structure.\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA whether to look for canonical RNA pairs.  By default (false) it analyzes DNA.\n     * @param removeDups whether to only look for base-pair parameters for each unique sequence in\n     *  the structure (if set to <i>true</i>)\n     * @param canonical Whether to consider only Watson-Crick base pairs\n     */\n    public BasePairParameters(Structure structure, boolean useRNA, boolean removeDups, boolean canonical) {\n        this.structure = structure;\n        this.useRNA = useRNA;\n        this.canonical = canonical;\n        this.nonredundant = removeDups;\n\n    }\n\n    /**\n     * This constructor takes a Structure object, whether to use RNA, and whether to remove duplicate sequences.\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA if true, the RNA standard bases will be used.  Otherwise, if false, it will work on standard DNA bases.\n     * @param removeDups if true, duplicate sequences will not be considered.  This is for the analysis of X-ray structures from\n     *                   RCSB, where there may be identical or similar units.\n     */\n    public BasePairParameters(Structure structure, boolean useRNA, boolean removeDups) {\n        this(structure, useRNA, removeDups, false);\n    }\n\n    /**\n     * This constructor takes a Structure object, and whether to use the RNA standard bases.\n     * @param structure The already-loaded structure to analyze.\n     * @param useRNA if true, the RNA standard bases will be used.  Otherwise, if false, it will work on standard DNA bases.\n     */\n    public BasePairParameters(Structure structure, boolean useRNA) {\n        this(structure, useRNA, false, false);\n    }\n\n    /**\n     * This constructor takes a Structure object, finds base pair and base-pair step parameters\n     * for double-helical regions within the structure for only canonical DNA pairs.\n     * @param structure The already-loaded structure to analyze.\n     */\n    public BasePairParameters(Structure structure) {\n        this(structure, false, false, true);\n    }\n\n\n    /**\n     * This method is the main function call to extract all step parameters, pairing parameters, and sequence\n     * information from the Structure object provided to the constructor.\n     * @return This same object with the populated data, convenient for output\n     *  (e.g. <i>log.info(new BasePairParameters(structure).analyze());</i>)\n     */\n    public BasePairParameters analyze() {\n        if (structure == null) {\n            pairingParameters = null;\n            stepParameters = null;\n            return this;\n        }\n        List<Chain> nucleics = this.getNucleicChains(nonredundant);\n        List<Pair<Group>> pairs = this.findPairs(nucleics);\n        this.pairingParameters = new double[pairs.size()][6];\n        this.stepParameters = new double[pairs.size()][6];\n        Matrix4d lastStep;\n        Matrix4d currentStep = null;\n        for (int i = 0; i < pairs.size(); i++) {\n            lastStep = currentStep;\n            currentStep = this.basePairReferenceFrame(pairs.get(i));\n            referenceFrames.add((Matrix4d)currentStep.clone());\n            for (int j = 0; j < 6; j++) pairingParameters[i][j] = pairParameters[j];\n            if (i != 0) {\n                lastStep.invert();\n                lastStep.mul(currentStep);\n                double[] sparms = calculateTp(lastStep);\n                for (int j = 0; j < 6; j++) stepParameters[i][j] = sparms[j];\n            }\n        }\n        return this;\n    }\n\n\n\n    /**\n     * This method returns the total number of base pairs that were found, used after the call to analyze().\n     * @return An integer value, number of base pairs\n     */\n    public int getLength() {\n        if (structure == null || pairParameters == null) throw new IllegalArgumentException(\"This structure is not analyzed or not initialized.\");\n        return pairingParameters.length;\n    }\n\n\n    /**\n     * This method reports all the pair parameters, in the order of:\n     * buckle, propeller, opening (in degrees), shear, stagger, stretch (in Å).\n     * @return A double[][] with length equal to number of base pairs for rows, and 6 columns\n     */\n    public double[][] getPairingParameters() {\n        return pairingParameters;\n    }\n\n    /**\n     * This method reports all the base-pair step parameters, in the order of:\n     * tilt, roll, twist (in degrees), shift, slide, rise (in Å).\n     * @return A double[][] with length equal to number of base pairs (the first row 0 has no step\n     *  and therefore is six zeroes), and 6 columns.\n     */\n    public double[][] getStepParameters() {\n        return stepParameters;\n    }\n\n\n    /**\n     * This method returns the primary strand's sequence where parameters were found.\n     * There are spaces in the string anywhere there was a break in the helix or when\n     * it goes from one helix to another helix in the structure. (the \"step\" is still returned)\n     * @return String of primary sequence with spaces between gaps and new helices.\n     */\n    public String getPairSequence() {\n        return pairSequence;\n    }\n\n\n    /**\n     * This method returns the names of the pairs in terms of A, G, T/U, and C for each base pair group in the\n     * list.  The first character is the leading strand base and the second character is the complementary base\n     * @return\n     */\n    public List<String> getPairingNames() {\n        return pairingNames;\n    }\n\n    public List<Matrix4d> getReferenceFrames() {\n        return referenceFrames;\n    }\n\n    /**\n     * This method is an internal test that the base pair specified is within a valid range.  If not, it throws an exception\n     * with a message.\n     * @param bp The index of the base pair or base-pair step to return.\n     */\n    private void checkArgument(int bp) {\n        if (bp < 0 || bp >= getPairingParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    }\n\n    /**\n     * This method returns the buckle in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getBuckle(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][0];\n    }\n\n    /**\n     * This method returns the propeller (\"propeller-twist\") in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getPropeller(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][1];\n    }\n\n    /**\n     * This method returns the opening in degrees for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getOpening(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][2];\n    }\n\n    /**\n     * This method returns the shear in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getShear(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][3];\n    }\n\n    /**\n     * This method returns the stretch in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getStretch(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][4];\n    }\n\n    /**\n     * This method returns the stagger in Å for the given base pair\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getStagger(int bp) {\n        checkArgument(bp);\n        return pairingParameters[bp][5];\n    }\n\n    /**\n     * This method returns the tilt for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getTilt(int bp) {\n        checkArgument(bp);\n        return stepParameters[bp][0];\n    }\n\n    /**\n     * This method returns the roll for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getRoll(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][1];\n    }\n\n    /**\n     * This method returns the twist for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in degrees)\n     */\n    public Double getTwist(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][2];\n    }\n\n    /**\n     * Return the shift for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getShift(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][3];\n    }\n\n    /**\n     * This method returns the slide for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getSlide(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][4];\n    }\n\n    /**\n     * This method returns the rise for the given base pair, relative to the one before it.\n     * @param bp the number of the base pair (starting with 0)\n     * @return the value as a double (in Å)\n     */\n    public Double getRise(int bp) {\n        if (bp < 0 || bp >= getStepParameters().length) throw new IllegalArgumentException(\"Base pair number is out of range.\");\n        return stepParameters[bp][5];\n    }\n\n\n    /**\n     * This method reports all the nucleic acid chains and has an option to remove duplicates if you\n     * are considering an analysis of only unique DNA or RNA helices in the Structure.\n     * @param removeDups If true, it will ignore duplicate chains\n     * @return A list of all the nucleic acid chains in order of the Structure\n     */\n    public List<Chain> getNucleicChains(boolean removeDups) {\n        if (structure == null) return new ArrayList<>();\n        List<Chain> chains = structure.getChains();\n        List<Chain> result = new ArrayList<>();\n        for (Chain c: chains) {\n            if (c.isNucleicAcid()) {\n                result.add(c);\n            }\n        }\n        if (removeDups) for (int i = 0; i < result.size(); i++) {\n            for (int j = i+2; j < result.size(); j++) {\n                // remove duplicate sequences (structures with two or more identical units)\n                if (result.get(i).getAtomSequence().equals(result.get(j).getAtomSequence())) {\n                    result.remove(j);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * This method performs a search for base pairs in the structure.  The criteria is alignment of\n     * sequences and the canonical base pairs of DNA or RNA. Use MismatchedBasePairParameters\n     * or TertiaryBasePairParameters for finding higher-order associations.\n     * @param chains The list of chains already found to be nucleic acids\n     * @return The list of corresponding Watson-Crick groups as pairs, as a Pair of nucleic acid Groups\n     */\n    public List<Pair<Group>> findPairs(List<Chain> chains) {\n        List<Pair<Group>> result = new ArrayList<>();\n        for (int i = 0; i < chains.size(); i++) {\n            Chain c = chains.get(i);\n            for (int j = i+1; j < chains.size(); j++) {\n                String complement = complement(chains.get(j).getAtomSequence(), useRNA);\n                String match = longestCommonSubstring(c.getAtomSequence(), complement);\n                if (log.isDebugEnabled()) {\n                    log.debug(c.getAtomSequence() + \" \" + chains.get(j).getAtomSequence() + \" \" + match);\n                }\n                int index1 = c.getAtomSequence().indexOf(match);\n                int index2 = complement.length() - complement.indexOf(match) - 1;\n                for (int k = 0; k < match.length(); k++) {\n                    Group g1 = c.getAtomGroup(index1+k);\n                    Group g2 = chains.get(j).getAtomGroup(index2-k);\n                    Integer type1 = BASE_MAP.get(g1.getPDBName());\n                    Integer type2 = BASE_MAP.get(g2.getPDBName());\n                    if (type1 == null || type2 == null) {\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    Atom a1 = g1.getAtom(RING_MAP.get(type1).get(0));\n                    Atom a2 = g2.getAtom(RING_MAP.get(type2).get(0));\n\n                    if (a1 == null) {\n                        log.info(\"Error processing \" + g1.getPDBName());\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n                    if (a2 == null) {\n                        log.info(\"Error processing \" + g2.getPDBName());\n                        if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                        continue;\n                    }\n\n                    double dx = a1.getX()-a2.getX();\n                    double dy = a1.getY()-a2.getY();\n                    double dz = a1.getZ()-a2.getZ();\n                    double distance = Math.sqrt(dx*dx+dy*dy+dz*dz);\n                    //log.info(\"C8-C6 Distance (Å): \" + distance);\n                    // could be a base pair\n                    if (Math.abs(distance-10.0) < 4.0) {\n                        boolean valid = true;\n                        for (String atomname : RING_MAP.get(type1)) {\n                            Atom a = g1.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) for (String atomname: RING_MAP.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null) valid = false;\n                        }\n                        if (valid) {\n                            result.add(new Pair<Group>(g1, g2));\n                            pairingNames.add((useRNA ? BASE_LIST_RNA[type1]+ BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1]+ BASE_LIST_DNA[type2]));\n                            pairSequence += c.getAtomSequence().charAt(index1 + k);\n                        } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n                }\n                if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length()-1) != ' ') pairSequence += ' ';\n            }\n            //log.info();\n        }\n        log.info(\"Matched: \" + pairSequence);\n        return result;\n    }\n\n\n    /**\n     * This method calculates the central frame (4x4 transformation matrix) of a single base pair.\n     * @param pair An array of the two groups that make a hypothetical pair\n     * @return The middle frame of the center of the base-pair formed\n     */\n    public Matrix4d basePairReferenceFrame(Pair<Group> pair) {\n        Integer type1 = BASE_MAP.get(pair.getFirst().getPDBName());\n        Integer type2 = BASE_MAP.get(pair.getSecond().getPDBName());\n        SuperPosition sp = new SuperPositionQCP(true);\n        if (type1 == null || type2 == null) return null;\n        PDBFileReader pdbFileReader = new PDBFileReader();\n        Structure s1, s2;\n        try {\n            s1 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type1].getBytes()));\n            s2 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type2].getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        Group std1 = s1.getChain(\"A\").getAtomGroup(0);\n        Group std2 = s2.getChain(\"A\").getAtomGroup(0);\n\n        Point3d[] pointref = new Point3d[std1.getAtoms().size()];\n        Point3d[] pointact = new Point3d[std1.getAtoms().size()];\n        int count = 0;\n\n        for (Atom a : std1.getAtoms()) {\n            if (pair.getFirst().getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair.getFirst().getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std1.getAtoms().size();\n        Matrix4d ref1 = (Matrix4d)sp.superposeAndTransform(pointact, pointref).clone();\n\n        pointref = new Point3d[std2.getAtoms().size()];\n        pointact = new Point3d[std2.getAtoms().size()];\n\n        count = 0;\n        for (Atom a : std2.getAtoms()) {\n            if (pair.getSecond().getAtom(a.getName()) == null) return null;\n            pointref[count] = a.getCoordsAsPoint3d();\n            pointact[count] = pair.getSecond().getAtom(a.getName()).getCoordsAsPoint3d();\n            count++;\n        }\n        assert count == std2.getAtoms().size();\n\n        Matrix4d temp = (Matrix4d)ref1.clone();\n        Matrix4d temp2 = (Matrix4d)temp.clone();\n        Matrix4d ref2 = sp.superposeAndTransform(pointact, pointref);\n\n        double[][] v = new double[3][4];\n        double[] y3 = new double[4];\n        double[] z3 = new double[4];\n        ref2.getColumn(1, y3);\n        ref2.getColumn(2, z3);\n        double[] z31 = new double[4];\n        ref1.getColumn(2, z31);\n        if (z3[0]*z31[0]+z3[1]*z31[1]+z3[2]*z31[2] < 0.0) {\n            for (int i = 0; i < 3; i++) {\n                y3[i] *= -1.0;\n                z3[i] *= -1.0;\n            }\n        }\n        ref2.setColumn(1, y3);\n        ref2.setColumn(2, z3);\n\n        temp.add(ref2);\n        temp.mul(0.5);\n        double[] x3 = new double[4];\n        temp.getColumn(0, x3);\n        temp.getColumn(1, y3);\n        temp.getColumn(2, z3);\n        x3 = removeComponent(x3, z3);\n        x3 = removeComponent(x3, y3);\n        y3 = removeComponent(y3, z3);\n        temp.setColumn(0, x3);\n        temp.setColumn(1, y3);\n        temp.setColumn(2, z3);\n\n        // normalize the short, long, and normal axes\n        for (int i = 0; i < 3; i++) {\n            temp.getColumn(i, v[i]);\n            double r = Math.sqrt(v[i][0] * v[i][0] + v[i][1] * v[i][1] + v[i][2] * v[i][2]);\n            for (int j = 0; j < 3; j++) {\n                v[i][j] /= r;\n            }\n            temp.setColumn(i, v[i]);\n        }\n\n        // calculate pairing parameters: buckle, propeller, opening, shear, stretch, stagger\n        temp2.invert();\n        temp2.mul(ref2);\n        pairParameters = calculateTp(temp2);\n        for (int i = 0; i < 6; i++) pairParameters[i] *= -1;\n\n        // return the central frame of the base pair\n        return temp;\n\n    }\n\n\n    @Override\n    public String toString() {\n        if (getPairingParameters() == null) return \"No data\";\n        StringBuilder result = new StringBuilder(10000);\n        result.append(pairingParameters.length + \" base pairs\\n\");\n        result.append(\"bp: buckle propeller opening shear stretch stagger tilt roll twist shift slide rise\\n\");\n        for (int i = 0; i < pairingParameters.length; i++) {\n            result.append(pairingNames.get(i)+\": \");\n            for (int j = 0; j < 6; j++)\n                result.append(String.format(\"%5.4f\", pairingParameters[i][j]) + \" \");\n            for (int j = 0; j < 6; j++)\n                result.append(String.format(\"%5.4f\", stepParameters[i][j]) + \" \");\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n\n    // The following methods are just helper classes for the rapid analyze of base-pair geometry.\n    /**\n     * This method calculates pairing and step parameters from 4x4 transformation matrices (used internally)\n     * that comes out as a Matrix4d.\n     * @param input the 4x4 matrix representing the transformation from strand II -> strand I or pair i to pair i+1\n     * @return Six parameters as double[6]\n     */\n    public static double[] calculateTp(Matrix4d input) {\n\n        double[][] A = new double[4][4];\n        for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) {\n            A[i][j] = input.getElement(i, j);\n        }\n        double[] M = new double[6];\n\n        double cosgamma, gamma, phi, omega, sgcp, omega2_minus_phi,\n                sm, cm, sp, cp, sg, cg;\n\n        cosgamma = A[2][2];\n        if (cosgamma > 1.0) cosgamma = 1.0;\n        else if (cosgamma < -1.0) cosgamma = -1.0;\n\n        gamma = acos(cosgamma);\n\n        sgcp = A[1][1]*A[0][2]-A[0][1]*A[1][2];\n\n        if (gamma == 0.0) omega = -atan2(A[0][1],A[1][1]);\n        else omega = atan2(A[2][1]*A[0][2]+sgcp*A[1][2],sgcp*A[0][2]-A[2][1]*A[1][2]);\n\n        omega2_minus_phi = atan2(A[1][2],A[0][2]);\n\n        phi = omega/2.0 - omega2_minus_phi;\n\n        M[0] = gamma*sin(phi)*180.0/PI;\n        M[1] = gamma*cos(phi)*180.0/PI;\n        M[2] = omega*180.0/PI;\n\n        sm = sin(omega/2.0-phi);\n        cm = cos(omega/2.0-phi);\n        sp = sin(phi);\n        cp = cos(phi);\n        sg = sin(gamma/2.0);\n        cg = cos(gamma/2.0);\n\n        M[3] = (cm*cg*cp-sm*sp)*A[0][3]+(sm*cg*cp+cm*sp)*A[1][3]-sg*cp*A[2][3];\n        M[4] = (-cm*cg*sp-sm*cp)*A[0][3]+(-sm*cg*sp+cm*cp)*A[1][3]+sg*sp*A[2][3];\n        M[5] = (cm*sg)*A[0][3]+(sm*sg)*A[1][3]+cg*A[2][3];\n\n        return M;\n\n    }\n\n    /**\n     * This method returns the complement of a base. (used internally)\n     * @param base The letter of the base\n     * @param RNA Whether it is RNA (if false, it is DNA)\n     * @return The character representing the complement of the base\n     */\n    protected static char complementBase(char base, boolean RNA) {\n        if (base == 'A' && RNA) return 'U';\n        if (base == 'A') return 'T';\n        if (base == 'T' && !RNA) return 'A';\n        if (base == 'U' && RNA) return 'A';\n        if (base == 'C') return 'G';\n        if (base == 'G') return 'C';\n        return ' ';\n    }\n\n    /**\n     * Simple helper method for quickly checking the complement of a sequence, see also DNASequence nad RNASequence classes\n     * for more extensively useful functions not used in this narrow context of structural biology of base pairs.  (Used internally)\n     */\n    private static String complement(String sequence, boolean RNA) {\n        String result = \"\";\n        for (int i = sequence.length() - 1; i >= 0; i--) {\n            result += complementBase(sequence.charAt(i), RNA);\n        }\n        return result;\n    }\n\n    /**\n     * This does a 3D Vector cross product of two vectors as double arrays. (used internally)\n     *\n     * @param a An array of length 3 or 4 (4th component is ignored)\n     * @param b An array of length 3 or 4 (4th component is ignored)\n     * @return The cross product of the vectors (just the first three components\n     */\n    private static double[] cross(double[] a, double[] b) {\n        assert a.length >= 3 && b.length >= 3;\n        double[] result = new double[4];\n        result[0] = a[1]*b[2]-a[2]*b[1];\n        result[1] = a[2]*b[0]-a[0]*b[2];\n        result[2] = a[0]*b[1]-a[1]*b[0];\n        return result;\n    }\n\n    /**\n     * This method removes any component of vector a that is along vector b. (used internally)\n     * @param a The array (vector) to remove component from\n     * @param b The component array (vector) to remove from the first\n     * @return The original array a with any component along b removed from it.\n     */\n    private static double[] removeComponent(double[] a, double[] b) {\n        double dot = 0;\n        double[] result = new double[4];\n        for (int i = 0; i < 3; i++) {\n            dot += a[i]*b[i];\n        }\n        for (int i = 0; i < 3; i++) {\n            result[i] = a[i]-dot*b[i];\n        }\n        return result;\n\n    }\n\n    /**\n     * This method finds the longest common substring between two strings. (used internally)\n     * @param s1 The first string\n     * @param s2 The second string\n     * @return The substring itself\n     */\n    private static String longestCommonSubstring(String s1, String s2) {\n        int start = 0;\n        int max = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            for (int j = 0; j < s2.length(); j++) {\n                int x = 0;\n                while (s1.charAt(i + x) == s2.charAt(j + x)) {\n                    x++;\n                    if (((i + x) >= s1.length()) || ((j + x) >= s2.length())) break;\n                }\n                if (x > max) {\n                    max = x;\n                    start = i;\n                }\n            }\n        }\n        return s1.substring(start, (start + max));\n    }\n\n    /**\n     * This returns true if a is the complement of b, false otherwise. (used internally)\n     * @param a First letter\n     * @param b Potential matching letter\n     * @param RNA Whether it is RNA (if false, DNA rules are used)\n     * @return True if the bases are complementary.\n     */\n    protected static boolean match(char a, char b, boolean RNA) {\n        if (a == 'A' && b == 'T' && !RNA) return true;\n        if (a == 'A' && b == 'U' && RNA) return true;\n        if (a == 'T' && b == 'A' && !RNA) return true;\n        if (a == 'U' && b == 'A' && RNA) return true;\n        if (a == 'G' && b == 'C') return true;\n        if (a == 'C' && b == 'G') return true;\n        return false;\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n *\n */\npackage org.biojava.nbio.structure.basepairs;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.basepairs.BasePairParameters;\nimport org.junit.Test;\n\nimport java.io.IOException;\n\nimport static org.junit.Assert.*;\n\n/**\n * Contributed to BioJava under it's LGPL\n * This class tests the implementations of the search for base pairs for different RCSB structures\n * and the tests uses 3DNA as a comparator program. (other programs such as CURVES and NEWHELIX exist but\n * this implementation is closest to that of 3DNA).\n * @author Luke Czapla\n * @since 5.0.0\n *\n */\npublic class TestBasePairParameters {\n\n    @Test\n    public void testBasePair() throws IOException, StructureException {\n\n        Structure structure = StructureIO.getStructure(\"1KX5\");\n\n        BasePairParameters bp = new BasePairParameters(structure);\n        bp.analyze();\n        String sequence = bp.getPairSequence();\n\n        assertEquals(147, bp.getLength());\n        // below all this set of comparator data was from an external program, 3DNA.\n        // next three in degrees: buckle, propeller, opening\n        assertEquals(bp.getBuckle(0), -3.796, 0.1);\n        assertEquals(bp.getPropeller(0), 4.482, 0.1);\n        assertEquals(bp.getOpening(0), -0.730, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(bp.getShear(0), -0.324, 0.02);\n        assertEquals(bp.getStretch(0), -0.578, 0.02);\n        assertEquals(bp.getStagger(0), -0.336, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(bp.getTilt(1), 2.354, 0.1);\n        assertEquals(bp.getRoll(1), 0.785, 0.1);\n        assertEquals(bp.getTwist(1), 32.522, 0.5);\n        // next three in Å, shift, slide, rise\n        assertEquals(bp.getShift(1), -0.873, 0.02);\n        assertEquals(bp.getSlide(1), -0.607, 0.02);\n        assertEquals(bp.getRise(1), 3.070, 0.02);\n\n\n        structure = StructureIO.getStructure(\"3PHP\");\n        bp = new TertiaryBasePairParameters(structure, true, false).analyze();\n        assertEquals(9, bp.getLength());\n\n        double[][] pairs = bp.getPairingParameters();\n        double[][] steps = bp.getStepParameters();\n\n        // test against values given by 3DNA, just using the raw arrays\n        assertEquals(pairs[4][0], 0.060, 0.1);\n        assertEquals(pairs[4][1], -9.323, 0.1);\n        assertEquals(pairs[4][2], -5.109, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(pairs[4][3], 0.126, 0.02);\n        assertEquals(pairs[4][4], -0.177, 0.02);\n        assertEquals(pairs[4][5], 0.273, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(steps[4][0], -1.456, 0.1);\n        assertEquals(steps[4][1], 6.583, 0.1);\n        assertEquals(steps[4][2], 33.234, 0.5);\n        // next three in Å, shift, slide, rise\n        assertEquals(steps[4][3], -0.735, 0.02);\n        assertEquals(steps[4][4], -0.978, 0.02);\n        assertEquals(steps[4][5], 3.491, 0.02);\n\n\n        structure = StructureIO.getStructure(\"1P71\");\n\n        bp = new MismatchedBasePairParameters(structure, false, false, false).analyze();\n        assertEquals(17, bp.getLength());\n\n        pairs = bp.getPairingParameters();\n        steps = bp.getStepParameters();\n\n        // this was tested against 3DNA as well.\n        assertEquals(pairs[16][0], -11.822, 0.1);\n        assertEquals(pairs[16][1], -11.405, 0.1);\n        assertEquals(pairs[16][2], -9.669, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(pairs[16][3], 0.855, 0.02);\n        assertEquals(pairs[16][4], -0.276, 0.02);\n        assertEquals(pairs[16][5], -0.604, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(steps[16][0], 1.516, 0.1);\n        assertEquals(steps[16][1], 9.291, 0.1);\n        assertEquals(steps[16][2], 42.052, 1.0);\n        // next three in Å, shift, slide, rise\n        assertEquals(steps[16][3], -0.627, 0.02);\n        assertEquals(steps[16][4], -0.858, 0.02);\n        assertEquals(steps[16][5], 4.697, 0.02);\n\n    }\n\n}\n\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n *\n */\npackage org.biojava.nbio.structure.basepairs;\n\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureIO;\nimport org.biojava.nbio.structure.basepairs.BasePairParameters;\nimport org.junit.Test;\n\nimport java.io.IOException;\n\nimport static org.junit.Assert.*;\n\n/**\n * This class tests the implementations of the search for base pairs for different RCSB structures\n * and the tests uses 3DNA as a comparator program. (other programs such as CURVES and NEWHELIX work similarly but\n * this implementation is closest to that of 3DNA)\n * @author Luke Czapla\n * @since 5.0.0\n *\n */\npublic class TestBasePairParameters {\n\n    @Test\n    public void testBasePair() throws IOException, StructureException {\n\n        Structure structure = StructureIO.getStructure(\"1KX5\");\n\n        BasePairParameters bp = new BasePairParameters(structure);\n        bp.analyze();\n        String sequence = bp.getPairSequence();\n\n        assertEquals(147, bp.getLength());\n        // below all this set of comparator data was from an external program, 3DNA.\n        // next three in degrees: buckle, propeller, opening\n        assertEquals(bp.getBuckle(0), -3.796, 0.1);\n        assertEquals(bp.getPropeller(0), 4.482, 0.1);\n        assertEquals(bp.getOpening(0), -0.730, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(bp.getShear(0), -0.324, 0.02);\n        assertEquals(bp.getStretch(0), -0.578, 0.02);\n        assertEquals(bp.getStagger(0), -0.336, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(bp.getTilt(1), 2.354, 0.1);\n        assertEquals(bp.getRoll(1), 0.785, 0.1);\n        assertEquals(bp.getTwist(1), 32.522, 0.5);\n        // next three in Å, shift, slide, rise\n        assertEquals(bp.getShift(1), -0.873, 0.02);\n        assertEquals(bp.getSlide(1), -0.607, 0.02);\n        assertEquals(bp.getRise(1), 3.070, 0.02);\n\n\n        structure = StructureIO.getStructure(\"3PHP\");\n        bp = new TertiaryBasePairParameters(structure, true, false).analyze();\n        assertEquals(9, bp.getLength());\n\n        double[][] pairs = bp.getPairingParameters();\n        double[][] steps = bp.getStepParameters();\n\n        // test against values given by 3DNA, just using the raw arrays\n        assertEquals(pairs[4][0], 0.060, 0.1);\n        assertEquals(pairs[4][1], -9.323, 0.1);\n        assertEquals(pairs[4][2], -5.109, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(pairs[4][3], 0.126, 0.02);\n        assertEquals(pairs[4][4], -0.177, 0.02);\n        assertEquals(pairs[4][5], 0.273, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(steps[4][0], -1.456, 0.1);\n        assertEquals(steps[4][1], 6.583, 0.1);\n        assertEquals(steps[4][2], 33.234, 0.5);\n        // next three in Å, shift, slide, rise\n        assertEquals(steps[4][3], -0.735, 0.02);\n        assertEquals(steps[4][4], -0.978, 0.02);\n        assertEquals(steps[4][5], 3.491, 0.02);\n\n\n        structure = StructureIO.getStructure(\"1P71\");\n\n        bp = new MismatchedBasePairParameters(structure, false, false, false).analyze();\n        assertEquals(17, bp.getLength());\n\n        pairs = bp.getPairingParameters();\n        steps = bp.getStepParameters();\n\n        // this was tested against 3DNA as well.\n        assertEquals(pairs[16][0], -11.822, 0.1);\n        assertEquals(pairs[16][1], -11.405, 0.1);\n        assertEquals(pairs[16][2], -9.669, 0.1);\n        // next three in Å: shear, stretch, stagger\n        assertEquals(pairs[16][3], 0.855, 0.02);\n        assertEquals(pairs[16][4], -0.276, 0.02);\n        assertEquals(pairs[16][5], -0.604, 0.02);\n        // next three in degrees: tilt, roll, twist\n        assertEquals(steps[16][0], 1.516, 0.1);\n        assertEquals(steps[16][1], 9.291, 0.1);\n        assertEquals(steps[16][2], 42.052, 1.0);\n        // next three in Å, shift, slide, rise\n        assertEquals(steps[16][3], -0.627, 0.02);\n        assertEquals(steps[16][4], -0.858, 0.02);\n        assertEquals(steps[16][5], 4.697, 0.02);\n\n    }\n\n}\n\n","commitMessage":"Full sentence revision of all JavaDoc and addition of separate error checking method\n","test_commitMessage":"Full sentence revision of all JavaDoc and addition of separate error checking method\n","allZero":false}