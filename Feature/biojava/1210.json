{"repository":"biojava","prod_path":"core/src/main/java/org/biojavax/bio/seq/io/GenbankFormat.java","test_path":"core/src/test/java/org/biojavax/bio/seq/io/GenbankFormatTest.java","prod_time":"2009-10-10 06:47:49","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b24ad9a67fb22d8ace85973e5925cf711a6f877a","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage\torg.biojavax.bio.seq.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojava.bio.seq.io.SeqIOListener;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojavax.Comment;\nimport org.biojavax.CrossRef;\nimport org.biojavax.DocRef;\nimport org.biojavax.DocRefAuthor;\nimport org.biojavax.Namespace;\nimport org.biojavax.Note;\nimport org.biojavax.RankedCrossRef;\nimport org.biojavax.RankedDocRef;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.SimpleComment;\nimport org.biojavax.SimpleCrossRef;\nimport org.biojavax.SimpleDocRef;\nimport org.biojavax.SimpleRankedCrossRef;\nimport org.biojavax.SimpleRankedDocRef;\nimport org.biojavax.SimpleRichAnnotation;\nimport org.biojavax.bio.seq.CompoundRichLocation;\nimport org.biojavax.bio.seq.RichFeature;\nimport org.biojavax.bio.seq.RichLocation;\nimport org.biojavax.bio.seq.RichSequence;\nimport org.biojavax.bio.seq.SimplePosition;\nimport org.biojavax.bio.seq.SimpleRichLocation;\nimport org.biojavax.bio.taxa.NCBITaxon;\nimport org.biojavax.bio.taxa.SimpleNCBITaxon;\nimport org.biojavax.ontology.ComparableTerm;\nimport org.biojavax.utils.StringTools;\n\n/**\n * Format reader for GenBank files. This version of Genbank format will generate\n * and write RichSequence objects. Loosely Based on code from the old, deprecated,\n * org.biojava.bio.seq.io.GenbankFormat object.\n *\n * @author Richard Holland\n * @author Mark Schreiber\n * @author David Scott\n * @author Bubba Puryear\n * @author George Waldon\n * @since 1.5\n */\npublic class GenbankFormat extends RichSequenceFormat.HeaderlessFormat {\n    \n    // Register this format with the format auto-guesser.\n    static {\n        RichSequence.IOTools.registerFormat(GenbankFormat.class);\n    }\n    \n    /**\n     * The name of this format\n     */\n    public static final String GENBANK_FORMAT = \"GENBANK\";\n    \n    protected static final String LOCUS_TAG =           \"LOCUS\";\n    protected static final String DEFINITION_TAG =      \"DEFINITION\";\n    protected static final String ACCESSION_TAG =       \"ACCESSION\";\n    protected static final String VERSION_TAG =         \"VERSION\";\n    protected static final String KEYWORDS_TAG =        \"KEYWORDS\";\n    //                                                  \"SEGMENT\"\n    protected static final String SOURCE_TAG =          \"SOURCE\";\n    protected static final String ORGANISM_TAG =        \"ORGANISM\";\n    protected static final String REFERENCE_TAG =       \"REFERENCE\";\n    protected static final String AUTHORS_TAG =         \"AUTHORS\";\n    protected static final String CONSORTIUM_TAG =      \"CONSRTM\";\n    protected static final String TITLE_TAG =           \"TITLE\";\n    protected static final String JOURNAL_TAG =         \"JOURNAL\";\n    protected static final String PUBMED_TAG =          \"PUBMED\";\n    protected static final String MEDLINE_TAG =         \"MEDLINE\"; //deprecated\n    protected static final String REMARK_TAG =          \"REMARK\";\n    protected static final String COMMENT_TAG =         \"COMMENT\";\n    protected static final String FEATURE_TAG =         \"FEATURES\";\n    protected static final String BASE_COUNT_TAG_FULL = \"BASE COUNT\"; //deprecated\n    protected static final String BASE_COUNT_TAG =      \"BASE\";\n    //                                                  \"CONTIG\"\n    protected static final String START_SEQUENCE_TAG =  \"ORIGIN\";\n    protected static final String END_SEQUENCE_TAG =    \"//\";\n    \n    // locus line\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+)\\\\s+\\\\d+\\\\s+(bp|aa)\\\\s{1,4}([dms]s-)?(\\\\S+)?\\\\s+(circular|linear)?\\\\s*(\\\\S+)?\\\\s*(\\\\S+)?$\");\n    // version line\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S*?)(\\\\.(\\\\d+))?(\\\\s+GI:(\\\\S+))?$\");\n    // reference line\n    protected static final Pattern refRange = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+to\\\\s+(\\\\d+)$\");\n    protected static final Pattern refp = Pattern.compile(\"^(\\\\d+)\\\\s*(?:(\\\\((?:bases|residues)\\\\s+(\\\\d+\\\\s+to\\\\s+\\\\d+(\\\\s*;\\\\s*\\\\d+\\\\s+to\\\\s+\\\\d+)*)\\\\))|\\\\(sites\\\\))?\");\n    // dbxref line\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\n    //sections start at a line and continue till the first line afterwards with a\n    //non-whitespace first character\n    //we want to match any of the following as a new section within a section\n    //  \\s{0,8} word \\s{1,7} value\n    //  \\s{21} /word = value\n    //  \\s{21} /word\n    protected static final Pattern sectp = Pattern.compile(\"^(\\\\s{0,8}(\\\\S+)\\\\s{1,7}(.*)|\\\\s{21}(/\\\\S+?)=(.*)|\\\\s{21}(/\\\\S+))$\");\n    \n    protected static final Pattern readableFiles = Pattern.compile(\".*(g[bp]k*$|\\\\u002eg[bp].*)\");\n    protected static final Pattern headerLine = Pattern.compile(\"^LOCUS.*\");\n    \n    private final static HashSet isNotQuoted = new HashSet();\n    static {\n        isNotQuoted.add(\"anticodon\");\n        isNotQuoted.add(\"citation\");\n        isNotQuoted.add(\"codon\");\n        isNotQuoted.add(\"codon_start\");\n        isNotQuoted.add(\"compare\");\n        isNotQuoted.add(\"cons_splice\");\n        isNotQuoted.add(\"direction\");\n        isNotQuoted.add(\"estimated_length\");\n        isNotQuoted.add(\"label\");\n        isNotQuoted.add(\"mod_base\");\n        isNotQuoted.add(\"number\");\n        isNotQuoted.add(\"rpt_type\");\n        isNotQuoted.add(\"rpt_unit_range\");\n        isNotQuoted.add(\"transl_except\");\n        isNotQuoted.add(\"transl_table\");\n    }\n    \n    /**\n     * Implements some GenBank-specific terms.\n     */\n    public static class Terms extends RichSequence.Terms {        \n        /**\n         * Getter for the Genbank term\n         * @return The genbank Term\n         */\n        public static ComparableTerm getGenBankTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"GenBank\");\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A file is in GenBank format if the name ends with gbk, contains the letters egb, or the first line of\n     * the file starts with the word LOCUS\n     */\n    public boolean canRead(File file) throws IOException {\n        if (readableFiles.matcher(file.getName()).matches()) return true;\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        final String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches();\n        br.close();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Returns an dna parser if the letters DNA or RNA appear in the first line of the file.\n     * Otherwise returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(File file) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String firstLine = br.readLine();\n        boolean dna = (firstLine.indexOf(\"DNA\") >0 || firstLine.indexOf(\"RNA\") > 0);\n        br.close();\n        if (dna) return RichSequence.IOTools.getDNAParser();\n        else return RichSequence.IOTools.getProteinParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A stream is in GenBank format if the first line of the stream starts with the word LOCUS\n     */\n    public boolean canRead(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        final String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches();\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Returns an dna parser if the letters DNA or RNA appear in the first line of the stream.\n     * Otherwise returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        String firstLine = br.readLine();\n        boolean dna = (firstLine.indexOf(\"DNA\") >0 || firstLine.indexOf(\"RNA\") > 0);\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        if (dna) return RichSequence.IOTools.getDNAParser();\n        else return RichSequence.IOTools.getProteinParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            SeqIOListener listener)\n            throws IllegalSymbolException, IOException, ParseException {\n        if (!(listener instanceof RichSeqIOListener)) throw new IllegalArgumentException(\"Only accepting RichSeqIOListeners today\");\n        return this.readRichSequence(reader,symParser,(RichSeqIOListener)listener,null);\n    }\n    \n    private String sectionKey = null;\n    private NCBITaxon tax = null;\n    private String organism = null;\n    private String accession = null;\n    private String identifier = null;\n    /**\n     * {@inheritDoc}\n     */\n    public boolean readRichSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            RichSeqIOListener rlistener,\n            Namespace ns)\n            throws IllegalSymbolException, IOException, ParseException {\n        \n        sectionKey = null;\n        tax = null;\n        organism = null;\n        accession = null;\n        identifier = null;\n        boolean hasAnotherSequence = true;\n        //boolean hasInternalWhitespace = false;\n        \n        rlistener.startSequence();\n        \n        if (ns==null) ns=RichObjectFactory.getDefaultNamespace();\n        rlistener.setNamespace(ns);\n        \n        // Get an ordered list of key->value pairs in array-tuples\n        List section = null;\n        try{\n            do {\n                section = this.readSection(reader);\n                sectionKey = ((String[])section.get(0))[0];\n                if(sectionKey == null){\n                    String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Section key was null\", sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // process section-by-section\n                if (sectionKey.equals(LOCUS_TAG)) {\n                    String loc = ((String[])section.get(0))[1];\n                    Matcher m = lp.matcher(loc);\n                    if (m.matches()) {\n                        rlistener.setName(m.group(1));\n                        accession = m.group(1); // default if no accession found\n                        rlistener.setAccession(accession);\n                        if (m.group(4)!=null)\n                            rlistener.addSequenceProperty(Terms.getMolTypeTerm(),m.group(4));\n                        // Optional extras\n                        String stranded = m.group(3);\n                        if(stranded!=null && stranded.equals(\"ss-\"))\n                            stranded = \"single\";\n                        else if(stranded!=null && stranded.equals(\"ms-\"))\n                            stranded = \"mixed\";\n                        else if(stranded!=null && stranded.equals(\"ds-\"))\n                            stranded = \"double\";\n                        String circular = m.group(5);\n                        String fifth = m.group(6);\n                        String sixth = m.group(7);\n                        if (stranded!=null) rlistener.addSequenceProperty(Terms.getStrandedTerm(),stranded);\n                        if (circular!=null && circular.equalsIgnoreCase(\"circular\")) rlistener.setCircular(true);\n                        if (sixth != null) {\n                            rlistener.setDivision(fifth);\n                            rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(),sixth);\n                        } else if (fifth!=null) {\n                            rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(),fifth);\n                        }\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad locus line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else if (sectionKey.equals(DEFINITION_TAG)) {\n                    rlistener.setDescription(((String[])section.get(0))[1]);\n                } else if (sectionKey.equals(ACCESSION_TAG)) {\n                    // if multiple accessions, store only first as accession,\n                    // and store rest in annotation\n                    String[] accs = ((String[])section.get(0))[1].split(\"\\\\s+\");\n                    accession = accs[0].trim();\n                    rlistener.setAccession(accession);\n                    for (int i = 1; i < accs.length; i++) {\n                        rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accs[i].trim());\n                    }\n                } else if (sectionKey.equals(VERSION_TAG)) {\n                    String ver = ((String[])section.get(0))[1];\n                    Matcher m = vp.matcher(ver);\n                    if (m.matches()) {\n                        String verAcc = m.group(1);\n                        if (!accession.equals(verAcc)) {\n                            // the version refers to a different accession!\n                            // believe the version line, and store the original\n                            // accession away in the additional accession set\n                            rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accession);\n                            accession = verAcc;\n                            rlistener.setAccession(accession);\n                        }\n                        if (m.group(3)!=null) rlistener.setVersion(Integer.parseInt(m.group(3)));\n                        if (m.group(5)!=null) {\n                            identifier = m.group(5);\n                            rlistener.setIdentifier(identifier);\n                        }\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad version line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else if (sectionKey.equals(KEYWORDS_TAG)) {\n                    String val = ((String[])section.get(0))[1];\n                    if (val.endsWith(\".\")) val = val.substring(0, val.length()-1); // chomp dot\n                    val = val.replace('\\n',' '); //remove newline\n                    String[] kws = val.split(\";\");\n                    \n                    for (int i = 0; i < kws.length; i++) {\n                        String kw = kws[i].trim();\n                        if (kw.length()==0) continue;\n                        rlistener.addSequenceProperty(Terms.getKeywordTerm(), kw);\n                    }\n                } else if (sectionKey.equals(SOURCE_TAG)) {\n                    // ignore - can get all this from the first feature\n                } else if (sectionKey.equals(REFERENCE_TAG) && !this.getElideReferences()) {\n                    // first line of section has rank and location\n                    int ref_rank;\n                    List baseRangeList=null;\n                    String ref = ((String[])section.get(0))[1];\n                    Matcher m = refp.matcher(ref);\n                    if (m.matches()) {\n                        ref_rank = Integer.parseInt(m.group(1));\n                        if (m.group(3) != null) baseRangeList=buildBaseRanges(m.group(3));\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad reference line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                    // rest can be in any order\n                    String authors = null;\n                    String consortium = null;\n                    String title = null;\n                    String journal = null;\n                    String medline = null;\n                    String pubmed = null;\n                    String remark = null;\n                    for (int i = 1; i < section.size(); i++) {\n                        String key = ((String[])section.get(i))[0];\n                        String val = ((String[])section.get(i))[1];\n                        if (key.equals(AUTHORS_TAG)) authors = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(CONSORTIUM_TAG)) consortium = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(TITLE_TAG)) title = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(JOURNAL_TAG)) journal = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(MEDLINE_TAG)) medline = val;\n                        else if (key.equals(PUBMED_TAG)) pubmed = val;\n                        else if (key.equals(REMARK_TAG)) remark = val.replace('\\n',' '); //see #2276\n                    }\n                    \n                    // create the docref object\n                    try {\n                        // Use consortium as well if present.\n                        if (authors==null) authors = consortium + \" (consortium)\";\n                        else if (consortium!=null) authors = authors + \", \" + consortium + \" (consortium)\";\n                        // Create docref.\n                        DocRef dr = (DocRef)RichObjectFactory.getObject(SimpleDocRef.class,new Object[]{DocRefAuthor.Tools.parseAuthorString(authors),journal,title});\n                        // assign either the pubmed or medline to the docref - medline gets priority\n                        if (medline!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.MEDLINE_KEY, medline, new Integer(0)}));\n                        else if (pubmed!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.PUBMED_KEY, pubmed, new Integer(0)}));\n                        // assign the remarks\n                        if (!this.getElideComments()) dr.setRemark(remark);\n                        // assign the docref to the bioentry: null if no base ranges, Integers if 1 base range - the normal case, joined RichLocation if more than 1\n                        RankedDocRef rdr = baseRangeList == null?new SimpleRankedDocRef(dr, null, null, ref_rank):(baseRangeList.size()==1?new SimpleRankedDocRef(dr, new Integer(((RichLocation)baseRangeList.get(0)).getMin()), new Integer(((RichLocation)baseRangeList.get(0)).getMax()), ref_rank):new SimpleRankedDocRef(dr, new CompoundRichLocation(baseRangeList), ref_rank));\n                        rlistener.setRankedDocRef(rdr);\n                    } catch (ChangeVetoException e) {\n                        throw new ParseException(e+\", accession:\"+accession);\n                    }\n                } else if (sectionKey.equals(COMMENT_TAG) && !this.getElideComments()) {\n                    // Set up some comments\n                    rlistener.setComment(((String[])section.get(0))[1]);\n                } else if (sectionKey.equals(FEATURE_TAG) && !this.getElideFeatures()) {\n                    // starting from second line of input, start a new feature whenever we come across\n                    // a key that does not start with /\n                    boolean seenAFeature = false;\n                    int rcrossrefCount = 0;\n                    boolean skippingBond = false;\n                    for (int i = 1 ; i < section.size(); i++) {\n                        String key = ((String[])section.get(i))[0];\n                        String val = ((String[])section.get(i))[1];\n                        if (key.startsWith(\"/\")) {\n                        \t  if(!skippingBond)\n                        \t  {\n\t                            key = key.substring(1); // strip leading slash\n\t                            val = val.replaceAll(\"\\\\s*[\\\\n\\\\r]+\\\\s*\",\" \").trim();\n\t                            if (val.endsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // strip quotes\n\t                            // parameter on old feature\n\t                            if (key.equals(\"db_xref\")) {\n\t                                Matcher m = dbxp.matcher(val);\n\t                                if (m.matches()) {\n\t                                    String dbname = m.group(1);\n\t                                    String raccession = m.group(2);\n\t                                    if (dbname.equalsIgnoreCase(\"taxon\")) {\n\t                                        // Set the Taxon instead of a dbxref\n\t                                        tax = (NCBITaxon)RichObjectFactory.getObject(SimpleNCBITaxon.class, new Object[]{Integer.valueOf(raccession)});\n\t                                        rlistener.setTaxon(tax);\n\t                                        try {\n\t                                            if (organism!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism.replace('\\n', ' '));// readSection can embed new lines\n\t                                        } catch (ChangeVetoException e) {\n\t                                            throw new ParseException(e+\", accession:\"+accession);\n\t                                        }\n\t                                    } else {\n\t                                        try {\n\t                                            CrossRef cr = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{dbname, raccession, new Integer(0)});\n\t                                            RankedCrossRef rcr = new SimpleRankedCrossRef(cr, ++rcrossrefCount);\n\t                                            rlistener.getCurrentFeature().addRankedCrossRef(rcr);\n\t                                        } catch (ChangeVetoException e) {\n\t                                            throw new ParseException(e+\", accession:\"+accession);\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad dbxref\", sectionToString(section));\n\t                                    throw new ParseException(message);\n\t                                }\n\t                            } else if (key.equalsIgnoreCase(\"organism\")) {\n\t                                try {\n\t                                    organism = val;\n\t                                    if (tax!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism.replace('\\n', ' '));// readSection can embed new lines\n\t                                } catch (ChangeVetoException e) {\n\t                                    throw new ParseException(e+\", accession:\"+accession);\n\t                                }\n\t                            } else {\n\t                                if (key.equalsIgnoreCase(\"translation\")) {\n\t                                    // strip spaces from sequence\n\t                                    val = val.replaceAll(\"\\\\s+\",\"\");\n\t                                }\n\t                                rlistener.addFeatureProperty(RichObjectFactory.getDefaultOntology().getOrCreateTerm(key),val);\n\t                            }\n                          \t}\n                        } else {\n                            // new feature!\n                            // end previous feature\n                            if(key.equalsIgnoreCase(\"bond\"))\n                            {\n                            \tskippingBond = true;\n                            }\n                            else\n                            {\n                            \tskippingBond = false;\n                            \tif (seenAFeature) {\n                            \t\trlistener.endFeature();\n                            \t}\n\t                            // start next one, with lots of lovely info in it\n\t                            RichFeature.Template templ = new RichFeature.Template();\n\t                            templ.annotation = new SimpleRichAnnotation();\n\t                            templ.sourceTerm = Terms.getGenBankTerm();\n\t                            templ.typeTerm = RichObjectFactory.getDefaultOntology().getOrCreateTerm(key);\n\t                            templ.featureRelationshipSet = new TreeSet();\n\t                            templ.rankedCrossRefs = new TreeSet();\n\t                            String tidyLocStr = val.replaceAll(\"\\\\s+\",\"\");\n\t                            templ.location = GenbankLocationParser.parseLocation(ns, accession, tidyLocStr);\n\t                            rlistener.startFeature(templ);\n\t                            seenAFeature = true;\n\t                            rcrossrefCount = 0;\n                            }\n                            \n                        }\n                    }\n                    \n                    if (seenAFeature) {\n                    \trlistener.endFeature();\n                    }\n                } else if (sectionKey.equals(BASE_COUNT_TAG)) {\n                    // ignore - can calculate from sequence content later if needed\n                } else if (sectionKey.equals(START_SEQUENCE_TAG) && !this.getElideSymbols()) {\n                    // our first line is ignorable as it is the ORIGIN tag\n                    // the second line onwards conveniently have the number as\n                    // the [0] tuple, and sequence string as [1] so all we have\n                    // to do is concat the [1] parts and then strip out spaces,\n                    // and replace '.' and '~' with '-' for our parser.\n                    StringBuffer seq = new StringBuffer();\n                    for (int i = 1 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\n                    try {\n                        SymbolList sl = new SimpleSymbolList(symParser,\n                                seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\"));\n                        rlistener.addSymbols(symParser.getAlphabet(),\n                                (Symbol[])(sl.toList().toArray(new Symbol[0])),\n                                0, sl.length());\n                    } catch (IllegalAlphabetException e) {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad sequence section\", sectionToString(section));\n                        throw new ParseException(e, message);\n                    }\n                }\n            } while (!sectionKey.equals(END_SEQUENCE_TAG));\n        }catch(RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad sequence section\", sectionToString(section));\n            throw new ParseException(e, message);\n        }\n        \n        // Allows us to tolerate trailing whitespace without\n        // thinking that there is another Sequence to follow\n        while (true) {\n            reader.mark(1);\n            int c = reader.read();\n            if (c == -1) {\n                hasAnotherSequence = false;\n                break;\n            }\n            if (Character.isWhitespace((char) c)) {\n                //hasInternalWhitespace = true;\n                continue;\n            }\n            //if (hasInternalWhitespace)\n            //    System.err.println(\"Warning: whitespace found between sequence entries\");\n            reader.reset();\n            break;\n        }\n        \n        // Finish up.\n        rlistener.endSequence();\n        return hasAnotherSequence;\n    }\n    \n    // reads an indented section, combining split lines and creating a list of key->value tuples\n    private List readSection(BufferedReader br) throws ParseException {\n        List section = new ArrayList();\n        String line;\n        String currKey = null;\n        StringBuffer currVal = new StringBuffer();\n        boolean done = false;\n        int linecount = 0;\n        \n        try {\n            while (!done) {\n                br.mark(320);\n                line = br.readLine();\n                String firstSecKey = section.size() == 0 ? \"\" : ((String[])section.get(0))[0];\n                if (line==null || line.length()==0 || (!line.startsWith(\" \") && linecount++>0 && ( !firstSecKey.equals(START_SEQUENCE_TAG)  || line.startsWith(END_SEQUENCE_TAG)))) {\n                    // dump out last part of section\n                    section.add(new String[]{currKey,currVal.toString()});\n                    br.reset();\n                    done = true;\n                } else {\n                    Matcher m = sectp.matcher(line);\n                    if (m.matches()) {\n                        // new key\n                        if (currKey!=null) section.add(new String[]{currKey,currVal.toString()});\n                        // key = group(2) or group(4) or group(6) - whichever is not null\n                        currKey = m.group(2)==null?(m.group(4)==null?m.group(6):m.group(4)):m.group(2);\n                        currVal = new StringBuffer();\n                        // val = group(3) if group(2) not null, group(5) if group(4) not null, \"\" otherwise, trimmed\n                        currVal.append((m.group(2)==null?(m.group(4)==null?\"\":m.group(5)):m.group(3)).trim());\n                    } else {\n                        // concatted line or SEQ START/END line?\n                        if (line.startsWith(START_SEQUENCE_TAG) || line.startsWith(END_SEQUENCE_TAG)) currKey = line;\n                        else {\n                            currVal.append(\"\\n\"); // newline in between lines - can be removed later\n                            currVal.append(currKey.charAt(0)=='/'?line.substring(21):line.substring(12));\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"\", sectionToString(section));\n            throw new ParseException(e, message);\n        } catch (RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad section\", sectionToString(section));\n            throw new ParseException(e, message);\n        }\n        return section;\n    }\n    \n    private final List buildBaseRanges(final String theBaseRangeList) throws ParseException {\n        if (theBaseRangeList == null) return null;\n        final List baseRangeList = new ArrayList();\n        final String[] baseRange = theBaseRangeList.split(\";\");\n        try{\n        for (int r=0; r<baseRange.length; r++) {\n            final Matcher rangeMatch = refRange.matcher(baseRange[r]);\n            if (rangeMatch.matches()) {\n                final int rangeStart = Integer.parseInt(rangeMatch.group(1));\n                final int rangeEnd = Integer.parseInt(rangeMatch.group(2));\n                baseRangeList.add(new SimpleRichLocation(new SimplePosition(rangeStart), new SimplePosition(rangeEnd), r));\n            } else {\n                String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad reference range found\", theBaseRangeList);\n                throw new ParseException(message);\n            }\n        }\n        return baseRangeList;\n        }catch(RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad base range\", theBaseRangeList);\n            throw new ParseException(e, message);\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void\twriteSequence(Sequence seq, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void writeSequence(Sequence seq, String format, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        if (!format.equals(this.getDefaultFormat())) throw new IllegalArgumentException(\"Unknown format: \"+format);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Namespace is ignored as Genbank has no concept of it.\n     */\n    public void writeSequence(Sequence seq, Namespace ns) throws IOException {\n        RichSequence rs;\n        try {\n            if (seq instanceof RichSequence) rs = (RichSequence)seq;\n            else rs = RichSequence.Tools.enrich(seq);\n        } catch (ChangeVetoException e) {\n            IOException e2 = new IOException(\"Unable to enrich sequence\");\n            e2.initCause(e);\n            throw e2;\n        }\n        \n        SymbolTokenization tok;\n        try {\n            tok = rs.getAlphabet().getTokenization(\"token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to get alphabet tokenizer\",e);\n        }\n        Set notes = rs.getNoteSet();\n        String accession = rs.getAccession();\n        StringBuffer accessions = new StringBuffer();\n        accessions.append(accession);\n        String stranded = \"\";\n        String udat = \"\";\n        String moltype = rs.getAlphabet().getName();\n        if (\"PROTEIN-TERM\".equals(moltype) || \"PROTEIN\".equals(moltype)) moltype = null; //a genpept curiosity\n        StringBuffer keywords = new StringBuffer();\n        for (Iterator i = notes.iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getStrandedTerm())) {\n                String value = n.getValue();\n                if(value != null && value.equals(\"single\"))\n                    stranded= \"ss-\";\n                else if(value != null && value.equals(\"mixed\"))\n                    stranded= \"ms-\";\n            }\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) moltype=n.getValue();\n            else if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                accessions.append(\" \");\n                accessions.append(n.getValue());\n            } else if (n.getTerm().equals(Terms.getKeywordTerm())) {\n                if (n.getValue() != null) {\n                    if (keywords.length()>0) keywords.append(\"; \");\n                    keywords.append(n.getValue());\n                }\n            }\n        }\n        \n        //adjust molecule type during format conversion\n        if(moltype!=null && moltype.length()>6) {\n            if(moltype.indexOf(\"DNA\")!=-1) moltype = \"DNA\";\n            else if(moltype.indexOf(\"RNA\")!=-1) moltype = \"RNA\";\n            else moltype = \"NA\";\n        }\n        \n        // locus(name) + length + alpha + div + date line\n        StringBuffer locusLine = new StringBuffer();\n        locusLine.append(StringTools.rightPad(rs.getName(),16));//13->28=15+1=16\n        locusLine.append(\" \");//29\n        locusLine.append(StringTools.leftPad(\"\"+rs.length(),11));//30->40=10+1=11\n        locusLine.append(\" \"+ (moltype==null? \"aa\":\"bp\") +\" \");//41->44\n        locusLine.append(StringTools.leftPad(stranded,3));//45->47=2+1=3\n        locusLine.append(StringTools.rightPad(moltype==null?\"\":moltype,6));//48->53=5+1=6\n        locusLine.append(\"  \");//54->55\n        locusLine.append(StringTools.rightPad(rs.getCircular()?\"circular\":\"linear\",8));//56->63=7+1=8\n        locusLine.append(\" \");//64->64\n        locusLine.append(StringTools.rightPad(rs.getDivision()==null?\"\":rs.getDivision(),3));//65->67=2+1=3\n        locusLine.append(\" \");//68->68\n        locusLine.append(StringTools.rightPad(udat,11));//69->79=10+1=11\n        StringTools.writeKeyValueLine(LOCUS_TAG, locusLine.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // definition line\n        StringTools.writeKeyValueLine(DEFINITION_TAG, rs.getDescription(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // accession line\n        StringTools.writeKeyValueLine(ACCESSION_TAG, accessions.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // version + gi line\n        String version = accession+\".\"+rs.getVersion();\n        if (rs.getIdentifier()!=null) version = version + \"  GI:\"+rs.getIdentifier();\n        StringTools.writeKeyValueLine(VERSION_TAG, version, 12, this.getLineWidth(), this.getPrintStream());\n        \n        // keywords line\n        keywords.append(\".\");\n        StringTools.writeKeyValueLine(KEYWORDS_TAG, keywords.toString(), 12, this.getLineWidth()-1, this.getPrintStream());\n        \n        // source line (from taxon)\n        //   organism line\n        NCBITaxon tax = rs.getTaxon();\n        if (tax!=null) {\n            StringTools.writeKeyValueLine(SOURCE_TAG, (isMitochondrial(rs)?\"mitochondrion \":\"\")+tax.getDisplayName(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+ORGANISM_TAG, tax.getDisplayName().split(\"\\\\s+\\\\(\")[0]+\"\\n\"+tax.getNameHierarchy(), 12, this.getLineWidth()-1, this.getPrintStream());\n        }\n        \n        // references - rank (bases x to y)\n        for (Iterator r = rs.getRankedDocRefs().iterator(); r.hasNext(); ) {\n            RankedDocRef rdr = (RankedDocRef)r.next();\n            DocRef d = rdr.getDocumentReference();\n            StringTools.writeKeyValueLine(REFERENCE_TAG, rdr.getRank()+((rdr.getLocation()==null || rdr.getLocation() ==RichLocation.EMPTY_LOCATION)?\"\": (moltype==null? \"  (residues \":\"  (bases \")+makeBaseRange(rdr)+\")\"), 12, this.getLineWidth(), this.getPrintStream());\n            // Any authors that were in the input as CONSRTM tags will\n            // be merged into the AUTHORS tag on output.\n            StringTools.writeKeyValueLine(\"  \"+AUTHORS_TAG, d.getAuthors(), 12, this.getLineWidth()-1, this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+TITLE_TAG, d.getTitle(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+JOURNAL_TAG, d.getLocation(), 12, this.getLineWidth(), this.getPrintStream());\n            CrossRef c = d.getCrossref();\n            if (c!=null) StringTools.writeKeyValueLine(StringTools.leftPad(c.getDbname(),9), c.getAccession(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+REMARK_TAG, d.getRemark(), 12, this.getLineWidth(), this.getPrintStream());\n        }\n        \n        // comments - if any\n        if (!rs.getComments().isEmpty()) {\n            Set comments = rs.getComments();\n            StringBuffer sb = new StringBuffer();\n            for (Iterator i = comments.iterator(); i.hasNext(); ) {\n                Comment c = (SimpleComment)i.next();\n                sb.append(c.getComment());\n                if (i.hasNext()) sb.append(\"\\n\");\n            }\n            StringTools.writeKeyValueLine(COMMENT_TAG, sb.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        }\n        \n        this.getPrintStream().println(FEATURE_TAG+\"             Location/Qualifiers\");\n        // feature_type     location\n        for (Iterator i = rs.getFeatureSet().iterator(); i.hasNext(); ) {\n            RichFeature f = (RichFeature)i.next();\n            StringTools.writeKeyValueLine(\"     \"+f.getTypeTerm().getName(), GenbankLocationParser.writeLocation((RichLocation)f.getLocation()), 21, this.getLineWidth()-1, \",\", this.getPrintStream());\n            for (Iterator j = f.getNoteSet().iterator(); j.hasNext(); ) {\n                Note n = (Note)j.next();\n                // /key=\"val\" or just /key if val==\"\"\n                if (n.getValue()==null || n.getValue().length()==0) StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName(), 21, this.getLineWidth(), this.getPrintStream());\n                else if (isNotQuoted(n)) {// doesn't have the value enclosed in quotes\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\"+n.getValue(), 21, this.getLineWidth(), this.getPrintStream());\n                } else if (n.getTerm().getName().equals(\"translation\")) {\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth()-1, this.getPrintStream());\n                } else {\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n            }\n            // add-in to source feature only organism and db_xref=\"taxon:xyz\" where present\n            if (f.getType().equals(\"source\") && tax!=null) {\n                String displayName = tax.getDisplayName();\n                if (displayName.indexOf('(')>-1) displayName = displayName.substring(0, displayName.indexOf('(')).trim();\n                StringTools.writeKeyValueLine(\"\", \"/organism=\\\"\"+displayName+\"\\\"\", 21, this.getLineWidth()-1, this.getPrintStream());// AF252370 fits in exactly 80 - but is wrapped\n                for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                    RankedCrossRef rcr = (RankedCrossRef)j.next();\n                    CrossRef cr = rcr.getCrossRef();\n                    StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n                StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"taxon:\"+tax.getNCBITaxID()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n            } else {\n                // add-in other dbxrefs where present\n                for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                    RankedCrossRef rcr = (RankedCrossRef)j.next();\n                    CrossRef cr = rcr.getCrossRef();\n                    StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n            }\n        }\n        \n        //BASE COUNT obsolete in Genbank flatfile format since October 2003\n        //if (rs.getAlphabet()==AlphabetManager.alphabetForName(\"DNA\")) {\n        //    // BASE COUNT     1510 a   1074 c    835 g   1609 t\n        //    int aCount = 0;\n        //    int cCount = 0;\n        //    int gCount = 0;\n        //    int tCount = 0;\n        //    int oCount = 0;\n        //    for (int i = 1; i <= rs.length(); i++) {\n        //        char c;\n        //        try {\n        //            c = tok.tokenizeSymbol(rs.symbolAt(i)).charAt(0);\n        //        } catch (Exception e) {\n        //            throw new RuntimeException(\"Unable to get symbol at position \"+i,e);\n        //        }\n        //        switch (c) {\n        //            case 'a': case 'A':\n        //                aCount++;\n        //                break;\n        //            case 'c': case 'C':\n        //                cCount++;\n        //                break;\n        //            case 'g': case 'G':\n        //                gCount++;\n        //                break;\n        //            case 't': case 'T':\n        //                tCount++;\n        //                break;\n        //            default:\n        //                oCount++;\n        //        }\n        //    }\n        //\n        //    this.getPrintStream().print(BASE_COUNT_TAG_FULL+\"    \");\n        //    this.getPrintStream().print(aCount + \" a   \");\n        //    this.getPrintStream().print(cCount + \" c   \");\n        //    this.getPrintStream().print(gCount + \" g   \");\n        //    this.getPrintStream().print(tCount + \" t    \");\n        //    this.getPrintStream().println(oCount + \" others\");\n        //}\n        \n        this.getPrintStream().println(START_SEQUENCE_TAG);\n        // sequence stuff\n        Symbol[] syms = (Symbol[])rs.toList().toArray(new Symbol[0]);\n        int lines = 0;\n        int symCount = 0;\n        for (int i = 0; i < syms.length; i++) {\n            if (symCount % 60 == 0) {\n                if (lines > 0) this.getPrintStream().print(\"\\n\"); // newline from previous line\n                int lineNum = (lines*60) + 1;\n                this.getPrintStream().print(StringTools.leftPad(\"\"+lineNum,9));\n                lines++;\n            }\n            if (symCount % 10 == 0) this.getPrintStream().print(\" \");\n            try {\n                this.getPrintStream().print(tok.tokenizeSymbol(syms[i]));\n            } catch (IllegalSymbolException e) {\n                throw new RuntimeException(\"Found illegal symbol: \"+syms[i]);\n            }\n            symCount++;\n        }\n        if(syms.length>0) //do not create an empty line\n            this.getPrintStream().print(\"\\n\");\n        this.getPrintStream().println(END_SEQUENCE_TAG);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultFormat() {\n        return GENBANK_FORMAT;\n    }\n    \n    private final static boolean isMitochondrial(final RichSequence theSequence) {\n        final Set featureSet = theSequence.getFeatureSet();\n        final Iterator i = featureSet.iterator();\n        while (i.hasNext()) {\n            final RichFeature feature = (RichFeature) i.next();\n            if (feature.getType().equals(\"source\")) {\n                final Set noteSet = feature.getNoteSet();\n                final Iterator n = noteSet.iterator();\n                while(n.hasNext()) {\n                    final Note note = (Note) n.next();\n                    if (note.getTerm().getName().equals(\"organelle\")) return note.getValue().equals(\"mitochondrion\");\n                }\n            }\n        }\n        return false;\n    }\n    \n    private final static boolean isNotQuoted(final Note theNote) {\n        return isNotQuoted(theNote.getTerm().getName(), theNote.getValue());\n    }\n    \n    private final static boolean isNotQuoted(final String theName, final String theValue) {\n        return isNotQuoted.contains(theName);\n    }\n    \n    private final static String makeBaseRange(final RankedDocRef theReference) {\n        return theReference.getLocation()==null?theReference.getStart()+\" to \"+theReference.getEnd():toString(theReference.getLocation());\n    }\n    \n    private final static String toString(final RichLocation theLocation) {\n        final StringBuffer list = new StringBuffer();\n        final Iterator b = theLocation.blockIterator();\n        while (b.hasNext()) {\n            final RichLocation location = (RichLocation) b.next();\n            list.append(location.getMin()+\" to \"+location.getMax());\n            if (b.hasNext()) list.append(\"; \");\n        }\n        return list.toString();\n    }\n    \n    /**\n     * Converts the current parse section to a String. Useful for debugging.\n     */\n    String sectionToString(List section){\n        StringBuffer parseBlock = new StringBuffer();\n        for(Iterator i = section.listIterator(); i.hasNext();){\n            String[] part = (String[])i.next();\n            for(int x = 0; x < part.length; x++){\n                parseBlock.append(part[x]);\n                if(x == 0){\n                    parseBlock.append(\"   \"); //the gap will have been trimmed\n                }\n            }\n        }\n        return parseBlock.toString();\n    }\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage\torg.biojavax.bio.seq.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojava.bio.seq.io.SeqIOListener;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.IllegalAlphabetException;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojavax.Comment;\nimport org.biojavax.CrossRef;\nimport org.biojavax.DocRef;\nimport org.biojavax.DocRefAuthor;\nimport org.biojavax.Namespace;\nimport org.biojavax.Note;\nimport org.biojavax.RankedCrossRef;\nimport org.biojavax.RankedDocRef;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.SimpleComment;\nimport org.biojavax.SimpleCrossRef;\nimport org.biojavax.SimpleDocRef;\nimport org.biojavax.SimpleRankedCrossRef;\nimport org.biojavax.SimpleRankedDocRef;\nimport org.biojavax.SimpleRichAnnotation;\nimport org.biojavax.bio.seq.CompoundRichLocation;\nimport org.biojavax.bio.seq.RichFeature;\nimport org.biojavax.bio.seq.RichLocation;\nimport org.biojavax.bio.seq.RichSequence;\nimport org.biojavax.bio.seq.SimplePosition;\nimport org.biojavax.bio.seq.SimpleRichLocation;\nimport org.biojavax.bio.taxa.NCBITaxon;\nimport org.biojavax.bio.taxa.SimpleNCBITaxon;\nimport org.biojavax.ontology.ComparableTerm;\nimport org.biojavax.utils.StringTools;\n\n/**\n * Format reader for GenBank files. This version of Genbank format will generate\n * and write RichSequence objects. Loosely Based on code from the old, deprecated,\n * org.biojava.bio.seq.io.GenbankFormat object.\n *\n * @author Richard Holland\n * @author Mark Schreiber\n * @author David Scott\n * @author Bubba Puryear\n * @author George Waldon\n * @since 1.5\n */\npublic class GenbankFormat extends RichSequenceFormat.HeaderlessFormat {\n    \n    // Register this format with the format auto-guesser.\n    static {\n        RichSequence.IOTools.registerFormat(GenbankFormat.class);\n    }\n    \n    /**\n     * The name of this format\n     */\n    public static final String GENBANK_FORMAT = \"GENBANK\";\n    \n    protected static final String LOCUS_TAG =           \"LOCUS\";\n    protected static final String DEFINITION_TAG =      \"DEFINITION\";\n    protected static final String ACCESSION_TAG =       \"ACCESSION\";\n    protected static final String VERSION_TAG =         \"VERSION\";\n    protected static final String KEYWORDS_TAG =        \"KEYWORDS\";\n    //                                                  \"SEGMENT\"\n    protected static final String SOURCE_TAG =          \"SOURCE\";\n    protected static final String ORGANISM_TAG =        \"ORGANISM\";\n    protected static final String REFERENCE_TAG =       \"REFERENCE\";\n    protected static final String AUTHORS_TAG =         \"AUTHORS\";\n    protected static final String CONSORTIUM_TAG =      \"CONSRTM\";\n    protected static final String TITLE_TAG =           \"TITLE\";\n    protected static final String JOURNAL_TAG =         \"JOURNAL\";\n    protected static final String PUBMED_TAG =          \"PUBMED\";\n    protected static final String MEDLINE_TAG =         \"MEDLINE\"; //deprecated\n    protected static final String REMARK_TAG =          \"REMARK\";\n    protected static final String COMMENT_TAG =         \"COMMENT\";\n    protected static final String FEATURE_TAG =         \"FEATURES\";\n    protected static final String BASE_COUNT_TAG_FULL = \"BASE COUNT\"; //deprecated\n    protected static final String BASE_COUNT_TAG =      \"BASE\";\n    //                                                  \"CONTIG\"\n    protected static final String START_SEQUENCE_TAG =  \"ORIGIN\";\n    protected static final String END_SEQUENCE_TAG =    \"//\";\n    \n    // locus line\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+)\\\\s+\\\\d+\\\\s+(bp|aa)\\\\s{1,4}([dms]s-)?(\\\\S+)?\\\\s+(circular|linear)?\\\\s*(\\\\S+)?\\\\s*(\\\\S+)?$\");\n    // version line\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S*?)(\\\\.(\\\\d+))?(\\\\s+GI:(\\\\S+))?$\");\n    // reference line\n    protected static final Pattern refRange = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+to\\\\s+(\\\\d+)$\");\n    protected static final Pattern refp = Pattern.compile(\"^(\\\\d+)\\\\s*(?:(\\\\((?:bases|residues)\\\\s+(\\\\d+\\\\s+to\\\\s+\\\\d+(\\\\s*;\\\\s*\\\\d+\\\\s+to\\\\s+\\\\d+)*)\\\\))|\\\\(sites\\\\))?\");\n    // dbxref line\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\n    //sections start at a line and continue till the first line afterwards with a\n    //non-whitespace first character\n    //we want to match any of the following as a new section within a section\n    //  \\s{0,8} word \\s{1,7} value\n    //  \\s{21} /word = value\n    //  \\s{21} /word\n    protected static final Pattern sectp = Pattern.compile(\"^(\\\\s{0,8}(\\\\S+)\\\\s{1,7}(.*)|\\\\s{21}(/\\\\S+?)=(.*)|\\\\s{21}(/\\\\S+))$\");\n    \n    protected static final Pattern readableFiles = Pattern.compile(\".*(g[bp]k*$|\\\\u002eg[bp].*)\");\n    protected static final Pattern headerLine = Pattern.compile(\"^LOCUS.*\");\n    \n    private final static HashSet isNotQuoted = new HashSet();\n    static {\n        isNotQuoted.add(\"anticodon\");\n        isNotQuoted.add(\"citation\");\n        isNotQuoted.add(\"codon\");\n        isNotQuoted.add(\"codon_start\");\n        isNotQuoted.add(\"compare\");\n        isNotQuoted.add(\"cons_splice\");\n        isNotQuoted.add(\"direction\");\n        isNotQuoted.add(\"estimated_length\");\n        isNotQuoted.add(\"label\");\n        isNotQuoted.add(\"mod_base\");\n        isNotQuoted.add(\"number\");\n        isNotQuoted.add(\"rpt_type\");\n        isNotQuoted.add(\"rpt_unit_range\");\n        isNotQuoted.add(\"transl_except\");\n        isNotQuoted.add(\"transl_table\");\n    }\n    \n    /**\n     * Implements some GenBank-specific terms.\n     */\n    public static class Terms extends RichSequence.Terms {        \n        /**\n         * Getter for the Genbank term\n         * @return The genbank Term\n         */\n        public static ComparableTerm getGenBankTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"GenBank\");\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A file is in GenBank format if the name ends with gbk, contains the letters egb, or the first line of\n     * the file starts with the word LOCUS\n     */\n    public boolean canRead(File file) throws IOException {\n        if (readableFiles.matcher(file.getName()).matches()) return true;\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        final String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches();\n        br.close();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Returns an dna parser if the letters DNA or RNA appear in the first line of the file.\n     * Otherwise returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(File file) throws IOException {\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String firstLine = br.readLine();\n        boolean dna = (firstLine.indexOf(\"DNA\") >0 || firstLine.indexOf(\"RNA\") > 0);\n        br.close();\n        if (dna) return RichSequence.IOTools.getDNAParser();\n        else return RichSequence.IOTools.getProteinParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A stream is in GenBank format if the first line of the stream starts with the word LOCUS\n     */\n    public boolean canRead(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        final String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches();\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Returns an dna parser if the letters DNA or RNA appear in the first line of the stream.\n     * Otherwise returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        String firstLine = br.readLine();\n        boolean dna = (firstLine.indexOf(\"DNA\") >0 || firstLine.indexOf(\"RNA\") > 0);\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        if (dna) return RichSequence.IOTools.getDNAParser();\n        else return RichSequence.IOTools.getProteinParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            SeqIOListener listener)\n            throws IllegalSymbolException, IOException, ParseException {\n        if (!(listener instanceof RichSeqIOListener)) throw new IllegalArgumentException(\"Only accepting RichSeqIOListeners today\");\n        return this.readRichSequence(reader,symParser,(RichSeqIOListener)listener,null);\n    }\n    \n    private String sectionKey = null;\n    private NCBITaxon tax = null;\n    private String organism = null;\n    private String accession = null;\n    private String identifier = null;\n    /**\n     * {@inheritDoc}\n     */\n    public boolean readRichSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            RichSeqIOListener rlistener,\n            Namespace ns)\n            throws IllegalSymbolException, IOException, ParseException {\n        \n        sectionKey = null;\n        tax = null;\n        organism = null;\n        accession = null;\n        identifier = null;\n        boolean hasAnotherSequence = true;\n        //boolean hasInternalWhitespace = false;\n        \n        rlistener.startSequence();\n        \n        if (ns==null) ns=RichObjectFactory.getDefaultNamespace();\n        rlistener.setNamespace(ns);\n        \n        // Get an ordered list of key->value pairs in array-tuples\n        List section = null;\n        try{\n            do {\n                section = this.readSection(reader);\n                sectionKey = ((String[])section.get(0))[0];\n                if(sectionKey == null){\n                    String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Section key was null\", sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // process section-by-section\n                if (sectionKey.equals(LOCUS_TAG)) {\n                    String loc = ((String[])section.get(0))[1];\n                    Matcher m = lp.matcher(loc);\n                    if (m.matches()) {\n                        rlistener.setName(m.group(1));\n                        accession = m.group(1); // default if no accession found\n                        rlistener.setAccession(accession);\n                        if (m.group(4)!=null)\n                            rlistener.addSequenceProperty(Terms.getMolTypeTerm(),m.group(4));\n                        // Optional extras\n                        String stranded = m.group(3);\n                        if(stranded!=null && stranded.equals(\"ss-\"))\n                            stranded = \"single\";\n                        else if(stranded!=null && stranded.equals(\"ms-\"))\n                            stranded = \"mixed\";\n                        else if(stranded!=null && stranded.equals(\"ds-\"))\n                            stranded = \"double\";\n                        String circular = m.group(5);\n                        String fifth = m.group(6);\n                        String sixth = m.group(7);\n                        if (stranded!=null) rlistener.addSequenceProperty(Terms.getStrandedTerm(),stranded);\n                        if (circular!=null && circular.equalsIgnoreCase(\"circular\")) rlistener.setCircular(true);\n                        if (sixth != null) {\n                            rlistener.setDivision(fifth);\n                            rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(),sixth);\n                        } else if (fifth!=null) {\n                            rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(),fifth);\n                        }\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad locus line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else if (sectionKey.equals(DEFINITION_TAG)) {\n                    rlistener.setDescription(((String[])section.get(0))[1]);\n                } else if (sectionKey.equals(ACCESSION_TAG)) {\n                    // if multiple accessions, store only first as accession,\n                    // and store rest in annotation\n                    String[] accs = ((String[])section.get(0))[1].split(\"\\\\s+\");\n                    accession = accs[0].trim();\n                    rlistener.setAccession(accession);\n                    for (int i = 1; i < accs.length; i++) {\n                        rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accs[i].trim());\n                    }\n                } else if (sectionKey.equals(VERSION_TAG)) {\n                    String ver = ((String[])section.get(0))[1];\n                    Matcher m = vp.matcher(ver);\n                    if (m.matches()) {\n                        String verAcc = m.group(1);\n                        if (!accession.equals(verAcc)) {\n                            // the version refers to a different accession!\n                            // believe the version line, and store the original\n                            // accession away in the additional accession set\n                            rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accession);\n                            accession = verAcc;\n                            rlistener.setAccession(accession);\n                        }\n                        if (m.group(3)!=null) rlistener.setVersion(Integer.parseInt(m.group(3)));\n                        if (m.group(5)!=null) {\n                            identifier = m.group(5);\n                            rlistener.setIdentifier(identifier);\n                        }\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad version line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else if (sectionKey.equals(KEYWORDS_TAG)) {\n                    String val = ((String[])section.get(0))[1];\n                    if (val.endsWith(\".\")) val = val.substring(0, val.length()-1); // chomp dot\n                    val = val.replace('\\n',' '); //remove newline\n                    String[] kws = val.split(\";\");\n                    \n                    for (int i = 0; i < kws.length; i++) {\n                        String kw = kws[i].trim();\n                        if (kw.length()==0) continue;\n                        rlistener.addSequenceProperty(Terms.getKeywordTerm(), kw);\n                    }\n                } else if (sectionKey.equals(SOURCE_TAG)) {\n                    // ignore - can get all this from the first feature\n                } else if (sectionKey.equals(REFERENCE_TAG) && !this.getElideReferences()) {\n                    // first line of section has rank and location\n                    int ref_rank;\n                    List baseRangeList=null;\n                    String ref = ((String[])section.get(0))[1];\n                    Matcher m = refp.matcher(ref);\n                    if (m.matches()) {\n                        ref_rank = Integer.parseInt(m.group(1));\n                        if (m.group(3) != null) baseRangeList=buildBaseRanges(m.group(3));\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad reference line\", sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                    // rest can be in any order\n                    String authors = null;\n                    String consortium = null;\n                    String title = null;\n                    String journal = null;\n                    String medline = null;\n                    String pubmed = null;\n                    String remark = null;\n                    for (int i = 1; i < section.size(); i++) {\n                        String key = ((String[])section.get(i))[0];\n                        String val = ((String[])section.get(i))[1];\n                        if (key.equals(AUTHORS_TAG)) authors = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(CONSORTIUM_TAG)) consortium = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(TITLE_TAG)) title = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(JOURNAL_TAG)) journal = val.replace('\\n',' '); //see #2276\n                        else if (key.equals(MEDLINE_TAG)) medline = val;\n                        else if (key.equals(PUBMED_TAG)) pubmed = val;\n                        else if (key.equals(REMARK_TAG)) remark = val.replace('\\n',' '); //see #2276\n                    }\n                    \n                    // create the docref object\n                    try {\n                        // Use consortium as well if present.\n                        if (authors==null) authors = consortium + \" (consortium)\";\n                        else if (consortium!=null) authors = authors + \", \" + consortium + \" (consortium)\";\n                        // Create docref.\n                        DocRef dr = (DocRef)RichObjectFactory.getObject(SimpleDocRef.class,new Object[]{DocRefAuthor.Tools.parseAuthorString(authors),journal,title});\n                        // assign either the pubmed or medline to the docref - medline gets priority\n                        if (medline!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.MEDLINE_KEY, medline, new Integer(0)}));\n                        else if (pubmed!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.PUBMED_KEY, pubmed, new Integer(0)}));\n                        // assign the remarks\n                        if (!this.getElideComments()) dr.setRemark(remark);\n                        // assign the docref to the bioentry: null if no base ranges, Integers if 1 base range - the normal case, joined RichLocation if more than 1\n                        RankedDocRef rdr = baseRangeList == null?new SimpleRankedDocRef(dr, null, null, ref_rank):(baseRangeList.size()==1?new SimpleRankedDocRef(dr, new Integer(((RichLocation)baseRangeList.get(0)).getMin()), new Integer(((RichLocation)baseRangeList.get(0)).getMax()), ref_rank):new SimpleRankedDocRef(dr, new CompoundRichLocation(baseRangeList), ref_rank));\n                        rlistener.setRankedDocRef(rdr);\n                    } catch (ChangeVetoException e) {\n                        throw new ParseException(e+\", accession:\"+accession);\n                    }\n                } else if (sectionKey.equals(COMMENT_TAG) && !this.getElideComments()) {\n                    // Set up some comments\n                    rlistener.setComment(((String[])section.get(0))[1]);\n                } else if (sectionKey.equals(FEATURE_TAG) && !this.getElideFeatures()) {\n                    // starting from second line of input, start a new feature whenever we come across\n                    // a key that does not start with /\n                    boolean seenAFeature = false;\n                    int rcrossrefCount = 0;\n                    boolean skippingBond = false;\n                    for (int i = 1 ; i < section.size(); i++) {\n                        String key = ((String[])section.get(i))[0];\n                        String val = ((String[])section.get(i))[1];\n                        if (key.startsWith(\"/\")) {\n                        \t  if(!skippingBond)\n                        \t  {\n\t                            key = key.substring(1); // strip leading slash\n\t                            val = val.replaceAll(\"\\\\s*[\\\\n\\\\r]+\\\\s*\",\" \").trim();\n\t                            if (val.endsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // strip quotes\n\t                            // parameter on old feature\n\t                            if (key.equals(\"db_xref\")) {\n\t                                Matcher m = dbxp.matcher(val);\n\t                                if (m.matches()) {\n\t                                    String dbname = m.group(1);\n\t                                    String raccession = m.group(2);\n\t                                    if (dbname.equalsIgnoreCase(\"taxon\")) {\n\t                                        // Set the Taxon instead of a dbxref\n\t                                        tax = (NCBITaxon)RichObjectFactory.getObject(SimpleNCBITaxon.class, new Object[]{Integer.valueOf(raccession)});\n\t                                        rlistener.setTaxon(tax);\n\t                                        try {\n\t                                            if (organism!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism.replace('\\n', ' '));// readSection can embed new lines\n\t                                        } catch (ChangeVetoException e) {\n\t                                            throw new ParseException(e+\", accession:\"+accession);\n\t                                        }\n\t                                    } else {\n\t                                        try {\n\t                                            CrossRef cr = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{dbname, raccession, new Integer(0)});\n\t                                            RankedCrossRef rcr = new SimpleRankedCrossRef(cr, ++rcrossrefCount);\n\t                                            rlistener.getCurrentFeature().addRankedCrossRef(rcr);\n\t                                        } catch (ChangeVetoException e) {\n\t                                            throw new ParseException(e+\", accession:\"+accession);\n\t                                        }\n\t                                    }\n\t                                } else {\n\t                                    String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad dbxref\", sectionToString(section));\n\t                                    throw new ParseException(message);\n\t                                }\n\t                            } else if (key.equalsIgnoreCase(\"organism\")) {\n\t                                try {\n\t                                    organism = val;\n\t                                    if (tax!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism.replace('\\n', ' '));// readSection can embed new lines\n\t                                } catch (ChangeVetoException e) {\n\t                                    throw new ParseException(e+\", accession:\"+accession);\n\t                                }\n\t                            } else {\n\t                                if (key.equalsIgnoreCase(\"translation\")) {\n\t                                    // strip spaces from sequence\n\t                                    val = val.replaceAll(\"\\\\s+\",\"\");\n\t                                }\n\t                                rlistener.addFeatureProperty(RichObjectFactory.getDefaultOntology().getOrCreateTerm(key),val);\n\t                            }\n                          \t}\n                        } else {\n                            // new feature!\n                            // end previous feature\n                            if(key.equalsIgnoreCase(\"bond\"))\n                            {\n                            \tskippingBond = true;\n                            }\n                            else\n                            {\n                            \tskippingBond = false;\n                            \tif (seenAFeature) {\n                            \t\trlistener.endFeature();\n                            \t}\n\t                            // start next one, with lots of lovely info in it\n\t                            RichFeature.Template templ = new RichFeature.Template();\n\t                            templ.annotation = new SimpleRichAnnotation();\n\t                            templ.sourceTerm = Terms.getGenBankTerm();\n\t                            templ.typeTerm = RichObjectFactory.getDefaultOntology().getOrCreateTerm(key);\n\t                            templ.featureRelationshipSet = new TreeSet();\n\t                            templ.rankedCrossRefs = new TreeSet();\n\t                            String tidyLocStr = val.replaceAll(\"\\\\s+\",\"\");\n\t                            templ.location = GenbankLocationParser.parseLocation(ns, accession, tidyLocStr);\n\t                            rlistener.startFeature(templ);\n\t                            seenAFeature = true;\n\t                            rcrossrefCount = 0;\n                            }\n                            \n                        }\n                    }\n                    \n                    if (seenAFeature) {\n                    \trlistener.endFeature();\n                    }\n                } else if (sectionKey.equals(BASE_COUNT_TAG)) {\n                    // ignore - can calculate from sequence content later if needed\n                } else if (sectionKey.equals(START_SEQUENCE_TAG) && !this.getElideSymbols()) {\n                    // our first line is ignorable as it is the ORIGIN tag\n                    // the second line onwards conveniently have the number as\n                    // the [0] tuple, and sequence string as [1] so all we have\n                    // to do is concat the [1] parts and then strip out spaces,\n                    // and replace '.' and '~' with '-' for our parser.\n                    StringBuffer seq = new StringBuffer();\n                    for (int i = 1 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\n                    try {\n                        SymbolList sl = new SimpleSymbolList(symParser,\n                                seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\"));\n                        rlistener.addSymbols(symParser.getAlphabet(),\n                                (Symbol[])(sl.toList().toArray(new Symbol[0])),\n                                0, sl.length());\n                    } catch (IllegalAlphabetException e) {\n                        String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad sequence section\", sectionToString(section));\n                        throw new ParseException(e, message);\n                    }\n                }\n            } while (!sectionKey.equals(END_SEQUENCE_TAG));\n        }catch(RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad sequence section\", sectionToString(section));\n            throw new ParseException(e, message);\n        }\n        \n        // Allows us to tolerate trailing whitespace without\n        // thinking that there is another Sequence to follow\n        while (true) {\n            reader.mark(1);\n            int c = reader.read();\n            if (c == -1) {\n                hasAnotherSequence = false;\n                break;\n            }\n            if (Character.isWhitespace((char) c)) {\n                //hasInternalWhitespace = true;\n                continue;\n            }\n            //if (hasInternalWhitespace)\n            //    System.err.println(\"Warning: whitespace found between sequence entries\");\n            reader.reset();\n            break;\n        }\n        \n        // Finish up.\n        rlistener.endSequence();\n        return hasAnotherSequence;\n    }\n    \n    // reads an indented section, combining split lines and creating a list of key->value tuples\n    private List readSection(BufferedReader br) throws ParseException {\n        List section = new ArrayList();\n        String line;\n        String currKey = null;\n        StringBuffer currVal = new StringBuffer();\n        boolean done = false;\n        int linecount = 0;\n        \n        try {\n            while (!done) {\n                br.mark(320);\n                line = br.readLine();\n                String firstSecKey = section.size() == 0 ? \"\" : ((String[])section.get(0))[0];\n                if (line==null || line.length()==0 || (!line.startsWith(\" \") && linecount++>0 && ( !firstSecKey.equals(START_SEQUENCE_TAG)  || line.startsWith(END_SEQUENCE_TAG)))) {\n                    // dump out last part of section\n                    section.add(new String[]{currKey,currVal.toString()});\n                    br.reset();\n                    done = true;\n                } else {\n                    Matcher m = sectp.matcher(line);\n                    if (m.matches()) {\n                        // new key\n                        if (currKey!=null) section.add(new String[]{currKey,currVal.toString()});\n                        // key = group(2) or group(4) or group(6) - whichever is not null\n                        currKey = m.group(2)==null?(m.group(4)==null?m.group(6):m.group(4)):m.group(2);\n                        currVal = new StringBuffer();\n                        // val = group(3) if group(2) not null, group(5) if group(4) not null, \"\" otherwise, trimmed\n                        currVal.append((m.group(2)==null?(m.group(4)==null?\"\":m.group(5)):m.group(3)).trim());\n                    } else {\n                        // concatted line or SEQ START/END line?\n                        if (line.startsWith(START_SEQUENCE_TAG) || line.startsWith(END_SEQUENCE_TAG)) currKey = line;\n                        else {\n                            currVal.append(\"\\n\"); // newline in between lines - can be removed later\n                            currVal.append(currKey.charAt(0)=='/'?line.substring(21):line.substring(12));\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"\", sectionToString(section));\n            throw new ParseException(e, message);\n        } catch (RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad section\", sectionToString(section));\n            throw new ParseException(e, message);\n        }\n        return section;\n    }\n    \n    private final List buildBaseRanges(final String theBaseRangeList) throws ParseException {\n        if (theBaseRangeList == null) return null;\n        final List baseRangeList = new ArrayList();\n        final String[] baseRange = theBaseRangeList.split(\";\");\n        try{\n        for (int r=0; r<baseRange.length; r++) {\n            final Matcher rangeMatch = refRange.matcher(baseRange[r]);\n            if (rangeMatch.matches()) {\n                final int rangeStart = Integer.parseInt(rangeMatch.group(1));\n                final int rangeEnd = Integer.parseInt(rangeMatch.group(2));\n                baseRangeList.add(new SimpleRichLocation(new SimplePosition(rangeStart), new SimplePosition(rangeEnd), r));\n            } else {\n                String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad reference range found\", theBaseRangeList);\n                throw new ParseException(message);\n            }\n        }\n        return baseRangeList;\n        }catch(RuntimeException e){\n            String message = ParseException.newMessage(this.getClass(), accession, identifier, \"Bad base range\", theBaseRangeList);\n            throw new ParseException(e, message);\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void\twriteSequence(Sequence seq, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void writeSequence(Sequence seq, String format, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        if (!format.equals(this.getDefaultFormat())) throw new IllegalArgumentException(\"Unknown format: \"+format);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Namespace is ignored as Genbank has no concept of it.\n     */\n    public void writeSequence(Sequence seq, Namespace ns) throws IOException {\n        RichSequence rs;\n        try {\n            if (seq instanceof RichSequence) rs = (RichSequence)seq;\n            else rs = RichSequence.Tools.enrich(seq);\n        } catch (ChangeVetoException e) {\n            IOException e2 = new IOException(\"Unable to enrich sequence\");\n            e2.initCause(e);\n            throw e2;\n        }\n        \n        SymbolTokenization tok;\n        try {\n            tok = rs.getAlphabet().getTokenization(\"token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to get alphabet tokenizer\",e);\n        }\n        Set notes = rs.getNoteSet();\n        String accession = rs.getAccession();\n        StringBuffer accessions = new StringBuffer();\n        accessions.append(accession);\n        String stranded = \"\";\n        String udat = \"\";\n        String moltype = rs.getAlphabet().getName();\n        if (\"PROTEIN-TERM\".equals(moltype) || \"PROTEIN\".equals(moltype)) moltype = null; //a genpept curiosity\n        StringBuffer keywords = new StringBuffer();\n        for (Iterator i = notes.iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getStrandedTerm())) {\n                String value = n.getValue();\n                if(value != null && value.equals(\"single\"))\n                    stranded= \"ss-\";\n                else if(value != null && value.equals(\"mixed\"))\n                    stranded= \"ms-\";\n            }\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) moltype=n.getValue();\n            else if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                accessions.append(\" \");\n                accessions.append(n.getValue());\n            } else if (n.getTerm().equals(Terms.getKeywordTerm())) {\n                if (n.getValue() != null) {\n                    if (keywords.length()>0) keywords.append(\"; \");\n                    keywords.append(n.getValue());\n                }\n            }\n        }\n        \n        //adjust molecule type during format conversion\n        if(moltype!=null && moltype.length()>6) {\n            if(moltype.indexOf(\"DNA\")!=-1) moltype = \"DNA\";\n            else if(moltype.indexOf(\"RNA\")!=-1) moltype = \"RNA\";\n            else moltype = \"NA\";\n        }\n        \n        // locus(name) + length + alpha + div + date line\n        StringBuffer locusLine = new StringBuffer();\n        locusLine.append(StringTools.rightPad(rs.getName(),16));//13->28=15+1=16\n        locusLine.append(\" \");//29\n        locusLine.append(StringTools.leftPad(\"\"+rs.length(),11));//30->40=10+1=11\n        locusLine.append(\" \"+ (moltype==null? \"aa\":\"bp\") +\" \");//41->44\n        locusLine.append(StringTools.leftPad(stranded,3));//45->47=2+1=3\n        locusLine.append(StringTools.rightPad(moltype==null?\"\":moltype,6));//48->53=5+1=6\n        locusLine.append(\"  \");//54->55\n        locusLine.append(StringTools.rightPad(rs.getCircular()?\"circular\":\"linear\",8));//56->63=7+1=8\n        locusLine.append(\" \");//64->64\n        locusLine.append(StringTools.rightPad(rs.getDivision()==null?\"\":rs.getDivision(),3));//65->67=2+1=3\n        locusLine.append(\" \");//68->68\n        locusLine.append(StringTools.rightPad(udat,11));//69->79=10+1=11\n        StringTools.writeKeyValueLine(LOCUS_TAG, locusLine.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // definition line\n        StringTools.writeKeyValueLine(DEFINITION_TAG, rs.getDescription(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // accession line\n        StringTools.writeKeyValueLine(ACCESSION_TAG, accessions.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        \n        // version + gi line\n        String version = accession+\".\"+rs.getVersion();\n        if (rs.getIdentifier()!=null) version = version + \"  GI:\"+rs.getIdentifier();\n        StringTools.writeKeyValueLine(VERSION_TAG, version, 12, this.getLineWidth(), this.getPrintStream());\n        \n        // keywords line\n        keywords.append(\".\");\n        StringTools.writeKeyValueLine(KEYWORDS_TAG, keywords.toString(), 12, this.getLineWidth()-1, this.getPrintStream());\n        \n        // source line (from taxon)\n        //   organism line\n        NCBITaxon tax = rs.getTaxon();\n        if (tax!=null) {\n            StringTools.writeKeyValueLine(SOURCE_TAG, (isMitochondrial(rs)?\"mitochondrion \":\"\")+tax.getDisplayName(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+ORGANISM_TAG, tax.getDisplayName().split(\"\\\\s+\\\\(\")[0]+\"\\n\"+tax.getNameHierarchy(), 12, this.getLineWidth()-1, this.getPrintStream());\n        }\n        \n        // references - rank (bases x to y)\n        for (Iterator r = rs.getRankedDocRefs().iterator(); r.hasNext(); ) {\n            RankedDocRef rdr = (RankedDocRef)r.next();\n            DocRef d = rdr.getDocumentReference();\n            StringTools.writeKeyValueLine(REFERENCE_TAG, rdr.getRank()+((rdr.getLocation()==null || rdr.getLocation() ==RichLocation.EMPTY_LOCATION)?\"\": (moltype==null? \"  (residues \":\"  (bases \")+makeBaseRange(rdr)+\")\"), 12, this.getLineWidth(), this.getPrintStream());\n            // Any authors that were in the input as CONSRTM tags will\n            // be merged into the AUTHORS tag on output.\n            StringTools.writeKeyValueLine(\"  \"+AUTHORS_TAG, d.getAuthors(), 12, this.getLineWidth()-1, this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+TITLE_TAG, d.getTitle(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+JOURNAL_TAG, d.getLocation(), 12, this.getLineWidth(), this.getPrintStream());\n            CrossRef c = d.getCrossref();\n            if (c!=null) StringTools.writeKeyValueLine(StringTools.leftPad(c.getDbname(),9), c.getAccession(), 12, this.getLineWidth(), this.getPrintStream());\n            StringTools.writeKeyValueLine(\"  \"+REMARK_TAG, d.getRemark(), 12, this.getLineWidth(), this.getPrintStream());\n        }\n        \n        // comments - if any\n        Set comments = rs.getComments();\n        if (!comments.isEmpty()) {\n            StringBuffer sb = new StringBuffer();\n            for (Iterator i = comments.iterator(); i.hasNext(); ) {\n                Comment c = (SimpleComment)i.next();\n                sb.append(c.getComment());\n                if (i.hasNext()) sb.append(\"\\n\");\n            }\n            StringTools.writeKeyValueLine(COMMENT_TAG, sb.toString(), 12, this.getLineWidth(), this.getPrintStream());\n        }\n        \n        this.getPrintStream().println(FEATURE_TAG+\"             Location/Qualifiers\");\n        // feature_type     location\n        for (Iterator i = rs.getFeatureSet().iterator(); i.hasNext(); ) {\n            RichFeature f = (RichFeature)i.next();\n            StringTools.writeKeyValueLine(\"     \"+f.getTypeTerm().getName(), GenbankLocationParser.writeLocation((RichLocation)f.getLocation()), 21, this.getLineWidth()-1, \",\", this.getPrintStream());\n            for (Iterator j = f.getNoteSet().iterator(); j.hasNext(); ) {\n                Note n = (Note)j.next();\n                // /key=\"val\" or just /key if val==\"\"\n                if (n.getValue()==null || n.getValue().length()==0) StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName(), 21, this.getLineWidth(), this.getPrintStream());\n                else if (isNotQuoted(n)) {// doesn't have the value enclosed in quotes\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\"+n.getValue(), 21, this.getLineWidth(), this.getPrintStream());\n                } else if (n.getTerm().getName().equals(\"translation\")) {\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth()-1, this.getPrintStream());\n                } else {\n                    StringTools.writeKeyValueLine(\"\", \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n            }\n            // add-in to source feature only organism and db_xref=\"taxon:xyz\" where present\n            if (f.getType().equals(\"source\") && tax!=null) {\n                String displayName = tax.getDisplayName();\n                if (displayName.indexOf('(')>-1) displayName = displayName.substring(0, displayName.indexOf('(')).trim();\n                StringTools.writeKeyValueLine(\"\", \"/organism=\\\"\"+displayName+\"\\\"\", 21, this.getLineWidth()-1, this.getPrintStream());// AF252370 fits in exactly 80 - but is wrapped\n                for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                    RankedCrossRef rcr = (RankedCrossRef)j.next();\n                    CrossRef cr = rcr.getCrossRef();\n                    StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n                StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"taxon:\"+tax.getNCBITaxID()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n            } else {\n                // add-in other dbxrefs where present\n                for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                    RankedCrossRef rcr = (RankedCrossRef)j.next();\n                    CrossRef cr = rcr.getCrossRef();\n                    StringTools.writeKeyValueLine(\"\", \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), this.getPrintStream());\n                }\n            }\n        }\n        \n        //BASE COUNT obsolete in Genbank flatfile format since October 2003\n        //if (rs.getAlphabet()==AlphabetManager.alphabetForName(\"DNA\")) {\n        //    // BASE COUNT     1510 a   1074 c    835 g   1609 t\n        //    int aCount = 0;\n        //    int cCount = 0;\n        //    int gCount = 0;\n        //    int tCount = 0;\n        //    int oCount = 0;\n        //    for (int i = 1; i <= rs.length(); i++) {\n        //        char c;\n        //        try {\n        //            c = tok.tokenizeSymbol(rs.symbolAt(i)).charAt(0);\n        //        } catch (Exception e) {\n        //            throw new RuntimeException(\"Unable to get symbol at position \"+i,e);\n        //        }\n        //        switch (c) {\n        //            case 'a': case 'A':\n        //                aCount++;\n        //                break;\n        //            case 'c': case 'C':\n        //                cCount++;\n        //                break;\n        //            case 'g': case 'G':\n        //                gCount++;\n        //                break;\n        //            case 't': case 'T':\n        //                tCount++;\n        //                break;\n        //            default:\n        //                oCount++;\n        //        }\n        //    }\n        //\n        //    this.getPrintStream().print(BASE_COUNT_TAG_FULL+\"    \");\n        //    this.getPrintStream().print(aCount + \" a   \");\n        //    this.getPrintStream().print(cCount + \" c   \");\n        //    this.getPrintStream().print(gCount + \" g   \");\n        //    this.getPrintStream().print(tCount + \" t    \");\n        //    this.getPrintStream().println(oCount + \" others\");\n        //}\n        \n        this.getPrintStream().println(START_SEQUENCE_TAG);\n        // sequence stuff\n        Symbol[] syms = (Symbol[])rs.toList().toArray(new Symbol[0]);\n        int lines = 0;\n        int symCount = 0;\n        for (int i = 0; i < syms.length; i++) {\n            if (symCount % 60 == 0) {\n                if (lines > 0) this.getPrintStream().print(\"\\n\"); // newline from previous line\n                int lineNum = (lines*60) + 1;\n                this.getPrintStream().print(StringTools.leftPad(\"\"+lineNum,9));\n                lines++;\n            }\n            if (symCount % 10 == 0) this.getPrintStream().print(\" \");\n            try {\n                this.getPrintStream().print(tok.tokenizeSymbol(syms[i]));\n            } catch (IllegalSymbolException e) {\n                throw new RuntimeException(\"Found illegal symbol: \"+syms[i]);\n            }\n            symCount++;\n        }\n        if(syms.length>0) //do not create an empty line\n            this.getPrintStream().print(\"\\n\");\n        this.getPrintStream().println(END_SEQUENCE_TAG);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultFormat() {\n        return GENBANK_FORMAT;\n    }\n    \n    private final static boolean isMitochondrial(final RichSequence theSequence) {\n        final Set featureSet = theSequence.getFeatureSet();\n        final Iterator i = featureSet.iterator();\n        while (i.hasNext()) {\n            final RichFeature feature = (RichFeature) i.next();\n            if (feature.getType().equals(\"source\")) {\n                final Set noteSet = feature.getNoteSet();\n                final Iterator n = noteSet.iterator();\n                while(n.hasNext()) {\n                    final Note note = (Note) n.next();\n                    if (note.getTerm().getName().equals(\"organelle\")) return note.getValue().equals(\"mitochondrion\");\n                }\n            }\n        }\n        return false;\n    }\n    \n    private final static boolean isNotQuoted(final Note theNote) {\n        return isNotQuoted(theNote.getTerm().getName(), theNote.getValue());\n    }\n    \n    private final static boolean isNotQuoted(final String theName, final String theValue) {\n        return isNotQuoted.contains(theName);\n    }\n    \n    private final static String makeBaseRange(final RankedDocRef theReference) {\n        return theReference.getLocation()==null?theReference.getStart()+\" to \"+theReference.getEnd():toString(theReference.getLocation());\n    }\n    \n    private final static String toString(final RichLocation theLocation) {\n        final StringBuffer list = new StringBuffer();\n        final Iterator b = theLocation.blockIterator();\n        while (b.hasNext()) {\n            final RichLocation location = (RichLocation) b.next();\n            list.append(location.getMin()+\" to \"+location.getMax());\n            if (b.hasNext()) list.append(\"; \");\n        }\n        return list.toString();\n    }\n    \n    /**\n     * Converts the current parse section to a String. Useful for debugging.\n     */\n    String sectionToString(List section){\n        StringBuffer parseBlock = new StringBuffer();\n        for(Iterator i = section.listIterator(); i.hasNext();){\n            String[] part = (String[])i.next();\n            for(int x = 0; x < part.length; x++){\n                parseBlock.append(part[x]);\n                if(x == 0){\n                    parseBlock.append(\"   \"); //the gap will have been trimmed\n                }\n            }\n        }\n        return parseBlock.toString();\n    }\n}","originTest":"package org.biojavax.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.StringReader;\nimport java.util.Iterator;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.seq.SequenceIterator;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojavax.Namespace;\nimport org.biojavax.Note;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.bio.seq.RichSequence;\nimport org.biojavax.bio.seq.io.GenbankFormat.Terms;\nimport org.biojavax.bio.taxa.NCBITaxon;\n\n/**\n * Tests for GenbankFormat. Ain't parsing fun?\n * @author Bubba Puryear\n * @author George Waldon\n */\npublic class GenbankFormatTest extends TestCase {\n    private GenbankFormat gbFormat;\n\n    /**\n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp() {\n        this.gbFormat = new GenbankFormat();\n    }\n\t\t\n\t\tpublic void testGenbankParsingWithBondFeatures() {\n\t\t\t\treadProteinFile(\"/BondFeature.gb\");\n\t\t}\n\n    public void testGenbankParsing_oldStyleFile() {\n\t\tRichSequence sequence = readDNAFile(\"/NoAccession.gb\");\n        assertEquals(\"NoAccess\", sequence.getName());\n        assertTrue(sequence.getCircular());\n        assertEquals(null, sequence.getDescription());\n        assertEquals(null, sequence.getDivision());\n        assertEquals(null, sequence.getTaxon());\n        assertEquals(\"NoAccess\", sequence.getURN());\n        assertEquals(0, sequence.getVersion());\n        String stranded = null;\n        String udat = null;\n        String molType = sequence.getAlphabet().getName();\n        for (Iterator i = sequence.getNoteSet().iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getStrandedTerm())) stranded=n.getValue();\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) molType=n.getValue();\n        }\n        assertNull(stranded);\n        assertNotNull(udat);\n        assertEquals(\"30-JUN-2006\", udat);\n        assertNotNull(molType);\n        assertEquals(\"DNA\", molType);\n    }\n\n\n    public void testGenbankParsing_contemporaryApp() {\n\t\tRichSequence sequence = readDNAFile(\"/AY069118.gb\");\n        assertEquals(\"AY069118\", sequence.getName());\n        assertFalse(sequence.getCircular());\n        assertEquals(\"Drosophila melanogaster GH13089 full length cDNA.\", sequence.getDescription());\n        assertEquals(\"INV\", sequence.getDivision());\n        NCBITaxon taxon = sequence.getTaxon();\n        assertNotNull(taxon);\n        assertEquals(\"Drosophila melanogaster\", taxon.getDisplayName());\n        assertEquals(\"AY069118\", sequence.getURN());\n        assertEquals(1, sequence.getVersion());\n        String stranded = null;\n        String udat = null;\n        String molType = sequence.getAlphabet().getName();\n        for (Iterator i = sequence.getNoteSet().iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getStrandedTerm())) stranded=n.getValue();\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) molType=n.getValue();\n        }\n        assertNull(stranded);\n        assertNotNull(udat);\n        assertEquals(\"17-DEC-2001\", udat);\n        assertNotNull(molType);\n        assertEquals(\"mRNA\", molType);\n    }\n\n\n    public void testGenbankWithNoAccession() {\n    \tRichSequence sequence = readDNAFile(\"/NoAccession.gb\");\n        assertNotNull(sequence);\n        assertEquals(\"NoAccess\", sequence.getAccession());\n    }\n\n    public void testCanReadWhatIsWritten() {\n    \t// Read a genbank file\n    \tRichSequence sequence = readDNAFile(\"/AY069118.gb\");\n        assertNotNull(sequence);\n\n        // Write the file to an in-memory buffer\n        OutputStream output = new ByteArrayOutputStream();\n\t\tRichSequenceFormat genbank = new GenbankFormat();\n\t\tRichStreamWriter seqsOut = new RichStreamWriter(output, genbank);\n\t\tSequenceIterator seqIterator = new RichSequence.IOTools.SingleRichSeqIterator(sequence);\n\t\ttry {\n\t\t\tseqsOut.writeStream(seqIterator, null);\n\t\t} catch (IOException e) {\n        \tfail(\"Unexpected exception: \"+e);\n\t\t}\n\n\t\t// Re-read the generated output\n\t\tString newContent = output.toString();\n        SymbolTokenization dna = RichSequence.IOTools.getDNAParser();\n        Namespace defaultNs = RichObjectFactory.getDefaultNamespace();\n\t\tBufferedReader input = new BufferedReader(new StringReader(newContent));\n\t\tRichSequence rereadSeq = null;\n        try {\n            RichStreamReader reader = new RichStreamReader(input, new GenbankFormat(), dna, RichSequenceBuilderFactory.FACTORY, defaultNs);\n            rereadSeq = reader.nextRichSequence();\n        } catch (Exception e) {\n        \te.printStackTrace();\n        \tfail(\"Unexpected exception: \"+e);\n        }\n        assertNotNull(rereadSeq);\n        assertEquals(sequence.getAccession(), rereadSeq.getAccession());\n        assertEquals(sequence.getName(), rereadSeq.getName());\n        assertEquals(sequence.seqString(), rereadSeq.seqString());\n    }\n\n    /** Test whether the parser reads minimal sequences. The sequence prototype\n     * was generated by writing a sequence read in fasta format \n     * (\">testempty no sequence\") under the tested format.\n     */\n    public void testReadEmptySequence() {\n        RichSequence sequence = readDNAFile(\"/empty_genbank.gb\");\n        assertNotNull(sequence);\n        assertEquals(sequence.getName(), \"testempty\");\n        assertEquals(sequence.getAccession(), \"\");\n        assertEquals(sequence.getVersion(), 0);\n        assertEquals(sequence.getDescription(), \"no sequence\");\n        assertEquals(sequence.getInternalSymbolList().length(), 0);\n    }\n\n    /**\n     * Read a genbank file, return a RichSequence\n     * @param filename name of file to read\n     * @return a RichSequence instance\n     */\n    private RichSequence readDNAFile(String filename) {\n\t\tInputStream inStream = this.getClass().getResourceAsStream(filename);\n        BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n        SymbolTokenization tokenization = RichSequence.IOTools.getDNAParser();\n        Namespace namespace = RichObjectFactory.getDefaultNamespace();\n        SimpleRichSequenceBuilder builder = new SimpleRichSequenceBuilder();\n        RichSequence sequence = null;\n        try {\n            this.gbFormat.readRichSequence(br, tokenization, builder, namespace);\n            sequence = builder.makeRichSequence();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Unexpected exception: \"+e);\n        }\n\t\treturn sequence;\n\t}\n\t\n\tprivate RichSequence readProteinFile(String filename) {\n\t\tInputStream inStream = this.getClass().getResourceAsStream(filename);\n        BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n        SymbolTokenization tokenization = RichSequence.IOTools.getProteinParser();\n        Namespace namespace = RichObjectFactory.getDefaultNamespace();\n        SimpleRichSequenceBuilder builder = new SimpleRichSequenceBuilder();\n        RichSequence sequence = null;\n        try {\n            this.gbFormat.readRichSequence(br, tokenization, builder, namespace);\n            sequence = builder.makeRichSequence();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Unexpected exception: \"+e);\n        }\n\t\treturn sequence;\n\t}\n}\n","changedTest":"","commitMessage":"Removed code redundancy\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7241 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}