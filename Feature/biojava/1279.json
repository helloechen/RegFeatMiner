{"repository":"biojava","prod_path":"core/src/main/java/org/biojavax/bio/seq/io/EMBLFormat.java","test_path":"core/src/test/java/org/biojavax/bio/seq/io/EMBLFormatTest.java","prod_time":"2010-09-24 13:40:16","test_time":"2010-09-24 13:40:16","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"69f0c854de75201f21b84eeeda03b8d70bdec8e2","test_commitID":"69f0c854de75201f21b84eeeda03b8d70bdec8e2","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage\torg.biojavax.bio.seq.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojava.bio.seq.io.SeqIOListener;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojavax.Comment;\nimport org.biojavax.CrossRef;\nimport org.biojavax.DocRef;\nimport org.biojavax.DocRefAuthor;\nimport org.biojavax.Namespace;\nimport org.biojavax.Note;\nimport org.biojavax.RankedCrossRef;\nimport org.biojavax.RankedDocRef;\nimport org.biojavax.RichAnnotation;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.SimpleComment;\nimport org.biojavax.SimpleCrossRef;\nimport org.biojavax.SimpleDocRef;\nimport org.biojavax.SimpleDocRefAuthor;\nimport org.biojavax.SimpleNote;\nimport org.biojavax.SimpleRankedCrossRef;\nimport org.biojavax.SimpleRankedDocRef;\nimport org.biojavax.SimpleRichAnnotation;\nimport org.biojavax.bio.seq.RichFeature;\nimport org.biojavax.bio.seq.RichLocation;\nimport org.biojavax.bio.seq.RichSequence;\nimport org.biojavax.bio.taxa.NCBITaxon;\nimport org.biojavax.bio.taxa.SimpleNCBITaxon;\nimport org.biojavax.ontology.ComparableTerm;\nimport org.biojavax.utils.StringTools;\n\n/**\n * Format reader for EMBL files. This version of EMBL format will generate\n * and write RichSequence objects. Loosely Based on code from the old, deprecated,\n * org.biojava.bio.seq.io.EmblLikeFormat object.\n * <p>\n * This format will read both Pre-87 and 87+ versions of EMBL. It will also write\n * them both. By default, it will write the most recent version. If you want\n * an earlier one, you must specify the format by passing one of the constants\n * defined in this class to {@link #writeSequence(Sequence, String, Namespace)}.\n *\n * @author Richard Holland\n * @author Jolyon Holdstock\n * @author Mark Schreiber\n * @since 1.5\n */\npublic class EMBLFormat extends RichSequenceFormat.HeaderlessFormat {\n    \n    // Register this format with the format auto-guesser.\n    static {\n        RichSequence.IOTools.registerFormat(EMBLFormat.class);\n    }\n    \n    /**\n     * The name of the Pre-87 format\n     */\n    public static final String EMBL_PRE87_FORMAT = \"EMBL_PRE87\";\n    \n    /**\n     * The name of the current format\n     */\n    public static final String EMBL_FORMAT = \"EMBL\";\n    \n    protected static final String LOCUS_TAG = \"ID\";\n    protected static final String ACCESSION_TAG = \"AC\";\n    protected static final String VERSION_TAG = \"SV\";\n    protected static final String DEFINITION_TAG = \"DE\";\n    protected static final String DATE_TAG = \"DT\";\n    protected static final String DATABASE_XREF_TAG = \"DR\";\n    protected static final String SOURCE_TAG = \"OS\";\n    protected static final String ORGANISM_TAG = \"OC\";\n    protected static final String ORGANELLE_TAG = \"OG\";\n    protected static final String REFERENCE_TAG = \"RN\";\n    protected static final String REFERENCE_POSITION_TAG = \"RP\";\n    protected static final String REFERENCE_XREF_TAG = \"RX\";\n    protected static final String AUTHORS_TAG = \"RA\";\n    protected static final String CONSORTIUM_TAG = \"RG\";\n    protected static final String TITLE_TAG = \"RT\";\n    protected static final String LOCATOR_TAG = \"RL\";\n    protected static final String REMARK_TAG = \"RC\";\n    protected static final String KEYWORDS_TAG = \"KW\";\n    protected static final String COMMENT_TAG = \"CC\";\n    protected static final String FEATURE_HEADER_TAG = \"FH\";\n    protected static final String FEATURE_TAG = \"FT\";\n    protected static final String CONTIG_TAG = \"CO\";\n    protected static final String TPA_TAG = \"AH\";\n    protected static final String START_SEQUENCE_TAG = \"SQ\";\n    protected static final String DELIMITER_TAG = \"XX\";\n    protected static final String END_SEQUENCE_TAG = \"//\";\n    \n    // the date pattern\n    // date (Rel. N, Created)\n    // date (Rel. N, Last updated, Version M)\n    protected static final Pattern dp = Pattern.compile(\"([^\\\\s]+)\\\\s*(\\\\(Rel\\\\.\\\\s+(\\\\d+), ([^\\\\)\\\\d]+)(\\\\d*)\\\\))?$\");\n    // locus line\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+);\\\\s+SV\\\\s+(\\\\d+);\\\\s+(linear|circular);\\\\s+(\\\\S+\\\\s?\\\\S+?);\\\\s+(\\\\S+);\\\\s+(\\\\S+);\\\\s+(\\\\d+)\\\\s+BP\\\\.$\");\n    protected static final Pattern lpPre87 = Pattern.compile(\"^(\\\\S+)\\\\s+standard;\\\\s+(circular)?\\\\s*(genomic)?\\\\s*(\\\\S+);\\\\s+(\\\\S+);\\\\s+\\\\d+\\\\s+BP\\\\.$\");\n    // version line\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S+?)\\\\.(\\\\d+)$\");\n    // reference position line\n    protected static final Pattern rpp = Pattern.compile(\"^(\\\\d+)(-(\\\\d+))?,?(\\\\s\\\\d+-\\\\d+,?)*$\");\n    // dbxref line\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\n    \n    protected static final Pattern readableFileNames = Pattern.compile(\".*\\\\u002e(em|dat).*\");\n    protected static final Pattern headerLine = Pattern.compile(\"^ID.*\");\n    \n    private NCBITaxon tax = null;\n    private String organism = null;\n    private String accession = null;\n    \n    /**\n     * Implements some EMBL-specific terms.\n     */\n    public static class Terms extends RichSequence.Terms {\n        \n        /**\n         * Getter for the RelUpdatedRecordVersion term\n         * @return The RelUpdatedRecordVersion Term\n         */\n        public static ComparableTerm getRelUpdatedRecordVersionTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"RelUpdatedRecordVersion\");\n        }\n        \n        /**\n         * Getter for the EMBL term\n         * @return The EMBL Term\n         */\n        public static ComparableTerm getEMBLTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"EMBL\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'genomic' term\n         * @return The genomic Term\n         */\n        public static ComparableTerm getGenomicTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"genomic\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'versionLine' term\n         * @return The version line Term\n         */\n        public static ComparableTerm getVersionLineTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"versionLine\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'dataClass' term\n         * @return The data class Term\n         */\n        public static ComparableTerm getDataClassTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"dataClass\");\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A file is in EMBL format if its name contains the word eem or edat, or the first line matches\n     * the EMBL format for the ID line.\n     */\n    public boolean canRead(File file) throws IOException {\n        if (readableFileNames.matcher(file.getName()).matches()) return true;\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches() &&\n                (lp.matcher(firstLine.substring(3).trim()).matches() ||\n                lpPre87.matcher(firstLine.substring(3).trim()).matches()\n                );\n        br.close();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Always returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(File file) throws IOException {\n        return RichSequence.IOTools.getDNAParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A stream is in EMBL format if its first line matches the EMBL format for the ID line.\n     */\n    public boolean canRead(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches() &&\n                (lp.matcher(firstLine.substring(3).trim()).matches() ||\n                lpPre87.matcher(firstLine.substring(3).trim()).matches()\n                );\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Always returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(BufferedInputStream stream) throws IOException {\n        return RichSequence.IOTools.getDNAParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            SeqIOListener listener)\n            throws IllegalSymbolException, IOException, ParseException {\n        if (!(listener instanceof RichSeqIOListener)) throw new IllegalArgumentException(\"Only accepting RichSeqIOListeners today\");\n        return this.readRichSequence(reader,symParser,(RichSeqIOListener)listener,null);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readRichSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            RichSeqIOListener rlistener,\n            Namespace ns)\n            throws IllegalSymbolException, IOException, ParseException {\n        tax = null;\n        organism = null;\n        accession = null;\n        boolean hasAnotherSequence = true;\n        //boolean hasInternalWhitespace = false;\n        \n        rlistener.startSequence();\n        \n        if (ns==null) ns=RichObjectFactory.getDefaultNamespace();\n        rlistener.setNamespace(ns);\n        \n        // Get an ordered list of key->value pairs in array-tuples\n        String sectionKey = null;\n        do {\n            List section = this.readSection(reader);\n            sectionKey = ((String[])section.get(0))[0];\n            if(sectionKey == null){\n                \n                String message = ParseException.newMessage(this.getClass(), accession, \"No section key\", \"Not set\", sectionToString(section));\n                throw new ParseException(message);\n            }\n            // process section-by-section\n            if (sectionKey.equals(LOCUS_TAG)) {\n                // entryname  dataclass; [circular] molecule; division; sequencelength BP.\n                String loc = ((String[])section.get(0))[1];\n                Matcher m = lp.matcher(loc);\n                Matcher mPre87 = lpPre87.matcher(loc);\n                if (m.matches()) {\n                    // first token is both name and primary accession\n                    rlistener.setName(m.group(1));\n                    rlistener.setAccession(m.group(1));\n                    // second token is version\n                    rlistener.setVersion(Integer.parseInt(m.group(2)));\n                    // third token is circular/linear\n                    rlistener.setCircular(m.group(3).equals(\"circular\"));\n                    // fourth token is moltype\n                    rlistener.addSequenceProperty(Terms.getMolTypeTerm(),m.group(4));\n                    // fifth token is data class\n                    rlistener.addSequenceProperty(Terms.getDataClassTerm(),m.group(5));\n                    // sixth token is taxonomic division\n                    rlistener.setDivision(m.group(6));\n                    // seventh token is sequence length, which is ignored\n                    // as it is calculated from the sequence data later.\n                } else if (mPre87.matches()) {\n                    rlistener.setName(mPre87.group(1));\n                    if (mPre87.group(3)!=null) {\n                        // add annotation for 'genomic' (Ensembl-specific term)\n                        rlistener.addSequenceProperty(Terms.getGenomicTerm(),null);\n                    }\n                    rlistener.addSequenceProperty(Terms.getMolTypeTerm(),mPre87.group(4));\n                    rlistener.setDivision(mPre87.group(5));\n                    // Optional extras\n                    String circular = mPre87.group(2);\n                    if (circular!=null) rlistener.setCircular(true);\n                } else {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"Not Set\",\"Bad ID line found\", sectionToString(section));\n                    throw new ParseException(message);\n                }\n            } else if (sectionKey.equals(DEFINITION_TAG)) {\n                rlistener.setDescription(((String[])section.get(0))[1]);\n            } else if (sectionKey.equals(SOURCE_TAG)) {\n                // only interested in organelle sub-tag\n                for (int i = 1; i < section.size(); i++) {\n                    sectionKey = ((String[])section.get(i))[0];\n                    if (sectionKey.equals(ORGANELLE_TAG)) {\n                        rlistener.addSequenceProperty(Terms.getOrganelleTerm(), ((String[])section.get(i))[1].trim());\n                        break; // skip out of for loop once found\n                    }\n                }\n            } else if (sectionKey.equals(DATE_TAG)) {\n                String chunk = ((String[])section.get(0))[1].trim();\n                Matcher dm = dp.matcher(chunk);\n                if (dm.matches()) {\n                    String date = dm.group(1);\n                    String rel = dm.group(3);\n                    String type = dm.group(4);\n                    if (type.equals(\"Created\")) {\n                        rlistener.addSequenceProperty(Terms.getDateCreatedTerm(), date);\n                        rlistener.addSequenceProperty(Terms.getRelCreatedTerm(), rel);\n                    } else if (type.equals(\"Last updated, Version \")) {\n                        rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(), date);\n                        rlistener.addSequenceProperty(Terms.getRelUpdatedTerm(), rel);\n                        rlistener.addSequenceProperty(Terms.getRelUpdatedRecordVersionTerm(), dm.group(5));\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad date type found\",sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad date line found\",sectionToString(section));\n                    throw new ParseException(message);\n                    \n                }\n            } else if (sectionKey.equals(ACCESSION_TAG)) {\n                // if multiple accessions, store only first as accession,\n                // and store rest in annotation\n                String[] accs = ((String[])section.get(0))[1].split(\";\");\n                accession = accs[0].trim();\n                rlistener.setAccession(accession);\n                for (int i = 1; i < accs.length; i++) {\n                    rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accs[i].trim());\n                }\n            } else if (sectionKey.equals(VERSION_TAG)) {\n                String ver = ((String[])section.get(0))[1];\n                Matcher m = vp.matcher(ver);\n                if (m.matches()) {\n                    String verAcc = m.group(1);\n                    if (!accession.equals(verAcc)) {\n                        // the version refers to a different accession!\n                        // believe the version line, and store the original\n                        // accession away in the additional accession set\n                        rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accession);\n                        accession = verAcc;\n                        rlistener.setAccession(accession);\n                    }\n                    rlistener.setVersion(Integer.parseInt(m.group(2)));\n                } else {\n                    rlistener.addSequenceProperty(Terms.getVersionLineTerm(),ver);\n                }\n            } else if (sectionKey.equals(KEYWORDS_TAG)) {\n                String val = ((String[])section.get(0))[1];\n                val = val.substring(0,val.length()-1); // chomp dot\n                val = val.replace('\\n',' '); //remove newline\n                String[] kws = val.split(\";\");\n                for (int i = 0; i < kws.length; i++) {\n                    String kw = kws[i].trim();\n                    if (kw.length()==0) continue;\n                    rlistener.addSequenceProperty(Terms.getKeywordTerm(), kw);\n                }\n            } else if (sectionKey.equals(DATABASE_XREF_TAG)) {\n                String val = ((String[])section.get(0))[1];\n                val = val.substring(0,val.length()-1); // chomp dot\n                // database_identifier; primary_identifier; secondary_identifier....\n                String[] parts = val.split(\";\");\n                // construct a DBXREF out of the dbname part[0] and accession part[1]\n                CrossRef crossRef = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{parts[0].trim(),parts[1].trim(), new Integer(0)});\n                // assign remaining bits of info as annotations\n                for (int j = 2; j < parts.length; j++) {\n                    Note note = new SimpleNote(Terms.getAdditionalAccessionTerm(),parts[j].trim(),j-1);\n                    try {\n                        crossRef.getRichAnnotation().addNote(note);\n                    } catch (ChangeVetoException ce) {\n                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Could not annotate identifier terms\",sectionToString(section));\n                        ParseException pe = new ParseException(message);\n                        pe.initCause(ce);\n                        throw pe;\n                    }\n                }\n                RankedCrossRef rcrossRef = new SimpleRankedCrossRef(crossRef, 0);\n                rlistener.setRankedCrossRef(rcrossRef);\n            } else if (sectionKey.equals(REFERENCE_TAG) && !this.getElideReferences()) {\n                // first line of section has rank and location\n                String refrank = ((String[])section.get(0))[1];\n                int ref_rank = Integer.parseInt(refrank.substring(1,refrank.length()-1));\n                int ref_start = -999;\n                int ref_end = -999;\n                // rest can be in any order\n                String consortium = null;\n                String authors = \"\";\n                String title = null;\n                String locator = null;\n                String pubmed = null;\n                String medline = null;\n                String doi = null;\n                String remark = null;\n                for (int i = 1; i < section.size(); i++) {\n                    String key = ((String[])section.get(i))[0];\n                    String val = ((String[])section.get(i))[1];\n                    if (key.equals(AUTHORS_TAG)) {\n                        if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                        authors = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(CONSORTIUM_TAG)) {\n                        if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                        consortium = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(TITLE_TAG)) {\n                        if (val.length()>1) {\n                            if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                            if (val.endsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // chomp quotes\n                            title = val.replace('\\n',' '); //see #2276\n                        } else title=null; // single semi-colon indicates no title\n                    }\n                    if (key.equals(LOCATOR_TAG)) {\n                        if (val.endsWith(\".\")) val = val.substring(0,val.length()-1); // chomp dot\n                        locator = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(REFERENCE_XREF_TAG)) {\n                        // database_identifier; primary_identifier.\n                        String[] refs = val.split(\"\\\\.(\\\\s+|$)\");\n                        for (int j = 0 ; j < refs.length; j++) {\n                            if (refs[j].trim().length()==0) continue;\n                            String[] parts = refs[j].split(\";\");\n                            String db = parts[0];\n                            String ref = parts[1].trim();\n                            if (db.equalsIgnoreCase(Terms.PUBMED_KEY)) pubmed = ref;\n                            else if (db.equalsIgnoreCase(Terms.MEDLINE_KEY)) medline = ref;\n                            else if (db.equalsIgnoreCase(Terms.DOI_KEY)) doi = ref;\n                        }\n                    }\n                    if (key.equals(REMARK_TAG)) remark = val.replace('\\n',' '); //see #2276\n                    if (key.equals(REFERENCE_POSITION_TAG)) {\n                        // only the first group is taken\n                        // if we have multiple lines, only the last line is taken\n                        Matcher m = rpp.matcher(val);\n                        if (m.matches()) {\n                            ref_start = Integer.parseInt(m.group(1));\n                            if(m.group(2) != null)\n                                ref_end = Integer.parseInt(m.group(3));\n                        } else {\n                            String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad reference line found\",sectionToString(section));\n                            throw new ParseException(message);\n                        }\n                    }\n                }\n                // create the docref object\n                try {\n                    List authSet = DocRefAuthor.Tools.parseAuthorString(authors);\n                    if (consortium!=null) authSet.add(new SimpleDocRefAuthor(consortium, true, false));\n                    DocRef dr = (DocRef)RichObjectFactory.getObject(SimpleDocRef.class,new Object[]{authSet,locator,title});\n                    // assign either the pubmed or medline to the docref - medline gets priority, then pubmed, then doi\n                    if (medline!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.MEDLINE_KEY, medline, new Integer(0)}));\n                    else if (pubmed!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.PUBMED_KEY, pubmed, new Integer(0)}));\n                    else if (doi!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.DOI_KEY, doi, new Integer(0)}));\n                    // assign the remarks\n                    if (!this.getElideComments()) dr.setRemark(remark);\n                    // assign the docref to the bioentry\n                    RankedDocRef rdr = new SimpleRankedDocRef(dr,\n                            (ref_start != -999 ? new Integer(ref_start) : null),\n                            (ref_end != -999 ? new Integer(ref_end) : null),\n                            ref_rank);\n                    rlistener.setRankedDocRef(rdr);\n                } catch (ChangeVetoException e) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                    throw new ParseException(e, message);\n                }\n            } else if (sectionKey.equals(COMMENT_TAG) && !this.getElideComments()) {\n                // Set up some comments\n                rlistener.setComment(((String[])section.get(0))[1]);\n            } else if (sectionKey.equals(FEATURE_TAG) && !this.getElideFeatures()) {\n                // starting from second line of input, start a new feature whenever we come across\n                // a key that does not start with /\n                boolean seenAFeature = false;\n                int rcrossrefCount = 0;\n                for (int i = 1 ; i < section.size(); i++) {\n                    String key = ((String[])section.get(i))[0];\n                    String val = ((String[])section.get(i))[1];\n                    if (key.startsWith(\"/\")) {\n                        key = key.substring(1); // strip leading slash\n                        val = val.replaceAll(\"\\\\s*[\\\\n\\\\r]+\\\\s*\",\" \").trim();\n                        if (val.startsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // strip quotes\n                        // parameter on old feature\n                        if (key.equalsIgnoreCase(\"db_xref\")) {\n                            Matcher m = dbxp.matcher(val);\n                            if (m.matches()) {\n                                String dbname = m.group(1);\n                                String raccession = m.group(2);\n                                if (dbname.equalsIgnoreCase(\"taxon\")) {\n                                    // Set the Taxon instead of a dbxref\n                                    tax = (NCBITaxon)RichObjectFactory.getObject(SimpleNCBITaxon.class, new Object[]{Integer.valueOf(raccession)});\n                                    rlistener.setTaxon(tax);\n                                    try {\n                                        if (organism!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism);\n                                    } catch (ChangeVetoException e) {\n                                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                        throw new ParseException(e, message);\n                                    }\n                                } else {\n                                    try {\n                                        CrossRef cr = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{dbname, raccession, new Integer(0)});\n                                        RankedCrossRef rcr = new SimpleRankedCrossRef(cr, ++rcrossrefCount);\n                                        rlistener.getCurrentFeature().addRankedCrossRef(rcr);\n                                    } catch (ChangeVetoException e) {\n                                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                        throw new ParseException(e, message);\n                                    }\n                                }\n                            } else {\n                                String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad dbxref found\",sectionToString(section));\n                                throw new ParseException(message);\n                            }\n                        } else if (key.equalsIgnoreCase(\"organism\")) {\n                            try {\n                                organism = val;\n                                if (tax!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism);\n                            } catch (ChangeVetoException e) {\n                                String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                throw new ParseException(message);\n                            }\n                        } else {\n                            if (key.equalsIgnoreCase(\"translation\")) {\n                                // strip spaces from sequence\n                                val = val.replaceAll(\"\\\\s+\",\"\");\n                            }\n                            rlistener.addFeatureProperty(RichObjectFactory.getDefaultOntology().getOrCreateTerm(key),val);\n                        }\n                    } else {\n                        // new feature!\n                        // end previous feature\n                        if (seenAFeature) rlistener.endFeature();\n                        // start next one, with lots of lovely info in it\n                        RichFeature.Template templ = new RichFeature.Template();\n                        templ.annotation = new SimpleRichAnnotation();\n                        templ.sourceTerm = Terms.getEMBLTerm();\n                        templ.typeTerm = RichObjectFactory.getDefaultOntology().getOrCreateTerm(key);\n                        templ.featureRelationshipSet = new TreeSet();\n                        templ.rankedCrossRefs = new TreeSet();\n                        String tidyLocStr = val.replaceAll(\"\\\\s+\",\"\");\n                        templ.location = GenbankLocationParser.parseLocation(ns, accession, tidyLocStr);\n                        rlistener.startFeature(templ);\n                        seenAFeature = true;\n                        rcrossrefCount = 0;\n                    }\n                }\n                if (seenAFeature) rlistener.endFeature();\n            } else if (sectionKey.equals(START_SEQUENCE_TAG) && !this.getElideSymbols()) {\n                StringBuffer seq = new StringBuffer();\n                for (int i = 0 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\n                try {\n                    SymbolList sl = new SimpleSymbolList(symParser,\n                            seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\"));\n                    rlistener.addSymbols(symParser.getAlphabet(),\n                            (Symbol[])(sl.toList().toArray(new Symbol[0])),\n                            0, sl.length());\n                } catch (Exception e) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad sequence\",sectionToString(section));\n                    throw new ParseException(e, message);\n                }\n            }\n        } while (!sectionKey.equals(END_SEQUENCE_TAG));\n        \n        // Allows us to tolerate trailing whitespace without\n        // thinking that there is another Sequence to follow\n        while (true) {\n            reader.mark(1);\n            int c = reader.read();\n            if (c == -1) {\n                hasAnotherSequence = false;\n                break;\n            }\n            if (Character.isWhitespace((char) c)) {\n                //hasInternalWhitespace = true;\n                continue;\n            }\n            //if (hasInternalWhitespace)\n            //    System.err.println(\"Warning: whitespace found between sequence entries\");\n            reader.reset();\n            break;\n        }\n        \n        // Finish up.\n        rlistener.endSequence();\n        return hasAnotherSequence;\n    }\n    \n    // reads an indented section, combining split lines and creating a list of key->value tuples\n    private List readSection(BufferedReader br) throws ParseException {\n        List section = new ArrayList();\n        String line;\n        boolean done = false;\n        \n        // while not done\n        try {\n            while (!done) {\n                // mark buffer\n                br.mark(160);\n                // read token\n                line = br.readLine();\n                if (line.length()<2) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad line found\",line);\n                    throw new ParseException(message);\n                }\n                String token = line.substring(0,2);\n                // READ SEQUENCE SECTION\n                if (token.equals(START_SEQUENCE_TAG)) {\n                    //      from next line, read sequence until // - leave // on stack\n                    StringBuffer sb = new StringBuffer();\n                    while (!done) {\n                        br.mark(160);\n                        line = br.readLine();\n                        if (line.startsWith(END_SEQUENCE_TAG)) {\n                            br.reset();\n                            done = true;\n                        } else {\n                            //      create sequence tag->value pair to return, sans numbers\n                            sb.append(line.replaceAll(\"\\\\d\",\"\"));\n                        }\n                    }\n                    section.add(new String[]{START_SEQUENCE_TAG,sb.toString()});\n                }\n                // READ FEATURE TABLE SECTION\n                else if (token.equals(FEATURE_HEADER_TAG)) {\n                    //      create dummy feature tag->value pair and add to return set\n                    section.add(new String[]{FEATURE_TAG,null});\n                    //      drop next FH line\n                    line = br.readLine(); // skip next line too - it is also FH\n                    //      read all FT lines until XX\n                    String currentTag = null;\n                    StringBuffer currentVal = null;\n                    while (!done) {\n                        line = br.readLine();\n                        if (line.startsWith(DELIMITER_TAG)) {\n                            done = true;\n                            // dump current tag if exists\n                            if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                        } else {\n                            //         FT lines:   FT   word            value\n                            //         or          FT                   /word\n                            //         or          FT                   /db_xref=\"taxon:3899....\n                            //                                          ......\"\n                            line = line.substring(5); // chomp off \"FT   \"\n                            if (!line.startsWith(\" \")) {\n                                // dump current tag if exists\n                                if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                // case 1 : word value - splits into key-value on its own\n                                String[] parts = line.trim().split(\"\\\\s+\");\n                                currentTag = parts[0];\n                                currentVal = new StringBuffer();\n                                currentVal.append(parts[1]);\n                            } else {\n                                line = line.trim();\n                                if (line.startsWith(\"/\")) {\n                                    // dump current tag if exists\n                                    if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                    // case 2 : /word[=.....]\n                                    currentVal = new StringBuffer();\n                                    int equalIndex = line.indexOf('=');\n                                    if (equalIndex>=0) {\n                                        currentTag = line.substring(0, equalIndex);\n                                        currentVal.append(line.substring(equalIndex+1));\n                                    } else {\n                                        currentTag = line;\n                                    }\n                                } else {\n                                    // case 3 : ....\"\n                                    currentVal.append(\"\\n\");\n                                    currentVal.append(line);\n                                }\n                            }\n                        }\n                    }\n                }\n                // READ END OF SEQUENCE\n                else if (token.equals(END_SEQUENCE_TAG)) {\n                    section.add(new String[]{END_SEQUENCE_TAG,null});\n                    done = true;\n                }\n                // READ DELIMITER TAG\n                else if (token.equals(DELIMITER_TAG)) {\n                    section.add(new String[]{DELIMITER_TAG,null});\n                    done = true;\n                }\n                // READ THIRD PARTY ANNOTATION SECTION\n                else if (token.equals(TPA_TAG)) {\n                    //      exception = don't know how to do TPA yet\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle TPAs just yet\",sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // READ CONTIG SECTION\n                else if (token.equals(CONTIG_TAG)) {\n                    //      exception = don't know how to do contigs yet\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle contig assemblies just yet\",sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // READ DOCREF\n                else if (token.equals(DATABASE_XREF_TAG)) {\n                    section.add(new String[]{DATABASE_XREF_TAG,line.substring(5).trim()});\n                    done = true;\n                }\n                // READ DATE\n                else if (token.equals(DATE_TAG)) {\n                    section.add(new String[]{DATE_TAG,line.substring(5).trim()});\n                    done = true;\n                }\n                // READ NORMAL TAG/VALUE SECTION\n                else {\n                    //      rewind buffer to mark\n                    br.reset();\n                    //      read token/values until XX\n                    String currentTag = null;\n                    StringBuffer currentVal = null;\n                    while (!done) {\n                        line = br.readLine();\n                        if (line.startsWith(DELIMITER_TAG)) {\n                            done = true;\n                            // dump current tag if exists\n                            if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                        } else {\n                            try {\n                                //      merge neighbouring repeated tokens by concatting values\n                                //      return tag->value pairs\n                                String tag = line.substring(0,2);\n                                String value = line.substring(5);\n                                if (currentTag==null || !tag.equals(currentTag)) {\n                                    // dump current tag if exists\n                                    if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                    // start new tag\n                                    currentTag = tag;\n                                    currentVal = new StringBuffer();\n                                    currentVal.append(value);\n                                } else {\n                                    currentVal.append(\"\\n\");\n                                    currentVal.append(value);\n                                }\n                            } catch (Exception e) {\n                                String message = ParseException.newMessage(this.getClass(), accession, \"not set\",\"\",sectionToString(section));\n                                throw new ParseException(e, message);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle TPAs just yet\",sectionToString(section));\n            throw new ParseException(message);\n        }\n        return section;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void\twriteSequence(Sequence seq, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void writeSequence(Sequence seq, String format, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, format, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Namespace is ignored as EMBL has no concept of it.\n     */\n    public void writeSequence(Sequence seq, Namespace ns) throws IOException {\n        this.writeSequence(seq, this.getDefaultFormat(), ns);\n    }\n    \n    /**\n     * As per {@link #writeSequence(Sequence, Namespace)}, except\n     * that it also takes a format parameter. This can be any of the formats\n     * defined as constants in this class.\n     * @param seq see {@link #writeSequence(Sequence, Namespace)}\n     * @param format the format to use.\n     * @param ns see {@link #writeSequence(Sequence, Namespace)}\n     * @throws IOException see {@link #writeSequence(Sequence, Namespace)}\n     */\n    public void writeSequence(Sequence seq, String format, Namespace ns) throws IOException {\n        if (!format.equals(EMBL_FORMAT) && !format.equals(EMBL_PRE87_FORMAT))\n            throw new IllegalArgumentException(\"Format \"+format+\" not recognised.\");\n        \n        RichSequence rs;\n        try {\n            if (seq instanceof RichSequence) rs = (RichSequence)seq;\n            else rs = RichSequence.Tools.enrich(seq);\n        } catch (ChangeVetoException e) {\n            IOException e2 = new IOException(\"Unable to enrich sequence\");\n            e2.initCause(e);\n            throw e2;\n        }\n        \n        SymbolTokenization tok;\n        try {\n            tok = rs.getAlphabet().getTokenization(\"token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to get alphabet tokenizer\",e);\n        }\n        \n        Set notes = rs.getNoteSet();\n        String accession = rs.getAccession();\n        StringBuffer accessions = new StringBuffer();\n        accessions.append(accession);\n        accessions.append(\";\");\n        String cdat = null;\n        String udat = null;\n        String crel = null;\n        String urel = null;\n        String urecv = null;\n        String organelle = null;\n        String versionLine = null;\n        String dataClass = \"STD\";\n        boolean genomic = false;\n        String moltype = rs.getAlphabet().getName();\n        for (Iterator i = notes.iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getDateCreatedTerm())) cdat=n.getValue();\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelCreatedTerm())) crel=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelUpdatedTerm())) urel=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelUpdatedRecordVersionTerm())) urecv=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) moltype=n.getValue();\n            else if (n.getTerm().equals(Terms.getVersionLineTerm())) versionLine=n.getValue();\n            else if (n.getTerm().equals(Terms.getGenomicTerm())) genomic = true;\n            else if (n.getTerm().equals(Terms.getDataClassTerm())) dataClass = n.getValue();\n            else if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                accessions.append(\" \");\n                accessions.append(n.getValue());\n                accessions.append(\";\");\n            } else if (n.getTerm().equals(Terms.getOrganelleTerm())) organelle=n.getValue();\n        }\n        \n        StringBuffer locusLine = new StringBuffer();\n        if (format.equals(EMBL_FORMAT)) {\n            // accession; SV version; circular/linear; moltype; dataclass; division; length BP.\n            locusLine.append(rs.getAccession());\n            locusLine.append(\"; SV \");\n            locusLine.append(rs.getVersion());\n            locusLine.append(\"; \");\n            locusLine.append(rs.getCircular()?\"circular\":\"linear\");\n            locusLine.append(\"; \");\n            locusLine.append(moltype);\n            locusLine.append(\"; \");\n            locusLine.append(dataClass);\n            locusLine.append(\"; \");\n            locusLine.append(rs.getDivision());\n            locusLine.append(\"; \");\n            locusLine.append(rs.length());\n            locusLine.append(\" BP.\");\n        } else if (format.equals(EMBL_PRE87_FORMAT)) {\n            // entryname  dataclass; [circular] molecule; division; sequencelength BP.\n            locusLine.append(StringTools.rightPad(rs.getName(),9));\n            locusLine.append(\" standard; \");\n            locusLine.append(rs.getCircular()?\"circular \":\"\");\n            // if it is Ensembl genomic, add that in too\n            if (genomic==true) locusLine.append(\"genomic \");\n            locusLine.append(moltype);\n            locusLine.append(\"; \");\n            locusLine.append(rs.getDivision()==null?\"\":rs.getDivision());\n            locusLine.append(\"; \");\n            locusLine.append(rs.length());\n            locusLine.append(\" BP.\");\n        }\n        StringTools.writeKeyValueLine(LOCUS_TAG, locusLine.toString(), 5, this.getLineWidth(), null, LOCUS_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // accession line\n        StringTools.writeKeyValueLine(ACCESSION_TAG, accessions.toString(), 5, this.getLineWidth(), null, ACCESSION_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // version line\n        if (format.equals(EMBL_PRE87_FORMAT)) {\n            if (versionLine!=null) StringTools.writeKeyValueLine(VERSION_TAG, versionLine, 5, this.getLineWidth(), null, VERSION_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(VERSION_TAG, accession+\".\"+rs.getVersion(), 5, this.getLineWidth(), null, VERSION_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // date line\n        StringTools.writeKeyValueLine(DATE_TAG, (cdat==null?udat:cdat)+\" (Rel. \"+(crel==null?\"0\":crel)+\", Created)\", 5, this.getLineWidth(), null, DATE_TAG, this.getPrintStream());\n        StringTools.writeKeyValueLine(DATE_TAG, udat+\" (Rel. \"+(urel==null?\"0\":urel)+\", Last updated, Version \"+(urecv==null?\"0\":urecv)+\")\", 5, this.getLineWidth(), null, DATE_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // definition line\n        StringTools.writeKeyValueLine(DEFINITION_TAG, rs.getDescription(), 5, this.getLineWidth(), null, DEFINITION_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // keywords line\n        StringBuffer keywords = new StringBuffer();\n        for (Iterator n = notes.iterator(); n.hasNext(); ) {\n            Note nt = (Note)n.next();\n            if (nt.getTerm().equals(Terms.getKeywordTerm())) {\n                if (keywords.length()>0) keywords.append(\"; \");\n                keywords.append(nt.getValue());\n            }\n        }\n        if (keywords.length()>0) {\n            keywords.append(\".\");\n            StringTools.writeKeyValueLine(KEYWORDS_TAG, keywords.toString(), 5, this.getLineWidth(), null, KEYWORDS_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        } else {\n            this.getPrintStream().println(KEYWORDS_TAG+\"   .\");\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // source line (from taxon)\n        //   organism line\n        NCBITaxon tax = rs.getTaxon();\n        if (tax!=null) {\n            StringTools.writeKeyValueLine(SOURCE_TAG, tax.getDisplayName(), 5, this.getLineWidth(), null, SOURCE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(ORGANISM_TAG, tax.getNameHierarchy(), 5, this.getLineWidth(), null, SOURCE_TAG, this.getPrintStream());\n            if (organelle!=null) StringTools.writeKeyValueLine(ORGANELLE_TAG, organelle, 5, this.getLineWidth(), null, ORGANELLE_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // references - rank (bases x to y)\n        for (Iterator r = rs.getRankedDocRefs().iterator(); r.hasNext(); ) {\n            RankedDocRef rdr = (RankedDocRef)r.next();\n            DocRef d = rdr.getDocumentReference();\n            // RN, RC, RP, RX, RG, RA, RT, RL\n            StringTools.writeKeyValueLine(REFERENCE_TAG, \"[\"+rdr.getRank()+\"]\", 5, this.getLineWidth(), null, REFERENCE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(REMARK_TAG, d.getRemark(), 5, this.getLineWidth(), null, REMARK_TAG, this.getPrintStream());\n            Integer rstart = rdr.getStart();\n            if (rstart==null) rstart = new Integer(1);\n            Integer rend = rdr.getEnd();\n            if (rend==null) rend = new Integer(rs.length());\n            StringTools.writeKeyValueLine(REFERENCE_POSITION_TAG, rstart+\"-\"+rend, 5, this.getLineWidth(), null, REFERENCE_POSITION_TAG, this.getPrintStream());\n            CrossRef c = d.getCrossref();\n            if (c!=null) StringTools.writeKeyValueLine(REFERENCE_XREF_TAG, c.getDbname()+\"; \"+c.getAccession()+\".\", 5, this.getLineWidth(), null, REFERENCE_XREF_TAG, this.getPrintStream());\n            List auths = d.getAuthorList();\n            for (Iterator j = auths.iterator(); j.hasNext(); ) {\n                DocRefAuthor a = (DocRefAuthor)j.next();\n                if (a.isConsortium()) {\n                    StringTools.writeKeyValueLine(CONSORTIUM_TAG, a+\";\", 5, this.getLineWidth(), null, CONSORTIUM_TAG, this.getPrintStream());\n                    j.remove();\n                }\n            }\n            if (!auths.isEmpty()) StringTools.writeKeyValueLine(AUTHORS_TAG, DocRefAuthor.Tools.generateAuthorString(auths, true)+\";\", 5, this.getLineWidth(), null, AUTHORS_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(AUTHORS_TAG, \";\", 5, this.getLineWidth(), null, AUTHORS_TAG, this.getPrintStream());\n            if (d.getTitle()!=null && d.getTitle().length()!=0) StringTools.writeKeyValueLine(TITLE_TAG, \"\\\"\"+d.getTitle()+\"\\\";\", 5, this.getLineWidth(), null, TITLE_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(TITLE_TAG, \";\", 5, this.getLineWidth(), null, TITLE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(LOCATOR_TAG, d.getLocation()+\".\", 5, this.getLineWidth(), null, LOCATOR_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // db references - ranked\n        for (Iterator r = rs.getRankedCrossRefs().iterator(); r.hasNext(); ) {\n            RankedCrossRef rcr = (RankedCrossRef)r.next();\n            CrossRef c = rcr.getCrossRef();\n            Set noteset = c.getNoteSet();\n            StringBuffer sb = new StringBuffer();\n            sb.append(c.getDbname());\n            sb.append(\"; \");\n            sb.append(c.getAccession());\n            boolean hasSecondary = false;\n            for (Iterator i = noteset.iterator(); i.hasNext(); ) {\n                Note n = (Note)i.next();\n                if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                    sb.append(\"; \");\n                    sb.append(n.getValue());\n                    hasSecondary = true;\n                }\n            }\n            //if (!hasSecondary) sb.append(\"; -\"); \n            //sb.append(\".\");\n            if (!hasSecondary) sb.append(\";\");\n            else sb.append(\".\");\n            StringTools.writeKeyValueLine(DATABASE_XREF_TAG, sb.toString(), 5, this.getLineWidth(), null, DATABASE_XREF_TAG, this.getPrintStream());\n        }\n        if (!rs.getRankedCrossRefs().isEmpty())\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // comments - if any\n        if (!rs.getComments().isEmpty()) {\n            StringBuffer sb = new StringBuffer();\n            for (Iterator i = rs.getComments().iterator(); i.hasNext(); ) {\n                Comment c = (SimpleComment)i.next();\n                sb.append(c.getComment());\n                if (i.hasNext()) sb.append(\"\\n\");\n            }\n            StringTools.writeKeyValueLine(COMMENT_TAG, sb.toString(), 5, this.getLineWidth(), null, COMMENT_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        this.getPrintStream().println(FEATURE_HEADER_TAG+\"   Key             Location/Qualifiers\");\n        this.getPrintStream().println(FEATURE_HEADER_TAG+\"   \");\n        // feature_type     location\n        for (Iterator i = rs.getFeatureSet().iterator(); i.hasNext(); ) {\n            RichFeature f = (RichFeature)i.next();\n            StringTools.writeKeyValueLine(FEATURE_TAG+\"   \"+f.getTypeTerm().getName(), GenbankLocationParser.writeLocation((RichLocation)f.getLocation()), 21, this.getLineWidth(), \",\", FEATURE_TAG, this.getPrintStream());\n            for (Iterator j = f.getNoteSet().iterator(); j.hasNext(); ) {\n                Note n = (Note)j.next();\n                // /key=\"val\" or just /key if val==\"\"\n                if (n.getValue()==null || n.getValue().length()==0) StringTools.writeKeyValueLine(FEATURE_TAG, \"/\"+n.getTerm().getName(), 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n                else StringTools.writeKeyValueLine(FEATURE_TAG, \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n            // add-in to source feature only organism and db_xref=\"taxon:xyz\" where present\n            if (f.getType().equals(\"source\") && tax!=null) {\n                String displayName = tax.getDisplayName();\n                if (displayName.indexOf('(')>-1) displayName = displayName.substring(0, displayName.indexOf('(')).trim();\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/organism=\\\"\"+displayName+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/db_xref=\\\"taxon:\"+tax.getNCBITaxID()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n            // add-in other dbxrefs where present\n            for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                RankedCrossRef rcr = (RankedCrossRef)j.next();\n                CrossRef cr = rcr.getCrossRef();\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n        }\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // SQ   Sequence 1859 BP; 609 A; 314 C; 355 G; 581 T; 0 other;\n        int aCount = 0;\n        int cCount = 0;\n        int gCount = 0;\n        int tCount = 0;\n        int oCount = 0;\n        for (int i = 1; i <= rs.length(); i++) {\n            char c;\n            try {\n                c = tok.tokenizeSymbol(rs.symbolAt(i)).charAt(0);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Unable to get symbol at position \"+i,e);\n            }\n            switch (c) {\n                case 'a': case 'A':\n                    aCount++;\n                    break;\n                case 'c': case 'C':\n                    cCount++;\n                    break;\n                case 'g': case 'G':\n                    gCount++;\n                    break;\n                case 't': case 'T':\n                    tCount++;\n                    break;\n                default:\n                    oCount++;\n            }\n        }\n        this.getPrintStream().print(START_SEQUENCE_TAG+\"   Sequence \"+rs.length()+\" BP; \");\n        this.getPrintStream().print(aCount + \" A; \");\n        this.getPrintStream().print(cCount + \" C; \");\n        this.getPrintStream().print(gCount + \" G; \");\n        this.getPrintStream().print(tCount + \" T; \");\n        this.getPrintStream().println(oCount + \" other;\");\n        \n        // sequence stuff\n        Symbol[] syms = (Symbol[])rs.toList().toArray(new Symbol[0]);\n        int lineLen = 0;\n        int symCount = 0;\n        this.getPrintStream().print(\"    \");\n        for (int i = 0; i < syms.length; i++) {\n            if (symCount % 60 == 0 && symCount>0) {\n                this.getPrintStream().print(StringTools.leftPad(\"\"+symCount,10));\n                this.getPrintStream().print(\"\\n    \");\n                lineLen = 0;\n            }\n            if (symCount % 10 == 0) {\n                this.getPrintStream().print(\" \");\n                lineLen++;\n            }\n            try {\n                this.getPrintStream().print(tok.tokenizeSymbol(syms[i]));\n            } catch (IllegalSymbolException e) {\n                throw new RuntimeException(\"Found illegal symbol: \"+syms[i]);\n            }\n            symCount++;\n            lineLen++;\n        }\n        this.getPrintStream().print(StringTools.leftPad(\"\"+symCount,(66-lineLen)+10));\n        this.getPrintStream().print(\"\\n\");\n        this.getPrintStream().println(END_SEQUENCE_TAG);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultFormat() {\n        return EMBL_FORMAT;\n    }\n    \n    \n    /**\n     * Converts the current parse section to a String. Useful for debugging.\n     */\n    String sectionToString(List section){\n        StringBuffer parseBlock = new StringBuffer();\n        for(Iterator i = section.listIterator(); i.hasNext();){\n            String[] part = (String[])i.next();\n            for(int x = 0; x < part.length; x++){\n                parseBlock.append(part[x]);\n                if(x == 0){\n                    parseBlock.append(\"   \"); //the gap will have been trimmed\n                }\n            }\n        }\n        return parseBlock.toString();\n    }\n}\n\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage\torg.biojavax.bio.seq.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.seq.Sequence;\nimport org.biojava.bio.seq.io.ParseException;\nimport org.biojava.bio.seq.io.SeqIOListener;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.SimpleSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojavax.Comment;\nimport org.biojavax.CrossRef;\nimport org.biojavax.DocRef;\nimport org.biojavax.DocRefAuthor;\nimport org.biojavax.Namespace;\nimport org.biojavax.Note;\nimport org.biojavax.RankedCrossRef;\nimport org.biojavax.RankedDocRef;\nimport org.biojavax.RichAnnotation;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.SimpleComment;\nimport org.biojavax.SimpleCrossRef;\nimport org.biojavax.SimpleDocRef;\nimport org.biojavax.SimpleDocRefAuthor;\nimport org.biojavax.SimpleNote;\nimport org.biojavax.SimpleRankedCrossRef;\nimport org.biojavax.SimpleRankedDocRef;\nimport org.biojavax.SimpleRichAnnotation;\nimport org.biojavax.bio.seq.RichFeature;\nimport org.biojavax.bio.seq.RichLocation;\nimport org.biojavax.bio.seq.RichSequence;\nimport org.biojavax.bio.taxa.NCBITaxon;\nimport org.biojavax.bio.taxa.SimpleNCBITaxon;\nimport org.biojavax.ontology.ComparableTerm;\nimport org.biojavax.utils.StringTools;\n\n/**\n * Format reader for EMBL files. This version of EMBL format will generate\n * and write RichSequence objects. Loosely Based on code from the old, deprecated,\n * org.biojava.bio.seq.io.EmblLikeFormat object.\n * <p>\n * This format will read both Pre-87 and 87+ versions of EMBL. It will also write\n * them both. By default, it will write the most recent version. If you want\n * an earlier one, you must specify the format by passing one of the constants\n * defined in this class to {@link #writeSequence(Sequence, String, Namespace)}.\n *\n * @author Richard Holland\n * @author Jolyon Holdstock\n * @author Mark Schreiber\n * @since 1.5\n */\npublic class EMBLFormat extends RichSequenceFormat.HeaderlessFormat {\n    \n    // Register this format with the format auto-guesser.\n    static {\n        RichSequence.IOTools.registerFormat(EMBLFormat.class);\n    }\n    \n    /**\n     * The name of the Pre-87 format\n     */\n    public static final String EMBL_PRE87_FORMAT = \"EMBL_PRE87\";\n    \n    /**\n     * The name of the current format\n     */\n    public static final String EMBL_FORMAT = \"EMBL\";\n    \n    protected static final String LOCUS_TAG = \"ID\";\n    protected static final String ACCESSION_TAG = \"AC\";\n    protected static final String VERSION_TAG = \"SV\";\n    protected static final String DEFINITION_TAG = \"DE\";\n    protected static final String DATE_TAG = \"DT\";\n    protected static final String DATABASE_XREF_TAG = \"DR\";\n    protected static final String SOURCE_TAG = \"OS\";\n    protected static final String ORGANISM_TAG = \"OC\";\n    protected static final String ORGANELLE_TAG = \"OG\";\n    protected static final String REFERENCE_TAG = \"RN\";\n    protected static final String REFERENCE_POSITION_TAG = \"RP\";\n    protected static final String REFERENCE_XREF_TAG = \"RX\";\n    protected static final String AUTHORS_TAG = \"RA\";\n    protected static final String CONSORTIUM_TAG = \"RG\";\n    protected static final String TITLE_TAG = \"RT\";\n    protected static final String LOCATOR_TAG = \"RL\";\n    protected static final String REMARK_TAG = \"RC\";\n    protected static final String KEYWORDS_TAG = \"KW\";\n    protected static final String COMMENT_TAG = \"CC\";\n    protected static final String FEATURE_HEADER_TAG = \"FH\";\n    protected static final String FEATURE_TAG = \"FT\";\n    protected static final String CONTIG_TAG = \"CO\";\n    protected static final String TPA_TAG = \"AH\";\n    protected static final String START_SEQUENCE_TAG = \"SQ\";\n    protected static final String DELIMITER_TAG = \"XX\";\n    protected static final String END_SEQUENCE_TAG = \"//\";\n    \n    // the date pattern\n    // date (Rel. N, Created)\n    // date (Rel. N, Last updated, Version M)\n    protected static final Pattern dp = Pattern.compile(\"([^\\\\s]+)\\\\s*(\\\\(Rel\\\\.\\\\s+(\\\\d+), ([^\\\\)\\\\d]+)(\\\\d*)\\\\))?$\");\n    // locus line\n    protected static final Pattern lp = Pattern.compile(\"^(\\\\S+);\\\\s+SV\\\\s+(\\\\d+);\\\\s+(linear|circular);\\\\s+(\\\\S+\\\\s?\\\\S+?);\\\\s+(\\\\S+);\\\\s+(\\\\S+);\\\\s+(\\\\d+)\\\\s+(BP|AA)\\\\.$\");\n    protected static final Pattern lpPre87 = Pattern.compile(\"^(\\\\S+)\\\\s+standard;\\\\s+(circular)?\\\\s*(genomic)?\\\\s*(\\\\S+);\\\\s+(\\\\S+);\\\\s+\\\\d+\\\\s+BP\\\\.$\");\n    // version line\n    protected static final Pattern vp = Pattern.compile(\"^(\\\\S+?)\\\\.(\\\\d+)$\");\n    // reference position line\n    protected static final Pattern rpp = Pattern.compile(\"^(\\\\d+)(-(\\\\d+))?,?(\\\\s\\\\d+-\\\\d+,?)*$\");\n    // dbxref line\n    protected static final Pattern dbxp = Pattern.compile(\"^([^:]+):(\\\\S+)$\");\n    \n    protected static final Pattern readableFileNames = Pattern.compile(\".*\\\\u002e(em|dat).*\");\n    protected static final Pattern headerLine = Pattern.compile(\"^ID.*\");\n    \n    private NCBITaxon tax = null;\n    private String organism = null;\n    private String accession = null;\n    \n    /**\n     * Implements some EMBL-specific terms.\n     */\n    public static class Terms extends RichSequence.Terms {\n        \n        /**\n         * Getter for the RelUpdatedRecordVersion term\n         * @return The RelUpdatedRecordVersion Term\n         */\n        public static ComparableTerm getRelUpdatedRecordVersionTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"RelUpdatedRecordVersion\");\n        }\n        \n        /**\n         * Getter for the EMBL term\n         * @return The EMBL Term\n         */\n        public static ComparableTerm getEMBLTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"EMBL\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'genomic' term\n         * @return The genomic Term\n         */\n        public static ComparableTerm getGenomicTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"genomic\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'versionLine' term\n         * @return The version line Term\n         */\n        public static ComparableTerm getVersionLineTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"versionLine\");\n        }\n        \n        /**\n         * Getter for the Ensembl-specific 'dataClass' term\n         * @return The data class Term\n         */\n        public static ComparableTerm getDataClassTerm() {\n            return RichObjectFactory.getDefaultOntology().getOrCreateTerm(\"dataClass\");\n        }\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A file is in EMBL format if its name contains the word eem or edat, or the first line matches\n     * the EMBL format for the ID line.\n     */\n    public boolean canRead(File file) throws IOException {\n        if (readableFileNames.matcher(file.getName()).matches()) return true;\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches() &&\n                (lp.matcher(firstLine.substring(3).trim()).matches() ||\n                lpPre87.matcher(firstLine.substring(3).trim()).matches()\n                );\n        br.close();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Always returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(File file) throws IOException {\n        return RichSequence.IOTools.getDNAParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     * A stream is in EMBL format if its first line matches the EMBL format for the ID line.\n     */\n    public boolean canRead(BufferedInputStream stream) throws IOException {\n        stream.mark(2000); // some streams may not support this\n        BufferedReader br = new BufferedReader(new InputStreamReader(stream));\n        String firstLine = br.readLine();\n        boolean readable = firstLine!=null && headerLine.matcher(firstLine).matches() &&\n                (lp.matcher(firstLine.substring(3).trim()).matches() ||\n                lpPre87.matcher(firstLine.substring(3).trim()).matches()\n                );\n        // don't close the reader as it'll close the stream too.\n        // br.close();\n        stream.reset();\n        return readable;\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Always returns a DNA tokenizer.\n     */\n    public SymbolTokenization guessSymbolTokenization(BufferedInputStream stream) throws IOException {\n        return RichSequence.IOTools.getDNAParser();\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            SeqIOListener listener)\n            throws IllegalSymbolException, IOException, ParseException {\n        if (!(listener instanceof RichSeqIOListener)) throw new IllegalArgumentException(\"Only accepting RichSeqIOListeners today\");\n        return this.readRichSequence(reader,symParser,(RichSeqIOListener)listener,null);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public boolean readRichSequence(BufferedReader reader,\n            SymbolTokenization symParser,\n            RichSeqIOListener rlistener,\n            Namespace ns)\n            throws IllegalSymbolException, IOException, ParseException {\n        tax = null;\n        organism = null;\n        accession = null;\n        boolean hasAnotherSequence = true;\n        //boolean hasInternalWhitespace = false;\n        \n        rlistener.startSequence();\n        \n        if (ns==null) ns=RichObjectFactory.getDefaultNamespace();\n        rlistener.setNamespace(ns);\n        \n        // Get an ordered list of key->value pairs in array-tuples\n        String sectionKey = null;\n        do {\n            List section = this.readSection(reader);\n            sectionKey = ((String[])section.get(0))[0];\n            if(sectionKey == null){\n                \n                String message = ParseException.newMessage(this.getClass(), accession, \"No section key\", \"Not set\", sectionToString(section));\n                throw new ParseException(message);\n            }\n            // process section-by-section\n            if (sectionKey.equals(LOCUS_TAG)) {\n                // entryname  dataclass; [circular] molecule; division; sequencelength BP.\n                String loc = ((String[])section.get(0))[1];\n                Matcher m = lp.matcher(loc);\n                Matcher mPre87 = lpPre87.matcher(loc);\n                if (m.matches()) {\n                    // first token is both name and primary accession\n                    rlistener.setName(m.group(1));\n                    rlistener.setAccession(m.group(1));\n                    // second token is version\n                    rlistener.setVersion(Integer.parseInt(m.group(2)));\n                    // third token is circular/linear\n                    rlistener.setCircular(m.group(3).equals(\"circular\"));\n                    // fourth token is moltype\n                    rlistener.addSequenceProperty(Terms.getMolTypeTerm(),m.group(4));\n                    // fifth token is data class\n                    rlistener.addSequenceProperty(Terms.getDataClassTerm(),m.group(5));\n                    // sixth token is taxonomic division\n                    rlistener.setDivision(m.group(6));\n                    // seventh token is sequence length, which is ignored\n                    // as it is calculated from the sequence data later.\n                } else if (mPre87.matches()) {\n                    rlistener.setName(mPre87.group(1));\n                    if (mPre87.group(3)!=null) {\n                        // add annotation for 'genomic' (Ensembl-specific term)\n                        rlistener.addSequenceProperty(Terms.getGenomicTerm(),null);\n                    }\n                    rlistener.addSequenceProperty(Terms.getMolTypeTerm(),mPre87.group(4));\n                    rlistener.setDivision(mPre87.group(5));\n                    // Optional extras\n                    String circular = mPre87.group(2);\n                    if (circular!=null) rlistener.setCircular(true);\n                } else {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"Not Set\",\"Bad ID line found\", sectionToString(section));\n                    throw new ParseException(message);\n                }\n            } else if (sectionKey.equals(DEFINITION_TAG)) {\n                rlistener.setDescription(((String[])section.get(0))[1]);\n            } else if (sectionKey.equals(SOURCE_TAG)) {\n                // only interested in organelle sub-tag\n                for (int i = 1; i < section.size(); i++) {\n                    sectionKey = ((String[])section.get(i))[0];\n                    if (sectionKey.equals(ORGANELLE_TAG)) {\n                        rlistener.addSequenceProperty(Terms.getOrganelleTerm(), ((String[])section.get(i))[1].trim());\n                        break; // skip out of for loop once found\n                    }\n                }\n            } else if (sectionKey.equals(DATE_TAG)) {\n                String chunk = ((String[])section.get(0))[1].trim();\n                Matcher dm = dp.matcher(chunk);\n                if (dm.matches()) {\n                    String date = dm.group(1);\n                    String rel = dm.group(3);\n                    String type = dm.group(4);\n                    if (type.equals(\"Created\")) {\n                        rlistener.addSequenceProperty(Terms.getDateCreatedTerm(), date);\n                        rlistener.addSequenceProperty(Terms.getRelCreatedTerm(), rel);\n                    } else if (type.equals(\"Last updated, Version \")) {\n                        rlistener.addSequenceProperty(Terms.getDateUpdatedTerm(), date);\n                        rlistener.addSequenceProperty(Terms.getRelUpdatedTerm(), rel);\n                        rlistener.addSequenceProperty(Terms.getRelUpdatedRecordVersionTerm(), dm.group(5));\n                    } else {\n                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad date type found\",sectionToString(section));\n                        throw new ParseException(message);\n                    }\n                } else {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad date line found\",sectionToString(section));\n                    throw new ParseException(message);\n                    \n                }\n            } else if (sectionKey.equals(ACCESSION_TAG)) {\n                // if multiple accessions, store only first as accession,\n                // and store rest in annotation\n                String[] accs = ((String[])section.get(0))[1].split(\";\");\n                accession = accs[0].trim();\n                rlistener.setAccession(accession);\n                for (int i = 1; i < accs.length; i++) {\n                    rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accs[i].trim());\n                }\n            } else if (sectionKey.equals(VERSION_TAG)) {\n                String ver = ((String[])section.get(0))[1];\n                Matcher m = vp.matcher(ver);\n                if (m.matches()) {\n                    String verAcc = m.group(1);\n                    if (!accession.equals(verAcc)) {\n                        // the version refers to a different accession!\n                        // believe the version line, and store the original\n                        // accession away in the additional accession set\n                        rlistener.addSequenceProperty(Terms.getAdditionalAccessionTerm(),accession);\n                        accession = verAcc;\n                        rlistener.setAccession(accession);\n                    }\n                    rlistener.setVersion(Integer.parseInt(m.group(2)));\n                } else {\n                    rlistener.addSequenceProperty(Terms.getVersionLineTerm(),ver);\n                }\n            } else if (sectionKey.equals(KEYWORDS_TAG)) {\n                String val = ((String[])section.get(0))[1];\n                val = val.substring(0,val.length()-1); // chomp dot\n                val = val.replace('\\n',' '); //remove newline\n                String[] kws = val.split(\";\");\n                for (int i = 0; i < kws.length; i++) {\n                    String kw = kws[i].trim();\n                    if (kw.length()==0) continue;\n                    rlistener.addSequenceProperty(Terms.getKeywordTerm(), kw);\n                }\n            } else if (sectionKey.equals(DATABASE_XREF_TAG)) {\n                String val = ((String[])section.get(0))[1];\n                val = val.substring(0,val.length()-1); // chomp dot\n                // database_identifier; primary_identifier; secondary_identifier....\n                String[] parts = val.split(\";\");\n                // construct a DBXREF out of the dbname part[0] and accession part[1]\n                CrossRef crossRef = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{parts[0].trim(),parts[1].trim(), new Integer(0)});\n                // assign remaining bits of info as annotations\n                for (int j = 2; j < parts.length; j++) {\n                    Note note = new SimpleNote(Terms.getAdditionalAccessionTerm(),parts[j].trim(),j-1);\n                    try {\n                        crossRef.getRichAnnotation().addNote(note);\n                    } catch (ChangeVetoException ce) {\n                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Could not annotate identifier terms\",sectionToString(section));\n                        ParseException pe = new ParseException(message);\n                        pe.initCause(ce);\n                        throw pe;\n                    }\n                }\n                RankedCrossRef rcrossRef = new SimpleRankedCrossRef(crossRef, 0);\n                rlistener.setRankedCrossRef(rcrossRef);\n            } else if (sectionKey.equals(REFERENCE_TAG) && !this.getElideReferences()) {\n                // first line of section has rank and location\n                String refrank = ((String[])section.get(0))[1];\n                int ref_rank = Integer.parseInt(refrank.substring(1,refrank.length()-1));\n                int ref_start = -999;\n                int ref_end = -999;\n                // rest can be in any order\n                String consortium = null;\n                String authors = \"\";\n                String title = null;\n                String locator = null;\n                String pubmed = null;\n                String medline = null;\n                String doi = null;\n                String remark = null;\n                for (int i = 1; i < section.size(); i++) {\n                    String key = ((String[])section.get(i))[0];\n                    String val = ((String[])section.get(i))[1];\n                    if (key.equals(AUTHORS_TAG)) {\n                        if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                        authors = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(CONSORTIUM_TAG)) {\n                        if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                        consortium = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(TITLE_TAG)) {\n                        if (val.length()>1) {\n                            if (val.endsWith(\";\")) val = val.substring(0,val.length()-1); // chomp semicolon\n                            if (val.endsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // chomp quotes\n                            title = val.replace('\\n',' '); //see #2276\n                        } else title=null; // single semi-colon indicates no title\n                    }\n                    if (key.equals(LOCATOR_TAG)) {\n                        if (val.endsWith(\".\")) val = val.substring(0,val.length()-1); // chomp dot\n                        locator = val.replace('\\n',' '); //see #2276\n                    }\n                    if (key.equals(REFERENCE_XREF_TAG)) {\n                        // database_identifier; primary_identifier.\n                        String[] refs = val.split(\"\\\\.(\\\\s+|$)\");\n                        for (int j = 0 ; j < refs.length; j++) {\n                            if (refs[j].trim().length()==0) continue;\n                            String[] parts = refs[j].split(\";\");\n                            String db = parts[0];\n                            String ref = parts[1].trim();\n                            if (db.equalsIgnoreCase(Terms.PUBMED_KEY)) pubmed = ref;\n                            else if (db.equalsIgnoreCase(Terms.MEDLINE_KEY)) medline = ref;\n                            else if (db.equalsIgnoreCase(Terms.DOI_KEY)) doi = ref;\n                        }\n                    }\n                    if (key.equals(REMARK_TAG)) remark = val.replace('\\n',' '); //see #2276\n                    if (key.equals(REFERENCE_POSITION_TAG)) {\n                        // only the first group is taken\n                        // if we have multiple lines, only the last line is taken\n                        Matcher m = rpp.matcher(val);\n                        if (m.matches()) {\n                            ref_start = Integer.parseInt(m.group(1));\n                            if(m.group(2) != null)\n                                ref_end = Integer.parseInt(m.group(3));\n                        } else {\n                            String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad reference line found\",sectionToString(section));\n                            throw new ParseException(message);\n                        }\n                    }\n                }\n                // create the docref object\n                try {\n                    List authSet = DocRefAuthor.Tools.parseAuthorString(authors);\n                    if (consortium!=null) authSet.add(new SimpleDocRefAuthor(consortium, true, false));\n                    DocRef dr = (DocRef)RichObjectFactory.getObject(SimpleDocRef.class,new Object[]{authSet,locator,title});\n                    // assign either the pubmed or medline to the docref - medline gets priority, then pubmed, then doi\n                    if (medline!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.MEDLINE_KEY, medline, new Integer(0)}));\n                    else if (pubmed!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.PUBMED_KEY, pubmed, new Integer(0)}));\n                    else if (doi!=null) dr.setCrossref((CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{Terms.DOI_KEY, doi, new Integer(0)}));\n                    // assign the remarks\n                    if (!this.getElideComments()) dr.setRemark(remark);\n                    // assign the docref to the bioentry\n                    RankedDocRef rdr = new SimpleRankedDocRef(dr,\n                            (ref_start != -999 ? new Integer(ref_start) : null),\n                            (ref_end != -999 ? new Integer(ref_end) : null),\n                            ref_rank);\n                    rlistener.setRankedDocRef(rdr);\n                } catch (ChangeVetoException e) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                    throw new ParseException(e, message);\n                }\n            } else if (sectionKey.equals(COMMENT_TAG) && !this.getElideComments()) {\n                // Set up some comments\n                rlistener.setComment(((String[])section.get(0))[1]);\n            } else if (sectionKey.equals(FEATURE_TAG) && !this.getElideFeatures()) {\n                // starting from second line of input, start a new feature whenever we come across\n                // a key that does not start with /\n                boolean seenAFeature = false;\n                int rcrossrefCount = 0;\n                for (int i = 1 ; i < section.size(); i++) {\n                    String key = ((String[])section.get(i))[0];\n                    String val = ((String[])section.get(i))[1];\n                    if (key.startsWith(\"/\")) {\n                        key = key.substring(1); // strip leading slash\n                        val = val.replaceAll(\"\\\\s*[\\\\n\\\\r]+\\\\s*\",\" \").trim();\n                        if (val.startsWith(\"\\\"\")) val = val.substring(1,val.length()-1); // strip quotes\n                        // parameter on old feature\n                        if (key.equalsIgnoreCase(\"db_xref\")) {\n                            Matcher m = dbxp.matcher(val);\n                            if (m.matches()) {\n                                String dbname = m.group(1);\n                                String raccession = m.group(2);\n                                if (dbname.equalsIgnoreCase(\"taxon\")) {\n                                    // Set the Taxon instead of a dbxref\n                                    tax = (NCBITaxon)RichObjectFactory.getObject(SimpleNCBITaxon.class, new Object[]{Integer.valueOf(raccession)});\n                                    rlistener.setTaxon(tax);\n                                    try {\n                                        if (organism!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism);\n                                    } catch (ChangeVetoException e) {\n                                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                        throw new ParseException(e, message);\n                                    }\n                                } else {\n                                    try {\n                                        CrossRef cr = (CrossRef)RichObjectFactory.getObject(SimpleCrossRef.class,new Object[]{dbname, raccession, new Integer(0)});\n                                        RankedCrossRef rcr = new SimpleRankedCrossRef(cr, ++rcrossrefCount);\n                                        rlistener.getCurrentFeature().addRankedCrossRef(rcr);\n                                    } catch (ChangeVetoException e) {\n                                        String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                        throw new ParseException(e, message);\n                                    }\n                                }\n                            } else {\n                                String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad dbxref found\",sectionToString(section));\n                                throw new ParseException(message);\n                            }\n                        } else if (key.equalsIgnoreCase(\"organism\")) {\n                            try {\n                                organism = val;\n                                if (tax!=null) tax.addName(NCBITaxon.SCIENTIFIC,organism);\n                            } catch (ChangeVetoException e) {\n                                String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"\",sectionToString(section));\n                                throw new ParseException(message);\n                            }\n                        } else {\n                            if (key.equalsIgnoreCase(\"translation\")) {\n                                // strip spaces from sequence\n                                val = val.replaceAll(\"\\\\s+\",\"\");\n                            }\n                            rlistener.addFeatureProperty(RichObjectFactory.getDefaultOntology().getOrCreateTerm(key),val);\n                        }\n                    } else {\n                        // new feature!\n                        // end previous feature\n                        if (seenAFeature) rlistener.endFeature();\n                        // start next one, with lots of lovely info in it\n                        RichFeature.Template templ = new RichFeature.Template();\n                        templ.annotation = new SimpleRichAnnotation();\n                        templ.sourceTerm = Terms.getEMBLTerm();\n                        templ.typeTerm = RichObjectFactory.getDefaultOntology().getOrCreateTerm(key);\n                        templ.featureRelationshipSet = new TreeSet();\n                        templ.rankedCrossRefs = new TreeSet();\n                        String tidyLocStr = val.replaceAll(\"\\\\s+\",\"\");\n                        templ.location = GenbankLocationParser.parseLocation(ns, accession, tidyLocStr);\n                        rlistener.startFeature(templ);\n                        seenAFeature = true;\n                        rcrossrefCount = 0;\n                    }\n                }\n                if (seenAFeature) rlistener.endFeature();\n            } else if (sectionKey.equals(START_SEQUENCE_TAG) && !this.getElideSymbols()) {\n                StringBuffer seq = new StringBuffer();\n                for (int i = 0 ; i < section.size(); i++) seq.append(((String[])section.get(i))[1]);\n                try {\n                    SymbolList sl = new SimpleSymbolList(symParser,\n                            seq.toString().replaceAll(\"\\\\s+\",\"\").replaceAll(\"[\\\\.|~]\",\"-\"));\n                    rlistener.addSymbols(symParser.getAlphabet(),\n                            (Symbol[])(sl.toList().toArray(new Symbol[0])),\n                            0, sl.length());\n                } catch (Exception e) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad sequence\",sectionToString(section));\n                    throw new ParseException(e, message);\n                }\n            }\n        } while (!sectionKey.equals(END_SEQUENCE_TAG));\n        \n        // Allows us to tolerate trailing whitespace without\n        // thinking that there is another Sequence to follow\n        while (true) {\n            reader.mark(1);\n            int c = reader.read();\n            if (c == -1) {\n                hasAnotherSequence = false;\n                break;\n            }\n            if (Character.isWhitespace((char) c)) {\n                //hasInternalWhitespace = true;\n                continue;\n            }\n            //if (hasInternalWhitespace)\n            //    System.err.println(\"Warning: whitespace found between sequence entries\");\n            reader.reset();\n            break;\n        }\n        \n        // Finish up.\n        rlistener.endSequence();\n        return hasAnotherSequence;\n    }\n    \n    // reads an indented section, combining split lines and creating a list of key->value tuples\n    private List readSection(BufferedReader br) throws ParseException {\n        List section = new ArrayList();\n        String line;\n        boolean done = false;\n        \n        // while not done\n        try {\n            while (!done) {\n                // mark buffer\n                br.mark(160);\n                // read token\n                line = br.readLine();\n                if (line.length()<2) {\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Bad line found\",line);\n                    throw new ParseException(message);\n                }\n                String token = line.substring(0,2);\n                // READ SEQUENCE SECTION\n                if (token.equals(START_SEQUENCE_TAG)) {\n                    //      from next line, read sequence until // - leave // on stack\n                    StringBuffer sb = new StringBuffer();\n                    while (!done) {\n                        br.mark(160);\n                        line = br.readLine();\n                        if (line.startsWith(END_SEQUENCE_TAG)) {\n                            br.reset();\n                            done = true;\n                        } else {\n                            //      create sequence tag->value pair to return, sans numbers\n                            sb.append(line.replaceAll(\"\\\\d\",\"\"));\n                        }\n                    }\n                    section.add(new String[]{START_SEQUENCE_TAG,sb.toString()});\n                }\n                // READ FEATURE TABLE SECTION\n                else if (token.equals(FEATURE_HEADER_TAG)) {\n                    //      create dummy feature tag->value pair and add to return set\n                    section.add(new String[]{FEATURE_TAG,null});\n                    //      drop next FH line\n                    line = br.readLine(); // skip next line too - it is also FH\n                    //      read all FT lines until XX\n                    String currentTag = null;\n                    StringBuffer currentVal = null;\n                    while (!done) {\n                        line = br.readLine();\n                        if (line.startsWith(DELIMITER_TAG)) {\n                            done = true;\n                            // dump current tag if exists\n                            if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                        } else {\n                            //         FT lines:   FT   word            value\n                            //         or          FT                   /word\n                            //         or          FT                   /db_xref=\"taxon:3899....\n                            //                                          ......\"\n                            line = line.substring(5); // chomp off \"FT   \"\n                            if (!line.startsWith(\" \")) {\n                                // dump current tag if exists\n                                if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                // case 1 : word value - splits into key-value on its own\n                                String[] parts = line.trim().split(\"\\\\s+\");\n                                currentTag = parts[0];\n                                currentVal = new StringBuffer();\n                                currentVal.append(parts[1]);\n                            } else {\n                                line = line.trim();\n                                if (line.startsWith(\"/\")) {\n                                    // dump current tag if exists\n                                    if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                    // case 2 : /word[=.....]\n                                    currentVal = new StringBuffer();\n                                    int equalIndex = line.indexOf('=');\n                                    if (equalIndex>=0) {\n                                        currentTag = line.substring(0, equalIndex);\n                                        currentVal.append(line.substring(equalIndex+1));\n                                    } else {\n                                        currentTag = line;\n                                    }\n                                } else {\n                                    // case 3 : ....\"\n                                    currentVal.append(\"\\n\");\n                                    currentVal.append(line);\n                                }\n                            }\n                        }\n                    }\n                }\n                // READ END OF SEQUENCE\n                else if (token.equals(END_SEQUENCE_TAG)) {\n                    section.add(new String[]{END_SEQUENCE_TAG,null});\n                    done = true;\n                }\n                // READ DELIMITER TAG\n                else if (token.equals(DELIMITER_TAG)) {\n                    section.add(new String[]{DELIMITER_TAG,null});\n                    done = true;\n                }\n                // READ THIRD PARTY ANNOTATION SECTION\n                else if (token.equals(TPA_TAG)) {\n                    //      exception = don't know how to do TPA yet\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle TPAs just yet\",sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // READ CONTIG SECTION\n                else if (token.equals(CONTIG_TAG)) {\n                    //      exception = don't know how to do contigs yet\n                    String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle contig assemblies just yet\",sectionToString(section));\n                    throw new ParseException(message);\n                }\n                // READ DOCREF\n                else if (token.equals(DATABASE_XREF_TAG)) {\n                    section.add(new String[]{DATABASE_XREF_TAG,line.substring(5).trim()});\n                    done = true;\n                }\n                // READ DATE\n                else if (token.equals(DATE_TAG)) {\n                    section.add(new String[]{DATE_TAG,line.substring(5).trim()});\n                    done = true;\n                }\n                // READ NORMAL TAG/VALUE SECTION\n                else {\n                    //      rewind buffer to mark\n                    br.reset();\n                    //      read token/values until XX\n                    String currentTag = null;\n                    StringBuffer currentVal = null;\n                    while (!done) {\n                        line = br.readLine();\n                        if (line.startsWith(DELIMITER_TAG)) {\n                            done = true;\n                            // dump current tag if exists\n                            if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                        } else {\n                            try {\n                                //      merge neighbouring repeated tokens by concatting values\n                                //      return tag->value pairs\n                                String tag = line.substring(0,2);\n                                String value = line.substring(5);\n                                if (currentTag==null || !tag.equals(currentTag)) {\n                                    // dump current tag if exists\n                                    if (currentTag!=null) section.add(new String[]{currentTag,currentVal.toString()});\n                                    // start new tag\n                                    currentTag = tag;\n                                    currentVal = new StringBuffer();\n                                    currentVal.append(value);\n                                } else {\n                                    currentVal.append(\"\\n\");\n                                    currentVal.append(value);\n                                }\n                            } catch (Exception e) {\n                                String message = ParseException.newMessage(this.getClass(), accession, \"not set\",\"\",sectionToString(section));\n                                throw new ParseException(e, message);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            String message = ParseException.newMessage(this.getClass(),accession,\"not set\", \"Unable to handle TPAs just yet\",sectionToString(section));\n            throw new ParseException(message);\n        }\n        return section;\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void\twriteSequence(Sequence seq, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public void writeSequence(Sequence seq, String format, PrintStream os) throws IOException {\n        if (this.getPrintStream()==null) this.setPrintStream(os);\n        this.writeSequence(seq, format, RichObjectFactory.getDefaultNamespace());\n    }\n    \n    /**\n     * {@inheritDoc}\n     * Namespace is ignored as EMBL has no concept of it.\n     */\n    public void writeSequence(Sequence seq, Namespace ns) throws IOException {\n        this.writeSequence(seq, this.getDefaultFormat(), ns);\n    }\n    \n    /**\n     * As per {@link #writeSequence(Sequence, Namespace)}, except\n     * that it also takes a format parameter. This can be any of the formats\n     * defined as constants in this class.\n     * @param seq see {@link #writeSequence(Sequence, Namespace)}\n     * @param format the format to use.\n     * @param ns see {@link #writeSequence(Sequence, Namespace)}\n     * @throws IOException see {@link #writeSequence(Sequence, Namespace)}\n     */\n    public void writeSequence(Sequence seq, String format, Namespace ns) throws IOException {\n        if (!format.equals(EMBL_FORMAT) && !format.equals(EMBL_PRE87_FORMAT))\n            throw new IllegalArgumentException(\"Format \"+format+\" not recognised.\");\n        \n        RichSequence rs;\n        try {\n            if (seq instanceof RichSequence) rs = (RichSequence)seq;\n            else rs = RichSequence.Tools.enrich(seq);\n        } catch (ChangeVetoException e) {\n            IOException e2 = new IOException(\"Unable to enrich sequence\");\n            e2.initCause(e);\n            throw e2;\n        }\n        \n        SymbolTokenization tok;\n        try {\n            tok = rs.getAlphabet().getTokenization(\"token\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to get alphabet tokenizer\",e);\n        }\n        \n        Set notes = rs.getNoteSet();\n        String accession = rs.getAccession();\n        StringBuffer accessions = new StringBuffer();\n        accessions.append(accession);\n        accessions.append(\";\");\n        String cdat = null;\n        String udat = null;\n        String crel = null;\n        String urel = null;\n        String urecv = null;\n        String organelle = null;\n        String versionLine = null;\n        String dataClass = \"STD\";\n        boolean genomic = false;\n        String moltype = rs.getAlphabet().getName();\n        for (Iterator i = notes.iterator(); i.hasNext(); ) {\n            Note n = (Note)i.next();\n            if (n.getTerm().equals(Terms.getDateCreatedTerm())) cdat=n.getValue();\n            else if (n.getTerm().equals(Terms.getDateUpdatedTerm())) udat=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelCreatedTerm())) crel=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelUpdatedTerm())) urel=n.getValue();\n            else if (n.getTerm().equals(Terms.getRelUpdatedRecordVersionTerm())) urecv=n.getValue();\n            else if (n.getTerm().equals(Terms.getMolTypeTerm())) moltype=n.getValue();\n            else if (n.getTerm().equals(Terms.getVersionLineTerm())) versionLine=n.getValue();\n            else if (n.getTerm().equals(Terms.getGenomicTerm())) genomic = true;\n            else if (n.getTerm().equals(Terms.getDataClassTerm())) dataClass = n.getValue();\n            else if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                accessions.append(\" \");\n                accessions.append(n.getValue());\n                accessions.append(\";\");\n            } else if (n.getTerm().equals(Terms.getOrganelleTerm())) organelle=n.getValue();\n        }\n        \n        StringBuffer locusLine = new StringBuffer();\n        if (format.equals(EMBL_FORMAT)) {\n            // accession; SV version; circular/linear; moltype; dataclass; division; length BP.\n            locusLine.append(rs.getAccession());\n            locusLine.append(\"; SV \");\n            locusLine.append(rs.getVersion());\n            locusLine.append(\"; \");\n            locusLine.append(rs.getCircular()?\"circular\":\"linear\");\n            locusLine.append(\"; \");\n            locusLine.append(moltype);\n            locusLine.append(\"; \");\n            locusLine.append(dataClass);\n            locusLine.append(\"; \");\n            locusLine.append(rs.getDivision());\n            locusLine.append(\"; \");\n            locusLine.append(rs.length());\n            locusLine.append(\" BP.\");\n        } else if (format.equals(EMBL_PRE87_FORMAT)) {\n            // entryname  dataclass; [circular] molecule; division; sequencelength BP.\n            locusLine.append(StringTools.rightPad(rs.getName(),9));\n            locusLine.append(\" standard; \");\n            locusLine.append(rs.getCircular()?\"circular \":\"\");\n            // if it is Ensembl genomic, add that in too\n            if (genomic==true) locusLine.append(\"genomic \");\n            locusLine.append(moltype);\n            locusLine.append(\"; \");\n            locusLine.append(rs.getDivision()==null?\"\":rs.getDivision());\n            locusLine.append(\"; \");\n            locusLine.append(rs.length());\n            locusLine.append(\" BP.\");\n        }\n        StringTools.writeKeyValueLine(LOCUS_TAG, locusLine.toString(), 5, this.getLineWidth(), null, LOCUS_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // accession line\n        StringTools.writeKeyValueLine(ACCESSION_TAG, accessions.toString(), 5, this.getLineWidth(), null, ACCESSION_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // version line\n        if (format.equals(EMBL_PRE87_FORMAT)) {\n            if (versionLine!=null) StringTools.writeKeyValueLine(VERSION_TAG, versionLine, 5, this.getLineWidth(), null, VERSION_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(VERSION_TAG, accession+\".\"+rs.getVersion(), 5, this.getLineWidth(), null, VERSION_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // date line\n        StringTools.writeKeyValueLine(DATE_TAG, (cdat==null?udat:cdat)+\" (Rel. \"+(crel==null?\"0\":crel)+\", Created)\", 5, this.getLineWidth(), null, DATE_TAG, this.getPrintStream());\n        StringTools.writeKeyValueLine(DATE_TAG, udat+\" (Rel. \"+(urel==null?\"0\":urel)+\", Last updated, Version \"+(urecv==null?\"0\":urecv)+\")\", 5, this.getLineWidth(), null, DATE_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // definition line\n        StringTools.writeKeyValueLine(DEFINITION_TAG, rs.getDescription(), 5, this.getLineWidth(), null, DEFINITION_TAG, this.getPrintStream());\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // keywords line\n        StringBuffer keywords = new StringBuffer();\n        for (Iterator n = notes.iterator(); n.hasNext(); ) {\n            Note nt = (Note)n.next();\n            if (nt.getTerm().equals(Terms.getKeywordTerm())) {\n                if (keywords.length()>0) keywords.append(\"; \");\n                keywords.append(nt.getValue());\n            }\n        }\n        if (keywords.length()>0) {\n            keywords.append(\".\");\n            StringTools.writeKeyValueLine(KEYWORDS_TAG, keywords.toString(), 5, this.getLineWidth(), null, KEYWORDS_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        } else {\n            this.getPrintStream().println(KEYWORDS_TAG+\"   .\");\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // source line (from taxon)\n        //   organism line\n        NCBITaxon tax = rs.getTaxon();\n        if (tax!=null) {\n            StringTools.writeKeyValueLine(SOURCE_TAG, tax.getDisplayName(), 5, this.getLineWidth(), null, SOURCE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(ORGANISM_TAG, tax.getNameHierarchy(), 5, this.getLineWidth(), null, SOURCE_TAG, this.getPrintStream());\n            if (organelle!=null) StringTools.writeKeyValueLine(ORGANELLE_TAG, organelle, 5, this.getLineWidth(), null, ORGANELLE_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // references - rank (bases x to y)\n        for (Iterator r = rs.getRankedDocRefs().iterator(); r.hasNext(); ) {\n            RankedDocRef rdr = (RankedDocRef)r.next();\n            DocRef d = rdr.getDocumentReference();\n            // RN, RC, RP, RX, RG, RA, RT, RL\n            StringTools.writeKeyValueLine(REFERENCE_TAG, \"[\"+rdr.getRank()+\"]\", 5, this.getLineWidth(), null, REFERENCE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(REMARK_TAG, d.getRemark(), 5, this.getLineWidth(), null, REMARK_TAG, this.getPrintStream());\n            Integer rstart = rdr.getStart();\n            if (rstart==null) rstart = new Integer(1);\n            Integer rend = rdr.getEnd();\n            if (rend==null) rend = new Integer(rs.length());\n            StringTools.writeKeyValueLine(REFERENCE_POSITION_TAG, rstart+\"-\"+rend, 5, this.getLineWidth(), null, REFERENCE_POSITION_TAG, this.getPrintStream());\n            CrossRef c = d.getCrossref();\n            if (c!=null) StringTools.writeKeyValueLine(REFERENCE_XREF_TAG, c.getDbname()+\"; \"+c.getAccession()+\".\", 5, this.getLineWidth(), null, REFERENCE_XREF_TAG, this.getPrintStream());\n            List auths = d.getAuthorList();\n            for (Iterator j = auths.iterator(); j.hasNext(); ) {\n                DocRefAuthor a = (DocRefAuthor)j.next();\n                if (a.isConsortium()) {\n                    StringTools.writeKeyValueLine(CONSORTIUM_TAG, a+\";\", 5, this.getLineWidth(), null, CONSORTIUM_TAG, this.getPrintStream());\n                    j.remove();\n                }\n            }\n            if (!auths.isEmpty()) StringTools.writeKeyValueLine(AUTHORS_TAG, DocRefAuthor.Tools.generateAuthorString(auths, true)+\";\", 5, this.getLineWidth(), null, AUTHORS_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(AUTHORS_TAG, \";\", 5, this.getLineWidth(), null, AUTHORS_TAG, this.getPrintStream());\n            if (d.getTitle()!=null && d.getTitle().length()!=0) StringTools.writeKeyValueLine(TITLE_TAG, \"\\\"\"+d.getTitle()+\"\\\";\", 5, this.getLineWidth(), null, TITLE_TAG, this.getPrintStream());\n            else StringTools.writeKeyValueLine(TITLE_TAG, \";\", 5, this.getLineWidth(), null, TITLE_TAG, this.getPrintStream());\n            StringTools.writeKeyValueLine(LOCATOR_TAG, d.getLocation()+\".\", 5, this.getLineWidth(), null, LOCATOR_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        // db references - ranked\n        for (Iterator r = rs.getRankedCrossRefs().iterator(); r.hasNext(); ) {\n            RankedCrossRef rcr = (RankedCrossRef)r.next();\n            CrossRef c = rcr.getCrossRef();\n            Set noteset = c.getNoteSet();\n            StringBuffer sb = new StringBuffer();\n            sb.append(c.getDbname());\n            sb.append(\"; \");\n            sb.append(c.getAccession());\n            boolean hasSecondary = false;\n            for (Iterator i = noteset.iterator(); i.hasNext(); ) {\n                Note n = (Note)i.next();\n                if (n.getTerm().equals(Terms.getAdditionalAccessionTerm())) {\n                    sb.append(\"; \");\n                    sb.append(n.getValue());\n                    hasSecondary = true;\n                }\n            }\n            //if (!hasSecondary) sb.append(\"; -\"); \n            //sb.append(\".\");\n            if (!hasSecondary) sb.append(\";\");\n            else sb.append(\".\");\n            StringTools.writeKeyValueLine(DATABASE_XREF_TAG, sb.toString(), 5, this.getLineWidth(), null, DATABASE_XREF_TAG, this.getPrintStream());\n        }\n        if (!rs.getRankedCrossRefs().isEmpty())\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // comments - if any\n        if (!rs.getComments().isEmpty()) {\n            StringBuffer sb = new StringBuffer();\n            for (Iterator i = rs.getComments().iterator(); i.hasNext(); ) {\n                Comment c = (SimpleComment)i.next();\n                sb.append(c.getComment());\n                if (i.hasNext()) sb.append(\"\\n\");\n            }\n            StringTools.writeKeyValueLine(COMMENT_TAG, sb.toString(), 5, this.getLineWidth(), null, COMMENT_TAG, this.getPrintStream());\n            this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        }\n        \n        this.getPrintStream().println(FEATURE_HEADER_TAG+\"   Key             Location/Qualifiers\");\n        this.getPrintStream().println(FEATURE_HEADER_TAG+\"   \");\n        // feature_type     location\n        for (Iterator i = rs.getFeatureSet().iterator(); i.hasNext(); ) {\n            RichFeature f = (RichFeature)i.next();\n            StringTools.writeKeyValueLine(FEATURE_TAG+\"   \"+f.getTypeTerm().getName(), GenbankLocationParser.writeLocation((RichLocation)f.getLocation()), 21, this.getLineWidth(), \",\", FEATURE_TAG, this.getPrintStream());\n            for (Iterator j = f.getNoteSet().iterator(); j.hasNext(); ) {\n                Note n = (Note)j.next();\n                // /key=\"val\" or just /key if val==\"\"\n                if (n.getValue()==null || n.getValue().length()==0) StringTools.writeKeyValueLine(FEATURE_TAG, \"/\"+n.getTerm().getName(), 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n                else StringTools.writeKeyValueLine(FEATURE_TAG, \"/\"+n.getTerm().getName()+\"=\\\"\"+n.getValue()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n            // add-in to source feature only organism and db_xref=\"taxon:xyz\" where present\n            if (f.getType().equals(\"source\") && tax!=null) {\n                String displayName = tax.getDisplayName();\n                if (displayName.indexOf('(')>-1) displayName = displayName.substring(0, displayName.indexOf('(')).trim();\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/organism=\\\"\"+displayName+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/db_xref=\\\"taxon:\"+tax.getNCBITaxID()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n            // add-in other dbxrefs where present\n            for (Iterator j = f.getRankedCrossRefs().iterator(); j.hasNext(); ) {\n                RankedCrossRef rcr = (RankedCrossRef)j.next();\n                CrossRef cr = rcr.getCrossRef();\n                StringTools.writeKeyValueLine(FEATURE_TAG, \"/db_xref=\\\"\"+cr.getDbname()+\":\"+cr.getAccession()+\"\\\"\", 21, this.getLineWidth(), null, FEATURE_TAG, this.getPrintStream());\n            }\n        }\n        this.getPrintStream().println(DELIMITER_TAG+\"   \");\n        \n        // SQ   Sequence 1859 BP; 609 A; 314 C; 355 G; 581 T; 0 other;\n        int aCount = 0;\n        int cCount = 0;\n        int gCount = 0;\n        int tCount = 0;\n        int oCount = 0;\n        for (int i = 1; i <= rs.length(); i++) {\n            char c;\n            try {\n                c = tok.tokenizeSymbol(rs.symbolAt(i)).charAt(0);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Unable to get symbol at position \"+i,e);\n            }\n            switch (c) {\n                case 'a': case 'A':\n                    aCount++;\n                    break;\n                case 'c': case 'C':\n                    cCount++;\n                    break;\n                case 'g': case 'G':\n                    gCount++;\n                    break;\n                case 't': case 'T':\n                    tCount++;\n                    break;\n                default:\n                    oCount++;\n            }\n        }\n        this.getPrintStream().print(START_SEQUENCE_TAG+\"   Sequence \"+rs.length()+\" BP; \");\n        this.getPrintStream().print(aCount + \" A; \");\n        this.getPrintStream().print(cCount + \" C; \");\n        this.getPrintStream().print(gCount + \" G; \");\n        this.getPrintStream().print(tCount + \" T; \");\n        this.getPrintStream().println(oCount + \" other;\");\n        \n        // sequence stuff\n        Symbol[] syms = (Symbol[])rs.toList().toArray(new Symbol[0]);\n        int lineLen = 0;\n        int symCount = 0;\n        this.getPrintStream().print(\"    \");\n        for (int i = 0; i < syms.length; i++) {\n            if (symCount % 60 == 0 && symCount>0) {\n                this.getPrintStream().print(StringTools.leftPad(\"\"+symCount,10));\n                this.getPrintStream().print(\"\\n    \");\n                lineLen = 0;\n            }\n            if (symCount % 10 == 0) {\n                this.getPrintStream().print(\" \");\n                lineLen++;\n            }\n            try {\n                this.getPrintStream().print(tok.tokenizeSymbol(syms[i]));\n            } catch (IllegalSymbolException e) {\n                throw new RuntimeException(\"Found illegal symbol: \"+syms[i]);\n            }\n            symCount++;\n            lineLen++;\n        }\n        this.getPrintStream().print(StringTools.leftPad(\"\"+symCount,(66-lineLen)+10));\n        this.getPrintStream().print(\"\\n\");\n        this.getPrintStream().println(END_SEQUENCE_TAG);\n    }\n    \n    /**\n     * {@inheritDoc}\n     */\n    public String getDefaultFormat() {\n        return EMBL_FORMAT;\n    }\n    \n    \n    /**\n     * Converts the current parse section to a String. Useful for debugging.\n     */\n    String sectionToString(List section){\n        StringBuffer parseBlock = new StringBuffer();\n        for(Iterator i = section.listIterator(); i.hasNext();){\n            String[] part = (String[])i.next();\n            for(int x = 0; x < part.length; x++){\n                parseBlock.append(part[x]);\n                if(x == 0){\n                    parseBlock.append(\"   \"); //the gap will have been trimmed\n                }\n            }\n        }\n        return parseBlock.toString();\n    }\n}\n\n","originTest":"package org.biojavax.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport junit.framework.TestCase;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojavax.Namespace;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.bio.seq.RichSequence;\n\n/**\n * Tests for EMBLFormat.\n * \n * @author George Waldon\n */\npublic class EMBLFormatTest extends TestCase {\n    private EMBLFormat emblFormat;\n\n    /**\n     * @see junit.framework.TestCase#setUp()\n     */\n    protected void setUp() {\n        this.emblFormat = new EMBLFormat();\n    }\n\n    /** Test whether the parser reads minimal sequences. The sequence prototype\n     * was generated by writing in EMBL format a sequence initially \n     * read from a fasta file (\">lcl|test.0| no sequence\").\n     * Note that EMBL-formatted files require a non-empty accession ; \n     * sequence names are lost and are replaced by accessions. \n     */\n    public void testReadEmptySequence() {\n        RichSequence sequence = readFile(\"/empty_embl.embl\");\n        assertNotNull(sequence);\n        assertEquals(sequence.getName(), \"test\");\n        assertEquals(sequence.getAccession(), \"test\");\n        assertEquals(sequence.getVersion(), 0);\n        assertEquals(sequence.getDescription(), \"no sequence\");\n        assertEquals(sequence.getInternalSymbolList().length(), 0);\n    }\n\n    /**\n     * Read an uniprot file, return a RichSequence\n     * @param filename name of file to read\n     * @return a RichSequence instance\n     */\n    private RichSequence readFile(String filename) {\n        InputStream inStream = this.getClass().getResourceAsStream(filename);\n        BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n        SymbolTokenization tokenization = RichSequence.IOTools.getDNAParser();\n        Namespace namespace = RichObjectFactory.getDefaultNamespace();\n        SimpleRichSequenceBuilder builder = new SimpleRichSequenceBuilder();\n        RichSequence sequence = null;\n        try {\n            this.emblFormat.readRichSequence(br, tokenization, builder, namespace);\n            sequence = builder.makeRichSequence();\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(\"Unexpected exception: \"+e);\n        }\n\t\treturn sequence;\n\t}\n}\n","changedTest":"package org.biojavax.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport junit.framework.TestCase;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojavax.Namespace;\nimport org.biojavax.RichObjectFactory;\nimport org.biojavax.bio.seq.RichSequence;\n\n/**\n * Tests for EMBLFormat.\n * \n * @author George Waldon\n */\npublic class EMBLFormatTest extends TestCase {\n    private EMBLFormat emblFormat;\n\n    /**\n     * @see junit.framework.TestCase#setUp()\n     */\n    @Override\n    protected void setUp() {\n        this.emblFormat = new EMBLFormat();\n    }\n\n    /** Test whether the parser reads minimal DNA sequences. The sequence prototype\n     * was generated by writing in EMBL format a DNA sequence originally\n     * read from a FASTA file (\">lcl|test.0| no sequence\").\n     * Note that EMBL-formatted files require a non-empty accession ; \n     * sequence names are lost and are replaced by accessions. \n     */\n    public void testReadEmptyDNASequence() {\n        RichSequence sequence = readDNAFile(\"/empty_embl.embl\");\n        assertNotNull(sequence);\n        assertEquals(sequence.getName(), \"test\");\n        assertEquals(sequence.getAccession(), \"test\");\n        assertEquals(sequence.getVersion(), 0);\n        assertEquals(sequence.getDescription(), \"no sequence\");\n        assertEquals(sequence.getInternalSymbolList().length(), 0);\n    }\n\n    public void testReadEMBLProteinFile() {\n        RichSequence sequence = readProteinFile(\"/A00060.emblp\");\n    }\n\n    /**\n     * Read a DNA file, return a RichSequence\n     * @param filename name of file to read\n     * @return a RichSequence instance\n     */\n    private RichSequence readDNAFile(String filename) {\n        InputStream inStream = this.getClass().getResourceAsStream(filename);\n        BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n        SymbolTokenization tokenization = RichSequence.IOTools.getDNAParser();\n        Namespace namespace = RichObjectFactory.getDefaultNamespace();\n        SimpleRichSequenceBuilder builder = new SimpleRichSequenceBuilder();\n        RichSequence sequence = null;\n        try {\n            this.emblFormat.readRichSequence(br, tokenization, builder, namespace);\n            sequence = builder.makeRichSequence();\n        } catch (Exception e) {\n            fail(\"Unexpected exception: \" + e);\n        }\n        return sequence;\n    }\n\n    /**\n     * Read a Protein file, return a RichSequence\n     * @param filename name of file to read\n     * @return a RichSequence instance\n     */\n    private RichSequence readProteinFile(String filename) {\n        InputStream inStream = this.getClass().getResourceAsStream(filename);\n        BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n        SymbolTokenization tokenization = RichSequence.IOTools.getProteinParser();\n        Namespace namespace = RichObjectFactory.getDefaultNamespace();\n        SimpleRichSequenceBuilder builder = new SimpleRichSequenceBuilder();\n        RichSequence sequence = null;\n        try {\n            this.emblFormat.readRichSequence(br, tokenization, builder, namespace);\n            sequence = builder.makeRichSequence();\n        } catch (Exception e) {\n            fail(\"Unexpected exception: \" + e);\n        }\n        return sequence;\n    }\n}\n","commitMessage":"Parsing of protein files in EMBL  format (see #3137).\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8253 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Parsing of protein files in EMBL  format (see #3137).\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8253 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}