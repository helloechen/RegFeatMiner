{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/SuperPositionQCP.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestSuperPositionQCP.java","prod_time":"2016-09-09 19:06:44","test_time":"","type":"","proType":"EDIT","add_annotation_line":2,"add_call_line":11,"add_classname_line":1,"add_condition_line":1,"add_field_line":2,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":8,"add_return_line":3,"del_annotation_line":0,"del_call_line":1,"del_classname_line":1,"del_condition_line":0,"del_field_line":2,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"34f4fdf41cb462e0b60ee80ef3217dbf8f1bfb37","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Usage:\n * <p>\n * The input consists of 2 Point3d arrays of equal length. The input coordinates\n * are not changed.\n * <pre>\n *    Point3d[] x = ...\n *    Point3d[] y = ...\n *    SuperPositionQCP qcp = new SuperPositionQCP();\n *    qcp.set(x, y);\n * </pre>\n * <p>   \n * or with weighting factors [0 - 1]]\n * <pre>\n *    double[] weights = ...\n *    qcp.set(x, y, weights);\n * </pre>\n * <p>   \n * For maximum efficiency, create a SuperPositionQCP object once and reuse it.\n * <p>\n * A. Calculate rmsd only\n * <pre>\n * \t  double rmsd = qcp.getRmsd();\n * </pre>\n * <p>\n * B. Calculate a 4x4 transformation (rotation and translation) matrix\n * <pre>\n *    Matrix4d rottrans = qcp.getTransformationMatrix();\n * </pre>\n * <p>\n * C. Get transformated points (y superposed onto the reference x)\n * <pre>\n *    Point3d[] ySuperposed = qcp.getTransformedCoordinates();\n * </pre> \n * <p>\n * Citations:\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2011)\n * Reply to comment on: \"Fast determination of the optimal rotation matrix for macromolecular superpositions.\"\n * Journal of Computational Chemistry 32(1):185-186. [http://dx.doi.org/10.1002/jcc.21606]\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2010)\n * \"Fast determination of the optimal rotation matrix for macromolecular superpositions.\"\n * Journal of Computational Chemistry 31(7):1561-1563. [http://dx.doi.org/10.1002/jcc.21439]\n * <p>\n * Douglas L Theobald (2005)\n * \"Rapid calculation of RMSDs using a quaternion-based characteristic polynomial.\"\n * Acta Crystallogr A 61(4):478-480. [http://dx.doi.org/10.1107/S0108767305015266 ]\n * <p>\n * This is an adoption of the original C code QCProt 1.4 (2012, October 10) to Java. \n * The original C source code is available from http://theobald.brandeis.edu/qcp/ and was developed by\n * <p>\n * Douglas L. Theobald\n * Department of Biochemistry\n * MS 009\n * Brandeis University\n * 415 South St\n * Waltham, MA  02453\n * USA\n * <p>\n * dtheobald@brandeis.edu\n * <p>              \n * Pu Liu\n * Johnson & Johnson Pharmaceutical Research and Development, L.L.C.\n * 665 Stockton Drive\n * Exton, PA  19341\n * USA\n * <p>\n * pliu24@its.jnj.com\n * <p>\n * @author Douglas L. Theobald (original C code)\n * @author Pu Liu (original C code)\n * @author Peter Rose (adopted to Java)\n * @author Aleix Lafita (adopted to Java) \n */\npublic final class SuperPositionQCP {\n\t\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SuperPositionQCP.class);\n\n\t/**\n\t * The required eigenvector precission\n\t */\n\tprivate static final double EVEC_PREC = 1E-6;\n\t\n\t/**\n\t * The required eigenvalue precission\n\t */\n\tprivate static final double EVAL_PREC = 1E-11;\n\n\tprivate Point3d[] x;\n\tprivate Point3d[] y;\n\n\tprivate double[] weight;\n\tprivate double wsum;\n\n\tprivate Point3d[] xref;\n\tprivate Point3d[] yref;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n    /**\n     * Default constructor\n     */\n    public SuperPositionQCP() {\n    \tthis.centered = false;\n    }\n    \n    /**\n     * Constructor with option to set centered flag. This constructor\n     * should be used if both coordinate input set have been centered at the origin.\n     * @param centered if set true, the input coordinates are already centered at the origin\n     */\n    public SuperPositionQCP(boolean centered) {\n\t\tthis.centered = centered;\n\t}\n\n\t/**\n     * Sets the two input coordinate arrays. These input arrays must be of\n     * equal length. Input coordinates are not modified.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     */\n\tpublic void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n    /**\n     * Sets the two input coordinate arrays and weight array. \n     * All input arrays must be of equal length. \n     * Input coordinates are not modified.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     * @param weight a weight in the inclusive range [0,1] for each point\n     */\n\tpublic void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void setCentered(boolean centered) {\n\t\tthis.centered = centered;\n\t}\n\n\t/**\n     * Return the RMSD of the superposition of input coordinate set y onto x.\n     * Note, this is the fasted way to calculate an RMSD without actually\n     * superposing the two sets. The calculation is performed \"lazy\", meaning\n     * calculations are only performed if necessary.\n     * @return root mean square deviation for superposition of y onto x\n     */\n\tpublic double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t}\n\t\treturn rmsd;\n\t}\n\n    /**\n     * Returns a 4x4 transformation matrix that transforms the y coordinates onto the x coordinates.\n     * The calculation is performed \"lazy\", meaning calculations are only performed if necessary.\n     * @return 4x4 transformation matrix to transform y coordinates onto x\n     */\n\tpublic Matrix4d getTransformationMatrix() {\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\tpublic Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t}\n\t\treturn rotmat;\n\t}\n\n    /**\n     * Returns the transformed (superposed) y coordinates\n     * TODO this is actually returning a transformation of the x coordinates, we should review if that's correct and change it if not\n     * @return transformed y coordinates\n     */\n\tpublic Point3d[] getTransformedCoordinates() {\n\t\tCalcPoint.transform(transformation, x);\n\t\treturn x;\n\t}\n\n    /**\n     * Calculates the RMSD value for superposition of y onto x.\n     * This requires the coordinates to be precentered.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = CalcPoint.clonePoint3dArray(x);\n\t\t\txtrans = CalcPoint.centroid(xref);\n\t\t\tlogger.debug(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tCalcPoint.translate(xtrans, xref);\n\n\t\t\tyref = CalcPoint.clonePoint3dArray(y);\n\t\t\tytrans = CalcPoint.centroid(yref);\n\t\t\tlogger.debug(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tCalcPoint.translate(ytrans, yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(wsum);\n\t}\n\n\t/**\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\t\t\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\t\t\n\t\t// combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n     * Calculates the inner product between two coordinate sets x and y (optionally weighted,\n     * if weights set through {@link #set(Point3d[], Point3d[], double[])}). It also\n     * calculates an upper bound of the most positive root of the key matrix. \n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t * \n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\twsum = 0;\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\t\n\t\t\t\twsum += weight[i];\n\t\t\t\t\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y\n\t\t\t\t\t\t+ coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y\n\t\t\t\t\t\t+ coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t\twsum = coords1.length;\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(double len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0\n\t\t\t\t* (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx\n\t\t\t\t- Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2)\n\t\t\t\t* (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 1; i < 51; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(EVAL_PREC*mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50) {\n\t\t\tlogger.warn(String.format(\"More than %d iterations needed!\", i));\n\t\t} else {\n\t\t\tlogger.info(String.format(\"%d iterations needed!\", i));\n\t\t}\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < EVEC_PREC) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12\n\t\t\t\t\t\t* a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11\n\t\t\t\t\t\t* a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11\n\t\t\t\t\t\t* a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34\n\t\t\t\t\t\t\t* a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33\n\t\t\t\t\t\t\t* a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\tlogger.debug(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Usage:\n * <p>\n * The input consists of 2 Point3d arrays of equal length. The input coordinates\n * are not changed.\n * <pre>\n *    Point3d[] x = ...\n *    Point3d[] y = ...\n *    SuperPositionQCP qcp = new SuperPositionQCP();\n *    qcp.set(x, y);\n * </pre>\n * <p>   \n * or with weighting factors [0 - 1]]\n * <pre>\n *    double[] weights = ...\n *    qcp.set(x, y, weights);\n * </pre>\n * <p>   \n * For maximum efficiency, create a SuperPositionQCP object once and reuse it.\n * <p>\n * A. Calculate rmsd only\n * <pre>\n * \t  double rmsd = qcp.getRmsd();\n * </pre>\n * <p>\n * B. Calculate a 4x4 transformation (rotation and translation) matrix\n * <pre>\n *    Matrix4d rottrans = qcp.getTransformationMatrix();\n * </pre>\n * <p>\n * C. Get transformated points (y superposed onto the reference x)\n * <pre>\n *    Point3d[] ySuperposed = qcp.getTransformedCoordinates();\n * </pre> \n * <p>\n * Citations:\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2011)\n * Reply to comment on: \"Fast determination of the optimal rotation matrix for macromolecular superpositions.\"\n * Journal of Computational Chemistry 32(1):185-186. [http://dx.doi.org/10.1002/jcc.21606]\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2010)\n * \"Fast determination of the optimal rotation matrix for macromolecular superpositions.\"\n * Journal of Computational Chemistry 31(7):1561-1563. [http://dx.doi.org/10.1002/jcc.21439]\n * <p>\n * Douglas L Theobald (2005)\n * \"Rapid calculation of RMSDs using a quaternion-based characteristic polynomial.\"\n * Acta Crystallogr A 61(4):478-480. [http://dx.doi.org/10.1107/S0108767305015266 ]\n * <p>\n * This is an adoption of the original C code QCProt 1.4 (2012, October 10) to Java. \n * The original C source code is available from http://theobald.brandeis.edu/qcp/ and was developed by\n * <p>\n * Douglas L. Theobald\n * Department of Biochemistry\n * MS 009\n * Brandeis University\n * 415 South St\n * Waltham, MA  02453\n * USA\n * <p>\n * dtheobald@brandeis.edu\n * <p>              \n * Pu Liu\n * Johnson & Johnson Pharmaceutical Research and Development, L.L.C.\n * 665 Stockton Drive\n * Exton, PA  19341\n * USA\n * <p>\n * pliu24@its.jnj.com\n * <p>\n * @author Douglas L. Theobald (original C code)\n * @author Pu Liu (original C code)\n * @author Peter Rose (adopted to Java)\n * @author Aleix Lafita (adopted to Java) \n */\npublic final class SuperPositionQCP extends SuperPositionAbstract {\n\t\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(SuperPositionQCP.class);\n\n\tprivate double EVEC_PREC = 1E-6;\n\tprivate double EVAL_PREC = 1E-11;\n\n\tprivate Point3d[] x;\n\tprivate Point3d[] y;\n\n\tprivate double[] weight;\n\tprivate double wsum;\n\n\tprivate Point3d[] xref;\n\tprivate Point3d[] yref;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n\t/**\n\t * Default constructor for the quaternion based superposition algorithm.\n\t * \n\t * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n\t */\n    public SuperPositionQCP(boolean centered) {\n    \tsuper(centered);\n    }\n    \n    /**\n     * Constructor with option to set the precision values.\n     * \n     * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n     * @param evec_prec required eigenvector precision\n     * @param eval_prec required eigenvalue precision\n     */\n    public SuperPositionQCP(boolean centered, double evec_prec, double eval_prec) {\n    \tsuper(centered);\n    \tEVEC_PREC = evec_prec;\n    \tEVAL_PREC = eval_prec;\n\t}\n\n\t/**\n     * Sets the two input coordinate arrays. These input arrays must be of\n     * equal length. Input coordinates are not modified.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     */\n\tprivate void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n    /**\n     * Sets the two input coordinate arrays and weight array. \n     * All input arrays must be of equal length. \n     * Input coordinates are not modified.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     * @param weight a weight in the inclusive range [0,1] for each point\n     */\n\tprivate void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void setCentered(boolean centered) {\n\t\tthis.centered = centered;\n\t}\n\n\t/**\n     * Return the RMSD of the superposition of input coordinate set y onto x.\n     * Note, this is the fasted way to calculate an RMSD without actually\n     * superposing the two sets. The calculation is performed \"lazy\", meaning\n     * calculations are only performed if necessary.\n     * @return root mean square deviation for superposition of y onto x\n     */\n\tprivate double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t}\n\t\treturn rmsd;\n\t}\n\n    @Override\n    public Matrix4d superpose(Point3d[] fixed, Point3d[] moved) {\n    \tset(fixed, moved);\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n    \n    /**\n     * Weighted superposition.\n     * \n     * @param fixed\n     * @param moved\n     * @param weight array of weigths for each equivalent point position\n     * @return\n     */\n    public Matrix4d weightedSuperpose(Point3d[] fixed, Point3d[] moved, double[] weight) {\n    \tset(fixed, moved, weight);\n    \tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n    }\n\n\tprivate Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t}\n\t\treturn rotmat;\n\t}\n\n    /**\n     * Calculates the RMSD value for superposition of y onto x.\n     * This requires the coordinates to be precentered.\n     * @param x 3d points of reference coordinate set\n     * @param y 3d points of coordinate set for superposition\n     */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = CalcPoint.clonePoint3dArray(x);\n\t\t\txtrans = CalcPoint.centroid(xref);\n\t\t\tlogger.debug(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tCalcPoint.translate(xtrans, xref);\n\n\t\t\tyref = CalcPoint.clonePoint3dArray(y);\n\t\t\tytrans = CalcPoint.centroid(yref);\n\t\t\tlogger.debug(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tCalcPoint.translate(ytrans, yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(wsum);\n\t}\n\n\t/**\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\t\t\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\t\t\n\t\t// combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n     * Calculates the inner product between two coordinate sets x and y (optionally weighted,\n     * if weights set through {@link #set(Point3d[], Point3d[], double[])}). It also\n     * calculates an upper bound of the most positive root of the key matrix. \n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t * \n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\twsum = 0;\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\t\n\t\t\t\twsum += weight[i];\n\t\t\t\t\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y\n\t\t\t\t\t\t+ coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y\n\t\t\t\t\t\t+ coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t\twsum = coords1.length;\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(double len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0\n\t\t\t\t* (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx\n\t\t\t\t- Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2)\n\t\t\t\t* (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 1; i < 51; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(EVAL_PREC*mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50) {\n\t\t\tlogger.warn(String.format(\"More than %d iterations needed!\", i));\n\t\t} else {\n\t\t\tlogger.info(String.format(\"%d iterations needed!\", i));\n\t\t}\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < EVEC_PREC) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12\n\t\t\t\t\t\t* a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11\n\t\t\t\t\t\t* a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11\n\t\t\t\t\t\t* a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34\n\t\t\t\t\t\t\t* a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33\n\t\t\t\t\t\t\t* a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < EVEC_PREC) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\tlogger.debug(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic double getRmsd(Point3d[] fixed, Point3d[] moved) {\n\t\tset(fixed, moved);\n\t\treturn getRmsd();\n\t}\n\t\n\t/** \n\t * @param fixed\n\t * @param moved\n\t * @param weight array of weigths for each equivalent point position\n\t * @return weighted RMSD.\n\t */\n\tpublic double getWeightedRmsd(Point3d[] fixed, Point3d[] moved, double[] weight) {\n\t\tset(fixed, moved, weight);\n\t\treturn getRmsd();\n\t}\n\n}\n","originTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test the Quaternion-Based Characteristic Polynomial {@link SuperPositionQCP}\n * algorithm for RMSD and Superposition calculations.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestSuperPositionQCP {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(TestSuperPositionQCP.class);\n\n\tprivate List<Point3d[]> cloud1;\n\tprivate List<Point3d[]> cloud2;\n\n\tprivate AxisAngle4d rotAxis;\n\tprivate Vector3d translation;\n\tprivate Matrix4d transform;\n\n\t/**\n\t * Generate two clouds of random points of different sizes to test\n\t * correctness and performance of superposition algorithms.\n\t * \n\t * @throws StructureException\n\t */\n\t@Before\n\tpublic void setUp() throws StructureException {\n\n\t\tcloud1 = new ArrayList<Point3d[]>(5);\n\t\tcloud2 = new ArrayList<Point3d[]>(5);\n\n\t\tRandom rnd = new Random(0);\n\n\t\trotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\t\ttranslation = new Vector3d(0.345, 2.453, 5.324);\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\n\t\tList<Integer> sizes = Arrays.asList(5, 50, 500, 5000, 50000, 500000);\n\n\t\tfor (Integer size : sizes) {\n\n\t\t\tPoint3d[] c1 = new Point3d[size];\n\t\t\tPoint3d[] c2 = new Point3d[size];\n\n\t\t\tfor (int p = 0; p < size; p++) {\n\n\t\t\t\tPoint3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50),\n\t\t\t\t\t\trnd.nextInt(150));\n\t\t\t\tc1[p] = a;\n\n\t\t\t\t// Add some noise\n\t\t\t\tPoint3d b = new Point3d(a.x + rnd.nextDouble(), a.y\n\t\t\t\t\t\t+ rnd.nextDouble(), a.z + rnd.nextDouble());\n\t\t\t\tc2[p] = b;\n\t\t\t}\n\n\t\t\tCalcPoint.center(c1);\n\t\t\tCalcPoint.center(c2);\n\n\t\t\tCalcPoint.transform(transform, c1);\n\n\t\t\tcloud1.add(c1);\n\t\t\tcloud2.add(c2);\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the transformation matrix from superposition\n\t * {@link SuperPositionQCP#getTransformationMatrix()},\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testTransformationMatrix() throws StructureException {\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\t\t\t// Use SVD superposition to obtain the optimal transformation matrix\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1.get(c),\n\t\t\t\t\tcloud2.get(c));\n\t\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\tPoint3d[] c2c = CalcPoint.clonePoint3dArray(cloud2.get(c));\n\n\t\t\t// Use SuperPosition to obtain the optimal transformation matrix\n\t\t\tlong spStart = System.nanoTime();\n\t\t\tMatrix4d spTransform = SuperPosition.superposeWithTranslation(c2c,\n\t\t\t\t\tcloud1.get(c));\n\t\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\n\t\t\t// Use QCP algorithm to get the optimal transformation matrix\n\t\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\t\tqcp.set(cloud2.get(c), cloud1.get(c));\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tMatrix4d qcpTransform = qcp.getTransformationMatrix();\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tlogger.info(String.format(\"Transformation Matrix %d points: \"\n\t\t\t\t\t+ \"SVD time %d us, SP time: %d us, QCP time: %d us\",\n\t\t\t\t\tcloud1.get(c).length, svdTime, spTime, qcpTime));\n\n\t\t\t// Check that the transformation matrix was recovered\n\t\t\tassertTrue(transform.epsilonEquals(svdTransform, 0.01));\n\t\t\tassertTrue(transform.epsilonEquals(spTransform, 0.01));\n\t\t\tassertTrue(transform.epsilonEquals(qcpTransform, 0.01));\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the RMSD of a superposition\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testRMSD() throws StructureException {\n\n\t\tfor (int c = 0; c < cloud1.size(); c++) {\n\t\t\tPoint3d[] c2c = CalcPoint.clonePoint3dArray(cloud2.get(c));\n\n\t\t\t// Use SVD superposition to obtain the RMSD\n\t\t\tlong svdStart = System.nanoTime();\n\t\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1.get(c),\n\t\t\t\t\tcloud2.get(c));\n\t\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\t\tCalcPoint.transform(svdTransform, c2c);\n\t\t\tdouble svdrmsd = SuperPosition.rmsd(cloud1.get(c), c2c);\n\t\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t\tc2c = CalcPoint.clonePoint3dArray(cloud2.get(c));\n\n\t\t\t// Use SVD superposition to obtain the RMSD\n\t\t\tlong spStart = System.nanoTime();\n\t\t\tSuperPosition.superposeWithTranslation(c2c, cloud1.get(c));\n\t\t\tdouble sprmsd = SuperPosition.rmsd(c2c, cloud1.get(c));\n\t\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\n\t\t\t// Use QCP algorithm to obtain the RMSD\n\t\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\t\tqcp.set(cloud2.get(c), cloud1.get(c));\n\t\t\tlong qcpStart = System.nanoTime();\n\t\t\tdouble qcprmsd = qcp.getRmsd();\n\t\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\t\tlogger.info(String.format(\"RMSD %d points: SVD time %d us, \"\n\t\t\t\t\t+ \"SP time: %d us, QCP time: %d us\", cloud1.get(c).length,\n\t\t\t\t\tsvdTime, spTime, qcpTime));\n\n\t\t\t// Check that the returned RMSDs are equal\n\t\t\tassertEquals(svdrmsd, sprmsd, 0.001);\n\t\t\tassertEquals(svdrmsd, qcprmsd, 0.001);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testSymmetryQCP() {\n\n\t\tPoint3d[] set1 = new Point3d[16];\n\t\tset1[0] = new Point3d(14.065934, 47.068832, -32.895836);\n\t\tset1[1] = new Point3d(-14.065934, -47.068832, -32.895836);\n\t\tset1[2] = new Point3d(-47.068832, 14.065934, -32.895836);\n\t\tset1[3] = new Point3d(47.068832, -14.065934, -32.895836);\n\t\tset1[4] = new Point3d(-14.065934, 47.068832, 32.895836);\n\t\tset1[5] = new Point3d(14.065934, -47.068832, 32.895836);\n\t\tset1[6] = new Point3d(47.068832, 14.065934, 32.895836);\n\t\tset1[7] = new Point3d(-47.068832, -14.065934, 32.895836);\n\t\tset1[8] = new Point3d(43.813946, 22.748293, -32.14434);\n\t\tset1[9] = new Point3d(-43.813946, -22.748293, -32.14434);\n\t\tset1[10] = new Point3d(-22.748293, 43.813946, -32.14434);\n\t\tset1[11] = new Point3d(22.748293, -43.813946, -32.14434);\n\t\tset1[12] = new Point3d(-43.813946, 22.748293, 32.14434);\n\t\tset1[13] = new Point3d(43.813946, -22.748293, 32.14434);\n\t\tset1[14] = new Point3d(22.748293, 43.813946, 32.14434);\n\t\tset1[15] = new Point3d(-22.748293, -43.813946, 32.14434);\n\n\t\tPoint3d[] set2 = CalcPoint.clonePoint3dArray(set1);\n\t\tCalcPoint.transform(transform, set2);\n\n\t\t// Use SP superposition to obtain the RMSD\n\t\tlong spStart = System.nanoTime();\n\t\tSuperPosition.superposeWithTranslation(set1, set2);\n\t\tdouble sprmsd = SuperPosition.rmsd(set1, set2);\n\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\n\t\tset2 = CalcPoint.clonePoint3dArray(set1);\n\n\t\t// Use QCP algorithm to get the RMSD\n\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\tqcp.set(set1, set2);\n\t\tlong qcpStart = System.nanoTime();\n\t\tdouble qcprmsd = qcp.getRmsd();\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\tlogger.info(String.format(\"RMSD Symmetry: SP time: %d us\"\n\t\t\t\t+ \", QCP time: %d us\", spTime, qcpTime));\n\n\t\t// Check that the returned RMSDs are equal\n\t\tassertEquals(sprmsd, qcprmsd, 0.001);\n\n\t}\n\n}\n","changedTest":"","commitMessage":"All superposition algorithms implement the SuperPosition interface\n\n#558","test_commitMessage":"","allZero":false}