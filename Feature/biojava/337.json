{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/scop/ScopInstallation.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/scop/ScopInstallationTest.java","prod_time":"2015-03-09 23:44:37","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":7,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":5,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"0c4954b72b418bb5d7e0270d2da08304b58698f2","test_commitID":"","isfound":"not found test change","originPro":"/**\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n * \n * Author: Andreas Prlic\n * \n * \n */\n\npackage org.biojava.nbio.structure.scop;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n\n/** This class provides access to the SCOP protein structure classification.\n * \n * For more information about SCOP see here:\n *  <ul>\n *   <li>SCOP: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/\">http://scop.mrc-lmb.cam.ac.uk/scop/</a></li>\n\n *  <li> Introduction: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/intro.html\">http://scop.mrc-lmb.cam.ac.uk/scop/intro.html</a> </li>\n\n *   <li> SCOP parsable files: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/parse/\">http://scop.mrc-lmb.cam.ac.uk/scop/parse/</a> </li>\n * </ul>\n\n * \n * This class can automatically download missing files from the SCOP classification.\n * \n * @author Andreas Prlic\n *\n */\npublic class ScopInstallation implements LocalScopDatabase {\n\n\tpublic static final String DEFAULT_VERSION = \"1.75\";\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScopInstallation.class);\n\n\tprotected String scopVersion;\n\t\n\t// Stores URLs for cla, des, hie, and com files\n\tprivate final List<ScopMirror> mirrors;\n\n\t// Cache filenames (with version appended)\n\tpublic static final String claFileName = \"dir.cla.scop.txt_\";\n\tpublic static final String desFileName = \"dir.des.scop.txt_\";\n\tpublic static final String hieFileName = \"dir.hie.scop.txt_\";\n\tpublic static final String comFileName = \"dir.com.scop.txt_\";\n\n\t// Download locations\n\tpublic static final String SCOP_DOWNLOAD = \"http://scop.mrc-lmb.cam.ac.uk/scop/parse/\";\n\tpublic static final String SCOP_DOWNLOAD_ALTERNATE = \"http://scop.berkeley.edu/downloads/parse/\";\n\t\n\tpublic static final String NEWLINE;\n\tpublic static final String FILESPLIT ;\n\n\tstatic {\n\n\t\tNEWLINE     = System.getProperty(\"line.separator\");\n\t\tFILESPLIT   = System.getProperty(\"file.separator\");\n\t}\n\n\tString cacheLocation ;\n\n\tAtomicBoolean installedCla;\n\tAtomicBoolean installedDes;\n\tAtomicBoolean installedHie;\n\tAtomicBoolean installedCom;\n\n\tMap<Integer, List<String>> commentsMap;\n\tMap<String, List<ScopDomain>> domainMap;\n\tMap<Integer, ScopDescription> sunidMap;\n\tMap<Integer, ScopNode> scopTree;\n\n\n\t/** Create a new SCOP installation. \n\t * \n\t * @param cacheLocation where the SCOP files are stored. If they can't be found at that location they will get automatically downloaded and installed there. \n\t */\n\tpublic ScopInstallation(String cacheLocation){\n\n\t\tsetCacheLocation(cacheLocation);\n\n\t\tinstalledCla = new AtomicBoolean();\n\t\tinstalledCla.set(false);\n\t\tinstalledDes = new AtomicBoolean();\n\t\tinstalledDes.set(false);\n\t\tinstalledHie = new AtomicBoolean();\n\t\tinstalledHie.set(false);\n\t\tinstalledCom = new AtomicBoolean();\n\t\tinstalledCom.set(false);\n\n\t\tscopVersion = DEFAULT_VERSION;\n\t\tmirrors = new ArrayList<ScopMirror>(1);\n\n\t\tdomainMap = new HashMap<String, List<ScopDomain>>();\n\n\t\tsunidMap  = new HashMap<Integer, ScopDescription>();\n\t\tscopTree  = new TreeMap<Integer, ScopNode>();\n\n\t}\n\n\t/**\n\t * Removes all of the comments (dir.com file) in order to free memory. The file will need to be reloaded if {@link #getComments(int)} is called subsequently.\n\t */\n\tpublic void nullifyComments() {\n\t\tcommentsMap = null;\n\t}\n\t\n\t/**\n\t * Create a new SCOP installation, downloading the file to \"the right place\".\n\t * This will first check for system properties or environmental variables\n\t * called {@link UserConfiguration#PDB_CACHE_DIR}, or else will use a temporary directory\n\t */\n\tpublic ScopInstallation() {\n\t\tthis((new UserConfiguration()).getCacheFilePath());\n\t}\n\n\tpublic void ensureClaInstalled() throws IOException {\n\t\tif (installedCla.get()) return;\n\t\tif (!claFileAvailable()) downloadClaFile();\n\t\tparseClassification();\n\t\tinstalledCla.set(true);\n\t}\n\n\tpublic void ensureDesInstalled() throws IOException {\n\t\tif (installedDes.get()) return;\n\t\tif (!desFileAvailable()) downloadDesFile();\n\t\tparseDescriptions();\n\t\tinstalledDes.set(true);\n\t}\n\n\tpublic void ensureComInstalled() throws IOException {\n\t\tif (installedCom.get()) return;\n\t\tif (!comFileAvailable()) downloadComFile();\n\t\tparseComments();\n\t\tinstalledCom.set(true);\n\t}\n\n\tpublic void ensureHieInstalled() throws IOException {\n\t\tif ( installedHie.get()) return;\n\t\tif ( ! hieFileAvailable()) downloadHieFile();\n\t\tparseHierarchy();\n\t\tinstalledHie.set(true);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getByCategory(org.biojava.nbio.structure.scop.ScopCategory)\n\t */\n\t@Override\n\tpublic List<ScopDescription> getByCategory(ScopCategory category){\n\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\t\t\tif ( sc.getCategory().equals(category))\n\n\t\t\t\ttry {\n\t\t\t\t\tmatches.add((ScopDescription)sc.clone());\n\t\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\t\tthrow new RuntimeException(\"Could not clone \" + ScopDescription.class + \" subclass\", e);\n\t\t\t\t}\n\n\t\t}\n\t\treturn matches;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByClassificationId(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDescription> filterByClassificationId(String query){\n\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\n\n\t\t\tif( sc.getClassificationId().startsWith(query)){\n\t\t\t\tmatches.add(sc);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getTree(org.biojava.nbio.structure.scop.ScopDomain)\n\t */\n\t@Override\n\tpublic List<ScopNode> getTree(ScopDomain domain){\n\t\tScopNode node = getScopNode(domain.getSunid());\n\n\n\t\tList<ScopNode> tree = new ArrayList<ScopNode>();\n\t\twhile (node != null){\n\n\t\t\t//System.out.println(\"This node: sunid:\" + node.getSunid() );\n\t\t\t//System.out.println(getScopDescriptionBySunid(node.getSunid()));\n\t\t\tnode = getScopNode(node.getParentSunid());\n\t\t\tif ( node != null)\n\t\t\t\ttree.add(node);\n\t\t}\n\t\tCollections.reverse(tree);\n\t\treturn tree;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDomainName(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDomain> filterByDomainName(String query) {\n\n\t\tList<ScopDomain > domains = new ArrayList<ScopDomain>();\n\t\tif (query.length() <5){\n\t\t\treturn domains;\n\t\t}\n\n\t\tString pdbId = query.substring(1,5);\n\n\t\tList<ScopDomain> doms = getDomainsForPDB(pdbId);\n\n\n\t\tif ( doms == null)\n\t\t\treturn domains;\n\n\t\tquery = query.toLowerCase();\n\t\tfor ( ScopDomain d: doms){\n\t\t\tif ( d.getScopId().toLowerCase().contains(query)){\n\t\t\t\tdomains.add(d);\n\t\t\t}\n\t\t}\n\n\t\treturn domains;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDescription(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDescription> filterByDescription(String query) throws ScopIOException {\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tquery = query.toLowerCase();\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\n\t\t\tif( sc.getDescription().toLowerCase().startsWith(query)){\n\t\t\t\tmatches.add(sc);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDescriptionBySunid(int)\n\t */\n\t@Override\n\tpublic ScopDescription getScopDescriptionBySunid(int sunid) {\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\t\treturn sunidMap.get(sunid);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainsForPDB(java.lang.String)\n\t */\n\t@Override\n\tpublic  List<ScopDomain> getDomainsForPDB(String pdbId) {\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDomain> doms = domainMap.get(pdbId.toLowerCase());\n\t\t\n\t\tList<ScopDomain> retdoms = new ArrayList<ScopDomain>();\n\t\t\n\t\tif ( doms == null)\n\t\t\treturn retdoms;\n\n\t\tfor ( ScopDomain d : doms){\n\t\t\ttry {\n\t\t\t\tScopDomain n = (ScopDomain) d.clone();\n\t\t\t\tretdoms.add(n);\n\t\t\t}  catch (CloneNotSupportedException e){\n\t\t\t\tthrow new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n\t\t\t}\n\n\n\t\t}\n\t\treturn retdoms;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainByScopID(java.lang.String)\n\t */\n\t@Override\n\tpublic ScopDomain getDomainByScopID(String scopId) {\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tif ( scopId.length() < 6) {\n\t\t\tthrow new ScopIOException(\"Does not look like a scop ID! \" + scopId);\n\t\t}\n\t\tString pdbId = scopId.substring(1,5);\n\t\tList<ScopDomain> doms = getDomainsForPDB(pdbId);\n\t\tif ( doms == null)\n\t\t\treturn null;\n\t\tfor ( ScopDomain d : doms){\n\t\t\tif ( d.getScopId().equalsIgnoreCase(scopId)) \n\t\t\t\treturn d;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopNode(int)\n\t */\n\t@Override\n\tpublic ScopNode getScopNode(int sunid){\n\n\t\ttry {\n\t\t\tensureHieInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\treturn scopTree.get(sunid);\n\t}\n\n\n\tprivate void parseClassification() throws IOException{\n\n\t\tFile file = new File(getClaFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseClassification(buffer);\n\n\t}\n\n\tprivate void parseHierarchy() throws IOException{\n\n\t\tFile file = new File(getHieFilename());\n\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseHierarchy(buffer);\n\n\t}\n\n\tprivate void parseHierarchy(BufferedReader buffer) throws IOException {\n\t\tString line;\n\n\t\tint counter =0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 3 ) {\n\t\t\t\tthrow new IOException(\"parseHierarchy: Can't parse line \" + line +\" (length: \" + spl.length+\")\");\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tint sunid       = Integer.parseInt(spl[0]);\n\t\t\tint parentSunid = -1;\n\n\t\t\tif ( sunid != 0)\n\t\t\t\tparentSunid = Integer.parseInt(spl[1]);\n\n\t\t\tString children = spl[2];\n\t\t\tString[] childIds = children.split(\",\");\n\n\t\t\tList<Integer> chis = new ArrayList<Integer>();\n\n\t\t\tfor ( String id : childIds){\n\t\t\t\tif ( id.equals(\"-\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tchis.add(Integer.parseInt(id));\n\t\t\t}\n\n\t\t\tScopNode node = new ScopNode();\n\n\t\t\tnode.setSunid(sunid);\n\t\t\tnode.setParentSunid(parentSunid);\n\t\t\tnode.setChildren(chis);\n\n\t\t\tscopTree.put(sunid, node);\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid nodes.\", counter);\n\t}\n\n\n\tprivate void parseDescriptions() throws IOException{\n\n\t\tFile file = new File(getDesFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseDescriptions(buffer);\n\n\t}\n\t\n\tprivate void parseComments() throws IOException{\n\n\t\tFile file = new File(getComFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseComments(buffer);\n\n\t}\n\t\n\tprivate void parseComments(BufferedReader buffer) throws IOException {\n\n\t\tcommentsMap = new HashMap<Integer,List<String>>();\n\n\t\tint counter = 0;\n\t\tString line;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif (line.startsWith(\"#\")) continue;\n\t\t\tString[] parts = line.split(\"!\");\n\t\t\tint sunId = Integer.parseInt(parts[0].trim());\n\t\t\tif (parts.length == 1) {\n\t\t\t\tcommentsMap.put(sunId, new ArrayList<String>(1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<String> comments = new ArrayList<String>(parts.length - 1);\n\t\t\tfor (int i = 1; i < parts.length; i++) {\n\t\t\t\tString trimmed = parts[i].trim();\n\t\t\t\tif( !trimmed.isEmpty() ) {\n\t\t\t\t\tcomments.add(trimmed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcommentsMap.put(sunId, comments);\n\t\t\tcounter++;\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP comments.\", counter);\n\n\t}\n\t\n\tprivate void parseDescriptions(BufferedReader buffer) throws IOException {\n\t\tString line = null;\n\n\t\tint counter = 0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 5 ) {\n\t\t\t\tthrow new IOException(\"parseDescriptions: Can't parse line \" + line +\" (length: \" + spl.length+\")\");\n\t\t\t}\n\t\t\tcounter++;\n\n\t\t\t//46464  dm  a.1.1.2 -   Hemoglobin I\n\t\t\tint sunID = Integer.parseInt(spl[0]);\n\t\t\tScopCategory category =  ScopCategory.fromString(spl[1]);\n\t\t\tString classificationId = spl[2];\n\t\t\tString name = spl[3];\n\t\t\tString desc = spl[4];\n\n\t\t\tScopDescription c = new ScopDescription();\n\t\t\tc.setSunID(sunID);\n\t\t\tc.setCategory(category);\n\t\t\tc.setClassificationId(classificationId);\n\t\t\tc.setName(name);\n\t\t\tc.setDescription(desc);\n\n\t\t\tsunidMap.put(sunID, c);\n\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid descriptions.\", counter);\n\t}\n\n\n\n\tprivate void parseClassification(BufferedReader buffer) throws IOException {\n\t\tString line = null;\n\n\t\tint counter = 0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 6){\n\t\t\t\tthrow new IOException(\"Can't parse line \" + line);\n\t\t\t}\n\t\t\tcounter++;\n\n\t\t\tString scopId = spl[0];\n\t\t\tString pdbId = spl[1];\n\t\t\tString range = spl[2];\n\t\t\tString classificationId = spl[3];\n\t\t\tInteger sunid = Integer.parseInt(spl[4]);\n\t\t\tString tree = spl[5];\n\n\n\n\t\t\tScopDomain d = new ScopDomain();\n\t\t\td.setScopId(scopId);\n\t\t\td.setPdbId(pdbId);\n\n\t\t\td.setRanges(extractRanges(range));\n\n\t\t\td.setClassificationId(classificationId);\n\t\t\td.setSunid(sunid);\n\n\t\t\tString[] treeSplit = tree.split(\",\");\n\n\t\t\tif (  treeSplit.length != 7 ) {\n\t\t\t\tthrow new IOException(\"Can't process: \" + line );\n\t\t\t}\n\n\t\t\tint classId =Integer.parseInt(treeSplit[0].substring(3));\n\t\t\tint foldId = Integer.parseInt(treeSplit[1].substring(3));\n\t\t\tint superfamilyId = Integer.parseInt(treeSplit[2].substring(3));\n\t\t\tint familyId = Integer.parseInt(treeSplit[3].substring(3));\t\t\t\t\t\t\n\t\t\tint domainId = Integer.parseInt(treeSplit[4].substring(3));\n\t\t\tint speciesId = Integer.parseInt(treeSplit[5].substring(3));\n\t\t\tint px = Integer.parseInt(treeSplit[6].substring(3));\n\n\t\t\td.setClassId(classId);\n\t\t\td.setFoldId(foldId);\n\t\t\td.setSuperfamilyId(superfamilyId);\n\t\t\td.setFamilyId(familyId);\n\t\t\td.setDomainId(domainId);\n\t\t\td.setSpeciesId(speciesId);\n\t\t\td.setPx(px);\n\n\t\t\tList<ScopDomain> domainList;\n\t\t\tif ( domainMap.containsKey(pdbId)){\n\t\t\t\tdomainList = domainMap.get(pdbId);\n\t\t\t} else {\n\t\t\t\tdomainList = new ArrayList<ScopDomain>();\n\t\t\t\tdomainMap.put(pdbId,domainList);\n\t\t\t}\n\n\t\t\tdomainList.add(d);\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid domains.\", counter);\n\n\t}\n\n\t/** \n\t * Converts the SCOP range field into a list of subranges suitable for\n\t * storage in a ScopDomain object. Each range should be of a format\n\t * compatible with {@link StructureTools#getSubRanges(Structure,String)}.\n\t * @param range\n\t * @return\n\t */\n\tprivate List<String> extractRanges(String range) {\n\t\tList<String> ranges;\n\t\tString[] rangeSpl = range.split(\",\");\n\n\t\t// Recent versions of scop always specify a chain, so no processing is needed\n\t\tif(scopVersion.compareTo(\"1.73\") < 0 ) {\n\t\t\tfor(int i=0; i<rangeSpl.length;i++) {\n\t\t\t\tString subRange = rangeSpl[i];\n\n\t\t\t\t// Allow single-chains, as well as the '-' special case\n\t\t\t\tif(subRange.length()<2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Allow explicit chain syntax\n\t\t\t\tif(subRange.charAt(1) != ':') {\n\t\t\t\t\t// Early versions sometimes skip the chain identifier for single-chain domains\n\t\t\t\t\t// Indicate this with a chain \"_\"\n\t\t\t\t\trangeSpl[i] = \"_:\"+subRange;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tranges = Arrays.asList(rangeSpl);\n\t\treturn ranges;\n\t}\n\n\tprotected void downloadClaFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getClaURL(scopVersion));\n\n\t\t\t\tString localFileName = getClaFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .cla file\",exception);\n\t}\n\n\tprotected void downloadDesFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getDesURL( scopVersion));\n\n\t\t\t\tString localFileName = getDesFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .des file\",exception);\n\t}\n\n\tprotected void downloadHieFile() throws IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getHieURL( scopVersion));\n\n\t\t\t\tString localFileName = getHieFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .hie file\",exception);\n\n\t}\n\n\tprotected void downloadComFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getComURL(scopVersion));\n\n\t\t\t\tString localFileName = getComFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch (IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .com file\",exception);\n\t}\n\n\tprotected void downloadFileFromRemote(URL remoteURL, File localFile) throws IOException{\n\t\tlogger.info(\"Downloading \" + remoteURL + \" to: \" + localFile);\n\t\tFileOutputStream out = new FileOutputStream(localFile);\n\n\t\tInputStream in = remoteURL.openStream();\n\t\tbyte[] buf = new byte[4 * 1024]; // 4K buffer\n\t\tint bytesRead;\n\t\twhile ((bytesRead = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, bytesRead);\n\t\t}\n\t\tin.close();\n\t\tout.close();\n\n\n\t}\n\n\tprivate boolean claFileAvailable(){\n\t\tString fileName = getClaFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean desFileAvailable(){\n\t\tString fileName = getDesFilename();\n\n\t\tFile f = new File(fileName);\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean hieFileAvailable(){\n\t\tString fileName = getHieFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean comFileAvailable(){\n\t\tString fileName = getComFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprotected String getClaFilename(){\n\t\treturn cacheLocation + claFileName + scopVersion;\n\t}\n\n\tprotected String getDesFilename(){\n\t\treturn cacheLocation + desFileName + scopVersion;\n\n\t}\n\n\tprotected String getHieFilename(){\n\t\treturn cacheLocation + hieFileName + scopVersion;\n\n\t}\n\n\tprotected String getComFilename(){\n\t\treturn cacheLocation + comFileName + scopVersion;\n\t}\n\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\n\tpublic void setCacheLocation(String cacheLocation) {\n\n\t\tif (! cacheLocation.endsWith(FILESPLIT))\n\t\t\tcacheLocation += FILESPLIT;\n\t\tthis.cacheLocation = cacheLocation;\n\n\n\t}\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopVersion()\n\t */\n\t@Override\n\tpublic String getScopVersion() {\n\t\treturn scopVersion;\n\t}\n\t@Override\n\tpublic void setScopVersion(String scopVersion) {\n\t\tthis.scopVersion = scopVersion;\n\t}\n\t\n\n\t/**\n\t * Get the URL of the first scop mirror being used\n\t * @return\n\t */\n\t@Deprecated\n\tpublic String getScopDownloadURL() {\n\t\tif(mirrors.size()<1) initScopURLs();\n\t\treturn mirrors.get(0).getRootURL();\n\t}\n\n\t/**\n\t * @param scopDownloadURL URL to load\n\t * @deprecated Use {@link #addMirror} instead\n\t */\n\t@Deprecated\n\tpublic void setScopDownloadURL(String scopDownloadURL) {\n\t\tmirrors.clear();\n\t\tmirrors.add(new ScopMirror(scopDownloadURL));\n\t}\n\t\n\tpublic void addMirror(String scopDownloadURL) {\n\t\tmirrors.add(new ScopMirror(scopDownloadURL));\n\t}\n\tvoid addMirror(ScopMirror scopURLs) {\n\t\tmirrors.add(scopURLs);\n\t}\n\tpublic List<ScopMirror> getMirrors() {\n\t\tif(mirrors.isEmpty()) {\n\t\t\tthis.initScopURLs();\n\t\t}\n\t\treturn mirrors;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDomainsBySunid(java.lang.Integer)\n\t */\n\t@Override\n\tpublic List<ScopDomain> getScopDomainsBySunid(Integer sunid)\n\t{\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDomain> domains = new ArrayList<ScopDomain>();\n\n\t\tfor (String pdbId: domainMap.keySet()){\n\t\t\tfor (ScopDomain d : domainMap.get(pdbId)){\n\t\t\t\ttry {\n\t\t\t\t\tif ( d.getPx() == sunid) {\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t} else if ( d.getSpeciesId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getDomainId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getFamilyId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getSuperfamilyId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getFoldId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getClassId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Type \" + d + \" not recognized\"); // only possible if SCOP changes\n\t\t\t\t\t}\n\t\t\t\t} catch (CloneNotSupportedException e){\n\t\t\t\t\tthrow new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn domains;\n\n\t}\n\n\t@Override\n\tpublic List<String> getComments(int sunid) {\n\t\ttry {\n\t\t\tensureComInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\t\tif (!commentsMap.containsKey(sunid)) return new ArrayList<String>(1);\n\t\treturn commentsMap.get(sunid);\n\t}\n\t\n\n\tprivate void initScopURLs() {\n\t\tif(!this.mirrors.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// first, try default scop\n\t\tScopMirror primary = new ScopMirror();\n\t\t// If unreachable, try alternate Berkeley location\n\t\tScopMirror alt = new ScopMirror(\n\t\t\t\tSCOP_DOWNLOAD_ALTERNATE,\n\t\t\t\t\"dir.cla.scop.%s.txt\",\"dir.des.scop.%s.txt\",\n\t\t\t\t\"dir.hie.scop.%s.txt\",\"dir.com.scop.%s.txt\");\n\t\tmirrors.add(primary);\n\t\tmirrors.add(alt);\n\t}\n}\n","changedPro":"/**\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n * \n * Author: Andreas Prlic\n * \n * \n */\n\npackage org.biojava.nbio.structure.scop;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.util.FileDownloadUtils;\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\n\n/** This class provides access to the SCOP protein structure classification.\n * \n * For more information about SCOP see here:\n *  <ul>\n *   <li>SCOP: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/\">http://scop.mrc-lmb.cam.ac.uk/scop/</a></li>\n\n *  <li> Introduction: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/intro.html\">http://scop.mrc-lmb.cam.ac.uk/scop/intro.html</a> </li>\n\n *   <li> SCOP parsable files: <a href=\"http://scop.mrc-lmb.cam.ac.uk/scop/parse/\">http://scop.mrc-lmb.cam.ac.uk/scop/parse/</a> </li>\n * </ul>\n\n * \n * This class can automatically download missing files from the SCOP classification.\n * \n * @author Andreas Prlic\n *\n */\npublic class ScopInstallation implements LocalScopDatabase {\n\n\tpublic static final String DEFAULT_VERSION = \"1.75\";\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(ScopInstallation.class);\n\n\tprotected String scopVersion;\n\t\n\t// Stores URLs for cla, des, hie, and com files\n\tprivate final List<ScopMirror> mirrors;\n\n\t// Cache filenames (with version appended)\n\tpublic static final String claFileName = \"dir.cla.scop.txt_\";\n\tpublic static final String desFileName = \"dir.des.scop.txt_\";\n\tpublic static final String hieFileName = \"dir.hie.scop.txt_\";\n\tpublic static final String comFileName = \"dir.com.scop.txt_\";\n\n\t// Download locations\n\tpublic static final String SCOP_DOWNLOAD = \"http://scop.mrc-lmb.cam.ac.uk/scop/parse/\";\n\tpublic static final String SCOP_DOWNLOAD_ALTERNATE = \"http://scop.berkeley.edu/downloads/parse/\";\n\t\n\tpublic static final String NEWLINE;\n\tpublic static final String FILESPLIT ;\n\n\tstatic {\n\n\t\tNEWLINE     = System.getProperty(\"line.separator\");\n\t\tFILESPLIT   = System.getProperty(\"file.separator\");\n\t}\n\n\tString cacheLocation ;\n\n\tAtomicBoolean installedCla;\n\tAtomicBoolean installedDes;\n\tAtomicBoolean installedHie;\n\tAtomicBoolean installedCom;\n\n\tMap<Integer, List<String>> commentsMap;\n\tMap<String, List<ScopDomain>> domainMap;\n\tMap<Integer, ScopDescription> sunidMap;\n\tMap<Integer, ScopNode> scopTree;\n\n\n\t/** Create a new SCOP installation. \n\t * \n\t * @param cacheLocation where the SCOP files are stored. If they can't be found at that location they will get automatically downloaded and installed there. \n\t */\n\tpublic ScopInstallation(String cacheLocation){\n\n\t\tsetCacheLocation(cacheLocation);\n\n\t\tinstalledCla = new AtomicBoolean();\n\t\tinstalledCla.set(false);\n\t\tinstalledDes = new AtomicBoolean();\n\t\tinstalledDes.set(false);\n\t\tinstalledHie = new AtomicBoolean();\n\t\tinstalledHie.set(false);\n\t\tinstalledCom = new AtomicBoolean();\n\t\tinstalledCom.set(false);\n\n\t\tscopVersion = DEFAULT_VERSION;\n\t\tmirrors = new ArrayList<ScopMirror>(1);\n\n\t\tdomainMap = new HashMap<String, List<ScopDomain>>();\n\n\t\tsunidMap  = new HashMap<Integer, ScopDescription>();\n\t\tscopTree  = new TreeMap<Integer, ScopNode>();\n\n\t}\n\n\t/**\n\t * Removes all of the comments (dir.com file) in order to free memory. The file will need to be reloaded if {@link #getComments(int)} is called subsequently.\n\t */\n\tpublic void nullifyComments() {\n\t\tcommentsMap = null;\n\t\tinstalledCom.set(false);\n\t}\n\t\n\t/**\n\t * Create a new SCOP installation, downloading the file to \"the right place\".\n\t * This will first check for system properties or environmental variables\n\t * called {@link UserConfiguration#PDB_CACHE_DIR}, or else will use a temporary directory\n\t */\n\tpublic ScopInstallation() {\n\t\tthis((new UserConfiguration()).getCacheFilePath());\n\t}\n\n\tpublic void ensureClaInstalled() throws IOException {\n\t\tif (installedCla.get()) return;\n\t\tif (!claFileAvailable()) downloadClaFile();\n\t\tparseClassification();\n\t\tinstalledCla.set(true);\n\t}\n\n\tpublic void ensureDesInstalled() throws IOException {\n\t\tif (installedDes.get()) return;\n\t\tif (!desFileAvailable()) downloadDesFile();\n\t\tparseDescriptions();\n\t\tinstalledDes.set(true);\n\t}\n\n\tpublic void ensureComInstalled() throws IOException {\n\t\tif (installedCom.get()) return;\n\t\tif (!comFileAvailable()) downloadComFile();\n\t\tparseComments();\n\t\tinstalledCom.set(true);\n\t}\n\n\tpublic void ensureHieInstalled() throws IOException {\n\t\tif ( installedHie.get()) return;\n\t\tif ( ! hieFileAvailable()) downloadHieFile();\n\t\tparseHierarchy();\n\t\tinstalledHie.set(true);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getByCategory(org.biojava.nbio.structure.scop.ScopCategory)\n\t */\n\t@Override\n\tpublic List<ScopDescription> getByCategory(ScopCategory category){\n\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\t\t\tif ( sc.getCategory().equals(category))\n\n\t\t\t\ttry {\n\t\t\t\t\tmatches.add((ScopDescription)sc.clone());\n\t\t\t\t} catch (CloneNotSupportedException e) {\n\t\t\t\t\tthrow new RuntimeException(\"Could not clone \" + ScopDescription.class + \" subclass\", e);\n\t\t\t\t}\n\n\t\t}\n\t\treturn matches;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByClassificationId(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDescription> filterByClassificationId(String query){\n\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\n\n\t\t\tif( sc.getClassificationId().startsWith(query)){\n\t\t\t\tmatches.add(sc);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getTree(org.biojava.nbio.structure.scop.ScopDomain)\n\t */\n\t@Override\n\tpublic List<ScopNode> getTree(ScopDomain domain){\n\t\tScopNode node = getScopNode(domain.getSunid());\n\n\n\t\tList<ScopNode> tree = new ArrayList<ScopNode>();\n\t\twhile (node != null){\n\n\t\t\t//System.out.println(\"This node: sunid:\" + node.getSunid() );\n\t\t\t//System.out.println(getScopDescriptionBySunid(node.getSunid()));\n\t\t\tnode = getScopNode(node.getParentSunid());\n\t\t\tif ( node != null)\n\t\t\t\ttree.add(node);\n\t\t}\n\t\tCollections.reverse(tree);\n\t\treturn tree;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDomainName(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDomain> filterByDomainName(String query) {\n\n\t\tList<ScopDomain > domains = new ArrayList<ScopDomain>();\n\t\tif (query.length() <5){\n\t\t\treturn domains;\n\t\t}\n\n\t\tString pdbId = query.substring(1,5);\n\n\t\tList<ScopDomain> doms = getDomainsForPDB(pdbId);\n\n\n\t\tif ( doms == null)\n\t\t\treturn domains;\n\n\t\tquery = query.toLowerCase();\n\t\tfor ( ScopDomain d: doms){\n\t\t\tif ( d.getScopId().toLowerCase().contains(query)){\n\t\t\t\tdomains.add(d);\n\t\t\t}\n\t\t}\n\n\t\treturn domains;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDescription(java.lang.String)\n\t */\n\t@Override\n\tpublic List<ScopDescription> filterByDescription(String query) throws ScopIOException {\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tquery = query.toLowerCase();\n\t\tList<ScopDescription> matches = new ArrayList<ScopDescription>();\n\t\tfor (Integer i : sunidMap.keySet()){\n\t\t\tScopDescription sc = sunidMap.get(i);\n\n\t\t\tif( sc.getDescription().toLowerCase().startsWith(query)){\n\t\t\t\tmatches.add(sc);\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t}\n\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDescriptionBySunid(int)\n\t */\n\t@Override\n\tpublic ScopDescription getScopDescriptionBySunid(int sunid) {\n\t\ttry {\n\t\t\tensureDesInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\t\treturn sunidMap.get(sunid);\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainsForPDB(java.lang.String)\n\t */\n\t@Override\n\tpublic  List<ScopDomain> getDomainsForPDB(String pdbId) {\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDomain> doms = domainMap.get(pdbId.toLowerCase());\n\t\t\n\t\tList<ScopDomain> retdoms = new ArrayList<ScopDomain>();\n\t\t\n\t\tif ( doms == null)\n\t\t\treturn retdoms;\n\n\t\tfor ( ScopDomain d : doms){\n\t\t\ttry {\n\t\t\t\tScopDomain n = (ScopDomain) d.clone();\n\t\t\t\tretdoms.add(n);\n\t\t\t}  catch (CloneNotSupportedException e){\n\t\t\t\tthrow new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n\t\t\t}\n\n\n\t\t}\n\t\treturn retdoms;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainByScopID(java.lang.String)\n\t */\n\t@Override\n\tpublic ScopDomain getDomainByScopID(String scopId) {\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tif ( scopId.length() < 6) {\n\t\t\tthrow new ScopIOException(\"Does not look like a scop ID! \" + scopId);\n\t\t}\n\t\tString pdbId = scopId.substring(1,5);\n\t\tList<ScopDomain> doms = getDomainsForPDB(pdbId);\n\t\tif ( doms == null)\n\t\t\treturn null;\n\t\tfor ( ScopDomain d : doms){\n\t\t\tif ( d.getScopId().equalsIgnoreCase(scopId)) \n\t\t\t\treturn d;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopNode(int)\n\t */\n\t@Override\n\tpublic ScopNode getScopNode(int sunid){\n\n\t\ttry {\n\t\t\tensureHieInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\treturn scopTree.get(sunid);\n\t}\n\n\n\tprivate void parseClassification() throws IOException{\n\n\t\tFile file = new File(getClaFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseClassification(buffer);\n\n\t}\n\n\tprivate void parseHierarchy() throws IOException{\n\n\t\tFile file = new File(getHieFilename());\n\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseHierarchy(buffer);\n\n\t}\n\n\tprivate void parseHierarchy(BufferedReader buffer) throws IOException {\n\t\tString line;\n\n\t\tint counter =0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 3 ) {\n\t\t\t\tthrow new IOException(\"parseHierarchy: Can't parse line \" + line +\" (length: \" + spl.length+\")\");\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tint sunid       = Integer.parseInt(spl[0]);\n\t\t\tint parentSunid = -1;\n\n\t\t\tif ( sunid != 0)\n\t\t\t\tparentSunid = Integer.parseInt(spl[1]);\n\n\t\t\tString children = spl[2];\n\t\t\tString[] childIds = children.split(\",\");\n\n\t\t\tList<Integer> chis = new ArrayList<Integer>();\n\n\t\t\tfor ( String id : childIds){\n\t\t\t\tif ( id.equals(\"-\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tchis.add(Integer.parseInt(id));\n\t\t\t}\n\n\t\t\tScopNode node = new ScopNode();\n\n\t\t\tnode.setSunid(sunid);\n\t\t\tnode.setParentSunid(parentSunid);\n\t\t\tnode.setChildren(chis);\n\n\t\t\tscopTree.put(sunid, node);\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid nodes.\", counter);\n\t}\n\n\n\tprivate void parseDescriptions() throws IOException{\n\n\t\tFile file = new File(getDesFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseDescriptions(buffer);\n\n\t}\n\t\n\tprivate void parseComments() throws IOException{\n\n\t\tFile file = new File(getComFilename());\n\n\t\tInputStreamProvider ips = new InputStreamProvider();\n\t\tBufferedReader buffer = new BufferedReader (new InputStreamReader(ips.getInputStream(file)));\n\n\t\tparseComments(buffer);\n\n\t}\n\t\n\tprivate void parseComments(BufferedReader buffer) throws IOException {\n\n\t\tcommentsMap = new HashMap<Integer,List<String>>();\n\n\t\tint counter = 0;\n\t\tString line;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif (line.startsWith(\"#\")) continue;\n\t\t\tString[] parts = line.split(\"!\");\n\t\t\tint sunId = Integer.parseInt(parts[0].trim());\n\t\t\tif (parts.length == 1) {\n\t\t\t\tcommentsMap.put(sunId, new ArrayList<String>(1));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tList<String> comments = new ArrayList<String>(parts.length - 1);\n\t\t\tfor (int i = 1; i < parts.length; i++) {\n\t\t\t\tString trimmed = parts[i].trim();\n\t\t\t\tif( !trimmed.isEmpty() ) {\n\t\t\t\t\tcomments.add(trimmed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcommentsMap.put(sunId, comments);\n\t\t\tcounter++;\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP comments.\", counter);\n\n\t}\n\t\n\tprivate void parseDescriptions(BufferedReader buffer) throws IOException {\n\t\tString line = null;\n\n\t\tint counter = 0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 5 ) {\n\t\t\t\tthrow new IOException(\"parseDescriptions: Can't parse line \" + line +\" (length: \" + spl.length+\")\");\n\t\t\t}\n\t\t\tcounter++;\n\n\t\t\t//46464  dm  a.1.1.2 -   Hemoglobin I\n\t\t\tint sunID = Integer.parseInt(spl[0]);\n\t\t\tScopCategory category =  ScopCategory.fromString(spl[1]);\n\t\t\tString classificationId = spl[2];\n\t\t\tString name = spl[3];\n\t\t\tString desc = spl[4];\n\n\t\t\tScopDescription c = new ScopDescription();\n\t\t\tc.setSunID(sunID);\n\t\t\tc.setCategory(category);\n\t\t\tc.setClassificationId(classificationId);\n\t\t\tc.setName(name);\n\t\t\tc.setDescription(desc);\n\n\t\t\tsunidMap.put(sunID, c);\n\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid descriptions.\", counter);\n\t}\n\n\n\n\tprivate void parseClassification(BufferedReader buffer) throws IOException {\n\t\tString line = null;\n\n\t\tint counter = 0;\n\t\twhile ((line = buffer.readLine ()) != null) {\n\t\t\tif ( line.startsWith(\"#\"))\n\t\t\t\tcontinue;\n\n\t\t\tString[] spl  = line.split(\"\\t\");\n\n\t\t\tif ( spl.length != 6){\n\t\t\t\tthrow new IOException(\"Can't parse line \" + line);\n\t\t\t}\n\t\t\tcounter++;\n\n\t\t\tString scopId = spl[0];\n\t\t\tString pdbId = spl[1];\n\t\t\tString range = spl[2];\n\t\t\tString classificationId = spl[3];\n\t\t\tInteger sunid = Integer.parseInt(spl[4]);\n\t\t\tString tree = spl[5];\n\n\n\n\t\t\tScopDomain d = new ScopDomain();\n\t\t\td.setScopId(scopId);\n\t\t\td.setPdbId(pdbId);\n\n\t\t\td.setRanges(extractRanges(range));\n\n\t\t\td.setClassificationId(classificationId);\n\t\t\td.setSunid(sunid);\n\n\t\t\tString[] treeSplit = tree.split(\",\");\n\n\t\t\tif (  treeSplit.length != 7 ) {\n\t\t\t\tthrow new IOException(\"Can't process: \" + line );\n\t\t\t}\n\n\t\t\tint classId =Integer.parseInt(treeSplit[0].substring(3));\n\t\t\tint foldId = Integer.parseInt(treeSplit[1].substring(3));\n\t\t\tint superfamilyId = Integer.parseInt(treeSplit[2].substring(3));\n\t\t\tint familyId = Integer.parseInt(treeSplit[3].substring(3));\t\t\t\t\t\t\n\t\t\tint domainId = Integer.parseInt(treeSplit[4].substring(3));\n\t\t\tint speciesId = Integer.parseInt(treeSplit[5].substring(3));\n\t\t\tint px = Integer.parseInt(treeSplit[6].substring(3));\n\n\t\t\td.setClassId(classId);\n\t\t\td.setFoldId(foldId);\n\t\t\td.setSuperfamilyId(superfamilyId);\n\t\t\td.setFamilyId(familyId);\n\t\t\td.setDomainId(domainId);\n\t\t\td.setSpeciesId(speciesId);\n\t\t\td.setPx(px);\n\n\t\t\tList<ScopDomain> domainList;\n\t\t\tif ( domainMap.containsKey(pdbId)){\n\t\t\t\tdomainList = domainMap.get(pdbId);\n\t\t\t} else {\n\t\t\t\tdomainList = new ArrayList<ScopDomain>();\n\t\t\t\tdomainMap.put(pdbId,domainList);\n\t\t\t}\n\n\t\t\tdomainList.add(d);\n\t\t}\n\t\tlogger.info(\"Parsed {} SCOP sunid domains.\", counter);\n\n\t}\n\n\t/** \n\t * Converts the SCOP range field into a list of subranges suitable for\n\t * storage in a ScopDomain object. Each range should be of a format\n\t * compatible with {@link StructureTools#getSubRanges(Structure,String)}.\n\t * @param range\n\t * @return\n\t */\n\tprivate List<String> extractRanges(String range) {\n\t\tList<String> ranges;\n\t\tString[] rangeSpl = range.split(\",\");\n\n\t\t// Recent versions of scop always specify a chain, so no processing is needed\n\t\tif(scopVersion.compareTo(\"1.73\") < 0 ) {\n\t\t\tfor(int i=0; i<rangeSpl.length;i++) {\n\t\t\t\tString subRange = rangeSpl[i];\n\n\t\t\t\t// Allow single-chains, as well as the '-' special case\n\t\t\t\tif(subRange.length()<2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Allow explicit chain syntax\n\t\t\t\tif(subRange.charAt(1) != ':') {\n\t\t\t\t\t// Early versions sometimes skip the chain identifier for single-chain domains\n\t\t\t\t\t// Indicate this with a chain \"_\"\n\t\t\t\t\trangeSpl[i] = \"_:\"+subRange;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tranges = Arrays.asList(rangeSpl);\n\t\treturn ranges;\n\t}\n\n\tprotected void downloadClaFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getClaURL(scopVersion));\n\n\t\t\t\tString localFileName = getClaFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .cla file\",exception);\n\t}\n\n\tprotected void downloadDesFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getDesURL( scopVersion));\n\n\t\t\t\tString localFileName = getDesFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .des file\",exception);\n\t}\n\n\tprotected void downloadHieFile() throws IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getHieURL( scopVersion));\n\n\t\t\t\tString localFileName = getHieFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch(IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .hie file\",exception);\n\n\t}\n\n\tprotected void downloadComFile() throws FileNotFoundException, IOException{\n\t\tif(mirrors.size()<1) {\n\t\t\tinitScopURLs();\n\t\t}\n\t\tIOException exception = null;\n\t\tfor(ScopMirror mirror:mirrors) {\n\t\t\ttry {\n\t\t\t\tURL url = new URL(mirror.getComURL(scopVersion));\n\n\t\t\t\tString localFileName = getComFilename();\n\t\t\t\tFile localFile = new File(localFileName);\n\n\t\t\t\tdownloadFileFromRemote(url, localFile);\n\t\t\t\treturn;\n\t\t\t} catch (IOException e ) {\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\t\tthrow new IOException(\"Unable to download SCOP .com file\",exception);\n\t}\n\n\tprotected void downloadFileFromRemote(URL remoteURL, File localFile) throws IOException{\n\t\tlogger.info(\"Downloading \" + remoteURL + \" to: \" + localFile);\n\t\tFileDownloadUtils.downloadFile(remoteURL, localFile);\n\t}\n\n\tprivate boolean claFileAvailable(){\n\t\tString fileName = getClaFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean desFileAvailable(){\n\t\tString fileName = getDesFilename();\n\n\t\tFile f = new File(fileName);\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean hieFileAvailable(){\n\t\tString fileName = getHieFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprivate boolean comFileAvailable(){\n\t\tString fileName = getComFilename();\n\n\t\tFile f = new File(fileName);\n\n\t\treturn f.exists() && f.length()>0;\n\t}\n\n\tprotected String getClaFilename(){\n\t\treturn cacheLocation + claFileName + scopVersion;\n\t}\n\n\tprotected String getDesFilename(){\n\t\treturn cacheLocation + desFileName + scopVersion;\n\n\t}\n\n\tprotected String getHieFilename(){\n\t\treturn cacheLocation + hieFileName + scopVersion;\n\n\t}\n\n\tprotected String getComFilename(){\n\t\treturn cacheLocation + comFileName + scopVersion;\n\t}\n\n\tpublic String getCacheLocation() {\n\t\treturn cacheLocation;\n\t}\n\n\tpublic void setCacheLocation(String cacheLocation) {\n\n\t\tif (! cacheLocation.endsWith(FILESPLIT))\n\t\t\tcacheLocation += FILESPLIT;\n\t\tthis.cacheLocation = cacheLocation;\n\n\n\t}\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopVersion()\n\t */\n\t@Override\n\tpublic String getScopVersion() {\n\t\treturn scopVersion;\n\t}\n\t@Override\n\tpublic void setScopVersion(String scopVersion) {\n\t\tif(scopVersion == null)\n\t\t\tthrow new NullPointerException(\"Null scop version\");\n\t\tif(this.scopVersion.equals(scopVersion))\n\t\t\treturn;\n\t\tthis.scopVersion = scopVersion;\n\t\t// reset installation flags\n\t\tinstalledCla.set(false);\n\t\tinstalledDes.set(false);\n\t\tinstalledHie.set(false);\n\t\tinstalledCom.set(false);\n\n\t}\n\t\n\n\t/**\n\t * Get the URL of the first scop mirror being used\n\t * @return\n\t */\n\t@Deprecated\n\tpublic String getScopDownloadURL() {\n\t\tif(mirrors.size()<1) initScopURLs();\n\t\treturn mirrors.get(0).getRootURL();\n\t}\n\n\t/**\n\t * @param scopDownloadURL URL to load\n\t * @deprecated Use {@link #addMirror} instead\n\t */\n\t@Deprecated\n\tpublic void setScopDownloadURL(String scopDownloadURL) {\n\t\tmirrors.clear();\n\t\tmirrors.add(new ScopMirror(scopDownloadURL));\n\t}\n\t\n\tpublic void addMirror(String scopDownloadURL) {\n\t\tmirrors.add(new ScopMirror(scopDownloadURL));\n\t}\n\tvoid addMirror(ScopMirror scopURLs) {\n\t\tmirrors.add(scopURLs);\n\t}\n\tpublic List<ScopMirror> getMirrors() {\n\t\tif(mirrors.isEmpty()) {\n\t\t\tthis.initScopURLs();\n\t\t}\n\t\treturn mirrors;\n\t}\n\n\t/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDomainsBySunid(java.lang.Integer)\n\t */\n\t@Override\n\tpublic List<ScopDomain> getScopDomainsBySunid(Integer sunid)\n\t{\n\n\t\ttry {\n\t\t\tensureClaInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\n\t\tList<ScopDomain> domains = new ArrayList<ScopDomain>();\n\n\t\tfor (String pdbId: domainMap.keySet()){\n\t\t\tfor (ScopDomain d : domainMap.get(pdbId)){\n\t\t\t\ttry {\n\t\t\t\t\tif ( d.getPx() == sunid) {\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t} else if ( d.getSpeciesId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getDomainId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getFamilyId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getSuperfamilyId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getFoldId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t}else if ( d.getClassId() == sunid ){\n\t\t\t\t\t\tdomains.add((ScopDomain)d.clone());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RuntimeException(\"Type \" + d + \" not recognized\"); // only possible if SCOP changes\n\t\t\t\t\t}\n\t\t\t\t} catch (CloneNotSupportedException e){\n\t\t\t\t\tthrow new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn domains;\n\n\t}\n\n\t@Override\n\tpublic List<String> getComments(int sunid) {\n\t\ttry {\n\t\t\tensureComInstalled();\n\t\t} catch (IOException e) {\n\t\t\tthrow new ScopIOException(e);\n\t\t}\n\t\tif (!commentsMap.containsKey(sunid)) return new ArrayList<String>(1);\n\t\treturn commentsMap.get(sunid);\n\t}\n\t\n\n\tprivate void initScopURLs() {\n\t\tif(!this.mirrors.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// first, try default scop\n\t\tScopMirror primary = new ScopMirror();\n\t\t// If unreachable, try alternate Berkeley location\n\t\tScopMirror alt = new ScopMirror(\n\t\t\t\tSCOP_DOWNLOAD_ALTERNATE,\n\t\t\t\t\"dir.cla.scop.%s.txt\",\"dir.des.scop.%s.txt\",\n\t\t\t\t\"dir.hie.scop.%s.txt\",\"dir.com.scop.%s.txt\");\n\t\tmirrors.add(primary);\n\t\tmirrors.add(alt);\n\t}\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.test.scop;\n\nimport org.biojava.nbio.structure.scop.ScopDatabase;\nimport org.biojava.nbio.structure.scop.ScopFactory;\nimport org.biojava.nbio.structure.scop.ScopInstallation;\nimport org.biojava.nbio.structure.scop.ScopMirror;\nimport org.junit.Assume;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n/**\n * Tests {@link ScopInstallation}.\n * @author dmyerstu\n * @since 3.0.6\n */\n@RunWith(Parameterized.class)\npublic class ScopInstallationTest extends ScopDatabaseTest {\n\n\tpublic ScopInstallationTest(String tag,ScopDatabase scop) {\n\t\tsuper(tag,scop);\n\t}\n\n\t//@Parameters\n\t@Parameters(name=\"{0}\")\n\tpublic static Collection<Object[]> availableDatabases() {\n\t\tArrayList<Object[]> databases = new ArrayList<Object[]>();\n\t\tScopInstallation scop;\n\n\t\tfor(String version : new String[] {\n\t\t\t\tScopFactory.VERSION_1_75,\n\t\t\t\tScopFactory.VERSION_1_73,\n\t\t\t\tScopFactory.VERSION_1_71,\n\t\t}) {\n\t\t\tscop = new ScopInstallation();\n\t\t\tscop.setScopVersion(version);\n\n\t\t\t// Don't fail if the server is down\n\t\t\tboolean reachable = false;\n\t\t\tfor(ScopMirror mirror: scop.getMirrors()) {\n\t\t\t\tif(mirror.isReachable()) {\n\t\t\t\t\treachable = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tAssume.assumeTrue(\"SCOP server is currently unreachable.\",reachable);\n\n\t\t\tdatabases.add(new Object[] {version, scop});\n\t\t}\n\t\treturn databases;\n\t}\n\n}\n","changedTest":"","commitMessage":"Improvements to ScopInstallation\n","test_commitMessage":"","allZero":false}