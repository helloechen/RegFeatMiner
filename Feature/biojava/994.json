{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/util/RotationAxis.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/util/RotationAxisTest.java","prod_time":"2021-08-01 06:07:16","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":4,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"5f007ec36694513380ae0721187b95e2e001405b","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.StringWriter;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Calculates the rotation axis for an alignment\n *\n * <p>A superposition of two structures is generally represented as a rotation\n * matrix plus a translation vector. However, it can also be represented as an\n * axis of rotation plus some translation.\n *\n * <p>This class calculates the rotation axis and stores it as four properties:\n * <ul><li>A unit vector parallel to the rotation axis ({@link #getRotationAxis()})\n * <li>The angle of rotation ({@link #getAngle()})\n * <li>A point on the rotation axis ({@link #getRotationPos()})\n * <li>Some translation parallel to the axis ({@link #getScrewTranslation()})\n * </ul>\n *\n * <p>The axis of rotation is poorly defined and numerically unstable for small\n * angles. Therefore it's direction is left as null for angles less than\n * {@link #MIN_ANGLE}.\n *\n * @author Spencer Bliven\n *\n */\npublic final class RotationAxis {\n\n\t/**\n\t * Minimum angle to calculate rotation axes. 5 degrees.\n\t */\n\tstatic final double MIN_ANGLE = Math.toRadians(5.);\n\n\tprivate double theta;\n\tprivate Atom rotationAxis; // axis of rotation\n\tprivate Atom rotationPos; // a point on the axis of rotation\n\tprivate Atom screwTranslation; //translation parallel to the axis of rotation\n\tprivate Atom otherTranslation; // translation perpendicular to the axis of rotation\n\n\t/**\n\t * The rotation angle\n\t * @return the angle, in radians\n\t */\n\tpublic double getAngle() {\n\t\treturn theta;\n\t}\n\n\t/**\n\t * Get a unit vector along the rotation axis\n\t * @return rotationAxis\n\t */\n\tpublic Atom getRotationAxis() {\n\t\treturn rotationAxis;\n\t}\n\n\t/**\n\t * Returns the rotation axis and angle in a single javax.vecmath.AxisAngle4d object\n\t * @return\n\t */\n\tpublic AxisAngle4d getAxisAngle4d() {\n\t\treturn new AxisAngle4d(rotationAxis.getX(),rotationAxis.getY(),rotationAxis.getZ(),theta);\n\t}\n\n\t/**\n\t * Get a position on the rotation axis.\n\t *\n\t * Specifically, project the origin onto the rotation axis\n\t * @return rotationPos\n\t */\n\tpublic Atom getRotationPos() {\n\t\treturn rotationPos;\n\t}\n\n\t/**\n\t * Get the component of translation parallel to the axis of rotation\n\t * @return\n\t */\n\tpublic Atom getScrewTranslation() {\n\t\treturn screwTranslation;\n\t}\n\n\tpublic Vector3d getVector3dScrewTranslation() {\n\t\treturn new Vector3d(screwTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ());\n\t}\n\n\tpublic double getTranslation() {\n\t\treturn Calc.amount(screwTranslation);\n\t}\n\n\t/**\n\t * Calculate the rotation axis for the first block of an AFPChain\n\t * @param afpChain\n\t * @throws StructureException\n\t * @throws NullPointerException if afpChain does not contain a valid rotation matrix and shift vector\n\t */\n\tpublic RotationAxis(AFPChain afpChain) throws StructureException {\n\t\tif(afpChain.getAlnLength() < 1) {\n\t\t\tthrow new StructureException(\"No aligned residues\");\n\t\t}\n\t\tinit(afpChain.getBlockRotationMatrix()[0],afpChain.getBlockShiftVector()[0]);\n\t}\n\n\t/**\n\t * Create a rotation axis from a vector, a point, and an angle.\n\t *\n\t * The result will be a pure rotation, with no screw component.\n\t * @param axis A vector parallel to the axis of rotation\n\t * @param pos A point on the axis of rotation\n\t * @param theta The angle to rotate (radians)\n\t */\n\tpublic RotationAxis(Atom axis, Atom pos, double theta) {\n\t\tthis.rotationAxis = Calc.unitVector(axis);\n\t\tthis.rotationPos = (Atom) pos.clone();\n\t\tthis.theta = theta;\n\t\tthis.screwTranslation = new AtomImpl(); //zero\n\t\tthis.otherTranslation = null; //deprecated\n\t}\n\n\t/**\n\t * Determine the location of the rotation axis based on a rotation matrix and a translation vector\n\t * @param rotation\n\t * @param translation\n\t */\n\tpublic RotationAxis(Matrix rotation, Atom translation) {\n\t\tinit(rotation, translation);\n\t}\n\n\t/**\n\t * Create a rotation axis from a Matrix4d containing a rotational\n\t * component and a translational component.\n\t *\n\t * @param transform\n\t */\n\tpublic RotationAxis(Matrix4d transform) {\n\n\t\tMatrix rot = Matrices.getRotationJAMA(transform);\n\t\tAtom transl = Calc.getTranslationVector(transform);\n\t\tinit(rot,transl);\n\t}\n\n\t/**\n\t * Get the rotation matrix corresponding to this axis\n\t * @return A 3x3 rotation matrix\n\t */\n\tpublic Matrix getRotationMatrix() {\n\t\treturn getRotationMatrix(theta);\n\t}\n\n\t/**\n\t * Get the rotation matrix corresponding to a rotation about this axis\n\t * @param theta The amount to rotate\n\t * @return A 3x3 rotation matrix\n\t */\n\tpublic Matrix getRotationMatrix(double theta) {\n\t\tif( rotationAxis == null) {\n\t\t\t// special case for pure translational axes\n\t\t\treturn Matrix.identity(3, 3);\n\t\t}\n\t\tdouble x = rotationAxis.getX();\n\t\tdouble y = rotationAxis.getY();\n\t\tdouble z = rotationAxis.getZ();\n\t\tdouble cos = Math.cos(theta);\n\t\tdouble sin = Math.sin(theta);\n\t\tdouble com = 1 - cos;\n\t\treturn new Matrix(new double[][] {\n\t\t\t\t{com*x*x + cos, com*x*y+sin*z, com*x*z+-sin*y},\n\t\t\t\t{com*x*y-sin*z, com*y*y+cos, com*y*z+sin*x},\n\t\t\t\t{com*x*z+sin*y, com*y*z-sin*x, com*z*z+cos},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the rotation order o that gives the lowest value of {@code |2PI / o - theta},\n\t * given that the value is strictly lower than {@code threshold}, for orders {@code o=1,...,maxOrder}.\n\t */\n\tpublic int guessOrderFromAngle(double threshold, int maxOrder) {\n\t\tdouble bestDelta = threshold;\n\t\tint bestOrder = 1;\n\t\tfor (int order = 2; order < maxOrder; order++) {\n\t\t\tdouble delta = Math.abs(2 * Math.PI / order - theta);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tbestOrder = order;\n\t\t\t\tbestDelta = delta;\n\t\t\t}\n\t\t}\n\t\treturn bestOrder;\n\t}\n\n\n\t/**\n\t * Returns a matrix that describes both rotation and translation.\n\t */\n\tpublic Matrix getFullMatrix() {\n\t\treturn null; // TODO, easy\n\t}\n\n\t/**\n\t * Initialize variables\n\t *\n\t * @param rotation\n\t * @param translation\n\t */\n\tprivate void init(Matrix rotation, Atom translation) {\n\t\tif(rotation.getColumnDimension() != 3 || rotation.getRowDimension() != 3) {\n\t\t\tthrow new IllegalArgumentException(\"Expected 3x3 rotation matrix\");\n\t\t}\n\n\n\t\t// Calculate angle\n\t\tdouble c = (rotation.trace()-1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\tthis.theta = Math.acos(c);\n\n\t\tif(theta < MIN_ANGLE) {\n\t\t\tcalculateTranslationalAxis(rotation,translation);\n\t\t} else {\n\t\t\tcalculateRotationalAxis(rotation, translation, c);\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the rotation axis for the normal case, where there is a\n\t * significant rotation angle\n\t * @param rotation\n\t * @param translation\n\t * @param c\n\t */\n\tprivate void calculateRotationalAxis(Matrix rotation, Atom translation,\n\t\t\tdouble c) {\n\t\t// Calculate magnitude of rotationAxis components, but not signs\n\t\tdouble sum=0;\n\t\tdouble[] rotAx = new double[3];\n\t\tfor(int i=0;i<3;i++) {\n\t\t\trotAx[i] = Math.sqrt(rotation.get(i, i)-c);\n\t\t\tsum+=rotAx[i]*rotAx[i];\n\t\t}\n\t\tfor(int i=0;i<3;i++) {\n\t\t\trotAx[i] /= Math.sqrt(sum);\n\t\t}\n\n\t\t// Now determine signs\n\t\tdouble d0 = rotation.get(2,1)-rotation.get(1,2); //=2u[0]*sin(theta)\n\t\tdouble d1 = rotation.get(0,2)-rotation.get(2,0); //=2u[1]*sin(theta)\n\t\tdouble d2 = rotation.get(1,0)-rotation.get(0,1); //=2u[2]*sin(theta)\n\n\t\tdouble s12 = rotation.get(2,1)+rotation.get(1,2); //=2*u[1]*u[2]*(1-cos(theta))\n\t\tdouble s02 = rotation.get(0,2)+rotation.get(2,0); //=2*u[0]*u[2]*(1-cos(theta))\n\t\tdouble s01 = rotation.get(1,0)+rotation.get(0,1); //=2*u[0]*u[1]*(1-cos(theta))\n\n\t\t//Only use biggest d for the sign directly, for numerical stability around 180deg\n\t\tif( Math.abs(d0) < Math.abs(d1) ) { // not d0\n\t\t\tif( Math.abs(d1) < Math.abs(d2) ) { //d2\n\t\t\t\tif(d2>=0){ //u[2] positive\n\t\t\t\t\tif( s02 < 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t} else { //u[2] negative\n\t\t\t\t\trotAx[2] = -rotAx[2];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t}\n\t\t\t} else { //d1\n\t\t\t\tif(d1>=0) {//u[1] positive\n\t\t\t\t\tif( s01 < 0) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0) rotAx[2] = -rotAx[2];\n\t\t\t\t} else { //u[1] negative\n\t\t\t\t\trotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s01 >= 0) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0) rotAx[2] = -rotAx[2];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // not d1\n\t\t\tif( Math.abs(d0) < Math.abs(d2) ) { //d2\n\t\t\t\tif(d2>=0){ //u[2] positive\n\t\t\t\t\tif( s02 < 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t} else { //u[2] negative\n\t\t\t\t\trotAx[2] = -rotAx[2];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t}\n\t\t\t} else { //d0\n\t\t\t\tif(d0>=0) { //u[0] positive\n\t\t\t\t\tif( s01 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s02 < 0 ) rotAx[2] = -rotAx[2];\n\t\t\t\t} else { //u[0] negative\n\t\t\t\t\trotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s01 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[2] = -rotAx[2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trotationAxis = new AtomImpl();\n\t\trotationAxis.setCoords(rotAx);\n\n\t\t// Calculate screw = (rotationAxis dot translation)*u\n\t\tdouble dotProduct = Calc.scalarProduct(rotationAxis, translation);\n\n\t\tscrewTranslation = Calc.scale(rotationAxis, dotProduct);\n\t\totherTranslation = Calc.subtract(translation, screwTranslation);\n\n\t\tAtom hypot = Calc.vectorProduct(otherTranslation,rotationAxis);\n\t\tCalc.scaleEquals(hypot,.5/Math.tan(theta/2.0));\n\n\t\t// Calculate rotation axis position\n\t\trotationPos = Calc.scaleAdd(.5,otherTranslation, hypot);\n\t}\n\n\t/**\n\t * Handle cases with small angles of rotation\n\t * @param rotation\n\t * @param translation\n\t */\n\tprivate void calculateTranslationalAxis(Matrix rotation, Atom translation) {\n\t\t// set axis parallel to translation\n\t\trotationAxis = Calc.scale(translation, 1./Calc.amount(translation));\n\n\t\t// position is undefined\n\t\trotationPos = null;\n\n\t\tscrewTranslation = translation;\n\t\totherTranslation = new AtomImpl();\n\t\totherTranslation.setCoords(new double[] {0,0,0});\n\t}\n\n\t/**\n\t * Returns a Jmol script which will display the axis of rotation. This\n\t * consists of a cyan arrow along the axis, plus an arc showing the angle\n\t * of rotation.\n\t * <p>\n\t * As the rotation angle gets smaller, the axis of rotation becomes poorly\n\t * defined and would need to get farther and farther away from the protein.\n\t * This is not particularly useful, so we arbitrarily draw it parallel to\n\t * the translation and omit the arc.\n\t * @param atoms Some atoms from the protein, used for determining the bounds\n\t *  \t  of the axis.\n\t *\n\t * @return The Jmol script, suitable for calls to\n\t * {@link org.biojava.nbio.structure.align.gui.jmol.StructureAlignmentJmol#evalString() jmol.evalString()}\n\t */\n\tpublic String getJmolScript(Atom[] atoms){\n\t\treturn getJmolScript(atoms, 0);\n\t}\n\n\t/**\n\t * Find a segment of the axis that covers the specified set of atoms.\n\t * <p>\n\t * Projects the input atoms onto the rotation axis and returns the bounding\n\t * points.\n\t * <p>\n\t * In the case of a pure translational axis, the axis location is undefined\n\t * so the center of mass will be used instead.\n\t * @param atoms\n\t * @return two points defining the axis segment\n\t */\n\tpublic Pair<Atom> getAxisEnds(Atom[] atoms) {\n\t\t// Project each Atom onto the rotation axis to determine limits\n\t\tdouble min, max;\n\t\tmin = max = Calc.scalarProduct(rotationAxis,atoms[0]);\n\t\tfor(int i=1;i<atoms.length;i++) {\n\t\t\tdouble prod = Calc.scalarProduct(rotationAxis,atoms[i]);\n\t\t\tif(prod<min) min = prod;\n\t\t\tif(prod>max) max = prod;\n\t\t}\n\t\tdouble uLen = Calc.scalarProduct(rotationAxis,rotationAxis);// Should be 1, but double check\n\t\tmin/=uLen;\n\t\tmax/=uLen;\n\n\t\t// Project the origin onto the axis. If the axis is undefined, use the center of mass\n\t\tAtom axialPt;\n\t\tif(rotationPos == null) {\n\t\t\tAtom center = Calc.centerOfMass(atoms);\n\n\t\t\t// Project center onto the axis\n\t\t\tAtom centerOnAxis = Calc.scale(rotationAxis, Calc.scalarProduct(center, rotationAxis));\n\n\t\t\t// Remainder is projection of origin onto axis\n\t\t\taxialPt = Calc.subtract(center, centerOnAxis);\n\n\t\t} else {\n\t\t\taxialPt = rotationPos;\n\t\t}\n\n\t\t// Find end points of the rotation axis to display\n\t\tAtom axisMin = (Atom) axialPt.clone();\n\t\tCalc.scaleAdd(min, rotationAxis, axisMin);\n\t\tAtom axisMax = (Atom) axialPt.clone();\n\t\tCalc.scaleAdd(max, rotationAxis, axisMax);\n\n\t\treturn new Pair<>(axisMin, axisMax);\n\t}\n\t/**\n\t * Returns a Jmol script which will display the axis of rotation. This\n\t * consists of a cyan arrow along the axis, plus an arc showing the angle\n\t * of rotation.\n\t * <p>\n\t * As the rotation angle gets smaller, the axis of rotation becomes poorly\n\t * defined and would need to get farther and farther away from the protein.\n\t * This is not particularly useful, so we arbitrarily draw it parallel to\n\t * the translation and omit the arc.\n\t * @param atoms Some atoms from the protein, used for determining the bounds\n\t *  \t  of the axis.\n\t * @param axisID in case of representing more than one axis in the same jmol\n\t * \t\t  panel, indicate the ID number.\n\t *\n\t * @return The Jmol script, suitable for calls to\n\t * {@link org.biojava.nbio.structure.align.gui.jmol.StructureAlignmentJmol#evalString() jmol.evalString()}\n\t */\n\tpublic String getJmolScript(Atom[] atoms, int axisID){\n\t\tfinal double width=.5;// width of JMol object\n\t\tfinal String axisColor = \"yellow\"; //axis color\n\t\tfinal String screwColor = \"orange\"; //screw translation color\n\n\t\tPair<Atom> endPoints = getAxisEnds(atoms);\n\t\tAtom axisMin = endPoints.getFirst();\n\t\tAtom axisMax = endPoints.getSecond();\n\n\t\tStringWriter result = new StringWriter();\n\n\t\t// set arrow heads to a reasonable length\n\t\tresult.append(\"set defaultDrawArrowScale 2.0;\");\n\n\t\t// draw axis of rotation\n\t\tresult.append(\n\t\t\t\tString.format(\"draw ID rot\"+axisID+\" CYLINDER {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(), width, axisColor ));\n\n\t\t// draw screw component\n\t\tboolean positiveScrew = Math.signum(rotationAxis.getX()) == Math.signum(screwTranslation.getX());\n\t\tif( positiveScrew ) {\n\t\t\t// screw is in the same direction as the axis\n\t\t\tresult.append( String.format(\n\t\t\t\t\t\"draw ID screw\"+axisID+\" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(),\n\t\t\t\t\tscrewTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ(),\n\t\t\t\t\twidth, screwColor ));\n\t\t} else {\n\t\t\t// screw is in the opposite direction as the axis\n\t\t\tresult.append( String.format(\n\t\t\t\t\t\"draw ID screw\"+axisID+\" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\tscrewTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ(),\n\t\t\t\t\twidth, screwColor ));\n\t\t}\n\n\t\t// draw angle of rotation\n\t\tif(rotationPos != null) {\n\t\t\tresult.append(System.getProperty(\"line.separator\"));\n\t\t\tresult.append(String.format(\"draw ID rotArc\"+axisID+\" ARC {%f,%f,%f} {%f,%f,%f} {0,0,0} {0,%f,%d} SCALE 500 DIAMETER %f COLOR %s;\",\n\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(),\n\t\t\t\t\tMath.toDegrees(theta),\n\t\t\t\t\tpositiveScrew ? 0 : 1 , // draw at the opposite end from the screw arrow\n\t\t\t\t\t\t\twidth, axisColor ));\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Projects a given point onto the axis of rotation\n\t * @param point\n\t * @return An atom which lies on the axis, or null if the RotationAxis is purely translational\n\t */\n\tpublic Atom getProjectedPoint(Atom point) {\n\t\tif(rotationPos == null) {\n\t\t\t// translation only\n\t\t\treturn null;\n\t\t}\n\n\t\tAtom localPoint = Calc.subtract(point, rotationPos);\n\t\tdouble dot = Calc.scalarProduct(localPoint, rotationAxis);\n\n\t\tAtom localProjected = Calc.scale(rotationAxis, dot);\n\t\tAtom projected = Calc.add(localProjected, rotationPos);\n\t\treturn projected;\n\t}\n\n\t/**\n\t * Get the distance from a point to the axis of rotation\n\t * @param point\n\t * @return The distance to the axis, or NaN if the RotationAxis is purely translational\n\t */\n\tpublic double getProjectedDistance(Atom point) {\n\t\tAtom projected = getProjectedPoint(point);\n\t\tif( projected == null) {\n\t\t\t// translation only\n\t\t\treturn Double.NaN;\n\t\t}\n\n\n\t\treturn Calc.getDistance(point, projected);\n\n\t}\n\n\tpublic void rotate(Atom[] atoms, double theta) {\n\t\tMatrix rot = getRotationMatrix(theta);\n\t\tif(rotationPos == null) {\n\t\t\t// Undefined rotation axis; do nothing\n\t\t\treturn;\n\t\t}\n\t\tAtom negPos;\n\n\t\t\tnegPos = Calc.invert(rotationPos);\n\n\t\tfor(Atom a: atoms) {\n\t\t\tCalc.shift(a, negPos);\n\t\t}\n\t\tCalc.rotate(atoms, rot);\n\t\tfor(Atom a: atoms) {\n\t\t\tCalc.shift(a, rotationPos);\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the rotation angle for a structure\n\t * @param afpChain\n\t * @return The rotation angle, in radians\n\t * @throws StructureException If the alignment doesn't contain any blocks\n\t * @throws NullPointerException If the alignment doesn't have a rotation matrix set\n\t */\n\tpublic static double getAngle(AFPChain afpChain) throws StructureException {\n\t\tif(afpChain.getBlockNum() < 1) {\n\t\t\tthrow new StructureException(\"No aligned residues\");\n\t\t}\n\t\tMatrix rotation = afpChain.getBlockRotationMatrix()[0];\n\n\t\tif(rotation == null) {\n\t\t\tthrow new NullPointerException(\"AFPChain does not contain a rotation matrix\");\n\t\t}\n\t\treturn getAngle(rotation);\n\t}\n\t/**\n\t * Calculate the rotation angle for a given matrix\n\t * @param rotation Rotation matrix\n\t * @return The angle, in radians\n\t */\n\tpublic static double getAngle(Matrix rotation) {\n\t\tdouble c = (rotation.trace()-1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n\n\t/**\n\t *\n\t * @return If the rotation axis is well defined, rather than purely translational\n\t */\n\tpublic boolean isDefined() {\n\t\treturn rotationPos != null;\n\t}\n\n\t/**\n\t * Quickly compute the rotation angle from a rotation matrix.\n\t * @param transform 4D transformation matrix. Translation components are ignored.\n\t * @return Angle, from 0 to PI\n\t */\n\tpublic static double getAngle(Matrix4d transform) {\n\t\t// Calculate angle\n\t\tdouble c = (transform.m00 + transform.m11 + transform.m22 - 1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n\n\t/**\n\t * Quickly compute the rotation angle from a rotation matrix.\n\t * @param transform 3D rotation matrix\n\t * @return Angle, from 0 to PI\n\t */\n\tpublic static double getAngle(Matrix3d transform) {\n\t\t// Calculate angle\n\t\tdouble c = (transform.m00 + transform.m11 + transform.m22 - 1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport java.io.StringWriter;\nimport java.util.Locale;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.contact.Pair;\nimport org.biojava.nbio.structure.geometry.Matrices;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Calculates the rotation axis for an alignment\n *\n * <p>A superposition of two structures is generally represented as a rotation\n * matrix plus a translation vector. However, it can also be represented as an\n * axis of rotation plus some translation.\n *\n * <p>This class calculates the rotation axis and stores it as four properties:\n * <ul><li>A unit vector parallel to the rotation axis ({@link #getRotationAxis()})\n * <li>The angle of rotation ({@link #getAngle()})\n * <li>A point on the rotation axis ({@link #getRotationPos()})\n * <li>Some translation parallel to the axis ({@link #getScrewTranslation()})\n * </ul>\n *\n * <p>The axis of rotation is poorly defined and numerically unstable for small\n * angles. Therefore it's direction is left as null for angles less than\n * {@link #MIN_ANGLE}.\n *\n * @author Spencer Bliven\n *\n */\npublic final class RotationAxis {\n\n\t/**\n\t * Minimum angle to calculate rotation axes. 5 degrees.\n\t */\n\tstatic final double MIN_ANGLE = Math.toRadians(5.);\n\n\tprivate double theta;\n\tprivate Atom rotationAxis; // axis of rotation\n\tprivate Atom rotationPos; // a point on the axis of rotation\n\tprivate Atom screwTranslation; //translation parallel to the axis of rotation\n\tprivate Atom otherTranslation; // translation perpendicular to the axis of rotation\n\n\t/**\n\t * The rotation angle\n\t * @return the angle, in radians\n\t */\n\tpublic double getAngle() {\n\t\treturn theta;\n\t}\n\n\t/**\n\t * Get a unit vector along the rotation axis\n\t * @return rotationAxis\n\t */\n\tpublic Atom getRotationAxis() {\n\t\treturn rotationAxis;\n\t}\n\n\t/**\n\t * Returns the rotation axis and angle in a single javax.vecmath.AxisAngle4d object\n\t * @return\n\t */\n\tpublic AxisAngle4d getAxisAngle4d() {\n\t\treturn new AxisAngle4d(rotationAxis.getX(),rotationAxis.getY(),rotationAxis.getZ(),theta);\n\t}\n\n\t/**\n\t * Get a position on the rotation axis.\n\t *\n\t * Specifically, project the origin onto the rotation axis\n\t * @return rotationPos\n\t */\n\tpublic Atom getRotationPos() {\n\t\treturn rotationPos;\n\t}\n\n\t/**\n\t * Get the component of translation parallel to the axis of rotation\n\t * @return\n\t */\n\tpublic Atom getScrewTranslation() {\n\t\treturn screwTranslation;\n\t}\n\n\tpublic Vector3d getVector3dScrewTranslation() {\n\t\treturn new Vector3d(screwTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ());\n\t}\n\n\tpublic double getTranslation() {\n\t\treturn Calc.amount(screwTranslation);\n\t}\n\n\t/**\n\t * Calculate the rotation axis for the first block of an AFPChain\n\t * @param afpChain\n\t * @throws StructureException\n\t * @throws NullPointerException if afpChain does not contain a valid rotation matrix and shift vector\n\t */\n\tpublic RotationAxis(AFPChain afpChain) throws StructureException {\n\t\tif(afpChain.getAlnLength() < 1) {\n\t\t\tthrow new StructureException(\"No aligned residues\");\n\t\t}\n\t\tinit(afpChain.getBlockRotationMatrix()[0],afpChain.getBlockShiftVector()[0]);\n\t}\n\n\t/**\n\t * Create a rotation axis from a vector, a point, and an angle.\n\t *\n\t * The result will be a pure rotation, with no screw component.\n\t * @param axis A vector parallel to the axis of rotation\n\t * @param pos A point on the axis of rotation\n\t * @param theta The angle to rotate (radians)\n\t */\n\tpublic RotationAxis(Atom axis, Atom pos, double theta) {\n\t\tthis.rotationAxis = Calc.unitVector(axis);\n\t\tthis.rotationPos = (Atom) pos.clone();\n\t\tthis.theta = theta;\n\t\tthis.screwTranslation = new AtomImpl(); //zero\n\t\tthis.otherTranslation = null; //deprecated\n\t}\n\n\t/**\n\t * Determine the location of the rotation axis based on a rotation matrix and a translation vector\n\t * @param rotation\n\t * @param translation\n\t */\n\tpublic RotationAxis(Matrix rotation, Atom translation) {\n\t\tinit(rotation, translation);\n\t}\n\n\t/**\n\t * Create a rotation axis from a Matrix4d containing a rotational\n\t * component and a translational component.\n\t *\n\t * @param transform\n\t */\n\tpublic RotationAxis(Matrix4d transform) {\n\n\t\tMatrix rot = Matrices.getRotationJAMA(transform);\n\t\tAtom transl = Calc.getTranslationVector(transform);\n\t\tinit(rot,transl);\n\t}\n\n\t/**\n\t * Get the rotation matrix corresponding to this axis\n\t * @return A 3x3 rotation matrix\n\t */\n\tpublic Matrix getRotationMatrix() {\n\t\treturn getRotationMatrix(theta);\n\t}\n\n\t/**\n\t * Get the rotation matrix corresponding to a rotation about this axis\n\t * @param theta The amount to rotate\n\t * @return A 3x3 rotation matrix\n\t */\n\tpublic Matrix getRotationMatrix(double theta) {\n\t\tif( rotationAxis == null) {\n\t\t\t// special case for pure translational axes\n\t\t\treturn Matrix.identity(3, 3);\n\t\t}\n\t\tdouble x = rotationAxis.getX();\n\t\tdouble y = rotationAxis.getY();\n\t\tdouble z = rotationAxis.getZ();\n\t\tdouble cos = Math.cos(theta);\n\t\tdouble sin = Math.sin(theta);\n\t\tdouble com = 1 - cos;\n\t\treturn new Matrix(new double[][] {\n\t\t\t\t{com*x*x + cos, com*x*y+sin*z, com*x*z+-sin*y},\n\t\t\t\t{com*x*y-sin*z, com*y*y+cos, com*y*z+sin*x},\n\t\t\t\t{com*x*z+sin*y, com*y*z-sin*x, com*z*z+cos},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the rotation order o that gives the lowest value of {@code |2PI / o - theta},\n\t * given that the value is strictly lower than {@code threshold}, for orders {@code o=1,...,maxOrder}.\n\t */\n\tpublic int guessOrderFromAngle(double threshold, int maxOrder) {\n\t\tdouble bestDelta = threshold;\n\t\tint bestOrder = 1;\n\t\tfor (int order = 2; order < maxOrder; order++) {\n\t\t\tdouble delta = Math.abs(2 * Math.PI / order - theta);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tbestOrder = order;\n\t\t\t\tbestDelta = delta;\n\t\t\t}\n\t\t}\n\t\treturn bestOrder;\n\t}\n\n\n\t/**\n\t * Returns a matrix that describes both rotation and translation.\n\t */\n\tpublic Matrix getFullMatrix() {\n\t\treturn null; // TODO, easy\n\t}\n\n\t/**\n\t * Initialize variables\n\t *\n\t * @param rotation\n\t * @param translation\n\t */\n\tprivate void init(Matrix rotation, Atom translation) {\n\t\tif(rotation.getColumnDimension() != 3 || rotation.getRowDimension() != 3) {\n\t\t\tthrow new IllegalArgumentException(\"Expected 3x3 rotation matrix\");\n\t\t}\n\n\n\t\t// Calculate angle\n\t\tdouble c = (rotation.trace()-1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\tthis.theta = Math.acos(c);\n\n\t\tif(theta < MIN_ANGLE) {\n\t\t\tcalculateTranslationalAxis(rotation,translation);\n\t\t} else {\n\t\t\tcalculateRotationalAxis(rotation, translation, c);\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the rotation axis for the normal case, where there is a\n\t * significant rotation angle\n\t * @param rotation\n\t * @param translation\n\t * @param c\n\t */\n\tprivate void calculateRotationalAxis(Matrix rotation, Atom translation,\n\t\t\tdouble c) {\n\t\t// Calculate magnitude of rotationAxis components, but not signs\n\t\tdouble sum=0;\n\t\tdouble[] rotAx = new double[3];\n\t\tfor(int i=0;i<3;i++) {\n\t\t\trotAx[i] = Math.sqrt(rotation.get(i, i)-c);\n\t\t\tsum+=rotAx[i]*rotAx[i];\n\t\t}\n\t\tfor(int i=0;i<3;i++) {\n\t\t\trotAx[i] /= Math.sqrt(sum);\n\t\t}\n\n\t\t// Now determine signs\n\t\tdouble d0 = rotation.get(2,1)-rotation.get(1,2); //=2u[0]*sin(theta)\n\t\tdouble d1 = rotation.get(0,2)-rotation.get(2,0); //=2u[1]*sin(theta)\n\t\tdouble d2 = rotation.get(1,0)-rotation.get(0,1); //=2u[2]*sin(theta)\n\n\t\tdouble s12 = rotation.get(2,1)+rotation.get(1,2); //=2*u[1]*u[2]*(1-cos(theta))\n\t\tdouble s02 = rotation.get(0,2)+rotation.get(2,0); //=2*u[0]*u[2]*(1-cos(theta))\n\t\tdouble s01 = rotation.get(1,0)+rotation.get(0,1); //=2*u[0]*u[1]*(1-cos(theta))\n\n\t\t//Only use biggest d for the sign directly, for numerical stability around 180deg\n\t\tif( Math.abs(d0) < Math.abs(d1) ) { // not d0\n\t\t\tif( Math.abs(d1) < Math.abs(d2) ) { //d2\n\t\t\t\tif(d2>=0){ //u[2] positive\n\t\t\t\t\tif( s02 < 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t} else { //u[2] negative\n\t\t\t\t\trotAx[2] = -rotAx[2];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t}\n\t\t\t} else { //d1\n\t\t\t\tif(d1>=0) {//u[1] positive\n\t\t\t\t\tif( s01 < 0) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0) rotAx[2] = -rotAx[2];\n\t\t\t\t} else { //u[1] negative\n\t\t\t\t\trotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s01 >= 0) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0) rotAx[2] = -rotAx[2];\n\t\t\t\t}\n\t\t\t}\n\t\t} else { // not d1\n\t\t\tif( Math.abs(d0) < Math.abs(d2) ) { //d2\n\t\t\t\tif(d2>=0){ //u[2] positive\n\t\t\t\t\tif( s02 < 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t} else { //u[2] negative\n\t\t\t\t\trotAx[2] = -rotAx[2];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s12 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t}\n\t\t\t} else { //d0\n\t\t\t\tif(d0>=0) { //u[0] positive\n\t\t\t\t\tif( s01 < 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s02 < 0 ) rotAx[2] = -rotAx[2];\n\t\t\t\t} else { //u[0] negative\n\t\t\t\t\trotAx[0] = -rotAx[0];\n\t\t\t\t\tif( s01 >= 0 ) rotAx[1] = -rotAx[1];\n\t\t\t\t\tif( s02 >= 0 ) rotAx[2] = -rotAx[2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trotationAxis = new AtomImpl();\n\t\trotationAxis.setCoords(rotAx);\n\n\t\t// Calculate screw = (rotationAxis dot translation)*u\n\t\tdouble dotProduct = Calc.scalarProduct(rotationAxis, translation);\n\n\t\tscrewTranslation = Calc.scale(rotationAxis, dotProduct);\n\t\totherTranslation = Calc.subtract(translation, screwTranslation);\n\n\t\tAtom hypot = Calc.vectorProduct(otherTranslation,rotationAxis);\n\t\tCalc.scaleEquals(hypot,.5/Math.tan(theta/2.0));\n\n\t\t// Calculate rotation axis position\n\t\trotationPos = Calc.scaleAdd(.5,otherTranslation, hypot);\n\t}\n\n\t/**\n\t * Handle cases with small angles of rotation\n\t * @param rotation\n\t * @param translation\n\t */\n\tprivate void calculateTranslationalAxis(Matrix rotation, Atom translation) {\n\t\t// set axis parallel to translation\n\t\trotationAxis = Calc.scale(translation, 1./Calc.amount(translation));\n\n\t\t// position is undefined\n\t\trotationPos = null;\n\n\t\tscrewTranslation = translation;\n\t\totherTranslation = new AtomImpl();\n\t\totherTranslation.setCoords(new double[] {0,0,0});\n\t}\n\n\t/**\n\t * Returns a Jmol script which will display the axis of rotation. This\n\t * consists of a cyan arrow along the axis, plus an arc showing the angle\n\t * of rotation.\n\t * <p>\n\t * As the rotation angle gets smaller, the axis of rotation becomes poorly\n\t * defined and would need to get farther and farther away from the protein.\n\t * This is not particularly useful, so we arbitrarily draw it parallel to\n\t * the translation and omit the arc.\n\t * @param atoms Some atoms from the protein, used for determining the bounds\n\t *  \t  of the axis.\n\t *\n\t * @return The Jmol script, suitable for calls to\n\t * {@link org.biojava.nbio.structure.align.gui.jmol.StructureAlignmentJmol#evalString() jmol.evalString()}\n\t */\n\tpublic String getJmolScript(Atom[] atoms){\n\t\treturn getJmolScript(atoms, 0);\n\t}\n\n\t/**\n\t * Find a segment of the axis that covers the specified set of atoms.\n\t * <p>\n\t * Projects the input atoms onto the rotation axis and returns the bounding\n\t * points.\n\t * <p>\n\t * In the case of a pure translational axis, the axis location is undefined\n\t * so the center of mass will be used instead.\n\t * @param atoms\n\t * @return two points defining the axis segment\n\t */\n\tpublic Pair<Atom> getAxisEnds(Atom[] atoms) {\n\t\t// Project each Atom onto the rotation axis to determine limits\n\t\tdouble min, max;\n\t\tmin = max = Calc.scalarProduct(rotationAxis,atoms[0]);\n\t\tfor(int i=1;i<atoms.length;i++) {\n\t\t\tdouble prod = Calc.scalarProduct(rotationAxis,atoms[i]);\n\t\t\tif(prod<min) min = prod;\n\t\t\tif(prod>max) max = prod;\n\t\t}\n\t\tdouble uLen = Calc.scalarProduct(rotationAxis,rotationAxis);// Should be 1, but double check\n\t\tmin/=uLen;\n\t\tmax/=uLen;\n\n\t\t// Project the origin onto the axis. If the axis is undefined, use the center of mass\n\t\tAtom axialPt;\n\t\tif(rotationPos == null) {\n\t\t\tAtom center = Calc.centerOfMass(atoms);\n\n\t\t\t// Project center onto the axis\n\t\t\tAtom centerOnAxis = Calc.scale(rotationAxis, Calc.scalarProduct(center, rotationAxis));\n\n\t\t\t// Remainder is projection of origin onto axis\n\t\t\taxialPt = Calc.subtract(center, centerOnAxis);\n\n\t\t} else {\n\t\t\taxialPt = rotationPos;\n\t\t}\n\n\t\t// Find end points of the rotation axis to display\n\t\tAtom axisMin = (Atom) axialPt.clone();\n\t\tCalc.scaleAdd(min, rotationAxis, axisMin);\n\t\tAtom axisMax = (Atom) axialPt.clone();\n\t\tCalc.scaleAdd(max, rotationAxis, axisMax);\n\n\t\treturn new Pair<>(axisMin, axisMax);\n\t}\n\t/**\n\t * Returns a Jmol script which will display the axis of rotation. This\n\t * consists of a cyan arrow along the axis, plus an arc showing the angle\n\t * of rotation.\n\t * <p>\n\t * As the rotation angle gets smaller, the axis of rotation becomes poorly\n\t * defined and would need to get farther and farther away from the protein.\n\t * This is not particularly useful, so we arbitrarily draw it parallel to\n\t * the translation and omit the arc.\n\t * @param atoms Some atoms from the protein, used for determining the bounds\n\t *  \t  of the axis.\n\t * @param axisID in case of representing more than one axis in the same jmol\n\t * \t\t  panel, indicate the ID number.\n\t *\n\t * @return The Jmol script, suitable for calls to\n\t * {@link org.biojava.nbio.structure.align.gui.jmol.StructureAlignmentJmol#evalString() jmol.evalString()}\n\t */\n\tpublic String getJmolScript(Atom[] atoms, int axisID){\n\t\tfinal double width=.5;// width of JMol object\n\t\tfinal String axisColor = \"yellow\"; //axis color\n\t\tfinal String screwColor = \"orange\"; //screw translation color\n\n\t\tPair<Atom> endPoints = getAxisEnds(atoms);\n\t\tAtom axisMin = endPoints.getFirst();\n\t\tAtom axisMax = endPoints.getSecond();\n\n\t\tStringWriter result = new StringWriter();\n\n\t\t// set arrow heads to a reasonable length\n\t\tresult.append(\"set defaultDrawArrowScale 2.0;\");\n\n\t\t// draw axis of rotation\n\t\tresult.append(\n\t\t\t\tString.format(Locale.US, \"draw ID rot\"+axisID+\" CYLINDER {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(), width, axisColor ));\n\n\t\t// draw screw component\n\t\tboolean positiveScrew = Math.signum(rotationAxis.getX()) == Math.signum(screwTranslation.getX());\n\t\tif( positiveScrew ) {\n\t\t\t// screw is in the same direction as the axis\n\t\t\tresult.append( String.format(Locale.US,\n\t\t\t\t\t\"draw ID screw\"+axisID+\" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(),\n\t\t\t\t\tscrewTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ(),\n\t\t\t\t\twidth, screwColor ));\n\t\t} else {\n\t\t\t// screw is in the opposite direction as the axis\n\t\t\tresult.append( String.format(Locale.US,\n\t\t\t\t\t\"draw ID screw\"+axisID+\" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\",\n\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\tscrewTranslation.getX(),screwTranslation.getY(),screwTranslation.getZ(),\n\t\t\t\t\twidth, screwColor ));\n\t\t}\n\n\t\t// draw angle of rotation\n\t\tif(rotationPos != null) {\n\t\t\tresult.append(System.getProperty(\"line.separator\"));\n\t\t\tresult.append(String.format(Locale.US, \"draw ID rotArc\"+axisID+\" ARC {%f,%f,%f} {%f,%f,%f} {0,0,0} {0,%f,%d} SCALE 500 DIAMETER %f COLOR %s;\",\n\t\t\t\t\taxisMin.getX(),axisMin.getY(),axisMin.getZ(),\n\t\t\t\t\taxisMax.getX(),axisMax.getY(),axisMax.getZ(),\n\t\t\t\t\tMath.toDegrees(theta),\n\t\t\t\t\tpositiveScrew ? 0 : 1 , // draw at the opposite end from the screw arrow\n\t\t\t\t\t\t\twidth, axisColor ));\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Projects a given point onto the axis of rotation\n\t * @param point\n\t * @return An atom which lies on the axis, or null if the RotationAxis is purely translational\n\t */\n\tpublic Atom getProjectedPoint(Atom point) {\n\t\tif(rotationPos == null) {\n\t\t\t// translation only\n\t\t\treturn null;\n\t\t}\n\n\t\tAtom localPoint = Calc.subtract(point, rotationPos);\n\t\tdouble dot = Calc.scalarProduct(localPoint, rotationAxis);\n\n\t\tAtom localProjected = Calc.scale(rotationAxis, dot);\n\t\tAtom projected = Calc.add(localProjected, rotationPos);\n\t\treturn projected;\n\t}\n\n\t/**\n\t * Get the distance from a point to the axis of rotation\n\t * @param point\n\t * @return The distance to the axis, or NaN if the RotationAxis is purely translational\n\t */\n\tpublic double getProjectedDistance(Atom point) {\n\t\tAtom projected = getProjectedPoint(point);\n\t\tif( projected == null) {\n\t\t\t// translation only\n\t\t\treturn Double.NaN;\n\t\t}\n\n\n\t\treturn Calc.getDistance(point, projected);\n\n\t}\n\n\tpublic void rotate(Atom[] atoms, double theta) {\n\t\tMatrix rot = getRotationMatrix(theta);\n\t\tif(rotationPos == null) {\n\t\t\t// Undefined rotation axis; do nothing\n\t\t\treturn;\n\t\t}\n\t\tAtom negPos;\n\n\t\t\tnegPos = Calc.invert(rotationPos);\n\n\t\tfor(Atom a: atoms) {\n\t\t\tCalc.shift(a, negPos);\n\t\t}\n\t\tCalc.rotate(atoms, rot);\n\t\tfor(Atom a: atoms) {\n\t\t\tCalc.shift(a, rotationPos);\n\t\t}\n\t}\n\n\t/**\n\t * Calculate the rotation angle for a structure\n\t * @param afpChain\n\t * @return The rotation angle, in radians\n\t * @throws StructureException If the alignment doesn't contain any blocks\n\t * @throws NullPointerException If the alignment doesn't have a rotation matrix set\n\t */\n\tpublic static double getAngle(AFPChain afpChain) throws StructureException {\n\t\tif(afpChain.getBlockNum() < 1) {\n\t\t\tthrow new StructureException(\"No aligned residues\");\n\t\t}\n\t\tMatrix rotation = afpChain.getBlockRotationMatrix()[0];\n\n\t\tif(rotation == null) {\n\t\t\tthrow new NullPointerException(\"AFPChain does not contain a rotation matrix\");\n\t\t}\n\t\treturn getAngle(rotation);\n\t}\n\t/**\n\t * Calculate the rotation angle for a given matrix\n\t * @param rotation Rotation matrix\n\t * @return The angle, in radians\n\t */\n\tpublic static double getAngle(Matrix rotation) {\n\t\tdouble c = (rotation.trace()-1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n\n\t/**\n\t *\n\t * @return If the rotation axis is well defined, rather than purely translational\n\t */\n\tpublic boolean isDefined() {\n\t\treturn rotationPos != null;\n\t}\n\n\t/**\n\t * Quickly compute the rotation angle from a rotation matrix.\n\t * @param transform 4D transformation matrix. Translation components are ignored.\n\t * @return Angle, from 0 to PI\n\t */\n\tpublic static double getAngle(Matrix4d transform) {\n\t\t// Calculate angle\n\t\tdouble c = (transform.m00 + transform.m11 + transform.m22 - 1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n\n\t/**\n\t * Quickly compute the rotation angle from a rotation matrix.\n\t * @param transform 3D rotation matrix\n\t * @return Angle, from 0 to PI\n\t */\n\tpublic static double getAngle(Matrix3d transform) {\n\t\t// Calculate angle\n\t\tdouble c = (transform.m00 + transform.m11 + transform.m22 - 1)/2.0; //=cos(theta)\n\t\t// c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n\t\tif( -1-1e-8 < c && c < -1 ) c = -1;\n\t\tif( 1+1e-8 > c && c > 1 ) c = 1;\n\t\tif( -1 > c || c > 1 ) {\n\t\t\tthrow new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n\t\t}\n\t\treturn Math.acos(c);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Oct 7, 2013\n * Author: blivens\n *\n */\n\n/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Oct 7, 2013\n * Author: blivens\n *\n */\npackage org.biojava.nbio.structure.align.util;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\n\n/**\n * @author blivens\n *\n */\npublic class RotationAxisTest {\n\n\t@Test\n\tpublic void testProjection() throws Exception{\n\t\tRotationAxis axis;\n\t\tAtom dir,pos,projected;\n\n\t\tdir = new AtomImpl();\n\t\tpos = new AtomImpl();\n\n\t\t// 180 around z\n\t\tdir.setCoords( new double[] {0,0,1});\n\t\tpos.setCoords( new double[] {0,0,0} );\n\t\taxis = new RotationAxis(dir, pos, Math.PI);\n\n\t\tpos.setCoords( new double[] {1,2,3});\n\t\tprojected = axis.getProjectedPoint(pos);\n\t\tassertArrayEquals(new double[] {0,0,3},projected.getCoords(),1e-14);\n\n\t\tdouble dist = axis.getProjectedDistance(pos);\n\t\tassertEquals(Math.sqrt(5),dist,1e-14);\n\n\n\t\t// main diagonal through (1,1,0)\n\t\tdir.setCoords( new double[] {2,2,2});\n\t\tpos.setCoords( new double[] {1,1,0});\n\t\taxis = new RotationAxis(dir, pos, Math.PI);\n\n\t\tpos.setCoords( new double[] {1,1,0});\n\t\tprojected = axis.getProjectedPoint(pos);\n\t\tassertArrayEquals(new double[] {1,1,0},projected.getCoords(),1e-14);\n\n\t\tpos.setCoords( new double[] {0,0,-1});\n\t\tprojected = axis.getProjectedPoint(pos);\n\t\tassertArrayEquals(new double[] {0,0,-1},projected.getCoords(),1e-14);\n\n\t\tpos.setCoords( new double[] {-.5,-.5,0});\n\t\tprojected = axis.getProjectedPoint(pos);\n\t\tassertArrayEquals(new double[] {0,0,-1},projected.getCoords(),1e-14);\n\n\t\tdist = axis.getProjectedDistance(pos);\n\t\tassertEquals(Math.sqrt(3/2.),dist,1e-14);\n\n\t\tpos.setCoords( new double[] {0,0,0});\n\t\tprojected = axis.getProjectedPoint(pos);\n\t\tassertArrayEquals(new double[] {1/3.,1/3.,-2/3.},projected.getCoords(),1e-14);\n\n\t}\n\n\t@Test\n\tpublic void testRotationAngle() {\n\t\tfinal double tol = 1e-10;\n\n\t\tdouble angle;\n\t\tAxisAngle4d axis;\n\t\tMatrix4d trans;\n\t\tdouble result;\n\n\t\t// positive\n\t\tangle = .57 * Math.PI;\n\t\taxis = new AxisAngle4d(3., -4., 5., angle);\n\t\ttrans = new Matrix4d();\n\t\ttrans.set(axis);\n\n\t\tresult = RotationAxis.getAngle(trans);\n\t\tassertEquals(angle, result, tol);\n\n\t\t// negative\n\t\tangle = -.57 * Math.PI;\n\t\taxis = new AxisAngle4d(3., -4., 5., angle);\n\t\ttrans = new Matrix4d();\n\t\ttrans.set(axis);\n\n\t\tresult = RotationAxis.getAngle(trans);\n\t\tassertEquals(Math.abs(angle), result, tol);\n\n\t}\n}\n","changedTest":"","commitMessage":"Force US Locale for floats.\n\n#918 showed that locales which use commas for floating-point numbers\ncan cause problems with output formats. This commit fixes a number\nof other cases.\n\n- Force Locale.US when outputting floats to files/streams\n- Usually don't force Locale.US when outputting floats to standard out &\n  logging (would lead to more consistent logs but breaks localization)\n- Replace some `println(String.format(` calls with Java 5 `printf`","test_commitMessage":"","allZero":false}