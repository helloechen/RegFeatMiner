{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/symmetry/internal/CeSymm.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/symmetry/internal/TestCeSymm.java","prod_time":"2016-01-26 22:48:15","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"2aa40ead92dcb7bb8ff0dad293d2674274bcfb5a","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.ce.CeCPMain;\nimport org.biojava.nbio.structure.align.ce.MatrixListener;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.util.AFPChainScorer;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucTools;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\nimport org.biojava.nbio.structure.symmetry.utils.SymmetryTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Identify the symmetries in a structure by running an alignment of the\n * structure against itself disabling the diagonal of the identity alignment.\n * <p>\n * Iterating over previous results and disabling the diagonal of the previous\n * alignments can also be done with this implementation, which will generate a\n * set of self-alignments (disabled, because none improvements were shown, but\n * can be turn on manually).\n * <p>\n * Multiple levels of symmetry can be analyzed by finding symmetries in subunits\n * of previous results. This feature allows to find multiple symmetry axes.\n * <p>\n * The alignment is then refined to obtain a consistent alignment among all\n * residues of the structure and organized into different parts, called\n * symmetric subunits.\n * <p>\n * After refinement of the initial alignment, an optimization step can be used\n * to improve the overall score of the subunit multiple alignment.\n * \n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class CeSymm {\n\n\t/**\n\t * Version History:\n\t * <p>\n\t * <ul>\n\t * <li>1.0 - initial implementation of CE-Symm.\n\t * <li>1.1 - enable multiple CE-Symm runs to calculate all self-alignments.\n\t * <li>2.0 - refine the alignment for consistency of subunit definition.\n\t * <li>2.1 - optimize the alignment to improve the score.\n\t * <li>2.2 - run multiple symmetry levels recursively to find PG and\n\t * hierarchical symmetries.\n\t * </ul>\n\t * </li>\n\t */\n\tpublic static final String version = \"2.2\";\n\tpublic static final String algorithmName = \"jCE-symm\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(CeSymm.class);\n\tprivate final static boolean multiPass = false; // multiple self-alignments\n\n\t/**\n\t * Prevent instantiation. Static class.\n\t */\n\tprivate CeSymm() {\n\t}\n\n\tprivate static Matrix align(AFPChain afpChain, Atom[] ca1, Atom[] ca2,\n\t\t\tCESymmParameters params, Matrix origM, CECalculator calculator,\n\t\t\tint counter) throws StructureException {\n\n\t\tint fragmentLength = params.getWinSize();\n\t\tAtom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tint blankWindowSize = fragmentLength;\n\t\tif (origM == null) {\n\n\t\t\t// Build alignment ca1 to ca2-ca2\n\t\t\tafpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, null, blankWindowSize);\n\n\t\t} else {\n\t\t\t// we are doing an iteration on a previous alignment\n\t\t\t// mask the previous alignment\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, origM, blankWindowSize);\n\t\t}\n\n\t\tMatrix clone = (Matrix) origM.clone();\n\n\t\t// that's the matrix to run the alignment on..\n\t\tcalculator.setMatMatrix(clone.getArray());\n\n\t\tcalculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n\n\t\tfinal Matrix origMfinal = (Matrix) origM.clone();\n\t\t// Add a matrix listener to keep the blacked zones in max.\n\t\tcalculator.addMatrixListener(new MatrixListener() {\n\n\t\t\t@Override\n\t\t\tpublic double[][] matrixInOptimizer(double[][] max) {\n\n\t\t\t\t// Check every entry of origM for blacked out regions\n\t\t\t\tfor (int i = 0; i < max.length; i++) {\n\t\t\t\t\tfor (int j = 0; j < max[i].length; j++) {\n\t\t\t\t\t\tif (origMfinal.getArray()[i][j] > 1e9) {\n\t\t\t\t\t\t\tmax[i][j] = -origMfinal.getArray()[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean[][] initializeBreakFlag(boolean[][] brkFlag) {\n\n\t\t\t\treturn brkFlag;\n\t\t\t}\n\t\t});\n\n\t\tcalculator.nextStep(afpChain, ca1, ca2clone);\n\n\t\tafpChain.setAlgorithmName(algorithmName);\n\t\tafpChain.setVersion(version);\n\n\t\tafpChain.setDistanceMatrix(origM);\n\n\t\treturn origMfinal;\n\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprotected static CeSymmResult align(Atom[] atoms, CESymmParameters params)\n\t\t\tthrows StructureException {\n\n\t\tCeSymmResult result = new CeSymmResult();\n\t\tresult.setParams(params);\n\t\tresult.setAtoms(atoms);\n\n\t\t// STEP 1: prepare all the information for the symmetry alignment\n\t\tAtom[] ca2 = StructureTools.duplicateCA2(atoms);\n\t\tint rows = atoms.length;\n\t\tint cols = ca2.length;\n\n\t\tif (rows == 0 || cols == 0) {\n\t\t\tthrow new StructureException(\"Aligning empty structure\");\n\t\t}\n\n\t\tMatrix origM = null;\n\t\tAFPChain myAFP = new AFPChain(algorithmName);\n\t\tCECalculator calculator = new CECalculator(params);\n\t\tMatrix lastMatrix = null;\n\n\t\tList<AFPChain> selfAlignments = new ArrayList<AFPChain>();\n\n\t\t// STEP 2: perform the self-alignments of the structure\n\t\tint i = 0;\n\t\tdo {\n\t\t\tif (origM != null)\n\t\t\t\tmyAFP.setDistanceMatrix((Matrix) origM.clone());\n\n\t\t\torigM = align(myAFP, atoms, ca2, params, origM, calculator, i);\n\n\t\t\tdouble tmScore2 = AFPChainScorer.getTMScore(myAFP, atoms, ca2);\n\t\t\tmyAFP.setTMScore(tmScore2);\n\n\t\t\tAFPChain newAFP = (AFPChain) myAFP.clone();\n\t\t\tnewAFP = CeCPMain.postProcessAlignment(newAFP, atoms, ca2,\n\t\t\t\t\tcalculator);\n\n\t\t\t// Calculate and set the TM score for the newAFP alignment\n\t\t\tdouble tmScore3 = AFPChainScorer.getTMScore(newAFP, atoms, ca2);\n\t\t\tnewAFP.setTMScore(tmScore3);\n\n\t\t\t// Determine if the alignment is significant, stop if false\n\t\t\tif (tmScore3 < params.getScoreThreshold()) {\n\t\t\t\t// If it is the first alignment save it anyway\n\t\t\t\tif (i == 0)\n\t\t\t\t\tselfAlignments.add(newAFP);\n\t\t\t\t// store final matrix\n\t\t\t\tlastMatrix = newAFP.getDistanceMatrix().copy();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If it is a symmetric alignment add it to the allAlignments list\n\t\t\tselfAlignments.add(newAFP);\n\n\t\t\ti++;\n\n\t\t} while (i < params.getMaxSymmOrder() && multiPass);\n\n\t\t// We reached the maximum order, so blank out the final alignment\n\t\tif (lastMatrix == null && selfAlignments.size() > 1 && multiPass) {\n\t\t\tAFPChain last = selfAlignments.get(selfAlignments.size() - 1);\n\t\t\tlastMatrix = SymmetryTools.blankOutPreviousAlignment(last, ca2,\n\t\t\t\t\tlast.getCa1Length(), last.getCa2Length(), calculator,\n\t\t\t\t\torigM, params.getWinSize());\n\t\t\tlastMatrix = lastMatrix.getMatrix(0, last.getCa1Length() - 1, 0,\n\t\t\t\t\tlast.getCa2Length() - 1);\n\t\t}\n\n\t\t// Store the optimal self-alignment\n\t\tresult.setSelfAlignment(selfAlignments.get(0));\n\n\t\t// Determine the symmetry Type or get the one in params\n\t\tSymmetryType type = params.getSymmType();\n\t\tif (type == SymmetryType.AUTO) {\n\t\t\tif (result.getSelfAlignment().getBlockNum() == 1) {\n\t\t\t\tresult.setType(SymmetryType.OPEN);\n\t\t\t\tlogger.info(\"Open Symmetry detected\");\n\t\t\t} else {\n\t\t\t\tresult.setType(SymmetryType.CLOSE);\n\t\t\t\tlogger.info(\"Close Symmetry detected\");\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: order detection & symmetry refinement, apply consistency\n\t\tSymmetryRefiner refiner = null;\n\t\tOrderDetector orderDetector = null;\n\t\tint order = 1;\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\tcase CLOSE:\n\t\t\t\t// ORDER DETECTION\n\t\t\t\tswitch (params.getOrderDetectorMethod()) {\n\t\t\t\tcase SEQUENCE_FUNCTION:\n\t\t\t\t\torderDetector = new SequenceFunctionOrderDetector(\n\t\t\t\t\t\t\tparams.getMaxSymmOrder(), 0.4f);\n\t\t\t\t\torder = orderDetector.calculateOrder(\n\t\t\t\t\t\t\tresult.getSelfAlignment(), atoms);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USER_INPUT:\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// REFINEMENT METHOD\n\t\t\t\tswitch (params.getRefineMethod()) {\n\t\t\t\tcase NOT_REFINED:\n\t\t\t\t\tresult.setSymmOrder(order);\n\t\t\t\t\treturn result;\n\t\t\t\tcase GRAPH:\n\t\t\t\t\trefiner = new GraphRefiner();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SINGLE:\n\t\t\t\t\trefiner = new SingleRefiner();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// case OPEN\n\t\t\tdefault:\n\t\t\t\t// REFINEMENT METHOD\n\t\t\t\tif (params.getRefineMethod() == RefineMethod.NOT_REFINED) {\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\trefiner = new OpenRefiner();\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tMultipleAlignment msa = refiner.refine(result.getSelfAlignment(),\n\t\t\t\t\tatoms, order);\n\t\t\t\n\t\t\t// Refinement succeeded, store results\n\t\t\tresult.setMultipleAlignment(msa);\n\t\t\tresult.setSymmOrder(msa.size());\n\t\t\tresult.setRefined(true);\n\n\t\t} catch (RefinerFailedException e) {\n\t\t\tlogger.info(\"Refinement failed: \" + e.getMessage());\n\t\t\treturn result;\n\t\t}\n\n\t\t// STEP4: determine the symmetry axis and its subunit dependencies\n\t\tSymmetryAxes axes = new SymmetryAxes();\n\t\torder = result.getSymmOrder();\n\t\tMatrix4d axis = result.getMultipleAlignment().getBlockSet(0)\n\t\t\t\t.getTransformations().get(1);\n\n\t\tList<List<Integer>> superposition = new ArrayList<List<Integer>>();\n\t\tList<Integer> chain1 = new ArrayList<Integer>();\n\t\tList<Integer> chain2 = new ArrayList<Integer>();\n\t\tsuperposition.add(chain1);\n\t\tsuperposition.add(chain2);\n\t\tList<Integer> subunitTrans = new ArrayList<Integer>();\n\n\t\tswitch (type) {\n\t\tcase CLOSE:\n\n\t\t\tfor (int bk = 0; bk < order; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add((bk + 1) % order);\n\t\t\t\tsubunitTrans.add(bk);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\n\t\tdefault: // case OPEN:\n\n\t\t\tsubunitTrans.add(0);\n\t\t\tfor (int bk = 0; bk < order - 1; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add(bk + 1);\n\t\t\t\tsubunitTrans.add(bk + 1);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\t\t}\n\t\tresult.setAxes(axes);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the DEFAULT\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyze(Atom[] atoms) throws StructureException {\n\t\tCESymmParameters params = new CESymmParameters();\n\t\treturn analyze(atoms, params);\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the provided\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @param param\n\t *            CeSymmParameters bean\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyze(Atom[] atoms, CESymmParameters params)\n\t\t\tthrows StructureException {\n\n\t\tif (atoms.length < 1)\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\n\t\t// If the SSE information is needed, we calculate it if the user did not\n\t\tif (params.getSSEThreshold() > 0) {\n\t\t\tStructure s = atoms[0].getGroup().getChain().getStructure();\n\t\t\tif (SecStrucTools.getSecStrucInfo(s).isEmpty()) {\n\t\t\t\tlogger.info(\"Calculating Secondary Structure...\");\n\t\t\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\t\t\tssp.calculate(s, true);\n\t\t\t}\n\t\t}\n\n\t\tCeSymmIterative iter = new CeSymmIterative(params);\n\t\tCeSymmResult result = iter.execute(atoms);\n\n\t\tif (result.isRefined()) {\n\n\t\t\t// Optimize the global alignment once more (final step)\n\t\t\tif (params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(result);\n\t\t\t\t\tMultipleAlignment optimized = optimizer.optimize();\n\t\t\t\t\tresult.setMultipleAlignment(optimized);\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.info(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t\t// Return the un-optimized result instead\n\t\t\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\t\t\timposer.superimpose(result.getMultipleAlignment());\n\t\t\t\t\tMultipleAlignmentScorer.calculateScores(result\n\t\t\t\t\t\t\t.getMultipleAlignment());\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Analyze a single level of symmetry.\n\t * \n\t * @param atoms\n\t *            Atom array of the current level\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyzeLevel(Atom[] atoms,\n\t\t\tCESymmParameters params) throws StructureException {\n\n\t\tif (atoms.length < 1)\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\n\t\tCeSymmResult result = align(atoms, params);\n\n\t\tif (result.isRefined()) {\n\t\t\tMultipleAlignment msa = result.getMultipleAlignment();\n\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\timposer.superimpose(msa);\n\t\t\tMultipleAlignmentScorer.calculateScores(msa);\n\t\t\tresult.setMultipleAlignment(msa);\n\n\t\t\t// STEP 5: symmetry alignment optimization\n\t\t\tif (result.getParams().getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(result);\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t\tresult.setMultipleAlignment(msa);\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.debug(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.ce.CECalculator;\nimport org.biojava.nbio.structure.align.ce.CeCPMain;\nimport org.biojava.nbio.structure.align.ce.MatrixListener;\nimport org.biojava.nbio.structure.align.model.AFPChain;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.util.CoreSuperimposer;\nimport org.biojava.nbio.structure.align.multiple.util.MultipleAlignmentScorer;\nimport org.biojava.nbio.structure.align.util.AFPChainScorer;\nimport org.biojava.nbio.structure.jama.Matrix;\nimport org.biojava.nbio.structure.secstruc.SecStrucCalc;\nimport org.biojava.nbio.structure.secstruc.SecStrucTools;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.RefineMethod;\nimport org.biojava.nbio.structure.symmetry.internal.CESymmParameters.SymmetryType;\nimport org.biojava.nbio.structure.symmetry.utils.SymmetryTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Identify the symmetries in a structure by running an alignment of the\n * structure against itself disabling the diagonal of the identity alignment.\n * <p>\n * Iterating over previous results and disabling the diagonal of the previous\n * alignments can also be done with this implementation, which will generate a\n * set of self-alignments (disabled, because none improvements were shown, but\n * can be turn on manually).\n * <p>\n * Multiple levels of symmetry can be analyzed by finding symmetries in subunits\n * of previous results. This feature allows to find multiple symmetry axes.\n * <p>\n * The alignment is then refined to obtain a consistent alignment among all\n * residues of the structure and organized into different parts, called\n * symmetric subunits.\n * <p>\n * After refinement of the initial alignment, an optimization step can be used\n * to improve the overall score of the subunit multiple alignment.\n * \n * @author Andreas Prlic\n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class CeSymm {\n\n\t/**\n\t * Version History:\n\t * <p>\n\t * <ul>\n\t * <li>1.0 - initial implementation of CE-Symm.\n\t * <li>1.1 - enable multiple CE-Symm runs to calculate all self-alignments.\n\t * <li>2.0 - refine the alignment for consistency of subunit definition.\n\t * <li>2.1 - optimize the alignment to improve the score.\n\t * <li>2.2 - run multiple symmetry levels recursively to find PG and\n\t * hierarchical symmetries.\n\t * </ul>\n\t * </li>\n\t */\n\tpublic static final String version = \"2.2\";\n\tpublic static final String algorithmName = \"jCE-symm\";\n\tprivate static final Logger logger = LoggerFactory.getLogger(CeSymm.class);\n\tprivate final static boolean multiPass = false; // multiple self-alignments\n\n\t/**\n\t * Prevent instantiation. Static class.\n\t */\n\tprivate CeSymm() {\n\t}\n\n\tprivate static Matrix align(AFPChain afpChain, Atom[] ca1, Atom[] ca2,\n\t\t\tCESymmParameters params, Matrix origM, CECalculator calculator,\n\t\t\tint counter) throws StructureException {\n\n\t\tint fragmentLength = params.getWinSize();\n\t\tAtom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n\n\t\tint rows = ca1.length;\n\t\tint cols = ca2.length;\n\n\t\t// Matrix that tracks similarity of a fragment of length fragmentLength\n\t\t// starting a position i,j.\n\n\t\tint blankWindowSize = fragmentLength;\n\t\tif (origM == null) {\n\n\t\t\t// Build alignment ca1 to ca2-ca2\n\t\t\tafpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, null, blankWindowSize);\n\n\t\t} else {\n\t\t\t// we are doing an iteration on a previous alignment\n\t\t\t// mask the previous alignment\n\t\t\torigM = SymmetryTools.blankOutPreviousAlignment(afpChain, ca2,\n\t\t\t\t\trows, cols, calculator, origM, blankWindowSize);\n\t\t}\n\n\t\tMatrix clone = (Matrix) origM.clone();\n\n\t\t// that's the matrix to run the alignment on..\n\t\tcalculator.setMatMatrix(clone.getArray());\n\n\t\tcalculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n\n\t\tfinal Matrix origMfinal = (Matrix) origM.clone();\n\t\t// Add a matrix listener to keep the blacked zones in max.\n\t\tcalculator.addMatrixListener(new MatrixListener() {\n\n\t\t\t@Override\n\t\t\tpublic double[][] matrixInOptimizer(double[][] max) {\n\n\t\t\t\t// Check every entry of origM for blacked out regions\n\t\t\t\tfor (int i = 0; i < max.length; i++) {\n\t\t\t\t\tfor (int j = 0; j < max[i].length; j++) {\n\t\t\t\t\t\tif (origMfinal.getArray()[i][j] > 1e9) {\n\t\t\t\t\t\t\tmax[i][j] = -origMfinal.getArray()[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean[][] initializeBreakFlag(boolean[][] brkFlag) {\n\n\t\t\t\treturn brkFlag;\n\t\t\t}\n\t\t});\n\n\t\tcalculator.nextStep(afpChain, ca1, ca2clone);\n\n\t\tafpChain.setAlgorithmName(algorithmName);\n\t\tafpChain.setVersion(version);\n\n\t\tafpChain.setDistanceMatrix(origM);\n\n\t\treturn origMfinal;\n\n\t}\n\n\t@SuppressWarnings(\"unused\")\n\tprotected static CeSymmResult align(Atom[] atoms, CESymmParameters params)\n\t\t\tthrows StructureException {\n\n\t\tCeSymmResult result = new CeSymmResult();\n\t\tresult.setParams(params);\n\t\tresult.setAtoms(atoms);\n\n\t\t// STEP 1: prepare all the information for the symmetry alignment\n\t\tAtom[] ca2 = StructureTools.duplicateCA2(atoms);\n\t\tint rows = atoms.length;\n\t\tint cols = ca2.length;\n\n\t\tif (rows == 0 || cols == 0) {\n\t\t\tthrow new StructureException(\"Aligning empty structure\");\n\t\t}\n\n\t\tMatrix origM = null;\n\t\tAFPChain myAFP = new AFPChain(algorithmName);\n\t\tCECalculator calculator = new CECalculator(params);\n\t\tMatrix lastMatrix = null;\n\n\t\tList<AFPChain> selfAlignments = new ArrayList<AFPChain>();\n\n\t\t// STEP 2: perform the self-alignments of the structure\n\t\tint i = 0;\n\t\tdo {\n\t\t\tif (origM != null)\n\t\t\t\tmyAFP.setDistanceMatrix((Matrix) origM.clone());\n\n\t\t\torigM = align(myAFP, atoms, ca2, params, origM, calculator, i);\n\n\t\t\tdouble tmScore2 = AFPChainScorer.getTMScore(myAFP, atoms, ca2);\n\t\t\tmyAFP.setTMScore(tmScore2);\n\n\t\t\tAFPChain newAFP = (AFPChain) myAFP.clone();\n\t\t\tnewAFP = CeCPMain.postProcessAlignment(newAFP, atoms, ca2,\n\t\t\t\t\tcalculator);\n\n\t\t\t// Calculate and set the TM score for the newAFP alignment\n\t\t\tdouble tmScore3 = AFPChainScorer.getTMScore(newAFP, atoms, ca2);\n\t\t\tnewAFP.setTMScore(tmScore3);\n\n\t\t\t// Determine if the alignment is significant, stop if false\n\t\t\tif (tmScore3 < params.getScoreThreshold()) {\n\t\t\t\t// If it is the first alignment save it anyway\n\t\t\t\tif (i == 0)\n\t\t\t\t\tselfAlignments.add(newAFP);\n\t\t\t\t// store final matrix\n\t\t\t\tlastMatrix = newAFP.getDistanceMatrix().copy();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If it is a symmetric alignment add it to the allAlignments list\n\t\t\tselfAlignments.add(newAFP);\n\n\t\t\ti++;\n\n\t\t} while (i < params.getMaxSymmOrder() && multiPass);\n\n\t\t// We reached the maximum order, so blank out the final alignment\n\t\tif (lastMatrix == null && selfAlignments.size() > 1 && multiPass) {\n\t\t\tAFPChain last = selfAlignments.get(selfAlignments.size() - 1);\n\t\t\tlastMatrix = SymmetryTools.blankOutPreviousAlignment(last, ca2,\n\t\t\t\t\tlast.getCa1Length(), last.getCa2Length(), calculator,\n\t\t\t\t\torigM, params.getWinSize());\n\t\t\tlastMatrix = lastMatrix.getMatrix(0, last.getCa1Length() - 1, 0,\n\t\t\t\t\tlast.getCa2Length() - 1);\n\t\t}\n\n\t\t// Store the optimal self-alignment\n\t\tresult.setSelfAlignment(selfAlignments.get(0));\n\n\t\t// Determine the symmetry Type or get the one in params\n\t\tSymmetryType type = params.getSymmType();\n\t\tif (type == SymmetryType.AUTO) {\n\t\t\tif (result.getSelfAlignment().getBlockNum() == 1) {\n\t\t\t\tresult.setType(SymmetryType.OPEN);\n\t\t\t\tlogger.info(\"Open Symmetry detected\");\n\t\t\t} else {\n\t\t\t\tresult.setType(SymmetryType.CLOSE);\n\t\t\t\tlogger.info(\"Close Symmetry detected\");\n\t\t\t}\n\t\t}\n\n\t\t// STEP 3: order detection & symmetry refinement, apply consistency\n\t\tSymmetryRefiner refiner = null;\n\t\tOrderDetector orderDetector = null;\n\t\tint order = 1;\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\tcase CLOSE:\n\t\t\t\t// ORDER DETECTION\n\t\t\t\tswitch (params.getOrderDetectorMethod()) {\n\t\t\t\tcase SEQUENCE_FUNCTION:\n\t\t\t\t\torderDetector = new SequenceFunctionOrderDetector(\n\t\t\t\t\t\t\tparams.getMaxSymmOrder(), 0.4f);\n\t\t\t\t\torder = orderDetector.calculateOrder(\n\t\t\t\t\t\t\tresult.getSelfAlignment(), atoms);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USER_INPUT:\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// REFINEMENT METHOD\n\t\t\t\tswitch (params.getRefineMethod()) {\n\t\t\t\tcase NOT_REFINED:\n\t\t\t\t\tresult.setSymmOrder(order);\n\t\t\t\t\treturn result;\n\t\t\t\tcase GRAPH:\n\t\t\t\t\trefiner = new GraphRefiner();\n\t\t\t\t\tbreak;\n\t\t\t\tcase SINGLE:\n\t\t\t\t\trefiner = new SingleRefiner();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// case OPEN\n\t\t\tdefault:\n\t\t\t\t// REFINEMENT METHOD\n\t\t\t\tif (params.getRefineMethod() == RefineMethod.NOT_REFINED) {\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\trefiner = new OpenRefiner();\n\t\t\t\t\torder = params.getUserOrder();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tMultipleAlignment msa = refiner.refine(result.getSelfAlignment(),\n\t\t\t\t\tatoms, order);\n\t\t\t\n\t\t\t// Refinement succeeded, store results\n\t\t\tresult.setMultipleAlignment(msa);\n\t\t\tresult.setSymmOrder(msa.size());\n\t\t\tresult.setRefined(true);\n\n\t\t} catch (RefinerFailedException e) {\n\t\t\tlogger.info(\"Refinement failed: \" + e.getMessage());\n\t\t\treturn result;\n\t\t}\n\n\t\t// STEP4: determine the symmetry axis and its subunit dependencies\n\t\tSymmetryAxes axes = new SymmetryAxes();\n\t\torder = result.getSymmOrder();\n\t\tMatrix4d axis = result.getMultipleAlignment().getBlockSet(0)\n\t\t\t\t.getTransformations().get(1);\n\n\t\tList<List<Integer>> superposition = new ArrayList<List<Integer>>();\n\t\tList<Integer> chain1 = new ArrayList<Integer>();\n\t\tList<Integer> chain2 = new ArrayList<Integer>();\n\t\tsuperposition.add(chain1);\n\t\tsuperposition.add(chain2);\n\t\tList<Integer> subunitTrans = new ArrayList<Integer>();\n\n\t\tswitch (type) {\n\t\tcase CLOSE:\n\n\t\t\tfor (int bk = 0; bk < order; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add((bk + 1) % order);\n\t\t\t\tsubunitTrans.add(bk);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\n\t\tdefault: // case OPEN:\n\n\t\t\tsubunitTrans.add(0);\n\t\t\tfor (int bk = 0; bk < order - 1; bk++) {\n\t\t\t\tchain1.add(bk);\n\t\t\t\tchain2.add(bk + 1);\n\t\t\t\tsubunitTrans.add(bk + 1);\n\t\t\t}\n\t\t\taxes.addAxis(axis, superposition, subunitTrans, order);\n\t\t\tbreak;\n\t\t}\n\t\tresult.setAxes(axes);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the DEFAULT\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyze(Atom[] atoms) throws StructureException {\n\t\tCESymmParameters params = new CESymmParameters();\n\t\treturn analyze(atoms, params);\n\t}\n\n\t/**\n\t * Analyze the symmetries of the input Atom array using the provided\n\t * parameters.\n\t * \n\t * @param atoms\n\t *            representative Atom array of the Structure\n\t * @param param\n\t *            CeSymmParameters bean\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyze(Atom[] atoms, CESymmParameters params)\n\t\t\tthrows StructureException {\n\n\t\tif (atoms.length < 1)\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\n\t\t// If the SSE information is needed, we calculate it if the user did not\n\t\tif (params.getSSEThreshold() > 0) {\n\t\t\tStructure s = atoms[0].getGroup().getChain().getStructure();\n\t\t\tif (SecStrucTools.getSecStrucInfo(s).isEmpty()) {\n\t\t\t\tlogger.info(\"Calculating Secondary Structure...\");\n\t\t\t\tSecStrucCalc ssp = new SecStrucCalc();\n\t\t\t\tssp.calculate(s, true);\n\t\t\t}\n\t\t}\n\n\t\tCeSymmIterative iter = new CeSymmIterative(params);\n\t\tCeSymmResult result = iter.execute(atoms);\n\n\t\tif (result.isRefined()) {\n\n\t\t\t// Optimize the global alignment once more (final step)\n\t\t\tif (params.getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(result);\n\t\t\t\t\tMultipleAlignment optimized = optimizer.optimize();\n\t\t\t\t\tresult.setMultipleAlignment(optimized);\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.info(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t\t// Return the un-optimized result instead\n\t\t\t\t\tCoreSuperimposer imposer = new CoreSuperimposer();\n\t\t\t\t\timposer.superimpose(result.getMultipleAlignment());\n\t\t\t\t\tMultipleAlignmentScorer.calculateScores(result\n\t\t\t\t\t\t\t.getMultipleAlignment());\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Analyze a single level of symmetry.\n\t * \n\t * @param atoms\n\t *            Atom array of the current level\n\t * @return CeSymmResult\n\t * @throws StructureException\n\t */\n\tpublic static CeSymmResult analyzeLevel(Atom[] atoms,\n\t\t\tCESymmParameters params) throws StructureException {\n\n\t\tif (atoms.length < 1)\n\t\t\tthrow new IllegalArgumentException(\"Empty Atom array given.\");\n\n\t\tCeSymmResult result = align(atoms, params);\n\n\t\tif (result.isRefined()) {\n\t\t\tMultipleAlignment msa = result.getMultipleAlignment();\n\n\t\t\t// STEP 5: symmetry alignment optimization\n\t\t\tif (result.getParams().getOptimization()) {\n\t\t\t\ttry {\n\t\t\t\t\tSymmOptimizer optimizer = new SymmOptimizer(result);\n\t\t\t\t\tmsa = optimizer.optimize();\n\t\t\t\t\tresult.setMultipleAlignment(msa);\n\t\t\t\t} catch (RefinerFailedException e) {\n\t\t\t\t\tlogger.debug(\"Optimization failed:\" + e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.symmetry.internal;\n\nimport java.io.IOException;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.symmetry.internal.CeSymm;\nimport org.junit.Test;\n\n/**\n * Test for the old bug of non-independent CeSymm runs.\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * \n */\npublic class TestCeSymm {\n\n\t@Test\n\tpublic void testIndependence() throws IOException, StructureException {\n\n\t\t// Only instantiate one CeSymm class\n\t\tString name;\n\t\tAtom[] atoms;\n\n\t\tname = \"1MER.A\";\n\t\tatoms = StructureTools.getRepresentativeAtomArray(StructureTools\n\t\t\t\t.getStructure(name));\n\t\tCeSymm.analyze(atoms);\n\n\t\tname = \"1ijq.A:377-641\";\n\t\tatoms = StructureTools.getRepresentativeAtomArray(StructureTools\n\t\t\t\t.getStructure(name));\n\t\t// This was causing an assertion error if runs are dependent\n\t\tCeSymm.analyze(atoms);\n\t}\n\n}\n","changedTest":"","commitMessage":"Fix display bugs","test_commitMessage":"","allZero":false}