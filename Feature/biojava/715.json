{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/SuperPositionQCP.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestSuperPositionQCP.java","prod_time":"2016-08-03 00:38:02","test_time":"2016-08-03 20:59:33","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":7,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":7,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e6eac12029d5026d1a5f81289f92aa2c50f1db51","test_commitID":"8593ffb5c715e3e69dc63464d18cdbc23b0db6fd","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Reference: Theobald DL (2005). Rapid calculation of RMSDs using a\n * quaternion-based characteristic polynomial. Acta Crystallogr A. 2005\n * Jul;61(Pt 4):478-80. (PubMed id: 15973002)\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * \n */\npublic final class SuperPositionQCP {\n\n\tdouble evecprec = 1d - 6;\n\tdouble evalprec = 1d - 11;\n\n\tprivate Point3d[] x = null;\n\tprivate Point3d[] y = null;\n\n\tprivate double[] weight = null;\n\n\tprivate Point3d[] xref = null;\n\tprivate Point3d[] yref = null;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n\tpublic void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void setCentered(boolean centered) {\n\t\tthis.centered = centered;\n\t}\n\n\tpublic double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t}\n\t\treturn rmsd;\n\t}\n\n\tpublic Matrix4d getTransformationMatrix() {\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\tpublic Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t}\n\t\treturn rotmat;\n\t}\n\n\tpublic Point3d[] getTransformedCoordinates() {\n\t\tSuperPosition.transform(transformation, x);\n\t\treturn x;\n\t}\n\n\t/**\n\t * this requires the coordinates to be precentered\n\t * \n\t * @param x\n\t * @param y\n\t */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = SuperPosition.clonePoint3dArray(x);\n\t\t\txtrans = SuperPosition.centroid(xref);\n\t\t\t// System.out.println(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tSuperPosition.translate(xtrans, xref);\n\n\t\t\tyref = SuperPosition.clonePoint3dArray(y);\n\t\t\tytrans = SuperPosition.centroid(yref);\n\t\t\t// System.out.println(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tSuperPosition.translate(ytrans, yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(x.length);\n\t}\n\n\t/*\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\t\t//\n\t\t// // combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t * \n\t * @param A\n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y\n\t\t\t\t\t\t+ coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y\n\t\t\t\t\t\t+ coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(int len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0\n\t\t\t\t* (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx\n\t\t\t\t- Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2)\n\t\t\t\t* (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 0; i < 50; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(evalprec * mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50)\n\t\t\tSystem.err.println(\"More than %d iterations needed!\" + i);\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < evecprec) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < evecprec) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12\n\t\t\t\t\t\t* a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11\n\t\t\t\t\t\t* a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11\n\t\t\t\t\t\t* a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < evecprec) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34\n\t\t\t\t\t\t\t* a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33\n\t\t\t\t\t\t\t* a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < evecprec) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\t//System.out.println(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Reference: Theobald DL (2005). Rapid calculation of RMSDs using a\n * quaternion-based characteristic polynomial. Acta Crystallogr A. 2005\n * Jul;61(Pt 4):478-80. (PubMed id: 15973002)\n * \n * @author Peter Rose\n * @author Aleix Lafita\n * \n */\npublic final class SuperPositionQCP {\n\n\tdouble evecprec = 1d - 6;\n\tdouble evalprec = 1d - 11;\n\n\tprivate Point3d[] x = null;\n\tprivate Point3d[] y = null;\n\n\tprivate double[] weight = null;\n\n\tprivate Point3d[] xref = null;\n\tprivate Point3d[] yref = null;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n\tpublic void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\tpublic void setCentered(boolean centered) {\n\t\tthis.centered = centered;\n\t}\n\n\tpublic double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t}\n\t\treturn rmsd;\n\t}\n\n\tpublic Matrix4d getTransformationMatrix() {\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\tpublic Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t}\n\t\treturn rotmat;\n\t}\n\n\tpublic Point3d[] getTransformedCoordinates() {\n\t\tCalcPoint.transform(transformation, x);\n\t\treturn x;\n\t}\n\n\t/**\n\t * this requires the coordinates to be precentered\n\t * \n\t * @param x\n\t * @param y\n\t */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = CalcPoint.clonePoint3dArray(x);\n\t\t\txtrans = CalcPoint.centroid(xref);\n\t\t\t// System.out.println(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tCalcPoint.translate(xtrans, xref);\n\n\t\t\tyref = CalcPoint.clonePoint3dArray(y);\n\t\t\tytrans = CalcPoint.centroid(yref);\n\t\t\t// System.out.println(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tCalcPoint.translate(ytrans, yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(x.length);\n\t}\n\n\t/*\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\t\t//\n\t\t// // combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t * \n\t * @param A\n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y\n\t\t\t\t\t\t+ coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y\n\t\t\t\t\t\t+ coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(int len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0\n\t\t\t\t* (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx\n\t\t\t\t- Sxx * Syy * Szz - Syz * Szx * Sxy - Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2)\n\t\t\t\t* (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 0; i < 50; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(evalprec * mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50)\n\t\t\tSystem.err.println(\"More than %d iterations needed!\" + i);\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < evecprec) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < evecprec) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12\n\t\t\t\t\t\t* a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11\n\t\t\t\t\t\t* a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11\n\t\t\t\t\t\t* a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < evecprec) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34\n\t\t\t\t\t\t\t* a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33\n\t\t\t\t\t\t\t* a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < evecprec) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\t//System.out.println(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n}\n","originTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test the Quaternion-Based Characteristic Polynomial {@link SuperPositionQCP}\n * algorithm for RMSD and Superposition calculations.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestSuperPositionQCP {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(TestSuperPositionQCP.class);\n\n\tprivate Atom[] cloud1;\n\tprivate Atom[] cloud2;\n\tprivate Atom[] cloud2clone;\n\n\tprivate AxisAngle4d axis;\n\tprivate Matrix4d transform;\n\n\t@Before\n\tpublic void setUp() {\n\n\t\t// Generate two big random clouds of points\n\t\tRandom rnd = new Random();\n\n\t\tcloud1 = new Atom[5000];\n\t\tcloud2 = new Atom[5000];\n\t\tcloud2clone = new Atom[5000];\n\n\t\taxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(axis);\n\n\t\tfor (int p = 0; p < 5000; p++) {\n\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setCoords(new double[] { rnd.nextInt(100), rnd.nextInt(50),\n\t\t\t\t\trnd.nextInt(150) });\n\t\t\tcloud1[p] = a;\n\n\t\t\tAtom b = new AtomImpl();\n\t\t\t// Add some noise\n\t\t\tb.setCoords(new double[] { a.getX() + rnd.nextDouble(),\n\t\t\t\t\ta.getY() + rnd.nextDouble(), a.getZ() + rnd.nextDouble() });\n\t\t\tCalc.transform(b, transform);\n\t\t\tcloud2[p] = b;\n\n\t\t\tAtom c = (Atom) b.clone();\n\t\t\tcloud2clone[p] = c;\n\t\t}\n\n\t}\n\n\t/**\n\t * Test method to obtain the transformation matrix from superposition\n\t * {@link SuperPositionQCP#getTransformationMatrix()},\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testTransformationMatrix() throws StructureException {\n\n\t\t// Use SVD superposition to obtain the optimal transformation matrix\n\t\tlong svdStart = System.nanoTime();\n\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1, cloud2);\n\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\t\tAxisAngle4d svdAxis = new AxisAngle4d();\n\t\tsvdAxis.set(svdTransform);\n\n\t\t// Use SuperPosition to obtain the optimal transformation matrix\n\t\tPoint3d[] cloud1p = Calc.atomsToPoints(cloud1);\n\t\tPoint3d[] cloud2p = Calc.atomsToPoints(cloud2);\n\t\tlong spStart = System.nanoTime();\n\t\tMatrix4d spTransform = SuperPosition.superpose(cloud1p, cloud2p);\n\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\t\tAxisAngle4d spAxis = new AxisAngle4d();\n\t\tspAxis.set(spTransform);\n\n\t\t// Use QCP algorithm to get the optimal transformation matrix\n\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\tqcp.set(Calc.atomsToPoints(cloud1), Calc.atomsToPoints(cloud2));\n\t\tlong qcpStart = System.nanoTime();\n\t\tMatrix4d qcpTransform = qcp.getTransformationMatrix();\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\t\tAxisAngle4d qcpAxis = new AxisAngle4d();\n\t\tqcpAxis.set(qcpTransform);\n\n\t\tlogger.info(String\n\t\t\t\t.format(\"Transformation Matrix: SVD time %d us\"\n\t\t\t\t\t\t+ \", SP time: %d us, QCP time: %d us\", svdTime, spTime,\n\t\t\t\t\t\tqcpTime));\n\n\t\t// Check that the rotation angle was recovered in both\n\t\tassertEquals(svdAxis.angle, axis.angle, 0.01);\n\t\tassertEquals(spAxis.angle, axis.angle, 0.01);\n\t\tassertEquals(qcpAxis.angle, axis.angle, 0.01);\n\n\t\t// Check that the axis vector was recovered\n\t\tAxisAngle4d negAxis = new AxisAngle4d(-axis.x, -axis.y, -axis.z,\n\t\t\t\taxis.angle);\n\n\t\tassertTrue(axis.epsilonEquals(svdAxis, 0.01)\n\t\t\t\t|| negAxis.epsilonEquals(svdAxis, 0.01));\n\n\t\tassertTrue(axis.epsilonEquals(spAxis, 0.01)\n\t\t\t\t|| negAxis.epsilonEquals(spAxis, 0.01));\n\t\t\n\t\tassertTrue(axis.epsilonEquals(qcpAxis, 0.01)\n\t\t\t\t|| negAxis.epsilonEquals(qcpAxis, 0.01));\n\n\t}\n\n\t/**\n\t * Test method to obtain the RMSD of a superposition\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testRMSD() throws StructureException {\n\n\t\t// Use SVD superposition to obtain the RMSD\n\t\tlong svdStart = System.nanoTime();\n\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1, cloud2);\n\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\tCalc.transform(cloud2clone, svdTransform);\n\t\tdouble svdrmsd = SVDSuperimposer.getRMS(cloud1, cloud2clone);\n\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t// Use QCP algorithm to get the optimal transformation matrix\n\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\tqcp.set(Calc.atomsToPoints(cloud1), Calc.atomsToPoints(cloud2));\n\t\tlong qcpStart = System.nanoTime();\n\t\tdouble qcprmsd = qcp.getRmsd();\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\tlogger.info(String.format(\"RMSD: SVD time %d us\" + \", QCP time: %d us\",\n\t\t\t\tsvdTime, qcpTime));\n\n\t\t// Check that the returned RMSDs are equal\n\t\tassertEquals(svdrmsd, qcprmsd, 0.01);\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.SVDSuperimposer;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.geometry.SuperPosition;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test the Quaternion-Based Characteristic Polynomial {@link SuperPositionQCP}\n * algorithm for RMSD and Superposition calculations.\n * \n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestSuperPositionQCP {\n\n\tprivate static final Logger logger = LoggerFactory\n\t\t\t.getLogger(TestSuperPositionQCP.class);\n\n\tprivate Atom[] cloud1;\n\tprivate Atom[] cloud2;\n\tprivate Atom[] cloud2noise;\n\n\tprivate AxisAngle4d axis;\n\tprivate Vector3d translation;\n\tprivate Matrix4d transform;\n\n\t@Before\n\tpublic void setUp() throws StructureException {\n\n\t\tint size = 50;\n\n\t\t// Generate two big random clouds of points\n\t\tRandom rnd = new Random();\n\n\t\tcloud1 = new Atom[size];\n\t\tcloud2 = new Atom[size];\n\t\tcloud2noise = new Atom[size];\n\n\t\taxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\t\ttranslation = new Vector3d(0.345, 2.453, 5.324);\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(axis);\n\t\ttransform.setTranslation(translation);\n\n\t\tfor (int p = 0; p < size; p++) {\n\n\t\t\tAtom a = new AtomImpl();\n\t\t\ta.setCoords(new double[] { rnd.nextInt(100), rnd.nextInt(50),\n\t\t\t\t\trnd.nextInt(150) });\n\t\t\tcloud1[p] = a;\n\t\t\tcloud2[p] = (Atom) a.clone();\n\t\t\t\n\t\t\tAtom b = new AtomImpl();\n\t\t\t// Add some noise\n\t\t\tb.setCoords(new double[] { a.getX() + rnd.nextDouble(),\n\t\t\t\t\ta.getY() + rnd.nextDouble(), a.getZ() + rnd.nextDouble() });\n\t\t\tcloud2noise[p] = b;\n\t\t}\n\n\t\tcloud1 = Calc.centerAtoms(cloud1);\n\t\tcloud2 = Calc.centerAtoms(cloud2);\n\t\tcloud2noise = Calc.centerAtoms(cloud2noise);\n\n\t\tCalc.transform(cloud2, transform);\n\t\tCalc.transform(cloud2noise, transform);\n\n\t}\n\n\t/**\n\t * Test method to obtain the transformation matrix from superposition\n\t * {@link SuperPositionQCP#getTransformationMatrix()},\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testTransformationMatrix() throws StructureException {\n\n\t\t// Use SVD superposition to obtain the optimal transformation matrix\n\t\tlong svdStart = System.nanoTime();\n\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1, cloud2);\n\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\t// Use SuperPosition to obtain the optimal transformation matrix\n\t\tPoint3d[] cloud1p = Calc.atomsToPoints(cloud1);\n\t\tPoint3d[] cloud2p = Calc.atomsToPoints(cloud2);\n\t\tlong spStart = System.nanoTime();\n\t\tMatrix4d spTransform = SuperPosition.superposeWithTranslation(cloud1p,\n\t\t\t\tcloud2p);\n\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\n\t\t// Use QCP algorithm to get the optimal transformation matrix\n\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\tqcp.set(Calc.atomsToPoints(cloud1), Calc.atomsToPoints(cloud2));\n\t\tlong qcpStart = System.nanoTime();\n\t\tMatrix4d qcpTransform = qcp.getTransformationMatrix();\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\tlogger.info(String\n\t\t\t\t.format(\"Transformation Matrix: SVD time %d us\"\n\t\t\t\t\t\t+ \", SP time: %d us, QCP time: %d us\", svdTime, spTime,\n\t\t\t\t\t\tqcpTime));\n\n\t\t// Check that the transformation matrix was recovered\n\t\tMatrix4d inverse = new Matrix4d();\n\t\tinverse.invert(transform);\n\n\t\tassertTrue(transform.epsilonEquals(svdTransform, 0.01)\n\t\t\t\t|| inverse.epsilonEquals(svdTransform, 0.01));\n\n\t\tassertTrue(transform.epsilonEquals(spTransform, 0.01)\n\t\t\t\t|| inverse.epsilonEquals(spTransform, 0.01));\n\n\t\tassertTrue(transform.epsilonEquals(qcpTransform, 0.01)\n\t\t\t\t|| inverse.epsilonEquals(qcpTransform, 0.01));\n\n\t}\n\n\t/**\n\t * Test method to obtain the RMSD of a superposition\n\t * {@link SuperPositionQCP#getRmsd()}.\n\t * \n\t * @throws StructureException\n\t */\n\t@Test\n\tpublic void testRMSD() throws StructureException {\n\t\t\n\t\tAtom[] cloud2clone = new Atom[cloud2noise.length];\n\t\tfor (int p = 0; p < cloud2noise.length; p++)\n\t\t\tcloud2clone[p] = (Atom) cloud2noise[p].clone();\n\t\t\n\t\t// Use SVD superposition to obtain the RMSD\n\t\tlong svdStart = System.nanoTime();\n\t\tSVDSuperimposer svd = new SVDSuperimposer(cloud1, cloud2noise);\n\t\tMatrix4d svdTransform = svd.getTransformation();\n\t\tCalc.transform(cloud2clone, svdTransform);\n\t\tdouble svdrmsd = SVDSuperimposer.getRMS(cloud1, cloud2clone);\n\t\tlong svdTime = (System.nanoTime() - svdStart) / 1000;\n\n\t\tPoint3d[] cloud1p = Calc.atomsToPoints(cloud1);\n\t\tPoint3d[] cloud2p = Calc.atomsToPoints(cloud2noise);\n\n\t\t// Use SVD superposition to obtain the RMSD\n\t\tlong spStart = System.nanoTime();\n\t\tSuperPosition.superposeWithTranslation(cloud1p, cloud2p);\n\t\tdouble sprmsd = SuperPosition.rmsd(cloud1p, cloud2p);\n\t\tlong spTime = (System.nanoTime() - spStart) / 1000;\n\n\t\t// Use QCP algorithm to get the optimal transformation matrix\n\t\tSuperPositionQCP qcp = new SuperPositionQCP();\n\t\tqcp.set(Calc.atomsToPoints(cloud1), Calc.atomsToPoints(cloud2noise));\n\t\tlong qcpStart = System.nanoTime();\n\t\tdouble qcprmsd = qcp.getRmsd();\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\tlogger.info(String.format(\"RMSD: SVD time %d us, SP time: %d us\"\n\t\t\t\t+ \", QCP time: %d us\", svdTime, spTime, qcpTime));\n\n\t\t// Check that the returned RMSDs are equal\n\t\tassertEquals(svdrmsd, qcprmsd, 0.001);\n\t\tassertEquals(svdrmsd, sprmsd, 0.001);\n\t}\n\n}\n","commitMessage":"Create CalcPoint Class to hold general methods with Point3d #545","test_commitMessage":"Document SuperPosition and introduce translation in test","allZero":false}