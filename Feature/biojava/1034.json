{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/GenbankWriter.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/GenbankWriterTest.java","prod_time":"2021-11-16 05:46:46","test_time":"2022-07-07 00:40:16","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"2e87f554171552bdee5cc68089ac89a3e39afde6","test_commitID":"008595b4e3cf08b21c73f37859179c92bdaaf290","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.io.template.GenbankHeaderFormatInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.StringManipulationHelper;\n\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\n\tint SEQUENCE_INDENT = 9;\n\n\tOutputStream os;\n\tCollection<S> sequences;\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\n\tprivate int lineLength = 60;\n\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\n\t/**\n\t * Use default line length of 60\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t */\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\n\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t}\n\n\t/**\n\t * Set custom lineLength\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t * @param lineLength\n\t */\n\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t\tthis.lineLength = lineLength;\n\t}\n\n\t/**\n\t * Allow an override of operating system line separator for programs that\n\t * needs a specific CRLF or CR or LF option\n\t *\n\t * @param lineSeparator\n\t */\n\n\tpublic void process() throws Exception {\n\t\t// Loosely based on code from Howard Salis\n\t\t// TODO - Force lower case?\n\t\t// boolean closeit = false;\n\t\tPrintWriter writer = new PrintWriter(os);\n\t\tfor (S sequence : sequences) {\n\t\t\tString header = headerFormat.getHeader(sequence);\n\t\t\twriter.format(header);\n\t\t\twriter.println();\n\t\t\t// os.write(lineSep);\n\n\t\t\t/*\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\n\t\t\t * the length, and there is no need #to record a long sequence of\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\n\t\t\t * return\n\t\t\t */\n\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\n\t\t\tint seq_len = data.length();\n\t\t\twriter.println(\"ORIGIN\");\n\t\t\t// os.write(lineSep);\n\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\n\t\t\t\t\tif ((words + 10) > data.length()) {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// os.write(lineSep);\n\t\t\t\twriter.println();\n\t\t\t}\n\n\t\t\twriter.println(\"//\");\n\n\t\t}\n\n\t\twriter.flush();\n\n\t}\n\n\t/*\n\t * public static void main(String[] args) { try { FileInputStream is = new\n\t * FileInputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds.faa\");\n\t *\n\t *\n\t * FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new\n\t * FastaReader<ProteinSequence, AminoAcidCompound>(is, new\n\t * GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new\n\t * ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t * LinkedHashMap<String, ProteinSequence> proteinSequences =\n\t * fastaReader.process(); is.close();\n\t *\n\t *\n\t * // System.out.println(proteinSequences);\n\t *\n\t * FileOutputStream fileOutputStream = new\n\t * FileOutputStream(\"/Users/Scooter/scripps/dyadic/c1-454Scaffolds_temp.faa\"\n\t * );\n\t *\n\t * BufferedOutputStream bo = new BufferedOutputStream(fileOutputStream);\n\t * long start = System.currentTimeMillis(); FastaWriter<ProteinSequence,\n\t * AminoAcidCompound> fastaWriter = new FastaWriter<ProteinSequence,\n\t * AminoAcidCompound>(bo, proteinSequences.values(), new\n\t * GenericFastaHeaderFormat<ProteinSequence, AminoAcidCompound>());\n\t * fastaWriter.process(); bo.close(); long end = System.currentTimeMillis();\n\t * System.out.println(\"Took \" + (end - start) + \" seconds\");\n\t *\n\t * fileOutputStream.close();\n\t *\n\t *\n\t * } catch (Exception e) { e.printStackTrace(); } }\n\t */\n\t/**\n\t * @return the lineLength\n\t */\n\tpublic int getLineLength() {\n\t\treturn lineLength;\n\t}\n\n\t/**\n\t * @param lineLength\n\t *            the lineLength to set\n\t */\n\tpublic void setLineLength(int lineLength) {\n\t\tthis.lineLength = lineLength;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.io.template.GenbankHeaderFormatInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.StringManipulationHelper;\n\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\n\tint SEQUENCE_INDENT = 9;\n\n\tOutputStream os;\n\tCollection<S> sequences;\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\n\tprivate int lineLength = 60;\n\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\n\t/**\n\t * Use default line length of 60\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t */\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\n\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t}\n\n\t/**\n\t * Set custom lineLength\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t * @param lineLength\n\t */\n\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t\tthis.lineLength = lineLength;\n\t}\n\n\t/**\n\t * Allow an override of operating system line separator for programs that\n\t * needs a specific CRLF or CR or LF option\n\t *\n\t * @param lineSeparator\n\t */\n\n\tpublic void process() throws Exception {\n\t\t// Loosely based on code from Howard Salis\n\t\t// TODO - Force lower case?\n\t\t// boolean closeit = false;\n\t\tPrintWriter writer = new PrintWriter(os);\n\t\tfor (S sequence : sequences) {\n\t\t\tString header = headerFormat.getHeader(sequence);\n\t\t\twriter.format(header);\n\t\t\twriter.println();\n\t\t\t// os.write(lineSep);\n\n\t\t\t/*\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\n\t\t\t * the length, and there is no need #to record a long sequence of\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\n\t\t\t * return\n\t\t\t */\n\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\n\t\t\tint seq_len = data.length();\n\t\t\twriter.println(\"ORIGIN\");\n\t\t\t// os.write(lineSep);\n\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\n\t\t\t\t\tif ((words + 10) > data.length()) {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// os.write(lineSep);\n\t\t\t\twriter.println();\n\t\t\t}\n\n\t\t\twriter.println(\"//\");\n\n\t\t}\n\n\t\twriter.flush();\n\n\t}\n\n\t/**\n\t * @return the lineLength\n\t */\n\tpublic int getLineLength() {\n\t\treturn lineLength;\n\t}\n\n\t/**\n\t * @param lineLength\n\t *            the lineLength to set\n\t */\n\tpublic void setLineLength(int lineLength) {\n\t\tthis.lineLength = lineLength;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\n\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriterTest {\n\n\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\n\t\tfor(DNASequence seq : dnaSequences.values()) {\n\t\t\tseqs.add(seq);\n\t\t}\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\t//System.out.println(fragwriter.toString());\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\t/**\n\t\t * Hello Jacek\n\t\t * can you please investigate why this test fails? it seems that\n\t\t * fragreader at the line below is read with the last feature\n\t\t * in an invalid state: location = 2005..2004\n\t\t */\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\n\t\tfragwriter.close();\n\t\tAssert.assertEquals(seqs.get(0).getSequenceAsString(), dnaSequences.values().iterator().next().getSequenceAsString());\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\n\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.features.AbstractFeature;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\nimport org.biojava.nbio.core.sequence.features.TextFeature;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriterTest {\n\n\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\n\t\tfor(DNASequence seq : dnaSequences.values()) {\n\t\t\tseqs.add(seq);\n\t\t}\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\t//System.out.println(fragwriter.toString());\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\t/**\n\t\t * Hello Jacek\n\t\t * can you please investigate why this test fails? it seems that\n\t\t * fragreader at the line below is read with the last feature\n\t\t * in an invalid state: location = 2005..2004\n\t\t */\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\n\t\tfragwriter.close();\n\t\tAssert.assertEquals(seqs.get(0).getSequenceAsString(), dnaSequences.values().iterator().next().getSequenceAsString());\n\t}\n\t\n\t/**\n\t * String Formatter error when key or value of Qualifier has character \"%\"\n\t * https://github.com/biojava/biojava/issues/886\n\t */\n\t@Test\n\tpublic void testGithub886() throws Exception {\n\t\t\n\t\tDNASequence seq = new DNASequence(\"ATGC\");\n\t\tseq.setAccession(new AccessionID(\".\"));\n\t\tAbstractFeature feature = new TextFeature(\"CDS\", \"source\", \"short description\", \"description\");\n\t\tfeature.setLocation(new SimpleLocation(1, 10, Strand.POSITIVE));\n\n\t\t// no percent symbols in key or value\n\t\tfeature.addQualifier(\"note1\", new Qualifier(\"note1\", \"50\", true));\n\t\t// percent symbol in key\n\t\tfeature.addQualifier(\"note2\", new Qualifier(\"%note2\", \"50\", true));\n\t\tfeature.addQualifier(\"note3\", new Qualifier(\"not%e3\", \"50\", true));\n\t\tfeature.addQualifier(\"note4\", new Qualifier(\"note4%\", \"50\", true));\n\t\t// percent symbol in value\n\t\tfeature.addQualifier(\"note5\", new Qualifier(\"note5\", \"%50\", true));\n\t\tfeature.addQualifier(\"note6\", new Qualifier(\"note6\", \"5%0\", true));\n\t\tfeature.addQualifier(\"note7\", new Qualifier(\"note7\", \"50%\", true));\n\t\t\n\t\tseq.addFeature(feature);\n\t\t\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequence(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(seq), \n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\tfragwriter.close();\n\t\tSystem.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\t\t\n\t\t// now read in the file that was created and check that the qualifiers were created correctly\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSeq = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\tAbstractFeature newFeature = (TextFeature) seq.getFeaturesByType(\"CDS\").get(0);\n\t\tMap<String, List<Qualifier>> newQualifiers = newFeature.getQualifiers();\n\t\t\n\t\tassertEquals(\"note1\", newQualifiers.get(\"note1\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note1\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"%note2\", newQualifiers.get(\"note2\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note2\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"not%e3\", newQualifiers.get(\"note3\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note3\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note4%\", newQualifiers.get(\"note4\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note4\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note5\", newQualifiers.get(\"note5\").get(0).getName());\n\t\tassertEquals(\"%50\", newQualifiers.get(\"note5\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note6\", newQualifiers.get(\"note6\").get(0).getName());\n\t\tassertEquals(\"5%0\", newQualifiers.get(\"note6\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note7\", newQualifiers.get(\"note7\").get(0).getName());\n\t\tassertEquals(\"50%\", newQualifiers.get(\"note7\").get(0).getValue());\n\t\t\n\t}\n}\n","commitMessage":"remove GenbankWriter main\n","test_commitMessage":"Added test for issue #886","allZero":true}