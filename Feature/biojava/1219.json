{"repository":"biojava","prod_path":"sequence/sequence-core/src/main/java/org/biojava3/core/symbol/SymbolList.java","test_path":"core/src/test/java/org/biojava/bio/symbol/SymbolListTest.java","prod_time":"2010-01-19 23:32:13","test_time":"","type":"","proType":"DELETE","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":29,"del_classname_line":1,"del_condition_line":1,"del_field_line":2,"del_import_line":6,"del_packageid_line":1,"del_parameter_line":18,"del_return_line":22,"label":"NEGATIVE","prod_commitID":"07fead3ec54562edc13537bad3bf311729c3df07","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava3.core.symbol;\n\nimport java.io.Serializable;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.ListIterator;\n\n/**\n * A symbol list is exactly the same as a normal list set up to contain symbols.\n * It is powered by a replaceable backing list which defaults to an instance of\n * {@link ArrayList}. It is possible to substitute the backing list for\n * something more efficient or better suited to the task, e.g. an interface\n * directly to disk or a database. In addition to the standard position-based\n * methods provided as part of the {@link List} interface, each method has a\n * _bio equivalent which accepts biological coordinates (1-indexed) as opposed\n * to standard coordinates (0-indexed).\n * \n * @author Richard Holland\n * @since 3.0\n */\npublic class SymbolList extends AbstractList<Symbol> implements Serializable {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate List<Symbol> backingList = new ArrayList<Symbol>();\n\n\t/**\n\t * Construct a new symbol list backed by an {@link ArrayList}.\n\t */\n\tpublic SymbolList() {\n\t}\n\n\t/**\n\t * Construct a new symbol list and fill it with the symbols from the\n\t * specified list. This does not wrap the specified list and operations on\n\t * the constructed object do not affect the specified list.\n\t * \n\t * @param symList\n\t *            the symbol list to take symbols from to populate this symbol\n\t *            list.\n\t */\n\tpublic SymbolList(List<Symbol> symList) {\n\t\tthis.addAll(symList);\n\t}\n\n\t/**\n\t * Set the backing list for this symbol list. It will wipe out all data\n\t * already in the new backing list and replace it with data already existing\n\t * in this symbol list. All operations on this symbol list will directly\n\t * affect the backing list, and vice versa.\n\t * \n\t * @param backingList\n\t *            the backing list to use.\n\t */\n\tpublic void setBackingList(List<Symbol> backingList) {\n\t\tif (backingList == null) {\n\t\t\tthrow new NullPointerException(\"The backing list cannot be null.\");\n\t\t}\n\t\tbackingList.clear();\n\t\tbackingList.addAll(this);\n\t\tthis.backingList = backingList;\n\t}\n\n\t/**\n\t * Obtain the backing list currently in use. Any modifications to it will\n\t * directly modify the symbol list too.\n\t * \n\t * @return the backing list.\n\t */\n\tpublic List<Symbol> getBackingList() {\n\t\treturn this.backingList;\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link add(int, Symbol)}.\n\t * \n\t * @param index\n\t *            the 1-indexed position.\n\t * @param element\n\t *            the symbol to add.\n\t */\n\tpublic void add_bio(int index, Symbol element) {\n\t\tthis.add(index - 1, element);\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link addAll(int, Collection<? extends\n\t * Symbol>)}.\n\t * \n\t * @param index\n\t *            the 1-indexed position.\n\t * @param c\n\t *            the symbols to add.\n\t */\n\tpublic boolean addAll_bio(int index, Collection<? extends Symbol> c) {\n\t\treturn this.addAll(index - 1, c);\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link get(int)}.\n\t * \n\t * @param index\n\t *            the 1-indexed position.\n\t * @return the symbol.\n\t */\n\tpublic Symbol get_bio(int index) {\n\t\treturn this.get(index - 1);\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link indexOf(Object)}.\n\t * \n\t * @param o\n\t *            the object to look for.\n\t * @return index the 1-indexed position.\n\t */\n\tpublic int indexOf_bio(Object o) {\n\t\treturn this.indexOf(o) + 1;\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link lastIndexOf(Object)}.\n\t * \n\t * @param o\n\t *            the object to look for.\n\t * @return index the last 1-indexed position.\n\t */\n\tpublic int lastIndexOf_bio(Object o) {\n\t\treturn this.lastIndexOf(o) + 1;\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link remove(int)}.\n\t * \n\t * @param index\n\t *            the 1-indexed position.\n\t * @return the symbol removed.\n\t */\n\tpublic Symbol remove_bio(int index) {\n\t\treturn this.remove(index - 1);\n\t}\n\n\t/**\n\t * A 1-indexed equivalent of {@link set(int,Symbol)}.\n\t * \n\t * @param index\n\t *            the 1-indexed position.\n\t * @param element\n\t *            the symbol to add.\n\t * @return the symbol replaced, if any.\n\t */\n\tpublic Symbol set_bio(int index, Symbol element) {\n\t\treturn this.set(index - 1, element);\n\t}\n\n\tpublic void add(int index, Symbol element) {\n\t\tthis.backingList.add(index, element);\n\t}\n\n\tpublic Symbol remove(int index) {\n\t\treturn this.backingList.remove(index);\n\t}\n\n\tpublic Symbol set(int index, Symbol element) {\n\t\treturn this.backingList.set(index, element);\n\t}\n\n\tpublic Symbol get(int index) {\n\t\treturn this.backingList.get(index);\n\t}\n\n\tpublic int size() {\n\t\treturn this.backingList.size();\n\t}\n\n\tpublic ListIterator<Symbol> listIterator() {\n\t\treturn this.listIterator(0);\n\t}\n\n\tpublic ListIterator<Symbol> listIterator(int index) {\n\t\treturn this.listIterator(index, 0);\n\t}\n\n\t/**\n\t * Provides a list iterator that uses 1-indexed coordinates. Otherwise\n\t * identical to {@link #listIterator()}.\n\t * \n\t * @return a list iterator.\n\t */\n\tpublic ListIterator<Symbol> listIterator_bio() {\n\t\treturn this.listIterator_bio(1);\n\t}\n\n\t/**\n\t * Provides a list iterator that uses 1-indexed coordinates. Otherwise\n\t * identical to {@link #listIterator(int)}.\n\t * \n\t * @param index\n\t *            the 1-indexed starting position for the iterator.\n\t * @return a list iterator.\n\t */\n\tpublic ListIterator<Symbol> listIterator_bio(int index) {\n\t\treturn this.listIterator(index, 1);\n\t}\n\n\t/**\n\t * Provides a list iterator that uses offest-indexed coordinates.\n\t * \n\t * @param index\n\t *            the offset-indexed starting position for the iterator.\n\t * @param offset\n\t *            the offset for indexing (usually 0 or 1).\n\t * @return a list iterator.\n\t */\n\tprivate ListIterator<Symbol> listIterator(final int index, final int offset) {\n\t\tfinal ListIterator<Symbol> def = super.listIterator(index - offset);\n\t\treturn new ListIterator<Symbol>() {\n\n\t\t\tpublic void add(Symbol e) {\n\t\t\t\tdef.add(e);\n\t\t\t}\n\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn def.hasNext();\n\t\t\t}\n\n\t\t\tpublic boolean hasPrevious() {\n\t\t\t\treturn def.hasPrevious();\n\t\t\t}\n\n\t\t\tpublic Symbol next() {\n\t\t\t\treturn def.next();\n\t\t\t}\n\n\t\t\tpublic int nextIndex() {\n\t\t\t\treturn def.nextIndex() + offset;\n\t\t\t}\n\n\t\t\tpublic Symbol previous() {\n\t\t\t\treturn def.previous();\n\t\t\t}\n\n\t\t\tpublic int previousIndex() {\n\t\t\t\treturn def.previousIndex() + offset;\n\t\t\t}\n\n\t\t\tpublic void remove() {\n\t\t\t\tdef.remove();\n\t\t\t}\n\n\t\t\tpublic void set(Symbol e) {\n\t\t\t\tdef.set(e);\n\t\t\t}\n\t\t};\n\t}\n}\n","changedPro":"","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.symbol;\n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.RNATools;\nimport org.biojava.bio.seq.io.ChunkedSymbolListFactory;\nimport org.biojava.utils.ChangeVetoException;\n\n/**\n * JUnit test for SymbolList objects\n * @author David Huen\n * @since 1.3\n */\npublic class SymbolListTest extends TestCase\n{\n    // SymbolList lengths to run tests at.\n    int testLengths[] = {100, 16384, 32000, 100000};\n\n    // number of times to repeat each test to deal with chance\n    // matches in last symbol.\n    int noRepeats = 8;\n\n    /**\n     * an interface for internal classes\n     */\n    private interface SymListFactory {\n        public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length);\n    }\n\n    public SymbolListTest(String string)\n    {\n        super(string);\n    }\n\n    /**\n     * creates a random SymbolList\n     *\n     * @param the Alphabet from which Symbols are to be drawn.  Can include ambiguity symbols.\n     */\n    protected Symbol [] createRandomSymbolArray(FiniteAlphabet alpha, int length)\n        throws Exception\n    {\n        int alfaSize = alpha.size();\n        AlphabetIndex indx = AlphabetManager.getAlphabetIndex(alpha);\n        Random rand = new Random();\n\n        Symbol [] array = new Symbol [length];\n\n        for (int i=0; i < length; i++) {\n            array[i] = indx.symbolForIndex(rand.nextInt(alfaSize));\n        }\n\n        return array;\n    }\n\n    /**\n     * compares a SymbolList against a Symbol array\n     */\n    protected boolean compareSymbolLists(SymbolList list, Symbol [] array)\n    {\n        // array must be at least as long as SymbolList\n        int length = list.length();\n        if (length > array.length) return false;\n\n        // compare symbol lists across length\n        for (int i =1; i <= length; i++) {\n            if (list.symbolAt(i) != array[i-1]) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Note that arrayAlpha <b>MUST NOT</b> have Symbols that are incompatible with symListAlpha!!!\n     * e.g. arrayAlpha may have ambiguity symbols in it that are only implicitly defined by symListAlpha.\n     * @param arrayAlpha the Alphabet from which the Symbols in the Symbol[] are to be drawn.\n     * @param symListAlpha the Alphabet on which the symbolList is to be defined.\n     */\n    protected boolean runSymbolListTest(FiniteAlphabet arrayAlpha, FiniteAlphabet symListAlpha, int length, SymListFactory factory)\n        throws Exception\n    {\n            // create a Symbol array of the kind required\n            Symbol [] array = createRandomSymbolArray(arrayAlpha, length);\n            assertNotNull(array);\n\n            // create the required SymbolList\n            SymbolList symList = factory.createSymbolList(array, symListAlpha, length);\n//            if (symList == null) return false;\n            assertNotNull(symList);\n\n            // verify and return result.\n            return compareSymbolLists(symList, array);\n    }\n\n\n    /**\n     * runs repeated tests for the constructor\n     * that takes a SymbolList argument\n     */\n    private boolean runRepeatedSymbolListTests(FiniteAlphabet arrayAlpha, FiniteAlphabet symListAlpha, SymListFactory factory)\n        throws Exception\n    {\n        for (int i=0; i < testLengths.length; i++) {\n\n            // setup test for specified length\n            int length = testLengths[i];\n\n            for (int j=0; j < noRepeats; j++ ) {\n                assertTrue(runSymbolListTest(arrayAlpha, symListAlpha, length, factory));\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * set that generates a DNA alphabet including ambiguity symbols.\n     */\n    private FiniteAlphabet generateAmbiguousDNA()\n    {\n        FiniteAlphabet dna = DNATools.getDNA();\n\n        FiniteAlphabet ambiguous = new SimpleAlphabet();\n\n        try {\n        ambiguous.addSymbol(DNATools.a());\n        ambiguous.addSymbol(DNATools.c());\n        ambiguous.addSymbol(DNATools.g());\n        ambiguous.addSymbol(DNATools.t());\n\n        Set chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars.add(DNATools.n());\n\n        return ambiguous;\n        }\n        catch (IllegalSymbolException ise) {\n            return null;\n        }\n        catch (ChangeVetoException cve) {\n            return null;\n        }\n    }\n\n    /**\n     * test for PackedSymbolList that implements ambiguity symbols.\n     */\n    public void testPackedSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a PackedSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    try {\n                        // get a packing\n                        Packing pack = PackingFactory.getPacking(DNATools.getDNA(), true);\n                        assertNotNull(pack);\n                        assertNotNull(array);\n                        assertNotNull(alpha);\n                        assertTrue(length > 0);\n\n                        return new PackedSymbolList(pack, array, length, alpha);\n                    }\n                    catch (IllegalAlphabetException iae) {\n                        iae.printStackTrace();\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    /**\n     * test for SimpleSymbolList that implements ambiguity symbols.\n     */\n    public void testSimpleSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a SimpleSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    assertNotNull(array);\n                    assertNotNull(alpha);\n                    assertTrue(length > 0);\n\n                    return new SimpleSymbolList(array, length, alpha);\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    /**\n     * test for PackedSymbolList that does not implement ambiguity symbols.\n     */\n    public void testPackedSymbolListWithoutAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet without ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        assertNotNull(symListAlpha);\n\n        // create a PackedSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    try {\n                        // get a packing\n                        Packing pack = PackingFactory.getPacking(DNATools.getDNA(), false);\n                        assertNotNull(pack);\n                        assertNotNull(array);\n                        assertNotNull(alpha);\n                        assertTrue(length > 0);\n\n                        return new PackedSymbolList(pack, array, length, alpha);\n                    }\n                    catch (IllegalAlphabetException iae) {\n                        iae.printStackTrace();\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(symListAlpha, symListAlpha, factory));\n    }\n    \n    public void testSymbolListsEqual() throws Exception {\n        SymbolList dna = DNATools.createDNA(\"\");\n        SymbolList rna = RNATools.createRNA(\"\");\n        assertFalse(dna.equals(rna));\n    }\n\n    /**\n     * test for SimpleSymbolList that implements ambiguity symbols.\n     */\n    public void testChunkedPackedSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a SimpleSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    assertNotNull(array);\n                    assertNotNull(alpha);\n                    assertTrue(length > 0);\n\n                    try {\n                        // create the factory that will make our sequence\n                        ChunkedSymbolListFactory chunker = new ChunkedSymbolListFactory(new PackedSymbolListFactory(true));\n\n                        // add symbols to it.\n                        chunker.addSymbols(alpha, array, 0, length);\n                        return chunker.makeSymbolList();\n                    }\n                        catch (IllegalAlphabetException iae) {\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    // creates a suite\n    public static Test suite()\n    {\n        TestSuite suite = new TestSuite(SymbolListTest.class);\n\n//        TestSuite suite = new TestSuite();\n//        suite.add(new SymbolListTest(\"PackedSymbolListWithAmbiguitySymbols\"));\n\n        return suite;\n    }\n\n    // harness for tests\n    public static void main(String [] args)\n    {\n        junit.textui.TestRunner.run(suite());\n    }\n}\n","changedTest":"","commitMessage":"New generic sequences.\n\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7309 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}