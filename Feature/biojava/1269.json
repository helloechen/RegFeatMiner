{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleProfileProfileAligner.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleProfileProfileAlignerTest.java","prod_time":"2010-08-11 10:09:47","test_time":"2010-08-11 10:09:47","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":4,"del_call_line":36,"del_classname_line":0,"del_condition_line":13,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":4,"del_return_line":0,"label":"POSITIVE","prod_commitID":"7697759eb7f0f244008db19a72dc79c3286b5f8a","test_commitID":"7697759eb7f0f244008db19a72dc79c3286b5f8a","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 30, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\nimport java.util.concurrent.Future;\n\nimport org.biojava3.alignment.template.AbstractProfileProfileAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Aligner;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a simple (naive) {@link Aligner} for a pair of {@link Profile}s.  This is basically an extension of the\n * {@link NeedlemanWunsch} pairwise sequence aligner to pairwise profile alignment using a sum-of-pairs score.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the pair of alignment {@link Profile}s is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfileProfileAligner<S extends Sequence<C>, C extends Compound>\n        extends AbstractProfileProfileAligner<S, C> {\n\n    /**\n     * Before running a profile-profile alignment, data must be sent in via calls to\n     * {@link #setQuery(Profile)}, {@link #setTarget(Profile)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public SimpleProfileProfileAligner() {\n    }\n\n    /**\n     * Prepares for a profile-profile alignment.\n     *\n     * @param query the first {@link Profile} of the pair to align\n     * @param target the second {@link Profile} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Profile<S, C> query, Profile<S, C> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align, still to be calculated\n     * @param target the second {@link Profile} of the pair to align, still to be calculated\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Future<ProfilePair<S, C>> query, Future<ProfilePair<S, C>> target,\n            GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align\n     * @param target the second {@link Profile} of the pair to align, still to be calculated\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Profile<S, C> query, Future<ProfilePair<S, C>> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align, still to be calculated\n     * @param target the second {@link Profile} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Future<ProfilePair<S, C>> query, Profile<S, C> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    // helper methods\n\n    // scores with linear gap penalty; saves memory by skipping allocation of separate matching and gap arrays\n    @Override\n    protected void alignScoreLinear() {\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = (short) (scores[x - 1][0] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = (short) (scores[0][y - 1] + getGapPenalty().getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) Math.max(Math.max(scores[x - 1][y] + getGapPenalty().getExtensionPenalty(),\n                        scores[x][y - 1] + getGapPenalty().getExtensionPenalty()), scores[x - 1][y - 1] +\n                        alignScoreColumns(x, y));\n            }\n        }\n    }\n\n    // traces back through score matrix; chooses highroad alignment\n    @Override\n    protected void alignTracebackLinear(List<Step> sx, List<Step> sy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        while (x > 0 || y > 0) {\n            if (x == 0) {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            } else if (y == 0 || scores[x][y] == scores[x - 1][y] + getGapPenalty().getExtensionPenalty()) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n            } else if (scores[x][y] == scores[x - 1][y - 1] + alignScoreColumns(x, y)) {\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n            } else {\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n            }\n        }\n    }\n\n    // scores with affine gap penalty\n    @Override\n    protected void alignScoreAffine(short[][] ix, short[][] iy) {\n        GapPenalty gapPenalty = getGapPenalty();\n        short min = (short) (Short.MIN_VALUE - gapPenalty.getOpenPenalty() - gapPenalty.getExtensionPenalty());\n        ix[0][0] = iy[0][0] = gapPenalty.getOpenPenalty();\n        for (int x = 1; x < scores.length; x++) {\n            scores[x][0] = iy[x][0] = min;\n            ix[x][0] = (short) (ix[x - 1][0] + gapPenalty.getExtensionPenalty());\n        }\n        for (int y = 1; y < scores[0].length; y++) {\n            scores[0][y] = ix[0][y] = min;\n            iy[0][y] = (short) (iy[0][y - 1] + gapPenalty.getExtensionPenalty());\n        }\n        for (int x = 1; x < scores.length; x++) {\n            for (int y = 1; y < scores[0].length; y++) {\n                scores[x][y] = (short) (Math.max(Math.max(scores[x - 1][y - 1], ix[x - 1][y - 1]), iy[x - 1][y - 1]) +\n                        alignScoreColumns(x, y));\n                ix[x][y] = (short) (Math.max(scores[x - 1][y] + gapPenalty.getOpenPenalty(), ix[x - 1][y]) +\n                        gapPenalty.getExtensionPenalty());\n                iy[x][y] = (short) (Math.max(scores[x][y - 1] + gapPenalty.getOpenPenalty(), iy[x][y - 1]) +\n                        gapPenalty.getExtensionPenalty());\n            }\n        }\n    }\n\n    // traces back through score matrices; chooses highroad alignment\n    @Override\n    protected void alignTracebackAffine(List<Step> sx, List<Step> sy, short[][] ix, short[][] iy) {\n        int x = scores.length - 1, y = scores[0].length - 1;\n        int max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n        Last last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n        while (x > 0 || y > 0) {\n            switch (last) {\n            case IX:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.GAP);\n                x--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() > ix[x][y]) ? Last.M : Last.IX;\n                break;\n            case M:\n                sx.add(0, Step.COMPOUND);\n                sy.add(0, Step.COMPOUND);\n                x--;\n                y--;\n                max = Math.max(Math.max(scores[x][y], ix[x][y]), iy[x][y]);\n                last = (max == ix[x][y]) ? Last.IX : ((max == scores[x][y]) ? Last.M : Last.IY);\n                break;\n            case IY:\n                sx.add(0, Step.GAP);\n                sy.add(0, Step.COMPOUND);\n                y--;\n                last = (scores[x][y] + getGapPenalty().getOpenPenalty() >= iy[x][y]) ? Last.M : Last.IY;\n            }\n        }\n    }\n\n    // sets output fields\n    @Override\n    protected void alignSetOutputs(List<Step> sx, List<Step> sy) {\n        score = scores[scores.length - 1][scores[0].length - 1];\n        profile = pair = new SimpleProfilePair<S, C>(getQuery(), getTarget(), sx, sy);\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 30, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.List;\nimport java.util.concurrent.Future;\n\nimport org.biojava3.alignment.template.AbstractProfileProfileAligner;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Aligner;\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a simple (naive) {@link Aligner} for a pair of {@link Profile}s.  This is basically an extension of the\n * {@link NeedlemanWunsch} pairwise sequence aligner to pairwise profile alignment using a sum-of-pairs score.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the pair of alignment {@link Profile}s is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfileProfileAligner<S extends Sequence<C>, C extends Compound>\n        extends AbstractProfileProfileAligner<S, C> {\n\n    /**\n     * Before running a profile-profile alignment, data must be sent in via calls to\n     * {@link #setQuery(Profile)}, {@link #setTarget(Profile)}, {@link #setGapPenalty(GapPenalty)}, and\n     * {@link #setSubstitutionMatrix(SubstitutionMatrix)}.\n     */\n    public SimpleProfileProfileAligner() {\n    }\n\n    /**\n     * Prepares for a profile-profile alignment.\n     *\n     * @param query the first {@link Profile} of the pair to align\n     * @param target the second {@link Profile} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Profile<S, C> query, Profile<S, C> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align, still to be calculated\n     * @param target the second {@link Profile} of the pair to align, still to be calculated\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Future<ProfilePair<S, C>> query, Future<ProfilePair<S, C>> target,\n            GapPenalty gapPenalty, SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align\n     * @param target the second {@link Profile} of the pair to align, still to be calculated\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Profile<S, C> query, Future<ProfilePair<S, C>> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    /**\n     * Prepares for a profile-profile alignment run concurrently.\n     *\n     * @param query the first {@link Profile} of the pair to align, still to be calculated\n     * @param target the second {@link Profile} of the pair to align\n     * @param gapPenalty the gap penalties used during alignment\n     * @param subMatrix the set of substitution scores used during alignment\n     */\n    public SimpleProfileProfileAligner(Future<ProfilePair<S, C>> query, Profile<S, C> target, GapPenalty gapPenalty,\n            SubstitutionMatrix<C> subMatrix) {\n        super(query, target, gapPenalty, subMatrix);\n    }\n\n    // method for AbstractMatrixAligner\n\n    @Override\n    protected void setOutputs(List<Step> sx, List<Step> sy) {\n        super.setOutputs(sx, sy);\n        profile = pair = new SimpleProfilePair<S, C>(getQuery(), getTarget(), sx, sy);\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class SimpleProfileProfileAlignerTest {\n\n    private ProteinSequence protein1, protein2, protein3, protein4;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private Profile<ProteinSequence, AminoAcidCompound> prof1, prof2, prof3, prof4;\n    private SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound> sppa1, sppa2, sppa3;\n    private ProfilePair<ProteinSequence, AminoAcidCompound> pp1, pp2, all;\n\n    @Before\n    public void setup() {\n        protein1 = new ProteinSequence(\"ARND\");\n        protein2 = new ProteinSequence(\"ARND\");\n        protein3 = new ProteinSequence(\"HILK\");\n        protein4 = new ProteinSequence(\"ANDR\");\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        prof1 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein1);\n        prof2 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein2);\n        prof3 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein3);\n        prof4 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein4);\n        sppa1 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(prof1, prof2, gaps, blosum62);\n        pp1 = sppa1.getPair();\n        sppa2 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(prof3, prof4, gaps, blosum62);\n        pp2 = sppa2.getPair();\n        sppa3 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(pp1, pp2, gaps, blosum62);\n        all = sppa3.getPair();\n    }\n\n    @Test\n    public void testSimpleProfileProfileAligner() {\n        SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound> alig =\n                new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>();\n        alig.setQuery(prof1);\n        alig.setTarget(prof2);\n        alig.setGapPenalty(gaps);\n        alig.setSubstitutionMatrix(blosum62);\n        assertEquals(alig.getScore(), sppa1.getScore());\n    }\n\n    @Test\n    public void testSimpleProfileProfileAlignerProfileOfSCProfileOfSCGapPenaltySubstitutionMatrixOfC() {\n        assertNotNull(sppa1);\n        assertNotNull(sppa2);\n        assertNotNull(sppa3);\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(sppa1.getQuery(), prof1);\n        assertEquals(sppa2.getQuery(), prof3);\n        assertEquals(sppa3.getQuery(), pp1);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(sppa1.getTarget(), prof2);\n        assertEquals(sppa2.getTarget(), prof4);\n        assertEquals(sppa3.getTarget(), pp2);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(sppa1.getGapPenalty(), gaps);\n        assertEquals(sppa2.getGapPenalty(), gaps);\n        assertEquals(sppa3.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(sppa1.getSubstitutionMatrix(), blosum62);\n        assertEquals(sppa2.getSubstitutionMatrix(), blosum62);\n        assertEquals(sppa3.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(sppa1.isStoringScoreMatrix());\n        assertFalse(sppa2.isStoringScoreMatrix());\n        assertFalse(sppa3.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        short[][] scores = sppa1.getScoreMatrix();\n        assertEquals(scores[2][1], 1);\n        scores = sppa2.getScoreMatrix();\n        assertEquals(scores[3][4], -7);\n        scores = sppa3.getScoreMatrix();\n        assertEquals(scores[1][2], 1);\n    }\n\n    @Test // TODO fix spacing, fix consensus sequence labels\n    public void testGetScoreMatrixAsString() {\n        assertEquals(sppa1.getScoreMatrixAsString(), String.format(\n                \"        A   R   N   D%n\" +\n                \"    0  -3  -4  -5  -6%n\" +\n                \"A  -3   4   1   0  -1%n\" +\n                \"R  -4   1   9   6   5%n\" +\n                \"N  -5   0   6  15  12%n\" +\n                \"D  -6  -1   5  12  21%n\"));\n        assertEquals(sppa2.getScoreMatrixAsString(), String.format(\n                \"        A   N   D   R%n\" +\n                \"    0  -3  -4  -5  -6%n\" +\n                \"H  -3  -2  -2  -5  -5%n\" +\n                \"I  -4  -4  -5  -5  -8%n\" +\n                \"L  -5  -5  -6  -8  -7%n\" +\n                \"K  -6  -6  -5  -7  -6%n\"));\n        assertEquals(sppa3.getScoreMatrixAsString(), String.format(\n                \"        -   H   I   L   K%n\" +\n                \"    0  -3  -4  -5  -6  -7%n\" +\n                \"A  -3   4   1   0  -1  -2%n\" +\n                \"R  -4   1   4   1   0   3%n\" +\n                \"N  -5   0   5   3   1   0%n\" +\n                \"D  -6  -1   2   7   4   3%n\"));\n    }\n\n    @Test\n    public void testGetScoreMatrixAt() {\n        assertEquals(sppa1.getScoreMatrixAt(0, 3), -5);\n        assertEquals(sppa2.getScoreMatrixAt(1, 1), -2);\n        assertEquals(sppa3.getScoreMatrixAt(3, 5), 0);\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(sppa1.getComputationTime() > 0);\n        assertTrue(sppa2.getComputationTime() > 0);\n        assertTrue(sppa3.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(sppa1.getProfile().toString(), String.format(\"ARND%nARND%n\"));\n        assertEquals(sppa2.getProfile().toString(), String.format(\"-HILK%nAND-R%n\"));\n        assertEquals(sppa3.getProfile().toString(), String.format(\"ARND--%nARND--%n--HILK%nA-ND-R%n\"));\n    }\n\n    @Test // TODO better bounds\n    public void testGetMaxScore() {\n        assertEquals(sppa1.getMaxScore(), 21);\n        assertEquals(sppa2.getMaxScore(), 21);\n        assertEquals(sppa3.getMaxScore(), 21);\n    }\n\n    @Test // TODO better bounds\n    public void testGetMinScore() {\n        assertEquals(sppa1.getMinScore(), -12);\n        assertEquals(sppa2.getMinScore(), -12);\n        assertEquals(sppa3.getMinScore(), -13);\n    }\n\n    @Test // TODO fix last score\n    public void testGetScore() {\n        assertEquals(sppa1.getScore(), 21);\n        assertEquals(sppa2.getScore(), -6);\n//        assertEquals(sppa3.getScore(), 3);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(pp1.toString(), String.format(\"ARND%nARND%n\"));\n        assertEquals(pp2.toString(), String.format(\"-HILK%nAND-R%n\"));\n        assertEquals(all.toString(), String.format(\"ARND--%nARND--%n--HILK%nA-ND-R%n\"));\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport org.biojava3.alignment.template.GapPenalty;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfilePair;\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class SimpleProfileProfileAlignerTest {\n\n    private ProteinSequence protein1, protein2, protein3, protein4;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private Profile<ProteinSequence, AminoAcidCompound> prof1, prof2, prof3, prof4;\n    private SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound> sppa1, sppa2, sppa3;\n    private ProfilePair<ProteinSequence, AminoAcidCompound> pp1, pp2, all;\n\n    @Before\n    public void setup() {\n        protein1 = new ProteinSequence(\"ARND\");\n        protein2 = new ProteinSequence(\"ARND\");\n        protein3 = new ProteinSequence(\"HILK\");\n        protein4 = new ProteinSequence(\"ANDR\");\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        prof1 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein1);\n        prof2 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein2);\n        prof3 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein3);\n        prof4 = new SimpleProfile<ProteinSequence, AminoAcidCompound>(protein4);\n        sppa1 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(prof1, prof2, gaps, blosum62);\n        pp1 = sppa1.getPair();\n        sppa2 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(prof3, prof4, gaps, blosum62);\n        pp2 = sppa2.getPair();\n        sppa3 = new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>(pp1, pp2, gaps, blosum62);\n        all = sppa3.getPair();\n    }\n\n    @Test\n    public void testSimpleProfileProfileAligner() {\n        SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound> alig =\n                new SimpleProfileProfileAligner<ProteinSequence, AminoAcidCompound>();\n        alig.setQuery(prof1);\n        alig.setTarget(prof2);\n        alig.setGapPenalty(gaps);\n        alig.setSubstitutionMatrix(blosum62);\n        assertEquals(alig.getScore(), sppa1.getScore());\n    }\n\n    @Test\n    public void testSimpleProfileProfileAlignerProfileOfSCProfileOfSCGapPenaltySubstitutionMatrixOfC() {\n        assertNotNull(sppa1);\n        assertNotNull(sppa2);\n        assertNotNull(sppa3);\n    }\n\n    @Test\n    public void testGetQuery() {\n        assertEquals(sppa1.getQuery(), prof1);\n        assertEquals(sppa2.getQuery(), prof3);\n        assertEquals(sppa3.getQuery(), pp1);\n    }\n\n    @Test\n    public void testGetTarget() {\n        assertEquals(sppa1.getTarget(), prof2);\n        assertEquals(sppa2.getTarget(), prof4);\n        assertEquals(sppa3.getTarget(), pp2);\n    }\n\n    @Test\n    public void testGetGapPenalty() {\n        assertEquals(sppa1.getGapPenalty(), gaps);\n        assertEquals(sppa2.getGapPenalty(), gaps);\n        assertEquals(sppa3.getGapPenalty(), gaps);\n    }\n\n    @Test\n    public void testGetSubstitutionMatrix() {\n        assertEquals(sppa1.getSubstitutionMatrix(), blosum62);\n        assertEquals(sppa2.getSubstitutionMatrix(), blosum62);\n        assertEquals(sppa3.getSubstitutionMatrix(), blosum62);\n    }\n\n    @Test\n    public void testIsStoringScoreMatrix() {\n        assertFalse(sppa1.isStoringScoreMatrix());\n        assertFalse(sppa2.isStoringScoreMatrix());\n        assertFalse(sppa3.isStoringScoreMatrix());\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        short[][][] scores = sppa1.getScoreMatrix();\n        assertEquals(scores[2][1][1], 1);\n        scores = sppa2.getScoreMatrix();\n        assertEquals(scores[3][4][0], -7);\n        scores = sppa3.getScoreMatrix();\n        assertEquals(scores[1][2][2], 1);\n    }\n\n    @Test\n    public void testGetScoreMatrixAsString() {\n        assertEquals(sppa1.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"        A   R   N   D%n\" +\n                \"    0  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -\\u221E   4  -4  -6  -7%n\" +\n                \"R  -\\u221E  -4   9   1  -2%n\" +\n                \"N  -\\u221E  -6   1  15   7%n\" +\n                \"D  -\\u221E  -7  -2   7  21%n\" +\n                \"%nDeletion%n\" +\n                \"        A   R   N   D%n\" +\n                \"   -2  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -3  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"R  -4   1  -7  -9 -10%n\" +\n                \"N  -5   0   6  -2  -5%n\" +\n                \"D  -6  -1   5  12   4%n\" +\n                \"%nInsertion%n\" +\n                \"        A   R   N   D%n\" +\n                \"   -2  -3  -4  -5  -6%n\" +\n                \"A  -\\u221E  -\\u221E   1   0  -1%n\" +\n                \"R  -\\u221E  -\\u221E  -7   6   5%n\" +\n                \"N  -\\u221E  -\\u221E  -9  -2  12%n\" +\n                \"D  -\\u221E  -\\u221E -10  -5   4%n\"));\n        assertEquals(sppa2.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"        A   N   D   R%n\" +\n                \"    0  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"H  -\\u221E  -2  -2  -5  -5%n\" +\n                \"I  -\\u221E  -4  -5  -5  -8%n\" +\n                \"L  -\\u221E  -5  -7  -9  -7%n\" +\n                \"K  -\\u221E  -6  -5  -7  -6%n\" +\n                \"%nDeletion%n\" +\n                \"        A   N   D   R%n\" +\n                \"   -2  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"H  -3  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"I  -4  -5  -5  -8  -8%n\" +\n                \"L  -5  -6  -6  -8  -9%n\" +\n                \"K  -6  -7  -7  -9 -10%n\" +\n                \"%nInsertion%n\" +\n                \"        A   N   D   R%n\" +\n                \"   -2  -3  -4  -5  -6%n\" +\n                \"H  -\\u221E  -\\u221E  -5  -5  -6%n\" +\n                \"I  -\\u221E  -\\u221E  -7  -8  -8%n\" +\n                \"L  -\\u221E  -\\u221E  -8  -9 -10%n\" +\n                \"K  -\\u221E  -\\u221E  -9  -8  -9%n\"));\n        assertEquals(sppa3.getScoreMatrixAsString(), String.format(\n                \"Substitution%n\" +\n                \"        -   H   I   L   K%n\" +\n                \"    0  -\\u221E  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -\\u221E   4  -5  -5  -6  -7%n\" +\n                \"R  -\\u221E  -4   4  -1  -2   3%n\" +\n                \"N  -\\u221E  -6   5   3  -2   0%n\" +\n                \"D  -\\u221E  -7   0   7  -1   0%n\" +\n                \"%nDeletion%n\" +\n                \"        -   H   I   L   K%n\" +\n                \"   -2  -\\u221E  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"A  -3  -\\u221E  -\\u221E  -\\u221E  -\\u221E  -\\u221E%n\" +\n                \"R  -4   1  -8  -8  -9 -10%n\" +\n                \"N  -5   0   1  -4  -5   0%n\" +\n                \"D  -6  -1   2   0  -5  -1%n\" +\n                \"%nInsertion%n\" +\n                \"        -   H   I   L   K%n\" +\n                \"   -2  -3  -4  -5  -6  -7%n\" +\n                \"A  -\\u221E  -\\u221E   1   0  -1  -2%n\" +\n                \"R  -\\u221E  -\\u221E  -7   1   0  -1%n\" +\n                \"N  -\\u221E  -\\u221E  -9   2   1   0%n\" +\n                \"D  -\\u221E  -\\u221E -10  -3   4   3%n\"));\n    }\n\n    @Test\n    public void testGetComputationTime() {\n        assertTrue(sppa1.getComputationTime() > 0);\n        assertTrue(sppa2.getComputationTime() > 0);\n        assertTrue(sppa3.getComputationTime() > 0);\n    }\n\n    @Test\n    public void testGetProfile() {\n        assertEquals(sppa1.getProfile().toString(), String.format(\"ARND%nARND%n\"));\n        assertEquals(sppa2.getProfile().toString(), String.format(\"-HILK%nAND-R%n\"));\n        assertEquals(sppa3.getProfile().toString(), String.format(\"ARND--%nARND--%n--HILK%nA-ND-R%n\"));\n    }\n\n    @Test\n    public void testGetMaxScore() {\n        assertEquals(sppa1.getMaxScore(), 21);\n        assertEquals(sppa2.getMaxScore(), 21);\n        assertEquals(sppa3.getMaxScore(), 21);\n    }\n\n    @Test\n    public void testGetMinScore() {\n        assertEquals(sppa1.getMinScore(), -12);\n        assertEquals(sppa2.getMinScore(), -12);\n        assertEquals(sppa3.getMinScore(), -13);\n    }\n\n    @Test\n    public void testGetScore() {\n        assertEquals(sppa1.getScore(), 21);\n        assertEquals(sppa2.getScore(), -6);\n        assertEquals(sppa3.getScore(), 3);\n    }\n\n    @Test\n    public void testGetPair() {\n        assertEquals(pp1.toString(), String.format(\"ARND%nARND%n\"));\n        assertEquals(pp2.toString(), String.format(\"-HILK%nAND-R%n\"));\n        assertEquals(all.toString(), String.format(\"ARND--%nARND--%n--HILK%nA-ND-R%n\"));\n    }\n\n}\n","commitMessage":"refactored alignment routines: granted access to all score matrices, reduced memory requirement\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8190 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"refactored alignment routines: granted access to all score matrices, reduced memory requirement\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8190 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}