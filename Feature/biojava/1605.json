{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/Bond.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/TestBond.java","prod_time":"2013-08-13 00:16:34","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":1,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":2,"label":"NEGATIVE","prod_commitID":"fd9628a3049d85842907a0afc81197e8c545b634","test_commitID":"","isfound":"not found test change","originPro":"/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage org.biojava.bio.structure;\n\n/**\n * A simple bond -- it stores information about two atoms as well as information\n * about the type of bond it is and its bond order.\n * \n * @see BondType\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\n * @author Ulysse Carion\n */\npublic class Bond {\n\tprivate BondType type;\n\tprivate Atom atomA;\n\tprivate Atom atomB;\n\tprivate int bondOrder;\n\n\t/**\n\t * Constructs a new bond from a pair of atoms, the type of bond this is, and\n\t * the bond order of the bond between them.\n\t * <p>\n\t * Note that when using this constructor, creating a Bond with some atoms A\n\t * and B is not equivalent to forming a bond between A and B; to do this,\n\t * one must either call {@link #addSelfToAtoms()} or use the constructor\n\t * {@link #Bond(Atom, Atom, BondType, int, boolean)}, with the last argument\n\t * set to 'true'.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param type\n\t *            this bond's type\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, BondType type, int bondOrder) {\n\t\tthis(atomA, atomB, type, bondOrder, false);\n\t}\n\n\t/**\n\t * Constructs a new bond from a pair of atoms, the type of bond this is, and\n\t * the bond order of the bond between them.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param type\n\t *            this bond's type\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t * @param addSelfToAtoms\n\t *            if set to true, this bond, once created, will automatically\n\t *            add itself to atomA and atomB's bond lists.\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, BondType type, int bondOrder,\n\t\t\tboolean addSelfToAtoms) {\n\t\tthis.type = type;\n\t\tthis.atomA = atomA;\n\t\tthis.atomB = atomB;\n\t\tthis.bondOrder = bondOrder;\n\n\t\tif (addSelfToAtoms) {\n\t\t\taddSelfToAtoms();\n\t\t}\n\t}\n\n\t/**\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\n\t * then the list returned from calling {@link Atom#getBonds()} will not\n\t * include this bond.\n\t */\n\t// TODO first check if those bonds haven't been made already\n\tpublic void addSelfToAtoms() {\n\t\tatomA.getBonds().add(this);\n\t\tatomB.getBonds().add(this);\n\t}\n\n\t/**\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomB()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomA() {\n\t\treturn atomA;\n\t}\n\n\t/**\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomA()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomB() {\n\t\treturn atomB;\n\t}\n\n\t/**\n\t * A utility method to get the other atom in a bond, given one of its atoms.\n\t * If the atom passed is one of the atoms in this bond, then this method is\n\t * essentially equivalent to saying\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\n\t * <p>\n\t * <i>Note:</i> Comparison of atoms in this method is done with\n\t * <code>==</code>, not <code>equals</code>.\n\t * \n\t * @param exclude\n\t *            the atom of the bond to not return\n\t * @throws IllegalArgumentException\n\t *             if the passed atom is not in this bond\n\t * @return the atom in this bond that was not passed as an argument\n\t */\n\tpublic Atom getOther(Atom exclude) {\n\t\tif (exclude != atomA && exclude != atomB) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\n\t\t}\n\n\t\tif (exclude == atomA) {\n\t\t\treturn atomB;\n\t\t} else {\n\t\t\treturn atomA;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the BondType of this Bond.\n\t * \n\t * @return this bond's BondType\n\t */\n\tpublic BondType getType() {\n\t\treturn type;\n\t}\n\n\t/**\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\n\t * single bond, '2' to a double bond, etc.\n\t * \n\t * @return this bond's bond order\n\t */\n\tpublic int getBondOrder() {\n\t\treturn bondOrder;\n\t}\n\n\t/**\n\t * Gets the distance between the two atoms of this bond.\n\t * <p>\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\n\t * this method will suppress the empty threat of a\n\t * {@link StructureException} that method makes.\n\t * \n\t * @return the distance between the two atoms of this bond.\n\t */\n\tpublic double getLength() {\n\t\ttry {\n\t\t\treturn Calc.getDistance(atomA, atomB);\n\t\t} catch (StructureException e) {\n\t\t\treturn -1; // this will never happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Bond [type=\" + type + \", atomA=\" + atomA + \", atomB=\" + atomB\n\t\t\t\t+ \", bondOrder=\" + bondOrder + \"]\";\n\t}\n}\n","changedPro":"/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage org.biojava.bio.structure;\n\n/**\n * A simple bond -- it stores information about two atoms as well as information\n * about its bond order.\n * \n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\n * @author Ulysse Carion\n */\npublic class Bond {\n\tprivate Atom atomA;\n\tprivate Atom atomB;\n\tprivate int bondOrder;\n\n\t/**\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\n\t * between them.\n\t * <p>\n\t * Note that when using this constructor, creating a Bond with some atoms A\n\t * and B is not equivalent to forming a bond between A and B; to do this,\n\t * one must either call {@link #addSelfToAtoms()} or use the constructor\n\t * {@link #Bond(Atom, Atom, int, boolean)}, with the last argument set to\n\t * 'true'.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder) {\n\t\tthis(atomA, atomB, bondOrder, false);\n\t}\n\n\t/**\n\t * Constructs a new bond from a pair of atoms and the bond order of the bond\n\t * between them.\n\t * \n\t * @param atomA\n\t *            one of the atoms in this bond\n\t * @param atomB\n\t *            the other atom in this bond\n\t * @param bondOrder\n\t *            the bond order of this bond\n\t * @param addSelfToAtoms\n\t *            if set to true, this bond, once created, will automatically\n\t *            add itself to atomA and atomB's bond lists.\n\t */\n\tpublic Bond(Atom atomA, Atom atomB, int bondOrder, boolean addSelfToAtoms) {\n\t\tthis.atomA = atomA;\n\t\tthis.atomB = atomB;\n\t\tthis.bondOrder = bondOrder;\n\n\t\tif (addSelfToAtoms) {\n\t\t\taddSelfToAtoms();\n\t\t}\n\t}\n\n\t/**\n\t * Adds this Bond to its atoms bond lists. If this method is not called,\n\t * then the list returned from calling {@link Atom#getBonds()} will not\n\t * include this bond.\n\t */\n\t// TODO first check if those bonds haven't been made already\n\tpublic void addSelfToAtoms() {\n\t\tatomA.getBonds().add(this);\n\t\tatomB.getBonds().add(this);\n\t}\n\n\t/**\n\t * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomB()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomA() {\n\t\treturn atomA;\n\t}\n\n\t/**\n\t * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\n\t * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n\t * which they are passed to this class's constructor.\n\t * \n\t * @see #getAtomA()\n\t * @return one of the two atoms in this bond\n\t */\n\tpublic Atom getAtomB() {\n\t\treturn atomB;\n\t}\n\n\t/**\n\t * A utility method to get the other atom in a bond, given one of its atoms.\n\t * If the atom passed is one of the atoms in this bond, then this method is\n\t * essentially equivalent to saying\n\t * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\n\t * <p>\n\t * <i>Note:</i> Comparison of atoms in this method is done with\n\t * <code>==</code>, not <code>equals</code>.\n\t * \n\t * @param exclude\n\t *            the atom of the bond to not return\n\t * @throws IllegalArgumentException\n\t *             if the passed atom is not in this bond\n\t * @return the atom in this bond that was not passed as an argument\n\t */\n\tpublic Atom getOther(Atom exclude) {\n\t\tif (exclude != atomA && exclude != atomB) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Atom to exclude is not in bond.\");\n\t\t}\n\n\t\tif (exclude == atomA) {\n\t\t\treturn atomB;\n\t\t} else {\n\t\t\treturn atomA;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the bond order of this bond. A return value of '1' corresponds to a\n\t * single bond, '2' to a double bond, etc.\n\t * \n\t * @return this bond's bond order\n\t */\n\tpublic int getBondOrder() {\n\t\treturn bondOrder;\n\t}\n\n\t/**\n\t * Gets the distance between the two atoms of this bond.\n\t * <p>\n\t * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}, but\n\t * this method will suppress the empty threat of a\n\t * {@link StructureException} that method makes.\n\t * \n\t * @return the distance between the two atoms of this bond.\n\t */\n\tpublic double getLength() {\n\t\ttry {\n\t\t\treturn Calc.getDistance(atomA, atomB);\n\t\t} catch (StructureException e) {\n\t\t\treturn -1; // this will never happen.\n\t\t}\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Bond [atomA=\" + atomA + \", atomB=\" + atomB + \", bondOrder=\"\n\t\t\t\t+ bondOrder + \"]\";\n\t}\n}\n","originTest":"package org.biojava.bio.structure;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Before;\n\npublic class TestBond extends TestCase {\n\tprivate Structure s;\n\t\n\t@Before\n\tpublic void setUp() throws IOException, StructureException {\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\tFileParsingParameters params = cache.getFileParsingParams();\n\t\t\n\t\tparams.setStoreEmptySeqRes(true);\n\t\tparams.setAlignSeqRes(true);\n\t\tparams.setLoadChemCompInfo(true);\n\t\tparams.setCreateAtomBonds(true);\n\t\t\n\t\tStructureIO.setAtomCache(cache);\n\t\ts = StructureIO.getStructure(\"1KH9\");\n\t}\n\t\n\tpublic void testIntraResidueBonds() throws StructureException {\n\t\tGroup g = s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\tAtom cg = g.getAtom(\"CG\");\n\n\t\tAtom cb = g.getAtom(\"CB\");\n\t\tAtom cd1 = g.getAtom(\"CD1\");\n\t\tAtom cd2 = g.getAtom(\"CD2\");\n\t\t\n\t\tassertEquals(3, cg.getBonds().size());\n\t\tfor (Bond bond : cg.getBonds()) {\n\t\t\tif (bond.getOther(cg) == cb) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd1) {\n\t\t\t\tassertEquals(2, bond.getBondOrder());\n\t\t\t} else if (bond.getOther(cg) == cd2) {\n\t\t\t\tassertEquals(1, bond.getBondOrder());\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void testPeptideBonds() throws StructureException {\n\t\tAminoAcidImpl residue1 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(273);\n\t\tAminoAcidImpl residue2 = (AminoAcidImpl) s.getChainByPDB(\"A\").getSeqResGroup(274);\n\t\t\n\t\tAtom carboxylC = residue1.getC();\n\t\tAtom aminoN = residue2.getN();\n\t\t\n\t\tassertTrue(areBonded(carboxylC, aminoN));\n\t}\n\t\n\tpublic void testLINKBonds() throws StructureException {\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(50).getAtom(\"OD1\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getAtomGroup(446).getAtom(\"MG\");\n\t\t\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tpublic void testDisulfideBonds() throws StructureException {\n\t\tAtom atom1 = s.getChainByPDB(\"A\").getSeqResGroup(177).getAtom(\"SG\");\n\t\tAtom atom2 = s.getChainByPDB(\"A\").getSeqResGroup(167).getAtom(\"SG\");\n\t\t\n\t\tassertTrue(areBonded(atom1, atom2));\n\t}\n\t\n\tprivate boolean areBonded(Atom a, Atom b) {\n\t\tfor (Bond bond : a.getBonds()) {\n\t\t\tif (bond.getOther(a) == b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n}\n","changedTest":"","commitMessage":"Remove BondType from Bond\n\nAll Bond objects are assumed to be covalent bonds\n","test_commitMessage":"","allZero":false}