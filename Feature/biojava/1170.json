{"repository":"biojava","prod_path":"alignment/src/main/java/org/biojava/bio/alignment/FlexibleAlignment.java","test_path":"alignment/src/test/java/org/biojava/bio/alignment/FlexibleAlignmentTest.java","prod_time":"2010-03-23 14:57:45","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":19,"add_classname_line":2,"add_condition_line":8,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":17,"add_return_line":1,"del_annotation_line":0,"del_call_line":15,"del_classname_line":3,"del_condition_line":7,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":14,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"6c9aa884b761dd552a6ea5ef3aefd305a16588f8","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Edit;\nimport org.biojava.bio.symbol.GappedSymbolList;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.RangeLocation;\nimport org.biojava.bio.symbol.SimpleGappedSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeEvent;\nimport org.biojava.utils.ChangeSupport;\nimport org.biojava.utils.ChangeVetoException;\n\n/** \n * <p>FlexibleAlignment is a class which implements\n * UnequalLengthAlignment, ARAlignment and EditableAlignment <b>It\n * places no restriction on where any sequence can be in the alignment\n * so there could be gaps in the alignment. You tell it where to put\n * the sequence, it will do it. I think I will be adding an Exception\n * NonContinuousAlignmentException. STILL UNDER\n * CONSTRUCTION. seqString does not work because there it does not\n * seem to support tokenization 'token' this is true for\n * SimpleAlignment too.</b>\n *\n * @author David Waring\n * @author Matthew Pocock\n */\npublic class FlexibleAlignment\n    extends AbstractULAlignment\n    implements ARAlignment, EditableAlignment{\n    \n    protected Map<Object, AlignmentElement> data;\n    protected List<Object> labelOrder;\n    protected  Location alignmentRange;\n    List<Alphabet> alphaList = new ArrayList<Alphabet>();\n    \n    /**\n    * construct this object with the reference sequence which can either be a gappedSymbolList or not\n    * label in all cases refers to an object that holds the display name (generally just a String).\n    * since more than one sequence in an alignment could have the same name this works as long as the\n    * labels are different objects even though they may hold the same name.\n    */\n\n    public FlexibleAlignment (List<AlignmentElement> seqList)throws BioException{\n        data = new Hashtable<Object, AlignmentElement>();\n        labelOrder = new Vector<Object>();\n        alignmentRange = new RangeLocation(1,1);\n        \n        int k=0;\n        // go through the list make sure that all seqs are GappedSymbolLists\n        for (Iterator<AlignmentElement> i = seqList.iterator();i.hasNext();){\n            AlignmentElement ae = i.next();\n            Object label = ae.getLabel();\n            Location loc = ae.getLoc();            \n            SymbolList seq = ae.getSymbolList();\n            alphaList.add(seq.getAlphabet());\n            if (! (seq instanceof GappedSymbolList)){\n                seq = new SimpleGappedSymbolList(seq);\n                ae = new SimpleAlignmentElement(label,seq,loc);\n            }\n            data.put(label,ae);\n            labelOrder.add(label);\n            int min = lesser(alignmentRange.getMin(),loc.getMin());\n            int max = greater(alignmentRange.getMax(),loc.getMax());\n            alignmentRange = new RangeLocation(min,max);\n            k++;\n        }\n        this.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n        try {\n            resetRange();\n        }catch (ChangeVetoException e){\n            throw new BioError(\"Should not have a problem here\");\n        }\n        \n    }\n\n    private int getOrder(Object label) throws Exception{\n\tfor (int i=0; i<labelOrder.size(); i++){\n\t    if(labelOrder.get(i).equals(label))\n\t\treturn i;\n\t}\n\tthrow new Exception(\"did not find label\");\n    }\n\n    \n   \n    /**\n    * add a new a alignment usings a location to the reference sequence. This should either contain\n    * no gaps or it should be relative to a reference sequence that already has the gaps added\n    */\n\n    public synchronized void addSequence(AlignmentElement ae)throws ChangeVetoException,BioException{\n        ChangeSupport cs;\n        ChangeEvent cevt;\n        \n        Object label = ae.getLabel();\n        SymbolList seq = ae.getSymbolList();\n        Location loc = ae.getLoc();\n        \n        // give the listeners a change to veto this\n         // create a new change event ->the EDIT is a static final variable of type ChangeType in SymbolList interface\n        cevt = new ChangeEvent(this, ARAlignment.ADD_LABEL, label);\n        cs = getChangeSupport(ARAlignment.ADD_LABEL);\n        \n        // let the listeners know what we want to do\n        cs.firePreChangeEvent(cevt);            \n        if (! (seq instanceof GappedSymbolList)){\n            seq = new SimpleGappedSymbolList(seq);\n            ae = new SimpleAlignmentElement(label,seq,loc);\n        }\n        data.put(label,ae);\n        labelOrder.add(label);\n\talphaList.add(seq.getAlphabet());\n        this.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);        \n\n        int min = lesser(alignmentRange.getMin(),loc.getMin()); \n        int max = greater(alignmentRange.getMax(),loc.getMax());\n        alignmentRange = new RangeLocation(min,max);\n        resetRange();\n\n        cs.firePostChangeEvent(cevt);                    \n        \n    }\n        \n        \n    public synchronized void removeSequence(Object label) throws ChangeVetoException{\n        \n        ChangeSupport cs;\n        ChangeEvent cevt;\n        \n        // give the listeners a change to veto this\n         // create a new change event ->the EDIT is a static final variable of type ChangeType in SymbolList interface\n        cevt = new ChangeEvent(this, ARAlignment.REMOVE_LABEL, label);\n        cs = getChangeSupport(ARAlignment.REMOVE_LABEL);\n        \n        // let the listeners know what we want to do\n        cs.firePreChangeEvent(cevt);\n\ttry{\n\t    alphaList.remove(getOrder(label));\n\t    this.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t}\n\tcatch (Throwable e){\n\t    e.printStackTrace();   \n        }\n        data.remove(label);\n        labelOrder.remove(label);\n        resetRange();\n        cs.firePostChangeEvent(cevt);\n             \n    }         \n        \n    /////////////////////////\n    // methods from Interface UnequalLengthAlignment\n    /////////////////////////\n    \n    /**\n    * The location of an individual SymbolList relative to overall Alignment\n    */        \n    public Location locInAlignment(Object label)throws NoSuchElementException{\n        return getAE(label).getLoc();\n    }        \n        \n    public List<Object> getLabelsAt(int column) throws IndexOutOfBoundsException {\n        if (column < 1 || column > this.length())\n            throw new IndexOutOfBoundsException();\n        List<Object> labelList = new ArrayList<Object>();\n        Location loc;\n        Object label;\n        for (Iterator<Object> labelIterator = data.keySet().iterator();labelIterator.hasNext();){\n            label = labelIterator.next();\n            loc = getAE(label).getLoc();\n            if (loc.contains(column))\n                labelList.add(label);\n        }\n        return labelList;\n    }\n            \n            \n    \n    /////////////////////////\n    // methods from Interface Alignment\n    ////////////////////////\n\n    public synchronized int length(){\n        return alignmentRange.getMax() - alignmentRange.getMin() + 1;\n    }\n    public Alphabet getAlphabet(){\n        return alphabet;\n    }\n    \n    /**\n    * getLabels will return a list of labels in left to right order\n    */\n    \n    public synchronized List<Object> getLabels(){\n        TreeSet<Object> sorted = new TreeSet<Object>(new LeftRightLocationComparator<Object>());\n        sorted.addAll(labelOrder);\n        return new Vector<Object>(sorted);\n    }\n    \n    /**\n    * This gets the symbol for an individual sequence at position in the overall alignment\n    * If the sequence is not aligned at that location it returns null\n    */\n    \n    \n    public synchronized Symbol symbolAt(Object label, int column) throws NoSuchElementException,IndexOutOfBoundsException{\n        \n        SymbolList seq = symbolListForLabel(label);\n        int cloc = posInSeq(label,column);\n        Symbol symbol = null;\n//debug (label.toString() + \" \" + column + \":\" + cloc);\n        if (seq == null){\n//            debug(\"seq is null\");\n        }\n  \n        try {\n            symbol = seq.symbolAt(cloc);\n        }catch (IndexOutOfBoundsException e){\n            // leave symbol == null\n        }\n        return symbol;    \n    }\n    \n    public synchronized SymbolList symbolListForLabel(Object label) throws NoSuchElementException{\n        return getAE(label).getSymbolList();\n    }\n    \n    \n    // methods from interface EditableAlignment\n    \n    public synchronized void edit(Object label,Edit edit) throws ChangeVetoException{\n        throw new BioError(\"Not implemented yet\");\n    }\n    \n    /**\n    * loc in this case is the Alignment Location\n    */\n    public synchronized void shiftAtAlignmentLoc(Object label, Location loc, int offset)\n        throws ChangeVetoException,IllegalAlignmentEditException,IndexOutOfBoundsException{\n        \n        Location sourceLoc = locInSeq(label,loc);\n        shiftAtSequenceLoc(label,sourceLoc,offset);\n\n        \n    }\n    \n    /**\n    * loc in this case is the SymbolList Location\n    */\n    public synchronized void shiftAtSequenceLoc(Object label, Location loc, int offset)\n        throws ChangeVetoException,IllegalAlignmentEditException,IndexOutOfBoundsException{\n        \n        ChangeSupport csgap;\n        ChangeEvent cegap;\n        ChangeSupport csloc;\n        ChangeEvent celoc;\n        celoc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n        csloc = getChangeSupport(EditableAlignment.LOCATION);\n        cegap = new ChangeEvent(this, EditableAlignment.GAPS, label);\n        csgap = getChangeSupport(EditableAlignment.GAPS);\n        \n        int caseValue = 0;\n        int absOffset = Math.abs(offset);\n        Location seqLoc = locInAlignment(label);\n        AlignmentElement ae = getAE(label);\n        SymbolList seq = ae.getSymbolList();\n        Location newLoc;\n        int min = loc.getMin();\n        int max = loc.getMax();\n        if (min < 1 || max > seq.length()){\n            throw new IndexOutOfBoundsException();\n        }\n        if (offset == 0) {\n            return;\n        }        \n        if (offset > 1) caseValue += 1;\n        if (min == 1) caseValue += 2;\n        if (max == seq.length()) caseValue += 4;\n        \n        switch(caseValue){\n            \n            case 0 : // internal shift to left\n                if (! allGaps(seq,min + offset, min - 1)){\n                    throw new IllegalAlignmentEditException ();\n                }\n                csgap.firePreChangeEvent(cegap);\n                \n                ((GappedSymbolList)seq).addGapsInView(max + 1, absOffset);                \n                removeGaps((GappedSymbolList)seq, min - absOffset, absOffset);\n                csgap.firePostChangeEvent(cegap);\n                break;\n                \n            case  1: // internal shift to right\n                if (! allGaps(seq,max + 1 , max + offset)){\n                    throw new IllegalAlignmentEditException ();\n                }\n                csgap.firePreChangeEvent(cegap);\n                removeGaps((GappedSymbolList)seq, max + 1, offset);\n                ((GappedSymbolList)seq).addGapsInView(min ,offset);                \n                csgap.firePostChangeEvent(cegap);\n                break;\n             \n            case 2 : // left end shift to left\n                csgap.firePreChangeEvent(cegap);\n                csloc.firePreChangeEvent(celoc);\n                ((GappedSymbolList)seq).addGapsInView(max + 1,absOffset);\n                newLoc = new RangeLocation(seqLoc.getMin() - absOffset, seqLoc.getMax());\n                ae.setLoc(newLoc);\n                resetRange();\n                csloc.firePostChangeEvent(celoc);\n                csgap.firePostChangeEvent(cegap);\n                break;\n                \n            case 3 : // left end shift to right\n                if (! allGaps(seq,max + 1 , max + offset)){\n                    throw new IllegalAlignmentEditException ();\n                }\n                csgap.firePreChangeEvent(cegap);\n                csloc.firePreChangeEvent(celoc);\n                removeGaps((GappedSymbolList)seq, max + 1, offset);\n                newLoc = new RangeLocation(seqLoc.getMin() + offset,seqLoc.getMax());\n                ae.setLoc(newLoc);\n                resetRange();\n                csloc.firePostChangeEvent(celoc);\n                csgap.firePostChangeEvent(cegap);\n                break;\n                \n            case 4 : // right end shift to left\n                if (! allGaps(seq,min - absOffset, min - 1)){\n                    throw new IllegalAlignmentEditException ();\n                }\n                csgap.firePreChangeEvent(cegap);\n                csloc.firePreChangeEvent(celoc);\n                removeGaps((GappedSymbolList)seq, min - absOffset , absOffset);\n                newLoc = new RangeLocation(seqLoc.getMin(),seqLoc.getMax() + offset);\n                ae.setLoc(newLoc);\n                resetRange();\n                csloc.firePostChangeEvent(celoc);\n                csgap.firePostChangeEvent(cegap);\n                break;\n                \n             case 5 : // right end shift to right\n                csgap.firePreChangeEvent(cegap);\n                csloc.firePreChangeEvent(celoc);\n                ((GappedSymbolList)seq).addGapsInView(min ,offset);\n                newLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax() + offset);\n                ae.setLoc(newLoc);\n                resetRange();\n                csloc.firePostChangeEvent(celoc);\n                csgap.firePostChangeEvent(cegap);\n                break;\n                \n            case 6 : // whole seq shift to left\ndebug(\"Shifting all to left \" + absOffset);\n                shift (label,offset);\n                break;\n                \n            case 7 : // whole seq shift to right\ndebug(\"Shifting all to right \" + absOffset);\n                shift (label,offset);\n                break;\n                \n            default :\ndebug(\"OOOPS something is wrong \" + loc.toString() + \" \" + absOffset);\n                return;\n        }\n    }        \n  \n        \n    \n    /**\n    * because there is a bug in GappedSymbolList\n    */\n    \n    public synchronized void removeGaps(GappedSymbolList seq,int start, int length){\n        try{\n            //  seq.removeGaps (start , length);\n            // because there is a bug in GappedSymbolList we do it one at a time\n            for (int i = 1; i <= length;i++){\n                seq.removeGap(start);\n            }\n        }catch (IllegalSymbolException e){\n            throw new BioError(\"We should have tested for this already\");\n        }\n    }\n    \n    /**\n    * make sure that all Symbols in this range are gaps\n    */\n    \n    protected synchronized boolean allGaps(SymbolList seq,int start, int end){\n\n        Symbol gs = seq.getAlphabet().getGapSymbol();\n        for (int i = start; i <= end; i++){\n            if (!(seq.symbolAt(i).equals(gs))){\n                return false;\n            }\n        }\n        return true;\n    }\n        \n    /**\n    * check that begining is at 1 otherwise shift everything over\n    */\n    protected synchronized void resetRange()throws ChangeVetoException{\n        \n        int min = 0;// just for the compiler\n        int max = 0;// just for the compiler\n        int lMin;\n        int lMax;\n        int count = 1;\n        // get the current range from all labels\n        for (Iterator<Object> i = getLabels().iterator();i.hasNext();){\n            Object label = i.next();            \n            lMin = locInAlignment(label).getMin();\n            lMax = locInAlignment(label).getMax();\n            if (count == 1){\n                min = lMin;\n            }else{\n                min = lesser(min , lMin);\n            }\n            if (count == 1){\n                max = lMax;\n            }else{\n                max = greater(max , lMax);\n            }\n            count++;\n         }\n        alignmentRange = new RangeLocation(min,max);\n        if (min != 1){\n            int offset = 1 - alignmentRange.getMin();\n            shiftAll(offset);\n            alignmentRange = new RangeLocation(alignmentRange.getMin() + offset, alignmentRange.getMax() + offset);\n        }\n    }\n    \n    \n    protected synchronized void shiftAll(int offset)throws ChangeVetoException{\n        List<Object> lList = getLabels();\n        for (Iterator<Object> i= lList.iterator();i.hasNext();){\n            Object label = i.next();\n            shift (label,offset);\n        }\n    }\n    \n    /**\n    * moves the whole sequence\n    */\n    \n    protected synchronized void shift(Object label,int offset)throws ChangeVetoException{\n        ChangeSupport csloc;\n        ChangeEvent celoc;\n        celoc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n        csloc = getChangeSupport(EditableAlignment.LOCATION);        \n        Location oLoc = locInAlignment(label);\n        Location nLoc = new RangeLocation(oLoc.getMin() + offset,oLoc.getMax() + offset);\n        csloc.firePreChangeEvent(celoc);        \n        debug(\"shifting \" + label.toString());\n        getAE(label).setLoc(nLoc);\n        resetRange();\n        debug(\"shifted \" + label);\n        csloc.firePostChangeEvent(celoc);\n    }\n    \n    // utility methods\n    protected int greater(int x, int y){\n        int greatest = (x > y) ? x : y;\n        return greatest;\n    }\n    protected int lesser(int x, int y){\n        int least = (x < y) ? x : y;\n        return least;\n    }\n    protected AlignmentElement getAE(Object label) throws NoSuchElementException{\n        if (!(data.containsKey(label)));\n        return data.get(label);\n    }\n    /**\n    * get the position in the sequence corresponding to the postion within the alignment\n    */\n    \n    protected synchronized int posInSeq(Object label,int column)throws NoSuchElementException, IndexOutOfBoundsException {\n        if (column < 1 || column > this.length()){\n            throw new IndexOutOfBoundsException();\n        }\n        Location loc = locInAlignment(label);\n        return (column - loc.getMin() + 1);\n    }\n    \n    protected synchronized Location locInSeq(Object label,Location viewLoc) throws NoSuchElementException, IndexOutOfBoundsException {\n        int min = posInSeq(label,viewLoc.getMin());\n        int max = posInSeq(label,viewLoc.getMax());\n        return  new RangeLocation(min,max);\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.util.Vector;\n\nimport org.biojava.bio.BioError;\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.Edit;\nimport org.biojava.bio.symbol.GappedSymbolList;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Location;\nimport org.biojava.bio.symbol.RangeLocation;\nimport org.biojava.bio.symbol.SimpleGappedSymbolList;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\nimport org.biojava.utils.ChangeEvent;\nimport org.biojava.utils.ChangeSupport;\nimport org.biojava.utils.ChangeVetoException;\n\n/**\n * <p>\n * FlexibleAlignment is a class which implements UnequalLengthAlignment,\n * ARAlignment and EditableAlignment <b>It places no restriction on where any\n * sequence can be in the alignment so there could be gaps in the alignment. You\n * tell it where to put the sequence, it will do it. I think I will be adding an\n * Exception NonContinuousAlignmentException. STILL UNDER CONSTRUCTION.\n * seqString does not work because there it does not seem to support\n * tokenization 'token' this is true for SimpleAlignment too.</b>\n * \n * @author David Waring\n * @author Matthew Pocock\n */\npublic class FlexibleAlignment extends AbstractULAlignment implements\n\t\tARAlignment, EditableAlignment {\n\n\tprotected Map<Object, AlignmentElement> data;\n\tprotected List<String> labelOrder;\n\tprotected Location alignmentRange;\n\tList<Alphabet> alphaList = new ArrayList<Alphabet>();\n\n\t/**\n\t * construct this object with the reference sequence which can either be a\n\t * gappedSymbolList or not label in all cases refers to an object that holds\n\t * the display name (generally just a String). since more than one sequence\n\t * in an alignment could have the same name this works as long as the labels\n\t * are different objects even though they may hold the same name.\n\t */\n\n\tpublic FlexibleAlignment(List<AlignmentElement> seqList)\n\t\t\tthrows BioException {\n\t\tdata = new Hashtable<Object, AlignmentElement>();\n\t\tlabelOrder = new Vector<String>();\n\t\talignmentRange = new RangeLocation(1, 1);\n\n\t\tint k = 0;\n\t\t// go through the list make sure that all seqs are GappedSymbolLists\n\t\tfor (Iterator<AlignmentElement> i = seqList.iterator(); i.hasNext();) {\n\t\t\tAlignmentElement ae = i.next();\n\t\t\tString label = ae.getLabel();\n\t\t\tLocation loc = ae.getLoc();\n\t\t\tSymbolList seq = ae.getSymbolList();\n\t\t\talphaList.add(seq.getAlphabet());\n\t\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t\t}\n\t\t\tdata.put(label, ae);\n\t\t\tlabelOrder.add(label);\n\t\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\t\talignmentRange = new RangeLocation(min, max);\n\t\t\tk++;\n\t\t}\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\ttry {\n\t\t\tresetRange();\n\t\t} catch (ChangeVetoException e) {\n\t\t\tthrow new BioError(\"Should not have a problem here\");\n\t\t}\n\n\t}\n\n\tprivate int getOrder(Object label) throws Exception {\n\t\tfor (int i = 0; i < labelOrder.size(); i++) {\n\t\t\tif (labelOrder.get(i).equals(label))\n\t\t\t\treturn i;\n\t\t}\n\t\tthrow new Exception(\"did not find label\");\n\t}\n\n\t/**\n\t * add a new a alignment usings a location to the reference sequence. This\n\t * should either contain no gaps or it should be relative to a reference\n\t * sequence that already has the gaps added\n\t */\n\n\tpublic synchronized void addSequence(AlignmentElement ae)\n\t\t\tthrows ChangeVetoException, BioException {\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\tString label = ae.getLabel();\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation loc = ae.getLoc();\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.ADD_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.ADD_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\tif (!(seq instanceof GappedSymbolList)) {\n\t\t\tseq = new SimpleGappedSymbolList(seq);\n\t\t\tae = new SimpleAlignmentElement(label, seq, loc);\n\t\t}\n\t\tdata.put(label, ae);\n\t\tlabelOrder.add(label);\n\t\talphaList.add(seq.getAlphabet());\n\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\n\t\tint min = lesser(alignmentRange.getMin(), loc.getMin());\n\t\tint max = greater(alignmentRange.getMax(), loc.getMax());\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tresetRange();\n\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\tpublic synchronized void removeSequence(Object label)\n\t\t\tthrows ChangeVetoException {\n\n\t\tChangeSupport cs;\n\t\tChangeEvent cevt;\n\n\t\t// give the listeners a change to veto this\n\t\t// create a new change event ->the EDIT is a static final variable of\n\t\t// type ChangeType in SymbolList interface\n\t\tcevt = new ChangeEvent(this, ARAlignment.REMOVE_LABEL, label);\n\t\tcs = getChangeSupport(ARAlignment.REMOVE_LABEL);\n\n\t\t// let the listeners know what we want to do\n\t\tcs.firePreChangeEvent(cevt);\n\t\ttry {\n\t\t\talphaList.remove(getOrder(label));\n\t\t\tthis.alphabet = AlphabetManager.getCrossProductAlphabet(alphaList);\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tdata.remove(label);\n\t\tlabelOrder.remove(label);\n\t\tresetRange();\n\t\tcs.firePostChangeEvent(cevt);\n\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface UnequalLengthAlignment\n\t// ///////////////////////\n\n\t/**\n\t * The location of an individual SymbolList relative to overall Alignment\n\t */\n\tpublic Location locInAlignment(Object label) throws NoSuchElementException {\n\t\treturn getAE(label).getLoc();\n\t}\n\n\tpublic List<Object> getLabelsAt(int column)\n\t\t\tthrows IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length())\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\tList<Object> labelList = new ArrayList<Object>();\n\t\tLocation loc;\n\t\tObject label;\n\t\tfor (Iterator<Object> labelIterator = data.keySet().iterator(); labelIterator\n\t\t\t\t.hasNext();) {\n\t\t\tlabel = labelIterator.next();\n\t\t\tloc = getAE(label).getLoc();\n\t\t\tif (loc.contains(column))\n\t\t\t\tlabelList.add(label);\n\t\t}\n\t\treturn labelList;\n\t}\n\n\t// ///////////////////////\n\t// methods from Interface Alignment\n\t// //////////////////////\n\n\tpublic synchronized int length() {\n\t\treturn alignmentRange.getMax() - alignmentRange.getMin() + 1;\n\t}\n\n\tpublic Alphabet getAlphabet() {\n\t\treturn alphabet;\n\t}\n\n\t/**\n\t * getLabels will return a list of labels in left to right order\n\t */\n\n\tpublic synchronized List<String> getLabels() {\n\t\tTreeSet<String> sorted = new TreeSet<String>(\n\t\t\t\tnew LeftRightLocationComparator<String>());\n\t\tsorted.addAll(labelOrder);\n\t\treturn new Vector<String>(sorted);\n\t}\n\n\t/**\n\t * This gets the symbol for an individual sequence at position in the\n\t * overall alignment If the sequence is not aligned at that location it\n\t * returns null\n\t */\n\n\tpublic synchronized Symbol symbolAt(String label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\n\t\tSymbolList seq = symbolListForLabel(label);\n\t\tint cloc = posInSeq(label, column);\n\t\tSymbol symbol = null;\n\t\t// debug (label.toString() + \" \" + column + \":\" + cloc);\n\t\tif (seq == null) {\n\t\t\t// debug(\"seq is null\");\n\t\t}\n\n\t\ttry {\n\t\t\tsymbol = seq.symbolAt(cloc);\n\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t// leave symbol == null\n\t\t}\n\t\treturn symbol;\n\t}\n\n\tpublic synchronized SymbolList symbolListForLabel(Object label)\n\t\t\tthrows NoSuchElementException {\n\t\treturn getAE(label).getSymbolList();\n\t}\n\n\t// methods from interface EditableAlignment\n\n\tpublic synchronized void edit(Object label, Edit edit)\n\t\t\tthrows ChangeVetoException {\n\t\tthrow new BioError(\"Not implemented yet\");\n\t}\n\n\t/**\n\t * loc in this case is the Alignment Location\n\t */\n\tpublic synchronized void shiftAtAlignmentLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tLocation sourceLoc = locInSeq(label, loc);\n\t\tshiftAtSequenceLoc(label, sourceLoc, offset);\n\n\t}\n\n\t/**\n\t * loc in this case is the SymbolList Location\n\t */\n\tpublic synchronized void shiftAtSequenceLoc(Object label, Location loc,\n\t\t\tint offset) throws ChangeVetoException,\n\t\t\tIllegalAlignmentEditException, IndexOutOfBoundsException {\n\n\t\tChangeSupport csgap;\n\t\tChangeEvent cegap;\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tcegap = new ChangeEvent(this, EditableAlignment.GAPS, label);\n\t\tcsgap = getChangeSupport(EditableAlignment.GAPS);\n\n\t\tint caseValue = 0;\n\t\tint absOffset = Math.abs(offset);\n\t\tLocation seqLoc = locInAlignment(label);\n\t\tAlignmentElement ae = getAE(label);\n\t\tSymbolList seq = ae.getSymbolList();\n\t\tLocation newLoc;\n\t\tint min = loc.getMin();\n\t\tint max = loc.getMax();\n\t\tif (min < 1 || max > seq.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif (offset == 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (offset > 1)\n\t\t\tcaseValue += 1;\n\t\tif (min == 1)\n\t\t\tcaseValue += 2;\n\t\tif (max == seq.length())\n\t\t\tcaseValue += 4;\n\n\t\tswitch (caseValue) {\n\n\t\tcase 0: // internal shift to left\n\t\t\tif (!allGaps(seq, min + offset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 1: // internal shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 2: // left end shift to left\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(max + 1, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() - absOffset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 3: // left end shift to right\n\t\t\tif (!allGaps(seq, max + 1, max + offset)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, max + 1, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin() + offset, seqLoc\n\t\t\t\t\t.getMax());\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 4: // right end shift to left\n\t\t\tif (!allGaps(seq, min - absOffset, min - 1)) {\n\t\t\t\tthrow new IllegalAlignmentEditException();\n\t\t\t}\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\tremoveGaps((GappedSymbolList) seq, min - absOffset, absOffset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 5: // right end shift to right\n\t\t\tcsgap.firePreChangeEvent(cegap);\n\t\t\tcsloc.firePreChangeEvent(celoc);\n\t\t\t((GappedSymbolList) seq).addGapsInView(min, offset);\n\t\t\tnewLoc = new RangeLocation(seqLoc.getMin(), seqLoc.getMax()\n\t\t\t\t\t+ offset);\n\t\t\tae.setLoc(newLoc);\n\t\t\tresetRange();\n\t\t\tcsloc.firePostChangeEvent(celoc);\n\t\t\tcsgap.firePostChangeEvent(cegap);\n\t\t\tbreak;\n\n\t\tcase 6: // whole seq shift to left\n\t\t\tdebug(\"Shifting all to left \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tcase 7: // whole seq shift to right\n\t\t\tdebug(\"Shifting all to right \" + absOffset);\n\t\t\tshift(label, offset);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdebug(\"OOOPS something is wrong \" + loc.toString() + \" \"\n\t\t\t\t\t+ absOffset);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * because there is a bug in GappedSymbolList\n\t */\n\n\tpublic synchronized void removeGaps(GappedSymbolList seq, int start,\n\t\t\tint length) {\n\t\ttry {\n\t\t\t// seq.removeGaps (start , length);\n\t\t\t// because there is a bug in GappedSymbolList we do it one at a time\n\t\t\tfor (int i = 1; i <= length; i++) {\n\t\t\t\tseq.removeGap(start);\n\t\t\t}\n\t\t} catch (IllegalSymbolException e) {\n\t\t\tthrow new BioError(\"We should have tested for this already\");\n\t\t}\n\t}\n\n\t/**\n\t * make sure that all Symbols in this range are gaps\n\t */\n\n\tprotected synchronized boolean allGaps(SymbolList seq, int start, int end) {\n\n\t\tSymbol gs = seq.getAlphabet().getGapSymbol();\n\t\tfor (int i = start; i <= end; i++) {\n\t\t\tif (!(seq.symbolAt(i).equals(gs))) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * check that begining is at 1 otherwise shift everything over\n\t */\n\tprotected synchronized void resetRange() throws ChangeVetoException {\n\n\t\tint min = 0;// just for the compiler\n\t\tint max = 0;// just for the compiler\n\t\tint lMin;\n\t\tint lMax;\n\t\tint count = 1;\n\t\t// get the current range from all labels\n\t\tfor (Iterator<String> i = getLabels().iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tlMin = locInAlignment(label).getMin();\n\t\t\tlMax = locInAlignment(label).getMax();\n\t\t\tif (count == 1) {\n\t\t\t\tmin = lMin;\n\t\t\t} else {\n\t\t\t\tmin = lesser(min, lMin);\n\t\t\t}\n\t\t\tif (count == 1) {\n\t\t\t\tmax = lMax;\n\t\t\t} else {\n\t\t\t\tmax = greater(max, lMax);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\talignmentRange = new RangeLocation(min, max);\n\t\tif (min != 1) {\n\t\t\tint offset = 1 - alignmentRange.getMin();\n\t\t\tshiftAll(offset);\n\t\t\talignmentRange = new RangeLocation(\n\t\t\t\t\talignmentRange.getMin() + offset, alignmentRange.getMax()\n\t\t\t\t\t\t\t+ offset);\n\t\t}\n\t}\n\n\tprotected synchronized void shiftAll(int offset) throws ChangeVetoException {\n\t\tList<String> lList = getLabels();\n\t\tfor (Iterator<String> i = lList.iterator(); i.hasNext();) {\n\t\t\tObject label = i.next();\n\t\t\tshift(label, offset);\n\t\t}\n\t}\n\n\t/**\n\t * moves the whole sequence\n\t */\n\n\tprotected synchronized void shift(Object label, int offset)\n\t\t\tthrows ChangeVetoException {\n\t\tChangeSupport csloc;\n\t\tChangeEvent celoc;\n\t\tceloc = new ChangeEvent(this, EditableAlignment.LOCATION, label);\n\t\tcsloc = getChangeSupport(EditableAlignment.LOCATION);\n\t\tLocation oLoc = locInAlignment(label);\n\t\tLocation nLoc = new RangeLocation(oLoc.getMin() + offset, oLoc.getMax()\n\t\t\t\t+ offset);\n\t\tcsloc.firePreChangeEvent(celoc);\n\t\tdebug(\"shifting \" + label.toString());\n\t\tgetAE(label).setLoc(nLoc);\n\t\tresetRange();\n\t\tdebug(\"shifted \" + label);\n\t\tcsloc.firePostChangeEvent(celoc);\n\t}\n\n\t// utility methods\n\tprotected int greater(int x, int y) {\n\t\tint greatest = (x > y) ? x : y;\n\t\treturn greatest;\n\t}\n\n\tprotected int lesser(int x, int y) {\n\t\tint least = (x < y) ? x : y;\n\t\treturn least;\n\t}\n\n\tprotected AlignmentElement getAE(Object label)\n\t\t\tthrows NoSuchElementException {\n\t\tif (!(data.containsKey(label)))\n\t\t\t;\n\t\treturn data.get(label);\n\t}\n\n\t/**\n\t * get the position in the sequence corresponding to the postion within the\n\t * alignment\n\t */\n\n\tprotected synchronized int posInSeq(Object label, int column)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tif (column < 1 || column > this.length()) {\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tLocation loc = locInAlignment(label);\n\t\treturn (column - loc.getMin() + 1);\n\t}\n\n\tprotected synchronized Location locInSeq(Object label, Location viewLoc)\n\t\t\tthrows NoSuchElementException, IndexOutOfBoundsException {\n\t\tint min = posInSeq(label, viewLoc.getMin());\n\t\tint max = posInSeq(label, viewLoc.getMax());\n\t\treturn new RangeLocation(min, max);\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n */\n\n\npackage org.biojava.bio.alignment;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.GappedSequence;\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.symbol.BasisSymbol;\nimport org.biojava.bio.symbol.LocationTools;\n\n/* @author Lachlan Coin */\npublic class FlexibleAlignmentTest extends TestCase {\n\n  public FlexibleAlignmentTest(String name){\n    super(name);\n  }\n\n    //public static void main(String[] args) throws Exception{\n    //\tFlexibleAlignmentTest aat = new FlexibleAlignmentTest();\n    //\taat.setUp();\n    //\taat.testDNA();\n    //\taat.testProtein();\n    //}\n\n\n    final static String[] alignment = new String[] {\"A-C\",\n                                       \"AGC\",\n                                       \"A-A\"};\n\n\n    final static String[] names = new String[] {\"MOUSE\", \"HUMAN\",\"SCHPO\"};\n\n    final static FlexibleAlignment alignDNA = parse(names, alignment, true);\n    final static FlexibleAlignment alignProt = parse(names, alignment, false);\n\n    protected void setUp() throws Exception{\n\n    }\n\n\n  public void testDNA()\n      throws Exception\n  {\n      List syms = ((BasisSymbol) alignDNA.symbolAt(2)).getSymbols();\n      assertEquals(syms.get(0), DNATools.getDNA().getGapSymbol());\n      assertEquals(syms.get(1), DNATools.g());\n  }\n\n\n  public void testProtein()\n      throws Exception\n  {\n      List syms = ((BasisSymbol) alignProt.symbolAt(2)).getSymbols();\n      assertEquals(syms.get(0), ProteinTools.getAlphabet().getGapSymbol());\n  }\n\n\n\n    private static FlexibleAlignment parse(String[] names, String[] alignment, boolean dna)\n    {\n        try\n        {\n            List sequences = new ArrayList();\n            for(int i=0; i<alignment.length; i++)\n            {\n                GappedSequence seq;\n                if(dna)\n                    seq = DNATools.createGappedDNASequence(alignment[i],names[i]);\n                else\n                    seq = ProteinTools.createGappedProteinSequence(alignment[i],names[i]);\n                AlignmentElement ae = new SimpleAlignmentElement(names[i], seq, LocationTools.makeLocation(1, alignment[i].length()));\n                //         System.out.println(seq.seqString());\n                sequences.add(ae);\n            }\n            FlexibleAlignment al = new FlexibleAlignment(sequences);\n            return al;\n        }\n        catch (Throwable t)\n        {\n            t.printStackTrace();\n            //System.exit(0);\n            return null;\n        }\n    }\n\n\n\n}\n","changedTest":"","commitMessage":"Introduced generic type arguments.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7594 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}