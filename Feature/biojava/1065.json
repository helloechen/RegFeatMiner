{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/GenbankWriter.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/GenbankWriterTest.java","prod_time":"2022-10-18 22:31:09","test_time":"2024-05-15 23:59:58","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"6365b6b2034239df25bbbd1de2564d4f4bafd2af","test_commitID":"1ae6b52630282eba2079b5764218f5420c1b12b5","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.io.template.GenbankHeaderFormatInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.StringManipulationHelper;\n\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\n\tint SEQUENCE_INDENT = 9;\n\n\tOutputStream os;\n\tCollection<S> sequences;\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\n\tprivate int lineLength = 60;\n\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\n\t/**\n\t * Use default line length of 60\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t */\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\n\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t}\n\n\t/**\n\t * Set custom lineLength\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t * @param lineLength\n\t */\n\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t\tthis.lineLength = lineLength;\n\t}\n\n\t/**\n\t * Allow an override of operating system line separator for programs that\n\t * needs a specific CRLF or CR or LF option\n\t *\n\t * @param lineSeparator\n\t */\n\n\tpublic void process() throws Exception {\n\t\t// Loosely based on code from Howard Salis\n\t\t// TODO - Force lower case?\n\t\t// boolean closeit = false;\n\t\tPrintWriter writer = new PrintWriter(os);\n\t\tfor (S sequence : sequences) {\n\t\t\tString header = headerFormat.getHeader(sequence);\n\t\t\twriter.print(header);\n\t\t\twriter.println();\n\t\t\t// os.write(lineSep);\n\t\t\t\n\t\t\t/*\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\n\t\t\t * the length, and there is no need #to record a long sequence of\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\n\t\t\t * return\n\t\t\t */\n\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\n\t\t\tint seq_len = data.length();\n\t\t\twriter.println(\"ORIGIN\");\n\t\t\t// os.write(lineSep);\n\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\n\t\t\t\t\tif ((words + 10) > data.length()) {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// os.write(lineSep);\n\t\t\t\twriter.println();\n\t\t\t}\n\n\t\t\twriter.println(\"//\");\n\n\t\t}\n\n\t\twriter.flush();\n\n\t}\n\n\t/**\n\t * @return the lineLength\n\t */\n\tpublic int getLineLength() {\n\t\treturn lineLength;\n\t}\n\n\t/**\n\t * @param lineLength\n\t *            the lineLength to set\n\t */\n\tpublic void setLineLength(int lineLength) {\n\t\tthis.lineLength = lineLength;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.io.template.GenbankHeaderFormatInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.biojava.nbio.core.util.StringManipulationHelper;\n\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriter<S extends Sequence<?>, C extends Compound> {\n\tint SEQUENCE_INDENT = 9;\n\n\tOutputStream os;\n\tCollection<S> sequences;\n\tGenbankHeaderFormatInterface<S, C> headerFormat;\n\tprivate int lineLength = 60;\n\n\t// byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\n\t/**\n\t * Use default line length of 60\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t */\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat) {\n\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t}\n\n\t/**\n\t * Set custom lineLength\n\t *\n\t * @param os\n\t * @param sequences\n\t * @param headerFormat\n\t * @param lineLength\n\t */\n\n\tpublic GenbankWriter(OutputStream os, Collection<S> sequences,\n\t\t\tGenbankHeaderFormatInterface<S, C> headerFormat, int lineLength) {\n\t\tthis.os = os;\n\t\tthis.sequences = sequences;\n\t\tthis.headerFormat = headerFormat;\n\t\tthis.lineLength = lineLength;\n\t}\n\n\t/**\n\t * Allow an override of operating system line separator for programs that\n\t * needs a specific CRLF or CR or LF option\n\t *\n\t * @param lineSeparator\n\t */\n\n\tpublic void process() throws Exception {\n\t\t// Loosely based on code from Howard Salis\n\t\t// TODO - Force lower case?\n\t\t// boolean closeit = false;\n\t\tPrintWriter writer = new PrintWriter(os);\n\t\tfor (S sequence : sequences) {\n\t\t\tString header = headerFormat.getHeader(sequence);\n\t\t\twriter.print(header);\n\t\t\twriter.println();\n\t\t\t// os.write(lineSep);\t\t\t\n\t\t\t/*\n\t\t\t * if isinstance(record.seq, UnknownSeq): #We have already recorded\n\t\t\t * the length, and there is no need #to record a long sequence of\n\t\t\t * NNNNNNN...NNN or whatever. if \"contig\" in record.annotations:\n\t\t\t * self._write_contig(record) else: self.handle.write(\"ORIGIN\\n\")\n\t\t\t * return\n\t\t\t */\n\n\t\t\tString data = sequence.getSequenceAsString().toLowerCase();\n\t\t\tint seq_len = data.length();\n\t\t\twriter.println(\"ORIGIN\");\n\t\t\t// os.write(lineSep);\n\n\t\t\tfor (int line_number = 0; line_number < seq_len; line_number += lineLength) {\n\t\t\t\twriter.print(StringManipulationHelper.padLeft(\n\t\t\t\t\t\tInteger.toString(line_number + 1), SEQUENCE_INDENT));\n\t\t\t\tfor (int words = line_number; words < Math.min(line_number\n\t\t\t\t\t\t+ lineLength, seq_len); words += 10) {\n\t\t\t\t\tif ((words + 10) > data.length()) {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriter.print((\" \" + data.substring(words, words + 10)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// os.write(lineSep);\n\t\t\t\twriter.println();\n\t\t\t}\n\n\t\t\twriter.println(\"//\");\n\n\t\t}\n\n\t\twriter.flush();\n\n\t}\n\n\t/**\n\t * @return the lineLength\n\t */\n\tpublic int getLineLength() {\n\t\treturn lineLength;\n\t}\n\n\t/**\n\t * @param lineLength\n\t *            the lineLength to set\n\t */\n\tpublic void setLineLength(int lineLength) {\n\t\tthis.lineLength = lineLength;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\n\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.features.AbstractFeature;\nimport org.biojava.nbio.core.sequence.features.DBReferenceInfo;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\nimport org.biojava.nbio.core.sequence.features.TextFeature;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriterTest {\n\n\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\n\t\tLinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\n\t\tfor(DNASequence seq : dnaSequences.values()) {\n\t\t\tseqs.add(seq);\n\t\t}\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\t//System.out.println(fragwriter.toString());\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\t/**\n\t\t * Hello Jacek\n\t\t * can you please investigate why this test fails? it seems that\n\t\t * fragreader at the line below is read with the last feature\n\t\t * in an invalid state: location = 2005..2004\n\t\t */\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\n\t\tfragwriter.close();\n\t\tAssert.assertEquals(seqs.get(0).getSequenceAsString(), dnaSequences.values().iterator().next().getSequenceAsString());\n\t}\n\t\n\t/**\n\t * String Formatter error when key or value of Qualifier has character \"%\"\n\t * https://github.com/biojava/biojava/issues/886\n\t */\n\t@Test\n\tpublic void testGithub886() throws Exception {\n\t\t\n\t\tDNASequence seq = new DNASequence(\"ATGC\");\n\t\tseq.setAccession(new AccessionID(\".\"));\n\t\tAbstractFeature feature = new TextFeature(\"CDS\", \"source\", \"short description\", \"description\");\n\t\tfeature.setLocation(new SimpleLocation(1, 10, Strand.POSITIVE));\n\n\t\t// no percent symbols in key or value\n\t\tfeature.addQualifier(\"note1\", new Qualifier(\"note1\", \"50\", true));\n\t\t// percent symbol in key\n\t\tfeature.addQualifier(\"note2\", new Qualifier(\"%note2\", \"50\", true));\n\t\tfeature.addQualifier(\"note3\", new Qualifier(\"not%e3\", \"50\", true));\n\t\tfeature.addQualifier(\"note4\", new Qualifier(\"note4%\", \"50\", true));\n\t\t// percent symbol in value\n\t\tfeature.addQualifier(\"note5\", new Qualifier(\"note5\", \"%50\", true));\n\t\tfeature.addQualifier(\"note6\", new Qualifier(\"note6\", \"5%0\", true));\n\t\tfeature.addQualifier(\"note7\", new Qualifier(\"note7\", \"50%\", true));\n\t\t\n\t\tseq.addFeature(feature);\n\t\t\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequence(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(seq), \n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\tfragwriter.close();\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\t\t\n\t\t// now read in the file that was created and check that the qualifiers were created correctly\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSeq = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\tAbstractFeature newFeature = (TextFeature) seq.getFeaturesByType(\"CDS\").get(0);\n\t\tMap<String, List<Qualifier>> newQualifiers = newFeature.getQualifiers();\n\t\t\n\t\tassertEquals(\"note1\", newQualifiers.get(\"note1\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note1\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"%note2\", newQualifiers.get(\"note2\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note2\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"not%e3\", newQualifiers.get(\"note3\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note3\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note4%\", newQualifiers.get(\"note4\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note4\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note5\", newQualifiers.get(\"note5\").get(0).getName());\n\t\tassertEquals(\"%50\", newQualifiers.get(\"note5\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note6\", newQualifiers.get(\"note6\").get(0).getName());\n\t\tassertEquals(\"5%0\", newQualifiers.get(\"note6\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note7\", newQualifiers.get(\"note7\").get(0).getName());\n\t\tassertEquals(\"50%\", newQualifiers.get(\"note7\").get(0).getValue());\n\t\t\n\t}\n\t\n\t@Test\n\tpublic void testLocationJoins() throws Exception {\n\t\t\n\t\t// First read a GenBank file containing location joins\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/with_joins.gb\");\n\t\tDNASequence sequence = GenbankReaderHelper.readGenbankDNASequence(inStream).values().iterator().next();\n\t\t\n\t\t// Check the joins are read correctly\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeatures();\n\t\t\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> join1 = features.get(0);\n\t\tList<Location> join1SubLocs = join1.getLocations().getSubLocations();\n\t\t\n\t\tassertEquals(\"join1, getType()\", \"CDS\", join1.getType());\n\t\tassertEquals(\"join1, getLocations().getStrand()\", \"POSITIVE\", join1.getLocations().getStrand().toString());\n\t\tassertEquals(\"join1, getLocations().getSubLocations().size()\", 6, join1SubLocs.size());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 1)\", 1, join1SubLocs.get(0).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 1)\", 1, join1SubLocs.get(0).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 2)\", 10, join1SubLocs.get(1).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 2)\", 12, join1SubLocs.get(1).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 3)\", 30, join1SubLocs.get(2).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 3)\", 30, join1SubLocs.get(2).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 3)\", 35, join1SubLocs.get(3).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 3)\", 38, join1SubLocs.get(3).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 5)\", 43, join1SubLocs.get(4).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 5)\", 46, join1SubLocs.get(4).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 6)\", 47, join1SubLocs.get(5).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 6)\", 50, join1SubLocs.get(5).getEnd().getPosition().intValue());\n\t\t\n\t\t//qualifiers\n\t\tassertEquals(\"join1, getType()\", \"Joined feature\", join1.getQualifiers().get(\"standard_name\").get(0).getValue());\n\t\t\n\t\t//Join 2\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> join2 = features.get(1);\n\t\tList<Location> join2SubLocs = join2.getLocations().getSubLocations();\n\t\t\n\t\tassertEquals(\"join2, getType()\", \"CDS\", join2.getType());\n\t\tassertEquals(\"join2, getLocations().getStrand()\", \"NEGATIVE\", join2.getLocations().getStrand().toString());\n\t\tassertEquals(\"join2, getLocations().getSubLocations().size()\", 5, join2SubLocs.size());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 1)\", 33, join2SubLocs.get(0).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 1)\", 33, join2SubLocs.get(0).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 2)\", 35, join2SubLocs.get(1).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 2)\", 37, join2SubLocs.get(1).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 3)\", 41, join2SubLocs.get(2).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 3)\", 43, join2SubLocs.get(2).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 4)\", 44, join2SubLocs.get(3).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 4)\", 46, join2SubLocs.get(3).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 5)\", 47, join2SubLocs.get(4).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 5)\", 50, join2SubLocs.get(4).getEnd().getPosition().intValue());\n\t\t\n\t\t//qualifiers\n\t\tassertEquals(\"join2, getType()\", \"Joined feature on complement\", join2.getQualifiers().get(\"standard_name\").get(0).getValue());\n\t\t\n\t\t// Now write the joins back to a file using the GenbankWriterHelper\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequenceOriginal(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(sequence));\n\t\tfragwriter.close();\n\t\t\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\t\t\n\t\t// Read the output file and test that no information is lost\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSequence = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\t\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> newFeatures = newSequence.getFeatures();\n\t\t\n\t\t// Check the output matches the original sequence feature\n\t\tfor (int i=0; i < features.size(); i++ ) {\n\t\t\tassertEquals(\"getFeatures(), getType()\", features.get(i).getType(), newFeatures.get(i).getType());\n\t\t\tassertEquals(\"getFeatures(), getStart()\", features.get(i).getLocations().getStart(), newFeatures.get(i).getLocations().getStart());\n\t\t\tassertEquals(\"getFeatures(), getEnd()\", features.get(i).getLocations().getEnd(), newFeatures.get(i).getLocations().getEnd());\n\t\t\tassertEquals(\"getFeatures(), getStrand()\", features.get(i).getLocations().getStrand(), newFeatures.get(i).getLocations().getStrand());\n\n\t\t\tList<Location> subLocations = features.get(i).getLocations().getSubLocations();\n\t\t\tList<Location> newSubLocations = newFeatures.get(i).getLocations().getSubLocations();\n\t\t\tassertEquals(\"getSubLocations()\", subLocations.size(), newSubLocations.size());\n\t\tfor (int j=0; j < subLocations.size(); j++ ) {\n\t\t\t\tassertEquals(\"getSubLocations(), getStart()\",  subLocations.get(j).getStart(), newSubLocations.get(j).getStart());\n\t\t\t\tassertEquals(\"getSubLocations(), getEnd()\",    subLocations.get(j).getEnd(), newSubLocations.get(j).getEnd());\n\t\t\t\tassertEquals(\"getSubLocations(), getStrand()\", subLocations.get(j).getStrand(), newSubLocations.get(j).getStrand());\n\t\t\t}\n\t\t\t\n\t\t\tMap<String, List<Qualifier>> qualifiers = features.get(i).getQualifiers();\n\t\t\tMap<String, List<Qualifier>> newQualifiers = newFeatures.get(i).getQualifiers();\n\t\t\t\n\t\t\tfor (String qualifierType:  qualifiers.keySet()) {\n\t\t\t\tassertEquals(\"getSubLocations()\", qualifiers.get(qualifierType).get(0).getValue(), newQualifiers.get(qualifierType).get(0).getValue());\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Going from GenBank file -> DNASequence object -> GenBank file looses information\n\t * https://github.com/biojava/biojava/issues/942\n\t */\n\t@Test\n\tpublic void testGithub942() throws Exception {\n\t\t\n\t\t// Important information is lost when reading and writing a\n\t\t// GenBank file through GenbankReaderHelper & GenbankWriterHelper\n\n\t\t// First read the sample GenBank file from\n\t\t// https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html using the\n\t\t// GenbankReaderHelper\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\tDNASequence sequence = GenbankReaderHelper.readGenbankDNASequence(inStream).values().iterator().next();\n\n\t\t// Then write sequence back to a file using the GenbankWriterHelper\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequenceOriginal(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(sequence));\n\t\tfragwriter.close();\n\t\t\n\t\t// Test no important information is lost\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSequence = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\t\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\n\t\tassertEquals(\"getOriginalHeader()\", sequence.getOriginalHeader(), newSequence.getOriginalHeader());\n\t\tassertEquals(\"getLength()\", sequence.getLength(), newSequence.getLength());\n\t\tassertEquals(\"getAccession().getID()\", sequence.getAccession().getID(), newSequence.getAccession().getID());\n\t\tassertEquals(\"getAccession().getVersion()\", sequence.getAccession().getVersion(), newSequence.getAccession().getVersion());\n\t\tassertEquals(\"getDescription()\", sequence.getDescription(), newSequence.getDescription());\n\t\t//assertEquals(\"getSource()\", sequence.getSource(), newSequence.getSource());\n\t\t//assertEquals(\"getDNAType()\", sequence.getDNAType(), newSequence.getDNAType());\n\t\t//assertEquals(\"getTaxonomy()\", sequence.getTaxonomy(), newSequence.getTaxonomy());\t\t\n\t\t//assertEquals(\"getReferences()\", sequence.getReferences(), newSequence.getReferences());\n\t\t//assertEquals(\"getComments()\", sequence.getComments(), newSequence.getComments());\n\t\t//assertEquals(\"getNotesList()\", sequence.getNotesList(), newSequence.getNotesList());\n\t\t\n\t\t//Assuming the features will be in the same order\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeatures();\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> newFeatures = newSequence.getFeatures();\n\t\t\n\t\t//feature locations and qualifiers\n\t\tfor (int i=0; i < features.size(); i++ ) {\n\t\t\t\n\t\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature = features.get(i);\n\t\t\tLocation location           = feature.getLocations();\n\t\t\tList<Location> subLocations = location.getSubLocations();\n\t\t\tMap<String, List<Qualifier>> qualifiers  = feature.getQualifiers();\n\t\t\t\n\t\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> newFeature = newFeatures.get(i);\n\t\t\tLocation newLocation           = newFeature.getLocations();\n\t\t\tList<Location> newSubLocations = newLocation.getSubLocations();\n\t\t\tMap<String, List<Qualifier>> newQualifiers  = newFeature.getQualifiers();\n\t\t\t\n\t\t\tassertEquals(\"feature, getType()\",       feature.getType(),    newFeature.getType());\n\t\t\tassertEquals(\"feature, Location start\",  location.getStart(),  newLocation.getStart());\n\t\t\tassertEquals(\"feature, Location end\",    location.getEnd(),    newLocation.getEnd());\n\t\t\tassertEquals(\"feature, Location strand\", location.getStrand(), newLocation.getStrand());\n\t\t\tassertEquals(\"feature, sublocations\",    subLocations.size(),  newSubLocations.size());\n\t\t\t\n\t\t\tfor (int j=0; j < subLocations.size(); j++ ) {\n\t\t\t\tassertEquals(\"SubLocations, start\",  subLocations.get(j).getStart(),  newSubLocations.get(j).getStart());\n\t\t\t\tassertEquals(\"SubLocations, end\",    subLocations.get(j).getEnd(),    newSubLocations.get(j).getEnd());\n\t\t\t\tassertEquals(\"SubLocations, strand\", subLocations.get(j).getStrand(), newSubLocations.get(j).getStrand());\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tassertEquals(\"getQualifiers()\", qualifiers.size(), newQualifiers.size());\n\t\t\t\n\t\t\tfor (String qualifierType: qualifiers.keySet()) {\n\t\t\t\t\n\t\t\t\tList<Qualifier> qualifier   = new ArrayList<Qualifier>(qualifiers.get(qualifierType));\n\t\t\t\tList<Qualifier> newQualifier = new ArrayList<Qualifier>(newQualifiers.get(qualifierType));\n\t\t\t\t\n\t\t\t\tassertEquals(\"getQualifiers()\", qualifier.size(), newQualifier.size());\n\t\t\t\t\n\t\t\t\tfor (int k=0; k < qualifier.size(); k++) {\n\t\t\t\t\tif (qualifier.get(k) instanceof DBReferenceInfo) {\n\t\t\t\t\t\tDBReferenceInfo dbxref = (DBReferenceInfo) qualifier.get(k);\n\t\t\t\t\t\tDBReferenceInfo newDbxref = (DBReferenceInfo) newQualifier.get(k);\n\t\t\t\t\t\tassertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getDatabase(), newDbxref.getDatabase());\n\t\t\t\t\t\tassertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getId(), newDbxref.getId());\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"getQualifiers()\", qualifier.get(k).getValue(), newQualifier.get(k).getValue());\n\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tassertEquals(\"getSequenceAsString()\", sequence.getSequenceAsString(), newSequence.getSequenceAsString());\n\t\t\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\n\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.features.AbstractFeature;\nimport org.biojava.nbio.core.sequence.features.DBReferenceInfo;\nimport org.biojava.nbio.core.sequence.features.FeatureInterface;\nimport org.biojava.nbio.core.sequence.features.Qualifier;\nimport org.biojava.nbio.core.sequence.features.TextFeature;\nimport org.biojava.nbio.core.sequence.location.SimpleLocation;\nimport org.biojava.nbio.core.sequence.location.template.Location;\nimport org.biojava.nbio.core.sequence.template.AbstractSequence;\nimport org.biojava.nbio.core.sequence.Strand;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * @author mckeee1\n *\n */\npublic class GenbankWriterTest {\n\n\n\t@Test\n\tpublic void testProcess() throws Exception {\n\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\t//File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\n\t\tMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence( inStream );\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tArrayList<DNASequence> seqs = new ArrayList<DNASequence>();\n\t\tfor(DNASequence seq : dnaSequences.values()) {\n\t\t\tseqs.add(seq);\n\t\t}\n\t\tGenbankWriterHelper.writeNucleotideSequence(fragwriter, seqs,\n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\t//System.out.println(fragwriter.toString());\n\t\tByteArrayInputStream fragreader = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\t/**\n\t\t * Hello Jacek\n\t\t * can you please investigate why this test fails? it seems that\n\t\t * fragreader at the line below is read with the last feature\n\t\t * in an invalid state: location = 2005..2004\n\t\t */\n\t\t//dnaSequences = GenbankReaderHelper.readGenbankDNASequence( fragreader );\n\t\tfragwriter.close();\n\t\tAssert.assertEquals(seqs.get(0).getSequenceAsString(), dnaSequences.values().iterator().next().getSequenceAsString());\n\t}\n\t\n\t/**\n\t * String Formatter error when key or value of Qualifier has character \"%\"\n\t * https://github.com/biojava/biojava/issues/886\n\t */\n\t@Test\n\tpublic void testGithub886() throws Exception {\n\t\t\n\t\tDNASequence seq = new DNASequence(\"ATGC\");\n\t\tseq.setAccession(new AccessionID(\".\"));\n\t\tAbstractFeature feature = new TextFeature(\"CDS\", \"source\", \"short description\", \"description\");\n\t\tfeature.setLocation(new SimpleLocation(1, 10, Strand.POSITIVE));\n\n\t\t// no percent symbols in key or value\n\t\tfeature.addQualifier(\"note1\", new Qualifier(\"note1\", \"50\", true));\n\t\t// percent symbol in key\n\t\tfeature.addQualifier(\"note2\", new Qualifier(\"%note2\", \"50\", true));\n\t\tfeature.addQualifier(\"note3\", new Qualifier(\"not%e3\", \"50\", true));\n\t\tfeature.addQualifier(\"note4\", new Qualifier(\"note4%\", \"50\", true));\n\t\t// percent symbol in value\n\t\tfeature.addQualifier(\"note5\", new Qualifier(\"note5\", \"%50\", true));\n\t\tfeature.addQualifier(\"note6\", new Qualifier(\"note6\", \"5%0\", true));\n\t\tfeature.addQualifier(\"note7\", new Qualifier(\"note7\", \"50%\", true));\n\t\t\n\t\tseq.addFeature(feature);\n\t\t\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequence(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(seq), \n\t\t\t\tGenbankWriterHelper.LINEAR_DNA);\n\t\tfragwriter.close();\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\t\t\n\t\t// now read in the file that was created and check that the qualifiers were created correctly\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSeq = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\tAbstractFeature newFeature = (TextFeature) seq.getFeaturesByType(\"CDS\").get(0);\n\t\tMap<String, List<Qualifier>> newQualifiers = newFeature.getQualifiers();\n\t\t\n\t\tassertEquals(\"note1\", newQualifiers.get(\"note1\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note1\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"%note2\", newQualifiers.get(\"note2\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note2\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"not%e3\", newQualifiers.get(\"note3\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note3\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note4%\", newQualifiers.get(\"note4\").get(0).getName());\n\t\tassertEquals(\"50\", newQualifiers.get(\"note4\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note5\", newQualifiers.get(\"note5\").get(0).getName());\n\t\tassertEquals(\"%50\", newQualifiers.get(\"note5\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note6\", newQualifiers.get(\"note6\").get(0).getName());\n\t\tassertEquals(\"5%0\", newQualifiers.get(\"note6\").get(0).getValue());\n\t\t\n\t\tassertEquals(\"note7\", newQualifiers.get(\"note7\").get(0).getName());\n\t\tassertEquals(\"50%\", newQualifiers.get(\"note7\").get(0).getValue());\n\t\t\n\t}\n\t\n\t@Test\n\tpublic void testLocationJoins() throws Exception {\n\t\t\n\t\t// First read a GenBank file containing location joins\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/with_joins.gb\");\n\t\tDNASequence sequence = GenbankReaderHelper.readGenbankDNASequence(inStream).values().iterator().next();\n\t\t\n\t\t// Check the joins are read correctly\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeatures();\n\t\t\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> join1 = features.get(0);\n\t\tList<Location> join1SubLocs = join1.getLocations().getSubLocations();\n\t\t\n\t\tassertEquals(\"join1, getType()\", \"CDS\", join1.getType());\n\t\tassertEquals(\"join1, getLocations().getStrand()\", \"POSITIVE\", join1.getLocations().getStrand().toString());\n\t\tassertEquals(\"join1, getLocations().getSubLocations().size()\", 6, join1SubLocs.size());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 1)\", 1, join1SubLocs.get(0).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 1)\", 1, join1SubLocs.get(0).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 2)\", 10, join1SubLocs.get(1).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 2)\", 12, join1SubLocs.get(1).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 3)\", 30, join1SubLocs.get(2).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 3)\", 30, join1SubLocs.get(2).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 3)\", 35, join1SubLocs.get(3).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 3)\", 38, join1SubLocs.get(3).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 5)\", 43, join1SubLocs.get(4).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 5)\", 46, join1SubLocs.get(4).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join1, SubLocation 6)\", 47, join1SubLocs.get(5).getStart().getPosition().intValue());\n\t\tassertEquals(\"join1, SubLocation 6)\", 50, join1SubLocs.get(5).getEnd().getPosition().intValue());\n\t\t\n\t\t//qualifiers\n\t\tassertEquals(\"join1, getType()\", \"Joined feature\", join1.getQualifiers().get(\"standard_name\").get(0).getValue());\n\t\t\n\t\t//Join 2\n\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> join2 = features.get(1);\n\t\tList<Location> join2SubLocs = join2.getLocations().getSubLocations();\n\t\t\n\t\tassertEquals(\"join2, getType()\", \"CDS\", join2.getType());\n\t\tassertEquals(\"join2, getLocations().getStrand()\", \"NEGATIVE\", join2.getLocations().getStrand().toString());\n\t\tassertEquals(\"join2, getLocations().getSubLocations().size()\", 5, join2SubLocs.size());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 1)\", 33, join2SubLocs.get(0).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 1)\", 33, join2SubLocs.get(0).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 2)\", 35, join2SubLocs.get(1).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 2)\", 37, join2SubLocs.get(1).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 3)\", 41, join2SubLocs.get(2).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 3)\", 43, join2SubLocs.get(2).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 4)\", 44, join2SubLocs.get(3).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 4)\", 46, join2SubLocs.get(3).getEnd().getPosition().intValue());\n\t\t\n\t\tassertEquals(\"join2, SubLocation 5)\", 47, join2SubLocs.get(4).getStart().getPosition().intValue());\n\t\tassertEquals(\"join2, SubLocation 5)\", 50, join2SubLocs.get(4).getEnd().getPosition().intValue());\n\t\t\n\t\t//qualifiers\n\t\tassertEquals(\"join2, getType()\", \"Joined feature on complement\", join2.getQualifiers().get(\"standard_name\").get(0).getValue());\n\t\t\n\t\t// Now write the joins back to a file using the GenbankWriterHelper\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequenceOriginal(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(sequence));\n\t\tfragwriter.close();\n\t\t\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\t\t\n\t\t// Read the output file and test that no information is lost\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSequence = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\t\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> newFeatures = newSequence.getFeatures();\n\t\t\n\t\t// Check the output matches the original sequence feature\n\t\tfor (int i=0; i < features.size(); i++ ) {\n\t\t\tassertEquals(\"getFeatures(), getType()\", features.get(i).getType(), newFeatures.get(i).getType());\n\t\t\tassertEquals(\"getFeatures(), getStart()\", features.get(i).getLocations().getStart(), newFeatures.get(i).getLocations().getStart());\n\t\t\tassertEquals(\"getFeatures(), getEnd()\", features.get(i).getLocations().getEnd(), newFeatures.get(i).getLocations().getEnd());\n\t\t\tassertEquals(\"getFeatures(), getStrand()\", features.get(i).getLocations().getStrand(), newFeatures.get(i).getLocations().getStrand());\n\n\t\t\tList<Location> subLocations = features.get(i).getLocations().getSubLocations();\n\t\t\tList<Location> newSubLocations = newFeatures.get(i).getLocations().getSubLocations();\n\t\t\tassertEquals(\"getSubLocations()\", subLocations.size(), newSubLocations.size());\n\t\tfor (int j=0; j < subLocations.size(); j++ ) {\n\t\t\t\tassertEquals(\"getSubLocations(), getStart()\",  subLocations.get(j).getStart(), newSubLocations.get(j).getStart());\n\t\t\t\tassertEquals(\"getSubLocations(), getEnd()\",    subLocations.get(j).getEnd(), newSubLocations.get(j).getEnd());\n\t\t\t\tassertEquals(\"getSubLocations(), getStrand()\", subLocations.get(j).getStrand(), newSubLocations.get(j).getStrand());\n\t\t\t}\n\t\t\t\n\t\t\tMap<String, List<Qualifier>> qualifiers = features.get(i).getQualifiers();\n\t\t\tMap<String, List<Qualifier>> newQualifiers = newFeatures.get(i).getQualifiers();\n\t\t\t\n\t\t\tfor (String qualifierType:  qualifiers.keySet()) {\n\t\t\t\tassertEquals(\"getSubLocations()\", qualifiers.get(qualifierType).get(0).getValue(), newQualifiers.get(qualifierType).get(0).getValue());\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\t/**\n\t * Going from GenBank file -> DNASequence object -> GenBank file looses information\n\t * https://github.com/biojava/biojava/issues/942\n\t */\n\t@Test\n\tpublic void testGithub942() throws Exception {\n\t\t\n\t\t// Important information is lost when reading and writing a\n\t\t// GenBank file through GenbankReaderHelper & GenbankWriterHelper\n\n\t\t// First read the sample GenBank file from\n\t\t// https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html using the\n\t\t// GenbankReaderHelper\n\t\tInputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n\t\tDNASequence sequence = GenbankReaderHelper.readGenbankDNASequence(inStream).values().iterator().next();\n\n\t\t// Then write sequence back to a file using the GenbankWriterHelper\n\t\tByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n\t\tGenbankWriterHelper.writeNucleotideSequenceOriginal(\n\t\t\t\tfragwriter, \n\t\t\t\tArrays.asList(sequence));\n\t\tfragwriter.close();\n\t\t\n\t\t// Test no important information is lost\n\t\tInputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n\t\tDNASequence newSequence = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n\t\t\n\t\t//System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n\n\t\tassertEquals(\"getOriginalHeader()\", sequence.getOriginalHeader(), newSequence.getOriginalHeader());\n\t\tassertEquals(\"getLength()\", sequence.getLength(), newSequence.getLength());\n\t\tassertEquals(\"getAccession().getID()\", sequence.getAccession().getID(), newSequence.getAccession().getID());\n\t\tassertEquals(\"getAccession().getVersion()\", sequence.getAccession().getVersion(), newSequence.getAccession().getVersion());\n\t\tassertEquals(\"getDescription()\", sequence.getDescription(), newSequence.getDescription());\n\t\t//assertEquals(\"getSource()\", sequence.getSource(), newSequence.getSource());\n\t\t//assertEquals(\"getDNAType()\", sequence.getDNAType(), newSequence.getDNAType());\n\t\t//assertEquals(\"getTaxonomy()\", sequence.getTaxonomy(), newSequence.getTaxonomy());\t\t\n\t\t//assertEquals(\"getReferences()\", sequence.getReferences(), newSequence.getReferences());\n\t\t//assertEquals(\"getComments()\", sequence.getComments(), newSequence.getComments());\n\t\t//assertEquals(\"getNotesList()\", sequence.getNotesList(), newSequence.getNotesList());\n\t\t\n\t\t//Assuming the features will be in the same order\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeatures();\n\t\tList<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> newFeatures = newSequence.getFeatures();\n\t\t\n\t\t//feature locations and qualifiers\n\t\tfor (int i=0; i < features.size(); i++ ) {\n\t\t\t\n\t\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature = features.get(i);\n\t\t\tLocation location           = feature.getLocations();\n\t\t\tList<Location> subLocations = location.getSubLocations();\n\t\t\tMap<String, List<Qualifier>> qualifiers  = feature.getQualifiers();\n\t\t\t\n\t\t\tFeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> newFeature = newFeatures.get(i);\n\t\t\tLocation newLocation           = newFeature.getLocations();\n\t\t\tList<Location> newSubLocations = newLocation.getSubLocations();\n\t\t\tMap<String, List<Qualifier>> newQualifiers  = newFeature.getQualifiers();\n\t\t\t\n\t\t\tassertEquals(\"feature, getType()\",       feature.getType(),    newFeature.getType());\n\t\t\tassertEquals(\"feature, Location start\",  location.getStart(),  newLocation.getStart());\n\t\t\tassertEquals(\"feature, Location end\",    location.getEnd(),    newLocation.getEnd());\n\t\t\tassertEquals(\"feature, Location strand\", location.getStrand(), newLocation.getStrand());\n\t\t\tassertEquals(\"feature, sublocations\",    subLocations.size(),  newSubLocations.size());\n\t\t\t\n\t\t\tfor (int j=0; j < subLocations.size(); j++ ) {\n\t\t\t\tassertEquals(\"SubLocations, start\",  subLocations.get(j).getStart(),  newSubLocations.get(j).getStart());\n\t\t\t\tassertEquals(\"SubLocations, end\",    subLocations.get(j).getEnd(),    newSubLocations.get(j).getEnd());\n\t\t\t\tassertEquals(\"SubLocations, strand\", subLocations.get(j).getStrand(), newSubLocations.get(j).getStrand());\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tassertEquals(\"getQualifiers()\", qualifiers.size(), newQualifiers.size());\n\t\t\t\n\t\t\tfor (String qualifierType: qualifiers.keySet()) {\n\t\t\t\t\n\t\t\t\tList<Qualifier> qualifier   = new ArrayList<Qualifier>(qualifiers.get(qualifierType));\n\t\t\t\tList<Qualifier> newQualifier = new ArrayList<Qualifier>(newQualifiers.get(qualifierType));\n\t\t\t\t\n\t\t\t\tassertEquals(\"getQualifiers()\", qualifier.size(), newQualifier.size());\n\t\t\t\t\n\t\t\t\tfor (int k=0; k < qualifier.size(); k++) {\n\t\t\t\t\tif (qualifier.get(k) instanceof DBReferenceInfo) {\n\t\t\t\t\t\tDBReferenceInfo dbxref = (DBReferenceInfo) qualifier.get(k);\n\t\t\t\t\t\tDBReferenceInfo newDbxref = (DBReferenceInfo) newQualifier.get(k);\n\t\t\t\t\t\tassertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getDatabase(), newDbxref.getDatabase());\n\t\t\t\t\t\tassertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getId(), newDbxref.getId());\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassertEquals(\"getQualifiers()\", qualifier.get(k).getValue(), newQualifier.get(k).getValue());\n\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tassertEquals(\"getSequenceAsString()\", sequence.getSequenceAsString(), newSequence.getSequenceAsString());\n\t\t\n\t}\n}\n","commitMessage":"formatting changes","test_commitMessage":"Fix issue s1319 Declarations should use Java collection interfaces on biojava-core\n","allZero":true}