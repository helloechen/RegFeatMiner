{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/geometry/SuperPositionQCP.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/geometry/TestSuperPositionQCP.java","prod_time":"2021-02-11 03:04:07","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e94f047cad95ccc1bf1acd4f6341f5569cf8a75c","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Usage:\n * <p>\n * The input consists of 2 Point3d arrays of equal length. The input coordinates\n * are not changed.\n *\n * <pre>\n *    Point3d[] x = ...\n *    Point3d[] y = ...\n *    SuperPositionQCP qcp = new SuperPositionQCP();\n *    qcp.set(x, y);\n * </pre>\n * <p>\n * or with weighting factors [0 - 1]]\n *\n * <pre>\n *    double[] weights = ...\n *    qcp.set(x, y, weights);\n * </pre>\n * <p>\n * For maximum efficiency, create a SuperPositionQCP object once and reuse it.\n * <p>\n * A. Calculate rmsd only\n *\n * <pre>\n * double rmsd = qcp.getRmsd();\n * </pre>\n * <p>\n * B. Calculate a 4x4 transformation (rotation and translation) matrix\n *\n * <pre>\n * Matrix4d rottrans = qcp.getTransformationMatrix();\n * </pre>\n * <p>\n * C. Get transformated points (y superposed onto the reference x)\n *\n * <pre>\n * Point3d[] ySuperposed = qcp.getTransformedCoordinates();\n * </pre>\n * <p>\n * Citations:\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2011) Reply to comment on: \"Fast\n * determination of the optimal rotation matrix for macromolecular\n * superpositions.\" Journal of Computational Chemistry 32(1):185-186.\n * [http://dx.doi.org/10.1002/jcc.21606]\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2010) \"Fast determination of the optimal\n * rotation matrix for macromolecular superpositions.\" Journal of Computational\n * Chemistry 31(7):1561-1563. [http://dx.doi.org/10.1002/jcc.21439]\n * <p>\n * Douglas L Theobald (2005) \"Rapid calculation of RMSDs using a\n * quaternion-based characteristic polynomial.\" Acta Crystallogr A\n * 61(4):478-480. [http://dx.doi.org/10.1107/S0108767305015266 ]\n * <p>\n * This is an adoption of the original C code QCProt 1.4 (2012, October 10) to\n * Java. The original C source code is available from\n * http://theobald.brandeis.edu/qcp/ and was developed by\n * <p>\n * Douglas L. Theobald Department of Biochemistry MS 009 Brandeis University 415\n * South St Waltham, MA 02453 USA\n * <p>\n * dtheobald@brandeis.edu\n * <p>\n * Pu Liu Johnson & Johnson Pharmaceutical Research and Development, L.L.C. 665\n * Stockton Drive Exton, PA 19341 USA\n * <p>\n * pliu24@its.jnj.com\n * <p>\n *\n * @author Douglas L. Theobald (original C code)\n * @author Pu Liu (original C code)\n * @author Peter Rose (adopted to Java)\n * @author Aleix Lafita (adopted to Java)\n */\npublic final class SuperPositionQCP extends SuperPositionAbstract {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SuperPositionQCP.class);\n\n\tprivate double evec_prec = 1E-6;\n\tprivate double eval_prec = 1E-11;\n\n\tprivate Point3d[] x;\n\tprivate Point3d[] y;\n\n\tprivate double[] weight;\n\tprivate double wsum;\n\n\tprivate Point3d[] xref;\n\tprivate Point3d[] yref;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n\t/**\n\t * Default constructor for the quaternion based superposition algorithm.\n\t *\n\t * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n\t */\n\tpublic SuperPositionQCP(boolean centered) {\n\t\tsuper(centered);\n\t}\n\n\t/**\n\t * Constructor with option to set the precision values.\n\t *\n\t * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n\t * @param evec_prec\n\t *            required eigenvector precision\n\t * @param eval_prec\n\t *            required eigenvalue precision\n\t */\n\tpublic SuperPositionQCP(boolean centered, double evec_prec, double eval_prec) {\n\t\tsuper(centered);\n\t\tthis.evec_prec = evec_prec;\n\t\tthis.eval_prec = eval_prec;\n\t}\n\n\t/**\n\t * Sets the two input coordinate arrays. These input arrays must be of equal\n\t * length. Input coordinates are not modified.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t */\n\tprivate void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\t/**\n\t * Sets the two input coordinate arrays and weight array. All input arrays\n\t * must be of equal length. Input coordinates are not modified.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t * @param weight\n\t *            a weight in the inclusive range [0,1] for each point\n\t */\n\tprivate void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\t/**\n\t * Return the RMSD of the superposition of input coordinate set y onto x.\n\t * Note, this is the fasted way to calculate an RMSD without actually\n\t * superposing the two sets. The calculation is performed \"lazy\", meaning\n\t * calculations are only performed if necessary.\n\t *\n\t * @return root mean square deviation for superposition of y onto x\n\t */\n\tprivate double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t\trmsdCalculated = true;\n\t\t}\n\t\treturn rmsd;\n\t}\n\n\t/**\n\t * Weighted superposition.\n\t *\n\t * @param fixed\n\t * @param moved\n\t * @param weight\n\t *            array of weigths for each equivalent point position\n\t * @return\n\t */\n\tpublic Matrix4d weightedSuperpose(Point3d[] fixed, Point3d[] moved, double[] weight) {\n\t\tset(moved, fixed, weight);\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\tprivate Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t\ttransformationCalculated = true;\n\t\t}\n\t\treturn rotmat;\n\t}\n\n\t/**\n\t * Calculates the RMSD value for superposition of y onto x. This requires\n\t * the coordinates to be precentered.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = CalcPoint.clonePoint3dArray(x);\n\t\t\txtrans = CalcPoint.centroid(xref);\n\t\t\tlogger.debug(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tCalcPoint.translate(new Vector3d(xtrans), xref);\n\n\t\t\tyref = CalcPoint.clonePoint3dArray(y);\n\t\t\tytrans = CalcPoint.centroid(yref);\n\t\t\tlogger.debug(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tCalcPoint.translate(new Vector3d(ytrans), yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(wsum);\n\t}\n\n\t/**\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n\t * Calculates the inner product between two coordinate sets x and y\n\t * (optionally weighted, if weights set through\n\t * {@link #set(Point3d[], Point3d[], double[])}). It also calculates an\n\t * upper bound of the most positive root of the key matrix.\n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t *\n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\twsum = 0;\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\n\t\t\t\twsum += weight[i];\n\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y + coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y + coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t\twsum = coords1.length;\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(double len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0 * (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx - Sxx * Syy * Szz - Syz * Szx * Sxy\n\t\t\t\t- Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2) * (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 1; i < 51; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(eval_prec * mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50) {\n\t\t\tlogger.warn(String.format(\"More than %d iterations needed!\", i));\n\t\t} else {\n\t\t\tlogger.info(String.format(\"%d iterations needed!\", i));\n\t\t}\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < evec_prec) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < evec_prec) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12 * a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11 * a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11 * a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < evec_prec) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34 * a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33 * a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < evec_prec) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\tlogger.debug(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic double getRmsd(Point3d[] fixed, Point3d[] moved) {\n\t\tset(moved, fixed);\n\t\treturn getRmsd();\n\t}\n\n\t@Override\n\tpublic Matrix4d superpose(Point3d[] fixed, Point3d[] moved) {\n\t\tset(moved, fixed);\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\t/**\n\t * @param fixed\n\t * @param moved\n\t * @param weight\n\t *            array of weigths for each equivalent point position\n\t * @return weighted RMSD.\n\t */\n\tpublic double getWeightedRmsd(Point3d[] fixed, Point3d[] moved, double[] weight) {\n\t\tset(moved, fixed, weight);\n\t\treturn getRmsd();\n\t}\n\n\t/**\n\t * The QCP method can be used as a two-step calculation: first compute the\n\t * RMSD (fast) and then compute the superposition.\n\t *\n\t * This method assumes that the RMSD of two arrays of points has been\n\t * already calculated using {@link #getRmsd(Point3d[], Point3d[])} method\n\t * and calculates the transformation of the same two point arrays.\n\t *\n\t * @param fixed\n\t * @param moved\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superposeAfterRmsd() {\n\n\t\tif (!rmsdCalculated) {\n\t\t\tthrow new IllegalStateException(\"The RMSD was not yet calculated. Use the superpose() method instead.\");\n\t\t}\n\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.nbio.structure.geometry;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of the Quaternion-Based Characteristic Polynomial algorithm\n * for RMSD and Superposition calculations.\n * <p>\n * Usage:\n * <p>\n * The input consists of 2 Point3d arrays of equal length. The input coordinates\n * are not changed.\n *\n * <pre>\n *    Point3d[] x = ...\n *    Point3d[] y = ...\n *    SuperPositionQCP qcp = new SuperPositionQCP();\n *    qcp.set(x, y);\n * </pre>\n * <p>\n * or with weighting factors [0 - 1]]\n *\n * <pre>\n *    double[] weights = ...\n *    qcp.set(x, y, weights);\n * </pre>\n * <p>\n * For maximum efficiency, create a SuperPositionQCP object once and reuse it.\n * <p>\n * A. Calculate rmsd only\n *\n * <pre>\n * double rmsd = qcp.getRmsd();\n * </pre>\n * <p>\n * B. Calculate a 4x4 transformation (rotation and translation) matrix\n *\n * <pre>\n * Matrix4d rottrans = qcp.getTransformationMatrix();\n * </pre>\n * <p>\n * C. Get transformated points (y superposed onto the reference x)\n *\n * <pre>\n * Point3d[] ySuperposed = qcp.getTransformedCoordinates();\n * </pre>\n * <p>\n * Citations:\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2011) Reply to comment on: \"Fast\n * determination of the optimal rotation matrix for macromolecular\n * superpositions.\" Journal of Computational Chemistry 32(1):185-186.\n * [http://dx.doi.org/10.1002/jcc.21606]\n * <p>\n * Liu P, Agrafiotis DK, & Theobald DL (2010) \"Fast determination of the optimal\n * rotation matrix for macromolecular superpositions.\" Journal of Computational\n * Chemistry 31(7):1561-1563. [http://dx.doi.org/10.1002/jcc.21439]\n * <p>\n * Douglas L Theobald (2005) \"Rapid calculation of RMSDs using a\n * quaternion-based characteristic polynomial.\" Acta Crystallogr A\n * 61(4):478-480. [http://dx.doi.org/10.1107/S0108767305015266 ]\n * <p>\n * This is an adoption of the original C code QCProt 1.4 (2012, October 10) to\n * Java. The original C source code is available from\n * http://theobald.brandeis.edu/qcp/ and was developed by\n * <p>\n * Douglas L. Theobald Department of Biochemistry MS 009 Brandeis University 415\n * South St Waltham, MA 02453 USA\n * <p>\n * dtheobald@brandeis.edu\n * <p>\n * Pu Liu Johnson & Johnson Pharmaceutical Research and Development, L.L.C. 665\n * Stockton Drive Exton, PA 19341 USA\n * <p>\n * pliu24@its.jnj.com\n * <p>\n *\n * @author Douglas L. Theobald (original C code)\n * @author Pu Liu (original C code)\n * @author Peter Rose (adopted to Java)\n * @author Aleix Lafita (adopted to Java)\n */\npublic final class SuperPositionQCP extends SuperPositionAbstract {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(SuperPositionQCP.class);\n\n\tprivate double evec_prec = 1E-3;\n\tprivate double eval_prec = 1E-11;\n\n\tprivate Point3d[] x;\n\tprivate Point3d[] y;\n\n\tprivate double[] weight;\n\tprivate double wsum;\n\n\tprivate Point3d[] xref;\n\tprivate Point3d[] yref;\n\tprivate Point3d xtrans;\n\tprivate Point3d ytrans;\n\n\tprivate double e0;\n\tprivate Matrix3d rotmat = new Matrix3d();\n\tprivate Matrix4d transformation = new Matrix4d();\n\tprivate double rmsd = 0;\n\tprivate double Sxy, Sxz, Syx, Syz, Szx, Szy;\n\tprivate double SxxpSyy, Szz, mxEigenV, SyzmSzy, SxzmSzx, SxymSyx;\n\tprivate double SxxmSyy, SxypSyx, SxzpSzx;\n\tprivate double Syy, Sxx, SyzpSzy;\n\tprivate boolean rmsdCalculated = false;\n\tprivate boolean transformationCalculated = false;\n\tprivate boolean centered = false;\n\n\t/**\n\t * Default constructor for the quaternion based superposition algorithm.\n\t *\n\t * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n\t */\n\tpublic SuperPositionQCP(boolean centered) {\n\t\tsuper(centered);\n\t}\n\n\t/**\n\t * Constructor with option to set the precision values.\n\t *\n\t * @param centered\n\t *            true if the point arrays are centered at the origin (faster),\n\t *            false otherwise\n\t * @param evec_prec\n\t *            required eigenvector precision\n\t * @param eval_prec\n\t *            required eigenvalue precision\n\t */\n\tpublic SuperPositionQCP(boolean centered, double evec_prec, double eval_prec) {\n\t\tsuper(centered);\n\t\tthis.evec_prec = evec_prec;\n\t\tthis.eval_prec = eval_prec;\n\t}\n\n\t/**\n\t * Sets the two input coordinate arrays. These input arrays must be of equal\n\t * length. Input coordinates are not modified.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t */\n\tprivate void set(Point3d[] x, Point3d[] y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\t/**\n\t * Sets the two input coordinate arrays and weight array. All input arrays\n\t * must be of equal length. Input coordinates are not modified.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t * @param weight\n\t *            a weight in the inclusive range [0,1] for each point\n\t */\n\tprivate void set(Point3d[] x, Point3d[] y, double[] weight) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.weight = weight;\n\t\trmsdCalculated = false;\n\t\ttransformationCalculated = false;\n\t}\n\n\t/**\n\t * Return the RMSD of the superposition of input coordinate set y onto x.\n\t * Note, this is the fasted way to calculate an RMSD without actually\n\t * superposing the two sets. The calculation is performed \"lazy\", meaning\n\t * calculations are only performed if necessary.\n\t *\n\t * @return root mean square deviation for superposition of y onto x\n\t */\n\tprivate double getRmsd() {\n\t\tif (!rmsdCalculated) {\n\t\t\tcalcRmsd(x, y);\n\t\t\trmsdCalculated = true;\n\t\t}\n\t\treturn rmsd;\n\t}\n\n\t/**\n\t * Weighted superposition.\n\t *\n\t * @param fixed\n\t * @param moved\n\t * @param weight\n\t *            array of weigths for each equivalent point position\n\t * @return\n\t */\n\tpublic Matrix4d weightedSuperpose(Point3d[] fixed, Point3d[] moved, double[] weight) {\n\t\tset(moved, fixed, weight);\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\tprivate Matrix3d getRotationMatrix() {\n\t\tgetRmsd();\n\t\tif (!transformationCalculated) {\n\t\t\tcalcRotationMatrix();\n\t\t\ttransformationCalculated = true;\n\t\t}\n\t\treturn rotmat;\n\t}\n\n\t/**\n\t * Calculates the RMSD value for superposition of y onto x. This requires\n\t * the coordinates to be precentered.\n\t *\n\t * @param x\n\t *            3d points of reference coordinate set\n\t * @param y\n\t *            3d points of coordinate set for superposition\n\t */\n\tprivate void calcRmsd(Point3d[] x, Point3d[] y) {\n\t\tif (centered) {\n\t\t\tinnerProduct(y, x);\n\t\t} else {\n\t\t\t// translate to origin\n\t\t\txref = CalcPoint.clonePoint3dArray(x);\n\t\t\txtrans = CalcPoint.centroid(xref);\n\t\t\tlogger.debug(\"x centroid: \" + xtrans);\n\t\t\txtrans.negate();\n\t\t\tCalcPoint.translate(new Vector3d(xtrans), xref);\n\n\t\t\tyref = CalcPoint.clonePoint3dArray(y);\n\t\t\tytrans = CalcPoint.centroid(yref);\n\t\t\tlogger.debug(\"y centroid: \" + ytrans);\n\t\t\tytrans.negate();\n\t\t\tCalcPoint.translate(new Vector3d(ytrans), yref);\n\t\t\tinnerProduct(yref, xref);\n\t\t}\n\t\tcalcRmsd(wsum);\n\t}\n\n\t/**\n\t * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n\t * coords1 is held fixed\n\t */\n\tprivate void calcTransformation() {\n\n\t\t// transformation.set(rotmat,new Vector3d(0,0,0), 1);\n\t\ttransformation.set(rotmat);\n\t\t// long t2 = System.nanoTime();\n\t\t// System.out.println(\"create transformation: \" + (t2-t1));\n\t\t// System.out.println(\"m3d -> m4d\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with x -> origin translation\n\t\tMatrix4d trans = new Matrix4d();\n\t\ttrans.setIdentity();\n\t\ttrans.setTranslation(new Vector3d(xtrans));\n\t\ttransformation.mul(transformation, trans);\n\t\t// System.out.println(\"setting xtrans\");\n\t\t// System.out.println(transformation);\n\n\t\t// combine with origin -> y translation\n\t\tytrans.negate();\n\t\tMatrix4d transInverse = new Matrix4d();\n\t\ttransInverse.setIdentity();\n\t\ttransInverse.setTranslation(new Vector3d(ytrans));\n\t\ttransformation.mul(transInverse, transformation);\n\t\t// System.out.println(\"setting ytrans\");\n\t\t// System.out.println(transformation);\n\t}\n\n\t/**\n\t * Calculates the inner product between two coordinate sets x and y\n\t * (optionally weighted, if weights set through\n\t * {@link #set(Point3d[], Point3d[], double[])}). It also calculates an\n\t * upper bound of the most positive root of the key matrix.\n\t * http://theobald.brandeis.edu/qcp/qcprot.c\n\t *\n\t * @param coords1\n\t * @param coords2\n\t * @return\n\t */\n\tprivate void innerProduct(Point3d[] coords1, Point3d[] coords2) {\n\t\tdouble x1, x2, y1, y2, z1, z2;\n\t\tdouble g1 = 0.0, g2 = 0.0;\n\n\t\tSxx = 0;\n\t\tSxy = 0;\n\t\tSxz = 0;\n\t\tSyx = 0;\n\t\tSyy = 0;\n\t\tSyz = 0;\n\t\tSzx = 0;\n\t\tSzy = 0;\n\t\tSzz = 0;\n\n\t\tif (weight != null) {\n\t\t\twsum = 0;\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\n\t\t\t\twsum += weight[i];\n\n\t\t\t\tx1 = weight[i] * coords1[i].x;\n\t\t\t\ty1 = weight[i] * coords1[i].y;\n\t\t\t\tz1 = weight[i] * coords1[i].z;\n\n\t\t\t\tg1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n\n\t\t\t\tx2 = coords2[i].x;\n\t\t\t\ty2 = coords2[i].y;\n\t\t\t\tz2 = coords2[i].z;\n\n\t\t\t\tg2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n\n\t\t\t\tSxx += (x1 * x2);\n\t\t\t\tSxy += (x1 * y2);\n\t\t\t\tSxz += (x1 * z2);\n\n\t\t\t\tSyx += (y1 * x2);\n\t\t\t\tSyy += (y1 * y2);\n\t\t\t\tSyz += (y1 * z2);\n\n\t\t\t\tSzx += (z1 * x2);\n\t\t\t\tSzy += (z1 * y2);\n\t\t\t\tSzz += (z1 * z2);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < coords1.length; i++) {\n\t\t\t\tg1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y + coords1[i].z * coords1[i].z;\n\t\t\t\tg2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y + coords2[i].z * coords2[i].z;\n\n\t\t\t\tSxx += coords1[i].x * coords2[i].x;\n\t\t\t\tSxy += coords1[i].x * coords2[i].y;\n\t\t\t\tSxz += coords1[i].x * coords2[i].z;\n\n\t\t\t\tSyx += coords1[i].y * coords2[i].x;\n\t\t\t\tSyy += coords1[i].y * coords2[i].y;\n\t\t\t\tSyz += coords1[i].y * coords2[i].z;\n\n\t\t\t\tSzx += coords1[i].z * coords2[i].x;\n\t\t\t\tSzy += coords1[i].z * coords2[i].y;\n\t\t\t\tSzz += coords1[i].z * coords2[i].z;\n\t\t\t}\n\t\t\twsum = coords1.length;\n\t\t}\n\n\t\te0 = (g1 + g2) * 0.5;\n\t}\n\n\tprivate int calcRmsd(double len) {\n\t\tdouble Sxx2 = Sxx * Sxx;\n\t\tdouble Syy2 = Syy * Syy;\n\t\tdouble Szz2 = Szz * Szz;\n\n\t\tdouble Sxy2 = Sxy * Sxy;\n\t\tdouble Syz2 = Syz * Syz;\n\t\tdouble Sxz2 = Sxz * Sxz;\n\n\t\tdouble Syx2 = Syx * Syx;\n\t\tdouble Szy2 = Szy * Szy;\n\t\tdouble Szx2 = Szx * Szx;\n\n\t\tdouble SyzSzymSyySzz2 = 2.0 * (Syz * Szy - Syy * Szz);\n\t\tdouble Sxx2Syy2Szz2Syz2Szy2 = Syy2 + Szz2 - Sxx2 + Syz2 + Szy2;\n\n\t\tdouble c2 = -2.0 * (Sxx2 + Syy2 + Szz2 + Sxy2 + Syx2 + Sxz2 + Szx2 + Syz2 + Szy2);\n\t\tdouble c1 = 8.0 * (Sxx * Syz * Szy + Syy * Szx * Sxz + Szz * Sxy * Syx - Sxx * Syy * Szz - Syz * Szx * Sxy\n\t\t\t\t- Szy * Syx * Sxz);\n\n\t\tSxzpSzx = Sxz + Szx;\n\t\tSyzpSzy = Syz + Szy;\n\t\tSxypSyx = Sxy + Syx;\n\t\tSyzmSzy = Syz - Szy;\n\t\tSxzmSzx = Sxz - Szx;\n\t\tSxymSyx = Sxy - Syx;\n\t\tSxxpSyy = Sxx + Syy;\n\t\tSxxmSyy = Sxx - Syy;\n\n\t\tdouble Sxy2Sxz2Syx2Szx2 = Sxy2 + Sxz2 - Syx2 - Szx2;\n\n\t\tdouble c0 = Sxy2Sxz2Syx2Szx2 * Sxy2Sxz2Syx2Szx2\n\t\t\t\t+ (Sxx2Syy2Szz2Syz2Szy2 + SyzSzymSyySzz2) * (Sxx2Syy2Szz2Syz2Szy2 - SyzSzymSyySzz2)\n\t\t\t\t+ (-(SxzpSzx) * (SyzmSzy) + (SxymSyx) * (SxxmSyy - Szz))\n\t\t\t\t\t\t* (-(SxzmSzx) * (SyzpSzy) + (SxymSyx) * (SxxmSyy + Szz))\n\t\t\t\t+ (-(SxzpSzx) * (SyzpSzy) - (SxypSyx) * (SxxpSyy - Szz))\n\t\t\t\t\t\t* (-(SxzmSzx) * (SyzmSzy) - (SxypSyx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzpSzy) + (SxzpSzx) * (SxxmSyy + Szz))\n\t\t\t\t\t\t* (-(SxymSyx) * (SyzmSzy) + (SxzpSzx) * (SxxpSyy + Szz))\n\t\t\t\t+ (+(SxypSyx) * (SyzmSzy) + (SxzmSzx) * (SxxmSyy - Szz))\n\t\t\t\t\t\t* (-(SxymSyx) * (SyzpSzy) + (SxzmSzx) * (SxxpSyy - Szz));\n\n\t\tmxEigenV = e0;\n\n\t\tint i;\n\t\tfor (i = 1; i < 51; ++i) {\n\t\t\tdouble oldg = mxEigenV;\n\t\t\tdouble x2 = mxEigenV * mxEigenV;\n\t\t\tdouble b = (x2 + c2) * mxEigenV;\n\t\t\tdouble a = b + c1;\n\t\t\tdouble delta = ((a * mxEigenV + c0) / (2.0 * x2 * mxEigenV + b + a));\n\t\t\tmxEigenV -= delta;\n\n\t\t\tif (Math.abs(mxEigenV - oldg) < Math.abs(eval_prec * mxEigenV))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == 50) {\n\t\t\tlogger.warn(String.format(\"More than %d iterations needed!\", i));\n\t\t} else {\n\t\t\tlogger.info(String.format(\"%d iterations needed!\", i));\n\t\t}\n\n\t\t/*\n\t\t * the fabs() is to guard against extremely small, but *negative*\n\t\t * numbers due to floating point error\n\t\t */\n\t\trmsd = Math.sqrt(Math.abs(2.0 * (e0 - mxEigenV) / len));\n\n\t\treturn 1;\n\t}\n\n\tprivate int calcRotationMatrix() {\n\t\tdouble a11 = SxxpSyy + Szz - mxEigenV;\n\t\tdouble a12 = SyzmSzy;\n\t\tdouble a13 = -SxzmSzx;\n\t\tdouble a14 = SxymSyx;\n\t\tdouble a21 = SyzmSzy;\n\t\tdouble a22 = SxxmSyy - Szz - mxEigenV;\n\t\tdouble a23 = SxypSyx;\n\t\tdouble a24 = SxzpSzx;\n\t\tdouble a31 = a13;\n\t\tdouble a32 = a23;\n\t\tdouble a33 = Syy - Sxx - Szz - mxEigenV;\n\t\tdouble a34 = SyzpSzy;\n\t\tdouble a41 = a14;\n\t\tdouble a42 = a24;\n\t\tdouble a43 = a34;\n\t\tdouble a44 = Szz - SxxpSyy - mxEigenV;\n\t\tdouble a3344_4334 = a33 * a44 - a43 * a34;\n\t\tdouble a3244_4234 = a32 * a44 - a42 * a34;\n\t\tdouble a3243_4233 = a32 * a43 - a42 * a33;\n\t\tdouble a3143_4133 = a31 * a43 - a41 * a33;\n\t\tdouble a3144_4134 = a31 * a44 - a41 * a34;\n\t\tdouble a3142_4132 = a31 * a42 - a41 * a32;\n\t\tdouble q1 = a22 * a3344_4334 - a23 * a3244_4234 + a24 * a3243_4233;\n\t\tdouble q2 = -a21 * a3344_4334 + a23 * a3144_4134 - a24 * a3143_4133;\n\t\tdouble q3 = a21 * a3244_4234 - a22 * a3144_4134 + a24 * a3142_4132;\n\t\tdouble q4 = -a21 * a3243_4233 + a22 * a3143_4133 - a23 * a3142_4132;\n\n\t\tdouble qsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t/*\n\t\t * The following code tries to calculate another column in the adjoint\n\t\t * matrix when the norm of the current column is too small. Usually this\n\t\t * commented block will never be activated. To be absolutely safe this\n\t\t * should be uncommented, but it is most likely unnecessary.\n\t\t */\n\t\tif (qsqr < evec_prec) {\n\t\t\tq1 = a12 * a3344_4334 - a13 * a3244_4234 + a14 * a3243_4233;\n\t\t\tq2 = -a11 * a3344_4334 + a13 * a3144_4134 - a14 * a3143_4133;\n\t\t\tq3 = a11 * a3244_4234 - a12 * a3144_4134 + a14 * a3142_4132;\n\t\t\tq4 = -a11 * a3243_4233 + a12 * a3143_4133 - a13 * a3142_4132;\n\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\tif (qsqr < evec_prec) {\n\t\t\t\tdouble a1324_1423 = a13 * a24 - a14 * a23, a1224_1422 = a12 * a24 - a14 * a22;\n\t\t\t\tdouble a1223_1322 = a12 * a23 - a13 * a22, a1124_1421 = a11 * a24 - a14 * a21;\n\t\t\t\tdouble a1123_1321 = a11 * a23 - a13 * a21, a1122_1221 = a11 * a22 - a12 * a21;\n\n\t\t\t\tq1 = a42 * a1324_1423 - a43 * a1224_1422 + a44 * a1223_1322;\n\t\t\t\tq2 = -a41 * a1324_1423 + a43 * a1124_1421 - a44 * a1123_1321;\n\t\t\t\tq3 = a41 * a1224_1422 - a42 * a1124_1421 + a44 * a1122_1221;\n\t\t\t\tq4 = -a41 * a1223_1322 + a42 * a1123_1321 - a43 * a1122_1221;\n\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\tif (qsqr < evec_prec) {\n\t\t\t\t\tq1 = a32 * a1324_1423 - a33 * a1224_1422 + a34 * a1223_1322;\n\t\t\t\t\tq2 = -a31 * a1324_1423 + a33 * a1124_1421 - a34 * a1123_1321;\n\t\t\t\t\tq3 = a31 * a1224_1422 - a32 * a1124_1421 + a34 * a1122_1221;\n\t\t\t\t\tq4 = -a31 * a1223_1322 + a32 * a1123_1321 - a33 * a1122_1221;\n\t\t\t\t\tqsqr = q1 * q1 + q2 * q2 + q3 * q3 + q4 * q4;\n\n\t\t\t\t\tif (qsqr < evec_prec) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * if qsqr is still too small, return the identity\n\t\t\t\t\t\t * matrix.\n\t\t\t\t\t\t */\n\t\t\t\t\t\trotmat.setIdentity();\n\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble normq = Math.sqrt(qsqr);\n\t\tq1 /= normq;\n\t\tq2 /= normq;\n\t\tq3 /= normq;\n\t\tq4 /= normq;\n\n\t\tlogger.debug(\"q: \" + q1 + \" \" + q2 + \" \" + q3 + \" \" + q4);\n\n\t\tdouble a2 = q1 * q1;\n\t\tdouble x2 = q2 * q2;\n\t\tdouble y2 = q3 * q3;\n\t\tdouble z2 = q4 * q4;\n\n\t\tdouble xy = q2 * q3;\n\t\tdouble az = q1 * q4;\n\t\tdouble zx = q4 * q2;\n\t\tdouble ay = q1 * q3;\n\t\tdouble yz = q3 * q4;\n\t\tdouble ax = q1 * q2;\n\n\t\trotmat.m00 = a2 + x2 - y2 - z2;\n\t\trotmat.m01 = 2 * (xy + az);\n\t\trotmat.m02 = 2 * (zx - ay);\n\n\t\trotmat.m10 = 2 * (xy - az);\n\t\trotmat.m11 = a2 - x2 + y2 - z2;\n\t\trotmat.m12 = 2 * (yz + ax);\n\n\t\trotmat.m20 = 2 * (zx + ay);\n\t\trotmat.m21 = 2 * (yz - ax);\n\t\trotmat.m22 = a2 - x2 - y2 + z2;\n\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic double getRmsd(Point3d[] fixed, Point3d[] moved) {\n\t\tset(moved, fixed);\n\t\treturn getRmsd();\n\t}\n\n\t@Override\n\tpublic Matrix4d superpose(Point3d[] fixed, Point3d[] moved) {\n\t\tset(moved, fixed);\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n\t/**\n\t * @param fixed\n\t * @param moved\n\t * @param weight\n\t *            array of weigths for each equivalent point position\n\t * @return weighted RMSD.\n\t */\n\tpublic double getWeightedRmsd(Point3d[] fixed, Point3d[] moved, double[] weight) {\n\t\tset(moved, fixed, weight);\n\t\treturn getRmsd();\n\t}\n\n\t/**\n\t * The QCP method can be used as a two-step calculation: first compute the\n\t * RMSD (fast) and then compute the superposition.\n\t *\n\t * This method assumes that the RMSD of two arrays of points has been\n\t * already calculated using {@link #getRmsd(Point3d[], Point3d[])} method\n\t * and calculates the transformation of the same two point arrays.\n\t *\n\t * @param fixed\n\t * @param moved\n\t * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n\t *         point arrays\n\t */\n\tpublic Matrix4d superposeAfterRmsd() {\n\n\t\tif (!rmsdCalculated) {\n\t\t\tthrow new IllegalStateException(\"The RMSD was not yet calculated. Use the superpose() method instead.\");\n\t\t}\n\n\t\tgetRotationMatrix();\n\t\tif (!centered) {\n\t\t\tcalcTransformation();\n\t\t} else {\n\t\t\ttransformation.set(rotmat);\n\t\t}\n\t\treturn transformation;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.geometry;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Random;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.nbio.structure.geometry.SuperPositionQuat;\nimport org.biojava.nbio.structure.geometry.SuperPositionQCP;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Test the Quaternion-Based Characteristic Polynomial {@link SuperPositionQCP}\n * algorithm for RMSD and Superposition calculations.\n *\n * @author Aleix Lafita\n * @since 5.0.0\n *\n */\npublic class TestSuperPositionQCP {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(TestSuperPosition.class);\n\n\t/**\n\t * Test case proposed by Peter Rose from his observations about quaternary\n\t * symmetry artifacts with the QCP algorithm.\n\t */\n\t@Test\n\tpublic void testSymmetryQCP() {\n\n\t\t// Generate an array of points with symmetry\n\t\tPoint3d[] set1 = new Point3d[16];\n\t\tset1[0] = new Point3d(14.065934, 47.068832, -32.895836);\n\t\tset1[1] = new Point3d(-14.065934, -47.068832, -32.895836);\n\t\tset1[2] = new Point3d(-47.068832, 14.065934, -32.895836);\n\t\tset1[3] = new Point3d(47.068832, -14.065934, -32.895836);\n\t\tset1[4] = new Point3d(-14.065934, 47.068832, 32.895836);\n\t\tset1[5] = new Point3d(14.065934, -47.068832, 32.895836);\n\t\tset1[6] = new Point3d(47.068832, 14.065934, 32.895836);\n\t\tset1[7] = new Point3d(-47.068832, -14.065934, 32.895836);\n\t\tset1[8] = new Point3d(43.813946, 22.748293, -32.14434);\n\t\tset1[9] = new Point3d(-43.813946, -22.748293, -32.14434);\n\t\tset1[10] = new Point3d(-22.748293, 43.813946, -32.14434);\n\t\tset1[11] = new Point3d(22.748293, -43.813946, -32.14434);\n\t\tset1[12] = new Point3d(-43.813946, 22.748293, 32.14434);\n\t\tset1[13] = new Point3d(43.813946, -22.748293, 32.14434);\n\t\tset1[14] = new Point3d(22.748293, 43.813946, 32.14434);\n\t\tset1[15] = new Point3d(-22.748293, -43.813946, 32.14434);\n\n\t\tPoint3d[] set2 = CalcPoint.clonePoint3dArray(set1);\n\n\t\t// Use a random transformation to set2\n\t\tAxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\t\tVector3d translation = new Vector3d(0.345, 2.453, 5.324);\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\t\tCalcPoint.transform(transform, set2);\n\n\t\t// Use Quaternion superposition to obtain the RMSD\n\t\tSuperPosition algorithm = new SuperPositionQuat(false);\n\t\tlong quatStart = System.nanoTime();\n\t\tdouble quatrmsd = algorithm.getRmsd(set1, set2);\n\t\tlong quatTime = (System.nanoTime() - quatStart) / 1000;\n\n\t\t// Use QCP algorithm to get the RMSD\n\t\talgorithm = new SuperPositionQCP(false);\n\t\tlong qcpStart = System.nanoTime();\n\t\tdouble qcprmsd = algorithm.getRmsd(set1, set2);\n\t\tlong qcpTime = (System.nanoTime() - qcpStart) / 1000;\n\n\t\tLOGGER.info(String.format(\"RMSD Symmetry: Quat time: %d us\" + \", QCP time: %d us\", quatTime, qcpTime));\n\n\t\t// Check that the returned RMSDs are equal\n\t\tassertEquals(quatrmsd, qcprmsd, 0.001);\n\n\t}\n\n\t/**\n\t * Test case proposed by Peter Rose to check the alternative use of QCP,\n\t * where first the RMSD is checked before obtaining the transformation\n\t * matrix, in order to speed up large-scale calculations.\n\t */\n\t@Test\n\tpublic void testAlternativeUsageQCP() {\n\n\t\t// Transformation applied to cloud points 1 that needs to be recovered\n\t\t// by the superposition method\n\t\tAxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n\t\tVector3d translation = new Vector3d(0.345, 2.453, 5.324);\n\n\t\tMatrix4d transform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\n\t\t// Generate a random artificial array of points\n\t\tRandom rnd = new Random(0);\n\n\t\ttransform = new Matrix4d();\n\t\ttransform.set(rotAxis);\n\t\ttransform.setTranslation(translation);\n\n\t\tPoint3d[] c1 = new Point3d[500];\n\t\tPoint3d[] c2 = new Point3d[500];\n\n\t\tfor (int p = 0; p < 500; p++) {\n\n\t\t\tPoint3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50), rnd.nextInt(150));\n\t\t\tc1[p] = a;\n\n\t\t\t// Add some noise to the second point\n\t\t\tPoint3d b = new Point3d(a.x + rnd.nextDouble(), a.y + rnd.nextDouble(), a.z + rnd.nextDouble());\n\t\t\tc2[p] = b;\n\n\t\t}\n\n\t\tCalcPoint.transform(transform, c1);\n\n\t\tSuperPositionQCP qcp = new SuperPositionQCP(false);\n\n\t\t// Step 1 calculate RMSD\n\t\tlong start = System.nanoTime() / 1000;\n\t\tqcp.getRmsd(c1, c2);\n\t\tlong rmsdTime = (System.nanoTime() / 1000 - start);\n\n\t\t// Step 2 Obtain the matrix after RMSD\n\t\tMatrix4d trans1 = qcp.superposeAfterRmsd();\n\t\tlong trans1time = (System.nanoTime() / 1000 - start) - rmsdTime;\n\n\t\t// Now obtain the matrix from scratch\n\t\tMatrix4d trans2 = qcp.superpose(c1, c2);\n\t\tlong trans2time = (System.nanoTime() / 1000 - start) - trans1time;\n\n\t\tLOGGER.info(String.format(\n\t\t\t\t\"Time for RMSD: %d us, superposition after RMSD: %d us, and superposition from scratch: %d us\",\n\t\t\t\trmsdTime, trans1time, trans2time));\n\n\t\t// Check the results are the same\n\t\tassertTrue(trans1.epsilonEquals(trans2, 0.05));\n\n\t}\n\n}\n","changedTest":"","commitMessage":"increase QCP precision threshold (try to fix #914)\n","test_commitMessage":"","allZero":false}