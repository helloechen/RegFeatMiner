{"repository":"biojava","prod_path":"biojava-alignment/src/main/java/org/biojava/nbio/alignment/GuideTree.java","test_path":"biojava-alignment/src/test/java/org/biojava/nbio/alignment/GuideTreeTest.java","prod_time":"2015-09-16 22:43:32","test_time":"2015-09-16 22:43:32","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"5ad3cc9e93ee928561a4423a0ac9a3835370b1b7","test_commitID":"5ad3cc9e93ee928561a4423a0ac9a3835370b1b7","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceScorer;\nimport org.biojava.nbio.alignment.template.Profile;\nimport org.biojava.nbio.alignment.template.ProfilePair;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.forester.evoinference.distance.NeighborJoining;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\n\nimport javax.swing.tree.TreeNode;\nimport java.util.*;\nimport java.util.concurrent.Future;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n    private List<S> sequences;\n    private List<PairwiseSequenceScorer<S, C>> scorers;\n    private BasicSymmetricalDistanceMatrix distances;\n    private String newick;\n    private Node root;\n\n    /**\n     * Creates a guide tree for use during progressive multiple sequence alignment.\n     *\n     * @param sequences the {@link List} of {@link Sequence}s to align\n     * @param scorers list of sequence pair scorers, one for each pair of sequences given\n     */\n    public GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n        this.sequences = Collections.unmodifiableList(sequences);\n        this.scorers = Collections.unmodifiableList(scorers);\n        distances = new BasicSymmetricalDistanceMatrix(sequences.size());\n        BasicSymmetricalDistanceMatrix distclone = new BasicSymmetricalDistanceMatrix(sequences.size());\n        for (int i = 0, n = 0; i < sequences.size(); i++) {\n            AccessionID id = sequences.get(i).getAccession();\n            String str = (id == null) ? Integer.toString(i + 1) : id.getID();\n            distances.setIdentifier(i, str);\n            distclone.setIdentifier(i, str);\n            for (int j = i+1; j < sequences.size(); j++) {\n                double dist = scorers.get(n++).getDistance();\n                distances.setValue(i, j, dist);\n                distclone.setValue(i, j, dist);\n            }\n        }\n        // TODO UPGMA and other hierarchical clustering routines\n        Phylogeny phylogeny = NeighborJoining.createInstance().execute(distclone);\n        newick = phylogeny.toString();\n        root = new Node(phylogeny.getRoot(), null);\n    }\n\n    /**\n     * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n     *\n     * @return list of sequence pair scores\n     */\n    public double[] getAllPairsScores() {\n    \tdouble[] scores = new double[scorers.size()];\n        int n = 0;\n        for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n            scores[n++] = scorer.getScore();\n        }\n        return scores;\n    }\n\n    /**\n     * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n     *\n     * @return the distance matrix used to construct this guide tree\n     */\n    public double[][] getDistanceMatrix() {\n        double[][] matrix = new double[distances.getSize()][distances.getSize()];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n     *\n     * @return the root node\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n     *\n     * @return the similarity matrix used to construct this guide tree\n     */\n    public double[][] getScoreMatrix() {\n    \tdouble[][] matrix = new double[sequences.size()][sequences.size()];\n        for (int i = 0, n = 0; i < matrix.length; i++) {\n            matrix[i][i] = scorers.get(i).getMaxScore();\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the {@link Sequence}s which make up the leaves of this tree.\n     *\n     * @return the sequences which make up the leaves of this tree\n     */\n    public List<S> getSequences() {\n        return sequences;\n    }\n\n    // method for Iterable\n\n    /**\n     * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n     */\n    @Override\n    public Iterator<GuideTreeNode<S, C>> iterator() {\n        return new PostOrderIterator();\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return newick;\n    }\n\n    /**\n     * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n     */\n    public class Node implements GuideTreeNode<S, C> {\n\n        private GuideTreeNode<S, C> parent, child1, child2;\n        private double distance;\n        private String name;\n        private boolean isLeaf, isVisited;\n        private Profile<S, C> profile;\n        private Future<ProfilePair<S, C>> profileFuture;\n\n        private Node(PhylogenyNode node, Node parent) {\n            this.parent = parent;\n            distance = node.getDistanceToParent();\n            name = node.getName();\n            if(isLeaf = node.isExternal()) {\n                profile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n            } else {\n                child1 = new Node(node.getChildNode1(), this);\n                child2 = new Node(node.getChildNode2(), this);\n            }\n        }\n\n        // methods for GuideTreeNode\n\n        @Override\n        public GuideTreeNode<S, C> getChild1() {\n            return child1;\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChild2() {\n            return child2;\n        }\n\n        @Override\n        public double getDistanceToParent() {\n            return distance;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public Profile<S, C> getProfile() {\n            return profile;\n        }\n\n        @Override\n        public Future<ProfilePair<S, C>> getProfileFuture() {\n            return profileFuture;\n        }\n\n        @Override\n        public void setProfile(Profile<S, C> profile) {\n            this.profile = profile;\n            profileFuture = null;\n        }\n\n        @Override\n        public void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n            this.profileFuture = profileFuture;\n            profile = null;\n        }\n\n        // methods for TreeNode\n\n        @Override\n        public Enumeration<GuideTreeNode<S, C>> children() {\n            Vector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n            children.add(getChild1());\n            children.add(getChild2());\n            return children.elements();\n        }\n\n        @Override\n        public boolean getAllowsChildren() {\n            return !isLeaf();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChildAt(int childIndex) {\n            if (childIndex == 1) {\n                return getChild1();\n            } else if (childIndex == 2) {\n                return getChild2();\n            }\n            throw new IndexOutOfBoundsException();\n        }\n\n        @Override\n        public int getChildCount() {\n            return 2;\n        }\n\n        @Override\n        public int getIndex(TreeNode child) {\n            return getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getParent() {\n            return parent;\n        }\n\n        @Override\n        public boolean isLeaf() {\n            return isLeaf;\n        }\n\n        // helper methods for iterator\n\n        private void clearVisited() {\n            isVisited = false;\n            if (!isLeaf()) {\n                ((Node) getChild1()).clearVisited();\n                ((Node) getChild2()).clearVisited();\n            }\n        }\n\n        private boolean isVisited() {\n            return isVisited;\n        }\n\n        private void visit() {\n            isVisited = true;\n        }\n\n    }\n\n    // helper class that defines the default post-order (leaves to root) traversal\n    private class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n        private Stack<Node> nodes;\n\n        private PostOrderIterator() {\n            getRoot().clearVisited();\n            nodes = new Stack<Node>();\n            nodes.push(getRoot());\n        }\n\n        // methods for Iterator\n\n        @Override\n        public boolean hasNext() {\n            return !nodes.isEmpty();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> next() {\n            while (hasNext()) {\n                Node next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n                if (child1 != null && !child1.isVisited()) {\n                    nodes.push(child1);\n                } else if (child2 != null && !child2.isVisited()) {\n                    nodes.push(child2);\n                } else {\n                    next.visit();\n                    return nodes.pop();\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 1, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.core.alignment.SimpleProfile;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.alignment.template.PairwiseSequenceScorer;\nimport org.biojava.nbio.core.alignment.template.Profile;\nimport org.biojava.nbio.core.alignment.template.ProfilePair;\nimport org.biojava.nbio.core.sequence.AccessionID;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.forester.evoinference.distance.NeighborJoining;\nimport org.forester.evoinference.matrix.distance.BasicSymmetricalDistanceMatrix;\nimport org.forester.phylogeny.Phylogeny;\nimport org.forester.phylogeny.PhylogenyNode;\n\nimport javax.swing.tree.TreeNode;\nimport java.util.*;\nimport java.util.concurrent.Future;\n\n/**\n * Implements a data structure for a guide tree used during progressive multiple sequence alignment.  Leaf\n * {@link Node}s correspond to single {@link Sequence}s.  Internal {@link Node}s correspond to multiple sequence\n * alignments.  The root {@link Node} corresponds to the full multiple sequence alignment.\n *\n * @author Mark Chapman\n * @param <S> each {@link Sequence} in the tree is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n */\npublic class GuideTree<S extends Sequence<C>, C extends Compound> implements Iterable<GuideTreeNode<S, C>> {\n\n    private List<S> sequences;\n    private List<PairwiseSequenceScorer<S, C>> scorers;\n    private BasicSymmetricalDistanceMatrix distances;\n    private String newick;\n    private Node root;\n\n    /**\n     * Creates a guide tree for use during progressive multiple sequence alignment.\n     *\n     * @param sequences the {@link List} of {@link Sequence}s to align\n     * @param scorers list of sequence pair scorers, one for each pair of sequences given\n     */\n    public GuideTree(List<S> sequences, List<PairwiseSequenceScorer<S, C>> scorers) {\n        this.sequences = Collections.unmodifiableList(sequences);\n        this.scorers = Collections.unmodifiableList(scorers);\n        distances = new BasicSymmetricalDistanceMatrix(sequences.size());\n        BasicSymmetricalDistanceMatrix distclone = new BasicSymmetricalDistanceMatrix(sequences.size());\n        for (int i = 0, n = 0; i < sequences.size(); i++) {\n            AccessionID id = sequences.get(i).getAccession();\n            String str = (id == null) ? Integer.toString(i + 1) : id.getID();\n            distances.setIdentifier(i, str);\n            distclone.setIdentifier(i, str);\n            for (int j = i+1; j < sequences.size(); j++) {\n                double dist = scorers.get(n++).getDistance();\n                distances.setValue(i, j, dist);\n                distclone.setValue(i, j, dist);\n            }\n        }\n        // TODO UPGMA and other hierarchical clustering routines\n        Phylogeny phylogeny = NeighborJoining.createInstance().execute(distclone);\n        newick = phylogeny.toString();\n        root = new Node(phylogeny.getRoot(), null);\n    }\n\n    /**\n     * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n     *\n     * @return list of sequence pair scores\n     */\n    public double[] getAllPairsScores() {\n    \tdouble[] scores = new double[scorers.size()];\n        int n = 0;\n        for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n            scores[n++] = scorer.getScore();\n        }\n        return scores;\n    }\n\n    /**\n     * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n     *\n     * @return the distance matrix used to construct this guide tree\n     */\n    public double[][] getDistanceMatrix() {\n        double[][] matrix = new double[distances.getSize()][distances.getSize()];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n     *\n     * @return the root node\n     */\n    public Node getRoot() {\n        return root;\n    }\n\n    /**\n     * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n     *\n     * @return the similarity matrix used to construct this guide tree\n     */\n    public double[][] getScoreMatrix() {\n    \tdouble[][] matrix = new double[sequences.size()][sequences.size()];\n        for (int i = 0, n = 0; i < matrix.length; i++) {\n            matrix[i][i] = scorers.get(i).getMaxScore();\n            for (int j = i+1; j < matrix.length; j++) {\n                matrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n            }\n        }\n        return matrix;\n    }\n\n    /**\n     * Returns the {@link Sequence}s which make up the leaves of this tree.\n     *\n     * @return the sequences which make up the leaves of this tree\n     */\n    public List<S> getSequences() {\n        return sequences;\n    }\n\n    // method for Iterable\n\n    /**\n     * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n     */\n    @Override\n    public Iterator<GuideTreeNode<S, C>> iterator() {\n        return new PostOrderIterator();\n    }\n\n    // method from Object\n\n    @Override\n    public String toString() {\n        return newick;\n    }\n\n    /**\n     * Implements a data structure for the node in a guide tree used during progressive multiple sequence alignment.\n     */\n    public class Node implements GuideTreeNode<S, C> {\n\n        private GuideTreeNode<S, C> parent, child1, child2;\n        private double distance;\n        private String name;\n        private boolean isLeaf, isVisited;\n        private Profile<S, C> profile;\n        private Future<ProfilePair<S, C>> profileFuture;\n\n        private Node(PhylogenyNode node, Node parent) {\n            this.parent = parent;\n            distance = node.getDistanceToParent();\n            name = node.getName();\n            if(isLeaf = node.isExternal()) {\n                profile = new SimpleProfile<S, C>(sequences.get(distances.getIndex(name)));\n            } else {\n                child1 = new Node(node.getChildNode1(), this);\n                child2 = new Node(node.getChildNode2(), this);\n            }\n        }\n\n        // methods for GuideTreeNode\n\n        @Override\n        public GuideTreeNode<S, C> getChild1() {\n            return child1;\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChild2() {\n            return child2;\n        }\n\n        @Override\n        public double getDistanceToParent() {\n            return distance;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public Profile<S, C> getProfile() {\n            return profile;\n        }\n\n        @Override\n        public Future<ProfilePair<S, C>> getProfileFuture() {\n            return profileFuture;\n        }\n\n        @Override\n        public void setProfile(Profile<S, C> profile) {\n            this.profile = profile;\n            profileFuture = null;\n        }\n\n        @Override\n        public void setProfileFuture(Future<ProfilePair<S, C>> profileFuture) {\n            this.profileFuture = profileFuture;\n            profile = null;\n        }\n\n        // methods for TreeNode\n\n        @Override\n        public Enumeration<GuideTreeNode<S, C>> children() {\n            Vector<GuideTreeNode<S, C>> children = new Vector<GuideTreeNode<S, C>>();\n            children.add(getChild1());\n            children.add(getChild2());\n            return children.elements();\n        }\n\n        @Override\n        public boolean getAllowsChildren() {\n            return !isLeaf();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getChildAt(int childIndex) {\n            if (childIndex == 1) {\n                return getChild1();\n            } else if (childIndex == 2) {\n                return getChild2();\n            }\n            throw new IndexOutOfBoundsException();\n        }\n\n        @Override\n        public int getChildCount() {\n            return 2;\n        }\n\n        @Override\n        public int getIndex(TreeNode child) {\n            return getChildAt(1) == child ? 1 : (getChildAt(2) == child ? 2 : -1);\n        }\n\n        @Override\n        public GuideTreeNode<S, C> getParent() {\n            return parent;\n        }\n\n        @Override\n        public boolean isLeaf() {\n            return isLeaf;\n        }\n\n        // helper methods for iterator\n\n        private void clearVisited() {\n            isVisited = false;\n            if (!isLeaf()) {\n                ((Node) getChild1()).clearVisited();\n                ((Node) getChild2()).clearVisited();\n            }\n        }\n\n        private boolean isVisited() {\n            return isVisited;\n        }\n\n        private void visit() {\n            isVisited = true;\n        }\n\n    }\n\n    // helper class that defines the default post-order (leaves to root) traversal\n    private class PostOrderIterator implements Iterator<GuideTreeNode<S, C>> {\n\n        private Stack<Node> nodes;\n\n        private PostOrderIterator() {\n            getRoot().clearVisited();\n            nodes = new Stack<Node>();\n            nodes.push(getRoot());\n        }\n\n        // methods for Iterator\n\n        @Override\n        public boolean hasNext() {\n            return !nodes.isEmpty();\n        }\n\n        @Override\n        public GuideTreeNode<S, C> next() {\n            while (hasNext()) {\n                Node next = nodes.peek(), child1 = (Node) next.getChild1(), child2 = (Node) next.getChild2();\n                if (child1 != null && !child1.isVisited()) {\n                    nodes.push(child1);\n                } else if (child2 != null && !child2.isVisited()) {\n                    nodes.push(child2);\n                } else {\n                    next.visit();\n                    return nodes.pop();\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceScorerType;\nimport org.biojava.nbio.alignment.Alignments.ProfileProfileAlignerType;\nimport org.biojava.nbio.alignment.template.GapPenalty;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class GuideTreeTest {\n\n    private List<ProteinSequence> proteins;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private GuideTree<ProteinSequence, AminoAcidCompound> tree;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        proteins = Arrays.asList(new ProteinSequence[] {new ProteinSequence(\"ARND\"), new ProteinSequence(\"ARND\"),\n                new ProteinSequence(\"HILK\"), new ProteinSequence(\"ANDR\")});\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        tree = new GuideTree<ProteinSequence, AminoAcidCompound>(proteins, Alignments.getAllPairsScorers(proteins,\n                PairwiseSequenceScorerType.GLOBAL_IDENTITIES, gaps, blosum62));\n    }\n\n    @Test\n    public void testGuideTree() {\n        assertNotNull(tree);\n    }\n\n    @Test\n    public void testGetAllPairsScores() {\n        assertArrayEquals(tree.getAllPairsScores(), new double[] {4, 0, 3, 0, 3, 0}, 0.00001);\n    }\n\n    @Test\n    public void testGetDistanceMatrix() {\n        assertArrayEquals(tree.getDistanceMatrix(), new double[][] {\n                {0.0, 0.0, 1.0, 0.4},\n                {0.0, 0.0, 1.0, 0.4},\n                {1.0, 1.0, 0.0, 1.0},\n                {0.4, 0.4, 1.0, 0.0}});\n    }\n\n    @Test\n    public void testGetRoot() {\n        assertEquals(Alignments.getProgressiveAlignment(tree, ProfileProfileAlignerType.GLOBAL, gaps,\n                blosum62).toString(), String.format(\"%s%n%s%n%s%n%s%n\",\n                \"--ARND-\",\n                \"--ARND-\",\n                \"HILK---\",\n                \"--A-NDR\"));\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        assertArrayEquals(tree.getScoreMatrix(), new double[][] {\n                {4, 4, 0, 3},\n                {4, 6, 0, 3},\n                {0, 0, 5, 0},\n                {3, 3, 0, 6}});\n    }\n\n    @Test\n    public void testGetSequences() {\n        List<ProteinSequence> list = tree.getSequences();\n        assertEquals(list.size(), 4);\n        assertEquals(list.get(0), proteins.get(0));\n        assertEquals(list.get(1), proteins.get(1));\n        assertEquals(list.get(2), proteins.get(2));\n        assertEquals(list.get(3), proteins.get(3));\n    }\n\n    @Test\n    public void testIterator() {\n        int i = 0;\n        for (GuideTreeNode<ProteinSequence, AminoAcidCompound> n : tree) {\n            switch (i++) {\n            case 0: assertEquals(n.getName(), \"1\"); break;\n            case 1: assertEquals(n.getName(), \"2\"); break;\n            case 2: assertEquals(n.getName(), \"\"); break;\n            case 3: assertEquals(n.getName(), \"3\"); break;\n            case 4: assertEquals(n.getName(), \"\"); break;\n            case 5: assertEquals(n.getName(), \"4\"); break;\n            case 6: assertEquals(n.getName(), \"\"); break;\n            }\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(tree.toString(),\n                \"(((1:0.0,2:0.0):-1.4,3:0.8999999999999999):-0.7,4:-0.7)\");\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on July 7, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.alignment;\n\nimport org.biojava.nbio.core.alignment.matrices.SubstitutionMatrixHelper;\nimport org.biojava.nbio.alignment.Alignments.PairwiseSequenceScorerType;\nimport org.biojava.nbio.alignment.Alignments.ProfileProfileAlignerType;\nimport org.biojava.nbio.alignment.template.GapPenalty;\nimport org.biojava.nbio.alignment.template.GuideTreeNode;\nimport org.biojava.nbio.core.alignment.template.SubstitutionMatrix;\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\npublic class GuideTreeTest {\n\n    private List<ProteinSequence> proteins;\n    private GapPenalty gaps;\n    private SubstitutionMatrix<AminoAcidCompound> blosum62;\n    private GuideTree<ProteinSequence, AminoAcidCompound> tree;\n\n    @Before\n    public void setup() throws CompoundNotFoundException { \n        proteins = Arrays.asList(new ProteinSequence[] {new ProteinSequence(\"ARND\"), new ProteinSequence(\"ARND\"),\n                new ProteinSequence(\"HILK\"), new ProteinSequence(\"ANDR\")});\n        gaps = new SimpleGapPenalty((short) 2, (short) 1);\n        blosum62 = SubstitutionMatrixHelper.getBlosum62();\n        tree = new GuideTree<ProteinSequence, AminoAcidCompound>(proteins, Alignments.getAllPairsScorers(proteins,\n                PairwiseSequenceScorerType.GLOBAL_IDENTITIES, gaps, blosum62));\n    }\n\n    @Test\n    public void testGuideTree() {\n        assertNotNull(tree);\n    }\n\n    @Test\n    public void testGetAllPairsScores() {\n        assertArrayEquals(tree.getAllPairsScores(), new double[] {4, 0, 3, 0, 3, 0}, 0.00001);\n    }\n\n    @Test\n    public void testGetDistanceMatrix() {\n        assertArrayEquals(tree.getDistanceMatrix(), new double[][] {\n                {0.0, 0.0, 1.0, 0.4},\n                {0.0, 0.0, 1.0, 0.4},\n                {1.0, 1.0, 0.0, 1.0},\n                {0.4, 0.4, 1.0, 0.0}});\n    }\n\n    @Test\n    public void testGetRoot() {\n        assertEquals(Alignments.getProgressiveAlignment(tree, ProfileProfileAlignerType.GLOBAL, gaps,\n                blosum62).toString(), String.format(\"%s%n%s%n%s%n%s%n\",\n                \"--ARND-\",\n                \"--ARND-\",\n                \"HILK---\",\n                \"--A-NDR\"));\n    }\n\n    @Test\n    public void testGetScoreMatrix() {\n        assertArrayEquals(tree.getScoreMatrix(), new double[][] {\n                {4, 4, 0, 3},\n                {4, 6, 0, 3},\n                {0, 0, 5, 0},\n                {3, 3, 0, 6}});\n    }\n\n    @Test\n    public void testGetSequences() {\n        List<ProteinSequence> list = tree.getSequences();\n        assertEquals(list.size(), 4);\n        assertEquals(list.get(0), proteins.get(0));\n        assertEquals(list.get(1), proteins.get(1));\n        assertEquals(list.get(2), proteins.get(2));\n        assertEquals(list.get(3), proteins.get(3));\n    }\n\n    @Test\n    public void testIterator() {\n        int i = 0;\n        for (GuideTreeNode<ProteinSequence, AminoAcidCompound> n : tree) {\n            switch (i++) {\n            case 0: assertEquals(n.getName(), \"1\"); break;\n            case 1: assertEquals(n.getName(), \"2\"); break;\n            case 2: assertEquals(n.getName(), \"\"); break;\n            case 3: assertEquals(n.getName(), \"3\"); break;\n            case 4: assertEquals(n.getName(), \"\"); break;\n            case 5: assertEquals(n.getName(), \"4\"); break;\n            case 6: assertEquals(n.getName(), \"\"); break;\n            }\n        }\n    }\n\n    @Test\n    public void testToString() {\n        assertEquals(tree.toString(),\n                \"(((1:0.0,2:0.0):-1.4,3:0.8999999999999999):-0.7,4:-0.7)\");\n    }\n\n}\n","commitMessage":"Massive refactoring: moved alignment data structures from biojava-alignment to biojava-core.\nMantaining main biological data structures in core will help to avoid problems of unwanted dependency. Unfortunately the substitution matrices related classes are tight coupled with SimpleSequencePair class and were moved too from alignment.\n\nUpdated pom file to remove dependency of core from alignment module temporary added by first implementation of SearchIO.\n","test_commitMessage":"Massive refactoring: moved alignment data structures from biojava-alignment to biojava-core.\nMantaining main biological data structures in core will help to avoid problems of unwanted dependency. Unfortunately the substitution matrices related classes are tight coupled with SimpleSequencePair class and were moved too from alignment.\n\nUpdated pom file to remove dependency of core from alignment module temporary added by first implementation of SearchIO.\n","allZero":false}