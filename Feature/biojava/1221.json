{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleProfile.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleProfileTest.java","prod_time":"2010-06-25 03:11:08","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":8,"add_classname_line":0,"add_condition_line":1,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f163c3fe142c016707cfba2d9673a0f6db857b58","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfileView;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Profile<S, C> {\n\n    private List<AlignedSequence<C>> list;\n    private List<S> originals;\n    private int length;\n\n    /**\n     * Creates a pair profile for the given sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    public SimpleProfile(S query, S target, List<Step> sx, List<Step> sy) {\n        if (sx.size() != sy.size()) {\n            throw new IllegalArgumentException(\"Alignments differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<C>>();\n        list.add(new SimpleAlignedSequence<C>(query, sx));\n        list.add(new SimpleAlignedSequence<C>(target, sy));\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.add(query);\n        originals.add(target);\n        originals = Collections.unmodifiableList(originals);\n        length = sx.size();\n    }\n\n    @Override\n    public AlignedSequence<C> getAlignedSequence(int listIndex) {\n        return list.get(listIndex - 1);\n    }\n\n    @Override\n    public AlignedSequence<C> getAlignedSequence(S sequence) {\n        for (AlignedSequence<C> s : list) {\n            if (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n                return s;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences() {\n        return list;\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences(int... listIndices) {\n        List<AlignedSequence<C>> tempList = new ArrayList<AlignedSequence<C>>();\n        for (int i : listIndices) {\n            tempList.add(getAlignedSequence(i));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences(S... sequences) {\n        List<AlignedSequence<C>> tempList = new ArrayList<AlignedSequence<C>>();\n        for (S s : sequences) {\n            tempList.add(getAlignedSequence(s));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public C getCompoundAt(int listIndex, int alignmentIndex) {\n        return getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public C getCompoundAt(S sequence, int alignmentIndex) {\n        AlignedSequence<C> s = getAlignedSequence(sequence);\n        return (s == null) ? null : s.getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return list.get(0).getCompoundSet();\n    }\n\n    @Override\n    public List<C> getCompoundsAt(int alignmentIndex) {\n        // TODO handle circular alignments\n        List<C> column = new ArrayList<C>();\n        for (AlignedSequence<C> s : list) {\n            column.add(s.getCompoundAt(alignmentIndex));\n        }\n        return Collections.unmodifiableList(column);\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int[] getIndicesAt(int alignmentIndex) {\n        int[] indices = new int[list.size()];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n        }\n        return indices;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public List<S> getOriginalSequences() {\n        return originals;\n    }\n\n    @Override\n    public int getSize() {\n        int size = 0;\n        for (AlignedSequence<C> s : list) {\n            size += s.getOverlapCount();\n        }\n        return size;\n    }\n\n    @Override\n    public ProfileView<S, C> getSubProfile(Location location) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public boolean isCircular() {\n        for (AlignedSequence<C> s : list) {\n            if (s.isCircular()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString(int width) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        // TODO handle circular alignments\n        StringBuilder s = new StringBuilder();\n        String newLine = System.getProperty(\"line.separator\");\n        for (AlignedSequence<C> as : list) {\n            s.append(as.toString() + newLine);\n        }\n        return s.toString();\n    }\n\n    @Override\n    public Iterator<AlignedSequence<C>> iterator() {\n        return list.iterator();\n    }\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 14, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.alignment.template.ProfileView;\nimport org.biojava3.core.sequence.location.template.Location;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\nimport org.biojava3.core.sequence.template.Sequence;\n\n/**\n * Implements a data structure for the results of sequence alignment.  Every {@link List} returned is unmodifiable.\n *\n * @author Mark Chapman\n * @param <S> each element of the alignment {@link Profile} is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n */\npublic class SimpleProfile<S extends Sequence<C>, C extends Compound> implements Profile<S, C> {\n\n    private List<AlignedSequence<C>> list;\n    private List<S> originals;\n    private int length;\n\n    /**\n     * Creates a pair profile for the given sequences.\n     *\n     * @param query the first sequence of the pair\n     * @param target the second sequence of the pair\n     * @param sx lists whether the query sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target sequence aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given sequences do not fit in alignments\n     */\n    protected SimpleProfile(S query, S target, List<Step> sx, List<Step> sy) {\n        if (sx.size() != sy.size()) {\n            throw new IllegalArgumentException(\"Alignments differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<C>>();\n        list.add(new SimpleAlignedSequence<C>(query, sx));\n        list.add(new SimpleAlignedSequence<C>(target, sy));\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.add(query);\n        originals.add(target);\n        originals = Collections.unmodifiableList(originals);\n        length = sx.size();\n    }\n\n    /**\n     * Creates a pair profile for the given profiles.\n     *\n     * @param query the first profile of the pair\n     * @param target the second profile of the pair\n     * @param sx lists whether the query profile aligns a {@link Compound} or gap at each index of the alignment\n     * @param sy lists whether the target profile aligns a {@link Compound} or gap at each index of the alignment\n     * @throws IllegalArgumentException if alignments differ in size or given profiles do not fit in alignments\n     */\n    protected SimpleProfile(Profile<S, C> query, Profile<S, C> target, List<Step> sx, List<Step> sy) {\n        // TODO SimpleProfile(Profile<S, C>, Profile<S, C>, List<Step>, List<Step>)\n        if (sx.size() != sy.size()) {\n            throw new IllegalArgumentException(\"Alignments differ in size\");\n        }\n        list = new ArrayList<AlignedSequence<C>>();\n        for (AlignedSequence<C> s : query) {\n            list.add(new SimpleAlignedSequence<C>(s, sx));\n        }\n        for (AlignedSequence<C> s : target) {\n            list.add(new SimpleAlignedSequence<C>(s, sy));\n        }\n        list = Collections.unmodifiableList(list);\n        originals = new ArrayList<S>();\n        originals.addAll(query.getOriginalSequences());\n        originals.addAll(target.getOriginalSequences());\n        originals = Collections.unmodifiableList(originals);\n        length = sx.size();\n    }\n\n    @Override\n    public AlignedSequence<C> getAlignedSequence(int listIndex) {\n        return list.get(listIndex - 1);\n    }\n\n    @Override\n    public AlignedSequence<C> getAlignedSequence(S sequence) {\n        for (AlignedSequence<C> s : list) {\n            if (s.equals(sequence) || s.getOriginalSequence().equals(sequence)) {\n                return s;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences() {\n        return list;\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences(int... listIndices) {\n        List<AlignedSequence<C>> tempList = new ArrayList<AlignedSequence<C>>();\n        for (int i : listIndices) {\n            tempList.add(getAlignedSequence(i));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public List<AlignedSequence<C>> getAlignedSequences(S... sequences) {\n        List<AlignedSequence<C>> tempList = new ArrayList<AlignedSequence<C>>();\n        for (S s : sequences) {\n            tempList.add(getAlignedSequence(s));\n        }\n        return Collections.unmodifiableList(tempList);\n    }\n\n    @Override\n    public C getCompoundAt(int listIndex, int alignmentIndex) {\n        return getAlignedSequence(listIndex).getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public C getCompoundAt(S sequence, int alignmentIndex) {\n        AlignedSequence<C> s = getAlignedSequence(sequence);\n        return (s == null) ? null : s.getCompoundAt(alignmentIndex);\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return list.get(0).getCompoundSet();\n    }\n\n    @Override\n    public List<C> getCompoundsAt(int alignmentIndex) {\n        // TODO handle circular alignments\n        List<C> column = new ArrayList<C>();\n        for (AlignedSequence<C> s : list) {\n            column.add(s.getCompoundAt(alignmentIndex));\n        }\n        return Collections.unmodifiableList(column);\n    }\n\n    @Override\n    public int getIndexOf(C compound) {\n        for (int i = 1; i <= length; i++) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int[] getIndicesAt(int alignmentIndex) {\n        int[] indices = new int[list.size()];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = list.get(i).getSequenceIndexAt(alignmentIndex);\n        }\n        return indices;\n    }\n\n    @Override\n    public int getLastIndexOf(C compound) {\n        for (int i = length; i >= 1; i--) {\n            if (getCompoundsAt(i).contains(compound)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    @Override\n    public int getLength() {\n        return length;\n    }\n\n    @Override\n    public List<S> getOriginalSequences() {\n        return originals;\n    }\n\n    @Override\n    public int getSize() {\n        int size = 0;\n        for (AlignedSequence<C> s : list) {\n            size += s.getOverlapCount();\n        }\n        return size;\n    }\n\n    @Override\n    public ProfileView<S, C> getSubProfile(Location location) {\n        // TODO ProfileView<S, C> getSubProfile(Location)\n        return null;\n    }\n\n    @Override\n    public boolean isCircular() {\n        for (AlignedSequence<C> s : list) {\n            if (s.isCircular()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString(int width) {\n        // TODO String toString(int)\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        // TODO handle circular alignments\n        StringBuilder s = new StringBuilder();\n        String newLine = System.getProperty(\"line.separator\");\n        for (AlignedSequence<C> as : list) {\n            s.append(as.toString() + newLine);\n        }\n        return s.toString();\n    }\n\n    @Override\n    public Iterator<AlignedSequence<C>> iterator() {\n        return list.iterator();\n    }\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 15, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.AlignedSequence.Step;\nimport org.biojava3.alignment.template.Profile;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class SimpleProfileTest {\n\n    private ProteinSequence query, target;\n    private Profile<ProteinSequence, AminoAcidCompound> profile;\n\n    @Before\n    public void setup() {\n        query = new ProteinSequence(\"ARND\");\n        target = new ProteinSequence(\"RDG\");\n        profile = new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), Arrays.asList(new Step[] {\n                Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND, Step.COMPOUND}));\n    }\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testSimpleProfile() {\n        new SimpleProfile<ProteinSequence, AminoAcidCompound>(query, target, Arrays.asList(new Step[] {\n                Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.COMPOUND, Step.GAP}), Arrays.asList(new Step[] {\n                Step.GAP, Step.COMPOUND, Step.GAP, Step.COMPOUND}));\n    }\n\n    @Test\n    public void testGetAlignedSequenceInt() {\n        assertEquals(profile.getAlignedSequence(1).toString(), \"ARND-\");\n        assertEquals(profile.getAlignedSequence(2).toString(), \"-R-DG\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds() {\n        profile.getAlignedSequence(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetAlignedSequenceIntOutOfBounds2() {\n        profile.getAlignedSequence(3);\n    }\n\n    @Test\n    public void testGetAlignedSequenceS() {\n        assertEquals(profile.getAlignedSequence(query).toString(), \"ARND-\");\n        assertEquals(profile.getAlignedSequence(target).toString(), \"-R-DG\");\n        assertNull(profile.getAlignedSequence(new ProteinSequence(\"AR\")));\n    }\n\n    @Test\n    public void testGetAlignedSequences() {\n        List<AlignedSequence<AminoAcidCompound>> list = profile.getAlignedSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"-R-DG\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesIntArray() {\n        List<AlignedSequence<AminoAcidCompound>> list = profile.getAlignedSequences(2, 1, 2);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"-R-DG\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n    }\n\n    @Test\n    public void testGetAlignedSequencesSArray() {\n        List<AlignedSequence<AminoAcidCompound>> list = profile.getAlignedSequences(query, query, target);\n        assertEquals(list.size(), 3);\n        assertEquals(list.get(0).toString(), \"ARND-\");\n        assertEquals(list.get(1).toString(), \"ARND-\");\n        assertEquals(list.get(2).toString(), \"-R-DG\");\n    }\n\n    @Test\n    public void testGetCompoundAtIntInt() {\n        assertEquals(profile.getCompoundAt(1, 4).getShortName(), \"D\");\n        assertEquals(profile.getCompoundAt(2, 3).getShortName(), \"-\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds() {\n        profile.getCompoundAt(0, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds2() {\n        profile.getCompoundAt(3, 4);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds3() {\n        profile.getCompoundAt(1, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtIntIntOutOfBounds4() {\n        profile.getCompoundAt(2, 6);\n    }\n\n    @Test\n    public void testGetCompoundAtSInt() {\n        assertEquals(profile.getCompoundAt(query, 2).getShortName(), \"R\");\n        assertEquals(profile.getCompoundAt(target, 5).getShortName(), \"G\");\n        assertNull(profile.getCompoundAt(new ProteinSequence(\"AR\"), 3));\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds() {\n        profile.getCompoundAt(query, 0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundAtSIntOutOfBounds2() {\n        profile.getCompoundAt(target, 6);\n    }\n\n    @Test\n    public void testGetCompoundSet() {\n        assertEquals(profile.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n    }\n\n    @Test\n    public void testGetCompoundsAt() {\n        List<AminoAcidCompound> column = profile.getCompoundsAt(5);\n        assertEquals(column.size(), 2);\n        assertEquals(column.get(0).getShortName(), \"-\");\n        assertEquals(column.get(1).getShortName(), \"G\");\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds() {\n        profile.getCompoundsAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetCompoundsAtOutOfBounds2() {\n        profile.getCompoundsAt(6);\n    }\n\n    @Test\n    public void testGetIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"-\")), 1);\n        assertEquals(profile.getIndexOf(cs.getCompoundForString(\"E\")), -1);\n    }\n\n    @Test\n    public void testGetIndicesAt() {\n        assertArrayEquals(profile.getIndicesAt(1), new int[] {1, 1});\n        assertArrayEquals(profile.getIndicesAt(2), new int[] {2, 1});\n        assertArrayEquals(profile.getIndicesAt(3), new int[] {3, 1});\n        assertArrayEquals(profile.getIndicesAt(4), new int[] {4, 2});\n        assertArrayEquals(profile.getIndicesAt(5), new int[] {4, 3});\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds() {\n        profile.getIndicesAt(0);\n    }\n\n    @Test(expected=IndexOutOfBoundsException.class)\n    public void testGetIndicesAtOutOfBounds2() {\n        profile.getIndicesAt(6);\n    }\n\n    @Test\n    public void testGetLastIndexOf() {\n        AminoAcidCompoundSet cs = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"A\")), 1);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"R\")), 2);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"N\")), 3);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"D\")), 4);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"G\")), 5);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"-\")), 5);\n        assertEquals(profile.getLastIndexOf(cs.getCompoundForString(\"E\")), -1);\n    }\n\n    @Test\n    public void testGetLength() {\n        assertEquals(profile.getLength(), 5);\n    }\n\n    @Test\n    public void testGetOriginalSequences() {\n        List<ProteinSequence> list = profile.getOriginalSequences();\n        assertEquals(list.size(), 2);\n        assertEquals(list.get(0), query);\n        assertEquals(list.get(1), target);\n    }\n\n    @Test\n    public void testGetSize() {\n        assertEquals(profile.getSize(), 2);\n    }\n\n    @Ignore // TODO SimpleProfile.getSubProfile(Location)\n    @Test\n    public void testGetSubProfile() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testIsCircular() {\n        assertFalse(profile.isCircular());\n    }\n\n    @Ignore // TODO SimpleProfile.toString(int)\n    @Test\n    public void testToStringInt() {\n        fail(\"Not yet implemented\");\n    }\n\n    @Test\n    public void testToString() {\n        String newLine = System.getProperty(\"line.separator\");\n        assertEquals(profile.toString(), \"ARND-\" + newLine + \"-R-DG\" + newLine);\n    }\n\n    @Test\n    public void testIterator() {\n        for (AlignedSequence<AminoAcidCompound> s : profile) {\n            assertEquals(s.toString().length(), 5);\n        }\n    }\n\n}\n","changedTest":"","commitMessage":"updates for profile-profile alignments\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8023 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}