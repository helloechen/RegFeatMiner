{"repository":"biojava","prod_path":"biojava3-protmod/src/main/java/org/biojava3/protmod/structure/ProteinModificationParser.java","test_path":"biojava3-protmod/src/test/java/org/biojava3/protmod/structure/ProteinModificationParserTest.java","prod_time":"2010-08-03 07:43:04","test_time":"2010-08-03 07:43:04","type":"RENAME","proType":"RENAME","add_annotation_line":0,"add_call_line":30,"add_classname_line":1,"add_condition_line":4,"add_field_line":3,"add_import_line":0,"add_packageid_line":1,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":1,"del_call_line":51,"del_classname_line":2,"del_condition_line":9,"del_field_line":3,"del_import_line":7,"del_packageid_line":1,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ff36adf92b7aea3c26537e83c1b5886a5cc1c706","test_commitID":"ff36adf92b7aea3c26537e83c1b5886a5cc1c706","isfound":"found test change","originPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 12, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.GroupType;\r\nimport org.biojava.bio.structure.PDBResidueNumber;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\nimport org.biojava.bio.structure.StructureTools;\r\nimport org.biojava.bio.structure.io.mmcif.chem.ResidueType;\r\nimport org.biojava.bio.structure.io.mmcif.chem.PolymerType;\r\nimport org.biojava.bio.structure.io.mmcif.model.ChemComp;\r\n\r\nimport org.biojava3.protmod.Component;\r\nimport org.biojava3.protmod.ComponentType;\r\nimport org.biojava3.protmod.ModificationCondition;\r\nimport org.biojava3.protmod.ModificationLinkage;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ModifiedCompoundImpl;\r\nimport org.biojava3.protmod.PDBAtom;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * Identify attachment modification in a 3-D structure.\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class DefaultProteinModificationParser\r\nimplements ProteinModificationParser {\r\n\t\r\n\tprivate double bondLengthTolerance = 0.4;\r\n\tprivate boolean recordUnidentifiableModifiedCompounds = false;\r\n\t\r\n\tprivate List<ModifiedCompound> identifiedModifiedCompounds = null;\r\n\tprivate List<PDBAtom[]> unidentifiableAtomLinkages = null;\r\n\tprivate List<PDBResidueNumber> unidentifiableModifiedResidues = null;\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bondLengthTolerance tolerance of error (in Angstroms) of the\r\n\t *  covalent bond length, when calculating the atom distance threshold.\r\n\t */\r\n\tpublic void setbondLengthTolerance(final double bondLengthTolerance) {\r\n\t\tif (bondLengthTolerance<0) {\r\n\t\t\tthrow new IllegalArgumentException(\"bondLengthTolerance \" +\r\n\t\t\t\t\t\"must be positive.\");\r\n\t\t}\r\n\t\tthis.bondLengthTolerance = bondLengthTolerance;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param recordUnidentifiableAtomLinkages true if choosing to record unidentifiable\r\n\t *  atoms; false, otherwise.\r\n\t */\r\n\tpublic void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds) {\r\n\t\tthis.recordUnidentifiableModifiedCompounds = recordUnidentifiableModifiedCompounds;\r\n\t}\r\n\t\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\tpublic List<ModifiedCompound> getIdentifiedModifiedCompound() {\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn identifiedModifiedCompounds;\r\n\t}\r\n\t\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\tpublic List<PDBAtom[]> getUnidentifiableAtomLinkages() {\r\n\t\tif (!recordUnidentifiableModifiedCompounds) {\r\n\t\t\tthrow new UnsupportedOperationException(\"Recording unidentified atom linkages\" +\r\n\t\t\t\t\t\"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn unidentifiableAtomLinkages;\r\n\t}\r\n\t\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t */\r\n\tpublic List<PDBResidueNumber> getUnidentifiableModifiedResidues() {\r\n\t\tif (!recordUnidentifiableModifiedCompounds) {\r\n\t\t\tthrow new UnsupportedOperationException(\"Recording unidentified atom linkages\" +\r\n\t\t\t\t\t\"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn unidentifiableModifiedResidues;\r\n\t}\r\n\t\r\n\t/**\r\n\t * {@inheritDoc}\r\n\t * @throws IllegalArgumentException if null structure or\r\n\t *  potentialModification.\r\n\t */\r\n\t@Override\r\n\tpublic void parse(final Structure structure, \r\n\t\t\tfinal Set<ProteinModification> potentialModifications) {\r\n\t\tidentifiedModifiedCompounds = new ArrayList<ModifiedCompound>();\r\n\t\tif (recordUnidentifiableModifiedCompounds) {\r\n\t\t\tunidentifiableAtomLinkages = new ArrayList<PDBAtom[]>();\r\n\t\t\tunidentifiableModifiedResidues = new ArrayList<PDBResidueNumber>();\r\n\t\t}\r\n\t\t\r\n\t\tif (structure==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null structure.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null potentialModifications.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications.isEmpty()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tList<Chain> chains = structure.getChains();\r\n\t\t\r\n\t\tfor (Chain chain : chains) {\r\n\t\t\tList<ModifiedCompound> modComps = new ArrayList<ModifiedCompound>();\r\n\t\t\t\r\n\t\t\tList<Group> residues = getAminoAcids(chain);\r\n\t\t\tList<Group> ligands = chain.getAtomLigands();\r\n\t\t\t\r\n\t\t\tMap<Component, Set<Group>> mapCompGroups = \r\n\t\t\t\tgetModificationGroups(potentialModifications, residues, ligands);\r\n\t\t\t\r\n\t\t\tfor (ProteinModification mod : potentialModifications) {\r\n\t\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\t\tList<Component> components = condition.getComponents();\r\n\t\t\t\tif (!mapCompGroups.keySet().containsAll(components)) {\r\n\t\t\t\t\t// not all components exist for this mod.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tint sizeComps = components.size();\r\n\t\t\t\tif (sizeComps==1) {\r\n\t\t\t\t\t// modified residue\r\n\t\t\t\t\t// TODO: is this the correct logic for CROSS_LINK_1?\r\n\t\t\t\t\tSet<Group> modifiedResidues = mapCompGroups.get(components.get(0));\r\n\t\t\t\t\tif (modifiedResidues != null) {\r\n\t\t\t\t\t\tfor (Group residue : modifiedResidues) {\r\n\t\t\t\t\t\t\tPDBResidueNumber resNum = StructureTools.getPDBResidueNumber(residue);\r\n\t\t\t\t\t\t\tModifiedCompound modRes = new ModifiedCompoundImpl(mod, resNum);\r\n\t\t\t\t\t\t\tmodComps.add(modRes);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// for multiple components\r\n\t\t\t\t\t\r\n\t\t\t\t\t// find linkages first\r\n\t\t\t\t\tList<List<Atom[]>> matchedAtomsOfLinkages =\r\n\t\t\t\t\t\t\tgetMatchedAtomsOfLinkages(condition, mapCompGroups);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (matchedAtomsOfLinkages.size() != condition.getLinkages().size()) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tassembleLinkages(matchedAtomsOfLinkages, mod, modComps);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// identify additional groups that are not directly attached to amino acids.\r\n\t\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\t\tidentifyAdditionalAttachments(mc, ligands, chain);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tidentifiedModifiedCompounds.addAll(modComps);\r\n\t\t\t\r\n\t\t\t// record unidentifiable linkage\r\n\t\t\tif (recordUnidentifiableModifiedCompounds) {\r\n\t\t\t\trecordUnidentifiableAtomLinkages(modComps, residues, ligands);\r\n\t\t\t\trecordUnidentifiableModifiedResidues(modComps, residues);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// TODO: this should be replaced when Andreas fix the getAtomGroups(\"amino\");\r\n\t/**\r\n\t * Get all amino acids in a chain.\r\n\t * @param chain\r\n\t * @return\r\n\t */\r\n\tprivate List<Group> getAminoAcids(Chain chain) {\r\n//\t\tList<Group> residues = new ArrayList<Group>();\r\n//\t\tfor (Group group : chain.getAtomGroups()) {\r\n//\t\t\tChemComp cc = group.getChemComp();\r\n//\t\t\tif (ResidueType.lPeptideLinking.equals(cc.getResidueType()) ||\r\n//\t\t\t\t\tPolymerType.PROTEIN_ONLY.contains(cc.getPolymerType())) {\r\n//\t\t\t\tresidues.add(group);\r\n//\t\t\t}\r\n//\t\t}\r\n\t\tList<Group> residues = new ArrayList<Group>(chain.getSeqResGroups());\r\n\t\tresidues.retainAll(chain.getAtomGroups());\r\n\t\t\r\n\t\treturn residues;\r\n\t}\r\n\t\r\n\t/**\r\n\t * identify additional groups that are not directly attached to amino acids.\r\n\t * @param mc {@link ModifiedCompound}.\r\n\t * @param chain a {@link Chain}.\r\n\t * @return a list of added groups.\r\n\t */\r\n\tprivate void identifyAdditionalAttachments(ModifiedCompound mc, \r\n\t\t\tList<Group> ligands, Chain chain) {\r\n\t\tif (ligands.isEmpty()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: should the additional groups only be allowed to the identified \r\n\t\t// heta groups or both amino acids and heta groups?\r\n\t\t// TODO: how about chain-chain links?\r\n\t\tList<Group> identifiedGroups = new ArrayList<Group>();\r\n\t\tfor (PDBResidueNumber num : mc.getLigands()) {\r\n\t\t\tGroup group;\r\n\t\t\ttry {\r\n\t\t\t\tString numIns = \"\" + num.getResidueNumber();\r\n\t\t\t\tif (num.getInsCode() != null) {\r\n\t\t\t\t\tnumIns += num.getInsCode();\r\n\t\t\t\t}\r\n\t\t\t\tgroup = chain.getGroupByPDB(numIns);\r\n\t\t\t} catch (StructureException e) {\r\n\t\t\t\t// should not happen\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tidentifiedGroups.add(group);\r\n\t\t}\r\n\t\t\r\n\t\tint start = 0;\r\n\t\t\r\n\t\tint n = identifiedGroups.size();\r\n\t\twhile (n > start) {\r\n\t\t\tfor (Group group1 : ligands) {\r\n\t\t\t\tfor (int i=start; i<n; i++) {\r\n\t\t\t\t\tGroup group2 = identifiedGroups.get(i);\r\n\t\t\t\t\tif (!identifiedGroups.contains(group1)) {\r\n\t\t\t\t\t\tList<Atom[]> linkages = ProteinModificationParserUtil.\r\n\t\t\t\t\t\t\t\tfindNonNCAtomLinkages(group1, false, group2, false, bondLengthTolerance);\r\n\t\t\t\t\t\tif (!linkages.isEmpty()) {\r\n\t\t\t\t\t\t\tfor (Atom[] linkage : linkages) {\r\n\t\t\t\t\t\t\t\tPDBResidueNumber residue1 = StructureTools\r\n\t\t\t\t\t\t\t\t\t.getPDBResidueNumber(linkage[0].getParent());\r\n\t\t\t\t\t\t\t\tString atom1 = linkage[0].getName();\r\n\t\t\t\t\t\t\t\tPDBResidueNumber residue2 = StructureTools\r\n\t\t\t\t\t\t\t\t\t.getPDBResidueNumber(linkage[1].getParent());\r\n\t\t\t\t\t\t\t\tString atom2 = linkage[1].getName();\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tmc.addGroup(residue1, false);\r\n\t\t\t\t\t\t\t\tmc.addAtomLinkage(\r\n\t\t\t\t\t\t\t\t\t\tnew PDBAtom(residue1, atom1), \r\n\t\t\t\t\t\t\t\t\t\tnew PDBAtom(residue2, atom2));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidentifiedGroups.add(group1);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart = n;\r\n\t\t\tn = identifiedGroups.size();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Record unidentifiable atom linkages in a chain. Only linkages between two\r\n\t * residues or one residue and one ligand will be recorded.\r\n\t */\r\n\tprivate void recordUnidentifiableAtomLinkages(List<ModifiedCompound> modComps,\r\n\t\t\tList<Group> residues, List<Group> ligands) {\r\n\t\t\r\n\t\t// first put identified linkages in a map for fast query\r\n\t\tMap<PDBAtom, Set<PDBAtom>> identifiedLinkages = new HashMap<PDBAtom, Set<PDBAtom>>();\r\n\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\tList<PDBAtom[]> linkages = mc.getAtomLinkages();\r\n\t\t\tfor (PDBAtom[] linkage : linkages) {\r\n\t\t\t\tSet<PDBAtom> set = identifiedLinkages.get(linkage[0]);\r\n\t\t\t\tif (set == null) {\r\n\t\t\t\t\tset = new HashSet<PDBAtom>();\r\n\t\t\t\t\tidentifiedLinkages.put(linkage[0], set);\r\n\t\t\t\t}\r\n\t\t\t\tset.add(linkage[1]);\r\n\t\t\t\t\r\n\t\t\t\tset = identifiedLinkages.get(linkage[1]);\r\n\t\t\t\tif (set == null) {\r\n\t\t\t\t\tset = new HashSet<PDBAtom>();\r\n\t\t\t\t\tidentifiedLinkages.put(linkage[1], set);\r\n\t\t\t\t}\r\n\t\t\t\tset.add(linkage[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// record\r\n\t\t// cross link\r\n\t\tint nRes = residues.size();\r\n\t\tfor (int i=0; i<nRes-1; i++) {\r\n\t\t\tGroup group1 = residues.get(i);\r\n\t\t\tfor (int j=i+1; j<nRes; j++) {\r\n\t\t\t\tGroup group2 = residues.get(j);\r\n\t\t\t\tList<Atom[]> linkages = ProteinModificationParserUtil.\r\n\t\t\t\t\t\tfindNonNCAtomLinkages(group1, true, group2, true, bondLengthTolerance);\r\n\t\t\t\tfor (Atom[] linkage : linkages) {\r\n\t\t\t\t\tPDBAtom atom1 = new PDBAtom(\r\n\t\t\t\t\t\t\tStructureTools.getPDBResidueNumber(group1),\r\n\t\t\t\t\t\t\tlinkage[0].getName());\r\n\t\t\t\t\tPDBAtom atom2 = new PDBAtom(\r\n\t\t\t\t\t\t\tStructureTools.getPDBResidueNumber(group2),\r\n\t\t\t\t\t\t\tlinkage[1].getName());\r\n\t\t\t\t\t\r\n\t\t\t\t\tSet<PDBAtom> set = identifiedLinkages.get(atom1);\r\n\t\t\t\t\tif (set == null || !set.contains(atom2)) {\r\n\t\t\t\t\t\tunidentifiableAtomLinkages.add(new PDBAtom[]{atom1, atom2});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// attachment\r\n\t\tint nLig = ligands.size();\r\n\t\tfor (int i=0; i<nRes; i++) {\r\n\t\t\tGroup group1 = residues.get(i);\r\n\t\t\tfor (int j=0; j<nLig; j++) {\r\n\t\t\t\tGroup group2 = ligands.get(j);\r\n\t\t\t\tif (group1==group2) { // overlap between residues and ligands\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tList<Atom[]> linkages = ProteinModificationParserUtil.\r\n\t\t\t\t\t\tfindNonNCAtomLinkages(group1, true, group2, false, bondLengthTolerance);\r\n\t\t\t\tfor (Atom[] linkage : linkages) {\r\n\t\t\t\t\tPDBAtom atom1 = new PDBAtom(\r\n\t\t\t\t\t\t\tStructureTools.getPDBResidueNumber(group1),\r\n\t\t\t\t\t\t\tlinkage[0].getName());\r\n\t\t\t\t\tPDBAtom atom2 = new PDBAtom(\r\n\t\t\t\t\t\t\tStructureTools.getPDBResidueNumber(group2),\r\n\t\t\t\t\t\t\tlinkage[1].getName());\r\n\t\t\t\t\t\r\n\t\t\t\t\tSet<PDBAtom> set = identifiedLinkages.get(atom1);\r\n\t\t\t\t\tif (set == null || !set.contains(atom2)) {\r\n\t\t\t\t\t\tunidentifiableAtomLinkages.add(new PDBAtom[]{atom1, atom2});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void recordUnidentifiableModifiedResidues(List<ModifiedCompound> modComps, List<Group> residues) {\r\n\t\tSet<PDBResidueNumber> identifiedComps = new HashSet<PDBResidueNumber>();\r\n\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\tidentifiedComps.addAll(mc.getResidues());\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: use the ModifiedAminoAcid after Andreas add that.\r\n\t\tfor (Group group : residues) {\r\n\t\t\tif (group.getType().equals(GroupType.HETATM)) {\r\n\t\t\t\tPDBResidueNumber resNum = StructureTools.getPDBResidueNumber(group);\r\n\t\t\t\tif (!identifiedComps.contains(resNum)) {\r\n\t\t\t\t\tunidentifiableModifiedResidues.add(resNum);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param modifications a set of {@link ProteinModification}s.\r\n\t * @param residues\r\n\t * @param ligands \r\n\t * @return map from component to list of corresponding residues\r\n\t *  in the chain.\r\n\t */\r\n\tprivate Map<Component, Set<Group>> getModificationGroups(\r\n\t\t\tfinal Set<ProteinModification> modifications,\r\n\t\t\tfinal List<Group> residues,\r\n\t\t\tfinal List<Group> ligands) {\r\n\t\tif (residues==null || ligands==null || modifications==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\r\n\t\t}\r\n\t\t\r\n\t\tSet<Component> comps = new HashSet<Component>();\r\n\t\tfor (ProteinModification mod : modifications) {\r\n\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\tfor (Component comp : condition.getComponents()) {\r\n\t\t\t\tcomps.add(comp);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tMap<Component, Set<Group>> mapCompRes = \r\n\t\t\tnew HashMap<Component, Set<Group>>();\r\n\t\t\r\n\t\t{\r\n\t\t\t// ligands\r\n\t\t\tfor (Group group : ligands) {\r\n\t\t\t\tString pdbccId = group.getPDBName().trim();\r\n\t\t\t\tComponent comp = Component.of(pdbccId, ComponentType.LIGAND);\r\n\t\t\t\tif (!comps.contains(comp)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\tif (gs==null) {\r\n\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t}\r\n\t\t\t\tgs.add(group);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t{\r\n\t\t\t// residues\r\n\t\t\tif (residues.isEmpty()) {\r\n\t\t\t\treturn mapCompRes;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// for all residues\r\n\t\t\tfor (Group group : residues) {\r\n\t\t\t\tString pdbccId = group.getPDBName().trim();\r\n\t\t\t\tComponent comp = Component.of(pdbccId, ComponentType.AMINOACID);\r\n\t\t\t\tif (!comps.contains(comp)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\tif (gs==null) {\r\n\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t}\r\n\t\t\t\tgs.add(group);\r\n\t\t\t}\r\n\r\n\t\t\t// for N-terminal\r\n\t\t\tint nRes = residues.size();\r\n\t\t\tint iRes = 0;\r\n\t\t\tGroup res;\r\n\t\t\tdo {\r\n\t\t\t\t// for all ligands on N terminal and the first residue\r\n\t\t\t\tres = residues.get(iRes++);\r\n\r\n\t\t\t\tComponent comp = Component.of(res.getPDBName(), ComponentType.AMINOACID, true, false);\r\n\t\t\t\tif (comps.contains(comp)) {\r\n\t\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\t\tif (gs==null) {\r\n\t\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgs.add(res);\r\n\t\t\t\t}\r\n\t\t\t} while (iRes<nRes && ligands.contains(res));\r\n\t\t\t\r\n\t\t\t// for C-terminal\r\n\t\t\tiRes = residues.size()-1;\r\n\t\t\tdo {\r\n\t\t\t\t// for all ligands on C terminal and the last residue\r\n\t\t\t\tres = residues.get(iRes--);\r\n\t\t\t\t\r\n\t\t\t\tComponent comp = Component.of(res.getPDBName(), ComponentType.AMINOACID, false, true);\r\n\t\t\t\tif (comps.contains(comp)) {\r\n\t\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\t\tif (gs==null) {\r\n\t\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgs.add(res);\r\n\t\t\t\t}\r\n\t\t\t} while (iRes>=0 && ligands.contains(res));\r\n\t\t}\r\n\r\n\t\treturn mapCompRes;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Get matched atoms for all linkages.\t\r\n\t */\r\n\tprivate List<List<Atom[]>> getMatchedAtomsOfLinkages(\r\n\t\t\tModificationCondition condition, Map<Component, Set<Group>> mapCompGroups) {\r\n\t\tList<ModificationLinkage> linkages = condition.getLinkages();\r\n\t\tint nLink = linkages.size();\r\n\r\n\t\tList<List<Atom[]>> matchedAtomsOfLinkages = \r\n\t\t\t\tnew ArrayList<List<Atom[]>>(nLink);\r\n\t\t\r\n\t\tfor (int iLink=0; iLink<nLink; iLink++) {\r\n\t\t\tModificationLinkage linkage = linkages.get(iLink);\r\n\t\t\tComponent comp1 = linkage.getComponent1();\r\n\t\t\tComponent comp2 = linkage.getComponent2();\r\n\r\n\t\t\tboolean isAA1 = comp1.getType()==ComponentType.AMINOACID;\r\n\t\t\tboolean isAA2 = comp2.getType()==ComponentType.AMINOACID;\r\n\t\t\t\r\n\t\t\tSet<Group> groups1 = mapCompGroups.get(comp1);\r\n\t\t\tSet<Group> groups2 = mapCompGroups.get(comp2);\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tList<Atom[]> list = new ArrayList<Atom[]>();\r\n\r\n\t\t\tList<String> potentialNamesOfAtomOnGroup1 = linkage.getPDBNameOfPotentialAtomsOnComponent1();\r\n\t\t\tList<String> potentialNamesOfAtomOnGroup2 = linkage.getPDBNameOfPotentialAtomsOnComponent2();\r\n\r\n\t\t\tfor (Group g1 : groups1) {\r\n\t\t\t\tfor (Group g2 : groups2) {\r\n\t\t\t\t\tif (g1 == g2) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\r\n\t\t\t\t\tAtom[] atoms = ProteinModificationParserUtil.findNearestNonNCAtomLinkage(\r\n\t\t\t\t\t\t\tg1, isAA1, g2, isAA2,\r\n\t\t\t\t\t\t\tpotentialNamesOfAtomOnGroup1,\r\n\t\t\t\t\t\t\tpotentialNamesOfAtomOnGroup2, \r\n\t\t\t\t\t\t\tbondLengthTolerance);\r\n\t\t\t\t\tif (atoms!=null) {\r\n\t\t\t\t\t\tlist.add(atoms);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (list.isEmpty()) {\r\n\t\t\t\t// broken linkage\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\r\n\t\t\tmatchedAtomsOfLinkages.add(list);\r\n\t\t}\r\n\t\t\r\n\t\treturn matchedAtomsOfLinkages;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Assembly the matched linkages.\r\n\t * @param matchedAtomsOfLinkages\r\n\t * @param mod\r\n\t * @param condition\r\n\t * @param ret ModifiedCompound will be stored here.\r\n\t */\r\n\tprivate void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,\r\n\t\t\tProteinModification mod, List<ModifiedCompound> ret) {\r\n\t\tModificationCondition condition = mod.getCondition();\r\n\t\tList<ModificationLinkage> modLinks = condition.getLinkages();\r\n\t\t\r\n\t\tint nLink = matchedAtomsOfLinkages.size();\r\n\t\tint[] indices = new int[nLink];\r\n\t\tSet<ModifiedCompound> identifiedCompounds = new HashSet<ModifiedCompound>();\r\n\t\twhile (indices[0]<matchedAtomsOfLinkages.get(0).size()) {\r\n\t\t\tList<Atom[]> atomLinkages = new ArrayList<Atom[]>(nLink);\r\n\t\t\tfor (int iLink=0; iLink<nLink; iLink++) {\r\n\t\t\t\tAtom[] atoms = matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);\r\n\t\t\t\tatomLinkages.add(atoms);\r\n\t\t\t}\r\n\t\t\tif (matchLinkages(modLinks, atomLinkages)) {\r\n\t\t\t\t// matched\r\n\t\t\t\tSet<PDBResidueNumber> residues = new LinkedHashSet<PDBResidueNumber>();\r\n\t\t\t\tSet<PDBResidueNumber> ligands = new LinkedHashSet<PDBResidueNumber>();\r\n\t\t\t\t\r\n\t\t\t\tint n = atomLinkages.size();\r\n\t\t\t\tList<PDBAtom[]> linkages = new ArrayList<PDBAtom[]>(n);\r\n\t\t\t\tfor (int i=0; i<n; i++) {\r\n\t\t\t\t\tAtom[] linkage = atomLinkages.get(i);\r\n\t\t\t\t\tPDBResidueNumber first = StructureTools.getPDBResidueNumber(linkage[0].getParent());\r\n\t\t\t\t\tPDBResidueNumber second = StructureTools.getPDBResidueNumber(linkage[1].getParent());\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (modLinks.get(i).getComponent1().getType() == ComponentType.AMINOACID) {\r\n\t\t\t\t\t\tresidues.add(first);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tligands.add(first);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (modLinks.get(i).getComponent2().getType() == ComponentType.AMINOACID) {\r\n\t\t\t\t\t\tresidues.add(second);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tligands.add(second);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tPDBAtom atom1 = new PDBAtom(first, linkage[0].getName());\r\n\t\t\t\t\tPDBAtom atom2 = new PDBAtom(second,\tlinkage[1].getName());\r\n\t\t\t\t\tlinkages.add(new PDBAtom[]{atom1,atom2});\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (ligands.isEmpty())\r\n\t\t\t\t\tligands = null;\r\n\t\t\t\t\r\n\t\t\t\tModifiedCompound mc = new ModifiedCompoundImpl(mod, residues, ligands, linkages);\r\n\t\t\t\tif (!identifiedCompounds.contains(mc)) {\r\n\t\t\t\t\tret.add(mc);\r\n\t\t\t\t\tidentifiedCompounds.add(mc);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// indices++ (e.g. [0,0,1]=>[0,0,2]=>[1,2,0])\r\n\t\t\tint i = nLink-1;\r\n\t\t\twhile (i>=0) {\r\n\t\t\t\tif (i==0 || indices[i]<matchedAtomsOfLinkages.get(i).size()-1) {\r\n\t\t\t\t\tindices[i]++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tindices[i] = 0;\r\n\t\t\t\t\ti--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param linkages\r\n\t * @param atomLinkages\r\n\t * @return true if atomLinkages satisfy the condition; false, otherwise.\r\n\t */\r\n\tprivate boolean matchLinkages(List<ModificationLinkage> linkages, \r\n\t\t\tList<Atom[]> atomLinkages) {\r\n\t\tint nLink = linkages.size();\r\n\t\tif (nLink != atomLinkages.size()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (int i=0; i<nLink-1; i++) {\r\n\t\t\tModificationLinkage link1 = linkages.get(i);\r\n\t\t\tAtom[] atoms1 = atomLinkages.get(i);\r\n\t\t\tfor (int j=i+1; j<nLink; j++) {\r\n\t\t\t\tModificationLinkage link2 = linkages.get(j);\r\n\t\t\t\tAtom[] atoms2 = atomLinkages.get(j);\r\n\t\t\t\t\r\n\t\t\t\t// check components\r\n\t\t\t\tif (((link1.getIndexOfComponent1()==link2.getIndexOfComponent1())\r\n\t\t\t\t\t\t\t!= (atoms1[0].getParent()==atoms2[0].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent1()==link2.getIndexOfComponent2())\r\n\t\t\t\t\t\t\t!= (atoms1[0].getParent()==atoms2[1].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent2()==link2.getIndexOfComponent1())\r\n\t\t\t\t\t\t\t!= (atoms1[1].getParent()==atoms2[0].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent2()==link2.getIndexOfComponent2())\r\n\t\t\t\t\t\t\t!= (atoms1[1].getParent()==atoms2[1].getParent()))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// check atoms\r\n\t\t\t\tString label11 = link1.getLabelOfAtomOnComponent1();\r\n\t\t\t\tString label12 = link1.getLabelOfAtomOnComponent2();\r\n\t\t\t\tString label21 = link2.getLabelOfAtomOnComponent1();\r\n\t\t\t\tString label22 = link2.getLabelOfAtomOnComponent2();\r\n\t\t\t\tif ((label11!=null && label21!=null && label11.equals(label21))\r\n\t\t\t\t\t\t\t!= (atoms1[0]==atoms2[0])\r\n\t\t\t\t\t || (label11!=null && label22!=null && label11.equals(label22))\r\n\t\t\t\t\t\t\t!= (atoms1[0]==atoms2[1])\r\n\t\t\t\t\t || (label12!=null && label21!=null && label12.equals(label21))\r\n\t\t\t\t\t\t\t!= (atoms1[1]==atoms2[0])\r\n\t\t\t\t\t || (label12!=null && label22!=null && label12.equals(label22))\r\n\t\t\t\t\t\t\t!= (atoms1[1]==atoms2[1])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n","changedPro":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 12, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.structure;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.LinkedHashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.GroupType;\r\nimport org.biojava.bio.structure.PDBResidueNumber;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\nimport org.biojava.bio.structure.StructureTools;\r\n//import org.biojava.bio.structure.io.mmcif.chem.ResidueType;\r\n//import org.biojava.bio.structure.io.mmcif.chem.PolymerType;\r\n//import org.biojava.bio.structure.io.mmcif.model.ChemComp;\r\n\r\nimport org.biojava3.protmod.Component;\r\nimport org.biojava3.protmod.ComponentType;\r\nimport org.biojava3.protmod.ModificationCondition;\r\nimport org.biojava3.protmod.ModificationLinkage;\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * Identify attachment modification in a 3-D structure.\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class ProteinModificationParser {\r\n\t\r\n\tprivate double bondLengthTolerance = 0.4;\r\n\tprivate boolean recordUnidentifiableModifiedCompounds = false;\r\n\t\r\n\tprivate Set<ModifiedCompound> identifiedModifiedCompounds = null;\r\n\tprivate Set<StructureAtomLinkage> unidentifiableAtomLinkages = null;\r\n\tprivate Set<StructureGroup> unidentifiableModifiedResidues = null;\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param bondLengthTolerance tolerance of error (in Angstroms) of the\r\n\t *  covalent bond length, when calculating the atom distance threshold.\r\n\t */\r\n\tpublic void setbondLengthTolerance(final double bondLengthTolerance) {\r\n\t\tif (bondLengthTolerance<0) {\r\n\t\t\tthrow new IllegalArgumentException(\"bondLengthTolerance \" +\r\n\t\t\t\t\t\"must be positive.\");\r\n\t\t}\r\n\t\tthis.bondLengthTolerance = bondLengthTolerance;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param recordUnidentifiableAtomLinkages true if choosing to record unidentifiable\r\n\t *  atoms; false, otherwise.\r\n\t * @see #getUnidentifiableModifiedResidues\r\n\t * @see #getUnidentifiableAtomLinkages\r\n\t */\r\n\tpublic void setRecordUnidentifiableCompounds(boolean recordUnidentifiableModifiedCompounds) {\r\n\t\tthis.recordUnidentifiableModifiedCompounds = recordUnidentifiableModifiedCompounds;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @return a set of identified {@link ModifiedCompound}s from\r\n\t *  the last parse result.\r\n\t * @see ModifiedCompound\r\n\t */\r\n\tpublic Set<ModifiedCompound> getIdentifiedModifiedCompound() {\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn identifiedModifiedCompounds;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @return a set of atom linkages, which represent the \r\n\t *  atom bonds that were not covered by the identified \r\n\t *  {@link ModifiedCompound}s from the last parse result.\r\n\t *  Each element of the list is a array containing two atoms.\r\n\t * @see StructureAtomLinkage\r\n\t * @see #setRecordUnidentifiableCompounds\r\n\t */\r\n\tpublic Set<StructureAtomLinkage> getUnidentifiableAtomLinkages() {\r\n\t\tif (!recordUnidentifiableModifiedCompounds) {\r\n\t\t\tthrow new UnsupportedOperationException(\"Recording unidentified atom linkages\" +\r\n\t\t\t\t\t\"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn unidentifiableAtomLinkages;\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @return a set of modified residues that were not covered by\r\n\t *  the identified ModifiedCompounds from the last parse \r\n\t *  result.\r\n\t *  @see StructureGroup\r\n\t *  @see #setRecordUnidentifiableCompounds\r\n\t *  @see #getIdentifiedModifiedCompound\r\n\t */\r\n\tpublic Set<StructureGroup> getUnidentifiableModifiedResidues() {\r\n\t\tif (!recordUnidentifiableModifiedCompounds) {\r\n\t\t\tthrow new UnsupportedOperationException(\"Recording unidentified atom linkages\" +\r\n\t\t\t\t\t\"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (identifiedModifiedCompounds==null) {\r\n\t\t\tthrow new IllegalStateException(\"No result available. Please call parse() first.\");\r\n\t\t}\r\n\t\t\r\n\t\treturn unidentifiableModifiedResidues;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Parse modifications in a structure.\r\n\t * @param structure query {@link Structure}.\r\n\t * @param potentialModifications query {@link ProteinModification}s.\r\n\t */\r\n\tpublic void parse(final Structure structure, \r\n\t\t\tfinal Set<ProteinModification> potentialModifications) {\r\n\t\tidentifiedModifiedCompounds = new LinkedHashSet<ModifiedCompound>();\r\n\t\tif (recordUnidentifiableModifiedCompounds) {\r\n\t\t\tunidentifiableAtomLinkages = new LinkedHashSet<StructureAtomLinkage>();\r\n\t\t\tunidentifiableModifiedResidues = new LinkedHashSet<StructureGroup>();\r\n\t\t}\r\n\t\t\r\n\t\tif (structure==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null structure.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null potentialModifications.\");\r\n\t\t}\r\n\t\t\r\n\t\tif (potentialModifications.isEmpty()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\tList<Chain> chains = structure.getChains();\r\n\t\t\r\n\t\tfor (Chain chain : chains) {\r\n\t\t\tList<ModifiedCompound> modComps = new ArrayList<ModifiedCompound>();\r\n\t\t\t\r\n\t\t\tList<Group> residues = getAminoAcids(chain);\r\n\t\t\tList<Group> ligands = chain.getAtomLigands();\r\n\t\t\t\r\n\t\t\tMap<Component, Set<Group>> mapCompGroups = \r\n\t\t\t\tgetModificationGroups(potentialModifications, residues, ligands);\r\n\t\t\t\r\n\t\t\tfor (ProteinModification mod : potentialModifications) {\r\n\t\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\t\tList<Component> components = condition.getComponents();\r\n\t\t\t\tif (!mapCompGroups.keySet().containsAll(components)) {\r\n\t\t\t\t\t// not all components exist for this mod.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tint sizeComps = components.size();\r\n\t\t\t\tif (sizeComps==1) {\r\n\t\t\t\t\t// modified residue\r\n\t\t\t\t\t// TODO: is this the correct logic for CROSS_LINK_1?\r\n\t\t\t\t\tSet<Group> modifiedResidues = mapCompGroups.get(components.get(0));\r\n\t\t\t\t\tif (modifiedResidues != null) {\r\n\t\t\t\t\t\tfor (Group residue : modifiedResidues) {\r\n\t\t\t\t\t\t\tPDBResidueNumber resNum = StructureTools.getPDBResidueNumber(residue);\r\n\t\t\t\t\t\t\tStructureGroup strucGroup = new StructureGroup(resNum, residue.getPDBCode(), ComponentType.AMINOACID);\r\n\t\t\t\t\t\t\tModifiedCompound modRes = new ModifiedCompoundImpl(mod, strucGroup);\r\n\t\t\t\t\t\t\tmodComps.add(modRes);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// for multiple components\r\n\t\t\t\t\t\r\n\t\t\t\t\t// find linkages first\r\n\t\t\t\t\tList<List<Atom[]>> matchedAtomsOfLinkages =\r\n\t\t\t\t\t\t\tgetMatchedAtomsOfLinkages(condition, mapCompGroups);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (matchedAtomsOfLinkages.size() != condition.getLinkages().size()) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tassembleLinkages(matchedAtomsOfLinkages, mod, modComps);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// identify additional groups that are not directly attached to amino acids.\r\n\t\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\t\tidentifyAdditionalAttachments(mc, ligands, chain);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tidentifiedModifiedCompounds.addAll(modComps);\r\n\t\t\t\r\n\t\t\t// record unidentifiable linkage\r\n\t\t\tif (recordUnidentifiableModifiedCompounds) {\r\n\t\t\t\trecordUnidentifiableAtomLinkages(modComps, residues, ligands);\r\n\t\t\t\trecordUnidentifiableModifiedResidues(modComps, residues);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t// TODO: this should be replaced when Andreas fix the getAtomGroups(\"amino\");\r\n\t/**\r\n\t * Get all amino acids in a chain.\r\n\t * @param chain\r\n\t * @return\r\n\t */\r\n\tprivate List<Group> getAminoAcids(Chain chain) {\r\n//\t\tList<Group> residues = new ArrayList<Group>();\r\n//\t\tfor (Group group : chain.getAtomGroups()) {\r\n//\t\t\tChemComp cc = group.getChemComp();\r\n//\t\t\tif (ResidueType.lPeptideLinking.equals(cc.getResidueType()) ||\r\n//\t\t\t\t\tPolymerType.PROTEIN_ONLY.contains(cc.getPolymerType())) {\r\n//\t\t\t\tresidues.add(group);\r\n//\t\t\t}\r\n//\t\t}\r\n\t\tList<Group> residues = new ArrayList<Group>(chain.getSeqResGroups());\r\n\t\tresidues.retainAll(chain.getAtomGroups());\r\n\t\t\r\n\t\treturn residues;\r\n\t}\r\n\t\r\n\t/**\r\n\t * identify additional groups that are not directly attached to amino acids.\r\n\t * @param mc {@link ModifiedCompound}.\r\n\t * @param chain a {@link Chain}.\r\n\t * @return a list of added groups.\r\n\t */\r\n\tprivate void identifyAdditionalAttachments(ModifiedCompound mc, \r\n\t\t\tList<Group> ligands, Chain chain) {\r\n\t\tif (ligands.isEmpty()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: should the additional groups only be allowed to the identified \r\n\t\t// heta groups or both amino acids and heta groups?\r\n\t\t// TODO: how about chain-chain links?\r\n\t\tList<Group> identifiedGroups = new ArrayList<Group>();\r\n\t\tfor (StructureGroup num : mc.getGroups(ComponentType.LIGAND)) {\r\n\t\t\tGroup group;\r\n\t\t\ttry {\r\n\t\t\t\tString numIns = \"\" + num.getResidueNumber();\r\n\t\t\t\tif (num.getInsCode() != null) {\r\n\t\t\t\t\tnumIns += num.getInsCode();\r\n\t\t\t\t}\r\n\t\t\t\tgroup = chain.getGroupByPDB(numIns);\r\n\t\t\t} catch (StructureException e) {\r\n\t\t\t\t// should not happen\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tidentifiedGroups.add(group);\r\n\t\t}\r\n\t\t\r\n\t\tint start = 0;\r\n\t\t\r\n\t\tint n = identifiedGroups.size();\r\n\t\twhile (n > start) {\r\n\t\t\tfor (Group group1 : ligands) {\r\n\t\t\t\tfor (int i=start; i<n; i++) {\r\n\t\t\t\t\tGroup group2 = identifiedGroups.get(i);\r\n\t\t\t\t\tif (!identifiedGroups.contains(group1)) {\r\n\t\t\t\t\t\tList<Atom[]> linkedAtoms = StructureUtil.findNonNCAtomLinkages(\r\n\t\t\t\t\t\t\t\tgroup1, false, group2, false, bondLengthTolerance);\r\n\t\t\t\t\t\tif (!linkedAtoms.isEmpty()) {\r\n\t\t\t\t\t\t\tfor (Atom[] atoms : linkedAtoms) {\r\n\t\t\t\t\t\t\t\tmc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0], \r\n\t\t\t\t\t\t\t\t\t\tComponentType.LIGAND, atoms[1], ComponentType.LIGAND));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tidentifiedGroups.add(group1);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tstart = n;\r\n\t\t\tn = identifiedGroups.size();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Record unidentifiable atom linkages in a chain. Only linkages between two\r\n\t * residues or one residue and one ligand will be recorded.\r\n\t */\r\n\tprivate void recordUnidentifiableAtomLinkages(List<ModifiedCompound> modComps,\r\n\t\t\tList<Group> residues, List<Group> ligands) {\r\n\t\t\r\n\t\t// first put identified linkages in a map for fast query\r\n\t\tSet<StructureAtomLinkage> identifiedLinkages = new HashSet<StructureAtomLinkage>();\r\n\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\tidentifiedLinkages.addAll(mc.getAtomLinkages());\r\n\t\t}\r\n\t\t\r\n\t\t// record\r\n\t\t// cross link\r\n\t\tint nRes = residues.size();\r\n\t\tfor (int i=0; i<nRes-1; i++) {\r\n\t\t\tGroup group1 = residues.get(i);\r\n\t\t\tfor (int j=i+1; j<nRes; j++) {\r\n\t\t\t\tGroup group2 = residues.get(j);\r\n\t\t\t\tList<Atom[]> linkages = StructureUtil.findNonNCAtomLinkages(\r\n\t\t\t\t\t\tgroup1, true, group2, true, bondLengthTolerance);\r\n\t\t\t\tfor (Atom[] atoms : linkages) {\r\n\t\t\t\t\tStructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(atoms[0], \r\n\t\t\t\t\t\t\tComponentType.LIGAND, atoms[1], ComponentType.LIGAND);\r\n\t\t\t\t\tif (!identifiedLinkages.contains(link)) {\r\n\t\t\t\t\t\tunidentifiableAtomLinkages.add(link);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// attachment\r\n\t\tint nLig = ligands.size();\r\n\t\tfor (int i=0; i<nRes; i++) {\r\n\t\t\tGroup group1 = residues.get(i);\r\n\t\t\tfor (int j=0; j<nLig; j++) {\r\n\t\t\t\tGroup group2 = ligands.get(j);\r\n\t\t\t\tif (group1==group2) { // overlap between residues and ligands\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tList<Atom[]> linkages = StructureUtil.findNonNCAtomLinkages(\r\n\t\t\t\t\t\tgroup1, true, group2, false, bondLengthTolerance);\r\n\t\t\t\tfor (Atom[] atoms : linkages) {\r\n\t\t\t\t\tStructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(atoms[0], \r\n\t\t\t\t\t\t\tComponentType.LIGAND, atoms[1], ComponentType.LIGAND);\r\n\t\t\t\t\tif (!identifiedLinkages.contains(link)) {\r\n\t\t\t\t\t\tunidentifiableAtomLinkages.add(link);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate void recordUnidentifiableModifiedResidues(List<ModifiedCompound> modComps, List<Group> residues) {\r\n\t\tSet<StructureGroup> identifiedComps = new HashSet<StructureGroup>();\r\n\t\tfor (ModifiedCompound mc : modComps) {\r\n\t\t\tidentifiedComps.addAll(mc.getGroups(ComponentType.AMINOACID));\r\n\t\t}\r\n\t\t\r\n\t\t// TODO: use the ModifiedAminoAcid after Andreas add that.\r\n\t\tfor (Group group : residues) {\r\n\t\t\tif (group.getType().equals(GroupType.HETATM)) {\r\n\t\t\t\tStructureGroup strucGroup = StructureUtil.getStructureGroup(\r\n\t\t\t\t\t\tgroup, ComponentType.AMINOACID);\r\n\t\t\t\tif (!identifiedComps.contains(strucGroup)) {\r\n\t\t\t\t\tunidentifiableModifiedResidues.add(strucGroup);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param modifications a set of {@link ProteinModification}s.\r\n\t * @param residues\r\n\t * @param ligands \r\n\t * @return map from component to list of corresponding residues\r\n\t *  in the chain.\r\n\t */\r\n\tprivate Map<Component, Set<Group>> getModificationGroups(\r\n\t\t\tfinal Set<ProteinModification> modifications,\r\n\t\t\tfinal List<Group> residues,\r\n\t\t\tfinal List<Group> ligands) {\r\n\t\tif (residues==null || ligands==null || modifications==null) {\r\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\r\n\t\t}\r\n\t\t\r\n\t\tSet<Component> comps = new HashSet<Component>();\r\n\t\tfor (ProteinModification mod : modifications) {\r\n\t\t\tModificationCondition condition = mod.getCondition();\r\n\t\t\tfor (Component comp : condition.getComponents()) {\r\n\t\t\t\tcomps.add(comp);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tMap<Component, Set<Group>> mapCompRes = \r\n\t\t\tnew HashMap<Component, Set<Group>>();\r\n\t\t\r\n\t\t{\r\n\t\t\t// ligands\r\n\t\t\tfor (Group group : ligands) {\r\n\t\t\t\tString pdbccId = group.getPDBName().trim();\r\n\t\t\t\tComponent comp = Component.of(pdbccId, ComponentType.LIGAND);\r\n\t\t\t\tif (!comps.contains(comp)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\tif (gs==null) {\r\n\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t}\r\n\t\t\t\tgs.add(group);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t{\r\n\t\t\t// residues\r\n\t\t\tif (residues.isEmpty()) {\r\n\t\t\t\treturn mapCompRes;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// for all residues\r\n\t\t\tfor (Group group : residues) {\r\n\t\t\t\tString pdbccId = group.getPDBName().trim();\r\n\t\t\t\tComponent comp = Component.of(pdbccId, ComponentType.AMINOACID);\r\n\t\t\t\tif (!comps.contains(comp)) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\tif (gs==null) {\r\n\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t}\r\n\t\t\t\tgs.add(group);\r\n\t\t\t}\r\n\r\n\t\t\t// for N-terminal\r\n\t\t\tint nRes = residues.size();\r\n\t\t\tint iRes = 0;\r\n\t\t\tGroup res;\r\n\t\t\tdo {\r\n\t\t\t\t// for all ligands on N terminal and the first residue\r\n\t\t\t\tres = residues.get(iRes++);\r\n\r\n\t\t\t\tComponent comp = Component.of(res.getPDBName(), ComponentType.AMINOACID, true, false);\r\n\t\t\t\tif (comps.contains(comp)) {\r\n\t\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\t\tif (gs==null) {\r\n\t\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgs.add(res);\r\n\t\t\t\t}\r\n\t\t\t} while (iRes<nRes && ligands.contains(res));\r\n\t\t\t\r\n\t\t\t// for C-terminal\r\n\t\t\tiRes = residues.size()-1;\r\n\t\t\tdo {\r\n\t\t\t\t// for all ligands on C terminal and the last residue\r\n\t\t\t\tres = residues.get(iRes--);\r\n\t\t\t\t\r\n\t\t\t\tComponent comp = Component.of(res.getPDBName(), ComponentType.AMINOACID, false, true);\r\n\t\t\t\tif (comps.contains(comp)) {\r\n\t\t\t\t\tSet<Group> gs = mapCompRes.get(comp);\r\n\t\t\t\t\tif (gs==null) {\r\n\t\t\t\t\t\tgs = new LinkedHashSet<Group>();\r\n\t\t\t\t\t\tmapCompRes.put(comp, gs);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgs.add(res);\r\n\t\t\t\t}\r\n\t\t\t} while (iRes>=0 && ligands.contains(res));\r\n\t\t}\r\n\r\n\t\treturn mapCompRes;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Get matched atoms for all linkages.\t\r\n\t */\r\n\tprivate List<List<Atom[]>> getMatchedAtomsOfLinkages(\r\n\t\t\tModificationCondition condition, Map<Component, Set<Group>> mapCompGroups) {\r\n\t\tList<ModificationLinkage> linkages = condition.getLinkages();\r\n\t\tint nLink = linkages.size();\r\n\r\n\t\tList<List<Atom[]>> matchedAtomsOfLinkages = \r\n\t\t\t\tnew ArrayList<List<Atom[]>>(nLink);\r\n\t\t\r\n\t\tfor (int iLink=0; iLink<nLink; iLink++) {\r\n\t\t\tModificationLinkage linkage = linkages.get(iLink);\r\n\t\t\tComponent comp1 = linkage.getComponent1();\r\n\t\t\tComponent comp2 = linkage.getComponent2();\r\n\r\n\t\t\tboolean isAA1 = comp1.getType()==ComponentType.AMINOACID;\r\n\t\t\tboolean isAA2 = comp2.getType()==ComponentType.AMINOACID;\r\n\t\t\t\r\n\t\t\tSet<Group> groups1 = mapCompGroups.get(comp1);\r\n\t\t\tSet<Group> groups2 = mapCompGroups.get(comp2);\t\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tList<Atom[]> list = new ArrayList<Atom[]>();\r\n\r\n\t\t\tList<String> potentialNamesOfAtomOnGroup1 = linkage.getPDBNameOfPotentialAtomsOnComponent1();\r\n\t\t\tList<String> potentialNamesOfAtomOnGroup2 = linkage.getPDBNameOfPotentialAtomsOnComponent2();\r\n\r\n\t\t\tfor (Group g1 : groups1) {\r\n\t\t\t\tfor (Group g2 : groups2) {\r\n\t\t\t\t\tif (g1 == g2) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\r\n\t\t\t\t\tAtom[] atoms = StructureUtil.findNearestNonNCAtomLinkage(\r\n\t\t\t\t\t\t\tg1, isAA1, g2, isAA2,\r\n\t\t\t\t\t\t\tpotentialNamesOfAtomOnGroup1,\r\n\t\t\t\t\t\t\tpotentialNamesOfAtomOnGroup2, \r\n\t\t\t\t\t\t\tbondLengthTolerance);\r\n\t\t\t\t\tif (atoms!=null) {\r\n\t\t\t\t\t\tlist.add(atoms);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\tif (list.isEmpty()) {\r\n\t\t\t\t// broken linkage\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\r\n\t\t\tmatchedAtomsOfLinkages.add(list);\r\n\t\t}\r\n\t\t\r\n\t\treturn matchedAtomsOfLinkages;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Assembly the matched linkages.\r\n\t * @param matchedAtomsOfLinkages\r\n\t * @param mod\r\n\t * @param condition\r\n\t * @param ret ModifiedCompound will be stored here.\r\n\t */\r\n\tprivate void assembleLinkages(List<List<Atom[]>> matchedAtomsOfLinkages,\r\n\t\t\tProteinModification mod, List<ModifiedCompound> ret) {\r\n\t\tModificationCondition condition = mod.getCondition();\r\n\t\tList<ModificationLinkage> modLinks = condition.getLinkages();\r\n\t\t\r\n\t\tint nLink = matchedAtomsOfLinkages.size();\r\n\t\tint[] indices = new int[nLink];\r\n\t\tSet<ModifiedCompound> identifiedCompounds = new HashSet<ModifiedCompound>();\r\n\t\twhile (indices[0]<matchedAtomsOfLinkages.get(0).size()) {\r\n\t\t\tList<Atom[]> atomLinkages = new ArrayList<Atom[]>(nLink);\r\n\t\t\tfor (int iLink=0; iLink<nLink; iLink++) {\r\n\t\t\t\tAtom[] atoms = matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);\r\n\t\t\t\tatomLinkages.add(atoms);\r\n\t\t\t}\r\n\t\t\tif (matchLinkages(modLinks, atomLinkages)) {\r\n\t\t\t\t// matched\r\n\t\t\t\t\r\n\t\t\t\tint n = atomLinkages.size();\r\n\t\t\t\tList<StructureAtomLinkage> linkages = new ArrayList<StructureAtomLinkage>(n);\r\n\t\t\t\tfor (int i=0; i<n; i++) {\r\n\t\t\t\t\tAtom[] linkage = atomLinkages.get(i);\r\n\t\t\t\t\tStructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(\r\n\t\t\t\t\t\t\tlinkage[0], modLinks.get(i).getComponent1().getType(), \r\n\t\t\t\t\t\t\tlinkage[1], modLinks.get(i).getComponent2().getType());\r\n\t\t\t\t\tlinkages.add(link);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tModifiedCompound mc = new ModifiedCompoundImpl(mod, linkages);\r\n\t\t\t\tif (!identifiedCompounds.contains(mc)) {\r\n\t\t\t\t\tret.add(mc);\r\n\t\t\t\t\tidentifiedCompounds.add(mc);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// indices++ (e.g. [0,0,1]=>[0,0,2]=>[1,2,0])\r\n\t\t\tint i = nLink-1;\r\n\t\t\twhile (i>=0) {\r\n\t\t\t\tif (i==0 || indices[i]<matchedAtomsOfLinkages.get(i).size()-1) {\r\n\t\t\t\t\tindices[i]++;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tindices[i] = 0;\r\n\t\t\t\t\ti--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param linkages\r\n\t * @param atomLinkages\r\n\t * @return true if atomLinkages satisfy the condition; false, otherwise.\r\n\t */\r\n\tprivate boolean matchLinkages(List<ModificationLinkage> linkages, \r\n\t\t\tList<Atom[]> atomLinkages) {\r\n\t\tint nLink = linkages.size();\r\n\t\tif (nLink != atomLinkages.size()) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfor (int i=0; i<nLink-1; i++) {\r\n\t\t\tModificationLinkage link1 = linkages.get(i);\r\n\t\t\tAtom[] atoms1 = atomLinkages.get(i);\r\n\t\t\tfor (int j=i+1; j<nLink; j++) {\r\n\t\t\t\tModificationLinkage link2 = linkages.get(j);\r\n\t\t\t\tAtom[] atoms2 = atomLinkages.get(j);\r\n\t\t\t\t\r\n\t\t\t\t// check components\r\n\t\t\t\tif (((link1.getIndexOfComponent1()==link2.getIndexOfComponent1())\r\n\t\t\t\t\t\t\t!= (atoms1[0].getParent()==atoms2[0].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent1()==link2.getIndexOfComponent2())\r\n\t\t\t\t\t\t\t!= (atoms1[0].getParent()==atoms2[1].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent2()==link2.getIndexOfComponent1())\r\n\t\t\t\t\t\t\t!= (atoms1[1].getParent()==atoms2[0].getParent()))\r\n\t\t\t\t\t|| ((link1.getIndexOfComponent2()==link2.getIndexOfComponent2())\r\n\t\t\t\t\t\t\t!= (atoms1[1].getParent()==atoms2[1].getParent()))) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// check atoms\r\n\t\t\t\tString label11 = link1.getLabelOfAtomOnComponent1();\r\n\t\t\t\tString label12 = link1.getLabelOfAtomOnComponent2();\r\n\t\t\t\tString label21 = link2.getLabelOfAtomOnComponent1();\r\n\t\t\t\tString label22 = link2.getLabelOfAtomOnComponent2();\r\n\t\t\t\tif ((label11!=null && label21!=null && label11.equals(label21))\r\n\t\t\t\t\t\t\t!= (atoms1[0]==atoms2[0])\r\n\t\t\t\t\t || (label11!=null && label22!=null && label11.equals(label22))\r\n\t\t\t\t\t\t\t!= (atoms1[0]==atoms2[1])\r\n\t\t\t\t\t || (label12!=null && label21!=null && label12.equals(label21))\r\n\t\t\t\t\t\t\t!= (atoms1[1]==atoms2[0])\r\n\t\t\t\t\t || (label12!=null && label22!=null && label12.equals(label22))\r\n\t\t\t\t\t\t\t!= (atoms1[1]==atoms2[1])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n}\r\n","originTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 8, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.parser;\r\n\r\nimport java.io.IOException;\r\n\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport org.biojava.bio.structure.Atom;\r\nimport org.biojava.bio.structure.Calc;\r\nimport org.biojava.bio.structure.Chain;\r\nimport org.biojava.bio.structure.Group;\r\nimport org.biojava.bio.structure.PDBResidueNumber;\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\nimport org.biojava.bio.structure.StructureTools;\r\n\r\nimport org.biojava3.protmod.PDBAtom;\r\nimport org.biojava3.protmod.ModificationCategory;\r\nimport org.biojava3.protmod.ModifiedCompound;\r\nimport org.biojava3.protmod.ProteinModification;\r\nimport org.biojava3.protmod.TmpAtomCache;\r\n\r\n/**\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class ProteinModificationParserTest extends TestCase {\r\n\t\r\n\tpublic void testMultiParser(){\r\n\t\tString[][] names = new String[][] {\r\n\t\t\t\t// Attachments\r\n\t\t\t\t{\"3HN3\", \"AA0151\"}, // NAG\r\n\t\t\t\t{\"1CPO\", \"AA0406\"}, // XYS\r\n\t\t\t\t{\"1AL2\", \"AA0059\"}, // MYR\r\n\t\t\t\t{\"1L9H\", \"AA0106\"}, // PLM\r\n\t\t\t\t{\"1BDO\", \"AA0117\"}, // BTN\r\n\t\t\t\t//{\"2IQD\", \"AA0118\"}, // no successful test case for LPA\r\n\t\t\t\t{\"1AT9\", \"AA0120\"}, // RET\r\n\t\t\t\t//{\"1DJP\", \"AA0121\"}, // DO2, (bond length error 3.0)\r\n\t\t\t\t{\"1ALL\", \"AA0131\"}, // CYC\r\n\t\t\t\t{\"1B8D\", \"AA0132\"}, // PEB\r\n\t\t\t\t{\"1OGP\", \"AA0142\"}, // MTQ\r\n\t\t\t\t{\"1EL5\", \"AA0143\"}, // FAD on CYS\r\n\t\t\t\t{\"1W1O\", \"AA0144\"}, // FAD on HIS\r\n\t\t\t\t{\"1DII\", \"AA0145\"}, // FAD on TYR\r\n\t\t\t\t{\"2KJS\", \"AA0150\"}, // PNS\r\n\t\t\t\t{\"1D7E\", \"AA0207\"}, // HC4\r\n\t\t\t\t{\"2TMD\", \"AA0220\"}, // FMN\r\n\t\t\t\t{\"1VAO\", \"AA0221\"}, // FAD on HIS\r\n\t\t\t\t{\"1PDA\", \"AA0252\"}, // DPM\r\n\t\t\t\t{\"2J96\", \"AA0258\"}, // PVN\r\n\t\t\t\t{\"2HIL\", \"AA0264\"}, // OPE\r\n\t\t\t\t//{\"1RTX\", \"AA0329\"}, // HEM, (bond length error 3.0, much closer to FE)\r\n\t\t\t\t{\"1FEH\", \"AA0334\"}, // HC1\r\n\t\t\t\t//{\"2Z6D\", \"AA0351\"}, // FMN, (bond length error 2.0)\r\n\t\t\t\t{\"1N63\", \"AA0355\"}, // CYS-CUN-MCN\r\n\t\t\t\t{\"1HXQ\", \"AA0372\"}, // U5P on HIS\r\n\t\t\t\t{\"1QI9\", \"AA0395\"}, // VO4 on HIS\r\n\t\t\t\t{\"1XG0\", \"AA0428\"}, // DBV on CYS\r\n\t\t\t\t//{\"1E9W\", \"AA0447\"}, // TSI on ILE, error when reading\r\n\t\t\t\t{\"2HIL\", \"AA0497\"}, // OPE on SER\r\n\t\t\t\t{\"3I3L\", \"AA0522\"}, // FAD on ASP\r\n\t\t\t\t{\"1MCC\", \"AA0045\"}, // ACE on GLU\r\n\t\t\t\t{\"5CPV\", \"AA0041\"}, // ACE on ALA\r\n\t\t\t\t{\"1BBR\", \"AA0042\"}, // ACE on ASP\r\n\t\t\t\t{\"1AL1\", \"AA0044\"}, // ACE on GLU\r\n\t\t\t\t{\"1SEM\", \"AA0050\"}, // ACE on PRO\r\n\t\t\t\t{\"1PVB\", \"AA0051\"}, // ACE on SER\r\n\t\t\t\t{\"1ZNF\", \"AA0053\"}, // ACE on THR\r\n\t\t\t\t{\"1SCY\", \"AA0089\"}, // NH2 on HIS\r\n\t\t\t\t\r\n\t\t\t\t// Modified resdiues\r\n\t\t\t\t{\"3MVJ\", \"AA0037\"}, // SEP\r\n\t\t\t\t{\"3MVJ\", \"AA0038\"}, // TPO\r\n\t\t\t\t{\"1KZU\", \"AA0021\"}, // FME\r\n\t\t\t\t{\"1AA6\", \"AA0022\"}, // CSE\r\n\t\t\t\t{\"1NT0\", \"AA0026\"}, // AHB\r\n\t\t\t\t{\"1ERM\", \"AA0027\"}, // BHD\r\n\t\t\t\t{\"1QGW\", \"AA0028\"}, // LYZ\r\n\t\t\t\t{\"2G66\", \"AA0029\"}, // HY3\r\n\t\t\t\t{\"2G66\", \"AA0030\"}, // HYP\r\n\t\t\t\t{\"1A39\", \"AA0031\"}, // PCA\r\n\t\t\t\t{\"1AG7\", \"AA0032\"}, // CGU\r\n\t\t\t\t{\"1D5W\", \"AA0033\"}, // PHD\r\n\t\t\t\t{\"1H9C\", \"AA0034\"}, // CSP\r\n\t\t\t\t{\"1EUD\", \"AA0035\"}, // NEP\r\n\t\t\t\t{\"1NSQ\", \"AA0036\"}, // HIP\r\n\t\t\t\t{\"3LXN\", \"AA0039\"}, // PTR\r\n\t\t\t\t{\"1ZM2\", \"AA0040\"}, // DDE\r\n\t\t\t\t{\"1E0Z\", \"AA0055\"}, // ALY\r\n\t\t\t\t{\"1DM3\", \"AA0056\"}, // SCY\r\n\t\t\t\t{\"2NPP\", \"AA0061\"}, // MAA\r\n\t\t\t\t{\"1GK8\", \"AA0064\"}, // MME\r\n\t\t\t\t{\"1DOJ\", \"AA0065\"}, // MEA\r\n\t\t\t\t{\"1DOJ\", \"AA0172\"}, // TYS\r\n\t\t\t\t{\"1G42\", \"AA0067\"}, // 2MR\r\n\t\t\t\t{\"2B2U\", \"AA0068\"}, // DA2\r\n\t\t\t\t{\"2B2U\", \"AA0074\"}, // M3L\r\n\t\t\t\t{\"1ALL\", \"AA0070\"}, // MEN\r\n\t\t\t\t{\"3FMY\", \"AA0071\"}, // MEQ\r\n\t\t\t\t{\"1E6Y\", \"AA0073\"}, // MHS\r\n\t\t\t\t{\"1E6Y\", \"AA0272\"}, // AGM\r\n\t\t\t\t{\"1IV8\", \"AA0075\"}, // MLY\r\n\t\t\t\t{\"1IV8\", \"AA0076\"}, // MLZ\r\n\t\t\t\t{\"1ZTO\", \"AA0082\"}, // AAR\r\n\t\t\t\t{\"2V1S\", \"AA0085\"}, // CY3\r\n\t\t\t\t{\"1XXP\", \"AA0091\"}, // CLE\r\n\t\t\t\t// {\"1XAE\", \"AA0094\"}, // NFA, C-terminal modification, but occurs in non-terminal residue\r\n\t\t\t\t// {\"2H9E\", \"AA0095\"}, // LPD\r\n\t\t\t\t// {\"2BF9\", \"AA0099\"}, // TYC, error reading PDB file\r\n\t\t\t\t// {\"1YYL\", \"AA0100\"}, // VLM\r\n\t\t\t\t{\"1AEX\", \"AA0101\"}, // SCH\r\n\t\t\t\t{\"1OMW\", \"AA0105\"}, // CMT\r\n\t\t\t\t{\"2C0J\", \"AA0106\"}, // P1L\r\n\t\t\t\t{\"1AA1\", \"AA0114\"}, // KCX\r\n\t\t\t\t{\"1O5K\", \"AA0115\"}, // MCL\r\n\t\t\t\t{\"1A8I\", \"AA0119\"}, // LLP\r\n\t\t\t\t{\"2J4Y\", \"AA0120\"}, // LYR\r\n\t\t\t\t//PVL not exist in PDB\r\n\t\t\t\t{\"1A2V\", \"AA0147\"}, // TPQ\r\n\t\t\t\t{\"1JJU\", \"AA0148\"}, // TRQ\r\n\t\t\t\t{\"1WCT\", \"AA0155\"}, // GTH\r\n\t\t\t\t{\"1A2C\", \"AA0172\"}, // TYS\r\n\t\t\t\t{\"1WCT\", \"AA0179\"}, // BTR\r\n\t\t\t\t{\"1AUK\", \"AA0185\"}, // FGL\r\n\t\t\t\t{\"148L\", \"AA0191\"}, // DAL\r\n\t\t\t\t// {\"1C4B\", \"AA0192\"}, // DIL\r\n\t\t\t\t{\"1T5M\", \"AA0196\"}, // DSG\r\n\t\t\t\t// {\"1CZQ\", \"AA0198\"}, // DTR\r\n\t\t\t\t{\"2JUE\", \"AA0199\"}, // DTH\r\n\t\t\t\t{\"1A7Y\", \"AA0200\"}, // DVA\r\n\t\t\t\t{\"1CXP\", \"AA0205\"}, // CSO\r\n\t\t\t\t{\"1F8W\", \"AA0205\"}, // CSX\r\n\t\t\t\t{\"1FFV\", \"AA0215\"}, // ARO\r\n\t\t\t\t{\"1CKN\", \"AA0228\"}, // GPL\r\n\t\t\t\t{\"1BUW\", \"AA0230\"}, // SNC\r\n\t\t\t\t{\"1CZI\", \"AA0234\"}, // SMC\r\n\t\t\t\t{\"1E93\", \"AA0251\"}, // OMT\r\n\t\t\t\t{\"1ACD\", \"AA0262\"}, // CSD\r\n\t\t\t\t{\"1C0T\", \"AA0262\"}, // CSW\r\n\t\t\t\t{\"1E6Y\", \"AA0265\"}, // GL3\r\n\t\t\t\t{\"1BI0\", \"AA0269\"}, // CSS\r\n\t\t\t\t{\"1E6Y\", \"AA0272\"}, // AGM\r\n\t\t\t\t{\"1HBM\", \"AA0273\"}, // MGN\r\n\t\t\t\t{\"1FFU\", \"AA0277\"}, // CSZ\r\n\t\t\t\t{\"3H5R\", \"AA0302\"}, // SNN, note: SNN is not at C-terminal in some structures, e.g. 3I4W\r\n\t\t\t\t{\"1JQ7\", \"AA0311\"}, // DMH\r\n\t\t\t\t{\"1J6Z\", \"AA0317\"}, // HIC\r\n\t\t\t\t{\"1B80\", \"AA0322\"}, // HTR\r\n\t\t\t\t{\"1CWM\", \"AA0336\"}, // IML\r\n\t\t\t\t{\"1BCK\", \"AA0337\"}, // MLE\r\n\t\t\t\t{\"1EA7\", \"AA0361\"}, // OSE\r\n\t\t\t\t{\"1TYS\", \"AA0363\"}, // CXM\r\n\t\t\t\t{\"1EBV\", \"AA0364\"}, // OAS\r\n\t\t\t\t{\"2VZK\", \"AA0423\"}, // TH5\r\n\t\t\t\t{\"2IU4\", \"AA0431\"}, // HIQ\r\n\t\t\t\t{\"1Y9A\", \"AA0432\"}, // OHS\r\n\t\t\t\t{\"2IUW\", \"AA0444\"}, // LED\r\n\t\t\t\t{\"1K83\", \"AA0449\"}, // ILX\r\n\t\t\t\t{\"2VH3\", \"AA0458\"}, // FGL\r\n\t\t\t\t{\"2AOC\", \"AA0464\"}, // OLT\r\n\t\t\t\t{\"1DSR\", \"AA0478\"}, // AHB\r\n\t\t\t\t{\"1AIQ\", \"AA0493\"}, // CXM\r\n\t\t\t\t{\"1CF0\", \"AA0509\"}, // IYR\r\n\t\t\t\t{\"1CTP\", \"AA0510\"}, // TYI\r\n\t\t\t\t{\"3L4M\", \"AA0520\"}, // 0AF\r\n\t\t\t\t{\"4ECA\", \"AA0525\"}, // AEI\r\n\r\n\t\t\t\t// Cross link\r\n\t\t\t\t{\"3M6S\", \"AA0025\"}, // Disulfide bond\r\n\t\t\t\t{\"1A6L\", \"AA0139\"}, // F3S\r\n\t\t\t\t{\"1A70\", \"AA0137\"}, // FES\r\n\t\t\t\t{\"1RPB\", \"AA0216\"}, // Isopeptide (Cys - ASP)\r\n\t\t\t\t{\"3B2M\", \"AA0294\"}, // isopeptide (Lys - Asn)\r\n\t\t\t\t{\"1CAD\", \"AA0136\"}, // FE and 4 Cys, cross-link4\r\n\t\t\t\t{\"1FP4\", \"AA0141\"}, // CFM, HCA, CYS, HIS\r\n\t\t\t\t{\"1M1N\", \"AA0141\"}, // CFN, HCA, CYS, HIS\r\n\t\t\t\t//{\"1G21\", \"AA0141\"}, // CFM, HCA, CYS, HIS, (bond length error 0.5)\r\n\t\t\t\t//{\"1M34\", \"AA0141\"}, // CFM, HCA, CYS, HIS, (bond length error 1.0)\r\n\t\t\t\t{\"1G7K\", \"AA0183\"}, // CRQ, cross-link1\r\n\t\t\t\t{\"1EMA\", \"AA0183\"}, // CRO, cross-link1\r\n\t\t\t\t//{\"1GGE\", \"AA0250\"}, // HIS-TYR, cross-link2, (bond length error 0.6)\r\n\t\t\t\t{\"2JE3\", \"AA0271\"}, // HEC, CYS, CYS, LYS\r\n\t\t\t\t//{\"1MHL\", \"AA0280\"}, // not work for HEM\r\n\t\t\t\t//{\"1MYP\", \"AA0280\"}, // not work for HEM\r\n\t\t\t\t//{\"3HML\", \"AA0283\"}, // PQQ, GLU, TYR, (bond length error 2)\r\n\t\t\t\t{\"1FWX\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"1QNI\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"2IWF\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"2IWK\", \"AA0298\"}, // CU4\r\n\t\t\t\t//{\"1G20\", \"AA0300\"}, // CLF (bond length error 20)\r\n\t\t\t\t{\"1SU6\", \"AA0310\"}, // NFS, 5 CYS, HIS\r\n\t\t\t\t{\"1SU7\", \"AA0310\"}, // NFS, 5 CYS, HIS (looks like 6 CYS are linked)\r\n\t\t\t\t//{\"1JJU\", \"AA0313\"}, // CYS-TRP, (bond length error 3)\r\n\t\t\t\t{\"1JJU\", \"AA0314\"}, // CYS-ASP\r\n\t\t\t\t{\"1JJU\", \"AA0315\"}, // CYS-GLU\r\n\t\t\t\t//{\"1AJ1\", \"AA0330\"}, // CYS-THR, could not find.\r\n\t\t\t\t{\"1PXQ\", \"AA0340\"}, // CYS-PHE\r\n\t\t\t\t{\"1PXQ\", \"AA0342\"}, // CYS-THR\r\n\t\t\t\t{\"1ITK\", \"AA0348\"}, // MET-TYR-TRP\r\n\t\t\t\t//{\"1R30\", \"AA0356\"}, // 3 CYS-SF4-SAM (bond length error 0.6)\r\n\t\t\t\t{\"1R30\", \"AA0357\"}, // 3 CYS-FES-ARG\r\n\t\t\t\t// {\"1S5L\", \"AA0366\"}, // 2 ASP-3 GLU-HIT-OEC (bond length error 6)\r\n\t\t\t\t{\"1NGK\", \"AA0368\"}, //TYR-TYR\r\n\t\t\t\t{\"1YZW\", \"AA0378\"}, // CRU\r\n\t\t\t\t{\"1XQM\", \"AA0379\"}, // CH6\r\n\t\t\t\t{\"1UIS\", \"AA0379\"}, // NRQ\r\n\t\t\t\t{\"2OJK\", \"AA0380\"}, // NYG\r\n\t\t\t\t{\"2A46\", \"AA0381\"}, // CR7\r\n\t\t\t\t{\"1YZW\", \"AA0183\"}, // CRU\r\n\t\t\t\t{\"1XQM\", \"AA0183\"}, // CH6\r\n\t\t\t\t{\"1UIS\", \"AA0183\"}, // NRQ\r\n\t\t\t\t{\"2OJK\", \"AA0183\"}, // NYG\r\n\t\t\t\t{\"2A46\", \"AA0183\"}, // CR7\r\n\t\t\t\t{\"2AXR\", \"AA0436\"}, // CYS-FAD-HIS\r\n\t\t\t\t{\"2QH7\", \"AA0438\"}, // 3 CYS-FES-HIS\r\n\t\t\t\t//{\"2VUM\", \"AA0451\"}, // CYS-TRP (bond length error 2)\r\n\t\t\t\t{\"3EE4\", \"AA0490\"}, // VAL-TYR\r\n\t\t\t\t{\"3H8L\", \"AA0513\"}, // CYS-S3H-CYS\r\n\t\t};\r\n\t\t\r\n\t\tfor ( String[] name : names){\r\n//\t\t\tSystem.out.println(\"===\\n\"+name[0]);\r\n\t\t\ttry {\r\n//\t\t\t\tString result = \r\n//\t\t\t\t\tparserTest(name[0], null); \r\n\t\t\t\t\tparserTest(name[0], name[1]);\r\n//\t\t\t\tSystem.out.println(result);\r\n\t\t\t} catch (Exception e){\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\tfail(e.getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n\r\n\tprivate String parserTest(String pdbId, String residId) throws IOException, StructureException {\t\t\r\n\t\tStructure struc = TmpAtomCache.cache.getStructure(pdbId);\r\n\r\n\t\tDefaultProteinModificationParser parser = new DefaultProteinModificationParser();\r\n//\t\tparser.setRecordUnidentifiableCompounds(true);\r\n//\t\tparser.setbondLengthTolerance(2);\r\n\t\t\r\n\t\tSet<ProteinModification> mods;\r\n\t\tif (residId==null) {\r\n\t\t\tmods = ProteinModification.allModifications();\r\n\t\t} else {\r\n\t\t\tmods = ProteinModification.getByResidId(residId);\r\n\t\t}\r\n\t\t\r\n\t\tassertFalse(mods.isEmpty());\r\n\r\n\t\tparser.parse(struc, mods);\r\n\t\tList<ModifiedCompound> mcs = parser.getIdentifiedModifiedCompound();\r\n\r\n\t\tassertFalse(pdbId + \" \" + residId +\" is not false\" , mcs.isEmpty());\r\n\t\t\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n//\t\tint i=0;\r\n//\t\tfor (ModifiedCompound mc : mcs) {\r\n//\t\t\tsb.append(\"Modification #\"+(++i)+\":\"+\"\\n\");\r\n//\t\t\tsb.append(printModification(mc, struc));\r\n//\t\t}\r\n//\t\t\r\n//\t\tList<PDBResidueNumber> unidentifiedModifiedResidues = parser.getUnidentifiableModifiedResidues();\r\n//\t\ti = 0;\r\n//\t\tfor (PDBResidueNumber resNum : unidentifiedModifiedResidues) {\r\n//\t\t\tsb.append(\"Unidenfied modified residue #\"+(++i)+\":\"+\"\\n\");\r\n//\t\t\tGroup group = StructureTools.getGroupByPDBResidueNumber(struc, resNum);\r\n//\t\t\tsb.append(\"\\t\"+group.getPDBCode()+\"\\t\"+resNum.getChainId()+\"\\t\"+resNum.getResidueNumber()+\"\\n\");\r\n//\t\t}\r\n//\r\n//\t\tList<PDBAtom[]> unidentifiedLinkages = parser.getUnidentifiableAtomLinkages();\r\n//\t\ti = 0;\r\n//\t\tfor (PDBAtom[] atoms : unidentifiedLinkages) {\r\n//\t\t\tsb.append(\"Unidenfied linkage #\"+(++i)+\":\"+\"\\n\");\r\n//\t\t\tsb.append(printLinkage(atoms, struc));\r\n//\t\t}\r\n\t\t\r\n\t\treturn sb.toString();\r\n\t}\r\n\t\r\n\tprivate String printModification(ModifiedCompound mc, Structure struc) throws StructureException {\r\n\t\tProteinModification mod = mc.getModification();\r\n\t\tModificationCategory cat = mod.getCategory();\r\n\t\t\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\tsb.append(cat.label()+\": \"+mod.getId()+\"\\n\");\r\n\t\t\r\n\t\tList<PDBAtom[]> atomLinkages = mc.getAtomLinkages();\r\n\t\tif (atomLinkages.isEmpty()) {\r\n\t\t\tGroup g = StructureTools.getGroupByPDBResidueNumber(struc, mc.getResidues().iterator().next());\r\n\t\t\tChain chain = g.getParent();\r\n\t\t\tsb.append(\"\\t\"+g.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"+g.getPDBCode()+\"\\n\");\r\n\t\t} else {\r\n\t\t\tfor (PDBAtom[] atoms : atomLinkages) {\r\n\t\t\t\tsb.append(printLinkage(atoms, struc));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn sb.toString();\r\n\t}\r\n\t\r\n\tprivate String printLinkage(PDBAtom[] atoms, Structure struc) throws StructureException {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\t\t\r\n\t\tAtom atom1 = getAtom(struc, atoms[0]);\r\n\t\t\r\n\t\tGroup group = atom1.getParent();\r\n\t\tChain chain = group.getParent();\r\n\t\tsb.append(\"\\t\"+group.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t+group.getPDBCode()+\"\\t\"+atom1.getName()+\"\\n\");\r\n\r\n\t\tAtom atom2 = getAtom(struc, atoms[1]);\r\n\t\tgroup = atom2.getParent();\r\n\t\tassertEquals(chain, group.getParent());\r\n\t\tsb.append(\"\\t\"+group.getPDBName()+\"\\t\"+chain.getName()+\"\\t\"\r\n\t\t\t\t+group.getPDBCode()+\"\\t\"+atom2.getName()+\"\\n\");\r\n\r\n\t\ttry {\r\n\t\t\tsb.append(\"\\t\"+Calc.getDistance(atom1, atom2)+\"\\n\");\r\n\t\t} catch (StructureException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn sb.toString();\r\n\t}\r\n\r\n\tprivate Atom getAtom(Structure struc, PDBAtom atom) throws StructureException {\r\n\t\tPDBResidueNumber num = atom.getGroup();\r\n\t\tGroup group = StructureTools.getGroupByPDBResidueNumber(struc, num);\r\n\t\treturn group.getAtom(atom.getAtomName());\r\n\t}\r\n}\r\n","changedTest":"/*\r\n *                    BioJava development code\r\n *\r\n * This code may be freely distributed and modified under the\r\n * terms of the GNU Lesser General Public Licence.  This should\r\n * be distributed with the code.  If you do not have a copy,\r\n * see:\r\n *\r\n *      http://www.gnu.org/copyleft/lesser.html\r\n *\r\n * Copyright for this code is held jointly by the individual\r\n * authors.  These should be listed in @author doc comments.\r\n *\r\n * For more information on the BioJava project and its aims,\r\n * or to join the biojava-l mailing list, visit the home page\r\n * at:\r\n *\r\n *      http://www.biojava.org/\r\n *\r\n * Created on Jun 8, 2010\r\n * Author: Jianjiong Gao \r\n *\r\n */\r\n\r\npackage org.biojava3.protmod.structure;\r\n\r\nimport java.io.IOException;\r\n\r\nimport java.util.Set;\r\n\r\nimport junit.framework.TestCase;\r\n\r\nimport org.biojava.bio.structure.Structure;\r\nimport org.biojava.bio.structure.StructureException;\r\n\r\nimport org.biojava3.protmod.ProteinModification;\r\n\r\n/**\r\n * \r\n * @author Jianjiong Gao\r\n * @since 3.0\r\n */\r\npublic class ProteinModificationParserTest extends TestCase {\r\n\t\r\n\tpublic void testMultiParser(){\r\n\t\tString[][] names = new String[][] {\r\n\t\t\t\t// Attachments\r\n\t\t\t\t{\"3HN3\", \"AA0151\"}, // NAG\r\n\t\t\t\t{\"1CPO\", \"AA0406\"}, // XYS\r\n\t\t\t\t{\"1AL2\", \"AA0059\"}, // MYR\r\n\t\t\t\t{\"1L9H\", \"AA0106\"}, // PLM\r\n\t\t\t\t{\"1BDO\", \"AA0117\"}, // BTN\r\n\t\t\t\t//{\"2IQD\", \"AA0118\"}, // no successful test case for LPA\r\n\t\t\t\t{\"1AT9\", \"AA0120\"}, // RET\r\n\t\t\t\t//{\"1DJP\", \"AA0121\"}, // DO2, (bond length error 3.0)\r\n\t\t\t\t{\"1ALL\", \"AA0131\"}, // CYC\r\n\t\t\t\t{\"1B8D\", \"AA0132\"}, // PEB\r\n\t\t\t\t{\"1OGP\", \"AA0142\"}, // MTQ\r\n\t\t\t\t{\"1EL5\", \"AA0143\"}, // FAD on CYS\r\n\t\t\t\t{\"1W1O\", \"AA0144\"}, // FAD on HIS\r\n\t\t\t\t{\"1DII\", \"AA0145\"}, // FAD on TYR\r\n\t\t\t\t{\"2KJS\", \"AA0150\"}, // PNS\r\n\t\t\t\t{\"1D7E\", \"AA0207\"}, // HC4\r\n\t\t\t\t{\"2TMD\", \"AA0220\"}, // FMN\r\n\t\t\t\t{\"1VAO\", \"AA0221\"}, // FAD on HIS\r\n\t\t\t\t{\"1PDA\", \"AA0252\"}, // DPM\r\n\t\t\t\t{\"2J96\", \"AA0258\"}, // PVN\r\n\t\t\t\t{\"2HIL\", \"AA0264\"}, // OPE\r\n\t\t\t\t//{\"1RTX\", \"AA0329\"}, // HEM, (bond length error 3.0, much closer to FE)\r\n\t\t\t\t{\"1FEH\", \"AA0334\"}, // HC1\r\n\t\t\t\t//{\"2Z6D\", \"AA0351\"}, // FMN, (bond length error 2.0)\r\n\t\t\t\t{\"1N63\", \"AA0355\"}, // CYS-CUN-MCN\r\n\t\t\t\t{\"1HXQ\", \"AA0372\"}, // U5P on HIS\r\n\t\t\t\t{\"1QI9\", \"AA0395\"}, // VO4 on HIS\r\n\t\t\t\t{\"1XG0\", \"AA0428\"}, // DBV on CYS\r\n\t\t\t\t//{\"1E9W\", \"AA0447\"}, // TSI on ILE, error when reading\r\n\t\t\t\t{\"2HIL\", \"AA0497\"}, // OPE on SER\r\n\t\t\t\t{\"3I3L\", \"AA0522\"}, // FAD on ASP\r\n\t\t\t\t{\"1MCC\", \"AA0045\"}, // ACE on GLU\r\n\t\t\t\t{\"5CPV\", \"AA0041\"}, // ACE on ALA\r\n\t\t\t\t{\"1BBR\", \"AA0042\"}, // ACE on ASP\r\n\t\t\t\t{\"1AL1\", \"AA0044\"}, // ACE on GLU\r\n\t\t\t\t{\"1SEM\", \"AA0050\"}, // ACE on PRO\r\n\t\t\t\t{\"1PVB\", \"AA0051\"}, // ACE on SER\r\n\t\t\t\t{\"1ZNF\", \"AA0053\"}, // ACE on THR\r\n\t\t\t\t{\"1SCY\", \"AA0089\"}, // NH2 on HIS\r\n\t\t\t\t\r\n\t\t\t\t// Modified resdiues\r\n\t\t\t\t{\"3MVJ\", \"AA0037\"}, // SEP\r\n\t\t\t\t{\"3MVJ\", \"AA0038\"}, // TPO\r\n\t\t\t\t{\"1KZU\", \"AA0021\"}, // FME\r\n\t\t\t\t{\"1AA6\", \"AA0022\"}, // CSE\r\n\t\t\t\t{\"1NT0\", \"AA0026\"}, // AHB\r\n\t\t\t\t{\"1ERM\", \"AA0027\"}, // BHD\r\n\t\t\t\t{\"1QGW\", \"AA0028\"}, // LYZ\r\n\t\t\t\t{\"2G66\", \"AA0029\"}, // HY3\r\n\t\t\t\t{\"2G66\", \"AA0030\"}, // HYP\r\n\t\t\t\t{\"1A39\", \"AA0031\"}, // PCA\r\n\t\t\t\t{\"1AG7\", \"AA0032\"}, // CGU\r\n\t\t\t\t{\"1D5W\", \"AA0033\"}, // PHD\r\n\t\t\t\t{\"1H9C\", \"AA0034\"}, // CSP\r\n\t\t\t\t{\"1EUD\", \"AA0035\"}, // NEP\r\n\t\t\t\t{\"1NSQ\", \"AA0036\"}, // HIP\r\n\t\t\t\t{\"3LXN\", \"AA0039\"}, // PTR\r\n\t\t\t\t{\"1ZM2\", \"AA0040\"}, // DDE\r\n\t\t\t\t{\"1E0Z\", \"AA0055\"}, // ALY\r\n\t\t\t\t{\"1DM3\", \"AA0056\"}, // SCY\r\n\t\t\t\t{\"2NPP\", \"AA0061\"}, // MAA\r\n\t\t\t\t{\"1GK8\", \"AA0064\"}, // MME\r\n\t\t\t\t{\"1DOJ\", \"AA0065\"}, // MEA\r\n\t\t\t\t{\"1DOJ\", \"AA0172\"}, // TYS\r\n\t\t\t\t{\"1G42\", \"AA0067\"}, // 2MR\r\n\t\t\t\t{\"2B2U\", \"AA0068\"}, // DA2\r\n\t\t\t\t{\"2B2U\", \"AA0074\"}, // M3L\r\n\t\t\t\t{\"1ALL\", \"AA0070\"}, // MEN\r\n\t\t\t\t{\"3FMY\", \"AA0071\"}, // MEQ\r\n\t\t\t\t{\"1E6Y\", \"AA0073\"}, // MHS\r\n\t\t\t\t{\"1E6Y\", \"AA0272\"}, // AGM\r\n\t\t\t\t{\"1IV8\", \"AA0075\"}, // MLY\r\n\t\t\t\t{\"1IV8\", \"AA0076\"}, // MLZ\r\n\t\t\t\t{\"1ZTO\", \"AA0082\"}, // AAR\r\n\t\t\t\t{\"2V1S\", \"AA0085\"}, // CY3\r\n\t\t\t\t{\"1XXP\", \"AA0091\"}, // CLE\r\n\t\t\t\t// {\"1XAE\", \"AA0094\"}, // NFA, C-terminal modification, but occurs in non-terminal residue\r\n\t\t\t\t// {\"2H9E\", \"AA0095\"}, // LPD\r\n\t\t\t\t// {\"2BF9\", \"AA0099\"}, // TYC, error reading PDB file\r\n\t\t\t\t// {\"1YYL\", \"AA0100\"}, // VLM\r\n\t\t\t\t{\"1AEX\", \"AA0101\"}, // SCH\r\n\t\t\t\t{\"1OMW\", \"AA0105\"}, // CMT\r\n\t\t\t\t{\"2C0J\", \"AA0106\"}, // P1L\r\n\t\t\t\t{\"1AA1\", \"AA0114\"}, // KCX\r\n\t\t\t\t{\"1O5K\", \"AA0115\"}, // MCL\r\n\t\t\t\t{\"1A8I\", \"AA0119\"}, // LLP\r\n\t\t\t\t{\"2J4Y\", \"AA0120\"}, // LYR\r\n\t\t\t\t//PVL not exist in PDB\r\n\t\t\t\t{\"1A2V\", \"AA0147\"}, // TPQ\r\n\t\t\t\t{\"1JJU\", \"AA0148\"}, // TRQ\r\n\t\t\t\t{\"1WCT\", \"AA0155\"}, // GTH\r\n\t\t\t\t{\"1A2C\", \"AA0172\"}, // TYS\r\n\t\t\t\t{\"1WCT\", \"AA0179\"}, // BTR\r\n\t\t\t\t{\"1AUK\", \"AA0185\"}, // FGL\r\n\t\t\t\t{\"148L\", \"AA0191\"}, // DAL\r\n\t\t\t\t// {\"1C4B\", \"AA0192\"}, // DIL\r\n\t\t\t\t{\"1T5M\", \"AA0196\"}, // DSG\r\n\t\t\t\t// {\"1CZQ\", \"AA0198\"}, // DTR\r\n\t\t\t\t{\"2JUE\", \"AA0199\"}, // DTH\r\n\t\t\t\t{\"1A7Y\", \"AA0200\"}, // DVA\r\n\t\t\t\t{\"1CXP\", \"AA0205\"}, // CSO\r\n\t\t\t\t{\"1F8W\", \"AA0205\"}, // CSX\r\n\t\t\t\t{\"1FFV\", \"AA0215\"}, // ARO\r\n\t\t\t\t{\"1CKN\", \"AA0228\"}, // GPL\r\n\t\t\t\t{\"1BUW\", \"AA0230\"}, // SNC\r\n\t\t\t\t{\"1CZI\", \"AA0234\"}, // SMC\r\n\t\t\t\t{\"1E93\", \"AA0251\"}, // OMT\r\n\t\t\t\t{\"1ACD\", \"AA0262\"}, // CSD\r\n\t\t\t\t{\"1C0T\", \"AA0262\"}, // CSW\r\n\t\t\t\t{\"1E6Y\", \"AA0265\"}, // GL3\r\n\t\t\t\t{\"1BI0\", \"AA0269\"}, // CSS\r\n\t\t\t\t{\"1E6Y\", \"AA0272\"}, // AGM\r\n\t\t\t\t{\"1HBM\", \"AA0273\"}, // MGN\r\n\t\t\t\t{\"1FFU\", \"AA0277\"}, // CSZ\r\n\t\t\t\t{\"3H5R\", \"AA0302\"}, // SNN, note: SNN is not at C-terminal in some structures, e.g. 3I4W\r\n\t\t\t\t{\"1JQ7\", \"AA0311\"}, // DMH\r\n\t\t\t\t{\"1J6Z\", \"AA0317\"}, // HIC\r\n\t\t\t\t{\"1B80\", \"AA0322\"}, // HTR\r\n\t\t\t\t{\"1CWM\", \"AA0336\"}, // IML\r\n\t\t\t\t{\"1BCK\", \"AA0337\"}, // MLE\r\n\t\t\t\t{\"1EA7\", \"AA0361\"}, // OSE\r\n\t\t\t\t{\"1TYS\", \"AA0363\"}, // CXM\r\n\t\t\t\t{\"1EBV\", \"AA0364\"}, // OAS\r\n\t\t\t\t{\"2VZK\", \"AA0423\"}, // TH5\r\n\t\t\t\t{\"2IU4\", \"AA0431\"}, // HIQ\r\n\t\t\t\t{\"1Y9A\", \"AA0432\"}, // OHS\r\n\t\t\t\t{\"2IUW\", \"AA0444\"}, // LED\r\n\t\t\t\t{\"1K83\", \"AA0449\"}, // ILX\r\n\t\t\t\t{\"2VH3\", \"AA0458\"}, // FGL\r\n\t\t\t\t{\"2AOC\", \"AA0464\"}, // OLT\r\n\t\t\t\t{\"1DSR\", \"AA0478\"}, // AHB\r\n\t\t\t\t{\"1AIQ\", \"AA0493\"}, // CXM\r\n\t\t\t\t{\"1CF0\", \"AA0509\"}, // IYR\r\n\t\t\t\t{\"1CTP\", \"AA0510\"}, // TYI\r\n\t\t\t\t{\"3L4M\", \"AA0520\"}, // 0AF\r\n\t\t\t\t{\"4ECA\", \"AA0525\"}, // AEI\r\n\r\n\t\t\t\t// Cross link\r\n\t\t\t\t{\"3M6S\", \"AA0025\"}, // Disulfide bond\r\n\t\t\t\t{\"1A6L\", \"AA0139\"}, // F3S\r\n\t\t\t\t{\"1A70\", \"AA0137\"}, // FES\r\n\t\t\t\t{\"1RPB\", \"AA0216\"}, // Isopeptide (Cys - ASP)\r\n\t\t\t\t{\"3B2M\", \"AA0294\"}, // isopeptide (Lys - Asn)\r\n\t\t\t\t{\"1CAD\", \"AA0136\"}, // FE and 4 Cys, cross-link4\r\n\t\t\t\t{\"1FP4\", \"AA0141\"}, // CFM, HCA, CYS, HIS\r\n\t\t\t\t{\"1M1N\", \"AA0141\"}, // CFN, HCA, CYS, HIS\r\n\t\t\t\t//{\"1G21\", \"AA0141\"}, // CFM, HCA, CYS, HIS, (bond length error 0.5)\r\n\t\t\t\t//{\"1M34\", \"AA0141\"}, // CFM, HCA, CYS, HIS, (bond length error 1.0)\r\n\t\t\t\t{\"1G7K\", \"AA0183\"}, // CRQ, cross-link1\r\n\t\t\t\t{\"1EMA\", \"AA0183\"}, // CRO, cross-link1\r\n\t\t\t\t//{\"1GGE\", \"AA0250\"}, // HIS-TYR, cross-link2, (bond length error 0.6)\r\n\t\t\t\t{\"2JE3\", \"AA0271\"}, // HEC, CYS, CYS, LYS\r\n\t\t\t\t//{\"1MHL\", \"AA0280\"}, // not work for HEM\r\n\t\t\t\t//{\"1MYP\", \"AA0280\"}, // not work for HEM\r\n\t\t\t\t//{\"3HML\", \"AA0283\"}, // PQQ, GLU, TYR, (bond length error 2)\r\n\t\t\t\t{\"1FWX\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"1QNI\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"2IWF\", \"AA0298\"}, // CU4\r\n\t\t\t\t{\"2IWK\", \"AA0298\"}, // CU4\r\n\t\t\t\t//{\"1G20\", \"AA0300\"}, // CLF (bond length error 20)\r\n\t\t\t\t{\"1SU6\", \"AA0310\"}, // NFS, 5 CYS, HIS\r\n\t\t\t\t{\"1SU7\", \"AA0310\"}, // NFS, 5 CYS, HIS (looks like 6 CYS are linked)\r\n\t\t\t\t//{\"1JJU\", \"AA0313\"}, // CYS-TRP, (bond length error 3)\r\n\t\t\t\t{\"1JJU\", \"AA0314\"}, // CYS-ASP\r\n\t\t\t\t{\"1JJU\", \"AA0315\"}, // CYS-GLU\r\n\t\t\t\t//{\"1AJ1\", \"AA0330\"}, // CYS-THR, could not find.\r\n\t\t\t\t{\"1PXQ\", \"AA0340\"}, // CYS-PHE\r\n\t\t\t\t{\"1PXQ\", \"AA0342\"}, // CYS-THR\r\n\t\t\t\t{\"1ITK\", \"AA0348\"}, // MET-TYR-TRP\r\n\t\t\t\t//{\"1R30\", \"AA0356\"}, // 3 CYS-SF4-SAM (bond length error 0.6)\r\n\t\t\t\t{\"1R30\", \"AA0357\"}, // 3 CYS-FES-ARG\r\n\t\t\t\t// {\"1S5L\", \"AA0366\"}, // 2 ASP-3 GLU-HIT-OEC (bond length error 6)\r\n\t\t\t\t{\"1NGK\", \"AA0368\"}, //TYR-TYR\r\n\t\t\t\t{\"1YZW\", \"AA0378\"}, // CRU\r\n\t\t\t\t{\"1XQM\", \"AA0379\"}, // CH6\r\n\t\t\t\t{\"1UIS\", \"AA0379\"}, // NRQ\r\n\t\t\t\t{\"2OJK\", \"AA0380\"}, // NYG\r\n\t\t\t\t{\"2A46\", \"AA0381\"}, // CR7\r\n\t\t\t\t{\"1YZW\", \"AA0183\"}, // CRU\r\n\t\t\t\t{\"1XQM\", \"AA0183\"}, // CH6\r\n\t\t\t\t{\"1UIS\", \"AA0183\"}, // NRQ\r\n\t\t\t\t{\"2OJK\", \"AA0183\"}, // NYG\r\n\t\t\t\t{\"2A46\", \"AA0183\"}, // CR7\r\n\t\t\t\t{\"2AXR\", \"AA0436\"}, // CYS-FAD-HIS\r\n\t\t\t\t{\"2QH7\", \"AA0438\"}, // 3 CYS-FES-HIS\r\n\t\t\t\t//{\"2VUM\", \"AA0451\"}, // CYS-TRP (bond length error 2)\r\n\t\t\t\t{\"3EE4\", \"AA0490\"}, // VAL-TYR\r\n\t\t\t\t{\"3H8L\", \"AA0513\"}, // CYS-S3H-CYS\r\n\t\t};\r\n\t\t\r\n\t\tfor ( String[] name : names){\r\n\t\t\ttry {\r\n//\t\t\t\tparserTest(name[0], null); \r\n\t\t\t\tparserTest(name[0], name[1]);\r\n\t\t\t} catch (Exception e){\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\tfail(e.getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n\r\n\tprivate void parserTest(String pdbId, String residId) throws IOException, StructureException {\t\t\r\n\t\tStructure struc = TmpAtomCache.cache.getStructure(pdbId);\r\n\r\n\t\tProteinModificationParser parser = new ProteinModificationParser();\r\n\t\tboolean recordUnidentifiable = false;\r\n\t\tparser.setRecordUnidentifiableCompounds(recordUnidentifiable);\r\n//\t\tparser.setbondLengthTolerance(2);\r\n\t\t\r\n\t\tSet<ProteinModification> mods;\r\n\t\tif (residId==null) {\r\n\t\t\tmods = ProteinModification.allModifications();\r\n\t\t} else {\r\n\t\t\tmods = ProteinModification.getByResidId(residId);\r\n\t\t}\r\n\t\t\r\n\t\tassertFalse(mods.isEmpty());\r\n\r\n\t\tparser.parse(struc, mods);\r\n\r\n\t\tassertFalse(pdbId + \" \" + residId +\" is not false\" , \r\n\t\t\t\tparser.getIdentifiedModifiedCompound().isEmpty());\r\n\t\t\r\n\t\tboolean print = false;\r\n\t\tif (print)\r\n\t\t\tprintResult(pdbId, parser, recordUnidentifiable);\r\n\t}\r\n\t\r\n\tprivate void printResult(String pdbId, ProteinModificationParser parser, boolean recordUnidentifiable) {\r\n\t\tStringBuilder sb = new StringBuilder();\r\n\r\n\t\tsb.append(\"===\");\r\n\t\tsb.append(pdbId);\r\n\t\tsb.append(\"===\\n\");\r\n\t\t\r\n\t\tSet<ModifiedCompound> mcs = parser.getIdentifiedModifiedCompound();\r\n\t\t\r\n\t\tint i=0;\r\n\t\tfor (ModifiedCompound mc : mcs) {\r\n\t\t\tsb.append(\"Modification #\");\r\n\t\t\tsb.append(++i);\r\n\t\t\tsb.append(\":\\n\");\r\n\t\t\tsb.append(mc);\r\n\t\t\tsb.append('\\n');\r\n\t\t}\r\n\t\t\r\n\t\tif (recordUnidentifiable) {\r\n\t\t\tSet<StructureGroup> unidentifiedModifiedResidues = parser.getUnidentifiableModifiedResidues();\r\n\t\t\ti = 0;\r\n\t\t\tfor (StructureGroup group : unidentifiedModifiedResidues) {\r\n\t\t\t\tsb.append(\"Unidenfied modified residue #\");\r\n\t\t\t\tsb.append(++i);\r\n\t\t\t\tsb.append(\":\\n\");\r\n\t\t\t\tsb.append(group);\r\n\t\t\t\tsb.append('\\n');\r\n\t\t\t}\r\n\t\r\n\t\t\tSet<StructureAtomLinkage> unidentifiedLinkages = parser.getUnidentifiableAtomLinkages();\r\n\t\t\ti = 0;\r\n\t\t\tfor (StructureAtomLinkage link : unidentifiedLinkages) {\r\n\t\t\t\tsb.append(\"Unidenfied linkage #\");\r\n\t\t\t\tsb.append(++i);\r\n\t\t\t\tsb.append(\":\\n\");\r\n\t\t\t\tsb.append(link);\r\n\t\t\t\tsb.append('\\n');\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(sb.toString());\r\n\t}\r\n}\r\n","commitMessage":"biojava3-protmod: code refactoring: add StructureAtomLinkage; package structure change\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8169 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"biojava3-protmod: code refactoring: add StructureAtomLinkage; package structure change\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8169 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}