{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/util/FlatFileCache.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/util/FlatFileCacheTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Oct 1, 2009\n * Author: Andreas Prlic\n *\n */\n\npackage org.biojava.nbio.core.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides a cache for storing multiple small files in memory. Can be used to e.g cache gzip compressed PDB files\n * for avoiding disk IO bottlenecks.\n * Note this is just a wrapper for the singleton cache.\n *\n * @author Andreas Prlic.\n *\n */\npublic class FlatFileCache {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FlatFileCache.class);\n\n\t/**\n\t * The cache singleton.\n\t */\n\tprivate static SoftHashMap<String, byte[]> cache = new SoftHashMap<String, byte[]>(0);\n\n\n\t// no public constructor;\n\tprivate FlatFileCache(){\n\n\t}\n\n\t/**\n\t * The file is read and the bytes stored immediately.\n\t * <p/> \n\t * Once added, {@code fileToCache} can be modified or deleted and the cached values will not change.\n\t * @param key\n\t * @param fileToCache A readable file, of Integer.MAX bytes length or less.\n\t */\n\tpublic  static void addToCache(String key, File fileToCache){\n\t\t//logger.debug(\"storing \" + key + \" on file cache (cache size: \" + cache.size() + \")\");\n\t\ttry (InputStream is = new FileInputStream(fileToCache)){\n\t\t\t\n\t\t\t// Get the size of the file\n\t\t\tlong length = fileToCache.length();\n\n\t\t\t// You cannot create an array using a long type.\n\t\t\t// It needs to be an int type.\n\t\t\t// Before converting to an int type, check\n\t\t\t// to ensure that file is not larger than Integer.MAX_VALUE.\n\t\t\tif (length > Integer.MAX_VALUE) {\n\t\t\t\t// File is too large\n\t\t\t\tthrow new IllegalArgumentException(\"File must be <= \" + Integer.MAX_VALUE + \" bytes long\");\n\t\t\t}\n\n\t\t\t// Create the byte array to hold the data\n\t\t\tbyte[] bytes = new byte[(int)length];\n\n\t\t\t// Read in the bytes\n\t\t\tint offset = 0;\n\t\t\tint numRead = 0;\n\t\t\twhile (offset < bytes.length\n\t\t\t\t\t&& (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {\n\t\t\t\toffset += numRead;\n\t\t\t}\n\n\t\t\t// Ensure all the bytes have been read in\n\t\t\tif (offset < bytes.length) {\n\t\t\t\tis.close();\n\t\t\t\tthrow new IOException(\"Could not completely read file \"+fileToCache.getName());\n\t\t\t}\n\n\t\t\t// Close the input stream and return bytes\n\t\t\tis.close();\n\n\t\t\tcache.put(key,bytes);\n\n\t\t} catch (Exception e){\n\t\t\tlogger.error(\"Error adding to cache! \" + e.getMessage(), e);\n\t\t}\n\t}\n\t/**\n\t * Gets the cached file as an InputStream.\n\t * Clients should check for null as the item might have expired in the  cache.\n\t * @param key\n\t * @return An {@code InputStream} or null. \n\t */\n\tpublic  static InputStream getInputStream(String key){\n\t\t//logger.debug(\"returning \" + key + \" from file cache (cache size: \" + cache.size() + \")\");\n\t\tbyte[] bytes = cache.get(key);\n\t\tif ( bytes == null)\n\t\t\treturn null;\n\n\t\treturn new ByteArrayInputStream(bytes);\n\n\t}\n\n\t/**\n\t * Returns the number of items in the cache.\n\t * If the cache is {@}, returns -1\n\t * @return\n\t */\n\tpublic static int size() {\n\t\tif ( cache != null)\n\t\t\treturn cache.size();\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/**\n\t * Removes all elements from the cache\n\t */\n\tpublic static void clear(){\n\t   cache.clear();\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Oct 1, 2009\n * Author: Andreas Prlic\n *\n */\n\npackage org.biojava.nbio.core.util;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Provides a cache for storing multiple small files in memory. Can be used to e.g cache gzip compressed PDB files\n * for avoiding disk IO bottlenecks.\n * Note this is just a wrapper for the singleton cache.\n *\n * @author Andreas Prlic.\n *\n */\npublic class FlatFileCache {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FlatFileCache.class);\n\n\t/**\n\t * The cache singleton.\n\t */\n\tprivate static SoftHashMap<String, byte[]> cache = new SoftHashMap<>(0);\n\n\n\t// no public constructor;\n\tprivate FlatFileCache(){\n\n\t}\n\n\t/**\n\t * The file is read and the bytes stored immediately.\n\t * <p/> \n\t * Once added, {@code fileToCache} can be modified or deleted and the cached values will not change.\n\t * @param key\n\t * @param fileToCache A readable file, of Integer.MAX bytes length or less.\n\t */\n\tpublic  static void addToCache(String key, File fileToCache){\n\t\t//logger.debug(\"storing \" + key + \" on file cache (cache size: \" + cache.size() + \")\");\n\t\ttry (InputStream is = new FileInputStream(fileToCache)){\n\t\t\t\n\t\t\t// Get the size of the file\n\t\t\tlong length = fileToCache.length();\n\n\t\t\t// You cannot create an array using a long type.\n\t\t\t// It needs to be an int type.\n\t\t\t// Before converting to an int type, check\n\t\t\t// to ensure that file is not larger than Integer.MAX_VALUE.\n\t\t\tif (length > Integer.MAX_VALUE) {\n\t\t\t\t// File is too large\n\t\t\t\tthrow new IllegalArgumentException(\"File must be <= \" + Integer.MAX_VALUE + \" bytes long\");\n\t\t\t}\n\n\t\t\t// Create the byte array to hold the data\n\t\t\tbyte[] bytes = new byte[(int)length];\n\n\t\t\t// Read in the bytes\n\t\t\tint offset = 0;\n\t\t\tint numRead = 0;\n\t\t\twhile (offset < bytes.length\n\t\t\t\t\t&& (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {\n\t\t\t\toffset += numRead;\n\t\t\t}\n\n\t\t\t// Ensure all the bytes have been read in\n\t\t\tif (offset < bytes.length) {\n\t\t\t\tis.close();\n\t\t\t\tthrow new IOException(\"Could not completely read file \"+fileToCache.getName());\n\t\t\t}\n\n\t\t\t// Close the input stream and return bytes\n\t\t\tis.close();\n\n\t\t\tcache.put(key,bytes);\n\n\t\t} catch (Exception e){\n\t\t\tlogger.error(\"Error adding to cache! \" + e.getMessage(), e);\n\t\t}\n\t}\n\t/**\n\t * Gets the cached file as an InputStream.\n\t * Clients should check for null as the item might have expired in the  cache.\n\t * @param key\n\t * @return An {@code InputStream} or null. \n\t */\n\tpublic  static InputStream getInputStream(String key){\n\t\t//logger.debug(\"returning \" + key + \" from file cache (cache size: \" + cache.size() + \")\");\n\t\tbyte[] bytes = cache.get(key);\n\t\tif ( bytes == null)\n\t\t\treturn null;\n\n\t\treturn new ByteArrayInputStream(bytes);\n\n\t}\n\n\t/**\n\t * Returns the number of items in the cache.\n\t * If the cache is {@}, returns -1\n\t * @return\n\t */\n\tpublic static int size() {\n\t\tif ( cache != null)\n\t\t\treturn cache.size();\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\t/**\n\t * Removes all elements from the cache\n\t */\n\tpublic static void clear(){\n\t   cache.clear();\n\t}\n\n}\n","originTest":"package org.biojava.nbio.core.util;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nclass FlatFileCacheTest {\n\n    final String aDNA = \"ATCG\";\n    final String aProtein = \"WCTH\";\n\n    @BeforeEach\n    void before(){\n        FlatFileCache.clear();\n    }\n\n    File createSmallTmpFile() throws IOException{\n        File f = Files.createTempFile(\"flatFile\", \"txt\").toFile();\n       writeToFile( aDNA, f);\n        return f;\n    }\n\n    private void writeToFile(String aDNA, File f) throws IOException {\n        FileOutputStream fos = new FileOutputStream(f);\n        fos.write(aDNA.getBytes(StandardCharsets.UTF_8));\n    }\n\n    @Test\n    void flatFileRetrieve () throws IOException {\n        File aDNAFile = createSmallTmpFile();\n        assertEquals(0, FlatFileCache.size());\n        FlatFileCache.addToCache(\"key\", aDNAFile);\n        assertEquals(1, FlatFileCache.size());\n\n        InputStream is = FlatFileCache.getInputStream(\"key\");\n        assertNotNull(is);\n        byte [] b = new byte[1024];\n        int read = is.read(b);\n        assertEquals(aDNAFile.length(), (long)read );\n        assertEquals(aDNA, new String(b, \"UTF8\").substring(0,4));\n    }\n\n    @Test\n    void clearRemovesAllItems () throws IOException {\n        for (int i = 0; i< 10; i++) {\n            FlatFileCache.addToCache(\"\"+i, createSmallTmpFile());\n        }\n        assertEquals(10, FlatFileCache.size());\n        FlatFileCache.clear();\n        assertEquals(0, FlatFileCache.size());\n    }\n\n    @Test\n    void nullReturnedIfNoValueForKey () throws IOException {\n        assertNull(FlatFileCache.getInputStream(\"nonexistent\"));\n    }\n\n    @Test\n    void fileCanBeModifiedButCachedValueIsUnchanged() throws IOException{\n        File aDNAFile = createSmallTmpFile();\n        FlatFileCache.addToCache(\"key\", aDNAFile);\n        long originalLength = aDNAFile.length();\n        \n        // write new content to original file\n        writeToFile( aProtein , aDNAFile);\n\n        // retrieve from cache, is unchanged\n        InputStream is = FlatFileCache.getInputStream(\"key\");\n        byte [] b = new byte[1024];\n        int read = is.read(b);\n        assertEquals(originalLength, (long)read );\n        assertEquals(aDNA, new String(b, \"UTF8\").substring(0,4));\n    }\n\n}\n","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":false}