{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/xtal/CrystalBuilder.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/xtal/TestCrystalBuilder.java","prod_time":"2014-09-09 23:20:05","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":36,"add_classname_line":0,"add_condition_line":20,"add_field_line":2,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":3,"del_annotation_line":0,"del_call_line":49,"del_classname_line":0,"del_condition_line":26,"del_field_line":10,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"c61bedc4b2c1479285cf7b617507518cf96fbd84","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.bio.structure.xtal;\n\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.contact.AtomContactSet;\nimport org.biojava.bio.structure.contact.StructureInterface;\nimport org.biojava.bio.structure.contact.StructureInterfaceList;\n\n\n\n/**\n * A class containing methods to find interfaces in a given crystallographic Structure by\n * reconstructing the crystal lattice through application of symmetry operators\n *  \n * @author duarte_j\n *\n */\npublic class CrystalBuilder {\n\t\n\t// Default number of cell neighbors to try in interface search (in 3 directions of space). \n\t// In the search, only bounding box overlaps are tried, thus there's not so much overhead in adding \n\t// more cells. We actually tested it and using numCells from 1 to 10 didn't change runtimes at all.\n\t// Examples with interfaces in distant neighbor cells:\n\t//   2nd neighbors: 3hz3, 1wqj, 2de3, 1jcd\n\t//   3rd neighbors: 3bd3, 1men, 2gkp, 1wui\n\t//   5th neighbors: 2ahf, 2h2z\n\t//   6th neighbors: 1was (in fact interfaces appear only at 5th neighbors for it) \n\t// Maybe this could be avoided by previously translating the given molecule to the first cell,\n\t// BUT! some bona fide cases exist, e.g. 2d3e: it is properly placed at the origin but the molecule \n\t// is enormously long in comparison with the dimensions of the unit cell, some interfaces come at the 7th neighbor.\n\t// After a scan of the whole PDB (Oct 2013) using numCells=50, the highest one was 4jgc with \n\t// interfaces up to the 11th neighbor. Other high ones (9th neighbors) are 4jbm and 4k3t.\n\t// We set the default value to 12 based on that (having not seen any difference in runtime)\n\tprivate static final int DEF_NUM_CELLS = 12;\n\t\n\t/**\n\t * Whether to consider HETATOMs in contact calculations\n\t */\n\tprivate static final boolean INCLUDE_HETATOMS = true;\n\t\n\tprivate Structure pdb;\n\tprivate SpaceGroup sg;\n\tprivate int numChainsAu;\n\tprivate int numOperatorsSg;\n\t\n\tprivate boolean verbose;\n\t\n\tprivate int numCells;\n\t\n\tprivate ArrayList<CrystalTransform> visited;\n\n\t/**\n\t * The bounding boxes of all AUs of the unit cell\n\t */\n\tprivate UnitCellBoundingBox bbGrid;\n\t\n\t// debugging vars\n\tprivate long start; \n\tprivate long end;\n\tprivate int trialCount;\t\n\tprivate int skippedRedundant;\n\tprivate int skippedAUsNoOverlap;\n\tprivate int skippedChainsNoOverlap;\n\tprivate int skippedSelfEquivalent;\n\t\n\n\t\n\tpublic CrystalBuilder(Structure pdb) {\n\t\tthis.pdb = pdb;\n\t\tthis.numChainsAu = pdb.getChains().size();\n\t\tthis.sg = (pdb.getCrystallographicInfo()==null)?null:pdb.getCrystallographicInfo().getSpaceGroup();\n\t\tthis.numOperatorsSg = 1;\n\t\tif (sg!=null) {\n\t\t\tthis.numOperatorsSg = sg.getMultiplicity();\n\t\t}\n\t\tthis.verbose = false;\n\t\tthis.numCells = DEF_NUM_CELLS;\t\t\n\t}\n\t\n\t/**\n\t * Set the verbose flag for verbose output of search algorithm to stdout\n\t * @param verbose\n\t */\n\tpublic void setVerbose(boolean verbose) {\n\t\tthis.verbose = verbose;\n\t}\n\t\n\t/**\n\t * Set the number of neighboring crystal cells that will be used in the search for contacts \n\t * @param numCells\n\t */\n\tpublic void setNumCells(int numCells) {\n\t\tthis.numCells = numCells;\n\t}\n\t\n\tprivate void initialiseVisited() {\n\t\tvisited = new ArrayList<CrystalTransform>();\n\t}\n\t\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon \n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains \n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within \n\t * the given cutoff distance.\n\t * NOTE: currently for entries that contain MTRXn records (e.g. large viral structures)\n\t * the full crystal is not reconstructed (see http://www.wwpdb.org/documentation/format33/sect8.html#MTRIXn)\n\t * @param cutoff the distance cutoff for 2 chains to be considered in contact\n\t * @return\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces(double cutoff) {\t\n\n\t\t// TODO at the moment this can't reconstruct the full crystal of many virus entries in the PDB\n\t\t// since it doesn't take into account the MATRXn records \n\t\t// (see http://www.wwpdb.org/documentation/format33/sect8.html#MTRIXn)\n\t\t\n\t\tStructureInterfaceList set = new StructureInterfaceList();\n\t\t\n\t\t// initialising the visited ArrayList for keeping track of symmetry redundancy\n\t\tinitialiseVisited();\n\t\t\n\t\t\n\t\t\n\t\t// initialising debugging vars\n\t\tstart = -1; \n\t\tend = -1;\n\t\ttrialCount = 0;\n\t\tskippedRedundant = 0;\n\t\tskippedAUsNoOverlap = 0;\n\t\tskippedChainsNoOverlap = 0;\n\t\tskippedSelfEquivalent = 0;\n\t\t\n\t\tbbGrid = new UnitCellBoundingBox(numOperatorsSg, numChainsAu);\n\t\t\n\t\tbbGrid.setOriginalAuBbs(pdb, INCLUDE_HETATOMS);\t\t\n\t\t\n\t\t// we can always calculate contacts within AU (be it crystallographic or not)\n\t\tcalcInterfacesWithinAu(set, cutoff);\n\t\t\n\t\t// this condition covers 3 cases:\n\t\t// a) entries with expMethod X-RAY/other diffraction and defined crystalCell (most usual case)\n\t\t// b) entries with expMethod null but defined crystalCell (e.g. PDB file with CRYST1 record but no expMethod annotation) \n\t\t// c) entries with expMethod not X-RAY (e.g. NMR) and defined crystalCell (NMR entries do have a dummy CRYST1 record \"1 1 1 90 90 90 P1\")\n\t\tif (    pdb.getCrystallographicInfo()!=null && \n\t\t\t\tpdb.getCrystallographicInfo().getCrystalCell()!=null && \n\t\t\t\tpdb.isCrystallographic()) {\n\t\t\t\t\t\t\n\n\t\t\t// we can only do this for crystallographic structures\n\t\t\tcalcInterfacesCrystal(set, cutoff);\n\t\t\t\n\t\t\t\n\t\t\tif (verbose) {\n\t\t\t\tend = System.currentTimeMillis();\n\t\t\t\tSystem.out.println(\"\\n\"+trialCount+\" chain-chain clash trials done. Time \"+(end-start)/1000+\"s\");\n\t\t\t\tSystem.out.println(\"  skipped (not overlapping AUs)       : \"+skippedAUsNoOverlap);\n\t\t\t\tSystem.out.println(\"  skipped (not overlapping chains)    : \"+skippedChainsNoOverlap);\n\t\t\t\tSystem.out.println(\"  skipped (sym redundant op pairs)    : \"+skippedRedundant);\n\t\t\t\tSystem.out.println(\"  skipped (sym redundant self op)     : \"+skippedSelfEquivalent);\n\n\t\t\t\tSystem.out.println(\"Found \"+set.size()+\" interfaces.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn set;\n\t}\n\t\n\t/**\n\t * Calculate interfaces within asymmetric unit\n\t * @param set\n\t * @param cutoff\n\t */\n\tprivate void calcInterfacesWithinAu(StructureInterfaceList set, double cutoff) {\n\t\t\n\t\t\n\t\tif (verbose) {\n\t\t\ttrialCount = 0;\n\t\t\tstart= System.currentTimeMillis();\t\t\t\n\t\t\tSystem.out.println(\"\\nInterfaces within asymmetric unit (total possible trials \"+(numChainsAu*(numChainsAu-1))/2+\")\");\n\t\t\tSystem.out.print(\"[ 0-( 0, 0, 0)] \"); // printing header for dots line to have same format as in calcInterfacesCrystal\n\t\t}\n\t\t\n\t\tint contactsFound = 0;\n\t\t\n\t\tint i = -1;\n\t\tfor (Chain chaini:pdb.getChains()) {\n\t\t\ti++;\n\t\t\tint j = -1;\n\t\t\tfor (Chain chainj:pdb.getChains()) {\n\t\t\t\tj++;\n\t\t\t\tif (j<=i) continue;\n\t\t\t\t\n\t\t\t\t// before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n\t\t\t\tif (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGrid.getChainBoundingBox(0,j), cutoff)) { \n\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\tskippedChainsNoOverlap++;\n\t\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (verbose) trialCount++;\n\t\t\t\t\n\t\t\t\t// note that we don't consider hydrogens when calculating contacts\n\t\t\t\tAtomContactSet graph = StructureTools.getAtomsInContact(chaini, chainj, cutoff, INCLUDE_HETATOMS); \n\t\t\t\tif (graph.size()>0) {\n\t\t\t\t\tcontactsFound++;\n\t\t\t\t\tif (verbose) System.out.print(\"x\");\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tCrystalTransform transf = new CrystalTransform(sg);\n\t\t\t\t\tStructureInterface interf = new StructureInterface(\n\t\t\t\t\t\t\tStructureTools.getAllAtomArray(chaini), StructureTools.getAllAtomArray(chainj),\n\t\t\t\t\t\t\tchaini.getChainID(), chainj.getChainID(),\n\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\ttransf, transf);\n\t\t\t\t\t\n\t\t\t\t\tset.add(interf);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tif (verbose) System.out.print(\"o\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (verbose) {\n\t\t\tend = System.currentTimeMillis();\n\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+(numChainsAu*(numChainsAu-1))/2+\")\");\n\t\t\tSystem.out.println(\"\\n\"+trialCount+\" chain-chain clash trials done. Time \"+(end-start)/1000+\"s\");\n\t\t}\n\n\t\t\n\t\t\n\t}\n\t\n\t/**\n\t * Calculate interfaces between original asymmetric unit and neighboring \n\t * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0 \n\t * @param set\n\t * @param cutoff\n\t */\n\tprivate void calcInterfacesCrystal(StructureInterfaceList set, double cutoff) {\n\n\t\t// both arrays below are of size numOperatorsSg (multiplicity of space group)\n\t\t// generate complete unit cell, by applying all SG operators\n\t\tStructure[] cell = getUnitCell();\n\t\t// we calculate all the bounds of each of the asym units, those will then be reused and translated\n\t\tbbGrid.setAllNonAuBbs(cell, INCLUDE_HETATOMS);\n\t\t\n\t\tif (verbose) {\n\t\t\ttrialCount = 0;\n\t\t\tstart= System.currentTimeMillis();\n\t\t\tint neighbors = (2*numCells+1)*(2*numCells+1)*(2*numCells+1)-1;\n\t\t\tint trials = numChainsAu*numOperatorsSg*numChainsAu*neighbors;\n\t\t\tSystem.out.println(\"\\nInterfaces between the original asym unit and the neighbouring \"+neighbors+\" whole unit cells (\"+numCells+\" neighbours)\" +\n\t\t\t\t\t\"(2x\"+numChainsAu+\"chains x \"+numOperatorsSg+\"AUs x \"+neighbors+\"cells = \"+trials+\" total possible trials)\");\n\t\t}\n\n\n\t\tfor (int i=-numCells;i<=numCells;i++) {\n\t\t\tfor (int j=-numCells;j<=numCells;j++) {\n\t\t\t\tfor (int k=-numCells;k<=numCells;k++) {\n\t\t\t\t\t\n\t\t\t\t\tPoint3i trans = new Point3i(i,j,k);\n\t\t\t\t\tVector3d transOrth = new Vector3d(i,j,k);\n\t\t\t\t\tpdb.getCrystallographicInfo().getCrystalCell().transfToOrthonormal(transOrth);\n\t\t\t\t\tUnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n\n\t\t\t\t\tfor (int au=0;au<numOperatorsSg;au++) { \n\t\t\t\t\t\tif (au==0 && i==0 && j==0 && k==0) continue; // that would be the original au \n\n\t\t\t\t\t\t// short-cut strategies\n\t\t\t\t\t\t// 1) we skip first of all if the bounding boxes of the AUs don't overlap\n\t\t\t\t\t\tif (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(au), cutoff)) {\n\t\t\t\t\t\t\tif (verbose) skippedAUsNoOverlap++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2) we check if we didn't already see its equivalent symmetry operator partner \t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tCrystalTransform tt = new CrystalTransform(sg,au);\n\t\t\t\t\t\ttt.translate(trans);\n\t\t\t\t\t\tif (isRedundant(tt)) { \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (verbose) skippedRedundant++;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddVisited(tt);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean selfEquivalent = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// now we copy and actually translate the AU if we saw it does overlap and the sym op was not redundant\n\t\t\t\t\t\tStructure jAsym = cell[au].clone();\n\t\t\t\t\t\tCalc.translate(jAsym, transOrth);\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t// 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\t\t\t\t\t\t\n\t\t\t\t\t\tif (tt.isEquivalent(tt)) { \n\t\t\t\t\t\t\tif (verbose) \n\t\t\t\t\t\t\t\tSystem.out.println(\"Transform \"+tt+\" is equivalent to itself, will skip half of i-chains to j-chains comparisons\");\n\t\t\t\t\t\t\t// in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n\t\t\t\t\t\t\t// we set a flag and do that within the loop below\n\t\t\t\t\t\t\tselfEquivalent = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (verbose) System.out.print(tt+\" \");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Now that we know that boxes overlap and operator is not redundant, we have to go to the details \n\t\t\t\t\t\tint contactsFound = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tint jIdx = -1;\n\t\t\t\t\t\tfor (Chain chainj:jAsym.getChains()) {\n\t\t\t\t\t\t\tjIdx++;\n\t\t\t\t\t\t\tint iIdx = -1;\n\t\t\t\t\t\t\tfor (Chain chaini:pdb.getChains()) { // we only have to compare the original asymmetric unit to every full cell around\n\t\t\t\t\t\t\t\tiIdx++;\n\t\t\t\t\t\t\t\tif(selfEquivalent && (jIdx>iIdx)) {\n\t\t\t\t\t\t\t\t\t// in case of self equivalency of the operator we can safely skip half of the matrix\n\t\t\t\t\t\t\t\t\tskippedSelfEquivalent++;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n\t\t\t\t\t\t\t\tif (!bbGrid.getChainBoundingBox(0,iIdx).overlaps(bbGridTrans.getChainBoundingBox(au,jIdx),cutoff)) {\n\t\t\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\t\t\tskippedChainsNoOverlap++;\n\t\t\t\t\t\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (verbose) trialCount++;\n\n\t\t\t\t\t\t\t\t// note that we don't consider hydrogens when calculating contacts\n\t\t\t\t\t\t\t\tAtomContactSet graph = StructureTools.getAtomsInContact(chaini, chainj, cutoff, INCLUDE_HETATOMS);\n\t\t\t\t\t\t\t\tif (graph.size()>0) {\n\t\t\t\t\t\t\t\t\tcontactsFound++;\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif (verbose) System.out.print(\"x\");\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tCrystalTransform transf = new CrystalTransform(sg);\n\t\t\t\t\t\t\t\t\tStructureInterface interf = new StructureInterface(\n\t\t\t\t\t\t\t\t\t\t\tStructureTools.getAllAtomArray(chaini), StructureTools.getAllAtomArray(chainj),\n\t\t\t\t\t\t\t\t\t\t\tchaini.getChainID(), chainj.getChainID(),\n\t\t\t\t\t\t\t\t\t\t\tgraph,\n\t\t\t\t\t\t\t\t\t\t\ttransf, tt);\n\n\t\t\t\t\t\t\t\t\tset.add(interf);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (verbose) System.out.print(\"o\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\tif (selfEquivalent) \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+(numChainsAu*(numChainsAu+1))/2+\")\");\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+numChainsAu*numChainsAu+\")\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\t\n\tprivate void addVisited(CrystalTransform tt) {\n\t\tvisited.add(tt);\n\t}\n\t\n\t/**\n\t * Checks whether given transformId/translation is symmetry redundant \n\t * Two transformations are symmetry redundant if their matrices (4d) multiplication gives the identity, i.e.\n\t * if one is the inverse of the other.\n\t * @param tt\n\t * @return\n\t */\n\tprivate boolean isRedundant(CrystalTransform tt) {\n\t\t\n\t\tIterator<CrystalTransform> it = visited.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tCrystalTransform v = it.next();\n\t\t\t\n\t\t\tif (tt.isEquivalent(v)) {\n\n\t\t\t\tif (verbose) System.out.println(\"Skipping redundant transformation: \"+tt+\", equivalent to \"+v);\n\t\t\t\t\n\t\t\t\t// there's only 1 possible equivalent partner for each visited matrix \n\t\t\t\t// (since the equivalent is its inverse matrix and the inverse matrix is unique)\n\t\t\t\t// thus once the partner has been seen, we don't need to check it ever again\n\t\t\t\tit.remove();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Generates all symmetry-related objects from this asym unit and returns the whole\n\t * unit cell (this asymmetric unit plus the symmetry-related objects). \n\t * @return\n\t */\n\tprivate Structure[] getUnitCell() {\n\n\t\tStructure[] aus = new Structure[numOperatorsSg];\n\t\taus[0] = pdb;\n\n\t\tint i = 1;\n\t\tfor (Matrix4d m:pdb.getCrystallographicInfo().getTransformationsOrthonormal()) {\n\t\t\t\n\t\t\tStructure sym = pdb.clone();\n\t\t\t\n\t\t\tCalc.transform(sym, m); \n\n\t\t\taus[i] = sym;\n\t\t\t\n\t\t\ti++;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn aus;\n\t}\n\t\n\t\n}\n","changedPro":"package org.biojava.bio.structure.xtal;\n\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Vector3d;\n\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.PDBCrystallographicInfo;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.contact.AtomContactSet;\nimport org.biojava.bio.structure.contact.StructureInterface;\nimport org.biojava.bio.structure.contact.StructureInterfaceList;\n\n\n\n/**\n * A class containing methods to find interfaces in a given crystallographic Structure by\n * reconstructing the crystal lattice through application of symmetry operators\n *  \n * @author duarte_j\n *\n */\npublic class CrystalBuilder {\n\t\n\t// Default number of cell neighbors to try in interface search (in 3 directions of space). \n\t// In the search, only bounding box overlaps are tried, thus there's not so much overhead in adding \n\t// more cells. We actually tested it and using numCells from 1 to 10 didn't change runtimes at all.\n\t// Examples with interfaces in distant neighbor cells:\n\t//   2nd neighbors: 3hz3, 1wqj, 2de3, 1jcd\n\t//   3rd neighbors: 3bd3, 1men, 2gkp, 1wui\n\t//   5th neighbors: 2ahf, 2h2z\n\t//   6th neighbors: 1was (in fact interfaces appear only at 5th neighbors for it) \n\t// Maybe this could be avoided by previously translating the given molecule to the first cell,\n\t// BUT! some bona fide cases exist, e.g. 2d3e: it is properly placed at the origin but the molecule \n\t// is enormously long in comparison with the dimensions of the unit cell, some interfaces come at the 7th neighbor.\n\t// After a scan of the whole PDB (Oct 2013) using numCells=50, the highest one was 4jgc with \n\t// interfaces up to the 11th neighbor. Other high ones (9th neighbors) are 4jbm and 4k3t.\n\t// We set the default value to 12 based on that (having not seen any difference in runtime)\n\tprivate static final int DEF_NUM_CELLS = 12;\n\t\n\t/**\n\t * Whether to consider HETATOMs in contact calculations\n\t */\n\tprivate static final boolean INCLUDE_HETATOMS = true;\n\t\n\tprivate Structure structure;\n\tprivate PDBCrystallographicInfo crystallographicInfo;\n\tprivate int numChainsAu;\n\tprivate int numOperatorsSg;\n\t\n\tprivate boolean verbose;\n\t\n\tprivate int numCells;\n\t\n\tprivate ArrayList<CrystalTransform> visited;\n\t\n\n\t\n\tpublic CrystalBuilder(Structure structure) {\n\t\tthis.structure = structure;\n\t\tthis.crystallographicInfo = structure.getCrystallographicInfo();\n\t\t\n\t\tthis.numChainsAu = structure.getChains().size();\t\t\n\t\tthis.numOperatorsSg = 1;\n\t\tif (structure.isCrystallographic()) {\n\t\t\tthis.numOperatorsSg = this.crystallographicInfo.getSpaceGroup().getMultiplicity();\n\t\t}\n\t\t\n\t\tthis.verbose = false;\n\t\tthis.numCells = DEF_NUM_CELLS;\t\t\t\t\n\t\t\n\t}\n\t\n\t/**\n\t * Set the verbose flag for verbose output of search algorithm to stdout\n\t * @param verbose\n\t */\n\tpublic void setVerbose(boolean verbose) {\n\t\tthis.verbose = verbose;\n\t}\n\t\n\t/**\n\t * Set the number of neighboring crystal cells that will be used in the search for contacts \n\t * @param numCells\n\t */\n\tpublic void setNumCells(int numCells) {\n\t\tthis.numCells = numCells;\n\t}\n\t\n\tprivate void initialiseVisited() {\n\t\tvisited = new ArrayList<CrystalTransform>();\n\t}\n\t\n\t/**\n\t * Returns the list of unique interfaces that the given Structure has upon \n\t * generation of all crystal symmetry mates. An interface is defined as any pair of chains \n\t * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within \n\t * the given cutoff distance.\n\t * @param cutoff the distance cutoff for 2 chains to be considered in contact\n\t * @return\n\t */\n\tpublic StructureInterfaceList getUniqueInterfaces(double cutoff) {\t\n\n\t\t\n\t\tStructureInterfaceList set = new StructureInterfaceList();\n\t\t\n\t\t// initialising the visited ArrayList for keeping track of symmetry redundancy\n\t\tinitialiseVisited();\n\t\t\n\t\t\n\t\t\n\t\t// the isCrystallographic() condition covers 3 cases:\n\t\t// a) entries with expMethod X-RAY/other diffraction and defined crystalCell (most usual case)\n\t\t// b) entries with expMethod null but defined crystalCell (e.g. PDB file with CRYST1 record but no expMethod annotation) \n\t\t// c) entries with expMethod not X-RAY (e.g. NMR) and defined crystalCell (NMR entries do have a dummy CRYST1 record \"1 1 1 90 90 90 P1\")\n\n\n\n\t\tcalcInterfacesCrystal(set, cutoff, structure.isCrystallographic());\n\n\t\t\n\t\treturn set;\n\t}\n\t\n\t/**\n\t * Calculate interfaces between original asymmetric unit and neighboring \n\t * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0 \n\t * @param set\n\t * @param cutoff\n\t */\n\tprivate void calcInterfacesCrystal(StructureInterfaceList set, double cutoff, boolean isCrystallographic) {\n\n\t\t\n\t\t// initialising debugging vars\n\t\tlong start = -1; \n\t\tlong end = -1;\n\t\tint trialCount = 0;\n\t\tint skippedRedundant = 0;\n\t\tint skippedAUsNoOverlap = 0;\n\t\tint skippedChainsNoOverlap = 0;\n\t\tint skippedSelfEquivalent = 0;\n\n\t\t\n\n\t\t// generate complete unit cell, by applying all SG operators (array is of size numOperatorsSg)\n\t\tStructure[] cell = getUnitCell();\n\n\t\t// The bounding boxes of all AUs of the unit cell\t\t\n\t\tUnitCellBoundingBox bbGrid = new UnitCellBoundingBox(numOperatorsSg, numChainsAu);;\n\t\t// we calculate all the bounds of each of the asym units, those will then be reused and translated\n\t\tbbGrid.setAllBbs(cell, INCLUDE_HETATOMS);\n\t\t\n\t\t// if not crystallographic there's no search to do in other cells, only chains within \"AU\" will be checked\n\t\tif (!isCrystallographic) numCells = 0;\n\t\t\n\t\tif (verbose) {\n\t\t\ttrialCount = 0;\n\t\t\tstart= System.currentTimeMillis();\n\t\t\tint neighbors = (2*numCells+1)*(2*numCells+1)*(2*numCells+1)-1;\n\t\t\tint auTrials = (numChainsAu*(numChainsAu-1))/2;\n\t\t\tint trials = numChainsAu*numOperatorsSg*numChainsAu*neighbors;\n\t\t\tSystem.out.println(\"Chain clash trials within original AU: \"+auTrials);\n\t\t\tSystem.out.println(\n\t\t\t\t\t\"Chain clash trials between the original AU and the neighbouring \"+neighbors+\n\t\t\t\t\t\" whole unit cells (\"+numCells+\" neighbours)\" +\n\t\t\t\t\t\"(2x\"+numChainsAu+\"chains x \"+numOperatorsSg+\"AUs x \"+neighbors+\"cells) : \"+trials);\n\t\t\tSystem.out.println(\"Total trials: \"+(auTrials+trials));\n\t\t}\n\n\n\t\tfor (int a=-numCells;a<=numCells;a++) {\n\t\t\tfor (int b=-numCells;b<=numCells;b++) {\n\t\t\t\tfor (int c=-numCells;c<=numCells;c++) {\n\t\t\t\t\t\n\t\t\t\t\tPoint3i trans = new Point3i(a,b,c);\n\t\t\t\t\tVector3d transOrth = new Vector3d(a,b,c);\n\t\t\t\t\tif (a!=0 || b!=0 || c!=0)\n\t\t\t\t\t\t// we avoid doing the transformation for 0,0,0 (in case it's not crystallographic) \n\t\t\t\t\t\tthis.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);\n\t\t\t\t\tUnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n\n\t\t\t\t\tfor (int n=0;n<numOperatorsSg;n++) { \n\n\t\t\t\t\t\t// short-cut strategies\n\t\t\t\t\t\t// 1) we skip first of all if the bounding boxes of the AUs don't overlap\n\t\t\t\t\t\tif (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n), cutoff)) {\n\t\t\t\t\t\t\tif (verbose) skippedAUsNoOverlap++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// 2) we check if we didn't already see its equivalent symmetry operator partner \t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tCrystalTransform tt = new CrystalTransform(this.crystallographicInfo.getSpaceGroup(), n);\n\t\t\t\t\t\ttt.translate(trans);\n\t\t\t\t\t\tif (isRedundant(tt)) { \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (verbose) skippedRedundant++;\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddVisited(tt);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean selfEquivalent = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// now we copy and actually translate the AU if we saw it does overlap and the sym op was not redundant\n\t\t\t\t\t\tStructure jAsym = null;\n\t\t\t\t\t\tif (n==0 && a==0 && b==0 && c==0) {\n\t\t\t\t\t\t\t// special case: for original AU there's no need to clone and no need to translate \n\t\t\t\t\t\t\tjAsym = cell[0];\n\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\tjAsym = cell[n].clone();\n\t\t\t\t\t\t\tCalc.translate(jAsym, transOrth);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t// 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\t\t\t\t\t\t\n\t\t\t\t\t\tif (tt.isEquivalent(tt)) { \n\t\t\t\t\t\t\tif (verbose) \n\t\t\t\t\t\t\t\tSystem.out.println(\"Transform \"+tt+\" is equivalent to itself, will skip half of i-chains to j-chains comparisons\");\n\t\t\t\t\t\t\t// in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n\t\t\t\t\t\t\t// we set a flag and do that within the loop below\n\t\t\t\t\t\t\tselfEquivalent = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (verbose) System.out.print(tt+\" \");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Now that we know that boxes overlap and operator is not redundant, we have to go to the details \n\t\t\t\t\t\tint contactsFound = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tint j = -1;\n\t\t\t\t\t\tfor (Chain chainj:jAsym.getChains()) {\n\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\tint i = -1;\n\t\t\t\t\t\t\tfor (Chain chaini:structure.getChains()) { // we only have to compare the original asymmetric unit to every full cell around\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\tif(selfEquivalent && (j>i)) {\n\t\t\t\t\t\t\t\t\t// in case of self equivalency of the operator we can safely skip half of the matrix\n\t\t\t\t\t\t\t\t\tskippedSelfEquivalent++;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// special case of original AU, we don't compare a chain to itself\n\t\t\t\t\t\t\t\tif (n==0 && a==0 && b==0 && c==0 && i==j) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n\t\t\t\t\t\t\t\tif (!bbGrid.getChainBoundingBox(0,i).overlaps(bbGridTrans.getChainBoundingBox(n,j),cutoff)) {\n\t\t\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\t\t\tskippedChainsNoOverlap++;\n\t\t\t\t\t\t\t\t\t\tSystem.out.print(\".\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (verbose) trialCount++;\n\n\t\t\t\t\t\t\t\t// finally we've gone through all short-cuts and the 2 chains seem to be close enough:\n\t\t\t\t\t\t\t\t// we do the calculation of contacts\n\t\t\t\t\t\t\t\tStructureInterface interf = calcContacts(chaini, chainj, cutoff, tt);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (interf!=null) {\n\t\t\t\t\t\t\t\t\tcontactsFound++;\n\t\t\t\t\t\t\t\t\tset.add(interf);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\tif (a==0 && b==0 && c==0 && n==0) \n\t\t\t\t\t\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+(numChainsAu*(numChainsAu-1))/2+\")\");\n\t\t\t\t\t\t\telse if (selfEquivalent) \t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+(numChainsAu*(numChainsAu+1))/2+\")\");\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tSystem.out.println(\" \"+contactsFound+\"(\"+numChainsAu*numChainsAu+\")\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (verbose) {\n\t\t\tend = System.currentTimeMillis();\n\t\t\tSystem.out.println(\"\\n\"+trialCount+\" chain-chain clash trials done. Time \"+(end-start)/1000+\"s\");\n\t\t\tSystem.out.println(\"  skipped (not overlapping AUs)       : \"+skippedAUsNoOverlap);\n\t\t\tSystem.out.println(\"  skipped (not overlapping chains)    : \"+skippedChainsNoOverlap);\n\t\t\tSystem.out.println(\"  skipped (sym redundant op pairs)    : \"+skippedRedundant);\n\t\t\tSystem.out.println(\"  skipped (sym redundant self op)     : \"+skippedSelfEquivalent);\n\n\t\t\tSystem.out.println(\"Found \"+set.size()+\" interfaces.\");\n\t\t}\n\t}\n\n\tprivate StructureInterface calcContacts(Chain chaini, Chain chainj, double cutoff, CrystalTransform tt) {\n\t\t\n\t\t// note that we don't consider hydrogens when calculating contacts\n\t\tAtomContactSet graph = StructureTools.getAtomsInContact(chaini, chainj, cutoff, INCLUDE_HETATOMS);\n\t\t\n\t\tif (graph.size()>0) {\n\t\t\tif (verbose) System.out.print(\"x\");\n\t\t\t\n\t\t\tCrystalTransform transf = new CrystalTransform(this.crystallographicInfo.getSpaceGroup());\n\t\t\tStructureInterface interf = new StructureInterface(\n\t\t\t\t\tStructureTools.getAllAtomArray(chaini), StructureTools.getAllAtomArray(chainj),\n\t\t\t\t\tchaini.getChainID(), chainj.getChainID(),\n\t\t\t\t\tgraph,\n\t\t\t\t\ttransf, tt);\n\n\t\t\treturn interf;\n\t\t\t\n\t\t} else {\n\t\t\tif (verbose) System.out.print(\"o\");\n\t\t\treturn null;\n\t\t}\t\t\n\t}\n\t\n\tprivate void addVisited(CrystalTransform tt) {\n\t\tvisited.add(tt);\n\t}\n\t\n\t/**\n\t * Checks whether given transformId/translation is symmetry redundant \n\t * Two transformations are symmetry redundant if their matrices (4d) multiplication gives the identity, i.e.\n\t * if one is the inverse of the other.\n\t * @param tt\n\t * @return\n\t */\n\tprivate boolean isRedundant(CrystalTransform tt) {\n\t\t\n\t\tIterator<CrystalTransform> it = visited.iterator();\n\t\twhile (it.hasNext()) {\n\t\t\tCrystalTransform v = it.next();\n\t\t\t\n\t\t\tif (tt.isEquivalent(v)) {\n\n\t\t\t\tif (verbose) System.out.println(\"Skipping redundant transformation: \"+tt+\", equivalent to \"+v);\n\t\t\t\t\n\t\t\t\t// there's only 1 possible equivalent partner for each visited matrix \n\t\t\t\t// (since the equivalent is its inverse matrix and the inverse matrix is unique)\n\t\t\t\t// thus once the partner has been seen, we don't need to check it ever again\n\t\t\t\tit.remove();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Generates all symmetry-related objects from this asym unit and returns the whole\n\t * unit cell (this asymmetric unit plus the symmetry-related objects). \n\t * @return\n\t */\n\tprivate Structure[] getUnitCell() {\n\n\t\tStructure[] aus = new Structure[numOperatorsSg];\n\t\taus[0] = structure;\n\n\t\tif (numOperatorsSg==1) return aus;\n\t\t\n\t\tint i = 1;\n\t\tfor (Matrix4d m:this.crystallographicInfo.getTransformationsOrthonormal()) {\n\t\t\t\n\t\t\tStructure sym = structure.clone();\n\t\t\t\n\t\t\tCalc.transform(sym, m); \n\n\t\t\taus[i] = sym;\n\t\t\t\n\t\t\ti++;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn aus;\n\t}\n\t\n}\n","originTest":"package org.biojava.bio.structure.xtal;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.contact.StructureInterfaceList;\nimport org.biojava3.structure.StructureIO;\nimport org.junit.Test;\n\npublic class TestCrystalBuilder {\n\n\t@Test\n\tpublic void test1NMR() throws IOException, StructureException { \n\n\t\t// a monomer NMR entry: must have no interfaces\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tStructureIO.setAtomCache(cache); \n\n\t\tcache.setUseMmCif(false);\n\t\tStructure s1 = StructureIO.getStructure(\"1NMR\");\n\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertTrue(interfaces.size()==0);\n\n\t}\n\t\n\t@Test\n\tpublic void test1B8G() throws IOException, StructureException { \n\n\t\t// a crystallographic entry: several interfaces\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tStructureIO.setAtomCache(cache); \n\n\t\tcache.setUseMmCif(false);\n\t\tStructure s1 = StructureIO.getStructure(\"1B8G\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertTrue(interfaces.size()>1);\n\t\t\n\t\t\n\t}\n\t\n\t@Test\n\tpublic void test2MFZ() throws IOException, StructureException { \n\n\t\t// a dimer NMR entry: must have 1 interface\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tStructureIO.setAtomCache(cache); \n\n\t\tcache.setUseMmCif(false);\n\t\tStructure s1 = StructureIO.getStructure(\"2MFZ\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertTrue(interfaces.size()==1);\n\t\t\t\t\n\t}\n\n\t@Test\n\tpublic void test4MF8() throws IOException, StructureException { \n\n\t\t// a crystallographic structure with protein+DNA: has only 3 prot-prot interfaces the rest are DNA-involving ones\n\t\t\n\t\tAtomCache cache = new AtomCache();\n\t\t\n\t\tStructureIO.setAtomCache(cache); \n\n\t\tcache.setUseMmCif(false);\n\t\tStructure s1 = StructureIO.getStructure(\"4MF8\");\n\t\tCrystalBuilder cb = new CrystalBuilder(s1);\n\t\tStructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n\t\tassertTrue(interfaces.size()>3);\n\t\t\t\t\n\t}\n}\n","changedTest":"","commitMessage":"Improved the unique xtal interfaces calculation","test_commitMessage":"","allZero":false}