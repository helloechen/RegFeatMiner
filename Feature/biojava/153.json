{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/HetatomImpl.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/HetatomImplTest.java","prod_time":"2015-01-06 19:45:03","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":1,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"656410e64d1e74d86699bd1c723f496cfde8cf5a","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 05.03.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.bio.structure;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.bio.structure.io.mmcif.model.ChemComp;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n *\n * Generic Implementation of a Group interface.\n * AminoAcidImpl and NucleotideImpl are closely related classes.\n * @see AminoAcidImpl\n * @see NucleotideImpl\n * @author Andreas Prlic\n * @author Horvath Tamas\n * @version %I% %G%\n * @since 1.4\n */\npublic class HetatomImpl implements Group,Serializable {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(HetatomImpl.class);\n\n\tprivate static final long serialVersionUID = 4491470432023820382L;\n\n\t/** this is a \"hetatm\".\n\t *\n\t */\n\tpublic static final GroupType type = GroupType.HETATM ;\n\n\tprivate static final List<String> WATERNAMES = Arrays.asList(new String[]{\"HOH\", \"DOD\",  \"WAT\"});\n\n\tprivate Map<String, Object> properties ;\n\n\tprivate long id;\n\n\t/** stores if 3d coordinates are available. */\n\tprotected boolean pdb_flag ;\n\n\t/** 3 letter name of amino acid in pdb file. */\n\tprotected String pdb_name ;\n\n\tprotected ResidueNumber residueNumber;\n\n\tprotected List<Atom> atoms ;\n\n\tprivate Chain parent;\n\n\tprivate Map<String,Atom> atomNameLookup;\n\n\tprivate ChemComp chemComp ;\n\n\tprivate List<Group> altLocs;\n\n\t/**\n\t *  Construct a Hetatom instance. \n\t */\n\tpublic HetatomImpl() {\n\t\tsuper();\n\n\t\tpdb_flag = false;\n\t\tpdb_name = null ;\n\n\t\tresidueNumber = null;\n\t\tatoms    = new ArrayList<Atom>();\n\t\tproperties = new HashMap<String,Object>();\n\t\tparent = null;\n\t\tchemComp = null;\n\t\taltLocs = null;\n\t\t\n\t\tatomNameLookup = new HashMap<String,Atom>();\n\t}\n\n\n\t/**\n\t *  returns true or false, depending if this group has 3D coordinates or not.\n\t * @return true if Group has 3D coordinates\n\t */\n\t@Override\n\tpublic boolean has3D() {\n\t\treturn pdb_flag;\n\t}\n\n\t/** flag if group has 3D data.\n\t *\n\t * @param flag  true to set flag that this Group has 3D coordinates\n\t */\n\t@Override\n\tpublic void setPDBFlag(boolean flag){\n\t\tpdb_flag = flag ;\n\t}\n\n\t/** Set three character name of Group .\n\t *\n\t * @param s  a String specifying the PDBName value\n\t * @see #getPDBName\n\t */\n\t@Override\n\tpublic void setPDBName(String s) {\n\t\t// hetatoms can have pdb_name length < 3. e.g. CU (see 1a4a position 1200 )\n\t\t//if (s.length() != 3) {\n\t\t//throw new PDBParseException(\"amino acid name is not of length 3!\");\n\t\t//}\n\t\tif (s != null && s.equals(\"?\")) logger.info(\"invalid pdbname: ?\");\n\t\tpdb_name =s ;\n\t\t\n\t}\n\n\t/**\n\t * Returns the PDBName.\n\t *\n\t * @return a String representing the PDBName value\n\t * @see #setPDBName\n\t */\n\t@Override\n\tpublic String getPDBName() { return pdb_name;}\n\n\t/**\n\t * {@inheritDoc} \n\t */\n\t@Override\n\tpublic void addAtom(Atom atom){\n\t\tatom.setGroup(this);\n\t\tatoms.add(atom);\n\t\tif (atom.getCoords() != null){\n\t\t\t// we have got coordinates!\n\t\t\tsetPDBFlag(true);\n\t\t}\n\t\tAtom existingAtom = atomNameLookup.put(atom.getName(),atom);\n\t\t\n\t\t// if an atom with same name is added to the group that has to be some kind of problem, \n\t\t// we need to warn properly\n\t\tif (existingAtom!=null) {\n\t\t\tString altLocStr = \"\";\n\t\t\tchar altLoc = atom.getAltLoc();\n\t\t\tif (altLoc!=' ') altLocStr = \"(alt loc '\"+altLoc+\"')\";\n\t\t\tlogger.warn(\"An atom with name \"+atom.getName()+\" \"+altLocStr+\" is already present in group: \"+this.toString()+\". The atom with serial \"+atom.getPDBserial()+\" will be ignored in look-ups.\"); \n\t\t}\n\t};\n\n\n\t/** remove all atoms\n\t *\n\t */\n\t@Override\n\tpublic void clearAtoms() {\n\t\tatoms.clear();\n\t\tsetPDBFlag(false);\n\t\tatomNameLookup.clear();\n\t}\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int size(){ return atoms.size();   }\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic List<Atom> getAtoms(){\n\t\treturn atoms ;\n\t}\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setAtoms(List<Atom> atoms) {\n\t\t\n\t\t// important we are resetting atoms to a new list, we need to reset the lookup too!\n\t\tatomNameLookup.clear();\n\t\t\n\t\tfor (Atom a: atoms){\n\t\t\ta.setGroup(this);\n\t\t\tatomNameLookup.put(a.getName(),a);\n\t\t}\n\t\tthis.atoms = atoms;\n\t\tif ( atoms.size() > 0) {\n\t\t\tpdb_flag = true;\n\t\t}\n\n\t}\n\n\t/**  \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Atom getAtom(String name) {\t\t\n\t\treturn atomNameLookup.get(name);\n\t}\n\n\t/** \n\t * {@inheritDoc}\t\n\t */\n\t@Override\n\tpublic Atom getAtom(int position) {\t\t\t\n\t\t\t\n\t\tif ((position < 0)|| ( position >= atoms.size())) {\n\t\t\t//throw new StructureException(\"No atom found at position \"+position);\n\t\t\treturn null;\n\t\t}\n\t\tAtom a = atoms.get(position);\n\t\treturn a ;\n\t}\n\n\t/**\n\t * {@inheritDoc} \n\t */\n\t@Override\n\tpublic boolean hasAtom(String fullName) {\n\n\t\tAtom a = atomNameLookup.get(fullName.trim());\n\t\tif ( a != null)\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\t \n\t */\n\t@Override\n\tpublic GroupType getType(){ return type;}\n\n\t@Override\n\tpublic String toString(){\n\n\t\tString str = \"Hetatom \"+ residueNumber + \" \" + pdb_name +  \" \"+ pdb_flag;\n\t\tif (pdb_flag) {\n\t\t\tstr = str + \" atoms: \"+atoms.size();\n\t\t}\n\t\tif ( altLocs != null)\n\t\t\tstr += \" has altLocs :\" + altLocs.size(); \n\n\n\t\treturn str ;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean hasAminoAtoms(){\n\t\t// if this method call is performed too often, it should become a\n\t\t// private method and provide a flag for Group object ...\n\n\t\tif (\thasAtom(StructureTools.CA_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.C_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.N_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.O_ATOM_NAME)) {\n\t\t\t\n\t\t\t// this is the minimun requirement for something to be considered an aminoacid with a backbone\n\t\t\t// note that if the backbone is incomplete it won't be considered an aminoacid\n\t\t\t// if it's a HETATOM that has all these atoms, this is a very good guess that this is \n\t\t\t// some kind of non-standard aminoacid\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setProperties(Map<String,Object> props) {\n\t\tproperties =  props ;\n\t}\n\n\t/** return properties.\n\t *\n\t * @return a HashMap object representing the properties value\n\t * @see #setProperties\n\t */\n\t@Override\n\tpublic Map<String, Object> getProperties() {\n\t\treturn properties ;\n\t}\n\n\t/** set a single property .\n\t *\n\t * @see #getProperties\n\t * @see #getProperty\n\t */\n\t@Override\n\tpublic void setProperty(String key, Object value){\n\t\tproperties.put(key,value);\n\t}\n\n\t/** get a single property .\n\t * @param key  a String\n\t * @return an Object\n\t * @see #setProperty\n\t * @see #setProperties\n\t */\n\t@Override\n\tpublic Object getProperty(String key){\n\t\treturn properties.get(key);\n\t}\n\n\n\t/** return an AtomIterator.\n\t *\n\t * @return an Iterator object\n\t */\n\t@Override\n\tpublic Iterator<Atom> iterator() {\n\t\tIterator<Atom> iter = new AtomIterator(this);\n\t\treturn iter ;\n\t}\n\n\t/** returns and identical copy of this Group object .\n\t * @return  and identical copy of this Group object\n\t */\n\t@Override\n\tpublic Object clone(){\n\n\t\tHetatomImpl n = new HetatomImpl();\n\t\tn.setPDBFlag(has3D());\n\t\tn.setResidueNumber(residueNumber);\n\t\t\n\t\tn.setPDBName(getPDBName());\n\t\t\n\t\t// copy the atoms\n\t\tfor (int i=0;i<atoms.size();i++){\n\t\t\tAtom atom = (Atom) atoms.get(i).clone();\n\t\t\tn.addAtom(atom);\n\t\t\tatom.setGroup(n);\n\t\t}\n\t\t\n\t\t// TODO alt locs are not cloned! do we need to clone them? - JD 2014-12-17\n\t\t\n\t\treturn n;\n\t}\n\n\t/** the Hibernate database ID\n\t *\n\t * @return the id\n\t */\n\tpublic long getId() {\n\t\treturn id;\n\t}\n\n\t/** the Hibernate database ID\n\t *\n\t * @param id the hibernate id\n\t */\n\tpublic void setId(long id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic ChemComp getChemComp() {\n\t\tif  ( chemComp == null ) {\n\t\t\tchemComp = ChemCompGroupFactory.getChemComp(pdb_name);\n\t\t\tif (chemComp == null) logger.info(\"getChemComp: \" + pdb_name);\n\t\t}\n\t\treturn chemComp;\n\t}\n\n\t@Override\n\tpublic void setChemComp(ChemComp cc) {\n\t\tchemComp = cc;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setChain(Chain chain) {\n\t\tthis.parent = chain;\n\t\t//TODO: setChain(), getChainId() and ResidueNumber.set/getChainId() are\n\t\t//duplicating functionality at present and could give different values.\n\t\tif (residueNumber != null) {\n\t\t\tresidueNumber.setChainId(chain.getChainID());\n\t\t}\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Chain getChain() {\n\t\treturn parent;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getChainId() {\n\t\tif (parent == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn parent.getChainID();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic ResidueNumber getResidueNumber() {\n\n\t\treturn residueNumber;\n\t}\n\n\n\t@Override\n\tpublic void setResidueNumber(ResidueNumber residueNumber) {\n\t\tthis.residueNumber = residueNumber;\n\t}\n\n\t@Override\n\tpublic void setResidueNumber(String chainId, Integer resNum, Character iCode) {\n\t\tthis.residueNumber = new ResidueNumber(chainId, resNum, iCode);\n\t}\n\n\t@Override\n\tpublic boolean hasAltLoc() {\n\t\tif ( altLocs == null)\n\t\t\treturn false;\n\t\tif ( altLocs.size() > 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<Group> getAltLocs() {\n\t\tif ( altLocs == null)\n\t\t\treturn new ArrayList<Group>();\n\t\treturn altLocs;\n\t}\n\n\t@Override\n\tpublic Group getAltLocGroup(Character altLoc) {\n\t\t\n\t\t\tAtom a = getAtom(0);\n\t\t\tif ( a == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\n\t\t\t// maybe the alt loc group in question is myself\n\t\t\tif (a.getAltLoc().equals(altLoc)) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (altLocs == null || altLocs.size() == 0)\n\t\t\t\treturn null;\n\n\t\t\tfor (Group group : altLocs) {\n\t\t\t\tif (group.getAtoms().isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// determine this group's alt-loc character code by looking\n\t\t\t\t// at its first atom's alt-loc character\n\t\t\t\tAtom b = group.getAtom(0);\n\t\t\t\tif ( b == null)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (b.getAltLoc().equals(altLoc)) {\n\t\t\t\t\treturn group;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void addAltLoc(Group group) {\n\t\tif ( altLocs == null) {\n\t\t\taltLocs = new ArrayList<Group>();\n\t\t}\n\t\taltLocs.add(group);\n\n\t}\n\n\t@Override\n\tpublic boolean isWater() {\n\t\treturn WATERNAMES.contains(pdb_name);\n\t}\n\n\t/** attempts to reduce the memory imprint of this group by trimming \n\t * all internal Collection objects to the required size.\n\t * \n\t */\n\t@Override\n\tpublic void trimToSize(){\n\n\t\tif ( atoms instanceof ArrayList<?>) {\n\t\t\tArrayList<Atom> myatoms = (ArrayList<Atom>) atoms;\n\t\t\tmyatoms.trimToSize();\n\t\t}\n\t\tif ( altLocs instanceof ArrayList<?>){\n\t\t\tArrayList<Group> myAltLocs = (ArrayList<Group>) altLocs;\n\t\t\tmyAltLocs.trimToSize();\n\t\t}\n\t\tatomNameLookup = new HashMap<String,Atom>(atomNameLookup);\n\n\t\tif ( hasAltLoc()) {\n\t\t\tfor (Group alt : getAltLocs()){\n\t\t\t\talt.trimToSize();\n\t\t\t}\n\t\t}\n\n\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 05.03.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.bio.structure;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.io.mmcif.ChemCompGroupFactory;\nimport org.biojava.bio.structure.io.mmcif.model.ChemComp;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n *\n * Generic Implementation of a Group interface.\n * AminoAcidImpl and NucleotideImpl are closely related classes.\n * @see AminoAcidImpl\n * @see NucleotideImpl\n * @author Andreas Prlic\n * @author Horvath Tamas\n * @version %I% %G%\n * @since 1.4\n */\npublic class HetatomImpl implements Group,Serializable {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(HetatomImpl.class);\n\n\tprivate static final long serialVersionUID = 4491470432023820382L;\n\n\t/** \n\t * The GroupType is HETATM\n\t */\n\tpublic static final GroupType type = GroupType.HETATM ;\n\n\n\tprivate Map<String, Object> properties ;\n\n\tprivate long id;\n\n\t/** stores if 3d coordinates are available. */\n\tprotected boolean pdb_flag ;\n\n\t/** 3 letter name of amino acid in pdb file. */\n\tprotected String pdb_name ;\n\n\tprotected ResidueNumber residueNumber;\n\n\tprotected List<Atom> atoms ;\n\n\tprivate Chain parent;\n\n\tprivate Map<String,Atom> atomNameLookup;\n\n\tprivate ChemComp chemComp ;\n\n\tprivate List<Group> altLocs;\n\n\t/**\n\t *  Construct a Hetatom instance. \n\t */\n\tpublic HetatomImpl() {\n\t\tsuper();\n\n\t\tpdb_flag = false;\n\t\tpdb_name = null ;\n\n\t\tresidueNumber = null;\n\t\tatoms    = new ArrayList<Atom>();\n\t\tproperties = new HashMap<String,Object>();\n\t\tparent = null;\n\t\tchemComp = null;\n\t\taltLocs = null;\n\t\t\n\t\tatomNameLookup = new HashMap<String,Atom>();\n\t}\n\n\n\t/**\n\t *  returns true or false, depending if this group has 3D coordinates or not.\n\t * @return true if Group has 3D coordinates\n\t */\n\t@Override\n\tpublic boolean has3D() {\n\t\treturn pdb_flag;\n\t}\n\n\t/** flag if group has 3D data.\n\t *\n\t * @param flag  true to set flag that this Group has 3D coordinates\n\t */\n\t@Override\n\tpublic void setPDBFlag(boolean flag){\n\t\tpdb_flag = flag ;\n\t}\n\n\t/** Set three character name of Group .\n\t *\n\t * @param s  a String specifying the PDBName value\n\t * @see #getPDBName\n\t */\n\t@Override\n\tpublic void setPDBName(String s) {\n\t\t// hetatoms can have pdb_name length < 3. e.g. CU (see 1a4a position 1200 )\n\t\t//if (s.length() != 3) {\n\t\t//throw new PDBParseException(\"amino acid name is not of length 3!\");\n\t\t//}\n\t\tif (s != null && s.equals(\"?\")) logger.info(\"invalid pdbname: ?\");\n\t\tpdb_name =s ;\n\t\t\n\t}\n\n\t/**\n\t * Returns the PDBName.\n\t *\n\t * @return a String representing the PDBName value\n\t * @see #setPDBName\n\t */\n\t@Override\n\tpublic String getPDBName() { return pdb_name;}\n\n\t/**\n\t * {@inheritDoc} \n\t */\n\t@Override\n\tpublic void addAtom(Atom atom){\n\t\tatom.setGroup(this);\n\t\tatoms.add(atom);\n\t\tif (atom.getCoords() != null){\n\t\t\t// we have got coordinates!\n\t\t\tsetPDBFlag(true);\n\t\t}\n\t\tAtom existingAtom = atomNameLookup.put(atom.getName(),atom);\n\t\t\n\t\t// if an atom with same name is added to the group that has to be some kind of problem, \n\t\t// we need to warn properly\n\t\tif (existingAtom!=null) {\n\t\t\tString altLocStr = \"\";\n\t\t\tchar altLoc = atom.getAltLoc();\n\t\t\tif (altLoc!=' ') altLocStr = \"(alt loc '\"+altLoc+\"')\";\n\t\t\tlogger.warn(\"An atom with name \"+atom.getName()+\" \"+altLocStr+\" is already present in group: \"+this.toString()+\". The atom with serial \"+atom.getPDBserial()+\" will be ignored in look-ups.\"); \n\t\t}\n\t};\n\n\n\t/** remove all atoms\n\t *\n\t */\n\t@Override\n\tpublic void clearAtoms() {\n\t\tatoms.clear();\n\t\tsetPDBFlag(false);\n\t\tatomNameLookup.clear();\n\t}\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic int size(){ return atoms.size();   }\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic List<Atom> getAtoms(){\n\t\treturn atoms ;\n\t}\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setAtoms(List<Atom> atoms) {\n\t\t\n\t\t// important we are resetting atoms to a new list, we need to reset the lookup too!\n\t\tatomNameLookup.clear();\n\t\t\n\t\tfor (Atom a: atoms){\n\t\t\ta.setGroup(this);\n\t\t\tatomNameLookup.put(a.getName(),a);\n\t\t}\n\t\tthis.atoms = atoms;\n\t\tif ( atoms.size() > 0) {\n\t\t\tpdb_flag = true;\n\t\t}\n\n\t}\n\n\t/**  \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Atom getAtom(String name) {\t\t\n\t\treturn atomNameLookup.get(name);\n\t}\n\n\t/** \n\t * {@inheritDoc}\t\n\t */\n\t@Override\n\tpublic Atom getAtom(int position) {\t\t\t\n\t\t\t\n\t\tif ((position < 0)|| ( position >= atoms.size())) {\n\t\t\t//throw new StructureException(\"No atom found at position \"+position);\n\t\t\treturn null;\n\t\t}\n\t\tAtom a = atoms.get(position);\n\t\treturn a ;\n\t}\n\n\t/**\n\t * {@inheritDoc} \n\t */\n\t@Override\n\tpublic boolean hasAtom(String fullName) {\n\n\t\tAtom a = atomNameLookup.get(fullName.trim());\n\t\tif ( a != null)\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\t \n\t */\n\t@Override\n\tpublic GroupType getType(){ return type;}\n\n\t@Override\n\tpublic String toString(){\n\n\t\tString str = \"Hetatom \"+ residueNumber + \" \" + pdb_name +  \" \"+ pdb_flag;\n\t\tif (pdb_flag) {\n\t\t\tstr = str + \" atoms: \"+atoms.size();\n\t\t}\n\t\tif ( altLocs != null)\n\t\t\tstr += \" has altLocs :\" + altLocs.size(); \n\n\n\t\treturn str ;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic boolean hasAminoAtoms(){\n\t\t// if this method call is performed too often, it should become a\n\t\t// private method and provide a flag for Group object ...\n\n\t\tif (\thasAtom(StructureTools.CA_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.C_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.N_ATOM_NAME) && \n\t\t\t\thasAtom(StructureTools.O_ATOM_NAME)) {\n\t\t\t\n\t\t\t// this is the minimun requirement for something to be considered an aminoacid with a backbone\n\t\t\t// note that if the backbone is incomplete it won't be considered an aminoacid\n\t\t\t// if it's a HETATOM that has all these atoms, this is a very good guess that this is \n\t\t\t// some kind of non-standard aminoacid\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\n\t/** \n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setProperties(Map<String,Object> props) {\n\t\tproperties =  props ;\n\t}\n\n\t/** return properties.\n\t *\n\t * @return a HashMap object representing the properties value\n\t * @see #setProperties\n\t */\n\t@Override\n\tpublic Map<String, Object> getProperties() {\n\t\treturn properties ;\n\t}\n\n\t/** set a single property .\n\t *\n\t * @see #getProperties\n\t * @see #getProperty\n\t */\n\t@Override\n\tpublic void setProperty(String key, Object value){\n\t\tproperties.put(key,value);\n\t}\n\n\t/** get a single property .\n\t * @param key  a String\n\t * @return an Object\n\t * @see #setProperty\n\t * @see #setProperties\n\t */\n\t@Override\n\tpublic Object getProperty(String key){\n\t\treturn properties.get(key);\n\t}\n\n\n\t/** return an AtomIterator.\n\t *\n\t * @return an Iterator object\n\t */\n\t@Override\n\tpublic Iterator<Atom> iterator() {\n\t\tIterator<Atom> iter = new AtomIterator(this);\n\t\treturn iter ;\n\t}\n\n\t/** returns and identical copy of this Group object .\n\t * @return  and identical copy of this Group object\n\t */\n\t@Override\n\tpublic Object clone(){\n\n\t\tHetatomImpl n = new HetatomImpl();\n\t\tn.setPDBFlag(has3D());\n\t\tn.setResidueNumber(residueNumber);\n\t\t\n\t\tn.setPDBName(getPDBName());\n\t\t\n\t\t// copy the atoms\n\t\tfor (int i=0;i<atoms.size();i++){\n\t\t\tAtom atom = (Atom) atoms.get(i).clone();\n\t\t\tn.addAtom(atom);\n\t\t\tatom.setGroup(n);\n\t\t}\n\t\t\n\t\t// TODO alt locs are not cloned! do we need to clone them? - JD 2014-12-17\n\t\t\n\t\treturn n;\n\t}\n\n\t/** the Hibernate database ID\n\t *\n\t * @return the id\n\t */\n\tpublic long getId() {\n\t\treturn id;\n\t}\n\n\t/** the Hibernate database ID\n\t *\n\t * @param id the hibernate id\n\t */\n\tpublic void setId(long id) {\n\t\tthis.id = id;\n\t}\n\n\t@Override\n\tpublic ChemComp getChemComp() {\n\t\tif  ( chemComp == null ) {\n\t\t\tchemComp = ChemCompGroupFactory.getChemComp(pdb_name);\n\t\t\tif (chemComp == null) logger.info(\"getChemComp: \" + pdb_name);\n\t\t}\n\t\treturn chemComp;\n\t}\n\n\t@Override\n\tpublic void setChemComp(ChemComp cc) {\n\t\tchemComp = cc;\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic void setChain(Chain chain) {\n\t\tthis.parent = chain;\n\t\t//TODO: setChain(), getChainId() and ResidueNumber.set/getChainId() are\n\t\t//duplicating functionality at present and could give different values.\n\t\tif (residueNumber != null) {\n\t\t\tresidueNumber.setChainId(chain.getChainID());\n\t\t}\n\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic Chain getChain() {\n\t\treturn parent;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getChainId() {\n\t\tif (parent == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn parent.getChainID();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic ResidueNumber getResidueNumber() {\n\n\t\treturn residueNumber;\n\t}\n\n\n\t@Override\n\tpublic void setResidueNumber(ResidueNumber residueNumber) {\n\t\tthis.residueNumber = residueNumber;\n\t}\n\n\t@Override\n\tpublic void setResidueNumber(String chainId, Integer resNum, Character iCode) {\n\t\tthis.residueNumber = new ResidueNumber(chainId, resNum, iCode);\n\t}\n\n\t@Override\n\tpublic boolean hasAltLoc() {\n\t\tif ( altLocs == null)\n\t\t\treturn false;\n\t\tif ( altLocs.size() > 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic List<Group> getAltLocs() {\n\t\tif ( altLocs == null)\n\t\t\treturn new ArrayList<Group>();\n\t\treturn altLocs;\n\t}\n\n\t@Override\n\tpublic Group getAltLocGroup(Character altLoc) {\n\t\t\n\t\t\tAtom a = getAtom(0);\n\t\t\tif ( a == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\n\t\t\t// maybe the alt loc group in question is myself\n\t\t\tif (a.getAltLoc().equals(altLoc)) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (altLocs == null || altLocs.size() == 0)\n\t\t\t\treturn null;\n\n\t\t\tfor (Group group : altLocs) {\n\t\t\t\tif (group.getAtoms().isEmpty())\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// determine this group's alt-loc character code by looking\n\t\t\t\t// at its first atom's alt-loc character\n\t\t\t\tAtom b = group.getAtom(0);\n\t\t\t\tif ( b == null)\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tif (b.getAltLoc().equals(altLoc)) {\n\t\t\t\t\treturn group;\n\t\t\t\t}\n\t\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void addAltLoc(Group group) {\n\t\tif ( altLocs == null) {\n\t\t\taltLocs = new ArrayList<Group>();\n\t\t}\n\t\taltLocs.add(group);\n\n\t}\n\n\t@Override\n\tpublic boolean isWater() {\n\t\treturn GroupType.WATERNAMES.contains(pdb_name);\n\t}\n\n\t/** attempts to reduce the memory imprint of this group by trimming \n\t * all internal Collection objects to the required size.\n\t * \n\t */\n\t@Override\n\tpublic void trimToSize(){\n\n\t\tif ( atoms instanceof ArrayList<?>) {\n\t\t\tArrayList<Atom> myatoms = (ArrayList<Atom>) atoms;\n\t\t\tmyatoms.trimToSize();\n\t\t}\n\t\tif ( altLocs instanceof ArrayList<?>){\n\t\t\tArrayList<Group> myAltLocs = (ArrayList<Group>) altLocs;\n\t\t\tmyAltLocs.trimToSize();\n\t\t}\n\t\tatomNameLookup = new HashMap<String,Atom>(atomNameLookup);\n\n\t\tif ( hasAltLoc()) {\n\t\t\tfor (Group alt : getAltLocs()){\n\t\t\t\talt.trimToSize();\n\t\t\t}\n\t\t}\n\n\n\t}\n\n}\n","originTest":"/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport junit.framework.TestCase;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\n\n/**\n *\n * @author Jules Jacobsen <jacobsen@ebi.ac.uk>\n */\npublic class HetatomImplTest extends TestCase{\n\n    int bigTestNumber = 60000;\n\n    public HetatomImplTest() {\n\n    }\n\n    @BeforeClass\n    public static void setUpClass() throws Exception {\n    }\n\n    @AfterClass\n    public static void tearDownClass() throws Exception {\n    }\n\n    @Override @Before\n    public void setUp() {\n    }\n\n    @After @Override\n    public void tearDown() {\n    }\n\n//    /**\n//     * Test of has3D method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testHas3D() {\n//        System.out.println(\"has3D\");\n//        HetatomImpl instance = new HetatomImpl();\n//        boolean expResult = false;\n//        boolean result = instance.has3D();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setPDBFlag method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetPDBFlag() {\n//        System.out.println(\"setPDBFlag\");\n//        boolean flag = false;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setPDBFlag(flag);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getPDBCode method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetPDBCode() {\n//        System.out.println(\"getPDBCode\");\n//        HetatomImpl instance = new HetatomImpl();\n//        String expResult = \"\";\n//        String result = instance.getPDBCode();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setPDBCode method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetPDBCode() {\n//        System.out.println(\"setPDBCode\");\n//        String pdb = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setPDBCode(pdb);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setPDBName method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetPDBName() throws Exception {\n//        System.out.println(\"setPDBName\");\n//        String s = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setPDBName(s);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getPDBName method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetPDBName() {\n//        System.out.println(\"getPDBName\");\n//        HetatomImpl instance = new HetatomImpl();\n//        String expResult = \"\";\n//        String result = instance.getPDBName();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of addAtom method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testAddAtom() {\n//        System.out.println(\"addAtom\");\n//        Atom atom = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.addAtom(atom);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of clearAtoms method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testClearAtoms() {\n//        System.out.println(\"clearAtoms\");\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.clearAtoms();\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of size method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSize() {\n//        System.out.println(\"size\");\n//        HetatomImpl instance = new HetatomImpl();\n//        int expResult = 0;\n//        int result = instance.size();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getAtoms method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetAtoms() {\n//        System.out.println(\"getAtoms\");\n//        HetatomImpl instance = new HetatomImpl();\n//        List expResult = null;\n//        List result = instance.getAtoms();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setAtoms method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetAtoms() {\n//        System.out.println(\"setAtoms\");\n//        List<Atom> atoms = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setAtoms(atoms);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getAtom method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetAtom_String() throws Exception {\n//        System.out.println(\"getAtom\");\n//        String name = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        Atom expResult = null;\n//        Atom result = instance.getAtom(name);\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getAtomByPDBname method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetAtomByPDBname() throws Exception {\n//        System.out.println(\"getAtomByPDBname\");\n//        String name = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        Atom expResult = null;\n//        Atom result = instance.getAtomByPDBname(name);\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getAtom method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetAtom_int() throws Exception {\n//        System.out.println(\"getAtom\");\n//        int position = 0;\n//        HetatomImpl instance = new HetatomImpl();\n//        Atom expResult = null;\n//        Atom result = instance.getAtom(position);\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of hasAtom method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testHasAtom() {\n//        System.out.println(\"hasAtom\");\n//        String fullName = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        boolean expResult = false;\n//        boolean result = instance.hasAtom(fullName);\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getType method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetType() {\n//        System.out.println(\"getType\");\n//        HetatomImpl instance = new HetatomImpl();\n//        String expResult = \"\";\n//        String result = instance.getType();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of toString method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testToString() {\n//        System.out.println(\"toString\");\n//        HetatomImpl instance = new HetatomImpl();\n//        String expResult = \"\";\n//        String result = instance.toString();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of hasAminoAtoms method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testHasAminoAtoms() {\n//        System.out.println(\"hasAminoAtoms\");\n//        HetatomImpl instance = new HetatomImpl();\n//        boolean expResult = false;\n//        boolean result = instance.hasAminoAtoms();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setProperties method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetProperties() {\n//        System.out.println(\"setProperties\");\n//        Map<String, Object> props = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setProperties(props);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getProperties method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetProperties() {\n//        System.out.println(\"getProperties\");\n//        HetatomImpl instance = new HetatomImpl();\n//        Map expResult = null;\n//        Map result = instance.getProperties();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setProperty method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetProperty() {\n//        System.out.println(\"setProperty\");\n//        String key = \"\";\n//        Object value = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setProperty(key, value);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getProperty method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetProperty() {\n//        System.out.println(\"getProperty\");\n//        String key = \"\";\n//        HetatomImpl instance = new HetatomImpl();\n//        Object expResult = null;\n//        Object result = instance.getProperty(key);\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of iterator method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testIterator() {\n//        System.out.println(\"iterator\");\n//        HetatomImpl instance = new HetatomImpl();\n//        Iterator expResult = null;\n//        Iterator result = instance.iterator();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of clone method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testClone() {\n//        System.out.println(\"clone\");\n//        HetatomImpl instance = new HetatomImpl();\n//        Object expResult = null;\n//        Object result = instance.clone();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setParent method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetParent() {\n//        System.out.println(\"setParent\");\n//        Chain parent = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setParent(parent);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getParent method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetParent() {\n//        System.out.println(\"getParent\");\n//        HetatomImpl instance = new HetatomImpl();\n//        Chain expResult = null;\n//        Chain result = instance.getParent();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getId method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetId() {\n//        System.out.println(\"getId\");\n//        HetatomImpl instance = new HetatomImpl();\n//        long expResult = 0L;\n//        long result = instance.getId();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setId method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetId() {\n//        System.out.println(\"setId\");\n//        long id = 0L;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setId(id);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of getChemComp method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testGetChemComp() {\n//        System.out.println(\"getChemComp\");\n//        HetatomImpl instance = new HetatomImpl();\n//        ChemComp expResult = null;\n//        ChemComp result = instance.getChemComp();\n//        assertEquals(expResult, result);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n//    /**\n//     * Test of setChemComp method, of class HetatomImpl.\n//     */\n//    @Test\n//    public void testSetChemComp() {\n//        System.out.println(\"setChemComp\");\n//        ChemComp cc = null;\n//        HetatomImpl instance = new HetatomImpl();\n//        instance.setChemComp(cc);\n//        // TODO review the generated test code and remove the default call to fail.\n//        fail(\"The test case is a prototype.\");\n//    }\n//\n    /**\n     * Test of setChain method, of class HetatomImpl.\n     */\n    @Test\n    public void testSetGetChain() {\n//        System.out.println(\"setGetChain\");\n        Chain chain = new ChainImpl();\n        chain.setChainID(\"A\");\n        HetatomImpl instance = new HetatomImpl();\n        instance.setChain(chain);\n        Chain expResult = chain;\n        Chain result = instance.getChain();\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of getChainId method, of class HetatomImpl.\n     */\n    @Test\n    public void testGetChainId() {\n//        System.out.println(\"getChainId\");\n        Chain chain = new ChainImpl();\n        chain.setChainID(\"A\");\n        HetatomImpl instance = new HetatomImpl();\n        instance.setChain(chain);\n        String expResult = \"A\";\n        String result = instance.getChainId();\n        assertEquals(expResult, result);\n    }\n\n    /**\n     * Test of getSeqNum method, of class HetatomImpl.\n     */\n    @Test\n    public void testSetGetResidueNumber() {\n//        System.out.println(\"setGetResidueNumber\");\n        ResidueNumber residueNumber = new ResidueNumber(\"A\", 42, ' ');\n        HetatomImpl instance = new HetatomImpl();\n        instance.setResidueNumber(residueNumber);\n        ResidueNumber expResult = residueNumber;\n        ResidueNumber result = instance.getResidueNumber();\n        assertEquals(expResult, result);\n\n    }\n\n    @Test\n    public void testGetResidueNumberUsage() {\n//        System.out.println(\"testGetResidueNumberUsage\");\n        List<Group> resNumgroups = new ArrayList<Group>();\n\n        for (int i = 0; i < bigTestNumber; i++) {\n            ResidueNumber resNum = new ResidueNumber(\"A\", i, ' ');\n            HetatomImpl hetAtom = new HetatomImpl();\n            hetAtom.setResidueNumber(resNum);\n            resNumgroups.add(hetAtom);\n        }\n\n        List<Integer> integers = new ArrayList<Integer>();\n\n        for (Group group : resNumgroups) {\n            ResidueNumber resnum = group.getResidueNumber();\n            integers.add(resnum.getSeqNum());\n        }\n        assertEquals(bigTestNumber, integers.size());\n    }\n\n    @Test\n    public void testSetResidueNumberUsage() {\n     \n        List<Group> resNumgroups = new ArrayList<Group>();\n\n        for (int i = 0; i < bigTestNumber; i++) {\n            ResidueNumber resNum = new ResidueNumber(\"A\", i, ' ');\n            HetatomImpl hetAtom = new HetatomImpl();\n            hetAtom.setResidueNumber(resNum);\n            resNumgroups.add(hetAtom);\n        }\n        int groupsSize = resNumgroups.size();\n        assertEquals(bigTestNumber, groupsSize);\n    }\n    \n    @Test\n    public void testHasAminoAtoms() {\n    \t\n    \tAtom CA = new AtomImpl();\n    \tCA.setName(\"CA\");\n    \tCA.setElement(Element.C);\n    \tCA.setPDBserial(1);\n    \tAtom C = new AtomImpl();\n    \tC.setName(\"C\");\n    \tC.setElement(Element.C);\n    \tC.setPDBserial(2);\n    \tAtom N = new AtomImpl();\n    \tN.setName(\"N\");\n    \tN.setElement(Element.N);\n    \tN.setPDBserial(3);\n    \tAtom O = new AtomImpl();\n    \tO.setName(\"O\");\n    \tO.setElement(Element.O);\n    \tO.setPDBserial(4);\n    \tAtom OXT = new AtomImpl();\n    \tOXT.setName(\"OXT\");\n    \tOXT.setElement(Element.O);\n    \tOXT.setPDBserial(5);\n\n    \tGroup g = new HetatomImpl();\n    \tg.addAtom(CA); \n    \tg.addAtom(C);\n    \tg.addAtom(N);\n    \tg.addAtom(O);\n    \t\n    \tassertTrue(g.hasAminoAtoms());\n    \t\n    \tg = new HetatomImpl();\n    \tg.addAtom(CA); \n    \tg.addAtom(C);\n    \tg.addAtom(N);\n    \tg.addAtom(O);\n    \tg.addAtom(OXT);\n    \t\n    \tassertTrue(g.hasAminoAtoms());\n    \t\n    \tg = new AminoAcidImpl();\n    \tg.addAtom(CA); \n    \tg.addAtom(C);\n    \tg.addAtom(N);\n    \tg.addAtom(O);\n    \t\n    \tassertTrue(g.hasAminoAtoms());\n    \t\n    \tg = new HetatomImpl();\n    \tg.addAtom(CA); \n    \tg.addAtom(C);\n    \tg.addAtom(N);\n    \tassertFalse(g.hasAminoAtoms());\n    \t\n    \tg = new HetatomImpl();\n    \tg.addAtom(CA); \n    \tg.addAtom(C);\n    \tg.addAtom(N);\n    \tg.addAtom(OXT);\n    \t\n    \tassertFalse(g.hasAminoAtoms());\n    \t\n    }\n}","changedTest":"","commitMessage":"Making Group.isWater() usage more consistent, removed some warnings","test_commitMessage":"","allZero":false}