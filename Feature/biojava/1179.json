{"repository":"biojava","prod_path":"alignment/src/main/java/org/biojava/bio/alignment/SubstitutionMatrix.java","test_path":"alignment/src/test/java/org/biojava/bio/alignment/SubstitutionMatrixTest.java","prod_time":"2010-04-07 21:47:58","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":3,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":3,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e1a48e0a4bd2791d57e2a406c3b9ded07719a8b3","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * Created on 2005-08-01\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\n\n/**\n * <p>\n * This object is able to read a substitution matrix file and constructs a short\n * matrix in memory. Every single element of the matrix can be accessed by the\n * method <code>getValueAt</code> with the parameters being two BioJava symbols.\n * This is why it is not necessary to access the matrix directly. If there is no\n * value for the two specified <code>Symbol</code>s an <code>Exception</code> is\n * thrown.\n * </p>\n * <p>\n * Substitution matrix files, are available at <a\n * href=\"ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/\"> the NCBI FTP\n * directory</a>.\n * </p>\n * \n * @author Andreas Dr&auml;ger <andreas.draeger@uni-tuebingen.de>\n */\npublic class SubstitutionMatrix {\n\t\n\t/**\n\t * \n\t */\n\tprivate Map<Symbol, Integer> rowSymbols, colSymbols;\n\n\t/**\n\t * \n\t */\n\tprivate short[][] matrix;\n\n\t/**\n\t * Minimal and maximal entry in this matrix\n\t */\n\tprivate short min, max;\n\n\t/**\n\t * The alphabet used by this matrix.\n\t */\n\tprivate FiniteAlphabet alphabet;\n\n\t/**\n\t * Name and description of this matrix.\n\t */\n\tprivate String description, name;\n\n\t/**\n\t * Just the new line symbol of the system.\n\t */\n\tprivate static final String newLine = System.getProperty(\"line.separator\");\n\n\t/**\n\t * This constructs a <code>SubstitutionMatrix</code> object that contains\n\t * two <code>Map</code> data structures having BioJava symbols as keys and\n\t * the value being the index of the matrix containing the substitution\n\t * score.\n\t * \n\t * @param alpha\n\t *            the alphabet of the matrix (e.g., DNA, RNA or PROTEIN, or\n\t *            PROTEIN-TERM)\n\t * @param matrixFile\n\t *            the file containing the substitution matrix. Lines starting\n\t *            with '<code>#</code>' are comments. The line starting with a\n\t *            white space, is the table head. Every line has to start with\n\t *            the one letter representation of the Symbol and then the\n\t *            values for the exchange.\n\t * @throws IOException\n\t * @throws BioException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, File matrixFile)\n\t\t\tthrows BioException, NumberFormatException, IOException {\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"\";\n\t\tthis.name = matrixFile.getName();\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = this.parseMatrix(matrixFile);\n\t}\n\n\t/**\n\t * With this constructor it is possible to construct a SubstitutionMatrix\n\t * object from a substitution matrix file. The given String contains a\n\t * number of lines separated by\n\t * <code>System.getProperty(\"line.separator\")</code>. Everything else is the\n\t * same than for the constructor above.\n\t * \n\t * @param alpha\n\t *            The <code>FiniteAlphabet</code> to use\n\t * @param matrixString\n\t * @param name\n\t *            of the matrix.\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, String matrixString,\n\t\t\tString name) throws BioException, NumberFormatException,\n\t\t\tIOException {\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"\";\n\t\tthis.name = name;\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = this.parseMatrix(matrixString);\n\t\t// this.printMatrix();\n\t}\n\n\t/**\n\t * Constructs a SubstitutionMatrix with every Match and every Replace having\n\t * the same expenses given by the parameters. Ambiguous symbols are not\n\t * considered because there might be to many of them (for proteins).\n\t * \n\t * @param alpha\n\t * @param match\n\t * @param replace\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, short match, short replace) {\n\t\tint i = 0, j = 0;\n\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"Identity matrix. All replaces and all matches are treated equally.\";\n\t\tthis.name = \"IDENTITY_\" + match + \"_\" + replace;\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = new short[alpha.size()][alpha.size()];\n\n\t\tSymbol[] sym = new Symbol[alpha.size()];\n\t\tIterator<Symbol> iter = alpha.iterator();\n\n\t\tfor (i = 0; iter.hasNext(); i++) {\n\t\t\tsym[i] = iter.next();\n\t\t\trowSymbols.put(sym[i], new Integer(i));\n\t\t\tcolSymbols.put(sym[i], new Integer(i));\n\t\t}\n\n\t\tfor (i = 0; i < alphabet.size(); i++)\n\t\t\tfor (j = 0; j < alphabet.size(); j++)\n\t\t\t\tif (sym[i].getMatches().contains(sym[j]))\n\t\t\t\t\tmatrix[i][j] = match;\n\t\t\t\telse\n\t\t\t\t\tmatrix[i][j] = replace;\n\n\t\t// this.printMatrix();\n\t}\n\n\t/**\n\t * This constructor can be used to guess the alphabet of this substitution\n\t * matrix. However, it is recommended to apply another constructor if the\n\t * alphabet is known.\n\t * \n\t * @param file\n\t *            A file containing a substitution matrix.\n\t * @throws NumberFormatException\n\t * @throws NoSuchElementException\n\t * @throws BioException\n\t * @throws IOException\n\t */\n\tpublic SubstitutionMatrix(File file) throws NumberFormatException,\n\t\t\tNoSuchElementException, BioException, IOException {\n\t\tthis(guessAlphabet(file), file);\n\t}\n\n\t/**\n\t * This constructor can be used to guess the alphabet of this substitution\n\t * matrix. However, it is recommended to apply another constructor if the\n\t * alphabet is known.\n\t * \n\t * @param reader\n\t * @throws NumberFormatException\n\t * @throws BioException\n\t * @throws IOException\n\t */\n\tpublic static SubstitutionMatrix getSubstitutionMatrix(BufferedReader reader)\n\t\t\tthrows NumberFormatException, BioException, IOException {\n\t\tStringBuffer stringMatrix = new StringBuffer(\"\");\n\t\twhile (reader.ready()) {\n\t\t\tstringMatrix.append(reader.readLine());\n\t\t\tstringMatrix.append(newLine);\n\t\t}\n\t\treader.close();\n\t\tString mat = stringMatrix.toString();\n\t\tFiniteAlphabet alpha = guessAlphabet(new BufferedReader(\n\t\t\t\tnew StringReader(mat)));\n\t\tSubstitutionMatrix matrix = new SubstitutionMatrix(alpha, mat,\n\t\t\t\t\"unknown\");\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * This method tries to identify the alphabet within a matrix file. This is\n\t * necessary in cases where we do not know if this is a matrix for DNA, RNA\n\t * or PROTEIN/PROTEIN-TERM.\n\t * \n\t * @param file\n\t * @return\n\t * @throws IOException\n\t * @throws BioException\n\t * @throws NoSuchElementException\n\t * @throws BioException\n\t */\n\tprivate static FiniteAlphabet guessAlphabet(File file) throws IOException,\n\t\t\tNoSuchElementException, BioException {\n\t\tString fileName = file.getName().toLowerCase();\n\t\tif (fileName.contains(\"pam\") || fileName.contains(\"blosum\"))\n\t\t\treturn (FiniteAlphabet) AlphabetManager\n\t\t\t\t\t.alphabetForName(\"PROTEIN-TERM\");\n\t\treturn guessAlphabet(new BufferedReader(new FileReader(file)));\n\t}\n\n\t/**\n\t * This method guesses the alphabet of the given substituttion matrix which\n\t * is required for the parser.\n\t * \n\t * @param reader\n\t * @return\n\t * @throws IOException\n\t * @throws BioException\n\t */\n\tprivate static FiniteAlphabet guessAlphabet(BufferedReader reader)\n\t\t\tthrows IOException, BioException {\n\t\tString line, trim;\n\t\tFiniteAlphabet alphabet = null;\n\t\twhile (reader.ready()) {\n\t\t\tline = reader.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.charAt(0) == '#')\n\t\t\t\tcontinue;\n\t\t\telse if ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t')) {\n\t\t\t\tString alphabets[] = new String[] { \"DNA\", \"RNA\", \"PROTEIN\",\n\t\t\t\t\t\t\"PROTEIN-TERM\" };\n\t\t\t\tSymbolTokenization symtok;\n\t\t\t\tfor (int i = 0; i < alphabets.length; i++) {\n\t\t\t\t\talphabet = (FiniteAlphabet) AlphabetManager\n\t\t\t\t\t\t\t.alphabetForName(alphabets[i]);\n\t\t\t\t\tsymtok = alphabet.getTokenization(\"token\");\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(trim);\n\t\t\t\t\tboolean noError = true;\n\t\t\t\t\tfor (int j = 0; st.hasMoreElements(); j++)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsymtok.parseToken(st.nextElement().toString());\n\t\t\t\t\t\t} catch (IllegalSymbolException exc) {\n\t\t\t\t\t\t\tnoError = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (noError)\n\t\t\t\t\t\treturn alphabet;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new BioException(\n\t\t\t\t\"Unknow alphabet used in this substitution matrix\");\n\t}\n\n\t/**\n\t * Reads a String representing the contents of a substitution matrix file.\n\t * \n\t * @param matrixObj\n\t * @return matrix\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tprivate short[][] parseMatrix(Object matrixObj) throws BioException,\n\t\t\tNumberFormatException, IOException {\n\t\tint j = 0, rows = 0, cols = 0;\n\t\tSymbolTokenization symtok = alphabet.getTokenization(\"token\");\n\t\tStringTokenizer st;\n\t\tString line, trim;\n\n\t\tthis.min = Short.MAX_VALUE;\n\t\tthis.max = Short.MIN_VALUE;\n\t\t/*\n\t\t * First: count how many elements are in the matrix fill lines and rows\n\t\t */\n\t\tReader reader;\n\t\tif (matrixObj instanceof File)\n\t\t\treader = new FileReader((File) matrixObj);\n\t\telse if (matrixObj instanceof String)\n\t\t\treader = new StringReader(matrixObj.toString());\n\t\telse\n\t\t\treturn null;\n\t\tBufferedReader br = new BufferedReader(reader);\n\n\t\twhile (br.ready()) {\n\t\t\tline = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.length() == 0)\n\t\t\t\tcontinue;\n\t\t\tif (trim.charAt(0) == '#') {\n\t\t\t\tdescription += line.substring(1);\n\t\t\t\tcontinue;\n\t\t\t} else if (!trim.startsWith(newLine)) {\n\t\t\t\tif ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t')) {\n\t\t\t\t\tst = new StringTokenizer(trim);\n\t\t\t\t\tfor (j = 0; st.hasMoreElements(); j++) {\n\t\t\t\t\t\tcolSymbols.put(symtok.parseToken(st.nextElement()\n\t\t\t\t\t\t\t\t.toString()), Integer.valueOf(j));\n\t\t\t\t\t}\n\t\t\t\t\tcols = j;\n\t\t\t\t} else {\n\t\t\t\t\t// the matrix.\n\t\t\t\t\tst = new StringTokenizer(line);\n\t\t\t\t\tif (st.hasMoreElements())\n\t\t\t\t\t\trowSymbols.put(symtok.parseToken(st.nextElement()\n\t\t\t\t\t\t\t\t.toString()), Integer.valueOf(rows++));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\tshort[][] matrix = new short[rows][cols];\n\n\t\trows = 0;\n\t\tif (matrixObj instanceof File)\n\t\t\treader = new FileReader((File) matrixObj);\n\t\telse if (matrixObj instanceof String)\n\t\t\treader = new StringReader(matrixObj.toString());\n\t\telse\n\t\t\treturn null;\n\t\tbr = new BufferedReader(reader);\n\n\t\t/*\n\t\t * Second reading. Fill the matrix.\n\t\t */\n\t\twhile (br.ready()) {\n\t\t\tline = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.length() == 0 || trim.charAt(0) == '#')\n\t\t\t\tcontinue;\n\t\t\telse if ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t'))\n\t\t\t\tcontinue;\n\t\t\telse if (!trim.startsWith(newLine)) { // lines:\n\t\t\t\tst = new StringTokenizer(trim);\n\t\t\t\tif (st.hasMoreElements())\n\t\t\t\t\tst.nextElement(); // throw away Symbol at\n\t\t\t\t// beginning.\n\t\t\t\tfor (j = 0; st.hasMoreElements(); j++) {// cols:\n\t\t\t\t\tmatrix[rows][j] = (short) Math.round(Double.parseDouble(st\n\t\t\t\t\t\t\t.nextElement().toString()));\n\t\t\t\t\tif (matrix[rows][j] > max)\n\t\t\t\t\t\tmax = matrix[rows][j]; // maximum.\n\t\t\t\t\tif (matrix[rows][j] < min)\n\t\t\t\t\t\tmin = matrix[rows][j]; // minimum.\n\t\t\t\t}\n\t\t\t\trows++;\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * There are some substitution matrices containing more columns than lines.\n\t * This has to do with the ambiguous symbols. Lines are always good, columns\n\t * might not contain the whole information. The matrix is supposed to be\n\t * symmetric anyway, so you can always set the ambiguous symbol to be the\n\t * first argument.\n\t * \n\t * @param row\n\t *            Symbol of the line\n\t * @param col\n\t *            Symbol of the column\n\t * @return expenses for the exchange of symbol row and symbol column.\n\t * @throws BioException\n\t */\n\tpublic short getValueAt(Symbol row, Symbol col) throws BioException {\n\t\tif ((!rowSymbols.containsKey(row)) || (!colSymbols.containsKey(col))) {\n\t\t\tSystem.err.printf(\"SubstitutionMatrix: No entry for the symbols %s and %s\\n\",\n\t\t\t\t\trow.getName(), col.getName());\n\n\t\t\t// treat the two records as X:\n\t\t\treturn 0;\n\t\t}\n\t\treturn matrix[rowSymbols.get(row).intValue()][colSymbols.get(col)\n\t\t\t\t.intValue()];\n\t}\n\n\t/**\n\t * This gives you the description of this matrix if there is one. Normally\n\t * substitution matrix files like BLOSUM contain some lines of description.\n\t * \n\t * @return the comment of the matrix\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t/**\n\t * Every substitution matrix has a name like \"BLOSUM30\" or \"PAM160\". This\n\t * will be returned by this method.\n\t * \n\t * @return the name of the matrix.\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * The minimum score of this matrix.\n\t * \n\t * @return minimum of the matrix.\n\t */\n\tpublic short getMin() {\n\t\treturn min;\n\t}\n\n\t/**\n\t * The maximum score in this matrix.\n\t * \n\t * @return maximum of the matrix.\n\t */\n\tpublic short getMax() {\n\t\treturn max;\n\t}\n\n\t/**\n\t * Sets the description to the given value.\n\t * \n\t * @param desc\n\t *            a description. This doesn't have to start with '#'.\n\t */\n\tpublic void setDescription(String desc) {\n\t\tthis.description = desc;\n\t}\n\n\t/**\n\t * Gives the alphabet used by this matrix.\n\t * \n\t * @return the alphabet of this matrix.\n\t */\n\tpublic FiniteAlphabet getAlphabet() {\n\t\treturn alphabet;\n\t}\n\n\t/**\n\t * Creates a <code>String</code> representation of this matrix.\n\t * \n\t * @return a string representation of this matrix without the description.\n\t */\n\tpublic String stringnifyMatrix() {\n\t\tint i = 0;\n\t\tStringBuffer matrixString = new StringBuffer();\n\t\tSymbol[] colSyms = new Symbol[this.colSymbols.keySet().size()];\n\n\t\ttry {\n\t\t\tSymbolTokenization symtok = alphabet.getTokenization(\"default\");\n\t\t\tmatrixString.append(\"  \");\n\t\t\tIterator<Symbol> colKeys = colSymbols.keySet().iterator();\n\t\t\twhile (colKeys.hasNext()) {\n\t\t\t\tcolSyms[i] = colKeys.next();\n\t\t\t\tmatrixString.append(symtok.tokenizeSymbol(colSyms[i++])\n\t\t\t\t\t\t.toUpperCase());\n\t\t\t\tmatrixString.append(' ');\n\t\t\t}\n\t\t\tmatrixString.append(newLine);\n\n\t\t\tIterator<Symbol> rowKeys = rowSymbols.keySet().iterator();\n\t\t\twhile (rowKeys.hasNext()) {\n\t\t\t\tSymbol rowSym = rowKeys.next();\n\t\t\t\tmatrixString\n\t\t\t\t\t\t.append(symtok.tokenizeSymbol(rowSym).toUpperCase());\n\t\t\t\tmatrixString.append(' ');\n\t\t\t\tfor (i = 0; i < colSyms.length; i++) {\n\t\t\t\t\tmatrixString.append(getValueAt(rowSym, colSyms[i]));\n\t\t\t\t\tmatrixString.append(' ');\n\t\t\t\t}\n\t\t\t\tmatrixString.append(newLine);\n\t\t\t}\n\t\t} catch (BioException exc) {\n\t\t\texc.printStackTrace();\n\t\t}\n\t\treturn matrixString.toString();\n\t}\n\n\t/**\n\t * Converts the description of the matrix to a String.\n\t * \n\t * @return Gives a description with approximately 60 letters on every line\n\t *         separated by <code>System.getProperty(\"line.separator\")</code>.\n\t *         Every line starts with <code>#</code>.\n\t */\n\tpublic String stringnifyDescription() {\n\t\tStringBuffer desc = new StringBuffer(), line = new StringBuffer();\n\t\tline.append(\"# \");\n\t\tStringTokenizer st = new StringTokenizer(description, \" \");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tline.append(st.nextElement().toString());\n\t\t\tline.append(' ');\n\t\t\tif (line.length() >= 60) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t\tif (st.hasMoreElements()) {\n\t\t\t\t\tline = new StringBuffer();\n\t\t\t\t\tline.append(\"# \");\n\t\t\t\t}\n\t\t\t} else if (!st.hasMoreElements()) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t}\n\t\t}\n\t\treturn desc.toString();\n\t}\n\n\t/**\n\t * Overrides the inherited method.\n\t * \n\t * @return Gives a string representation of the SubstitutionMatrix. This is\n\t *         a valid input for the constructor which needs a matrix string.\n\t *         This String also contains the description of the matrix if there\n\t *         is one.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer desc = new StringBuffer(), line = new StringBuffer();\n\t\tline.append(\"# \");\n\t\tStringTokenizer st = new StringTokenizer(description);\n\t\twhile (st.hasMoreElements()) {\n\t\t\tline.append(st.nextElement().toString());\n\t\t\tline.append(' ');\n\t\t\tif (line.length() >= 60) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t\tif (st.hasMoreElements()) {\n\t\t\t\t\tline = new StringBuffer();\n\t\t\t\t\tline.append(\"# \");\n\t\t\t\t}\n\t\t\t} else if (!st.hasMoreElements()) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t}\n\t\t}\n\t\tdesc.append(stringnifyMatrix());\n\t\treturn desc.toString();\n\t}\n\n\t/**\n\t * Just to perform some test. It prints the matrix on the screen.\n\t */\n\tpublic void printMatrix() {\n\t\t// Test output:\n\t\tIterator<Symbol> rowKeys = rowSymbols.keySet().iterator();\n\t\twhile (rowKeys.hasNext()) {\n\t\t\tIterator<Symbol> colKeys = colSymbols.keySet().iterator();\n\t\t\tSymbol rowSym = rowKeys.next();\n\t\t\tSystem.out.print(rowSym.getName() + \"\\t\");\n\t\t\twhile (colKeys.hasNext()) {\n\t\t\t\tSymbol colSym = colKeys.next();\n\t\t\t\tint x = rowSymbols.get(rowSym).intValue();\n\t\t\t\tint y = colSymbols.get(colSym).intValue();\n\t\t\t\tSystem.out.print(colSym.getName() + \" \" + \" \" + x + \" \" + y\n\t\t\t\t\t\t+ \" \" + matrix[x][y] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println(newLine);\n\t\t}\n\t\tSystem.out.println(toString());\n\t}\n\n\t/**\n\t * With this method you can get a &ldquo;normalized&rdquo;\n\t * <code>SubstitutionMatrix</code> object; however, since this\n\t * implementation uses an short matrix, the normalized matrix will be scaled\n\t * by ten. If you need values between zero and one, you have to divide every\n\t * value returned by <code>getValueAt</code> by ten.\n\t * \n\t * @return a new and normalized <code>SubstitutionMatrix</code> object given\n\t *         by this substitution matrix. Because this uses an\n\t *         <code>short</code> matrix, all values are scaled by 10.\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix normalizeMatrix() throws BioException,\n\t\t\tNumberFormatException, IOException {\n\t\tint i, j;\n\t\tshort min = getMin(), newMax = Short.MIN_VALUE;\n\t\tshort[][] mat = new short[matrix.length][matrix[matrix.length - 1].length];\n\t\tString name = getName() + \"_normalized\";\n\t\tString matString = stringnifyDescription() + \"  \";\n\t\tFiniteAlphabet alphabet = getAlphabet();\n\t\tMap<Symbol, Integer> rowMap = this.rowSymbols;\n\t\tMap<Symbol, Integer> colMap = this.colSymbols;\n\t\tSymbolTokenization symtok = alphabet.getTokenization(\"default\");\n\n\t\tfor (i = 0; i < matrix.length; i++)\n\t\t\tfor (j = 0; j < matrix[matrix.length - 1].length; j++) {\n\t\t\t\tmat[i][j] = (short) (matrix[i][j] - min);\n\t\t\t\tif (mat[i][j] > newMax)\n\t\t\t\t\tnewMax = mat[i][j];\n\t\t\t}\n\n\t\tfor (i = 0; i < mat.length; i++)\n\t\t\tfor (j = 0; j < mat[mat.length - 1].length; j++)\n\t\t\t\tmat[i][j] = (short) (mat[i][j] * 10 / newMax);\n\n\t\tObject[] rows = rowSymbols.keySet().toArray();\n\t\tObject[] cols = colSymbols.keySet().toArray();\n\t\tfor (i = 0; i < cols.length; i++)\n\t\t\tmatString += symtok.tokenizeSymbol((Symbol) cols[i]) + \" \";\n\t\tfor (i = 0; i < rows.length; i++) {\n\t\t\tmatString += newLine + symtok.tokenizeSymbol((Symbol) rows[i])\n\t\t\t\t\t+ \" \";\n\t\t\tfor (j = 0; j < cols.length; j++) {\n\t\t\t\tmatString += mat[rowMap.get((Symbol) rows[i]).intValue()][colMap\n\t\t\t\t\t\t.get((Symbol) cols[j]).intValue()]\n\t\t\t\t\t\t+ \" \";\n\t\t\t}\n\t\t}\n\t\tmatString += newLine;\n\t\treturn new SubstitutionMatrix(alphabet, matString, name);\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * Created on 2005-08-01\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\n\n/**\n * <p>\n * This object is able to read a substitution matrix file and constructs a short\n * matrix in memory. Every single element of the matrix can be accessed by the\n * method <code>getValueAt</code> with the parameters being two BioJava symbols.\n * This is why it is not necessary to access the matrix directly. If there is no\n * value for the two specified <code>Symbol</code>s an <code>Exception</code> is\n * thrown.\n * </p>\n * <p>\n * Substitution matrix files, are available at <a\n * href=\"ftp://ftp.ncbi.nlm.nih.gov/blast/matrices/\"> the NCBI FTP\n * directory</a>.\n * </p>\n * \n * @author Andreas Dr&auml;ger <andreas.draeger@uni-tuebingen.de>\n */\npublic class SubstitutionMatrix {\n\t\n\t/**\n\t * \n\t */\n\tprivate Map<Symbol, Integer> rowSymbols, colSymbols;\n\n\t/**\n\t * \n\t */\n\tprivate short[][] matrix;\n\n\t/**\n\t * Minimal and maximal entry in this matrix\n\t */\n\tprivate short min, max;\n\n\t/**\n\t * The alphabet used by this matrix.\n\t */\n\tprivate FiniteAlphabet alphabet;\n\n\t/**\n\t * Name and description of this matrix.\n\t */\n\tprivate String description, name;\n\n\t/**\n\t * Just the new line symbol of the system.\n\t */\n\tprivate static final String newLine = System.getProperty(\"line.separator\");\n\n\t/**\n\t * This constructs a <code>SubstitutionMatrix</code> object that contains\n\t * two <code>Map</code> data structures having BioJava symbols as keys and\n\t * the value being the index of the matrix containing the substitution\n\t * score.\n\t * \n\t * @param alpha\n\t *            the alphabet of the matrix (e.g., DNA, RNA or PROTEIN, or\n\t *            PROTEIN-TERM)\n\t * @param matrixFile\n\t *            the file containing the substitution matrix. Lines starting\n\t *            with '<code>#</code>' are comments. The line starting with a\n\t *            white space, is the table head. Every line has to start with\n\t *            the one letter representation of the Symbol and then the\n\t *            values for the exchange.\n\t * @throws IOException\n\t * @throws BioException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, File matrixFile)\n\t\t\tthrows BioException, NumberFormatException, IOException {\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"\";\n\t\tthis.name = matrixFile.getName();\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = this.parseMatrix(matrixFile);\n\t}\n\n\t/**\n\t * With this constructor it is possible to construct a SubstitutionMatrix\n\t * object from a substitution matrix file. The given String contains a\n\t * number of lines separated by\n\t * <code>System.getProperty(\"line.separator\")</code>. Everything else is the\n\t * same than for the constructor above.\n\t * \n\t * @param alpha\n\t *            The <code>FiniteAlphabet</code> to use\n\t * @param matrixString\n\t * @param name\n\t *            of the matrix.\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, String matrixString,\n\t\t\tString name) throws BioException, NumberFormatException,\n\t\t\tIOException {\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"\";\n\t\tthis.name = name;\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = this.parseMatrix(matrixString);\n\t\t// this.printMatrix();\n\t}\n\n\t/**\n\t * Constructs a SubstitutionMatrix with every Match and every Replace having\n\t * the same expenses given by the parameters. Ambiguous symbols are not\n\t * considered because there might be to many of them (for proteins).\n\t * \n\t * @param alpha\n\t * @param match\n\t * @param replace\n\t */\n\tpublic SubstitutionMatrix(FiniteAlphabet alpha, short match, short replace) {\n\t\tint i = 0, j = 0;\n\n\t\tthis.alphabet = alpha;\n\t\tthis.description = \"Identity matrix. All replaces and all matches are treated equally.\";\n\t\tthis.name = \"IDENTITY_\" + match + \"_\" + replace;\n\t\tthis.rowSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.colSymbols = new HashMap<Symbol, Integer>();\n\t\tthis.matrix = new short[alpha.size()][alpha.size()];\n\n\t\tSymbol[] sym = new Symbol[alpha.size()];\n\t\tIterator<Symbol> iter = alpha.iterator();\n\n\t\tfor (i = 0; iter.hasNext(); i++) {\n\t\t\tsym[i] = iter.next();\n\t\t\trowSymbols.put(sym[i], new Integer(i));\n\t\t\tcolSymbols.put(sym[i], new Integer(i));\n\t\t}\n\n\t\tfor (i = 0; i < alphabet.size(); i++)\n\t\t\tfor (j = 0; j < alphabet.size(); j++)\n\t\t\t\tif (sym[i].getMatches().contains(sym[j]))\n\t\t\t\t\tmatrix[i][j] = match;\n\t\t\t\telse\n\t\t\t\t\tmatrix[i][j] = replace;\n\n\t\t// this.printMatrix();\n\t}\n\n\t/**\n\t * This constructor can be used to guess the alphabet of this substitution\n\t * matrix. However, it is recommended to apply another constructor if the\n\t * alphabet is known.\n\t * \n\t * @param file\n\t *            A file containing a substitution matrix.\n\t * @throws NumberFormatException\n\t * @throws NoSuchElementException\n\t * @throws BioException\n\t * @throws IOException\n\t */\n\tpublic SubstitutionMatrix(File file) throws NumberFormatException,\n\t\t\tNoSuchElementException, BioException, IOException {\n\t\tthis(guessAlphabet(file), file);\n\t}\n\n\t/**\n\t * This constructor can be used to guess the alphabet of this substitution\n\t * matrix. However, it is recommended to apply another constructor if the\n\t * alphabet is known.\n\t * \n\t * @param reader\n\t * @throws NumberFormatException\n\t * @throws BioException\n\t * @throws IOException\n\t */\n\tpublic static SubstitutionMatrix getSubstitutionMatrix(BufferedReader reader)\n\t\t\tthrows NumberFormatException, BioException, IOException {\n\t\tStringBuffer stringMatrix = new StringBuffer(\"\");\n\t\twhile (reader.ready()) {\n\t\t\tstringMatrix.append(reader.readLine());\n\t\t\tstringMatrix.append(newLine);\n\t\t}\n\t\treader.close();\n\t\tString mat = stringMatrix.toString();\n\t\tFiniteAlphabet alpha = guessAlphabet(new BufferedReader(\n\t\t\t\tnew StringReader(mat)));\n\t\tSubstitutionMatrix matrix = new SubstitutionMatrix(alpha, mat,\n\t\t\t\t\"unknown\");\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * This method tries to identify the alphabet within a matrix file. This is\n\t * necessary in cases where we do not know if this is a matrix for DNA, RNA\n\t * or PROTEIN/PROTEIN-TERM.\n\t * \n\t * @param file\n\t * @return\n\t * @throws IOException\n\t * @throws BioException\n\t * @throws NoSuchElementException\n\t * @throws BioException\n\t */\n\tprivate static FiniteAlphabet guessAlphabet(File file) throws IOException,\n\t\t\tNoSuchElementException, BioException {\n\t\tString fileName = file.getName().toLowerCase();\n\t\tif (fileName.contains(\"pam\") || fileName.contains(\"blosum\"))\n\t\t\treturn (FiniteAlphabet) AlphabetManager\n\t\t\t\t\t.alphabetForName(\"PROTEIN-TERM\");\n\t\treturn guessAlphabet(new BufferedReader(new FileReader(file)));\n\t}\n\n\t/**\n\t * This method guesses the alphabet of the given substituttion matrix which\n\t * is required for the parser.\n\t * \n\t * @param reader\n\t * @return\n\t * @throws IOException\n\t * @throws BioException\n\t */\n\tprivate static FiniteAlphabet guessAlphabet(BufferedReader reader)\n\t\t\tthrows IOException, BioException {\n\t\tString line, trim;\n\t\tFiniteAlphabet alphabet = null;\n\t\twhile (reader.ready()) {\n\t\t\tline = reader.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.length()==0 || trim.charAt(0) == '#')\n\t\t\t\tcontinue;\n\t\t\t// Use line in next if-clause because trim will have lost leading important whitespace.\n\t\t\telse if ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t')) {\n\t\t\t\tString alphabets[] = new String[] { \"DNA\", \"RNA\", \"PROTEIN\",\n\t\t\t\t\t\t\"PROTEIN-TERM\" };\n\t\t\t\tSymbolTokenization symtok;\n\t\t\t\tfor (int i = 0; i < alphabets.length; i++) {\n\t\t\t\t\talphabet = (FiniteAlphabet) AlphabetManager\n\t\t\t\t\t\t\t.alphabetForName(alphabets[i]);\n\t\t\t\t\tsymtok = alphabet.getTokenization(\"token\");\n\t\t\t\t\tStringTokenizer st = new StringTokenizer(trim);\n\t\t\t\t\tboolean noError = true;\n\t\t\t\t\tfor (int j = 0; st.hasMoreElements(); j++)\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsymtok.parseToken(st.nextElement().toString());\n\t\t\t\t\t\t} catch (IllegalSymbolException exc) {\n\t\t\t\t\t\t\tnoError = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif (noError)\n\t\t\t\t\t\treturn alphabet;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new BioException(\n\t\t\t\t\"Unknow alphabet used in this substitution matrix\");\n\t}\n\n\t/**\n\t * Reads a String representing the contents of a substitution matrix file.\n\t * \n\t * @param matrixObj\n\t * @return matrix\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tprivate short[][] parseMatrix(Object matrixObj) throws BioException,\n\t\t\tNumberFormatException, IOException {\n\t\tint j = 0, rows = 0, cols = 0;\n\t\tSymbolTokenization symtok = alphabet.getTokenization(\"token\");\n\t\tStringTokenizer st;\n\t\tString line, trim;\n\n\t\tthis.min = Short.MAX_VALUE;\n\t\tthis.max = Short.MIN_VALUE;\n\t\t/*\n\t\t * First: count how many elements are in the matrix fill lines and rows\n\t\t */\n\t\tReader reader;\n\t\tif (matrixObj instanceof File)\n\t\t\treader = new FileReader((File) matrixObj);\n\t\telse if (matrixObj instanceof String)\n\t\t\treader = new StringReader(matrixObj.toString());\n\t\telse\n\t\t\treturn null;\n\t\tBufferedReader br = new BufferedReader(reader);\n\n\t\twhile (br.ready()) {\n\t\t\tline = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.length() == 0)\n\t\t\t\tcontinue;\n\t\t\tif (trim.charAt(0) == '#') {\n\t\t\t\tdescription += line.substring(1);\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\t// Use line in next if-clause because trim will have lost leading important whitespace.\n\t\t\telse if (!line.startsWith(newLine)) {\n\t\t\t\tif ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t')) {\n\t\t\t\t\tst = new StringTokenizer(trim);\n\t\t\t\t\tfor (j = 0; st.hasMoreElements(); j++) {\n\t\t\t\t\t\tcolSymbols.put(symtok.parseToken(st.nextElement()\n\t\t\t\t\t\t\t\t.toString()), Integer.valueOf(j));\n\t\t\t\t\t}\n\t\t\t\t\tcols = j;\n\t\t\t\t} else {\n\t\t\t\t\t// the matrix.\n\t\t\t\t\tst = new StringTokenizer(trim);\n\t\t\t\t\tif (st.hasMoreElements())\n\t\t\t\t\t\trowSymbols.put(symtok.parseToken(st.nextElement()\n\t\t\t\t\t\t\t\t.toString()), Integer.valueOf(rows++));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\tshort[][] matrix = new short[rows][cols];\n\n\t\trows = 0;\n\t\tif (matrixObj instanceof File)\n\t\t\treader = new FileReader((File) matrixObj);\n\t\telse if (matrixObj instanceof String)\n\t\t\treader = new StringReader(matrixObj.toString());\n\t\telse\n\t\t\treturn null;\n\t\tbr = new BufferedReader(reader);\n\n\t\t/*\n\t\t * Second reading. Fill the matrix.\n\t\t */\n\t\twhile (br.ready()) {\n\t\t\tline = br.readLine();\n\t\t\tif (line == null)\n\t\t\t\tbreak;\n\t\t\ttrim = line.trim();\n\t\t\tif (trim.length() == 0 || trim.charAt(0) == '#')\n\t\t\t\tcontinue;\n\t\t\telse if ((line.charAt(0) == ' ') || (line.charAt(0) == '\\t'))\n\t\t\t\tcontinue;\n\t\t\t// Use line in next if-clause because trim will have lost leading important whitespace.\n\t\t\telse if (!line.startsWith(newLine)) { // lines:\n\t\t\t\tst = new StringTokenizer(trim);\n\t\t\t\tif (st.hasMoreElements())\n\t\t\t\t\tst.nextElement(); // throw away Symbol at\n\t\t\t\t// beginning.\n\t\t\t\tfor (j = 0; st.hasMoreElements(); j++) {// cols:\n\t\t\t\t\tmatrix[rows][j] = (short) Math.round(Double.parseDouble(st\n\t\t\t\t\t\t\t.nextElement().toString()));\n\t\t\t\t\tif (matrix[rows][j] > max)\n\t\t\t\t\t\tmax = matrix[rows][j]; // maximum.\n\t\t\t\t\tif (matrix[rows][j] < min)\n\t\t\t\t\t\tmin = matrix[rows][j]; // minimum.\n\t\t\t\t}\n\t\t\t\trows++;\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\n\t\treturn matrix;\n\t}\n\n\t/**\n\t * There are some substitution matrices containing more columns than lines.\n\t * This has to do with the ambiguous symbols. Lines are always good, columns\n\t * might not contain the whole information. The matrix is supposed to be\n\t * symmetric anyway, so you can always set the ambiguous symbol to be the\n\t * first argument.\n\t * \n\t * @param row\n\t *            Symbol of the line\n\t * @param col\n\t *            Symbol of the column\n\t * @return expenses for the exchange of symbol row and symbol column.\n\t * @throws BioException\n\t */\n\tpublic short getValueAt(Symbol row, Symbol col) throws BioException {\n\t\tif ((!rowSymbols.containsKey(row)) || (!colSymbols.containsKey(col))) {\n\t\t\tSystem.err.printf(\"SubstitutionMatrix: No entry for the symbols %s and %s\\n\",\n\t\t\t\t\trow.getName(), col.getName());\n\n\t\t\t// treat the two records as X:\n\t\t\treturn 0;\n\t\t}\n\t\treturn matrix[rowSymbols.get(row).intValue()][colSymbols.get(col)\n\t\t\t\t.intValue()];\n\t}\n\n\t/**\n\t * This gives you the description of this matrix if there is one. Normally\n\t * substitution matrix files like BLOSUM contain some lines of description.\n\t * \n\t * @return the comment of the matrix\n\t */\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\t/**\n\t * Every substitution matrix has a name like \"BLOSUM30\" or \"PAM160\". This\n\t * will be returned by this method.\n\t * \n\t * @return the name of the matrix.\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * The minimum score of this matrix.\n\t * \n\t * @return minimum of the matrix.\n\t */\n\tpublic short getMin() {\n\t\treturn min;\n\t}\n\n\t/**\n\t * The maximum score in this matrix.\n\t * \n\t * @return maximum of the matrix.\n\t */\n\tpublic short getMax() {\n\t\treturn max;\n\t}\n\n\t/**\n\t * Sets the description to the given value.\n\t * \n\t * @param desc\n\t *            a description. This doesn't have to start with '#'.\n\t */\n\tpublic void setDescription(String desc) {\n\t\tthis.description = desc;\n\t}\n\n\t/**\n\t * Gives the alphabet used by this matrix.\n\t * \n\t * @return the alphabet of this matrix.\n\t */\n\tpublic FiniteAlphabet getAlphabet() {\n\t\treturn alphabet;\n\t}\n\n\t/**\n\t * Creates a <code>String</code> representation of this matrix.\n\t * \n\t * @return a string representation of this matrix without the description.\n\t */\n\tpublic String stringnifyMatrix() {\n\t\tint i = 0;\n\t\tStringBuffer matrixString = new StringBuffer();\n\t\tSymbol[] colSyms = new Symbol[this.colSymbols.keySet().size()];\n\n\t\ttry {\n\t\t\tSymbolTokenization symtok = alphabet.getTokenization(\"default\");\n\t\t\tmatrixString.append(\"  \");\n\t\t\tIterator<Symbol> colKeys = colSymbols.keySet().iterator();\n\t\t\twhile (colKeys.hasNext()) {\n\t\t\t\tcolSyms[i] = colKeys.next();\n\t\t\t\tmatrixString.append(symtok.tokenizeSymbol(colSyms[i++])\n\t\t\t\t\t\t.toUpperCase());\n\t\t\t\tmatrixString.append(' ');\n\t\t\t}\n\t\t\tmatrixString.append(newLine);\n\n\t\t\tIterator<Symbol> rowKeys = rowSymbols.keySet().iterator();\n\t\t\twhile (rowKeys.hasNext()) {\n\t\t\t\tSymbol rowSym = rowKeys.next();\n\t\t\t\tmatrixString\n\t\t\t\t\t\t.append(symtok.tokenizeSymbol(rowSym).toUpperCase());\n\t\t\t\tmatrixString.append(' ');\n\t\t\t\tfor (i = 0; i < colSyms.length; i++) {\n\t\t\t\t\tmatrixString.append(getValueAt(rowSym, colSyms[i]));\n\t\t\t\t\tmatrixString.append(' ');\n\t\t\t\t}\n\t\t\t\tmatrixString.append(newLine);\n\t\t\t}\n\t\t} catch (BioException exc) {\n\t\t\texc.printStackTrace();\n\t\t}\n\t\treturn matrixString.toString();\n\t}\n\n\t/**\n\t * Converts the description of the matrix to a String.\n\t * \n\t * @return Gives a description with approximately 60 letters on every line\n\t *         separated by <code>System.getProperty(\"line.separator\")</code>.\n\t *         Every line starts with <code>#</code>.\n\t */\n\tpublic String stringnifyDescription() {\n\t\tStringBuffer desc = new StringBuffer(), line = new StringBuffer();\n\t\tline.append(\"# \");\n\t\tStringTokenizer st = new StringTokenizer(description, \" \");\n\t\twhile (st.hasMoreElements()) {\n\t\t\tline.append(st.nextElement().toString());\n\t\t\tline.append(' ');\n\t\t\tif (line.length() >= 60) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t\tif (st.hasMoreElements()) {\n\t\t\t\t\tline = new StringBuffer();\n\t\t\t\t\tline.append(\"# \");\n\t\t\t\t}\n\t\t\t} else if (!st.hasMoreElements()) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t}\n\t\t}\n\t\treturn desc.toString();\n\t}\n\n\t/**\n\t * Overrides the inherited method.\n\t * \n\t * @return Gives a string representation of the SubstitutionMatrix. This is\n\t *         a valid input for the constructor which needs a matrix string.\n\t *         This String also contains the description of the matrix if there\n\t *         is one.\n\t */\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer desc = new StringBuffer(), line = new StringBuffer();\n\t\tline.append(\"# \");\n\t\tStringTokenizer st = new StringTokenizer(description);\n\t\twhile (st.hasMoreElements()) {\n\t\t\tline.append(st.nextElement().toString());\n\t\t\tline.append(' ');\n\t\t\tif (line.length() >= 60) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t\tif (st.hasMoreElements()) {\n\t\t\t\t\tline = new StringBuffer();\n\t\t\t\t\tline.append(\"# \");\n\t\t\t\t}\n\t\t\t} else if (!st.hasMoreElements()) {\n\t\t\t\tdesc.append(line);\n\t\t\t\tdesc.append(newLine);\n\t\t\t}\n\t\t}\n\t\tdesc.append(stringnifyMatrix());\n\t\treturn desc.toString();\n\t}\n\n\t/**\n\t * Just to perform some test. It prints the matrix on the screen.\n\t */\n\tpublic void printMatrix() {\n\t\t// Test output:\n\t\tIterator<Symbol> rowKeys = rowSymbols.keySet().iterator();\n\t\twhile (rowKeys.hasNext()) {\n\t\t\tIterator<Symbol> colKeys = colSymbols.keySet().iterator();\n\t\t\tSymbol rowSym = rowKeys.next();\n\t\t\tSystem.out.print(rowSym.getName() + \"\\t\");\n\t\t\twhile (colKeys.hasNext()) {\n\t\t\t\tSymbol colSym = colKeys.next();\n\t\t\t\tint x = rowSymbols.get(rowSym).intValue();\n\t\t\t\tint y = colSymbols.get(colSym).intValue();\n\t\t\t\tSystem.out.print(colSym.getName() + \" \" + \" \" + x + \" \" + y\n\t\t\t\t\t\t+ \" \" + matrix[x][y] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println(newLine);\n\t\t}\n\t\tSystem.out.println(toString());\n\t}\n\n\t/**\n\t * With this method you can get a &ldquo;normalized&rdquo;\n\t * <code>SubstitutionMatrix</code> object; however, since this\n\t * implementation uses an short matrix, the normalized matrix will be scaled\n\t * by ten. If you need values between zero and one, you have to divide every\n\t * value returned by <code>getValueAt</code> by ten.\n\t * \n\t * @return a new and normalized <code>SubstitutionMatrix</code> object given\n\t *         by this substitution matrix. Because this uses an\n\t *         <code>short</code> matrix, all values are scaled by 10.\n\t * @throws BioException\n\t * @throws IOException\n\t * @throws NumberFormatException\n\t */\n\tpublic SubstitutionMatrix normalizeMatrix() throws BioException,\n\t\t\tNumberFormatException, IOException {\n\t\tint i, j;\n\t\tshort min = getMin(), newMax = Short.MIN_VALUE;\n\t\tshort[][] mat = new short[matrix.length][matrix[matrix.length - 1].length];\n\t\tString name = getName() + \"_normalized\";\n\t\tString matString = stringnifyDescription() + \"  \";\n\t\tFiniteAlphabet alphabet = getAlphabet();\n\t\tMap<Symbol, Integer> rowMap = this.rowSymbols;\n\t\tMap<Symbol, Integer> colMap = this.colSymbols;\n\t\tSymbolTokenization symtok = alphabet.getTokenization(\"default\");\n\n\t\tfor (i = 0; i < matrix.length; i++)\n\t\t\tfor (j = 0; j < matrix[matrix.length - 1].length; j++) {\n\t\t\t\tmat[i][j] = (short) (matrix[i][j] - min);\n\t\t\t\tif (mat[i][j] > newMax)\n\t\t\t\t\tnewMax = mat[i][j];\n\t\t\t}\n\n\t\tfor (i = 0; i < mat.length; i++)\n\t\t\tfor (j = 0; j < mat[mat.length - 1].length; j++)\n\t\t\t\tmat[i][j] = (short) (mat[i][j] * 10 / newMax);\n\n\t\tObject[] rows = rowSymbols.keySet().toArray();\n\t\tObject[] cols = colSymbols.keySet().toArray();\n\t\tfor (i = 0; i < cols.length; i++)\n\t\t\tmatString += symtok.tokenizeSymbol((Symbol) cols[i]) + \" \";\n\t\tfor (i = 0; i < rows.length; i++) {\n\t\t\tmatString += newLine + symtok.tokenizeSymbol((Symbol) rows[i])\n\t\t\t\t\t+ \" \";\n\t\t\tfor (j = 0; j < cols.length; j++) {\n\t\t\t\tmatString += mat[rowMap.get((Symbol) rows[i]).intValue()][colMap\n\t\t\t\t\t\t.get((Symbol) cols[j]).intValue()]\n\t\t\t\t\t\t+ \" \";\n\t\t\t}\n\t\t}\n\t\tmatString += newLine;\n\t\treturn new SubstitutionMatrix(alphabet, matString, name);\n\t}\n\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Aug 23, 2007\n *\n */\n\npackage org.biojava.bio.alignment;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.AlphabetManager;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.Symbol;\n\npublic class SubstitutionMatrixTest extends TestCase {\n\n\n\n\tpublic void testParseSubstitutionMatrix(){\n\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/blosum62.mat\");\n        assertNotNull(inStream);\n\n\n        try {\n            FiniteAlphabet alphabet = (FiniteAlphabet) AlphabetManager.alphabetForName(\"PROTEIN-TERM\");\n            SymbolTokenization symtok = alphabet.getTokenization(\"token\");\n        \t//String file = readMatrix(inStream);\n        \t//SubstitutionMatrix matrix = new SubstitutionMatrix(alphabet,file,\"blosum 62\");\n        \tSubstitutionMatrix matrix = SubstitutionMatrix.getSubstitutionMatrix(\n        \t\t\tnew BufferedReader(new InputStreamReader(inStream)));\n        \t//matrix.printMatrix();\n\n        \tSymbol A = symtok.parseToken(\"A\");\n        \tSymbol W = symtok.parseToken(\"W\");\n        \tSymbol D = symtok.parseToken(\"D\");\n\n\n        \tassertEquals(matrix.getValueAt(A, A), 4);\n        \tassertEquals(matrix.getValueAt(W, D),-4);\n        } catch (Exception e){\n        \tfail(e.getMessage());\n        }\n\n\n\t}\n\n\n\tprivate String readMatrix(InputStream stream) throws IOException{\n\t\tString newline = System.getProperty(\"line.separator\");\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader( stream));\n\t\tStringBuffer file = new StringBuffer();\n\t\twhile (reader.ready()){\n\t\t\tfile.append(reader.readLine() );\n\t\t\tfile.append(newline);\n\t\t}\n\n\t\treturn file.toString();\n\t}\n}\n","changedTest":"","commitMessage":"Fix to NUC matrix file parsing.\n\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7630 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}