{"repository":"biojava","prod_path":"structure/src/main/java/org/biojava/bio/structure/StructureTools.java","test_path":"structure/src/test/java/org/biojava/bio/structure/StructureToolsTest.java","prod_time":"2009-09-17 07:00:13","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"2ff06c5d6a9939c8944c873b364e32a3b3758585","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\n\n\n/** A class that provides some tool methods.\n *\n * @author Andreas Prlic\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n    public static final String   caAtomName         = \"CA\" ;\n\n    /** The names of the Atoms that form the backbone.\n     *\n     */\n    public static final String[] backboneAtomNames = {\"N\",\"CA\",\"C\",\"O\",\"CB\"};\n\n    public static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\n\t// for conversion 3code 1code\n\tprivate static  SymbolTokenization threeLetter ;\n\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n    static {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\n\n\t\ttry {\n\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n\t\t} catch (Exception e) {\n\t\t\t// this should not happen.\n\t\t\t// only if BioJava has not been built correctly...\n\t\t\tlogger.config(e.getMessage());\n\t\t\te.printStackTrace() ;\n\t\t}\n\n    }\n\n\n    /** Count how many number of Atoms are contained within a Structure object.\n     *\n     * @param s the structure object\n     * @return the number of Atoms in this Structure\n     */\n    public static int getNrAtoms(Structure s){\n\n        int nrAtoms = 0;\n\n        Iterator<Group> iter = new GroupIterator(s);\n\n        while ( iter.hasNext()){\n            Group g = (Group) iter.next();\n            nrAtoms += g.size();\n        }\n\n        return nrAtoms;\n    }\n\n\n    /** Count how many groups are contained within a structure object.\n     *\n     * @param s the structure object\n     * @return the number of groups in the structure\n     */\n    public static int getNrGroups(Structure s){\n        int nrGroups = 0;\n\n        List<Chain> chains = s.getChains(0);\n        Iterator<Chain> iter = chains.iterator();\n        while (iter.hasNext()){\n            Chain c = (Chain) iter.next();\n            nrGroups += c.getAtomLength();\n        }\n        return nrGroups;\n    }\n\n\n    /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n     * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n     *\n     *\n     * @param s the structure to get the atoms from\n     *\n     * @param atomNames  contains the atom names to be used.\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomArray(Structure s, String[] atomNames){\n        Iterator<Group> iter = new GroupIterator(s);\n        List<Atom> atoms = new ArrayList<Atom>();\n        while ( iter.hasNext()){\n            Group g = (Group) iter.next();\n\n            // a temp container for the atoms of this group\n            List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n            // flag to check if this group contains all the requested atoms.\n            boolean thisGroupAllAtoms = true;\n            for ( int i = 0 ; i < atomNames.length; i++){\n                String atomName = atomNames[i];\n                try {\n                    Atom a = g.getAtom(atomName);\n                    thisGroupAtoms.add(a);\n                } catch (StructureException e){\n                    // this group does not have a required atom, skip it...\n                    thisGroupAllAtoms = false;\n                    break;\n                }\n            }\n            if ( thisGroupAllAtoms){\n                // add the atoms of this group to the array.\n                Iterator<Atom> aIter = thisGroupAtoms.iterator();\n                while(aIter.hasNext()){\n                    Atom a = (Atom) aIter.next();\n                    atoms.add(a);\n                }\n            }\n\n        }\n        return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n    }\n\n    /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n     * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n     *\n     *\n     * @param c the Chain to get the atoms from\n     *\n     * @param atomNames  contains the atom names to be used.\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomArray(Chain c, String[] atomNames){\n        \n       List<Group> groups = c.getAtomGroups();\n       \n        List<Atom> atoms = new ArrayList<Atom>();\n        \n       for (Group g : groups){\n\n            // a temp container for the atoms of this group\n            List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n            // flag to check if this group contains all the requested atoms.\n            boolean thisGroupAllAtoms = true;\n            for ( int i = 0 ; i < atomNames.length; i++){\n                String atomName = atomNames[i];\n                try {\n                    Atom a = g.getAtom(atomName);\n                    thisGroupAtoms.add(a);\n                } catch (StructureException e){\n                    // this group does not have a required atom, skip it...\n                    thisGroupAllAtoms = false;\n                    break;\n                }\n            }\n            if ( thisGroupAllAtoms){\n                // add the atoms of this group to the array.\n                Iterator<Atom> aIter = thisGroupAtoms.iterator();\n                while(aIter.hasNext()){\n                    Atom a = (Atom) aIter.next();\n                    atoms.add(a);\n                }\n            }\n\n        }\n        return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n    }\n    \n    /** Returns an Atom array of the CA atoms.\n     * @param c the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomCAArray(Chain c){\n        String[] atomNames = {caAtomName};\n        return getAtomArray(c,atomNames);\n    }\n    \n    \n\n\n    /** Returns an Atom array of the CA atoms.\n     * @param s the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomCAArray(Structure s){\n        String[] atomNames = {caAtomName};\n        return getAtomArray(s,atomNames);\n    }\n\n    /** Returns an Atom array of the MainChain atoms.\n\n     * @param s the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getBackboneAtomArray(Structure s){\n        String[] atomNames = backboneAtomNames;\n        return getAtomArray(s,atomNames);\n    }\n\n\n    /** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static Character convert_3code_1code(String code3)\n\tthrows IllegalSymbolException\n\t{\n\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\n\t\treturn new Character(code1.charAt(0)) ;\n\n\t}\n\n    /** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (IllegalSymbolException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\tlogger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n    /* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\n\n}\n","changedPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.seq.io.SymbolTokenization;\nimport org.biojava.bio.symbol.Alphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\n\n\n/** A class that provides some tool methods.\n *\n * @author Andreas Prlic\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n    public static final String   caAtomName         = \"CA\" ;\n\n    /** The names of the Atoms that form the backbone.\n     *\n     */\n    public static final String[] backboneAtomNames = {\"N\",\"CA\",\"C\",\"O\",\"CB\"};\n\n    public static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\n\t// for conversion 3code 1code\n\tprivate static  SymbolTokenization threeLetter ;\n\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n    static {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\n\n\t\ttry {\n\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n\t\t} catch (Exception e) {\n\t\t\t// this should not happen.\n\t\t\t// only if BioJava has not been built correctly...\n\t\t\tlogger.config(e.getMessage());\n\t\t\te.printStackTrace() ;\n\t\t}\n\n    }\n\n\n    /** Count how many number of Atoms are contained within a Structure object.\n     *\n     * @param s the structure object\n     * @return the number of Atoms in this Structure\n     */\n    public static int getNrAtoms(Structure s){\n\n        int nrAtoms = 0;\n\n        Iterator<Group> iter = new GroupIterator(s);\n\n        while ( iter.hasNext()){\n            Group g = (Group) iter.next();\n            nrAtoms += g.size();\n        }\n\n        return nrAtoms;\n    }\n\n\n    /** Count how many groups are contained within a structure object.\n     *\n     * @param s the structure object\n     * @return the number of groups in the structure\n     */\n    public static int getNrGroups(Structure s){\n        int nrGroups = 0;\n\n        List<Chain> chains = s.getChains(0);\n        Iterator<Chain> iter = chains.iterator();\n        while (iter.hasNext()){\n            Chain c = (Chain) iter.next();\n            nrGroups += c.getAtomLength();\n        }\n        return nrGroups;\n    }\n\n\n    /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n     * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n     *\n     *\n     * @param s the structure to get the atoms from\n     *\n     * @param atomNames  contains the atom names to be used.\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomArray(Structure s, String[] atomNames){\n        Iterator<Group> iter = new GroupIterator(s);\n        List<Atom> atoms = new ArrayList<Atom>();\n        while ( iter.hasNext()){\n            Group g = (Group) iter.next();\n\n            // a temp container for the atoms of this group\n            List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n            // flag to check if this group contains all the requested atoms.\n            boolean thisGroupAllAtoms = true;\n            for ( int i = 0 ; i < atomNames.length; i++){\n                String atomName = atomNames[i];\n                try {\n                    Atom a = g.getAtom(atomName);\n                    thisGroupAtoms.add(a);\n                } catch (StructureException e){\n                    // this group does not have a required atom, skip it...\n                    thisGroupAllAtoms = false;\n                    break;\n                }\n            }\n            if ( thisGroupAllAtoms){\n                // add the atoms of this group to the array.\n                Iterator<Atom> aIter = thisGroupAtoms.iterator();\n                while(aIter.hasNext()){\n                    Atom a = (Atom) aIter.next();\n                    atoms.add(a);\n                }\n            }\n\n        }\n        return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n    }\n\n    /** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n     * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n     *\n     *\n     * @param c the Chain to get the atoms from\n     *\n     * @param atomNames  contains the atom names to be used.\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomArray(Chain c, String[] atomNames){\n        \n       List<Group> groups = c.getAtomGroups();\n       \n        List<Atom> atoms = new ArrayList<Atom>();\n        \n       for (Group g : groups){\n\n            // a temp container for the atoms of this group\n            List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n            // flag to check if this group contains all the requested atoms.\n            boolean thisGroupAllAtoms = true;\n            for ( int i = 0 ; i < atomNames.length; i++){\n                String atomName = atomNames[i];\n                try {\n                    Atom a = g.getAtom(atomName);\n                    thisGroupAtoms.add(a);\n                } catch (StructureException e){\n                    // this group does not have a required atom, skip it...\n                    thisGroupAllAtoms = false;\n                    break;\n                }\n            }\n            if ( thisGroupAllAtoms){\n                // add the atoms of this group to the array.\n                Iterator<Atom> aIter = thisGroupAtoms.iterator();\n                while(aIter.hasNext()){\n                    Atom a = (Atom) aIter.next();\n                    atoms.add(a);\n                }\n            }\n\n        }\n        return (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n    }\n    \n    /** Returns an Atom array of the CA atoms.\n     * @param c the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomCAArray(Chain c){\n        String[] atomNames = {caAtomName};\n        return getAtomArray(c,atomNames);\n    }\n    \n    \n\n\n    /** Returns an Atom array of the CA atoms.\n     * @param s the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getAtomCAArray(Structure s){\n        String[] atomNames = {caAtomName};\n        return getAtomArray(s,atomNames);\n    }\n\n    /** Returns an Atom array of the MainChain atoms.\n\n     * @param s the structure object\n     * @return an Atom[] array\n     */\n    public static Atom[] getBackboneAtomArray(Structure s){\n        String[] atomNames = backboneAtomNames;\n        return getAtomArray(s,atomNames);\n    }\n\n\n    /** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static Character convert_3code_1code(String code3)\n\tthrows IllegalSymbolException\n\t{\n\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\n\t\treturn new Character(code1.charAt(0)) ;\n\n\t}\n\n    /** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (IllegalSymbolException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\t//logger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n    /* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\n\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.biojava.bio.structure.io.PDBFileParser;\n\nimport junit.framework.TestCase;\n\npublic class StructureToolsTest extends TestCase {\n\n    Structure structure;\n\n    protected void setUp()\n    {\n        InputStream inStream = this.getClass().getResourceAsStream(\"/5pti.pdb\");\n        assertNotNull(inStream);\n\n\n        PDBFileParser pdbpars = new PDBFileParser();\n        pdbpars.setAlignSeqRes(false);\n        try {\n            structure = pdbpars.parsePDBFile(inStream) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        assertNotNull(structure);\n\n        assertEquals(\"structure does not contain one chain \", 1 ,structure.size());\n    }\n\n\n    public void testGetCAAtoms(){\n        Atom[] cas = StructureTools.getAtomCAArray(structure);\n        assertEquals(\"did not find the expected number of Atoms (58), but got \" + cas.length,58,cas.length);\n    }\n\n    public void testGetNrAtoms(){\n        int length = StructureTools.getNrAtoms(structure);\n        assertEquals(\"did not find the expected number of Atoms (1104), but got \" + length,1104,length);\n\n\n    }\n\n\n\n}\n","changedTest":"","commitMessage":"less verbose parsing of chemically modified residues\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7229 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}