{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/symbol/SymbolList.java","test_path":"core/src/test/java/org/biojava/bio/symbol/SymbolListTest.java","prod_time":"2010-03-24 18:21:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"468b6e5d123d6d1b07d496f43c2027defa45e244","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\n\npackage org.biojava.bio.symbol;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava.utils.ChangeType;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.Changeable;\n\n/**\n * A sequence of symbols that belong to an alphabet.\n * <p>\n * This uses biological coordinates (1 to length).\n *\n * @author Matthew Pocock\n * @author Mark Schreiber\n * @author Francois Pepin\n */\npublic interface SymbolList extends Changeable {\n  /**\n   * Signals that the SymbolList is being edited. The getChange field of the\n   * event should contain the SymbolList.Edit object describing the change.\n   */\n  public static final ChangeType EDIT = new ChangeType(\n    \"the SymbolList has been edited\",\n    \"org.biojava.bio.symbol.SymbolList\",\n    \"EDIT\"\n  );\n  \n  /**\n   * The alphabet that this SymbolList is over.\n   * <p>\n   * Every symbol within this SymbolList is a member of this alphabet.\n   * <code>alphabet.contains(symbol) == true</code>\n   * for each symbol that is within this sequence.\n   *\n   * @return  the alphabet\n   */\n  Alphabet getAlphabet();\n  \n  /**\n   * The number of symbols in this SymbolList.\n   *\n   * @return  the length\n   */\n  int length();\n\n  /**\n   * Return the symbol at index, counting from 1.\n   *\n   * @param index the offset into this SymbolList\n   * @return  the Symbol at that index\n   * @throws IndexOutOfBoundsException if index is less than 1, or greater than\n   *                                   the length of the symbol list\n   */\n  Symbol symbolAt(int index) throws IndexOutOfBoundsException;\n  \n  /**\n   * Returns a List of symbols.\n   * <p>\n   * This is an immutable list of symbols. Do not edit it.\n   *\n   * @return  a List of Symbols\n   */\n  List toList();\n  \n  /**\n   * An Iterator over all Symbols in this SymbolList.\n   * <p>\n   * This is an ordered iterator over the Symbols. It cannot be used\n   * to edit the underlying symbols.\n   *\n   * @return  an iterator\n   */\n  Iterator iterator();\n  \n  /**\n   * Return a new SymbolList for the symbols start to end inclusive.\n   * <p>\n   * The resulting SymbolList will count from 1 to (end-start + 1) inclusive, and\n   * refer to the symbols start to end of the original sequence.\n   *\n   * @param start the first symbol of the new SymbolList\n   * @param end the last symbol (inclusive) of the new SymbolList\n   */\n  SymbolList subList(int start, int end) throws IndexOutOfBoundsException;\n    \n  /**\n   * Stringify this symbol list.\n   * <p>\n   * It is expected that this will use the symbol's token to render each\n   * symbol. It should be parsable back into a SymbolList using the default\n   * token parser for this alphabet.\n   *\n   * @return  a string representation of the symbol list\n   */\n  String seqString();\n  \n  /**\n   * Return a region of this symbol list as a String.\n   * <p>\n   * This should use the same rules as seqString.\n   *\n   * @param start  the first symbol to include\n   * @param end the last symbol to include\n   * @return the string representation\n   * @throws IndexOutOfBoundsException if either start or end are not within the\n   *         SymbolList\n   */\n  String subStr(int start, int end) throws IndexOutOfBoundsException;\n  \n  /**\n   * Apply an edit to the SymbolList as specified by the edit object.\n   *\n   * <h2>Description</h2>\n   *\n   * <p>\n   * All edits can be broken down into a series of operations that change\n   * contiguous blocks of the sequence. This represent a one of those operations.\n   * </p>\n   *\n   * <p>\n   * When applied, this Edit will replace 'length' number of symbols starting a\n   * position 'pos' by the SymbolList 'replacement'. This allow to do insertions\n   * (length=0), deletions (replacement=SymbolList.EMPTY_LIST) and replacements\n   * (length>=1 and replacement.length()>=1).\n   * </p>\n   *\n   * <p>\n   * The pos and pos+length should always be valid positions on the SymbolList\n   * to:\n   * <ul>\n   * <li>be edited (between 0 and symL.length()+1).</li>\n   * <li>To append to a sequence, pos=symL.length()+1, pos=0.</li>\n   * <li>To insert something at the beginning of the sequence, set pos=1 and\n   * length=0.</li>\n   * </ul>\n   * </p>\n   *\n   * <h2>Examples</h2>\n   *\n   * <code><pre>\n   * SymbolList seq = DNATools.createDNA(\"atcaaaaacgctagc\");\n   * System.out.println(seq.seqString());\n   *\n   * // delete 5 bases from position 4\n   * Edit ed = new Edit(4, 5, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // delete one base from the start\n   * ed = new Edit(1, 1, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   *\n   * // delete one base from the end\n   * ed = new Edit(seq.length(), 1, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // overwrite 2 bases from position 3 with \"tt\"\n   * ed = new Edit(3, 2, DNATools.createDNA(\"tt\"));\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // add 6 bases to the start\n   * ed = new Edit(1, 0, DNATools.createDNA(\"aattgg\");\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // add 4 bases to the end\n   * ed = new Edit(seq.length() + 1, 0, DNATools.createDNA(\"tttt\"));\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // full edit\n   * ed = new Edit(3, 2, DNATools.createDNA(\"aatagaa\");\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   * </pre></code>\n   *\n   * @param edit the Edit to perform\n   * @throws IndexOutOfBoundsException if the edit does not lie within the\n   *         SymbolList\n   * @throws IllegalAlphabetException if the SymbolList to insert has an\n   *         incompatible alphabet\n   * @throws ChangeVetoException  if either the SymboList does not support the\n   *         edit, or if the change was vetoed\n   */\n  void edit(Edit edit)\n  throws IndexOutOfBoundsException, IllegalAlphabetException,\n  ChangeVetoException;\n  \n  /**\n   * A useful object that represents an empty symbol list, to avoid returning\n   * null.\n   *\n   */\n  static final SymbolList EMPTY_LIST = new EmptySymbolList();\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\n\npackage org.biojava.bio.symbol;\n\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.biojava.utils.ChangeType;\nimport org.biojava.utils.ChangeVetoException;\nimport org.biojava.utils.Changeable;\n\n/**\n * A sequence of symbols that belong to an alphabet.\n * <p>\n * This uses biological coordinates (1 to length).\n *\n * @author Matthew Pocock\n * @author Mark Schreiber\n * @author Francois Pepin\n */\npublic interface SymbolList extends Changeable {\n  /**\n   * Signals that the SymbolList is being edited. The getChange field of the\n   * event should contain the SymbolList.Edit object describing the change.\n   */\n  public static final ChangeType EDIT = new ChangeType(\n    \"the SymbolList has been edited\",\n    \"org.biojava.bio.symbol.SymbolList\",\n    \"EDIT\"\n  );\n  \n  /**\n   * The alphabet that this SymbolList is over.\n   * <p>\n   * Every symbol within this SymbolList is a member of this alphabet.\n   * <code>alphabet.contains(symbol) == true</code>\n   * for each symbol that is within this sequence.\n   *\n   * @return  the alphabet\n   */\n  Alphabet getAlphabet();\n  \n  /**\n   * The number of symbols in this SymbolList.\n   *\n   * @return  the length\n   */\n  int length();\n\n  /**\n   * Return the symbol at index, counting from 1.\n   *\n   * @param index the offset into this SymbolList\n   * @return  the Symbol at that index\n   * @throws IndexOutOfBoundsException if index is less than 1, or greater than\n   *                                   the length of the symbol list\n   */\n  Symbol symbolAt(int index) throws IndexOutOfBoundsException;\n  \n  /**\n   * Returns a List of symbols.\n   * <p>\n   * This is an immutable list of symbols. Do not edit it.\n   *\n   * @return  a List of Symbols\n   */\n  List<Symbol> toList();\n  \n  /**\n   * An Iterator over all Symbols in this SymbolList.\n   * <p>\n   * This is an ordered iterator over the Symbols. It cannot be used\n   * to edit the underlying symbols.\n   *\n   * @return  an iterator\n   */\n  Iterator<Symbol> iterator();\n  \n  /**\n   * Return a new SymbolList for the symbols start to end inclusive.\n   * <p>\n   * The resulting SymbolList will count from 1 to (end-start + 1) inclusive, and\n   * refer to the symbols start to end of the original sequence.\n   *\n   * @param start the first symbol of the new SymbolList\n   * @param end the last symbol (inclusive) of the new SymbolList\n   */\n  SymbolList subList(int start, int end) throws IndexOutOfBoundsException;\n    \n  /**\n   * Stringify this symbol list.\n   * <p>\n   * It is expected that this will use the symbol's token to render each\n   * symbol. It should be parsable back into a SymbolList using the default\n   * token parser for this alphabet.\n   *\n   * @return  a string representation of the symbol list\n   */\n  String seqString();\n  \n  /**\n   * Return a region of this symbol list as a String.\n   * <p>\n   * This should use the same rules as seqString.\n   *\n   * @param start  the first symbol to include\n   * @param end the last symbol to include\n   * @return the string representation\n   * @throws IndexOutOfBoundsException if either start or end are not within the\n   *         SymbolList\n   */\n  String subStr(int start, int end) throws IndexOutOfBoundsException;\n  \n  /**\n   * Apply an edit to the SymbolList as specified by the edit object.\n   *\n   * <h2>Description</h2>\n   *\n   * <p>\n   * All edits can be broken down into a series of operations that change\n   * contiguous blocks of the sequence. This represent a one of those operations.\n   * </p>\n   *\n   * <p>\n   * When applied, this Edit will replace 'length' number of symbols starting a\n   * position 'pos' by the SymbolList 'replacement'. This allow to do insertions\n   * (length=0), deletions (replacement=SymbolList.EMPTY_LIST) and replacements\n   * (length>=1 and replacement.length()>=1).\n   * </p>\n   *\n   * <p>\n   * The pos and pos+length should always be valid positions on the SymbolList\n   * to:\n   * <ul>\n   * <li>be edited (between 0 and symL.length()+1).</li>\n   * <li>To append to a sequence, pos=symL.length()+1, pos=0.</li>\n   * <li>To insert something at the beginning of the sequence, set pos=1 and\n   * length=0.</li>\n   * </ul>\n   * </p>\n   *\n   * <h2>Examples</h2>\n   *\n   * <code><pre>\n   * SymbolList seq = DNATools.createDNA(\"atcaaaaacgctagc\");\n   * System.out.println(seq.seqString());\n   *\n   * // delete 5 bases from position 4\n   * Edit ed = new Edit(4, 5, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // delete one base from the start\n   * ed = new Edit(1, 1, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   *\n   * // delete one base from the end\n   * ed = new Edit(seq.length(), 1, SymbolList.EMPTY_LIST);\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // overwrite 2 bases from position 3 with \"tt\"\n   * ed = new Edit(3, 2, DNATools.createDNA(\"tt\"));\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // add 6 bases to the start\n   * ed = new Edit(1, 0, DNATools.createDNA(\"aattgg\");\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // add 4 bases to the end\n   * ed = new Edit(seq.length() + 1, 0, DNATools.createDNA(\"tttt\"));\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   *\n   * // full edit\n   * ed = new Edit(3, 2, DNATools.createDNA(\"aatagaa\");\n   * seq.edit(ed);\n   * System.out.println(seq.seqString());\n   * </pre></code>\n   *\n   * @param edit the Edit to perform\n   * @throws IndexOutOfBoundsException if the edit does not lie within the\n   *         SymbolList\n   * @throws IllegalAlphabetException if the SymbolList to insert has an\n   *         incompatible alphabet\n   * @throws ChangeVetoException  if either the SymboList does not support the\n   *         edit, or if the change was vetoed\n   */\n  void edit(Edit edit)\n  throws IndexOutOfBoundsException, IllegalAlphabetException,\n  ChangeVetoException;\n  \n  /**\n   * A useful object that represents an empty symbol list, to avoid returning\n   * null.\n   *\n   */\n  static final SymbolList EMPTY_LIST = new EmptySymbolList();\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.symbol;\n\nimport java.util.HashSet;\nimport java.util.Random;\nimport java.util.Set;\n\nimport junit.framework.Test;\nimport junit.framework.TestCase;\nimport junit.framework.TestSuite;\n\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.RNATools;\nimport org.biojava.bio.seq.io.ChunkedSymbolListFactory;\nimport org.biojava.utils.ChangeVetoException;\n\n/**\n * JUnit test for SymbolList objects\n * @author David Huen\n * @since 1.3\n */\npublic class SymbolListTest extends TestCase\n{\n    // SymbolList lengths to run tests at.\n    int testLengths[] = {100, 16384, 32000, 100000};\n\n    // number of times to repeat each test to deal with chance\n    // matches in last symbol.\n    int noRepeats = 8;\n\n    /**\n     * an interface for internal classes\n     */\n    private interface SymListFactory {\n        public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length);\n    }\n\n    public SymbolListTest(String string)\n    {\n        super(string);\n    }\n\n    /**\n     * creates a random SymbolList\n     *\n     * @param the Alphabet from which Symbols are to be drawn.  Can include ambiguity symbols.\n     */\n    protected Symbol [] createRandomSymbolArray(FiniteAlphabet alpha, int length)\n        throws Exception\n    {\n        int alfaSize = alpha.size();\n        AlphabetIndex indx = AlphabetManager.getAlphabetIndex(alpha);\n        Random rand = new Random();\n\n        Symbol [] array = new Symbol [length];\n\n        for (int i=0; i < length; i++) {\n            array[i] = indx.symbolForIndex(rand.nextInt(alfaSize));\n        }\n\n        return array;\n    }\n\n    /**\n     * compares a SymbolList against a Symbol array\n     */\n    protected boolean compareSymbolLists(SymbolList list, Symbol [] array)\n    {\n        // array must be at least as long as SymbolList\n        int length = list.length();\n        if (length > array.length) return false;\n\n        // compare symbol lists across length\n        for (int i =1; i <= length; i++) {\n            if (list.symbolAt(i) != array[i-1]) return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Note that arrayAlpha <b>MUST NOT</b> have Symbols that are incompatible with symListAlpha!!!\n     * e.g. arrayAlpha may have ambiguity symbols in it that are only implicitly defined by symListAlpha.\n     * @param arrayAlpha the Alphabet from which the Symbols in the Symbol[] are to be drawn.\n     * @param symListAlpha the Alphabet on which the symbolList is to be defined.\n     */\n    protected boolean runSymbolListTest(FiniteAlphabet arrayAlpha, FiniteAlphabet symListAlpha, int length, SymListFactory factory)\n        throws Exception\n    {\n            // create a Symbol array of the kind required\n            Symbol [] array = createRandomSymbolArray(arrayAlpha, length);\n            assertNotNull(array);\n\n            // create the required SymbolList\n            SymbolList symList = factory.createSymbolList(array, symListAlpha, length);\n//            if (symList == null) return false;\n            assertNotNull(symList);\n\n            // verify and return result.\n            return compareSymbolLists(symList, array);\n    }\n\n\n    /**\n     * runs repeated tests for the constructor\n     * that takes a SymbolList argument\n     */\n    private boolean runRepeatedSymbolListTests(FiniteAlphabet arrayAlpha, FiniteAlphabet symListAlpha, SymListFactory factory)\n        throws Exception\n    {\n        for (int i=0; i < testLengths.length; i++) {\n\n            // setup test for specified length\n            int length = testLengths[i];\n\n            for (int j=0; j < noRepeats; j++ ) {\n                assertTrue(runSymbolListTest(arrayAlpha, symListAlpha, length, factory));\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * set that generates a DNA alphabet including ambiguity symbols.\n     */\n    private FiniteAlphabet generateAmbiguousDNA()\n    {\n        FiniteAlphabet dna = DNATools.getDNA();\n\n        FiniteAlphabet ambiguous = new SimpleAlphabet();\n\n        try {\n        ambiguous.addSymbol(DNATools.a());\n        ambiguous.addSymbol(DNATools.c());\n        ambiguous.addSymbol(DNATools.g());\n        ambiguous.addSymbol(DNATools.t());\n\n        Set chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.c());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.a());\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars = new HashSet();\n        chars.add(DNATools.c());\n        chars.add(DNATools.g());\n        chars.add(DNATools.t());\n        ambiguous.addSymbol(dna.getAmbiguity(chars));\n\n        chars.add(DNATools.n());\n\n        return ambiguous;\n        }\n        catch (IllegalSymbolException ise) {\n            return null;\n        }\n        catch (ChangeVetoException cve) {\n            return null;\n        }\n    }\n\n    /**\n     * test for PackedSymbolList that implements ambiguity symbols.\n     */\n    public void testPackedSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a PackedSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    try {\n                        // get a packing\n                        Packing pack = PackingFactory.getPacking(DNATools.getDNA(), true);\n                        assertNotNull(pack);\n                        assertNotNull(array);\n                        assertNotNull(alpha);\n                        assertTrue(length > 0);\n\n                        return new PackedSymbolList(pack, array, length, alpha);\n                    }\n                    catch (IllegalAlphabetException iae) {\n                        iae.printStackTrace();\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    /**\n     * test for SimpleSymbolList that implements ambiguity symbols.\n     */\n    public void testSimpleSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a SimpleSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    assertNotNull(array);\n                    assertNotNull(alpha);\n                    assertTrue(length > 0);\n\n                    return new SimpleSymbolList(array, length, alpha);\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    /**\n     * test for PackedSymbolList that does not implement ambiguity symbols.\n     */\n    public void testPackedSymbolListWithoutAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet without ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        assertNotNull(symListAlpha);\n\n        // create a PackedSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    try {\n                        // get a packing\n                        Packing pack = PackingFactory.getPacking(DNATools.getDNA(), false);\n                        assertNotNull(pack);\n                        assertNotNull(array);\n                        assertNotNull(alpha);\n                        assertTrue(length > 0);\n\n                        return new PackedSymbolList(pack, array, length, alpha);\n                    }\n                    catch (IllegalAlphabetException iae) {\n                        iae.printStackTrace();\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(symListAlpha, symListAlpha, factory));\n    }\n    \n    public void testSymbolListsEqual() throws Exception {\n        SymbolList dna = DNATools.createDNA(\"\");\n        SymbolList rna = RNATools.createRNA(\"\");\n        assertFalse(dna.equals(rna));\n    }\n\n    /**\n     * test for SimpleSymbolList that implements ambiguity symbols.\n     */\n    public void testChunkedPackedSymbolListWithAmbiguitySymbols()\n        throws Exception\n    {\n        // create an alphabet with ambiguity symbols\n        FiniteAlphabet symListAlpha = (FiniteAlphabet) DNATools.getDNA();\n        FiniteAlphabet arrayAlpha = generateAmbiguousDNA();\n        assertNotNull(arrayAlpha);\n        assertNotNull(symListAlpha);\n\n        // create a SimpleSymbolList that supports ambiguity symbols\n        SymListFactory factory = new SymListFactory () {\n                public SymbolList createSymbolList(Symbol [] array, FiniteAlphabet alpha, int length)\n                {\n                    assertNotNull(array);\n                    assertNotNull(alpha);\n                    assertTrue(length > 0);\n\n                    try {\n                        // create the factory that will make our sequence\n                        ChunkedSymbolListFactory chunker = new ChunkedSymbolListFactory(new PackedSymbolListFactory(true));\n\n                        // add symbols to it.\n                        chunker.addSymbols(alpha, array, 0, length);\n                        return chunker.makeSymbolList();\n                    }\n                        catch (IllegalAlphabetException iae) {\n                        return null;\n                    }\n                }\n            };\n\n        // exercise the PackedSymbolList implementation\n        assertTrue(runRepeatedSymbolListTests(arrayAlpha, symListAlpha, factory));\n    }\n\n    // creates a suite\n    public static Test suite()\n    {\n        TestSuite suite = new TestSuite(SymbolListTest.class);\n\n//        TestSuite suite = new TestSuite();\n//        suite.add(new SymbolListTest(\"PackedSymbolListWithAmbiguitySymbols\"));\n\n        return suite;\n    }\n\n    // harness for tests\n    public static void main(String [] args)\n    {\n        junit.textui.TestRunner.run(suite());\n    }\n}\n","changedTest":"","commitMessage":"Improved Alignment classes: Now we have an alignment object that contains all information about the alignment instead of simply having a String output. This formatation algorithm has also been improved and should now be much faster and has become much simpler. Furthermore, many generic type attributes have been added. However, additional tests are necessary to make the new framework run properly.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7595 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":true}