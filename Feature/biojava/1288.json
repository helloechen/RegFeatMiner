{"repository":"biojava","prod_path":"structure/src/main/java/org/biojava/bio/structure/StructureTools.java","test_path":"structure/src/test/java/org/biojava/bio/structure/StructureToolsTest.java","prod_time":"2010-10-13 13:39:39","test_time":"2010-10-13 14:15:53","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":3,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":13,"del_classname_line":0,"del_condition_line":3,"del_field_line":2,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"POSITIVE","prod_commitID":"1fb80cc70eac91d2f8e110bba7faf79908d1fdec","test_commitID":"7a03aecac9e750a4a6b3b35563343e92603614af","isfound":"found test change","originPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n//import org.biojava.bio.seq.ProteinTools;\n//import org.biojava.bio.seq.io.SymbolTokenization;\n//import org.biojava.bio.symbol.Alphabet;\n//import org.biojava.bio.symbol.IllegalSymbolException;\n//import org.biojava.bio.symbol.Symbol;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n\tpublic static final String caAtomName = \" CA \";\n\n\tpublic static final String nAtomName = \"N\";\n\n\tpublic static final String oAtomName = \"O\";\n\n\tpublic static final String cbAtomName = \"CB\";\n\n\n\t/** The names of the Atoms that form the backbone.\n\t *\n\t */\n\tpublic static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n\tpublic static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\n\tprivate static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n\tprivate static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\t//amino acid 3 and 1 letter code definitions\n\tprivate static final Map<String, Character> aminoAcids;\n\n\t//\t// for conversion 3code 1code\n\t//\tprivate static  SymbolTokenization threeLetter ;\n\t//\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n\tstatic {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\t\taminoAcids = new HashMap<String, Character>();\n\t\taminoAcids.put(\"GLY\", new Character('G'));\n\t\taminoAcids.put(\"ALA\", new Character('A'));\n\t\taminoAcids.put(\"VAL\", new Character('V'));\n\t\taminoAcids.put(\"LEU\", new Character('L'));\n\t\taminoAcids.put(\"ILE\", new Character('I'));\n\t\taminoAcids.put(\"PHE\", new Character('F'));\n\t\taminoAcids.put(\"TYR\", new Character('Y'));\n\t\taminoAcids.put(\"TRP\", new Character('W'));\n\t\taminoAcids.put(\"PRO\", new Character('P'));\n\t\taminoAcids.put(\"HIS\", new Character('H'));\n\t\taminoAcids.put(\"LYS\", new Character('K'));\n\t\taminoAcids.put(\"ARG\", new Character('R'));\n\t\taminoAcids.put(\"SER\", new Character('S'));\n\t\taminoAcids.put(\"THR\", new Character('T'));\n\t\taminoAcids.put(\"GLU\", new Character('E'));\n\t\taminoAcids.put(\"GLN\", new Character('Q'));\n\t\taminoAcids.put(\"ASP\", new Character('D'));\n\t\taminoAcids.put(\"ASN\", new Character('N'));\n\t\taminoAcids.put(\"CYS\", new Character('C'));\n\t\taminoAcids.put(\"MET\", new Character('M'));\n\t\t//MSE is only found as a molecular replacement for MET\n\t\taminoAcids.put(\"MSE\", new Character('M'));\n\t\t//'non-standard', genetically encoded\n\t\t//http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n\t\t//IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n\t\t//likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n\t\taminoAcids.put(\"CSE\", new Character('U'));\n\t\taminoAcids.put(\"SEC\", new Character('U'));\n\t\taminoAcids.put(\"PYH\", new Character('O'));\n\t\taminoAcids.put(\"PYL\", new Character('O'));\n\n\t\t//\t\ttry {\n\t\t//\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n\t\t//\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n\t\t//\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n\t\t//\t\t} catch (Exception e) {\n\t\t//\t\t\t// this should not happen.\n\t\t//\t\t\t// only if BioJava has not been built correctly...\n\t\t//\t\t\tlogger.config(e.getMessage());\n\t\t//\t\t\te.printStackTrace() ;\n\t\t//\t\t}\n\n\t}\n\n\n\t/** Count how many number of Atoms are contained within a Structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of Atoms in this Structure\n\t */\n\tpublic static final int getNrAtoms(Structure s){\n\n\t\tint nrAtoms = 0;\n\n\t\tIterator<Group> iter = new GroupIterator(s);\n\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\t\t\tnrAtoms += g.size();\n\t\t}\n\n\t\treturn nrAtoms;\n\t}\n\n\n\t/** Count how many groups are contained within a structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of groups in the structure\n\t */\n\tpublic static final int getNrGroups(Structure s){\n\t\tint nrGroups = 0;\n\n\t\tList<Chain> chains = s.getChains(0);\n\t\tIterator<Chain> iter = chains.iterator();\n\t\twhile (iter.hasNext()){\n\t\t\tChain c = (Chain) iter.next();\n\t\t\tnrGroups += c.getAtomLength();\n\t\t}\n\t\treturn nrGroups;\n\t}\n\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Structure s, String[] atomNames){\n\t\tIterator<Group> iter = new GroupIterator(s);\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param c the Chain to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n\t\tList<Group> groups = c.getAtomGroups();\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (Group g : groups){\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param c the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomCAArray(Chain c){\n\t\tString[] atomNames = {\" CA \" };\n\t\treturn getAtomArray(c,atomNames);\n\t}\n\n\t/** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n\t * groups and chains. The chain will only contain groups that are part of the CA array.\n\t * \n\t * @param ca array of CA atoms\n\t * @return Atom array\n\t */\n\tpublic static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n\t\tAtom[] newCA = new Atom[ca.length];\n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getParent();\n\t\t\tChain parentC = parentG.getParent();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getName().equals(parentC.getName())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setName(parentC.getName());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup parentN = (Group)parentG.clone();\n\n\t\t\tnewCA[apos] = parentN.getAtom(\" CA \");\n\t\t\tnewChain.addGroup(parentN);\n\t\t}\n\t\treturn newCA;\n\t}\n\n\t/** Clone a set of CA Atoms, but returns the parent groups\n\t *  \n\t * @param ca Atom array\n\t * @return Group array\n\t */\n\tpublic static Group[] cloneGroups(Atom[] ca) {\n\t\tGroup[] newGroup = new Group[ca.length]; \n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getParent();\n\t\t\tChain parentC = parentG.getParent();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getName().equals(parentC.getName())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setName(parentC.getName());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup ng = (Group)parentG.clone();\n\t\t\tnewGroup[apos] = ng;\n\t\t\tnewChain.addGroup(ng);\n\t\t}\n\t\treturn newGroup;\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getAtomCAArray(Structure s){\n\t\tString[] atomNames = {\" CA \"};\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\t/** Returns an Atom array of the MainChain atoms.\n\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getBackboneAtomArray(Structure s){\n\t\tString[] atomNames = backboneAtomNames;\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\n\t/** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static final Character convert_3code_1code(String code3)\n\tthrows UnknownPdbAminoAcidException {\n\t\t//\t{\n\t\t//\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\t//\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\t\t//\n\t\t//\t\treturn new Character(code1.charAt(0)) ;\n\t\tCharacter code1 = null;\n\t\tcode1 = aminoAcids.get(code3);\n\n\t\tif (code1 == null) {\n\t\t\tthrow new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n\t\t} else {\n\t\t\treturn code1;\n\t\t}\n\n\t}\n\n\t/** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static final Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\t//logger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n\t/* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static final boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n\t * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n\t * \n\t * @param s\n\t * @param chainId\n\t * @return Structure\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\n\t\tif ( chainId != null)\n\t\t\tchainId = chainId.trim();\n\n\t\tif ( chainId == null || chainId.equals(\"\")){\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\t\tChain c =  null;\n\t\ttry {\n\t\t\tc = s.getChainByPDB(chainId);\n\t\t} catch (StructureException e){\n\t\t\tSystem.err.println(e.getMessage() + \" trying upper case Chain id...\");\n\t\t\tc = s.getChainByPDB(chainId.toUpperCase());\n\n\t\t}\n\t\tif ( c != null)\n\t\t\tnewS.addChain(c);\n\n\n\t\treturn newS;\n\t}\n\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainNr >=0 only takes the chain at that position into account.\t * \n\t * @param s\n\t * @param chainNr can be -1 to request all chains of model 0, otherwise will only add chain at this position \n\t * @return Structure object\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tif ( chainNr < 0 ) {\n\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\n\t\tChain c =  null;\n\n\t\tc = s.getChain(chainNr);\n\n\t\tnewS.addChain(c);\n\n\n\t\treturn newS;\n\t}\n\n\t/** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n\t * specification:\n\t *\n\t * If range is null or \"\" returns the whole structure / chain.\n\t * \n\t * range can be surrounded by ( and ). (but will be removed).\n\t * ranges are specified as\n\t * PDBresnum1 : PDBresnum2\n\t * \n\t *  a list of ranges is separated by ,\n\t *  \n\t *  Example\n\t *  4GCR(A:1-83)\n\t *  1CDG(A:407-495,A:582-686)\n\t *  \n\t * \n\t * \n\t * @param s\n\t * @param ranges\n\t * @return a structure object\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getSubRanges(Structure s, String ranges ) \n\tthrows StructureException\n\t{\n\t\tStructure struc = getReducedStructure(s, null);\n\n\t\tif ( ranges == null || ranges.equals(\"\"))\n\t\t\tthrow new IllegalArgumentException(\"ranges can't be null or empty\");\n\n\t\tranges = ranges.trim();\n\n\t\tif ( ranges.startsWith(\"(\"))\n\t\t\tranges = ranges.substring(1);\n\t\tif ( ranges.endsWith(\")\")) {\n\t\t\tranges = ranges.substring(0,ranges.length()-1);\n\t\t}\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\n\t\tString[] rangS =ranges.split(\",\");\n\n\n\t\tString prevChainId = null;\n\n\t\tfor ( String r: rangS){\n\t\t\tString[] coords = r.split(\":\");\n\t\t\tif ( coords.length > 2){\n\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n\t\t\t}\n\n\n\t\t\tChain chain = struc.getChainByPDB(coords[0]);\n\t\t\tGroup[] groups;\n\t\t\tif  ( coords.length > 1){\n\t\t\t\t// if length 1, only provided a Chain id...\n\n\n\t\t\t\tString[] pdbRanges = coords[1].split(\"-\");\n\t\t\t\tif ( pdbRanges.length!= 2)\n\t\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n\t\t\t\tString pdbresnumStart = pdbRanges[0].trim();\n\t\t\t\tString pdbresnumEnd   = pdbRanges[1].trim();\n\n\t\t\t\tgroups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t// only chain ID provided ... add the whole chain...\n\t\t\t\t groups = chain.getAtomGroups().toArray(new Group[chain.getAtomGroups().size()]);\n\t\t\t}\n\t\t\t\n\t\t\tChain c = null;\n\t\t\tif ( prevChainId == null) {\n\t\t\t\t// first chain...\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tc.setName(chain.getName());\n\t\t\t\tnewS.addChain(c);\n\t\t\t} else if ( prevChainId.equals(chain.getName())) {\n\t\t\t\tc = newS.getChainByPDB(prevChainId);\n\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tc = newS.getChainByPDB(chain.getName());\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// chain not in structure yet...\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setName(chain.getName());\n\t\t\t\t\tnewS.addChain(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the groups to the chain:\n\t\t\tfor ( Group g: groups) {\n\t\t\t\tc.addGroup(g);\n\t\t\t}\n\n\t\t\tprevChainId = c.getName();\n\t\t}\n\n\n\t\treturn newS;\n\t}\n\n\tpublic static final String convertAtomsToSeq(Atom[] atoms) {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tGroup prevGroup  = null;\n\t\tfor (Atom a : atoms){\n\t\t\tGroup g = a.getParent();\n\t\t\tif ( prevGroup != null) {\n\t\t\t\tif ( prevGroup.equals(g)) {\n\t\t\t\t\t// we add each group only once.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString code3 = g.getPDBName();\n\t\t\ttry {\n\t\t\t\tbuf.append(convert_3code_1code(code3) );\n\t\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t\tbuf.append('X');\n\t\t\t}\n\t\t\tprevGroup = g;\n\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/** get a PDB residue number object for this group\n\t * \n\t * @param g Group object\n\t * @return a ResidueNumber object\n\t */\n\tpublic static final ResidueNumber getPDBResidueNumber(Group g){\n\n\t\tResidueNumber pdbResNum = new ResidueNumber();\n\n\t\tChain parent = g.getParent();\n\t\tif ( parent != null)\n\t\t\tpdbResNum.setChainId(parent.getName());\n\n\t\tMatcher matcher = insertionCodePattern.matcher(g.getPDBCode());\n\t\tif (matcher.find()){\n\n\t\t\tString number = matcher.group(1);\n\t\t\tString insCode = matcher.group(2);\n\t\t\tpdbResNum.setSeqNum(Integer.parseInt(number));\n\t\t\tif ((insCode != null) && (! insCode.equals(\"\"))){\n\t\t\t\tpdbResNum.setInsCode(insCode);\n\t\t\t}\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpdbResNum.setSeqNum(Integer.parseInt(g.getPDBCode()));\n\t\t\t} catch (NumberFormatException e){\n\n\t\t\t}\n\t\t}\n\n\t\treturn pdbResNum;\n\n\t}\n\t\n\t/** Get a group represented by a ResidueNumber.\n\t * \n\t * @param struc a {@link Structure}\n\t * @param pdbResNum a {@link ResidueNumber}\n\t * @return a group in the structure that is represented by the pdbResNum. \n\t * @throws StructureException if the group cannot be found.\n\t */\n\tpublic static final Group getGroupByPDBResidueNumber(Structure struc, \n\t\t\tResidueNumber pdbResNum) throws StructureException {\n\t\tif (struc == null || pdbResNum==null) {\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\n\t\t}\n\t\t\n\t\tChain chain = struc.findChain(pdbResNum.getChainId());\n\t\t\n\t\tString numIns = \"\" + pdbResNum.getSeqNum();\n\t\tif (pdbResNum.getInsCode() != null) {\n\t\t\tnumIns += pdbResNum.getInsCode();\n\t\t}\n\t\t\n\t\treturn chain.getGroupByPDB(numIns);\n\t}\n\n}\n","changedPro":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jan 4, 2006\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n\n//import org.biojava.bio.seq.ProteinTools;\n//import org.biojava.bio.seq.io.SymbolTokenization;\n//import org.biojava.bio.symbol.Alphabet;\n//import org.biojava.bio.symbol.IllegalSymbolException;\n//import org.biojava.bio.symbol.Symbol;\n\n\n/**\n * A class that provides some tool methods.\n *\n * @author Andreas Prlic, Jules Jacobsen\n * @since 1.0\n * @version %I% %G%\n */\npublic class StructureTools {\n\n\t/** The Atom name of C-alpha atoms.\n\t *\n\t */\n\tpublic static final String caAtomName = \" CA \";\n\n\tpublic static final String nAtomName = \"N\";\n\n\tpublic static final String oAtomName = \"O\";\n\n\tpublic static final String cbAtomName = \"CB\";\n\n\n\t/** The names of the Atoms that form the backbone.\n\t *\n\t */\n\tpublic static final String[] backboneAtomNames = {nAtomName,caAtomName,\"C\",oAtomName, cbAtomName};\n\n\tpublic static final Character UNKNOWN_GROUP_LABEL = new Character('x');;\n\n\n\t//private static final String insertionCodeRegExp = \"([0-9]+)([a-zA-Z]*)\";\n\t//private static final Pattern insertionCodePattern = Pattern.compile(insertionCodeRegExp);\n\n\n\t// there is a file format change in PDB 3.0 and nucleotides are being renamed\n\tstatic private Map<String, Integer> nucleotides30 ;\n\tstatic private Map<String, Integer> nucleotides23 ;\n\n\t//amino acid 3 and 1 letter code definitions\n\tprivate static final Map<String, Character> aminoAcids;\n\n\t//\t// for conversion 3code 1code\n\t//\tprivate static  SymbolTokenization threeLetter ;\n\t//\tprivate static  SymbolTokenization oneLetter ;\n\n\tpublic static Logger logger =  Logger.getLogger(\"org.biojava.bio.structure\");\n\n\tstatic {\n\t\tnucleotides30 = new HashMap<String,Integer>();\n\t\tnucleotides30.put(\"DA\",1);\n\t\tnucleotides30.put(\"DC\",1);\n\t\tnucleotides30.put(\"DG\",1);\n\t\tnucleotides30.put(\"DT\",1);\n\t\tnucleotides30.put(\"DI\",1);\n\t\tnucleotides30.put(\"A\",1);\n\t\tnucleotides30.put(\"G\",1);\n\t\tnucleotides30.put(\"C\",1);\n\t\tnucleotides30.put(\"U\",1);\n\t\tnucleotides30.put(\"I\",1);\n\n\t\t//TODO: check if they are always HETATMs, in that case this will not be necessary\n\t\t// the DNA linkers - the +C , +G, +A  +T +U and +I have been replaced with these:\n\t\tnucleotides30.put(\"TAF\",1); // 2'-DEOXY-2'-FLUORO-ARABINO-FURANOSYL THYMINE-5'-PHOSPHATE\n\t\tnucleotides30.put(\"TC1\",1); // 3-(5-PHOSPHO-2-DEOXY-BETA-D-RIBOFURANOSYL)-2-OXO-1,3-DIAZA-PHENOTHIAZINE\n\t\tnucleotides30.put(\"TFE\",1); // 2'-O-[2-(TRIFLUORO)ETHYL] THYMIDINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TFO\",1); // [2-(6-AMINO-9H-PURIN-9-YL)-1-METHYLETHOXY]METHYLPHOSPHONIC ACID\"\n\t\tnucleotides30.put(\"TGP\",1); // 5'-THIO-2'-DEOXY-GUANOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"THX\",1); // PHOSPHONIC ACID 6-({6-[6-(6-CARBAMOYL-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONYL)-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDOCENE-2-CARBONYL]-3,6,7,8-TETRAHYDRO-3,6-DIAZA-AS-INDACENE-2-CARBONL}-AMINO)-HEXYL ESTER 5-(5-METHYL-2,4-DIOXO-3,4-DIHYDRO-2H-PYRIMIDIN-1-YL)-TETRAHYDRO-FURAN-2-YLMETHYL ESTER\n\t\tnucleotides30.put(\"TLC\",1); // 2-O,3-ETHDIYL-ARABINOFURANOSYL-THYMINE-5'-MONOPHOSPHATE\n\t\tnucleotides30.put(\"TLN\",1); //  [(1R,3R,4R,7S)-7-HYDROXY-3-(THYMIN-1-YL)-2,5-DIOXABICYCLO[2.2.1]HEPT-1-YL]METHYL DIHYDROGEN PHOSPHATE\"\n\t\tnucleotides30.put(\"TP1\",1); // 2-(METHYLAMINO)-ETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\t\tnucleotides30.put(\"TPC\",1); // 5'-THIO-2'-DEOXY-CYTOSINE PHOSPHONIC ACID\n\t\tnucleotides30.put(\"TPN\",1); // 2-AMINOETHYLGLYCINE-CARBONYLMETHYLENE-THYMINE\n\n\n\n\t\t// store nucleic acids (C, G, A, T, U, and I), and\n\t\t// the modified versions of nucleic acids (+C, +G, +A, +T, +U, and +I), and\n\t\tnucleotides23  = new HashMap<String,Integer>();\n\t\tString[] names = {\"C\",\"G\",\"A\",\"T\",\"U\",\"I\",\"+C\",\"+G\",\"+A\",\"+T\",\"+U\",\"+I\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tString n = names[i];\n\t\t\tnucleotides23.put(n,1);\n\t\t}\n\n\t\taminoAcids = new HashMap<String, Character>();\n\t\taminoAcids.put(\"GLY\", new Character('G'));\n\t\taminoAcids.put(\"ALA\", new Character('A'));\n\t\taminoAcids.put(\"VAL\", new Character('V'));\n\t\taminoAcids.put(\"LEU\", new Character('L'));\n\t\taminoAcids.put(\"ILE\", new Character('I'));\n\t\taminoAcids.put(\"PHE\", new Character('F'));\n\t\taminoAcids.put(\"TYR\", new Character('Y'));\n\t\taminoAcids.put(\"TRP\", new Character('W'));\n\t\taminoAcids.put(\"PRO\", new Character('P'));\n\t\taminoAcids.put(\"HIS\", new Character('H'));\n\t\taminoAcids.put(\"LYS\", new Character('K'));\n\t\taminoAcids.put(\"ARG\", new Character('R'));\n\t\taminoAcids.put(\"SER\", new Character('S'));\n\t\taminoAcids.put(\"THR\", new Character('T'));\n\t\taminoAcids.put(\"GLU\", new Character('E'));\n\t\taminoAcids.put(\"GLN\", new Character('Q'));\n\t\taminoAcids.put(\"ASP\", new Character('D'));\n\t\taminoAcids.put(\"ASN\", new Character('N'));\n\t\taminoAcids.put(\"CYS\", new Character('C'));\n\t\taminoAcids.put(\"MET\", new Character('M'));\n\t\t//MSE is only found as a molecular replacement for MET\n\t\taminoAcids.put(\"MSE\", new Character('M'));\n\t\t//'non-standard', genetically encoded\n\t\t//http://www.chem.qmul.ac.uk/iubmb/newsletter/1999/item3.html\n\t\t//IUBMB recommended name is 'SEC' but the wwPDB currently use 'CSE'\n\t\t//likewise 'PYL' (IUBMB) and 'PYH' (PDB)\n\t\taminoAcids.put(\"CSE\", new Character('U'));\n\t\taminoAcids.put(\"SEC\", new Character('U'));\n\t\taminoAcids.put(\"PYH\", new Character('O'));\n\t\taminoAcids.put(\"PYL\", new Character('O'));\n\n\t\t//\t\ttry {\n\t\t//\t\t\tAlphabet alpha_prot = ProteinTools.getAlphabet();\n\t\t//\t\t\tthreeLetter = alpha_prot.getTokenization(\"name\");\n\t\t//\t\t\toneLetter  = alpha_prot.getTokenization(\"token\");\n\t\t//\t\t} catch (Exception e) {\n\t\t//\t\t\t// this should not happen.\n\t\t//\t\t\t// only if BioJava has not been built correctly...\n\t\t//\t\t\tlogger.config(e.getMessage());\n\t\t//\t\t\te.printStackTrace() ;\n\t\t//\t\t}\n\n\t}\n\n\n\t/** Count how many number of Atoms are contained within a Structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of Atoms in this Structure\n\t */\n\tpublic static final int getNrAtoms(Structure s){\n\n\t\tint nrAtoms = 0;\n\n\t\tIterator<Group> iter = new GroupIterator(s);\n\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\t\t\tnrAtoms += g.size();\n\t\t}\n\n\t\treturn nrAtoms;\n\t}\n\n\n\t/** Count how many groups are contained within a structure object.\n\t *\n\t * @param s the structure object\n\t * @return the number of groups in the structure\n\t */\n\tpublic static final int getNrGroups(Structure s){\n\t\tint nrGroups = 0;\n\n\t\tList<Chain> chains = s.getChains(0);\n\t\tIterator<Chain> iter = chains.iterator();\n\t\twhile (iter.hasNext()){\n\t\t\tChain c = (Chain) iter.next();\n\t\t\tnrGroups += c.getAtomLength();\n\t\t}\n\t\treturn nrGroups;\n\t}\n\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param s the structure to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Structure s, String[] atomNames){\n\t\tIterator<Group> iter = new GroupIterator(s);\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\t\twhile ( iter.hasNext()){\n\t\t\tGroup g = (Group) iter.next();\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an array of the requested Atoms from the Structure object. Iterates over all groups\n\t * and checks if the requested atoms are in this group, no matter if this is a AminoAcid or Hetatom group.\n\t *\n\t *\n\t * @param c the Chain to get the atoms from\n\t *\n\t * @param atomNames  contains the atom names to be used.\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomArray(Chain c, String[] atomNames){\n\n\t\tList<Group> groups = c.getAtomGroups();\n\n\t\tList<Atom> atoms = new ArrayList<Atom>();\n\n\t\tfor (Group g : groups){\n\n\t\t\t// a temp container for the atoms of this group\n\t\t\tList<Atom> thisGroupAtoms = new ArrayList<Atom>();\n\t\t\t// flag to check if this group contains all the requested atoms.\n\t\t\tboolean thisGroupAllAtoms = true;\n\t\t\tfor ( int i = 0 ; i < atomNames.length; i++){\n\t\t\t\tString atomName = atomNames[i];\n\t\t\t\ttry {\n\t\t\t\t\tAtom a = g.getAtom(atomName);\n\t\t\t\t\tthisGroupAtoms.add(a);\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// this group does not have a required atom, skip it...\n\t\t\t\t\tthisGroupAllAtoms = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( thisGroupAllAtoms){\n\t\t\t\t// add the atoms of this group to the array.\n\t\t\t\tIterator<Atom> aIter = thisGroupAtoms.iterator();\n\t\t\t\twhile(aIter.hasNext()){\n\t\t\t\t\tAtom a = (Atom) aIter.next();\n\t\t\t\t\tatoms.add(a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn (Atom[]) atoms.toArray(new Atom[atoms.size()]);\n\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param c the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static final Atom[] getAtomCAArray(Chain c){\n\t\tString[] atomNames = {\" CA \" };\n\t\treturn getAtomArray(c,atomNames);\n\t}\n\n\t/** Provides an equivalent copy of Atoms in a new array. Clones everything, starting with parent \n\t * groups and chains. The chain will only contain groups that are part of the CA array.\n\t * \n\t * @param ca array of CA atoms\n\t * @return Atom array\n\t */\n\tpublic static final Atom[] cloneCAArray(Atom[] ca) throws StructureException{\n\t\tAtom[] newCA = new Atom[ca.length];\n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getParent();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getName().equals(parentC.getName())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setName(parentC.getName());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup parentN = (Group)parentG.clone();\n\n\t\t\tnewCA[apos] = parentN.getAtom(\" CA \");\n\t\t\tnewChain.addGroup(parentN);\n\t\t}\n\t\treturn newCA;\n\t}\n\n\t/** Clone a set of CA Atoms, but returns the parent groups\n\t *  \n\t * @param ca Atom array\n\t * @return Group array\n\t */\n\tpublic static Group[] cloneGroups(Atom[] ca) {\n\t\tGroup[] newGroup = new Group[ca.length]; \n\n\t\tList<Chain> model = new ArrayList<Chain>();\n\t\tint apos = -1;\n\t\tfor(Atom a: ca){\n\t\t\tapos++;\n\t\t\tGroup parentG = a.getParent();\n\t\t\tChain parentC = parentG.getChain();\n\n\t\t\tChain newChain = null;\n\t\t\tfor ( Chain c : model){\n\t\t\t\tif ( c.getName().equals(parentC.getName())){\n\t\t\t\t\tnewChain = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( newChain == null){\n\t\t\t\tnewChain = new ChainImpl();\n\t\t\t\tnewChain.setName(parentC.getName());\n\t\t\t\tmodel.add(newChain);\n\t\t\t}\n\n\t\t\tGroup ng = (Group)parentG.clone();\n\t\t\tnewGroup[apos] = ng;\n\t\t\tnewChain.addGroup(ng);\n\t\t}\n\t\treturn newGroup;\n\t}\n\n\t/** Returns an Atom array of the CA atoms.\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getAtomCAArray(Structure s){\n\t\tString[] atomNames = {\" CA \"};\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\t/** Returns an Atom array of the MainChain atoms.\n\n\t * @param s the structure object\n\t * @return an Atom[] array\n\t */\n\tpublic static Atom[] getBackboneAtomArray(Structure s){\n\t\tString[] atomNames = backboneAtomNames;\n\t\treturn getAtomArray(s,atomNames);\n\t}\n\n\n\t/** convert three character amino acid codes into single character\n\t *  e.g. convert CYS to C\n\t *  @return a character\n\t *  @param code3 a three character amino acid representation String\n\t *  @throws IllegalSymbolException\n\t */\n\n\tpublic static final Character convert_3code_1code(String code3)\n\tthrows UnknownPdbAminoAcidException {\n\t\t//\t{\n\t\t//\t\tSymbol sym   =  threeLetter.parseToken(code3) ;\n\t\t//\t\tString code1 =  oneLetter.tokenizeSymbol(sym);\n\t\t//\n\t\t//\t\treturn new Character(code1.charAt(0)) ;\n\t\tCharacter code1 = null;\n\t\tcode1 = aminoAcids.get(code3);\n\n\t\tif (code1 == null) {\n\t\t\tthrow new UnknownPdbAminoAcidException(code3 + \" not a standard amino acid\");\n\t\t} else {\n\t\t\treturn code1;\n\t\t}\n\n\t}\n\n\t/** convert a three letter code into single character.\n\t * catches for unusual characters\n\t *\n\t * @param groupCode3 three letter representation\n\t * @return null if group is a nucleotide code\n\t */\n\tpublic static final Character get1LetterCode(String groupCode3){\n\n\t\tCharacter aminoCode1 = null;\n\t\ttry {\n\t\t\t// is it a standard amino acid ?\n\t\t\taminoCode1 = convert_3code_1code(groupCode3);\n\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t// hm groupCode3 is not standard\n\t\t\t// perhaps it is an nucleotide?\n\t\t\tif ( isNucleotide(groupCode3) ) {\n\t\t\t\t//System.out.println(\"nucleotide, aminoCode1:\"+aminoCode1);\n\t\t\t\taminoCode1= null;\n\t\t\t} else {\n\t\t\t\t// does not seem to be so let's assume it is\n\t\t\t\t//  nonstandard aminoacid and label it \"X\"\n\t\t\t\t//logger.warning(\"unknown group name \"+groupCode3 );\n\t\t\t\taminoCode1 = UNKNOWN_GROUP_LABEL;\n\t\t\t}\n\t\t}\n\n\t\treturn aminoCode1;\n\n\t}\n\n\n\t/* Test if the threelettercode of an ATOM entry corresponds to a\n\t * nucleotide or to an aminoacid.\n\t * @param a 3-character code for a group.\n\t *\n\t */\n\tpublic static final boolean isNucleotide(String groupCode3){\n\n\t\tString code = groupCode3.trim();\n\t\tif ( nucleotides30.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nucleotides23.containsKey(code)){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false ;\n\t}\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainId is provided only return a structure containing that Chain ID. \n\t * Converts lower case chain IDs to upper case if structure does not contain a chain with that ID. \n\t * \n\t * @param s\n\t * @param chainId\n\t * @return Structure\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, String chainId) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\n\t\tif ( chainId != null)\n\t\t\tchainId = chainId.trim();\n\n\t\tif ( chainId == null || chainId.equals(\"\")){\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\t\tChain c =  null;\n\t\ttry {\n\t\t\tc = s.getChainByPDB(chainId);\n\t\t} catch (StructureException e){\n\t\t\tSystem.err.println(e.getMessage() + \" trying upper case Chain id...\");\n\t\t\tc = s.getChainByPDB(chainId.toUpperCase());\n\n\t\t}\n\t\tif ( c != null)\n\t\t\tnewS.addChain(c);\n\n\n\t\treturn newS;\n\t}\n\n\n\t/** Reduce a structure to provide a smaller representation . Only takes the first model of the structure. If chainNr >=0 only takes the chain at that position into account.\t * \n\t * @param s\n\t * @param chainNr can be -1 to request all chains of model 0, otherwise will only add chain at this position \n\t * @return Structure object\n\t * @since 3.0\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getReducedStructure(Structure s, int chainNr) throws StructureException{\n\t\t// since we deal here with structure alignments,\n\t\t// only use Model 1...\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\t\tnewS.setSSBonds(s.getSSBonds());\n\t\tnewS.setDBRefs(s.getDBRefs());\n\t\tif ( chainNr < 0 ) {\n\n\t\t\t// only get model 0\n\t\t\tList<Chain> model0 = s.getModel(0);\n\t\t\tfor (Chain c : model0){\n\t\t\t\tnewS.addChain(c);\n\t\t\t}\n\t\t\treturn newS;\n\n\t\t}\n\n\n\t\tChain c =  null;\n\n\t\tc = s.getChain(chainNr);\n\n\t\tnewS.addChain(c);\n\n\n\t\treturn newS;\n\t}\n\n\t/** In addition to the functionality provided by getReducedStructure also provides a way to specify sub-regions of a structure with the following \n\t * specification:\n\t *\n\t * If range is null or \"\" returns the whole structure / chain.\n\t * \n\t * range can be surrounded by ( and ). (but will be removed).\n\t * ranges are specified as\n\t * PDBresnum1 : PDBresnum2\n\t * \n\t *  a list of ranges is separated by ,\n\t *  \n\t *  Example\n\t *  4GCR(A:1-83)\n\t *  1CDG(A:407-495,A:582-686)\n\t *  \n\t * \n\t * \n\t * @param s\n\t * @param ranges\n\t * @return a structure object\n\t */\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static final Structure getSubRanges(Structure s, String ranges ) \n\tthrows StructureException\n\t{\n\t\tStructure struc = getReducedStructure(s, null);\n\n\t\tif ( ranges == null || ranges.equals(\"\"))\n\t\t\tthrow new IllegalArgumentException(\"ranges can't be null or empty\");\n\n\t\tranges = ranges.trim();\n\n\t\tif ( ranges.startsWith(\"(\"))\n\t\t\tranges = ranges.substring(1);\n\t\tif ( ranges.endsWith(\")\")) {\n\t\t\tranges = ranges.substring(0,ranges.length()-1);\n\t\t}\n\n\t\tStructure newS = new StructureImpl();\n\t\tnewS.setHeader(s.getHeader());\n\t\tnewS.setPDBCode(s.getPDBCode());\n\t\tnewS.setPDBHeader(s.getPDBHeader());\n\n\t\tString[] rangS =ranges.split(\",\");\n\n\n\t\tString prevChainId = null;\n\n\t\tfor ( String r: rangS){\n\t\t\tString[] coords = r.split(\":\");\n\t\t\tif ( coords.length > 2){\n\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n\t\t\t}\n\n\n\t\t\tChain chain = struc.getChainByPDB(coords[0]);\n\t\t\tGroup[] groups;\n\t\t\tif  ( coords.length > 1){\n\t\t\t\t// if length 1, only provided a Chain id...\n\n\n\t\t\t\tString[] pdbRanges = coords[1].split(\"-\");\n\t\t\t\tif ( pdbRanges.length!= 2)\n\t\t\t\t\tthrow new StructureException(\"wrong range specification, should be provided as chainID:pdbResnum1=pdbRensum2\");\n\t\t\t\tString pdbresnumStart = pdbRanges[0].trim();\n\t\t\t\tString pdbresnumEnd   = pdbRanges[1].trim();\n\n\t\t\t\tgroups = chain.getGroupsByPDB(pdbresnumStart, pdbresnumEnd);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t// only chain ID provided ... add the whole chain...\n\t\t\t\t groups = chain.getAtomGroups().toArray(new Group[chain.getAtomGroups().size()]);\n\t\t\t}\n\t\t\t\n\t\t\tChain c = null;\n\t\t\tif ( prevChainId == null) {\n\t\t\t\t// first chain...\n\t\t\t\tc = new ChainImpl();\n\t\t\t\tc.setName(chain.getName());\n\t\t\t\tnewS.addChain(c);\n\t\t\t} else if ( prevChainId.equals(chain.getName())) {\n\t\t\t\tc = newS.getChainByPDB(prevChainId);\n\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tc = newS.getChainByPDB(chain.getName());\n\t\t\t\t} catch (StructureException e){\n\t\t\t\t\t// chain not in structure yet...\n\t\t\t\t\tc = new ChainImpl();\n\t\t\t\t\tc.setName(chain.getName());\n\t\t\t\t\tnewS.addChain(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add the groups to the chain:\n\t\t\tfor ( Group g: groups) {\n\t\t\t\tc.addGroup(g);\n\t\t\t}\n\n\t\t\tprevChainId = c.getName();\n\t\t}\n\n\n\t\treturn newS;\n\t}\n\n\tpublic static final String convertAtomsToSeq(Atom[] atoms) {\n\n\t\tStringBuffer buf = new StringBuffer();\n\t\tGroup prevGroup  = null;\n\t\tfor (Atom a : atoms){\n\t\t\tGroup g = a.getParent();\n\t\t\tif ( prevGroup != null) {\n\t\t\t\tif ( prevGroup.equals(g)) {\n\t\t\t\t\t// we add each group only once.\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString code3 = g.getPDBName();\n\t\t\ttry {\n\t\t\t\tbuf.append(convert_3code_1code(code3) );\n\t\t\t} catch (UnknownPdbAminoAcidException e){\n\t\t\t\tbuf.append('X');\n\t\t\t}\n\t\t\tprevGroup = g;\n\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\t/** get a PDB residue number object for this group\n\t * \n\t * @param g Group object\n\t * @return a ResidueNumber object\n\t * @deprecated replaced by  Group.getResidueNumber()\n\t */\n\tpublic static final ResidueNumber getPDBResidueNumber(Group g){\n\n\t\treturn g.getResidueNumber();\n\n\t}\n\t\n\t/** Get a group represented by a ResidueNumber.\n\t * \n\t * @param struc a {@link Structure}\n\t * @param pdbResNum a {@link ResidueNumber}\n\t * @return a group in the structure that is represented by the pdbResNum. \n\t * @throws StructureException if the group cannot be found.\n\t */\n\tpublic static final Group getGroupByPDBResidueNumber(Structure struc, \n\t\t\tResidueNumber pdbResNum) throws StructureException {\n\t\tif (struc == null || pdbResNum==null) {\n\t\t\tthrow new IllegalArgumentException(\"Null argument(s).\");\n\t\t}\n\t\t\n\t\tChain chain = struc.findChain(pdbResNum.getChainId());\n\t\t\n\t\tString numIns = \"\" + pdbResNum.getSeqNum();\n\t\tif (pdbResNum.getInsCode() != null) {\n\t\t\tnumIns += pdbResNum.getInsCode();\n\t\t}\n\t\t\n\t\treturn chain.getGroupByPDB(numIns);\n\t}\n\n}\n","originTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava.bio.structure.io.PDBFileParser;\n\nimport junit.framework.TestCase;\n\npublic class StructureToolsTest extends TestCase {\n\n    Structure structure;\n\n    protected void setUp()\n    {\n        InputStream inStream = this.getClass().getResourceAsStream(\"/5pti.pdb\");\n        assertNotNull(inStream);\n\n\n        PDBFileParser pdbpars = new PDBFileParser();\n        FileParsingParameters params = new FileParsingParameters();\n        params.setAlignSeqRes(false);\n        pdbpars.setFileParsingParameters(params);\n        \n        try {\n            structure = pdbpars.parsePDBFile(inStream) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        assertNotNull(structure);\n\n        assertEquals(\"structure does not contain one chain \", 1 ,structure.size());\n    }\n\n\n    public void testGetCAAtoms(){\n        Atom[] cas = StructureTools.getAtomCAArray(structure);\n        assertEquals(\"did not find the expected number of Atoms (58), but got \" + cas.length,58,cas.length);\n    }\n\n    public void testGetNrAtoms(){\n        int length = StructureTools.getNrAtoms(structure);\n        assertEquals(\"did not find the expected number of Atoms (1104), but got \" + length,1104,length);\n\n\n    }\n\n\n\n}\n","changedTest":"/*\n *                  BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on Jun 8, 2007\n *\n */\npackage org.biojava.bio.structure;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.biojava.bio.structure.io.FileParsingParameters;\nimport org.biojava.bio.structure.io.PDBFileParser;\n\nimport junit.framework.TestCase;\n\npublic class StructureToolsTest extends TestCase {\n\n    Structure structure;\n\n    protected void setUp()\n    {\n        InputStream inStream = this.getClass().getResourceAsStream(\"/5pti.pdb\");\n        assertNotNull(inStream);\n\n\n        PDBFileParser pdbpars = new PDBFileParser();\n        FileParsingParameters params = new FileParsingParameters();\n        params.setAlignSeqRes(false);\n        pdbpars.setFileParsingParameters(params);\n        \n        try {\n            structure = pdbpars.parsePDBFile(inStream) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        assertNotNull(structure);\n\n        assertEquals(\"structure does not contain one chain \", 1 ,structure.size());\n    }\n\n\n    public void testGetCAAtoms(){\n        Atom[] cas = StructureTools.getAtomCAArray(structure);\n        assertEquals(\"did not find the expected number of Atoms (58), but got \" + cas.length,58,cas.length);\n    }\n\n    public void testGetNrAtoms(){\n        int length = StructureTools.getNrAtoms(structure);\n        assertEquals(\"did not find the expected number of Atoms (1070), but got \" + length,1070,length);\n\n\n    }\n\n\n\n}\n","commitMessage":"major API update. Renaming getParent methods and better handling of residue numbers, insCodes and altLocs.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8278 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"updating new Atom nr. to match results after altLocs are being parsed.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8280 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}