{"repository":"biojava","prod_path":"biojava3-alignment/src/main/java/org/biojava3/alignment/SimpleSubstitutionMatrix.java","test_path":"biojava3-alignment/src/test/java/org/biojava3/alignment/SimpleSubstitutionMatrixTest.java","prod_time":"2014-11-20 08:59:44","test_time":"2014-11-20 08:59:44","type":"EDIT","proType":"EDIT","add_annotation_line":2,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":5,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":1,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":5,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"faa29c896922ed6f9bd16b17a62e0b3f964805da","test_commitID":"faa29c896922ed6f9bd16b17a62e0b3f964805da","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 9, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\n\n/**\n * Implements a data structure which holds the score (penalty or bonus) given during alignment for the exchange of one\n * {@link Compound} in a sequence for another.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n * @param <C> each element of the matrix corresponds to a pair of {@link Compound}s of type C\n */\npublic class SimpleSubstitutionMatrix<C extends Compound> implements SubstitutionMatrix<C> {\n\n    private static final String comment = \"#\";\n\n    private CompoundSet<C> compoundSet;\n    private String description, name;\n    private short[][] matrix;\n    private short max, min;\n    private List<C> rows, cols;\n\n    /**\n     * Creates a substitution matrix using the defaults (BLOSUM 62).\n     *\n     * @throws ClassCastException if type parameter C is not {@link AminoAcidCompound}\n     */\n    @SuppressWarnings(\"unchecked\") // TODO proper generic type checking instead of possible ClassCastException\n    public SimpleSubstitutionMatrix() {\n        this((CompoundSet<C>) AminoAcidCompoundSet.getAminoAcidCompoundSet(), new InputStreamReader(\n                SimpleSubstitutionMatrix.class.getResourceAsStream(\"/blosum62.txt\")), \"blosum62\");\n    }\n\n    /**\n     * Creates a substitution matrix by reading in a file.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param fileInput file parsed for a substitution matrix\n     * @throws FileNotFoundException if fileInput parameter cannot be read\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, File fileInput) throws FileNotFoundException {\n        this(compoundSet, new BufferedReader(new FileReader(fileInput)), fileInput.getName());\n    }\n\n    /**\n     * Creates a substitution matrix by parsing some input.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param input input parsed for a substitution matrix\n     * @param name the name (short description) of this matrix\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, Reader input, String name) {\n        this(compoundSet, new Scanner(input), name);\n    }\n\n    /**\n     * Creates a substitution matrix by parsing a String.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param matrixInput String parsed for a substitution matrix\n     * @param name the name (short description) of this matrix\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, String matrixInput, String name) {\n        this(compoundSet, new Scanner(matrixInput), name);\n    }\n\n    /**\n     * Creates an identity substitution matrix from match and replace values.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param match matrix value used for equivalent {@link Compound}s\n     * @param replace matrix value used for differing {@link Compound}s\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, short match, short replace) {\n        this.compoundSet = compoundSet;\n        description = \"Identity matrix. All replaces and all matches are treated equally.\";\n        name = \"IDENTITY_\" + match + \"_\" + replace;\n        max = (match > replace) ? match : replace;\n        min = (match < replace) ? match : replace;\n        rows = cols = compoundSet.getAllCompounds();\n        matrix = new short[rows.size()][cols.size()];\n        for (int r = 0; r < rows.size(); r++) {\n            for (int c = 0; c < cols.size(); c++) {\n                try {\n                    matrix[r][c] = (compoundSet.compoundsEquivalent(rows.get(r), cols.get(c))) ? match : replace;\n                } catch (UnsupportedOperationException e) {\n                    matrix[r][c] = (r == c) ? match : replace;\n                }\n            }\n        }\n    }\n\n    // helper constructor that creates a substitution matrix by parsing input\n    private SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, Scanner input, String name) {\n        this.compoundSet = compoundSet;\n        this.name = name;\n        max = Short.MIN_VALUE;\n        min = Short.MAX_VALUE;\n        rows = new ArrayList<C>();\n        cols = new ArrayList<C>();\n        StringBuilder descriptionIn = new StringBuilder();\n        List<short[]> matrixIn = new ArrayList<short[]>();\n        while(input.hasNextLine()) {\n            String line = input.nextLine();\n            if (line.startsWith(comment)) {\n                descriptionIn.append(String.format(\"%s%n\", line));\n            } else if (!line.trim().isEmpty()) {\n                StringTokenizer st = new StringTokenizer(line);\n                if (cols.isEmpty()) {\n                    while (st.hasMoreTokens()) {\n                        cols.add(compoundSet.getCompoundForString(st.nextToken()));\n                    }\n                } else {\n                    rows.add(compoundSet.getCompoundForString(st.nextToken()));\n                    short[] row = new short[cols.size()];\n                    for (int i = 0; i < row.length && st.hasMoreTokens(); i++) {\n                        row[i] = Short.parseShort(st.nextToken());\n                        max = (max > row[i]) ? max : row[i];\n                        min = (min < row[i]) ? min : row[i];\n                    }\n                    matrixIn.add(row);\n                }\n            }\n        }\n        input.close();\n        description = descriptionIn.toString();\n        matrix = new short[rows.size()][cols.size()];\n        for (int i = 0; i < rows.size(); i++) {\n            matrix[i] = matrixIn.get(i);\n        }\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return compoundSet;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public short[][] getMatrix() {\n        short[][] copy = new short[matrix.length][matrix[0].length];\n        for (int i = 0; i < copy.length; i++) {\n            copy[i] = Arrays.copyOf(matrix[i], matrix[i].length);\n        }\n        return copy;\n    }\n\n    @Override\n    public String getMatrixAsString() {\n        StringBuilder s = new StringBuilder();\n        int lengthCompound = compoundSet.getMaxSingleCompoundStringLength(), lengthRest =\n                Math.max(Math.max(Short.toString(min).length(), Short.toString(max).length()), lengthCompound) + 1;\n        String padCompound = \"%\" + Integer.toString(lengthCompound) + \"s\",\n                padRest = \"%\" + Integer.toString(lengthRest);\n        for (int i = 0; i < lengthCompound; i++) {\n            s.append(\" \");\n        }\n        for (C col : cols) {\n            s.append(String.format(padRest + \"s\", compoundSet.getStringForCompound(col)));\n        }\n        s.append(String.format(\"%n\"));\n        for (C row : rows) {\n            s.append(String.format(padCompound, compoundSet.getStringForCompound(row)));\n            for (C col : cols) {\n                s.append(String.format(padRest + \"d\", getValue(row, col)));\n            }\n            s.append(String.format(\"%n\"));\n        }\n        return s.toString();\n    }\n\n    @Override\n    public short getMaxValue() {\n        return max;\n    }\n\n    @Override\n    public short getMinValue() {\n        return min;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n    /**\n     * Returns the index of the first occurrence of the specified element in the list.\n     * If the list does not contain the given compound, the index of the first occurrence\n     * of the element according to case-insensitive equality.\n     * If no such elements exist, -1 is returned.\n     * @param list list of compounds to search\n     * @param compound compound to search for\n     * @return Returns the index of the first match to the specified element in this list, or -1 if there is no such index.\n     */\n    private static <C extends Compound> int getIndexOfCompound(List<C> list, C compound) {\n    \tint index = list.indexOf(compound);\n    \tif (index == -1) {\n\t    \tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tif (compound.equalsIgnoreCase(list.get(i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \treturn index;\n\t}\n    @Override\n    public short getValue(C from, C to) {\n        int row = getIndexOfCompound(rows, from), col = getIndexOfCompound(cols, to);\n        if (row == -1 || col == -1) {\n            row = getIndexOfCompound(cols, from);\n            col = getIndexOfCompound(rows, to);\n            if (row == -1 || col == -1) {\n                return min;\n            }\n        }\n        return matrix[row][col];\n    }\n\n    @Override\n    public SubstitutionMatrix<C> normalizeMatrix(short scale) {\n        // TODO SubstitutionMatrix<C> normalizeMatrix(short)\n        return null;\n    }\n\n    @Override\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    @Override\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Returns in a format similar to the standard NCBI files.\n     */\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(description, \"\\n\\r\");\n        while (st.hasMoreTokens()) {\n            String line = st.nextToken();\n            if (!line.startsWith(comment)) {\n                s.append(comment);\n            }\n            s.append(String.format(\"%s%n\", line));\n        }\n        s.append(getMatrixAsString());\n        return s.toString();\n    }\n\n\tpublic Map<C, Short> getRow(C row) {\n\t\tint rowIndex = rows.indexOf(row);\n\t\tMap<C, Short> map = new HashMap<C, Short>();\n\t\tfor (int colIndex = 0; colIndex < matrix[rowIndex].length; colIndex++) {\n\t\t\tmap.put(cols.get(colIndex), matrix[rowIndex][colIndex]);\n\t\t}\n\t\treturn map;\n\t}\n\n\tpublic Map<C, Short> getColumn(C column) {\n\t\tint colIndex = cols.indexOf(column);\n\t\tMap<C, Short> map = new HashMap<C, Short>();\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tmap.put(rows.get(i), matrix[i][colIndex]);\n\t\t}\n\t\treturn map;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 9, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.CompoundSet;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n/**\n * Implements a data structure which holds the score (penalty or bonus) given during alignment for the exchange of one\n * {@link Compound} in a sequence for another.\n *\n * @author Mark Chapman\n * @author Daniel Cameron\n * @param <C> each element of the matrix corresponds to a pair of {@link Compound}s of type C\n */\npublic class SimpleSubstitutionMatrix<C extends Compound> implements SubstitutionMatrix<C> {\n\n    private static final String comment = \"#\";\n\n    private CompoundSet<C> compoundSet;\n    private String description, name;\n    private short[][] matrix;\n    private short max, min;\n    private List<C> rows, cols;\n\n    public static SubstitutionMatrix<AminoAcidCompound> getBlosum62() {\n        return new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(), new InputStreamReader(\n                SimpleSubstitutionMatrix.class.getResourceAsStream(\"/blosum62.txt\")), \"blosum62\");\n    }\n\n    /**\n     * Creates a substitution matrix using the defaults (BLOSUM 62).\n     *\n     * @throws ClassCastException if type parameter C is not {@link AminoAcidCompound}\n     * @deprecated Use {@link #getBlosum62} instead.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Deprecated\n    public SimpleSubstitutionMatrix() {\n        this((CompoundSet<C>) AminoAcidCompoundSet.getAminoAcidCompoundSet(), new InputStreamReader(\n                SimpleSubstitutionMatrix.class.getResourceAsStream(\"/blosum62.txt\")), \"blosum62\");\n    }\n\n    /**\n     * Creates a substitution matrix by reading in a file.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param fileInput file parsed for a substitution matrix\n     * @throws FileNotFoundException if fileInput parameter cannot be read\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, File fileInput) throws FileNotFoundException {\n        this(compoundSet, new BufferedReader(new FileReader(fileInput)), fileInput.getName());\n    }\n\n    /**\n     * Creates a substitution matrix by parsing some input.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param input input parsed for a substitution matrix\n     * @param name the name (short description) of this matrix\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, Reader input, String name) {\n        this(compoundSet, new Scanner(input), name);\n    }\n\n    /**\n     * Creates a substitution matrix by parsing a String.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param matrixInput String parsed for a substitution matrix\n     * @param name the name (short description) of this matrix\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, String matrixInput, String name) {\n        this(compoundSet, new Scanner(matrixInput), name);\n    }\n\n    /**\n     * Creates an identity substitution matrix from match and replace values.\n     *\n     * @param compoundSet the {@link CompoundSet} on which the matrix is defined\n     * @param match matrix value used for equivalent {@link Compound}s\n     * @param replace matrix value used for differing {@link Compound}s\n     */\n    public SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, short match, short replace) {\n        this.compoundSet = compoundSet;\n        description = \"Identity matrix. All replaces and all matches are treated equally.\";\n        name = \"IDENTITY_\" + match + \"_\" + replace;\n        max = (match > replace) ? match : replace;\n        min = (match < replace) ? match : replace;\n        rows = cols = compoundSet.getAllCompounds();\n        matrix = new short[rows.size()][cols.size()];\n        for (int r = 0; r < rows.size(); r++) {\n            for (int c = 0; c < cols.size(); c++) {\n                try {\n                    matrix[r][c] = (compoundSet.compoundsEquivalent(rows.get(r), cols.get(c))) ? match : replace;\n                } catch (UnsupportedOperationException e) {\n                    matrix[r][c] = (r == c) ? match : replace;\n                }\n            }\n        }\n    }\n\n    // helper constructor that creates a substitution matrix by parsing input\n    private SimpleSubstitutionMatrix(CompoundSet<C> compoundSet, Scanner input, String name) {\n        this.compoundSet = compoundSet;\n        this.name = name;\n        max = Short.MIN_VALUE;\n        min = Short.MAX_VALUE;\n        rows = new ArrayList<C>();\n        cols = new ArrayList<C>();\n        StringBuilder descriptionIn = new StringBuilder();\n        List<short[]> matrixIn = new ArrayList<short[]>();\n        while(input.hasNextLine()) {\n            String line = input.nextLine();\n            if (line.startsWith(comment)) {\n                descriptionIn.append(String.format(\"%s%n\", line));\n            } else if (!line.trim().isEmpty()) {\n                StringTokenizer st = new StringTokenizer(line);\n                if (cols.isEmpty()) {\n                    while (st.hasMoreTokens()) {\n                        cols.add(compoundSet.getCompoundForString(st.nextToken()));\n                    }\n                } else {\n                    rows.add(compoundSet.getCompoundForString(st.nextToken()));\n                    short[] row = new short[cols.size()];\n                    for (int i = 0; i < row.length && st.hasMoreTokens(); i++) {\n                        row[i] = Short.parseShort(st.nextToken());\n                        max = (max > row[i]) ? max : row[i];\n                        min = (min < row[i]) ? min : row[i];\n                    }\n                    matrixIn.add(row);\n                }\n            }\n        }\n        input.close();\n        description = descriptionIn.toString();\n        matrix = new short[rows.size()][cols.size()];\n        for (int i = 0; i < rows.size(); i++) {\n            matrix[i] = matrixIn.get(i);\n        }\n    }\n\n    @Override\n    public CompoundSet<C> getCompoundSet() {\n        return compoundSet;\n    }\n\n    @Override\n    public String getDescription() {\n        return description;\n    }\n\n    @Override\n    public short[][] getMatrix() {\n        short[][] copy = new short[matrix.length][matrix[0].length];\n        for (int i = 0; i < copy.length; i++) {\n            copy[i] = Arrays.copyOf(matrix[i], matrix[i].length);\n        }\n        return copy;\n    }\n\n    @Override\n    public String getMatrixAsString() {\n        StringBuilder s = new StringBuilder();\n        int lengthCompound = compoundSet.getMaxSingleCompoundStringLength(), lengthRest =\n                Math.max(Math.max(Short.toString(min).length(), Short.toString(max).length()), lengthCompound) + 1;\n        String padCompound = \"%\" + Integer.toString(lengthCompound) + \"s\",\n                padRest = \"%\" + Integer.toString(lengthRest);\n        for (int i = 0; i < lengthCompound; i++) {\n            s.append(\" \");\n        }\n        for (C col : cols) {\n            s.append(String.format(padRest + \"s\", compoundSet.getStringForCompound(col)));\n        }\n        s.append(String.format(\"%n\"));\n        for (C row : rows) {\n            s.append(String.format(padCompound, compoundSet.getStringForCompound(row)));\n            for (C col : cols) {\n                s.append(String.format(padRest + \"d\", getValue(row, col)));\n            }\n            s.append(String.format(\"%n\"));\n        }\n        return s.toString();\n    }\n\n    @Override\n    public short getMaxValue() {\n        return max;\n    }\n\n    @Override\n    public short getMinValue() {\n        return min;\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n    /**\n     * Returns the index of the first occurrence of the specified element in the list.\n     * If the list does not contain the given compound, the index of the first occurrence\n     * of the element according to case-insensitive equality.\n     * If no such elements exist, -1 is returned.\n     * @param list list of compounds to search\n     * @param compound compound to search for\n     * @return Returns the index of the first match to the specified element in this list, or -1 if there is no such index.\n     */\n    private static <C extends Compound> int getIndexOfCompound(List<C> list, C compound) {\n    \tint index = list.indexOf(compound);\n    \tif (index == -1) {\n\t    \tfor (int i = 0; i < list.size(); i++) {\n\t\t\t\tif (compound.equalsIgnoreCase(list.get(i))) {\n\t\t\t\t\tindex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n    \t}\n    \treturn index;\n\t}\n    @Override\n    public short getValue(C from, C to) {\n        int row = getIndexOfCompound(rows, from), col = getIndexOfCompound(cols, to);\n        if (row == -1 || col == -1) {\n            row = getIndexOfCompound(cols, from);\n            col = getIndexOfCompound(rows, to);\n            if (row == -1 || col == -1) {\n                return min;\n            }\n        }\n        return matrix[row][col];\n    }\n\n    @Override\n    public SubstitutionMatrix<C> normalizeMatrix(short scale) {\n        // TODO SubstitutionMatrix<C> normalizeMatrix(short)\n        return null;\n    }\n\n    @Override\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    @Override\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    /**\n     * Returns in a format similar to the standard NCBI files.\n     */\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        StringTokenizer st = new StringTokenizer(description, \"\\n\\r\");\n        while (st.hasMoreTokens()) {\n            String line = st.nextToken();\n            if (!line.startsWith(comment)) {\n                s.append(comment);\n            }\n            s.append(String.format(\"%s%n\", line));\n        }\n        s.append(getMatrixAsString());\n        return s.toString();\n    }\n\n\tpublic Map<C, Short> getRow(C row) {\n\t\tint rowIndex = rows.indexOf(row);\n\t\tMap<C, Short> map = new HashMap<C, Short>();\n\t\tfor (int colIndex = 0; colIndex < matrix[rowIndex].length; colIndex++) {\n\t\t\tmap.put(cols.get(colIndex), matrix[rowIndex][colIndex]);\n\t\t}\n\t\treturn map;\n\t}\n\n\tpublic Map<C, Short> getColumn(C column) {\n\t\tint colIndex = cols.indexOf(column);\n\t\tMap<C, Short> map = new HashMap<C, Short>();\n\t\tfor (int i = 0; i < matrix.length; i++) {\n\t\t\tmap.put(rows.get(i), matrix[i][colIndex]);\n\t\t}\n\t\treturn map;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 10, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\npublic class SimpleSubstitutionMatrixTest {\n\n    @Test(expected=FileNotFoundException.class)\n    public void testSimpleSubstitutionMatrixNotFound() throws FileNotFoundException {\n        new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(),\n                new File(\"blosum63.txt\"));\n    }\n\n    @Ignore // TODO why does this not cause ClassCastException? loses typing at runtime?\n    @Test(expected=ClassCastException.class)\n    public void testSimpleSubstitutionMatrixWrong() {\n        new SimpleSubstitutionMatrix<NucleotideCompound>();\n    }\n\n    @Test()\n    public void testSimpleSubstitutionMatrix() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(matrix.getName(), \"blosum62\");\n        assertEquals(matrix.getMaxValue(), 11);\n        assertEquals(matrix.getMinValue(), -4);\n    }\n\n    @Test\n    public void testSimpleSubstitutionMatrixCompoundSetOfCStringString() {\n        DNACompoundSet dnacs = DNACompoundSet.getDNACompoundSet();\n        SubstitutionMatrix<NucleotideCompound> dnaTest = new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,\n                \"# Test\\nA C G T\\nA 5 0 0 0\\nC 0 5 0 0\\nG 0 0 5 0\\nT 0 0 0 1\\n\", \"DNA Test\");\n        short[][] matrix = dnaTest.getMatrix();\n        assertEquals(matrix[1][1], 5);\n        assertEquals(matrix[3][3], 1);\n        assertEquals(matrix[3][1], 0);\n        assertEquals(dnaTest.getMatrixAsString().substring(2,9), \"A C G T\");\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"G\"), dnacs.getCompoundForString(\"G\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"A\"), dnacs.getCompoundForString(\"G\")), 0);\n    }\n\n    @Test\n    public void testSimpleSubstitutionMatrixCompoundSetOfCShortShort() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(\n                AminoAcidCompoundSet.getAminoAcidCompoundSet(), (short) 5, (short) 1);\n        assertEquals(matrix.getName(), \"IDENTITY_5_1\");\n    }\n\n    @Test\n    public void testSetDescription() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getDescription().substring(0, 2), \"# \");\n        matrix.setDescription(\"blah\");\n        assertEquals(matrix.getDescription().substring(0, 2), \"bl\");\n    }\n\n    @Test\n    public void testSetName() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getName(), \"blosum62\");\n        matrix.setName(\"blah\");\n        assertEquals(matrix.getName(), \"blah\");\n    }\n\n    @Test\n    public void testToString() {\n        SubstitutionMatrix<NucleotideCompound> matrix = new SimpleSubstitutionMatrix<NucleotideCompound>(\n                DNACompoundSet.getDNACompoundSet(),\n                \"# Test\\nA C  G T\\nA 5  0 0 0\\nC 0 5 0 0 \\nG 0 0 5 0\\n    T 0     0 0 1\\n\", \"DNAtest\");\n        assertEquals(matrix.toString().substring(0,6), \"# Test\");\n        assertEquals(matrix.toString(),\n                String.format(\"# Test%n  A C G T%nA 5 0 0 0%nC 0 5 0 0%nG 0 0 5 0%nT 0 0 0 1%n\"));\n    }\n    /**\n     * @author Daniel Cameron\n     */\n    @Test\n    public void testCaseEquivalence() {\n    \tDNACompoundSet dnacs = DNACompoundSet.getDNACompoundSet();\n        SubstitutionMatrix<NucleotideCompound> dnaTest = new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,\n                \"# Test\\nA C G T\\nA 5 0 0 0\\nC 0 5 0 0\\nG 0 0 5 0\\nT 0 0 0 1\\n\", \"DNA Test\");\n        @SuppressWarnings(\"unused\")\n\t\tshort[][] matrix = dnaTest.getMatrix();\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"G\"), dnacs.getCompoundForString(\"g\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"A\"), dnacs.getCompoundForString(\"g\")), 0);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"G\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"A\")), 0);\n    }\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on June 10, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava3.alignment;\n\nimport org.biojava3.alignment.template.SubstitutionMatrix;\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.DNASequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.compound.DNACompoundSet;\nimport org.biojava3.core.sequence.compound.NucleotideCompound;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class SimpleSubstitutionMatrixTest {\n\n    @Test(expected=FileNotFoundException.class)\n    public void testSimpleSubstitutionMatrixNotFound() throws FileNotFoundException {\n        new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(),\n                new File(\"blosum63.txt\"));\n    }\n\n    @Test\n    public void test() throws CompoundNotFoundException {\n        NucleotideCompound A = new DNASequence(\"A\").getCompoundAt(1);\n        NucleotideCompound a = new DNASequence(\"a\").getCompoundAt(1);\n        NucleotideCompound c = new DNASequence(\"c\").getCompoundAt(1);\n        SubstitutionMatrix<NucleotideCompound> matrix = new SimpleSubstitutionMatrix<NucleotideCompound>(DNACompoundSet.getDNACompoundSet(), (short)1, (short)0);\n        assertEquals(1, (matrix.getValue(A, A)));\n        assertEquals(1, (matrix.getValue(a, a)));\n        assertEquals(1, (matrix.getValue(A, a)));\n        assertEquals(0, (matrix.getValue(a, c)));\n    }\n\n    @Test()\n    public void testSimpleSubstitutionMatrix() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getCompoundSet(), AminoAcidCompoundSet.getAminoAcidCompoundSet());\n        assertEquals(matrix.getName(), \"blosum62\");\n        assertEquals(matrix.getMaxValue(), 11);\n        assertEquals(matrix.getMinValue(), -4);\n    }\n\n    @Test\n    public void testSimpleSubstitutionMatrixCompoundSetOfCStringString() {\n        DNACompoundSet dnacs = DNACompoundSet.getDNACompoundSet();\n        SubstitutionMatrix<NucleotideCompound> dnaTest = new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,\n                \"# Test\\nA C G T\\nA 5 0 0 0\\nC 0 5 0 0\\nG 0 0 5 0\\nT 0 0 0 1\\n\", \"DNA Test\");\n        short[][] matrix = dnaTest.getMatrix();\n        assertEquals(matrix[1][1], 5);\n        assertEquals(matrix[3][3], 1);\n        assertEquals(matrix[3][1], 0);\n        assertEquals(dnaTest.getMatrixAsString().substring(2,9), \"A C G T\");\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"G\"), dnacs.getCompoundForString(\"G\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"A\"), dnacs.getCompoundForString(\"G\")), 0);\n    }\n\n    @Test\n    public void testSimpleSubstitutionMatrixCompoundSetOfCShortShort() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(\n                AminoAcidCompoundSet.getAminoAcidCompoundSet(), (short) 5, (short) 1);\n        assertEquals(matrix.getName(), \"IDENTITY_5_1\");\n    }\n\n    @Test\n    public void testSetDescription() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getDescription().substring(0, 2), \"# \");\n        matrix.setDescription(\"blah\");\n        assertEquals(matrix.getDescription().substring(0, 2), \"bl\");\n    }\n\n    @Test\n    public void testSetName() {\n        SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>();\n        assertEquals(matrix.getName(), \"blosum62\");\n        matrix.setName(\"blah\");\n        assertEquals(matrix.getName(), \"blah\");\n    }\n\n    @Test\n    public void testToString() {\n        SubstitutionMatrix<NucleotideCompound> matrix = new SimpleSubstitutionMatrix<NucleotideCompound>(\n                DNACompoundSet.getDNACompoundSet(),\n                \"# Test\\nA C  G T\\nA 5  0 0 0\\nC 0 5 0 0 \\nG 0 0 5 0\\n    T 0     0 0 1\\n\", \"DNAtest\");\n        assertEquals(matrix.toString().substring(0,6), \"# Test\");\n        assertEquals(matrix.toString(),\n                String.format(\"# Test%n  A C G T%nA 5 0 0 0%nC 0 5 0 0%nG 0 0 5 0%nT 0 0 0 1%n\"));\n    }\n    /*\n     * Author: Daniel Cameron\n     */\n    @Test\n    public void testCaseEquivalence() {\n    \tDNACompoundSet dnacs = DNACompoundSet.getDNACompoundSet();\n        SubstitutionMatrix<NucleotideCompound> dnaTest = new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs,\n                \"# Test\\nA C G T\\nA 5 0 0 0\\nC 0 5 0 0\\nG 0 0 5 0\\nT 0 0 0 1\\n\", \"DNA Test\");\n        @SuppressWarnings(\"unused\")\n\t\tshort[][] matrix = dnaTest.getMatrix();\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"G\"), dnacs.getCompoundForString(\"g\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"A\"), dnacs.getCompoundForString(\"g\")), 0);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"G\")), 5);\n        assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"A\")), 0);\n    }\n\n}\n","commitMessage":"Fixed this issue:\n        NucleotideCompound A = new DNASequence(\"A\").getCompoundAt(1);\n        NucleotideCompound a = new DNASequence(\"a\").getCompoundAt(1);\n        SubstitutionMatrix<NucleotideCompound> matrix = new SimpleSubstitutionMatrix<>(DNACompoundSet.getDNACompoundSet(), (short)1, (short)0);\n        System.out.println(matrix.getValue(A, a)); // prints 1\n        System.out.println(matrix.getValue(a, A)); // prints 1\n        System.out.println(matrix.getValue(a, a)); // prints 0!!!\n        System.out.println(matrix.getValue(A, A)); // prints 0!!!\n The simple solution: compoundsEquivalent should always return true if the two are equal.\n Added a test for this.\n\n Also deprecated the no-args constructor SimpleSubstitutionMatrix() in favor of a static factory method getBlosum62(). The former was dangerous, since the generic type couldn't be checked. Plus, we should be explicit about what it is, since it only applies to amino acid sequences.\n","test_commitMessage":"Fixed this issue:\n        NucleotideCompound A = new DNASequence(\"A\").getCompoundAt(1);\n        NucleotideCompound a = new DNASequence(\"a\").getCompoundAt(1);\n        SubstitutionMatrix<NucleotideCompound> matrix = new SimpleSubstitutionMatrix<>(DNACompoundSet.getDNACompoundSet(), (short)1, (short)0);\n        System.out.println(matrix.getValue(A, a)); // prints 1\n        System.out.println(matrix.getValue(a, A)); // prints 1\n        System.out.println(matrix.getValue(a, a)); // prints 0!!!\n        System.out.println(matrix.getValue(A, A)); // prints 0!!!\n The simple solution: compoundsEquivalent should always return true if the two are equal.\n Added a test for this.\n\n Also deprecated the no-args constructor SimpleSubstitutionMatrix() in favor of a static factory method getBlosum62(). The former was dangerous, since the generic type couldn't be checked. Plus, we should be explicit about what it is, since it only applies to amino acid sequences.\n","allZero":false}