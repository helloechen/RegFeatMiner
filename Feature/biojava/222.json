{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/PDBStatus.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/PDBStatusTest.java","prod_time":"2015-01-30 05:32:57","test_time":"2015-01-30 05:32:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"f5f987b5ce9c95446de64d07921aa80b3808d05c","test_commitID":"f5f987b5ce9c95446de64d07921aa80b3808d05c","isfound":"found test change","originPro":"/**\n *\n */\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.align.util.HTTPConnectionTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n *\n * <p>All methods query the \n * <a href=\"http://www.rcsb.org/pdb/rest/idStatus?structureId=1HHB,3HHB,4HHB\">\n * PDB website.</a>\n *\n * <p>PDB supersessions form a directed acyclic graph, where edges point from an\n * obsolete ID to the entry that directly superseded it. For example, here are  \n * edges from one portion of the graph:<br/>\n *\n * 1CAT -> 3CAT<br/>\n * 3CAT -> 7CAT<br/>\n * 3CAT -> 8CAT<br/>\n *\n * <p>The methods {@link #getReplaces(String, boolean) getReplaces(pdbId, false)}/ \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, false, true)}\n * just get the incoming/outgoing edges for a single node. The recursive versions \n * ({@link #getReplaces(String, boolean) getReplaces(pdbId, true)}, \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, true, false)})\n * will do a depth-first search up/down the tree and return a list of all nodes ]\n * reached.\n *\n * <p>Finally, the getCurrent() method returns a single PDB ID from among the \n * results of \n * {@link #getReplacement(String, boolean) getReplacement(pdbId, true)}. \n * To be consistent with the old REST ordering, this is the PDB ID that occurs \n * last alphabetically.\n *\n * <p>Results are cached to reduce server load.\n *\n * @author Spencer Bliven <sbliven@ucsd.edu>\n * @author Amr AL-Hossary\n * @since 3.0.2\n */\npublic class PDBStatus {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(PDBStatus.class);\n\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\n\t/**\n\t * saves the returned results for further use.\n\t *\n\t */\n\t//TODO Use SoftReferences to allow garbage collection\n\tprivate static Map<String, Map<String, String>> recordsCache= new Hashtable<String, Map<String, String>>();\n\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tMODEL,\n\t\tUNKNOWN;\n\n\n\t\t/**\n\t\t *\n\t\t * @param statusStr\n\t\t * @return\n\t\t * @throws IllegalArgumentException If the string is not recognized\n\t\t */\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tString statusStrUpper = statusStr.toUpperCase();\n\t\t\tif(statusStrUpper.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"MODEL\"))\n\t\t\t\tstatus = Status.MODEL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"UNKNOWN\"))\n\t\t\t\tstatus = Status.UNKNOWN;\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to parse status '\"+statusStrUpper+\"'.\");\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the PDB in question.\n\t *\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tStatus[] statuses = getStatus(new String[] {pdbId});\n\t\tif(statuses != null) {\n\t\t\tassert(statuses.length == 1);\n\t\t\treturn statuses[0];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the a collection of PDBs in question in a single query.\n\t *\n\t * @see #getStatus(String)\n\t * @param pdbIds\n\t * @return The status array, or null if an error occurred.\n\t */\n\tpublic static Status[] getStatus(String[] pdbIds) {\n\t\tStatus[] statuses = new Status[pdbIds.length];\n\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(pdbIds);\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != pdbIds.length) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", Arrays.toString(pdbIds));\n\t\t\treturn null;\n\t\t}\n\n\n\t\tfor(int pdbNum = 0;pdbNum<pdbIds.length;pdbNum++) {\n\t\t\t//Locate first element of attrList with matching structureId.\n\t\t\t//attrList is usually short, so don't worry about performance\n\t\t\tboolean foundAttr = false;\n\t\t\tfor( Map<String,String> attrs : attrList) {\n\n\t\t\t\t//Check that the record matches pdbId\n\t\t\t\tString id = attrs.get(\"structureId\");\n\t\t\t\tif(id == null || !id.equalsIgnoreCase(pdbIds[pdbNum])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Check that the status is given\n\t\t\t\tString statusStr = attrs.get(\"status\");\n\t\t\t\tStatus status = null;\n\t\t\t\tif(statusStr == null ) {\n\t\t\t\t\tlogger.error(\"No status returned for {}\", pdbIds[pdbNum]);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t} else {\n\t\t\t\t\tstatus = Status.fromString(statusStr);\n\t\t\t\t}\n\n\t\t\t\tif(status == null) {\n\t\t\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t}\n\n\t\t\t\tstatuses[pdbNum] = status;\n\t\t\t\tfoundAttr = true;\n\t\t\t}\n\t\t\tif(!foundAttr) {\n\t\t\t\tlogger.error(\"No result found for {}\", pdbIds[pdbNum]);\n\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t}\n\t\t}\n\n\t\treturn statuses;\n\t}\n\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to selecting\n\t * the first element from\n\t * {@link #getReplacement(String,boolean,boolean)\n\t *\n\t * @param oldPdbId\n\t * @return The replacement for oldPdbId, or null if none are found or if an error occurred.\n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\tList<String> replacements =  getReplacement(oldPdbId,true, false);\n\t\tif(replacements != null && !replacements.isEmpty())\n\t\t\treturn replacements.get(0);\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT IDs, this will\n\t * be itself. For obsolete IDs, the behavior depends on the recursion \n\t * parameter. If false, only IDs which directly supersede oldPdbId are\n\t * returned. If true, the replacements for obsolete records are recursively \n\t * fetched, yielding a list of all current replacements of oldPdbId.\n\t *\n\t *\n\t *\n\t * @param oldPdbId A pdb ID\n\t * @param recurse Indicates whether the replacements for obsolete records \n\t * \t\tshould be fetched.\n\t * @param includeObsolete Indicates whether obsolete records should be\n\t * \t\tincluded in the results.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB or that an error has occurred.\n\t */\n\tpublic static List<String> getReplacement(String oldPdbId, boolean recurse, boolean includeObsolete) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equalsIgnoreCase(oldPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tlogger.error(\"No status returned for {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we're current, just return\n\t\tLinkedList<String> results = new LinkedList<String>();\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\tresults.add(oldPdbId);\n\t\t\t\treturn results;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\tlogger.error(\"{} is OBSOLETE but lacks a replacedBy attribute.\", oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t//include this result\n\t\t\t\tif(includeObsolete) {\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn results; //empty\n\t\t\t\t}\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(includeObsolete) {\n\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check status of replacement\n\t\t\t\t\t\t\tStatus replacementStatus = getStatus(replacement);\n\t\t\t\t\t\t\tswitch(replacementStatus) {\n\t\t\t\t\t\t\t\tcase OBSOLETE:\n\t\t\t\t\t\t\t\t\t//ignore obsolete\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURRENT:\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// include it\n\t\t\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, treat like we're current\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\n\t\t\t\t//include this result, since it's not obsolete\n\t\t\t\tresults.add(oldPdbId);\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes two reverse sorted lists of strings and merges the second into the\n\t * first. Duplicates are removed.\n\t *\n\t * @param merged A reverse sorted list. Modified by this method to contain\n\t * \t\tthe contents of other.\n\t * @param other A reverse sorted list. Not modified.\n\t */\n\tprivate static void mergeReversed(List<String> merged,\n\t                                  final List<String> other) {\n\n\t\tif(other.isEmpty())\n\t\t\treturn;\n\n\t\tif(merged.isEmpty()) {\n\t\t\tmerged.addAll(other);\n\t\t\treturn;\n\t\t}\n\n\t\tListIterator<String> m = merged.listIterator();\n\t\tListIterator<String> o = other.listIterator();\n\n\t\tString nextM, prevO;\n\t\tprevO = o.next();\n\t\twhile(m.hasNext()) {\n\t\t\t// peek at m\n\t\t\tnextM = m.next();\n\t\t\tm.previous();\n\n\t\t\t//insert from O until exhausted or occurs after nextM\n\t\t\twhile(prevO.compareTo(nextM) > 0) {\n\t\t\t\tm.add(prevO);\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\t\t\t//remove duplicates\n\t\t\tif(prevO.equals(nextM)) {\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\n\t\t\tm.next();\n\t\t}\n\t\tm.add(prevO);\n\t\twhile(o.hasNext()) {\n\t\t\tm.add(o.next());\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t *\n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimited 'replaces'\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = new LinkedList<String>();\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tmergeReversed(allDescendents,roots);\n\t\t\t}\n\t\t\tmergeReversed(allDescendents,Arrays.asList(directDescendents));\n\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\n\n\t/**\n\t * The status of PDB IDs are cached to reduce server overload.\n\t *\n\t * This method clears the cached records.\n\t */\n\tpublic static void clearCache() {\n\t\trecordsCache.clear();\n\t}\n\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t *\n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t *\n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t *\n\t * <p>Results are not guaranteed to be returned in the same order as pdbIDs.\n\t * Refer to the structureId property to match them.\n\t *\n\t * @param pdbIDs\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) {\n\n\t\tList<Map<String,String>> result = new ArrayList<Map<String,String>>(pdbIDs.length);\n\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse\n\t\t\tlogger.info(String.format(\"Got System property %s=%s\",PDB_SERVER_PROPERTY,serverName));\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=\",serverName);\n\t\tfor(String pdbId : pdbIDs) {\n\t\t\tpdbId = pdbId.toUpperCase();\n\t\t\t//check the cache\n\t\t\tif (recordsCache.containsKey(pdbId)) {\n\t\t\t\t//logger.debug(\"Fetching \"+pdbId+\" from Cache\");\n\t\t\t\tresult.add( recordsCache.get(pdbId) );\n\t\t\t} else {\n\t\t\t\turlStr += pdbId + \",\";\n\t\t\t}\n\t\t}\n\n\t\t// check if any ids still need fetching\n\t\tif(urlStr.charAt(urlStr.length()-1) == '=') {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n\t\t\tlogger.info(\"Fetching {}\", urlStr);\n\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\n\t\t\t// Fetch results of SAX parsing\n\t\t\tList<Map<String,String>> records = handler.getRecords();\n\n\t\t\t//add to cache\n\t\t\tfor(Map<String,String> record : records) {\n\t\t\t\tString pdbId = record.get(\"structureId\").toUpperCase();\n\t\t\t\tif(pdbId != null) {\n\t\t\t\t\trecordsCache.put(pdbId, record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// return results\n\t\t\tresult.addAll(handler.getRecords());\n\n\t\t\t// TODO should throw these forward and let the caller log\n\t\t} catch (IOException e){\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t} catch (SAXException e) {\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t *\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Map<String,String>> records;\n\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Map<String,String>>();\n\t\t}\n\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t                         Attributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\t//Convert attributes into a Map, as it should have been.\n\t\t\t\t//Important since SAX reuses Attributes objects for different calls\n\t\t\t\tMap<String,String> attrMap = new HashMap<String,String>(attributes.getLength()*2);\n\t\t\t\tfor(int i=0;i<attributes.getLength();i++) {\n\t\t\t\t\tattrMap.put(attributes.getQName(i), attributes.getValue(i));\n\t\t\t\t}\n\t\t\t\trecords.add(attrMap);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tlogger.error(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\n\t\tpublic List<Map<String, String>> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n\t/** Returns a list of current PDB IDs\n\t *\n\t * @return a list of PDB IDs, or null if a problem occurred\n\t */\n\n\tpublic static SortedSet<String> getCurrentPDBIds() throws IOException {\n\n\t\tSortedSet<String> allPDBs = new TreeSet<String>();\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse\n\t\t\tlogger.info(String.format(\"Got System property %s=%s\",PDB_SERVER_PROPERTY,serverName));\n\n\t\t// Build REST query URL\n\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/getCurrent\",serverName);\n\t\tURL u = new URL(urlStr);\n\n\t\tInputStream stream = HTTPConnectionTools.getInputStream(u, 60000);\n\n\t\tif (stream != null) {\n\t\t\tBufferedReader reader = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(stream));\n\n\t\t\tString line = null;\n\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tint index = line.lastIndexOf(\"structureId=\");\n\t\t\t\tif (index > 0) {\n\t\t\t\t\tallPDBs.add(line.substring(index + 13, index + 17));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn allPDBs;\n\n\t}\n\n}","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n *\n */\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.align.util.HTTPConnectionTools;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n *\n * <p>All methods query the \n * <a href=\"http://www.rcsb.org/pdb/rest/idStatus?structureId=1HHB,3HHB,4HHB\">\n * PDB website.</a>\n *\n * <p>PDB supersessions form a directed acyclic graph, where edges point from an\n * obsolete ID to the entry that directly superseded it. For example, here are  \n * edges from one portion of the graph:<br/>\n *\n * 1CAT -> 3CAT<br/>\n * 3CAT -> 7CAT<br/>\n * 3CAT -> 8CAT<br/>\n *\n * <p>The methods {@link #getReplaces(String, boolean) getReplaces(pdbId, false)}/ \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, false, true)}\n * just get the incoming/outgoing edges for a single node. The recursive versions \n * ({@link #getReplaces(String, boolean) getReplaces(pdbId, true)}, \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, true, false)})\n * will do a depth-first search up/down the tree and return a list of all nodes ]\n * reached.\n *\n * <p>Finally, the getCurrent() method returns a single PDB ID from among the \n * results of \n * {@link #getReplacement(String, boolean) getReplacement(pdbId, true)}. \n * To be consistent with the old REST ordering, this is the PDB ID that occurs \n * last alphabetically.\n *\n * <p>Results are cached to reduce server load.\n *\n * @author Spencer Bliven <sbliven@ucsd.edu>\n * @author Amr AL-Hossary\n * @since 3.0.2\n */\npublic class PDBStatus {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(PDBStatus.class);\n\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\n\t/**\n\t * saves the returned results for further use.\n\t *\n\t */\n\t//TODO Use SoftReferences to allow garbage collection\n\tprivate static Map<String, Map<String, String>> recordsCache= new Hashtable<String, Map<String, String>>();\n\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tMODEL,\n\t\tUNKNOWN;\n\n\n\t\t/**\n\t\t *\n\t\t * @param statusStr\n\t\t * @return\n\t\t * @throws IllegalArgumentException If the string is not recognized\n\t\t */\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tString statusStrUpper = statusStr.toUpperCase();\n\t\t\tif(statusStrUpper.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"MODEL\"))\n\t\t\t\tstatus = Status.MODEL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"UNKNOWN\"))\n\t\t\t\tstatus = Status.UNKNOWN;\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to parse status '\"+statusStrUpper+\"'.\");\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the PDB in question.\n\t *\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tStatus[] statuses = getStatus(new String[] {pdbId});\n\t\tif(statuses != null) {\n\t\t\tassert(statuses.length == 1);\n\t\t\treturn statuses[0];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the status of the a collection of PDBs in question in a single query.\n\t *\n\t * @see #getStatus(String)\n\t * @param pdbIds\n\t * @return The status array, or null if an error occurred.\n\t */\n\tpublic static Status[] getStatus(String[] pdbIds) {\n\t\tStatus[] statuses = new Status[pdbIds.length];\n\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(pdbIds);\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != pdbIds.length) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", Arrays.toString(pdbIds));\n\t\t\treturn null;\n\t\t}\n\n\n\t\tfor(int pdbNum = 0;pdbNum<pdbIds.length;pdbNum++) {\n\t\t\t//Locate first element of attrList with matching structureId.\n\t\t\t//attrList is usually short, so don't worry about performance\n\t\t\tboolean foundAttr = false;\n\t\t\tfor( Map<String,String> attrs : attrList) {\n\n\t\t\t\t//Check that the record matches pdbId\n\t\t\t\tString id = attrs.get(\"structureId\");\n\t\t\t\tif(id == null || !id.equalsIgnoreCase(pdbIds[pdbNum])) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Check that the status is given\n\t\t\t\tString statusStr = attrs.get(\"status\");\n\t\t\t\tStatus status = null;\n\t\t\t\tif(statusStr == null ) {\n\t\t\t\t\tlogger.error(\"No status returned for {}\", pdbIds[pdbNum]);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t} else {\n\t\t\t\t\tstatus = Status.fromString(statusStr);\n\t\t\t\t}\n\n\t\t\t\tif(status == null) {\n\t\t\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t\t}\n\n\t\t\t\tstatuses[pdbNum] = status;\n\t\t\t\tfoundAttr = true;\n\t\t\t}\n\t\t\tif(!foundAttr) {\n\t\t\t\tlogger.error(\"No result found for {}\", pdbIds[pdbNum]);\n\t\t\t\tstatuses[pdbNum] = null;\n\t\t\t}\n\t\t}\n\n\t\treturn statuses;\n\t}\n\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to selecting\n\t * the first element from\n\t * {@link #getReplacement(String,boolean,boolean)\n\t *\n\t * @param oldPdbId\n\t * @return The replacement for oldPdbId, or null if none are found or if an error occurred.\n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\tList<String> replacements =  getReplacement(oldPdbId,true, false);\n\t\tif(replacements != null && !replacements.isEmpty())\n\t\t\treturn replacements.get(0);\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT IDs, this will\n\t * be itself. For obsolete IDs, the behavior depends on the recursion \n\t * parameter. If false, only IDs which directly supersede oldPdbId are\n\t * returned. If true, the replacements for obsolete records are recursively \n\t * fetched, yielding a list of all current replacements of oldPdbId.\n\t *\n\t *\n\t *\n\t * @param oldPdbId A pdb ID\n\t * @param recurse Indicates whether the replacements for obsolete records \n\t * \t\tshould be fetched.\n\t * @param includeObsolete Indicates whether obsolete records should be\n\t * \t\tincluded in the results.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB or that an error has occurred.\n\t */\n\tpublic static List<String> getReplacement(String oldPdbId, boolean recurse, boolean includeObsolete) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equalsIgnoreCase(oldPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tlogger.error(\"No status returned for {}\", oldPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tlogger.error(\"Unknown status '{}'\", statusStr);\n\t\t\treturn null;\n\t\t}\n\n\t\t// If we're current, just return\n\t\tLinkedList<String> results = new LinkedList<String>();\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\tresults.add(oldPdbId);\n\t\t\t\treturn results;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\tlogger.error(\"{} is OBSOLETE but lacks a replacedBy attribute.\", oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t//include this result\n\t\t\t\tif(includeObsolete) {\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn results; //empty\n\t\t\t\t}\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(includeObsolete) {\n\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check status of replacement\n\t\t\t\t\t\t\tStatus replacementStatus = getStatus(replacement);\n\t\t\t\t\t\t\tswitch(replacementStatus) {\n\t\t\t\t\t\t\t\tcase OBSOLETE:\n\t\t\t\t\t\t\t\t\t//ignore obsolete\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase CURRENT:\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t// include it\n\t\t\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, treat like we're current\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\n\t\t\t\t//include this result, since it's not obsolete\n\t\t\t\tresults.add(oldPdbId);\n\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes two reverse sorted lists of strings and merges the second into the\n\t * first. Duplicates are removed.\n\t *\n\t * @param merged A reverse sorted list. Modified by this method to contain\n\t * \t\tthe contents of other.\n\t * @param other A reverse sorted list. Not modified.\n\t */\n\tprivate static void mergeReversed(List<String> merged,\n\t                                  final List<String> other) {\n\n\t\tif(other.isEmpty())\n\t\t\treturn;\n\n\t\tif(merged.isEmpty()) {\n\t\t\tmerged.addAll(other);\n\t\t\treturn;\n\t\t}\n\n\t\tListIterator<String> m = merged.listIterator();\n\t\tListIterator<String> o = other.listIterator();\n\n\t\tString nextM, prevO;\n\t\tprevO = o.next();\n\t\twhile(m.hasNext()) {\n\t\t\t// peek at m\n\t\t\tnextM = m.next();\n\t\t\tm.previous();\n\n\t\t\t//insert from O until exhausted or occurs after nextM\n\t\t\twhile(prevO.compareTo(nextM) > 0) {\n\t\t\t\tm.add(prevO);\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\t\t\t//remove duplicates\n\t\t\tif(prevO.equals(nextM)) {\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\n\t\t\tm.next();\n\t\t}\n\t\tm.add(prevO);\n\t\twhile(o.hasNext()) {\n\t\t\tm.add(o.next());\n\t\t}\n\n\t}\n\n\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t *\n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimited 'replaces'\n\t\t\tlogger.error(\"Error getting Status for {} from the PDB website.\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\t\tMap<String,String> attrs = attrList.get(0);\n\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tlogger.error(\"Results returned from the query don't match {}\", newPdbId);\n\t\t\treturn null;\n\t\t}\n\n\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = new LinkedList<String>();\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tmergeReversed(allDescendents,roots);\n\t\t\t}\n\t\t\tmergeReversed(allDescendents,Arrays.asList(directDescendents));\n\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\n\n\t/**\n\t * The status of PDB IDs are cached to reduce server overload.\n\t *\n\t * This method clears the cached records.\n\t */\n\tpublic static void clearCache() {\n\t\trecordsCache.clear();\n\t}\n\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t *\n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t *\n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t *\n\t * <p>Results are not guaranteed to be returned in the same order as pdbIDs.\n\t * Refer to the structureId property to match them.\n\t *\n\t * @param pdbIDs\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) {\n\n\t\tList<Map<String,String>> result = new ArrayList<Map<String,String>>(pdbIDs.length);\n\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse\n\t\t\tlogger.info(String.format(\"Got System property %s=%s\",PDB_SERVER_PROPERTY,serverName));\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=\",serverName);\n\t\tfor(String pdbId : pdbIDs) {\n\t\t\tpdbId = pdbId.toUpperCase();\n\t\t\t//check the cache\n\t\t\tif (recordsCache.containsKey(pdbId)) {\n\t\t\t\t//logger.debug(\"Fetching \"+pdbId+\" from Cache\");\n\t\t\t\tresult.add( recordsCache.get(pdbId) );\n\t\t\t} else {\n\t\t\t\turlStr += pdbId + \",\";\n\t\t\t}\n\t\t}\n\n\t\t// check if any ids still need fetching\n\t\tif(urlStr.charAt(urlStr.length()-1) == '=') {\n\t\t\treturn result;\n\t\t}\n\n\t\ttry {\n\t\t\tlogger.info(\"Fetching {}\", urlStr);\n\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\n\t\t\t// Fetch results of SAX parsing\n\t\t\tList<Map<String,String>> records = handler.getRecords();\n\n\t\t\t//add to cache\n\t\t\tfor(Map<String,String> record : records) {\n\t\t\t\tString pdbId = record.get(\"structureId\").toUpperCase();\n\t\t\t\tif(pdbId != null) {\n\t\t\t\t\trecordsCache.put(pdbId, record);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// return results\n\t\t\tresult.addAll(handler.getRecords());\n\n\t\t\t// TODO should throw these forward and let the caller log\n\t\t} catch (IOException e){\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t} catch (SAXException e) {\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tlogger.error(\"Problem getting status for {} from PDB server. Error: {}\", Arrays.toString(pdbIDs), e.getMessage());\n\t\t\treturn null;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t *\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Map<String,String>> records;\n\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Map<String,String>>();\n\t\t}\n\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t                         Attributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\t//Convert attributes into a Map, as it should have been.\n\t\t\t\t//Important since SAX reuses Attributes objects for different calls\n\t\t\t\tMap<String,String> attrMap = new HashMap<String,String>(attributes.getLength()*2);\n\t\t\t\tfor(int i=0;i<attributes.getLength();i++) {\n\t\t\t\t\tattrMap.put(attributes.getQName(i), attributes.getValue(i));\n\t\t\t\t}\n\t\t\t\trecords.add(attrMap);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tlogger.error(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\n\t\tpublic List<Map<String, String>> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n\t/** Returns a list of current PDB IDs\n\t *\n\t * @return a list of PDB IDs, or null if a problem occurred\n\t */\n\n\tpublic static SortedSet<String> getCurrentPDBIds() throws IOException {\n\n\t\tSortedSet<String> allPDBs = new TreeSet<String>();\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse\n\t\t\tlogger.info(String.format(\"Got System property %s=%s\",PDB_SERVER_PROPERTY,serverName));\n\n\t\t// Build REST query URL\n\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/getCurrent\",serverName);\n\t\tURL u = new URL(urlStr);\n\n\t\tInputStream stream = HTTPConnectionTools.getInputStream(u, 60000);\n\n\t\tif (stream != null) {\n\t\t\tBufferedReader reader = new BufferedReader(\n\t\t\t\t\tnew InputStreamReader(stream));\n\n\t\t\tString line = null;\n\n\t\t\twhile ((line = reader.readLine()) != null) {\n\t\t\t\tint index = line.lastIndexOf(\"structureId=\");\n\t\t\t\tif (index > 0) {\n\t\t\t\t\tallPDBs.add(line.substring(index + 13, index + 17));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn allPDBs;\n\n\t}\n\n}","originTest":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\tassertFalse(Arrays.asList(\"YES\").equals(Arrays.asList(\"NO\"))); //check for deep equals\n\t\t\n\t\t// 1CMW is replacedBy NONE\n\t\tassertEquals(Arrays.asList(),PDBStatus.getReplacement(\"1CMW\", true, false));\n\t\tassertEquals(Arrays.asList(\"1CMW\"),PDBStatus.getReplacement(\"1CMW\", true, true));\n\t\t\n\t\t// 1HHB is replacedBy 2-4HHB\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,true));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\"),PDBStatus.getReplacement(\"1HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\",\"1HHB\"),PDBStatus.getReplacement(\"1HHB\",false,true));\n\t\t\n\t\t// 1CAT is replacedBy 3CAT is replacedBy 7-8CAT\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\",\"1CAT\"),PDBStatus.getReplacement(\"1CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"1CAT\",true,false));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\"),PDBStatus.getReplacement(\"3CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"3CAT\",true,false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tassertEquals(\"3ENI\",PDBStatus.getCurrent(\"1KSA\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"1CAT\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"3CAT\"));\n\t\tassertEquals(\"7CAT\",PDBStatus.getCurrent(\"7CAT\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\tassertEquals(new ArrayList<String>(), Arrays.asList(new String[] {}));\n\t\t\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"4HHB\",false));\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"3HHB\",false));\n\t\tassertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\", false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",true));\n\t\tassertEquals(Arrays.asList(\"3CAT\"),PDBStatus.getReplaces(\"8CAT\",false));\n\t\tassertEquals(Arrays.asList(\"3CAT\",\"1CAT\"),PDBStatus.getReplaces(\"8CAT\",true));\n\t\t\n\t}\n\t\n\t/**\n\t * Tests a helper method for merging that was giving me problems\n\t */\n\tpublic void testMergeReversed() {\n\t\ttry {\n\t\t\tMethod mergeReversed = PDBStatus.class.getDeclaredMethod(\"mergeReversed\",\n\t\t\t\t\tList.class,List.class);\n\t\t\tmergeReversed.setAccessible(true);\n\n\n\t\t\tList<String> a,b;\n\n\t\t\tb = Arrays.asList(\"F\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"B\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"B\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\", \"1\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\t\t\t\n\t\t\tb = Arrays.asList();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\n\t\t\tb = Arrays.asList(\"G\",\"D\",\"C\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"F\");\n\t\t\ta.add(\"B\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"D\",\"C\",\"B\",\"A\", \"1\"),a);\n\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}\n\t\n\t/**\n\t * Test low-level connectivity to the PDB\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\t\t\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"4HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replaces\",\"1HHB\",attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"3ENI\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"3ENI\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"1M50 1KSA\",attrs.get(\"replaces\"));\n\t\t\t\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}\n\t\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\tassertFalse(Arrays.asList(\"YES\").equals(Arrays.asList(\"NO\"))); //check for deep equals\n\t\t\n\t\t// 1CMW is replacedBy NONE\n\t\tassertEquals(Arrays.asList(),PDBStatus.getReplacement(\"1CMW\", true, false));\n\t\tassertEquals(Arrays.asList(\"1CMW\"),PDBStatus.getReplacement(\"1CMW\", true, true));\n\t\t\n\t\t// 1HHB is replacedBy 2-4HHB\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,true));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\"),PDBStatus.getReplacement(\"1HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\",\"1HHB\"),PDBStatus.getReplacement(\"1HHB\",false,true));\n\t\t\n\t\t// 1CAT is replacedBy 3CAT is replacedBy 7-8CAT\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\",\"1CAT\"),PDBStatus.getReplacement(\"1CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"1CAT\",true,false));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\"),PDBStatus.getReplacement(\"3CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"3CAT\",true,false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tassertEquals(\"3ENI\",PDBStatus.getCurrent(\"1KSA\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"1CAT\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"3CAT\"));\n\t\tassertEquals(\"7CAT\",PDBStatus.getCurrent(\"7CAT\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\tassertEquals(new ArrayList<String>(), Arrays.asList(new String[] {}));\n\t\t\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"4HHB\",false));\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"3HHB\",false));\n\t\tassertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\", false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",true));\n\t\tassertEquals(Arrays.asList(\"3CAT\"),PDBStatus.getReplaces(\"8CAT\",false));\n\t\tassertEquals(Arrays.asList(\"3CAT\",\"1CAT\"),PDBStatus.getReplaces(\"8CAT\",true));\n\t\t\n\t}\n\t\n\t/**\n\t * Tests a helper method for merging that was giving me problems\n\t */\n\tpublic void testMergeReversed() {\n\t\ttry {\n\t\t\tMethod mergeReversed = PDBStatus.class.getDeclaredMethod(\"mergeReversed\",\n\t\t\t\t\tList.class,List.class);\n\t\t\tmergeReversed.setAccessible(true);\n\n\n\t\t\tList<String> a,b;\n\n\t\t\tb = Arrays.asList(\"F\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"B\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"B\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\", \"1\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\t\t\t\n\t\t\tb = Arrays.asList();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\n\t\t\tb = Arrays.asList(\"G\",\"D\",\"C\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"F\");\n\t\t\ta.add(\"B\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"D\",\"C\",\"B\",\"A\", \"1\"),a);\n\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}\n\t\n\t/**\n\t * Test low-level connectivity to the PDB\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\t\t\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"4HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replaces\",\"1HHB\",attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"3ENI\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"3ENI\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"1M50 1KSA\",attrs.get(\"replaces\"));\n\t\t\t\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}\n\t\n}\n","commitMessage":"Adding license statement to all java files\n","test_commitMessage":"Adding license statement to all java files\n","allZero":true}