{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/MultipleSequenceAlignment.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/MultipleSequenceAlignmentTest.java","prod_time":"2022-01-04 02:27:49","test_time":"2022-01-04 02:27:49","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"3c045a73c9a80af6dfa69008a1499383ed264859","test_commitID":"3c045a73c9a80af6dfa69008a1499383ed264859","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\n\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.LightweightProfile;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Implements a minimal data structure for reading and writing a sequence alignment.  The full {@code Profile} data\n * structure in the alignment module provides additional functionality.\n *\n * @author Scooter Willis\n * @author Mark Chapman\n */\npublic class MultipleSequenceAlignment<S extends Sequence<C>, C extends Compound> implements LightweightProfile<S, C> {\n\n\tprivate List<S> sequences = new ArrayList<S>();\n\tprivate Integer length = null;\n\n\t/**\n\t * A sequence that has been aligned to other sequences will have inserts.\n\t * @param sequence\n\t */\n\tpublic void addAlignedSequence(S sequence){\n\t\tif(length == null){\n\t\t\tlength = sequence.getLength();\n\t\t}\n\t\tif(sequence.getLength() != length){\n\t\t\tthrow new IllegalArgumentException(sequence.getAccession() + \" length = \" + sequence.getLength() +\n\t\t\t\t\t\" not equal to MSA length = \" + length);\n\t\t}\n\t\tsequences.add(sequence);\n\t}\n\n\t/**\n\t * Remove a sequence\n\t * @param sequence\n\t * @return flag\n\t */\n\tpublic boolean removeAlignedSequence(S sequence){\n\t\treturn sequences.remove(sequence);\n\t}\n//methods for LightweightProfile\n\n\t/**\n\t * Uses bioIndex starting at 1 instead of 0\n\t * @param listIndex\n\t * @return sequence\n\t */\n\n\n\t@Override\n\tpublic S getAlignedSequence(int listIndex) {\n\t\treturn sequences.get(listIndex - 1);\n\t}\n\n\t/**\n\t * Get the list of sequences\n\t * @return list of sequences\n\t */\n\t@Override\n\tpublic List<S> getAlignedSequences() {\n\t\treturn Collections.unmodifiableList(sequences);\n\t}\n\n\t/**\n\t * Get a list of compounds at a sequence position\n\t * @param alignmentIndex\n\t * @return compounds\n\t */\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (S s : sequences) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t/**\n\t * Get the Compounds defined in the first sequence\n\t * @return get compound set\n\t */\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn sequences.get(0).getCompoundSet();\n\t}\n\n\t/**\n\t * Get the length of the MSA where it is assumed that\n\t * all sequence position\n\t * @return length of MSA\n\t */\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t/**\n\t * Get the number of sequences in the MSA\n\t * @return nr of sequences\n\t */\n\t@Override\n\tpublic int getSize() {\n\t\treturn sequences.size();\n\t}\n\n\t/**\n\t * Get a string representation of the MSA with a fixed width\n\t * @param width\n\t * @return String\n\t */\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(sequences), true, true, true, false);\n\t}\n\n\t/**\n\t * Support for different MSA formats\n\t * @param format\n\t * @return String in one of the supported file formats.\n\t */\n\t@Override\n\tpublic String toString(StringFormat format) {\n\t\tswitch (format) {\n\t\tcase ALN:\n\t\tcase CLUSTALW:\n\t\tdefault:\n\t\t\treturn toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(sequences) +\n\t\t\t\t\t\"   \", true, false, true, false);\n\t\tcase FASTA:\n\t\t\treturn toString(60, null, \">%s%n\", false, false, false, false);\n\t\tcase GCG:\n\t\tcase MSF:\n\t\t\treturn toString(50, IOUtils.getGCGHeader(sequences), IOUtils.getIDFormat(sequences), true, false, false,\n\t\t\t\t\tfalse);\n\t\tcase PDBWEB:\n\t\t\treturn toString(60, null, \"%s\", true, false, true, true);\n\t\t}\n\t}\n\n\t/**\n\t * String representation of the MSA\n\t * @return String\n\t */\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false);\n\t}\n\n\t// helper methods\n\n\t/**\n\t * Helper method that does all the formating work\n\t * @param width\n\t * @param header\n\t * @param idFormat\n\t * @param interlaced\n\t * @param aligIndices\n\t * @param aligConservation\n\t * @param webDisplay\n\t * @return String\n\t */\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean interlaced, boolean aligIndices,\n\t\t\tboolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n\t\tif (webDisplay && sequences.size() == 2) {\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (S as : sequences) {\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif (webDisplay && sequences.size() == 2) {\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (aligConservation && sequences.size() == 2 && counter == 1) {\n\t\t\t\t\t\tprintConservation(s, idFormat, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (S as : sequences) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && sequences.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t *\n\t * @param s\n\t * @param counter\n\t * @param idFormat\n\t * @param start\n\t * @param end\n\t */\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, int start, int end) {\n\t\tS as = sequences.get(counter - 1), seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\n\t\tString mySeq = as.getSubSequence(start, end).getSequenceAsString();\n\t\tString s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n\t\tCompoundSet<C> cs = getCompoundSet();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n\t\t\t\t\tseq2.getCompoundAt(i)), c));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n\t/**\n\t *\n\t * @param s\n\t * @param idFormat\n\t * @param start\n\t * @param end\n\t * @param webDisplay\n\t */\n\tprivate void printConservation(StringBuilder s, String idFormat, int start, int end, boolean webDisplay) {\n\t\tS seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\tAccessionID ac1 = sequences.get(0).getAccession();\n\t\t\tString id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t\t\tid1 = id1.replaceAll(\".\", \" \");\n\t\t\ts.append(String.format(idFormat, id1));\n\t\t}\n\n\t\tString s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n\t\tCompoundSet<C> cs = getCompoundSet();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\ts.append(IOUtils.getPDBConservation(webDisplay, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n\t\t\t\t\tseq2.getCompoundAt(i))));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\n\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.sequence.io.util.IOUtils;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.LightweightProfile;\nimport org.biojava.nbio.core.sequence.template.Sequence;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Implements a minimal data structure for reading and writing a sequence alignment.  The full {@code Profile} data\n * structure in the alignment module provides additional functionality.\n *\n * @author Scooter Willis\n * @author Mark Chapman\n */\npublic class MultipleSequenceAlignment<S extends Sequence<C>, C extends Compound> implements LightweightProfile<S, C> {\n\n\tprivate List<S> sequences = new ArrayList<S>();\n\tprivate Integer length = null;\n\n\t/**\n\t * A sequence that has been aligned to other sequences will have inserts.\n\t * @param sequence\n\t */\n\tpublic void addAlignedSequence(S sequence){\n\t\tif(length == null){\n\t\t\tlength = sequence.getLength();\n\t\t}\n\t\tif(sequence.getLength() != length){\n\t\t\tthrow new IllegalArgumentException(sequence.getAccession() + \" length = \" + sequence.getLength() +\n\t\t\t\t\t\" not equal to MSA length = \" + length);\n\t\t}\n\t\tsequences.add(sequence);\n\t}\n\n\t/**\n\t * Remove a sequence\n\t * @param sequence\n\t * @return flag\n\t */\n\tpublic boolean removeAlignedSequence(S sequence){\n\t\treturn sequences.remove(sequence);\n\t}\n//methods for LightweightProfile\n\n\t/**\n\t * Uses bioIndex starting at 1 instead of 0\n\t * @param listIndex\n\t * @return sequence\n\t */\n\n\n\t@Override\n\tpublic S getAlignedSequence(int listIndex) {\n\t\treturn sequences.get(listIndex - 1);\n\t}\n\n\t/**\n\t * Get the list of sequences\n\t * @return list of sequences\n\t */\n\t@Override\n\tpublic List<S> getAlignedSequences() {\n\t\treturn Collections.unmodifiableList(sequences);\n\t}\n\n\t/**\n\t * Get a list of compounds at a sequence position\n\t * @param alignmentIndex\n\t * @return compounds\n\t */\n\t@Override\n\tpublic List<C> getCompoundsAt(int alignmentIndex) {\n\t\tList<C> column = new ArrayList<C>();\n\t\tfor (S s : sequences) {\n\t\t\tcolumn.add(s.getCompoundAt(alignmentIndex));\n\t\t}\n\t\treturn Collections.unmodifiableList(column);\n\t}\n\n\t/**\n\t * Get the Compounds defined in the first sequence\n\t * @return get compound set\n\t */\n\t@Override\n\tpublic CompoundSet<C> getCompoundSet() {\n\t\treturn sequences.get(0).getCompoundSet();\n\t}\n\n\t/**\n\t * Get the length of the MSA where it is assumed that\n\t * all sequence position\n\t * @return length of MSA\n\t */\n\t@Override\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\t/**\n\t * Get the number of sequences in the MSA\n\t * @return nr of sequences\n\t */\n\t@Override\n\tpublic int getSize() {\n\t\treturn sequences.size();\n\t}\n\n\t/**\n\t * Get a string representation of the MSA with a fixed width\n\t * @param width\n\t * @return String\n\t */\n\t@Override\n\tpublic String toString(int width) {\n\t\treturn toString(width, null, IOUtils.getIDFormat(sequences), true, true, true, false);\n\t}\n\n\t/**\n\t * Support for different MSA formats\n\t * @param format\n\t * @return String in one of the supported file formats.\n\t */\n\t@Override\n\tpublic String toString(StringFormat format) {\n\t\tswitch (format) {\n\t\tcase ALN:\n\t\tcase CLUSTALW:\n\t\tdefault:\n\t\t\treturn toString(60, String.format(\"CLUSTAL W MSA from BioJava%n%n\"), IOUtils.getIDFormat(sequences) +\n\t\t\t\t\t\"   \", true, false, true, false);\n\t\tcase FASTA:\n\t\t\treturn toString(60, null, \">%s%n\", false, false, false, false);\n\t\tcase GCG:\n\t\tcase MSF:\n\t\t\treturn toString(50, IOUtils.getGCGHeader(sequences), IOUtils.getIDFormat(sequences), true, false, false,\n\t\t\t\t\tfalse);\n\t\tcase PDBWEB:\n\t\t\treturn toString(60, null, \"%s\", true, false, true, true);\n\t\t}\n\t}\n\n\t/**\n\t * String representation of the MSA\n\t * @return String\n\t */\n\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(getLength(), null, null, false, false, false, false);\n\t}\n\n\t// helper methods\n\n\t/**\n\t * Helper method that does all the formatting work\n\t * @param width\n\t * @param header\n\t * @param idFormat\n\t * @param interlaced\n\t * @param aligIndices\n\t * @param aligConservation\n\t * @param webDisplay\n\t * @return String\n\t */\n\t// creates formatted String\n\tprivate String toString(int width, String header, String idFormat, boolean interlaced, boolean aligIndices,\n\t\t\tboolean aligConservation, boolean webDisplay) {\n\n\t\t// TODO handle circular alignments\n\t\tStringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n\n\t\tif (webDisplay && sequences.size() == 2) {\n\t\t\ts.append(\"<div><pre>\");\n\t\t}\n\n\t\twidth = Math.max(1, width);\n\t\tif (interlaced) {\n\t\t\tString aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) +\n\t\t\t\t\t\"d%n\";\n\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t\tif (aligIndices) {\n\t\t\t\t\tif (end < i + width) {\n\t\t\t\t\t\tint line = end - start + 1;\n\t\t\t\t\t\taligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) +\n\t\t\t\t\t\t\t\t\"d%n\";\n\t\t\t\t\t}\n\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\ts.append(String.format(idFormat, \"\"));\n\t\t\t\t\t}\n\t\t\t\t\ts.append(String.format(aligIndFormat, start, end));\n\t\t\t\t}\n\t\t\t\tint counter = 0;\n\t\t\t\tfor (S as : sequences) {\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif (webDisplay && sequences.size() == 2) {\n\t\t\t\t\t\tprintSequenceAlignmentWeb(s, counter, idFormat, start, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (idFormat != null) {\n\t\t\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t\t}\n\t\t\t\t\tif (aligConservation && sequences.size() == 2 && counter == 1) {\n\t\t\t\t\t\tprintConservation(s, idFormat, start, end, webDisplay);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (S as : sequences) {\n\t\t\t\tif (idFormat != null) {\n\t\t\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < getLength(); i += width) {\n\t\t\t\t\tint start = i + 1, end = Math.min(getLength(), i + width);\n\t\t\t\t\ts.append(as.getSubSequence(start, end).getSequenceAsString());\n\t\t\t\t\ts.append(String.format(\"%n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (webDisplay && aligConservation && sequences.size() == 2) {\n\t\t\ts.append(IOUtils.getPDBLegend());\n\t\t}\n\t\treturn s.toString();\n\t}\n\n\t/**\n\t *\n\t * @param s\n\t * @param counter\n\t * @param idFormat\n\t * @param start\n\t * @param end\n\t */\n\tprivate void printSequenceAlignmentWeb(StringBuilder s, int counter, String idFormat, int start, int end) {\n\t\tS as = sequences.get(counter - 1), seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\ts.append(String.format(idFormat, as.getAccession()));\n\t\t}\n\n\t\tString mySeq = as.getSubSequence(start, end).getSequenceAsString();\n\t\tString s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n\t\tCompoundSet<C> cs = getCompoundSet();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length() || i >= mySeq.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\tchar c = mySeq.charAt(i);\n\t\t\ts.append(IOUtils.getPDBCharacter(true, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n\t\t\t\t\tseq2.getCompoundAt(i)), c));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n\t/**\n\t *\n\t * @param s\n\t * @param idFormat\n\t * @param start\n\t * @param end\n\t * @param webDisplay\n\t */\n\tprivate void printConservation(StringBuilder s, String idFormat, int start, int end, boolean webDisplay) {\n\t\tS seq1 = sequences.get(0), seq2 = sequences.get(1);\n\n\t\tif (idFormat != null) {\n\t\t\tAccessionID ac1 = sequences.get(0).getAccession();\n\t\t\tString id1 = (ac1 == null) ? \"null\" : ac1.getID();\n\t\t\tid1 = id1.replaceAll(\".\", \" \");\n\t\t\ts.append(String.format(idFormat, id1));\n\t\t}\n\n\t\tString s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n\t\tString s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n\t\tCompoundSet<C> cs = getCompoundSet();\n\n\t\tfor (int i = 0; i < s1.length(); i++) {\n\t\t\tif (i >= s2.length())\n\t\t\t\tbreak;\n\t\t\tchar c1 = s1.charAt(i);\n\t\t\tchar c2 = s2.charAt(i);\n\t\t\ts.append(IOUtils.getPDBConservation(webDisplay, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i),\n\t\t\t\t\tseq2.getCompoundAt(i))));\n\t\t}\n\n\t\ts.append(String.format(\"%n\"));\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on November 21, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\npublic class MultipleSequenceAlignmentTest {\n\n\tprivate MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msaProteins;\n\tprivate MultipleSequenceAlignment<DNASequence,NucleotideCompound> msaDNA;\n\n\t@Before\n\tpublic void setup() throws CompoundNotFoundException {\n\t\tmsaProteins = new MultipleSequenceAlignment<>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tmsaProteins.addAlignedSequence(new ProteinSequence(\"ARNDCEQGHILKMFPSTWYVBZJX\"));\n\t\t}\n\t\tmsaDNA = new MultipleSequenceAlignment<>();\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tmsaDNA.addAlignedSequence(new DNASequence(\"ATCGATCGATCGATCG\"));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testGetCompoundsAt() {\n\t\tAminoAcidCompound aminoAcid = AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(\"N\");\n\t\tList<AminoAcidCompound> colProteins = new ArrayList<>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tcolProteins.add(aminoAcid);\n\t\t}\n\t\tassertEquals(msaProteins.getCompoundsAt(3), colProteins);\n\t\tNucleotideCompound nucleotide = DNACompoundSet.getDNACompoundSet().getCompoundForString(\"C\");\n\t\tList<NucleotideCompound> colDNA = new ArrayList<>();\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tcolDNA.add(nucleotide);\n\t\t}\n\t\tassertEquals(msaDNA.getCompoundsAt(3), colDNA);\n\t}\n\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on November 21, 2010\n * Author: Mark Chapman\n */\n\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.template.LightweightProfile;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n\nclass MultipleSequenceAlignmentTest {\n\n\tprivate MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msaProteins;\n\tprivate MultipleSequenceAlignment<DNASequence,NucleotideCompound> msaDNA;\n\n\tprivate static final String aaSeq = \"ARNDCEQGHILKMFPSTWYVBZJX\";\n\t@BeforeEach\n\t void setup() throws CompoundNotFoundException {\n\t\tmsaProteins = new MultipleSequenceAlignment<>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tProteinSequence ps = new ProteinSequence(aaSeq);\n\t\t\tps.setAccession(new AccessionID(i+\"\"));\n\t\t\tmsaProteins.addAlignedSequence(ps);\n\t\t}\n\t\tmsaDNA = new MultipleSequenceAlignment<>();\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tmsaDNA.addAlignedSequence(new DNASequence(\"ATCGATCGATCGATCG\"));\n\t\t}\n\t}\n\n\t@Test\n\tvoid allSequencesMustBeSameLength() throws CompoundNotFoundException {\n\t\tProteinSequence differentLength = new ProteinSequence(\"ARNDC\");\n\t\tassertThrows(IllegalArgumentException.class, ()->msaProteins.addAlignedSequence(differentLength));\n\t}\n\n\t@Test\n\tvoid addRemoveAlignments() throws CompoundNotFoundException {\n\t\tassertEquals(8, msaProteins.getSize());\n\t\tassertEquals(8, msaProteins.getAlignedSequences().size());\n\t\tassertEquals(aaSeq.length(), msaProteins.getLength());\n\t\tmsaProteins.removeAlignedSequence(new ProteinSequence(aaSeq));\n\t\tassertEquals(7, msaProteins.getSize());\n\t\tassertEquals(7, msaProteins.getAlignedSequences().size());\n\t}\n\n\t@ParameterizedTest\n\t@EnumSource(LightweightProfile.StringFormat.class)\n\tvoid formattedAlignmentToString(LightweightProfile.StringFormat format){\n\t\tString formatted = msaProteins.toString(format);\n\t\tassertTrue(formatted.length() > 0);\n\t}\n\n\t@Test\n\tvoid alignmentToBasicString(){\n\t\tString alnStr = msaProteins.toString();\n\t\tString [] lines  = alnStr.split(System.lineSeparator());\n\t\tassertEquals(8, lines.length);\n\n\t\t//lines all same length\n\t\tSet<Integer> collect = Arrays.stream(lines).map(String::length).collect(Collectors.toSet());\n\t\tassertEquals(1, collect.size());\n\t}\n\t@Test\n\tvoid alignmentToWidth() {\n\t\tString alnStr = msaProteins.toString(10);\n\t\tassertEquals(29, alnStr.split(System.lineSeparator()).length);\n\t}\n\n\t@Test\n\t void testGetCompoundsAt() {\n\t\tAminoAcidCompound aminoAcid = AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(\"N\");\n\t\tList<AminoAcidCompound> colProteins = new ArrayList<>();\n\t\tfor (int i = 0; i < 8; i++) {\n\t\t\tcolProteins.add(aminoAcid);\n\t\t}\n\t\tassertEquals(msaProteins.getCompoundsAt(3), colProteins);\n\t\tNucleotideCompound nucleotide = DNACompoundSet.getDNACompoundSet().getCompoundForString(\"C\");\n\t\tList<NucleotideCompound> colDNA = new ArrayList<>();\n\t\tfor (int i = 0; i < 7; i++) {\n\t\t\tcolDNA.add(nucleotide);\n\t\t}\n\t\tassertEquals(msaDNA.getCompoundsAt(3), colDNA);\n\t}\n\n\n}\n","commitMessage":"test MSA\n","test_commitMessage":"test MSA\n","allZero":true}