{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/xtal/CrystalCell.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/xtal/TestCrystalCell.java","prod_time":"2015-01-26 20:11:33","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":2,"del_classname_line":0,"del_condition_line":0,"del_field_line":2,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"f5a3aff6b080639c41c36d9d9802c080d71eced3","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.bio.structure.xtal;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Tuple3d;\nimport javax.vecmath.Vector3d;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A crystal cell's parameters.\n * \n * @author duarte_j\n *\n */\npublic class CrystalCell implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate static final Logger logger = LoggerFactory.getLogger(CrystalCell.class);\n\n\tprivate static final double MIN_VALID_CELL_SIZE = 10.0; // the minimum admitted for a crystal cell\n\n\t\n\tprivate double a;\n\tprivate double b;\n\tprivate double c;\n\t\n\tprivate double alpha;\n\tprivate double beta;\n\tprivate double gamma;\n\t\n\tprivate double alphaRad;\n\tprivate double betaRad;\n\tprivate double gammaRad;\n\t\n\tprivate double volume; // cached volume\n\t\n\tprivate double maxDimension; // cached max dimension\n\n\tprivate Matrix3d M; \t// cached basis change transformation matrix\n\tprivate Matrix3d Minv;  // cached basis change transformation matrix\n\tprivate Matrix3d Mtransp;\n\tprivate Matrix3d MtranspInv;\n\t\n\tpublic CrystalCell() {\n\t\t\n\t}\n\t\n\tpublic CrystalCell(double a, double b, double c, double alpha, double beta, double gamma){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.setAlpha(alpha); // initialises both alpha and alphaRad\n\t\tthis.setBeta(beta);\n\t\tthis.setGamma(gamma);\n\t}\n\n\tpublic double getA() {\n\t\treturn a;\n\t}\n\n\tpublic void setA(double a) {\n\t\tthis.a = a;\n\t}\n\n\tpublic double getB() {\n\t\treturn b;\n\t}\n\n\tpublic void setB(double b) {\n\t\tthis.b = b;\n\t}\n\n\tpublic double getC() {\n\t\treturn c;\n\t}\n\n\tpublic void setC(double c) {\n\t\tthis.c = c;\n\t}\n\n\tpublic double getAlpha() {\n\t\treturn alpha;\n\t}\n\n\tpublic void setAlpha(double alpha) {\n\t\tthis.alpha = alpha;\n\t\tthis.alphaRad = Math.toRadians(alpha);\n\t}\n\n\tpublic double getBeta() {\n\t\treturn beta;\n\t}\n\n\tpublic void setBeta(double beta) {\n\t\tthis.beta = beta;\n\t\tthis.betaRad = Math.toRadians(beta);\n\t}\n\n\tpublic double getGamma() {\n\t\treturn gamma;\n\t}\n\n\tpublic void setGamma(double gamma) {\n\t\tthis.gamma = gamma;\n\t\tthis.gammaRad = Math.toRadians(gamma);\n\t}\n\t\n\t/**\n\t * Returns the volume of this unit cell.\n\t * See http://en.wikipedia.org/wiki/Parallelepiped\n\t * @return\n\t */\n\tpublic double getVolume() {\n\t\tif (volume!=0) {\n\t\t\treturn volume;\n\t\t}\n\t\tvolume =  a*b*c*\n\t\tMath.sqrt(1-Math.cos(alphaRad)*Math.cos(alphaRad)-Math.cos(betaRad)*Math.cos(betaRad)-Math.cos(gammaRad)*Math.cos(gammaRad)\n\t\t\t\t+2.0*Math.cos(alphaRad)*Math.cos(betaRad)*Math.cos(gammaRad));\n\t\t\n\t\treturn volume;\n\t}\n\t\n\t/**\n\t * Get the index of a unit cell to which the query point belongs.\n\t * \n\t * <p>For instance, all points in the unit cell at the origin will return (0,0,0);\n\t * Points in the unit cell one unit further along the `a` axis will return (1,0,0),\n\t * etc.\n\t * @param pt Input point\n\t * @return A new point with the three indices of the cell containing pt\n\t */\n\tpublic Point3i getCellIndices(Tuple3d pt) {\n\t\tPoint3d p = new Point3d(pt);\n\t\tthis.transfToCrystal(p);\n\n\t\tint x = (int)Math.floor(p.x);\n\t\tint y = (int)Math.floor(p.y);\n\t\tint z = (int)Math.floor(p.z);\n\t\treturn new Point3i(x,y,z);\n\t}\n\n\t/**\n\t * Converts the coordinates in pt so that they occur within the (0,0,0) unit cell\n\t * @param pt\n\t */\n\tpublic void transfToOriginCell(Tuple3d pt) {\n\t\ttransfToCrystal(pt);\n\n\t\t// convert all coordinates to [0,1) interval\n\t\tpt.x = pt.x<0 ? (pt.x%1.0 + 1.0)%1.0 : pt.x%1.0;\n\t\tpt.y = pt.y<0 ? (pt.y%1.0 + 1.0)%1.0 : pt.y%1.0;\n\t\tpt.z = pt.z<0 ? (pt.z%1.0 + 1.0)%1.0 : pt.z%1.0;\n\n\t\ttransfToOrthonormal(pt);\n\t}\n\n\t/**\n\t * Converts a set of points so that the reference point falls in the unit cell.\n\t *\n\t * This is useful to transform a whole chain at once, allowing some of the\n\t * atoms to be outside the unit cell, but forcing the centroid to be within it.\n\t *\n\t * @param points A set of points to transform\n\t * @param reference The reference point, which is unmodified but which would\n\t *    be in the unit cell were it to have been transformed. It is safe to\n\t *    use a member of the points array here.\n\t */\n\tpublic void transfToOriginCell(Tuple3d[] points, Tuple3d reference) {\n\t\treference = new Point3d(reference);//clone\n\t\ttransfToCrystal(reference);\n\n\t\tint x = (int)Math.floor(reference.x);\n\t\tint y = (int)Math.floor(reference.y);\n\t\tint z = (int)Math.floor(reference.z);\n\n\t\tfor( Tuple3d point: points ) {\n\t\t\ttransfToCrystal(point);\n\t\t\tpoint.x -= x;\n\t\t\tpoint.y -= y;\n\t\t\tpoint.z -= z;\n\t\t\ttransfToOrthonormal(point);\n\t\t}\n\t}\n\n\t/**\n\t * Transform given Matrix4d in crystal basis to the orthonormal basis using\n\t * the PDB axes convention (NCODE=1)\n\t * @param m\n\t * @return\n\t */\n\tpublic Matrix4d transfToOrthonormal(Matrix4d m) {\n\t\tVector3d trans = new Vector3d(m.m03,m.m13,m.m23);\n\t\ttransfToOrthonormal(trans);\n\n\t\tMatrix3d rot = new Matrix3d();\n\t\tm.getRotationScale(rot);\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1\n\t\t// Rprime = MT-1 * R * MT\n\t\trot.mul(this.getMTranspose());\n\t\trot.mul(this.getMTransposeInv(),rot);\n\n\t\treturn new Matrix4d(rot,trans,1.0);\n\t}\n\n\t/**\n\t * Transforms the given crystal basis coordinates into orthonormal coordinates.\n\t * e.g. transfToOrthonormal(new Point3d(1,1,1)) returns the orthonormal coordinates of the \n\t * vertex of the unit cell.\n\t * See Giacovazzo section 2.E, eq. 2.E.1 (or any linear algebra manual) \n\t * @param v\n\t */\n\tpublic void transfToOrthonormal(Tuple3d v) {\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1\n\t\tgetMTransposeInv().transform(v);\n\t}\n\t\n\t/**\n\t * Transform given Matrix4d in orthonormal basis to the crystal basis using\n\t * the PDB axes convention (NCODE=1)\n\t * @param m\n\t * @return\n\t */\n\tpublic Matrix4d transfToCrystal(Matrix4d m) {\n\t\tVector3d trans = new Vector3d(m.m03,m.m13,m.m23);\n\t\ttransfToCrystal(trans);\n\t\t\n\t\tMatrix3d rot = new Matrix3d();\n\t\tm.getRotationScale(rot);\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1 (the inverse equation)\n\t\t// R = MT * Rprime * MT-1\n\t\trot.mul(this.getMTransposeInv());\n\t\trot.mul(this.getMTranspose(),rot);\n\n\t\treturn new Matrix4d(rot,trans,1.0);\t\t\n\t}\n\t\n\t/**\n\t * Transforms the given orthonormal basis coordinates into crystal coordinates.\n\t * See Giacovazzo eq 2.20 (or any linear algebra manual)\n\t * @param v\n\t */\n\tpublic void transfToCrystal(Tuple3d v) {\n\t\tgetMTranspose().transform(v);\n\t}\n\t\n\t/**\n\t * Returns the change of basis (crystal to orthonormal) transform matrix, that is \n\t * M inverse in the notation of Giacovazzo. \n\t * Using the PDB axes convention \n\t * (CCP4 uses NCODE identifiers to distinguish the different conventions, the PDB one is called NCODE=1) \n\t * The matrix is only calculated upon first call of this method, thereafter it is cached.\n\t * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5 (eq 2.30)\n\t * \n\t * The non-standard orthogonalisation codes (NCODE for ccp4) are flagged in REMARK 285 after 2011's remediation\n\t * with text: \"THE ENTRY COORDINATES ARE NOT PRESENTED IN THE STANDARD CRYSTAL FRAME\". There were only 148 PDB\n\t * entries with non-standard code in 2011. See:\n\t * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf \n     * The SCALE1,2,3 records contain the correct transformation matrix (what Giacovazzo calls M matrix). \n     * In those cases if we calculate the M matrix following Giacovazzo's equations here, we get an entirely wrong one.  \n     * Examples of PDB with non-standard orthogonalisation are 1bab and 1bbb.\n\t * @return\n\t */\n\tprivate Matrix3d getMInv() {\n\t\tif (Minv!=null) {\n\t\t\treturn Minv;\n\t\t}\n\n\t\t// see eq. 2.30 Giacovazzo \n\t\tMinv =  new Matrix3d(                    this.a,                                           0,              0,\n\t\t\t\t\t\t\t  this.b*Math.cos(gammaRad),                   this.b*Math.sin(gammaRad),              0,\n\t\t\t\t\t\t\t  this.c*Math.cos(betaRad) , -this.c*Math.sin(betaRad)*getCosAlphaStar(),  1.0/getCstar());\n\t\treturn Minv;\n\t}\n\n\t// another axes convention (from Giacovazzo) eq. 2.31b, not sure what would be the NCODE of this\n//\tprivate Matrix3d getMInv() {\n//\t\tif (Minv!=null) {\n//\t\t\treturn Minv;\n//\t\t}\n//\t\tMinv = new Matrix3d( 1/getAstar(),  -(getCosGammaStar()/getSinGammaStar())/getAstar(), this.a*Math.cos(betaRad),\n//\t\t\t\t                        0,                   1/(getBstar()*getSinGammaStar()), this.b*Math.sin(alphaRad),\n//\t\t\t\t                        0,                                                  0,                  this.c);\n//\t\treturn Minv;\n//\t}\n\t\n\t// and yet another axes convention (from Giacovazzo) eq. 2.31c, not sure what would be the NCODE of this\n//\tprivate Matrix3d getMInv() {\n//\t\tif (Minv!=null) {\n//\t\t\treturn Minv;\n//\t\t}\n//\t\tMinv = new Matrix3d( alphaRad*Math.sin(gammaRad)*getSinBetaStar(), this.a*Math.cos(gammaRad), this.a*Math.sin(gammaRad)*getCosBetaStar(),\n//\t\t\t\t                                                        0,                    this.b,                                          0,\n//\t\t\t\t                                                        0, this.c*Math.cos(alphaRad),                   this.c*Math.sin(alphaRad));\n//\t\treturn Minv;\n//\t}\n\t\n\t// relationships among direct and reciprocal lattice parameters\n\t// see Table 2.1 of chapter 2 of Giacovazzo\n\t@SuppressWarnings(\"unused\")\n\tprivate double getAstar() {\n\t\treturn (this.b*this.c*Math.sin(alphaRad))/getVolume();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getBstar() {\n\t\treturn (this.a*this.c*Math.sin(betaRad))/getVolume();\n\t}\n\t\n\tprivate double getCstar() {\n\t\treturn (this.a*this.b*Math.sin(gammaRad))/getVolume();\n\t}\n\t\n\tprivate double getCosAlphaStar() {\n\t\treturn (Math.cos(betaRad)*Math.cos(gammaRad)-Math.cos(alphaRad))/(Math.sin(betaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getCosBetaStar() {\n\t\treturn (Math.cos(alphaRad)*Math.cos(gammaRad)-Math.cos(betaRad))/(Math.sin(alphaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getCosGammaStar() {\n\t\treturn (Math.cos(alphaRad)*Math.cos(betaRad)-Math.cos(gammaRad))/(Math.sin(alphaRad)*Math.sin(betaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinAlphaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(betaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinBetaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(alphaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinGammaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(alphaRad)*Math.sin(betaRad));\n\t}\n\t\n\t/**\n\t * Returns the change of basis (orthonormal to crystal) transform matrix, that is\n\t * M in the notation of Giacovazzo.\n\t * Using the PDB convention (NCODE=1).\n\t * The matrix is only calculated upon first call of this method, thereafter it is cached. \n\t * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5 \n\t * @return\n\t */\n\tprivate Matrix3d getM() {\n\t\tif (M!=null){\n\t\t\treturn M;\n\t\t}\n\t\tM = new Matrix3d();\n\t\tM.invert(getMInv());\n\t\treturn M;\n\t}\n\t\n\tpublic Matrix3d getMTranspose() {\n\t\tif (Mtransp!=null){\n\t\t\treturn Mtransp;\n\t\t}\n\t\tMatrix3d M = getM();\n\t\tMtransp = new Matrix3d();\n\t\tMtransp.transpose(M);\n\t\treturn Mtransp;\n\t}\n\t\n\tprivate Matrix3d getMTransposeInv() {\n\t\tif (MtranspInv!=null){\n\t\t\treturn MtranspInv;\n\t\t}\n\t\tMtranspInv = new Matrix3d();\n\t\tMtranspInv.invert(getMTranspose());\n\t\treturn MtranspInv;\n\t}\n\t\n\t/**\n\t * Gets the maximum dimension of the unit cell.\n\t * @return\n\t */\n\tpublic double getMaxDimension() {\n\t\tif (maxDimension!=0) {\n\t\t\treturn maxDimension;\n\t\t}\n\t\tPoint3d vert0 = new Point3d(0,0,0);\n\t\tPoint3d vert1 = new Point3d(1,0,0);\n\t\ttransfToOrthonormal(vert1);\n\t\tPoint3d vert2 = new Point3d(0,1,0);\n\t\ttransfToOrthonormal(vert2);\n\t\tPoint3d vert3 = new Point3d(0,0,1);\n\t\ttransfToOrthonormal(vert3);\n\t\tPoint3d vert4 = new Point3d(1,1,0);\n\t\ttransfToOrthonormal(vert4);\n\t\tPoint3d vert5 = new Point3d(1,0,1);\n\t\ttransfToOrthonormal(vert5);\n\t\tPoint3d vert6 = new Point3d(0,1,1);\n\t\ttransfToOrthonormal(vert6);\n\t\tPoint3d vert7 = new Point3d(1,1,1);\n\t\ttransfToOrthonormal(vert7);\n\n\t\tArrayList<Double> vertDists = new ArrayList<Double>();\n\t\tvertDists.add(vert0.distance(vert7));\n\t\tvertDists.add(vert3.distance(vert4));\n\t\tvertDists.add(vert1.distance(vert6));\n\t\tvertDists.add(vert2.distance(vert5));\n\t\tmaxDimension = Collections.max(vertDists);\n\t\treturn maxDimension;\n\t}\n\t\n\t/**\n\t * Given a scale matrix parsed from the PDB entry (SCALE1,2,3 records),\n\t * checks that the matrix is a consistent scale matrix by comparing the\n\t * cell volume to the inverse of the scale matrix determinant (tolerance of 1/100).\n\t * If they don't match false is returned.\n\t * See the PDB documentation for the SCALE record.\n\t * See also last equation of section 2.5 of \"Fundamentals of Crystallography\" C. Giacovazzo\n\t * @param scaleMatrix\n\t * @return\n\t */\n\tpublic boolean checkScaleMatrixConsistency(Matrix4d scaleMatrix) {\n\n\t\tdouble vol = getVolume();\n\t\tMatrix3d m = new Matrix3d();\n\t\tscaleMatrix.getRotationScale(m);\n\n\t\t// note we need to have a relaxed tolerance here as the PDB scale matrix is given with not such high precision\n\t\t// plus we don't want to have false positives, so we stay conservative\n\t\tdouble tolerance = vol/100.0;\t\t\n\t\tif ((Math.abs(vol - 1.0/m.determinant() )>tolerance)) { \n\t\t\t//System.err.println(\"Warning! SCALE matrix from PDB does not match 1/determinat == cell volume: \"+\n\t\t\t//\t\tString.format(\"vol=%6.3f  1/det=%6.3f\",vol,1.0/m.determinant()));\n\t\t\treturn false;\n\t\t}\n\t\t// this would be to check our own matrix, must always match!\n\t\t//if (!deltaComp(vol,1.0/getMTranspose().determinant())) {\n\t\t//\tSystem.err.println(\"Our calculated SCALE matrix does not match 1/det=cell volume\");\n\t\t//}\n\n\t\treturn true;\n\t\t\n\t}\n\t\n\t/**\n\t * Given a scale matrix parsed from a PDB entry (SCALE1,2,3 records), \n\t * compares it to our calculated Mtranspose matrix to see if they coincide and \n\t * returns true if they do.\n\t * If they don't that means that the PDB entry is not in the standard\n\t * orthogonalisation (NCODE=1 in ccp4).\n\t * In 2011's remediation only 148 PDB entries were found not to be in\n\t * a non-standard orthogonalisation. See:\n\t * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf\n\t * For normal cases the scale matrix is diagonal without a translation component.\n\t * Additionally the translation component of the SCALE matrix is also checked to \n\t * make sure it is (0,0,0), if not false is return\n\t * @param scaleMatrix\n\t * @return\n\t */\n\tpublic boolean checkScaleMatrix(Matrix4d scaleMatrix) {\n\t\t\n\t\tfor (int i=0;i<3;i++) {\n\t\t\tfor (int j=0;j<3;j++) {\n\t\t\t\tif (!deltaComp(getMTranspose().getElement(i, j),scaleMatrix.getElement(i, j))) {\n\t\t\t\t\t//System.out.println(\"Our value   (\"+i+\",\"+j+\"): \"+getM().getElement(i,j));\n\t\t\t\t\t//System.out.println(\"Their value (\"+i+\",\"+j+\"): \"+scaleMatrix.getElement(i,j));\n\t\t\t\t\treturn false;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<3;i++) {\n\t\t\tif (!deltaComp(scaleMatrix.getElement(i, 3),0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate boolean deltaComp(double d1, double d2) {\n\t\tif (Math.abs(d1-d2)<0.0001) return true;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks whether the dimensions of this crystal cell are reasonable for protein \n\t * crystallography: if all 3 dimensions are below {@value #MIN_VALID_CELL_SIZE} the cell \n\t * is considered unrealistic and false returned\n\t * @return\n\t */\n\tpublic boolean isCellReasonable() {\n\t\t// this check is necessary mostly when reading PDB files that can contain the default 1 1 1 crystal cell\n\t\t// if we use that further things can go wrong, for instance for interface calculation\n\t\t// For instance programs like coot produce by default a 1 1 1 cell \n\t\t\n\t\tif (this.getA()<MIN_VALID_CELL_SIZE &&\n\t\t\t\tthis.getB()<MIN_VALID_CELL_SIZE &&\n\t\t\t\tthis.getC()<MIN_VALID_CELL_SIZE) {\n\t\t\tlogger.warn(\"Warning! crystal cell with 3 dimensions below \"+MIN_VALID_CELL_SIZE+\". Will ignore it.\");\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"a%7.2f b%7.2f c%7.2f alpha%6.2f beta%6.2f gamma%6.2f\", a, b, c, alpha, beta, gamma);\n\t}\n}","changedPro":"package org.biojava.bio.structure.xtal;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nimport javax.vecmath.Matrix3d;\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Point3i;\nimport javax.vecmath.Tuple3d;\nimport javax.vecmath.Vector3d;\n\n//import org.slf4j.Logger;\n//import org.slf4j.LoggerFactory;\n\n/**\n * A crystal cell's parameters.\n * \n * @author duarte_j\n *\n */\npublic class CrystalCell implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\t//private static final Logger logger = LoggerFactory.getLogger(CrystalCell.class);\n\n\tpublic static final double MIN_VALID_CELL_SIZE = 10.0; // the minimum admitted for a crystal cell\n\n\t\n\tprivate double a;\n\tprivate double b;\n\tprivate double c;\n\t\n\tprivate double alpha;\n\tprivate double beta;\n\tprivate double gamma;\n\t\n\tprivate double alphaRad;\n\tprivate double betaRad;\n\tprivate double gammaRad;\n\t\n\tprivate double volume; // cached volume\n\t\n\tprivate double maxDimension; // cached max dimension\n\n\tprivate Matrix3d M; \t// cached basis change transformation matrix\n\tprivate Matrix3d Minv;  // cached basis change transformation matrix\n\tprivate Matrix3d Mtransp;\n\tprivate Matrix3d MtranspInv;\n\t\n\tpublic CrystalCell() {\n\t\t\n\t}\n\t\n\tpublic CrystalCell(double a, double b, double c, double alpha, double beta, double gamma){\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\t\tthis.setAlpha(alpha); // initialises both alpha and alphaRad\n\t\tthis.setBeta(beta);\n\t\tthis.setGamma(gamma);\n\t}\n\n\tpublic double getA() {\n\t\treturn a;\n\t}\n\n\tpublic void setA(double a) {\n\t\tthis.a = a;\n\t}\n\n\tpublic double getB() {\n\t\treturn b;\n\t}\n\n\tpublic void setB(double b) {\n\t\tthis.b = b;\n\t}\n\n\tpublic double getC() {\n\t\treturn c;\n\t}\n\n\tpublic void setC(double c) {\n\t\tthis.c = c;\n\t}\n\n\tpublic double getAlpha() {\n\t\treturn alpha;\n\t}\n\n\tpublic void setAlpha(double alpha) {\n\t\tthis.alpha = alpha;\n\t\tthis.alphaRad = Math.toRadians(alpha);\n\t}\n\n\tpublic double getBeta() {\n\t\treturn beta;\n\t}\n\n\tpublic void setBeta(double beta) {\n\t\tthis.beta = beta;\n\t\tthis.betaRad = Math.toRadians(beta);\n\t}\n\n\tpublic double getGamma() {\n\t\treturn gamma;\n\t}\n\n\tpublic void setGamma(double gamma) {\n\t\tthis.gamma = gamma;\n\t\tthis.gammaRad = Math.toRadians(gamma);\n\t}\n\t\n\t/**\n\t * Returns the volume of this unit cell.\n\t * See http://en.wikipedia.org/wiki/Parallelepiped\n\t * @return\n\t */\n\tpublic double getVolume() {\n\t\tif (volume!=0) {\n\t\t\treturn volume;\n\t\t}\n\t\tvolume =  a*b*c*\n\t\tMath.sqrt(1-Math.cos(alphaRad)*Math.cos(alphaRad)-Math.cos(betaRad)*Math.cos(betaRad)-Math.cos(gammaRad)*Math.cos(gammaRad)\n\t\t\t\t+2.0*Math.cos(alphaRad)*Math.cos(betaRad)*Math.cos(gammaRad));\n\t\t\n\t\treturn volume;\n\t}\n\t\n\t/**\n\t * Get the index of a unit cell to which the query point belongs.\n\t * \n\t * <p>For instance, all points in the unit cell at the origin will return (0,0,0);\n\t * Points in the unit cell one unit further along the `a` axis will return (1,0,0),\n\t * etc.\n\t * @param pt Input point\n\t * @return A new point with the three indices of the cell containing pt\n\t */\n\tpublic Point3i getCellIndices(Tuple3d pt) {\n\t\tPoint3d p = new Point3d(pt);\n\t\tthis.transfToCrystal(p);\n\n\t\tint x = (int)Math.floor(p.x);\n\t\tint y = (int)Math.floor(p.y);\n\t\tint z = (int)Math.floor(p.z);\n\t\treturn new Point3i(x,y,z);\n\t}\n\n\t/**\n\t * Converts the coordinates in pt so that they occur within the (0,0,0) unit cell\n\t * @param pt\n\t */\n\tpublic void transfToOriginCell(Tuple3d pt) {\n\t\ttransfToCrystal(pt);\n\n\t\t// convert all coordinates to [0,1) interval\n\t\tpt.x = pt.x<0 ? (pt.x%1.0 + 1.0)%1.0 : pt.x%1.0;\n\t\tpt.y = pt.y<0 ? (pt.y%1.0 + 1.0)%1.0 : pt.y%1.0;\n\t\tpt.z = pt.z<0 ? (pt.z%1.0 + 1.0)%1.0 : pt.z%1.0;\n\n\t\ttransfToOrthonormal(pt);\n\t}\n\n\t/**\n\t * Converts a set of points so that the reference point falls in the unit cell.\n\t *\n\t * This is useful to transform a whole chain at once, allowing some of the\n\t * atoms to be outside the unit cell, but forcing the centroid to be within it.\n\t *\n\t * @param points A set of points to transform\n\t * @param reference The reference point, which is unmodified but which would\n\t *    be in the unit cell were it to have been transformed. It is safe to\n\t *    use a member of the points array here.\n\t */\n\tpublic void transfToOriginCell(Tuple3d[] points, Tuple3d reference) {\n\t\treference = new Point3d(reference);//clone\n\t\ttransfToCrystal(reference);\n\n\t\tint x = (int)Math.floor(reference.x);\n\t\tint y = (int)Math.floor(reference.y);\n\t\tint z = (int)Math.floor(reference.z);\n\n\t\tfor( Tuple3d point: points ) {\n\t\t\ttransfToCrystal(point);\n\t\t\tpoint.x -= x;\n\t\t\tpoint.y -= y;\n\t\t\tpoint.z -= z;\n\t\t\ttransfToOrthonormal(point);\n\t\t}\n\t}\n\n\t/**\n\t * Transform given Matrix4d in crystal basis to the orthonormal basis using\n\t * the PDB axes convention (NCODE=1)\n\t * @param m\n\t * @return\n\t */\n\tpublic Matrix4d transfToOrthonormal(Matrix4d m) {\n\t\tVector3d trans = new Vector3d(m.m03,m.m13,m.m23);\n\t\ttransfToOrthonormal(trans);\n\n\t\tMatrix3d rot = new Matrix3d();\n\t\tm.getRotationScale(rot);\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1\n\t\t// Rprime = MT-1 * R * MT\n\t\trot.mul(this.getMTranspose());\n\t\trot.mul(this.getMTransposeInv(),rot);\n\n\t\treturn new Matrix4d(rot,trans,1.0);\n\t}\n\n\t/**\n\t * Transforms the given crystal basis coordinates into orthonormal coordinates.\n\t * e.g. transfToOrthonormal(new Point3d(1,1,1)) returns the orthonormal coordinates of the \n\t * vertex of the unit cell.\n\t * See Giacovazzo section 2.E, eq. 2.E.1 (or any linear algebra manual) \n\t * @param v\n\t */\n\tpublic void transfToOrthonormal(Tuple3d v) {\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1\n\t\tgetMTransposeInv().transform(v);\n\t}\n\t\n\t/**\n\t * Transform given Matrix4d in orthonormal basis to the crystal basis using\n\t * the PDB axes convention (NCODE=1)\n\t * @param m\n\t * @return\n\t */\n\tpublic Matrix4d transfToCrystal(Matrix4d m) {\n\t\tVector3d trans = new Vector3d(m.m03,m.m13,m.m23);\n\t\ttransfToCrystal(trans);\n\t\t\n\t\tMatrix3d rot = new Matrix3d();\n\t\tm.getRotationScale(rot);\n\t\t// see Giacovazzo section 2.E, eq. 2.E.1 (the inverse equation)\n\t\t// R = MT * Rprime * MT-1\n\t\trot.mul(this.getMTransposeInv());\n\t\trot.mul(this.getMTranspose(),rot);\n\n\t\treturn new Matrix4d(rot,trans,1.0);\t\t\n\t}\n\t\n\t/**\n\t * Transforms the given orthonormal basis coordinates into crystal coordinates.\n\t * See Giacovazzo eq 2.20 (or any linear algebra manual)\n\t * @param v\n\t */\n\tpublic void transfToCrystal(Tuple3d v) {\n\t\tgetMTranspose().transform(v);\n\t}\n\t\n\t/**\n\t * Returns the change of basis (crystal to orthonormal) transform matrix, that is \n\t * M inverse in the notation of Giacovazzo. \n\t * Using the PDB axes convention \n\t * (CCP4 uses NCODE identifiers to distinguish the different conventions, the PDB one is called NCODE=1) \n\t * The matrix is only calculated upon first call of this method, thereafter it is cached.\n\t * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5 (eq 2.30)\n\t * \n\t * The non-standard orthogonalisation codes (NCODE for ccp4) are flagged in REMARK 285 after 2011's remediation\n\t * with text: \"THE ENTRY COORDINATES ARE NOT PRESENTED IN THE STANDARD CRYSTAL FRAME\". There were only 148 PDB\n\t * entries with non-standard code in 2011. See:\n\t * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf \n     * The SCALE1,2,3 records contain the correct transformation matrix (what Giacovazzo calls M matrix). \n     * In those cases if we calculate the M matrix following Giacovazzo's equations here, we get an entirely wrong one.  \n     * Examples of PDB with non-standard orthogonalisation are 1bab and 1bbb.\n\t * @return\n\t */\n\tprivate Matrix3d getMInv() {\n\t\tif (Minv!=null) {\n\t\t\treturn Minv;\n\t\t}\n\n\t\t// see eq. 2.30 Giacovazzo \n\t\tMinv =  new Matrix3d(                    this.a,                                           0,              0,\n\t\t\t\t\t\t\t  this.b*Math.cos(gammaRad),                   this.b*Math.sin(gammaRad),              0,\n\t\t\t\t\t\t\t  this.c*Math.cos(betaRad) , -this.c*Math.sin(betaRad)*getCosAlphaStar(),  1.0/getCstar());\n\t\treturn Minv;\n\t}\n\n\t// another axes convention (from Giacovazzo) eq. 2.31b, not sure what would be the NCODE of this\n//\tprivate Matrix3d getMInv() {\n//\t\tif (Minv!=null) {\n//\t\t\treturn Minv;\n//\t\t}\n//\t\tMinv = new Matrix3d( 1/getAstar(),  -(getCosGammaStar()/getSinGammaStar())/getAstar(), this.a*Math.cos(betaRad),\n//\t\t\t\t                        0,                   1/(getBstar()*getSinGammaStar()), this.b*Math.sin(alphaRad),\n//\t\t\t\t                        0,                                                  0,                  this.c);\n//\t\treturn Minv;\n//\t}\n\t\n\t// and yet another axes convention (from Giacovazzo) eq. 2.31c, not sure what would be the NCODE of this\n//\tprivate Matrix3d getMInv() {\n//\t\tif (Minv!=null) {\n//\t\t\treturn Minv;\n//\t\t}\n//\t\tMinv = new Matrix3d( alphaRad*Math.sin(gammaRad)*getSinBetaStar(), this.a*Math.cos(gammaRad), this.a*Math.sin(gammaRad)*getCosBetaStar(),\n//\t\t\t\t                                                        0,                    this.b,                                          0,\n//\t\t\t\t                                                        0, this.c*Math.cos(alphaRad),                   this.c*Math.sin(alphaRad));\n//\t\treturn Minv;\n//\t}\n\t\n\t// relationships among direct and reciprocal lattice parameters\n\t// see Table 2.1 of chapter 2 of Giacovazzo\n\t@SuppressWarnings(\"unused\")\n\tprivate double getAstar() {\n\t\treturn (this.b*this.c*Math.sin(alphaRad))/getVolume();\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getBstar() {\n\t\treturn (this.a*this.c*Math.sin(betaRad))/getVolume();\n\t}\n\t\n\tprivate double getCstar() {\n\t\treturn (this.a*this.b*Math.sin(gammaRad))/getVolume();\n\t}\n\t\n\tprivate double getCosAlphaStar() {\n\t\treturn (Math.cos(betaRad)*Math.cos(gammaRad)-Math.cos(alphaRad))/(Math.sin(betaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getCosBetaStar() {\n\t\treturn (Math.cos(alphaRad)*Math.cos(gammaRad)-Math.cos(betaRad))/(Math.sin(alphaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getCosGammaStar() {\n\t\treturn (Math.cos(alphaRad)*Math.cos(betaRad)-Math.cos(gammaRad))/(Math.sin(alphaRad)*Math.sin(betaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinAlphaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(betaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinBetaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(alphaRad)*Math.sin(gammaRad));\n\t}\n\t\n\t@SuppressWarnings(\"unused\")\n\tprivate double getSinGammaStar() {\n\t\treturn getVolume()/(this.a*this.b*this.c*Math.sin(alphaRad)*Math.sin(betaRad));\n\t}\n\t\n\t/**\n\t * Returns the change of basis (orthonormal to crystal) transform matrix, that is\n\t * M in the notation of Giacovazzo.\n\t * Using the PDB convention (NCODE=1).\n\t * The matrix is only calculated upon first call of this method, thereafter it is cached. \n\t * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5 \n\t * @return\n\t */\n\tprivate Matrix3d getM() {\n\t\tif (M!=null){\n\t\t\treturn M;\n\t\t}\n\t\tM = new Matrix3d();\n\t\tM.invert(getMInv());\n\t\treturn M;\n\t}\n\t\n\tpublic Matrix3d getMTranspose() {\n\t\tif (Mtransp!=null){\n\t\t\treturn Mtransp;\n\t\t}\n\t\tMatrix3d M = getM();\n\t\tMtransp = new Matrix3d();\n\t\tMtransp.transpose(M);\n\t\treturn Mtransp;\n\t}\n\t\n\tprivate Matrix3d getMTransposeInv() {\n\t\tif (MtranspInv!=null){\n\t\t\treturn MtranspInv;\n\t\t}\n\t\tMtranspInv = new Matrix3d();\n\t\tMtranspInv.invert(getMTranspose());\n\t\treturn MtranspInv;\n\t}\n\t\n\t/**\n\t * Gets the maximum dimension of the unit cell.\n\t * @return\n\t */\n\tpublic double getMaxDimension() {\n\t\tif (maxDimension!=0) {\n\t\t\treturn maxDimension;\n\t\t}\n\t\tPoint3d vert0 = new Point3d(0,0,0);\n\t\tPoint3d vert1 = new Point3d(1,0,0);\n\t\ttransfToOrthonormal(vert1);\n\t\tPoint3d vert2 = new Point3d(0,1,0);\n\t\ttransfToOrthonormal(vert2);\n\t\tPoint3d vert3 = new Point3d(0,0,1);\n\t\ttransfToOrthonormal(vert3);\n\t\tPoint3d vert4 = new Point3d(1,1,0);\n\t\ttransfToOrthonormal(vert4);\n\t\tPoint3d vert5 = new Point3d(1,0,1);\n\t\ttransfToOrthonormal(vert5);\n\t\tPoint3d vert6 = new Point3d(0,1,1);\n\t\ttransfToOrthonormal(vert6);\n\t\tPoint3d vert7 = new Point3d(1,1,1);\n\t\ttransfToOrthonormal(vert7);\n\n\t\tArrayList<Double> vertDists = new ArrayList<Double>();\n\t\tvertDists.add(vert0.distance(vert7));\n\t\tvertDists.add(vert3.distance(vert4));\n\t\tvertDists.add(vert1.distance(vert6));\n\t\tvertDists.add(vert2.distance(vert5));\n\t\tmaxDimension = Collections.max(vertDists);\n\t\treturn maxDimension;\n\t}\n\t\n\t/**\n\t * Given a scale matrix parsed from the PDB entry (SCALE1,2,3 records),\n\t * checks that the matrix is a consistent scale matrix by comparing the\n\t * cell volume to the inverse of the scale matrix determinant (tolerance of 1/100).\n\t * If they don't match false is returned.\n\t * See the PDB documentation for the SCALE record.\n\t * See also last equation of section 2.5 of \"Fundamentals of Crystallography\" C. Giacovazzo\n\t * @param scaleMatrix\n\t * @return\n\t */\n\tpublic boolean checkScaleMatrixConsistency(Matrix4d scaleMatrix) {\n\n\t\tdouble vol = getVolume();\n\t\tMatrix3d m = new Matrix3d();\n\t\tscaleMatrix.getRotationScale(m);\n\n\t\t// note we need to have a relaxed tolerance here as the PDB scale matrix is given with not such high precision\n\t\t// plus we don't want to have false positives, so we stay conservative\n\t\tdouble tolerance = vol/100.0;\t\t\n\t\tif ((Math.abs(vol - 1.0/m.determinant() )>tolerance)) { \n\t\t\t//System.err.println(\"Warning! SCALE matrix from PDB does not match 1/determinat == cell volume: \"+\n\t\t\t//\t\tString.format(\"vol=%6.3f  1/det=%6.3f\",vol,1.0/m.determinant()));\n\t\t\treturn false;\n\t\t}\n\t\t// this would be to check our own matrix, must always match!\n\t\t//if (!deltaComp(vol,1.0/getMTranspose().determinant())) {\n\t\t//\tSystem.err.println(\"Our calculated SCALE matrix does not match 1/det=cell volume\");\n\t\t//}\n\n\t\treturn true;\n\t\t\n\t}\n\t\n\t/**\n\t * Given a scale matrix parsed from a PDB entry (SCALE1,2,3 records), \n\t * compares it to our calculated Mtranspose matrix to see if they coincide and \n\t * returns true if they do.\n\t * If they don't that means that the PDB entry is not in the standard\n\t * orthogonalisation (NCODE=1 in ccp4).\n\t * In 2011's remediation only 148 PDB entries were found not to be in\n\t * a non-standard orthogonalisation. See:\n\t * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf\n\t * For normal cases the scale matrix is diagonal without a translation component.\n\t * Additionally the translation component of the SCALE matrix is also checked to \n\t * make sure it is (0,0,0), if not false is return\n\t * @param scaleMatrix\n\t * @return\n\t */\n\tpublic boolean checkScaleMatrix(Matrix4d scaleMatrix) {\n\t\t\n\t\tfor (int i=0;i<3;i++) {\n\t\t\tfor (int j=0;j<3;j++) {\n\t\t\t\tif (!deltaComp(getMTranspose().getElement(i, j),scaleMatrix.getElement(i, j))) {\n\t\t\t\t\t//System.out.println(\"Our value   (\"+i+\",\"+j+\"): \"+getM().getElement(i,j));\n\t\t\t\t\t//System.out.println(\"Their value (\"+i+\",\"+j+\"): \"+scaleMatrix.getElement(i,j));\n\t\t\t\t\treturn false;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i=0;i<3;i++) {\n\t\t\tif (!deltaComp(scaleMatrix.getElement(i, 3),0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate boolean deltaComp(double d1, double d2) {\n\t\tif (Math.abs(d1-d2)<0.0001) return true;\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Checks whether the dimensions of this crystal cell are reasonable for protein \n\t * crystallography: if all 3 dimensions are below {@value #MIN_VALID_CELL_SIZE} the cell \n\t * is considered unrealistic and false returned\n\t * @return\n\t */\n\tpublic boolean isCellReasonable() {\n\t\t// this check is necessary mostly when reading PDB files that can contain the default 1 1 1 crystal cell\n\t\t// if we use that further things can go wrong, for instance for interface calculation\n\t\t// For instance programs like coot produce by default a 1 1 1 cell \n\t\t\n\t\tif (this.getA()<MIN_VALID_CELL_SIZE &&\n\t\t\t\tthis.getB()<MIN_VALID_CELL_SIZE &&\n\t\t\t\tthis.getC()<MIN_VALID_CELL_SIZE) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t\t\n\t}\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"a%7.2f b%7.2f c%7.2f alpha%6.2f beta%6.2f gamma%6.2f\", a, b, c, alpha, beta, gamma);\n\t}\n}","originTest":"package org.biojava.bio.structure.xtal;\n\nimport static org.junit.Assert.*;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Point3i;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\npublic class TestCrystalCell {\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t}\n\n\t@Test\n\tpublic void testGetCellIndices() {\n\t\tCrystalCell cell = new CrystalCell(100, 100, 100, 90, 90, 45);\n\n\t\tPoint3i result,expected;\n\t\tPoint3d query;\n\n\t\tquery = new Point3d(0,0,0);\n\t\texpected = new Point3i(0,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(99.9,0,0);\n\t\texpected = new Point3i(0,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(100,0,0);\n\t\texpected = new Point3i(1,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(0,50,0);\n\t\texpected = new Point3i(-1,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(51,50,0);\n\t\texpected = new Point3i(0,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(72,71,0);\n\t\texpected = new Point3i(0,1,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(500,0,0);\n\t\texpected = new Point3i(5,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(-500,0,0);\n\t\texpected = new Point3i(-5,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(-550,0,0);\n\t\texpected = new Point3i(-6,0,0);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\n\t\tquery = new Point3d(2,1,500);\n\t\texpected = new Point3i(0,0,5);\n\t\tresult = cell.getCellIndices(query);\n\t\tassertEquals(\"Wrong index for \"+query,expected,result);\n\t}\n\n\t@Test\n\tpublic void testTransformToOrigin() {\n\t\tCrystalCell cell = new CrystalCell(100, 100, 100, 90, 90, 45);\n\t\tdouble h = 100/Math.sqrt(2);\n\t\tdouble tol = 1e-6;\n\n\t\tPoint3d query,expected;\n\n\n\t\t// Note that the 0 boundaries are instable\n\t\t// If tests break, it's ok to move into the cell (e.g. <2,1,1> is unambiguous)\n\t\tquery = new Point3d(0,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(99.9,0,0);\n\t\texpected = new Point3d(99.9,0,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(100,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(0,50,0);\n\t\texpected = new Point3d(100,50,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(51,50,0);\n\t\texpected = new Point3d(51,50,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(h+2,h+1,0);\n\t\texpected = new Point3d(2,1,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(500,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(-500,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(2,1,500);\n\t\texpected = new Point3d(2,1,0);\n\t\tcell.transfToOriginCell(query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\t}\n\n\t@Test\n\tpublic void testTransformToOriginArray() {\n\t\tCrystalCell cell = new CrystalCell(100, 100, 100, 90, 90, 45);\n\t\tdouble h = 100/Math.sqrt(2);\n\t\tdouble tol = 1e-6;\n\n\t\tPoint3d query,expected;\n\n\n\t\t// Note that the 0 boundaries are instable\n\t\t// If tests break, it's ok to move into the cell (e.g. <2,1,1> is unambiguous)\n\t\tquery = new Point3d(0,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(99.9,0,0);\n\t\texpected = new Point3d(99.9,0,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(100,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(0,50,0);\n\t\texpected = new Point3d(100,50,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(51,50,0);\n\t\texpected = new Point3d(51,50,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(h+2,h+1,0);\n\t\texpected = new Point3d(2,1,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(500,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(-500,0,0);\n\t\texpected = new Point3d(0,0,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\n\t\tquery = new Point3d(2,1,500);\n\t\texpected = new Point3d(2,1,0);\n\t\tcell.transfToOriginCell(new Point3d[] {query}, query);\n\t\tassertTrue(\"Error transforming to origin. Expected:\"+expected+\" but was:\"+query, expected.epsilonEquals(query, tol));\n\t}\n\n}\n","changedTest":"","commitMessage":"Dealing better with unreasonable crystal cells","test_commitMessage":"","allZero":false}