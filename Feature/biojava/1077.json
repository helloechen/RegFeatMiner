{"repository":"biojava","prod_path":"biojava-protein-disorder/src/main/java/org/biojava/nbio/ronn/Jronn.java","test_path":"biojava-protein-disorder/src/test/java/org/biojava/nbio/ronn/JronnTest.java","prod_time":"2023-05-21 23:40:41","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":1,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":1,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"86307e962b30dc805cf3b1476133985120600037","test_commitID":"","isfound":"not found test change","originPro":"/*        BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.ronn;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.data.sequence.FastaSequence;\nimport org.biojava.nbio.data.sequence.SequenceUtil;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\n\n\n/**\n * This class gives public API to RONN functions.\n * It is build on top of the command line client. Due to this fact a few things\n * could be improved and extended pending the refactoring of the command line client.\n *\n * The input sequence limitations - the input sequence must not contain any ambiguous characters,\n * and have a minimum length of 19 amino acids.\n *\n * @author Peter Troshin\n * @version 1.0\n * @since 3.0.2\n *\n */\npublic class Jronn implements Serializable {\n\n\t/**\n\t *\n\t */\n\tprivate static final long serialVersionUID = 8104272449130849946L;\n\t// Load models\n\tprivate static final ModelLoader loader = new ModelLoader();\n\tstatic {\n\t\ttry {\n\t\t\tloader.loadModels();\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\n\t\t}\n\t}\n\n\n\t/**\n\t * Holder for the ranges, contain pointers to starting and ending position\n\t * on the sequence which comprises a disordered region. Immutable.\n\t * @author pvtroshin\n\t */\n\tpublic static class Range {\n\t\t/**\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\n\t\t */\n\t\tpublic final int from;\n\t\t/**\n\t\t * The range ending position includes the last residue.\n\t\t */\n\t\tpublic final int to;\n\n\t\tpublic final float score;\n\t\tpublic Range(int from, int to, float score) {\n\t\t\tassert from>=0;\n\t\t\tassert from<to;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.score = score;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + from;\n\t\t\tresult = prime * result + to;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tRange other = (Range) obj;\n\t\t\tif (from != other.from)\n\t\t\t\treturn false;\n\t\t\tif (to != other.to)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Calculates the probability value for each residue in the protein sequence,\n\t * telling the probability that the residue belongs to disordered region.\n\t * In general, values greater than 0.5 considered to be in the disordered regions.\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the probability scores for each residue in the sequence\n\t */\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\n\t\t    return predictSerial(sequence);\n\t}\n\n\t/**\n\t * Calculates the probability value for each residue in the protein sequence,\n\t * telling the probability that the residue belongs to disordered region.\n\t * In general, values greater than 0.5 considered to be in the disordered regions.\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the probability scores for each residue in the sequence\n\t */\n\tpublic static float[] getDisorderScores(ProteinSequence sequence) {\n\n\t\tFastaSequence seq = convertProteinSequencetoFasta(sequence);\n\n\t\treturn predictSerial(seq);\n\t}\n\n\t/** Utility method to convert a BioJava ProteinSequence object to the FastaSequence\n\t *  object used internally in JRonn.\n\t *\n\t * @param sequence\n\t * @return\n\t */\n\tpublic static FastaSequence convertProteinSequencetoFasta(ProteinSequence sequence){\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor (AminoAcidCompound compound : sequence) {\n\n\t\t\tString c = compound.getShortName();\n\n\t\t\tif (! SequenceUtil.NON_AA.matcher(c).find()) {\n\t\t\t\tbuf.append(c);\n\t\t\t} else {\n\t\t\t\tbuf.append(\"X\");\n\t\t\t}\n\t\t}\n\n\t\treturn new FastaSequence(sequence.getAccession().getID(),buf.toString());\n\t}\n\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\n\t\tORonn.validateSequenceForRonn(fsequence);\n\t\tORonn ronn;\n\t\tfloat[] disorder = null;\n\t\ttry {\n\t\t\tronn = new ORonn(fsequence, loader);\n\t\t\tdisorder = ronn.call().getMeanScores();\n\t\t} catch (NumberFormatException | IOException e) {\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\n\t\t} \n\t\treturn disorder;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the\n\t * probability of disorder is greater then 0.50.\n\t *\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the array of ranges if there are any residues predicted to have the\n\t * probability of disorder greater then 0.5, null otherwise.\n\t *\n\t */\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\n\t\tfloat[] scores = getDisorderScores(sequence);\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\n\t}\n\n\t/**\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\n\t * @return the array of ranges if there are any residues predicted to have the\n\t * probability of disorder greater then {@code probability}, null otherwise.\n\t */\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\n\t\tassert scores!=null && scores.length>0;\n\t\tassert probability>0 && probability<1;\n\n\t\tint count=0;\n\t\tint regionLen=0;\n\t\tList<Range> ranges = new ArrayList<Range>();\n\t\tfor(float score: scores) {\n\t\t\tcount++;\n\t\t\t// Round to 2 decimal points before comparison\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\n\t\t\tif(score>probability) {\n\t\t\t\tregionLen++;\n\t\t\t} else {\n\t\t\t\tif(regionLen>0) {\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1,score));\n\t\t\t\t}\n\t\t\t\tregionLen=0;\n\t\t\t}\n\t\t}\n\t\t// In case of the range to boundary runs to the very end of the sequence\n\t\tif(regionLen>1) {\n\t\t\tranges.add(new Range(count-regionLen+1, count,scores[scores.length-1]));\n\t\t}\n\t\treturn ranges.toArray(new Range[ranges.size()]);\n\n\t}\n\n\t/**\n\t * Calculates the probability of disorder scores for each residue in the sequence for\n\t * many sequences in the input.\n\t *\n\t * @param sequences the list of the FastaSequence objects\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\n\t * @see #getDisorder(FastaSequence)\n\t */\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\n\t\tresults = sequences.stream().collect(Collectors.toMap(fastaSequence ->  fastaSequence, fastaSequence -> predictSerial(fastaSequence)));\n\t\treturn results;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\n\t *\n\t * @param sequences sequences the list of the FastaSequence objects\n\t * @return\n\t * @see #getDisorder(FastaSequence)\n\t */\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\n\t\tdisorderRanges = sequences.stream().collect(Collectors.toMap(fastaSequence -> fastaSequence, fastaSequence -> getDisorder(fastaSequence) ));\n\t\treturn disorderRanges;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the protein sequence.\n\t * @param fastaFile input file name containing the sequence in FASTA\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\n\t * @throws FileNotFoundException if the input file cannot be found\n\t * @throws IOException of the system cannot access or read from the input file\n\t * @see #getDisorder(FastaSequence)\n\t * @see #Jronn.Range\n\t */\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws FileNotFoundException, IOException {\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\n\t\treturn getDisorder(sequences);\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\n\t *\n\t * @param fastaFile  fully qualified path to the input FASTA file\n\t * @param outputFile file name of the file for the results\n\t * @param threadNumber the number of threads to use, default\n\t * @param controls the format of the result file\n\t * @throws FileNotFoundException if input file in not found\n\t * @throws IOException if the input or the output files cannot be accessed\n\t * @see ORonn.ResultLayout\n\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\n\t\tInputParameters in = new InputParameters();\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\n\t\t//in.setThreadNum(Integer.toString(threadNumber));\n\t\tORonn.predictParallel(sequences, in, loader);\n\t}\n\t*/\n}\n","changedPro":"/*        BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.ronn;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.data.sequence.FastaSequence;\nimport org.biojava.nbio.data.sequence.SequenceUtil;\n\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.stream.Collectors;\n\n\n/**\n * This class gives public API to RONN functions.\n * It is build on top of the command line client. Due to this fact a few things\n * could be improved and extended pending the refactoring of the command line client.\n *\n * The input sequence limitations - the input sequence must not contain any ambiguous characters,\n * and have a minimum length of 19 amino acids.\n *\n * @author Peter Troshin\n * @version 1.0\n * @since 3.0.2\n *\n */\npublic class Jronn implements Serializable {\n\n\t/**\n\t *\n\t */\n\tprivate static final long serialVersionUID = 8104272449130849946L;\n\t// Load models\n\tprivate static final ModelLoader loader = new ModelLoader();\n\tstatic {\n\t\ttry {\n\t\t\tloader.loadModels();\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(\"Fails to load models!\" + e.getMessage(), e);\n\t\t}\n\t}\n\n\n\t/**\n\t * Holder for the ranges, contain pointers to starting and ending position\n\t * on the sequence which comprises a disordered region. Immutable.\n\t * @author pvtroshin\n\t */\n\tpublic static class Range {\n\t\t/**\n\t\t * Range starting position counts from 1 (the first position on the sequence is 1)\n\t\t */\n\t\tpublic final int from;\n\t\t/**\n\t\t * The range ending position includes the last residue.\n\t\t */\n\t\tpublic final int to;\n\n\t\tpublic final float score;\n\t\tpublic Range(int from, int to, float score) {\n\t\t\tassert from>=0;\n\t\t\tassert from<to;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.score = score;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Range\" + \" From:\" + from + \"\\t\" + \"to: \" + to + \"\\n\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + from;\n\t\t\tresult = prime * result + to;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tRange other = (Range) obj;\n\t\t\tif (from != other.from)\n\t\t\t\treturn false;\n\t\t\tif (to != other.to)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Calculates the probability value for each residue in the protein sequence,\n\t * telling the probability that the residue belongs to disordered region.\n\t * In general, values greater than 0.5 considered to be in the disordered regions.\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the probability scores for each residue in the sequence\n\t */\n\tpublic static float[] getDisorderScores(FastaSequence sequence) {\n\t\t    return predictSerial(sequence);\n\t}\n\n\t/**\n\t * Calculates the probability value for each residue in the protein sequence,\n\t * telling the probability that the residue belongs to disordered region.\n\t * In general, values greater than 0.5 considered to be in the disordered regions.\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the probability scores for each residue in the sequence\n\t */\n\tpublic static float[] getDisorderScores(ProteinSequence sequence) {\n\n\t\tFastaSequence seq = convertProteinSequencetoFasta(sequence);\n\n\t\treturn predictSerial(seq);\n\t}\n\n\t/** Utility method to convert a BioJava ProteinSequence object to the FastaSequence\n\t *  object used internally in JRonn.\n\t *\n\t * @param sequence\n\t * @return\n\t */\n\tpublic static FastaSequence convertProteinSequencetoFasta(ProteinSequence sequence){\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor (AminoAcidCompound compound : sequence) {\n\n\t\t\tString c = compound.getShortName();\n\n\t\t\tif (! SequenceUtil.NON_AA.matcher(c).find()) {\n\t\t\t\tbuf.append(c);\n\t\t\t} else {\n\t\t\t\tbuf.append(\"X\");\n\t\t\t}\n\t\t}\n\n\t\treturn new FastaSequence(sequence.getAccession().getID(),buf.toString());\n\t}\n\n\tprivate static float[] predictSerial(FastaSequence fsequence) {\n\t\tORonn.validateSequenceForRonn(fsequence);\n\t\tORonn ronn;\n\t\tfloat[] disorder = null;\n\t\ttry {\n\t\t\tronn = new ORonn(fsequence, loader);\n\t\t\tdisorder = ronn.call().getMeanScores();\n\t\t} catch (NumberFormatException | IOException e) {\n\t\t\tthrow new RuntimeException(\"Jronn fails to load models \" + e.getLocalizedMessage(), e);\n\t\t} \n\t\treturn disorder;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the sequence. More formally, the regions for which the\n\t * probability of disorder is greater then 0.50.\n\t *\n\t *\n\t * @param sequence an instance of FastaSequence object, holding the name and the sequence.\n\t * @return the array of ranges if there are any residues predicted to have the\n\t * probability of disorder greater then 0.5, null otherwise.\n\t *\n\t */\n\tpublic static Range[] getDisorder(FastaSequence sequence) {\n\t\tfloat[] scores = getDisorderScores(sequence);\n\t\treturn scoresToRanges(scores, RonnConstraint.DEFAULT_RANGE_PROBABILITY_THRESHOLD);\n\t}\n\n\t/**\n\t * Convert raw scores to ranges. Gives ranges for given probability of disorder value\n\t * @param scores the raw probability of disorder scores for each residue in the sequence.\n\t * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\n\t * @return the array of ranges if there are any residues predicted to have the\n\t * probability of disorder greater then {@code probability}, null otherwise.\n\t */\n\tpublic static Range[] scoresToRanges(float[] scores, float probability)  {\n\t\tassert scores!=null && scores.length>0;\n\t\tassert probability>0 && probability<1;\n\n\t\tint count=0;\n\t\tint regionLen=0;\n\t\tList<Range> ranges = new ArrayList<Range>();\n\t\tfor(float score: scores) {\n\t\t\tcount++;\n\t\t\t// Round to 2 decimal points before comparison\n\t\t\tscore = (float) (Math.round(score*100.0)/100.0);\n\t\t\tif(score>probability) {\n\t\t\t\tregionLen++;\n\t\t\t} else {\n\t\t\t\tif(regionLen>0) {\n\t\t\t\t\tranges.add(new Range(count-regionLen, count-1,score));\n\t\t\t\t}\n\t\t\t\tregionLen=0;\n\t\t\t}\n\t\t}\n\t\t// In case of the range to boundary runs to the very end of the sequence\n\t\tif(regionLen>1) {\n\t\t\tranges.add(new Range(count-regionLen+1, count,scores[scores.length-1]));\n\t\t}\n\t\treturn ranges.toArray(new Range[ranges.size()]);\n\n\t}\n\n\t/**\n\t * Calculates the probability of disorder scores for each residue in the sequence for\n\t * many sequences in the input.\n\t *\n\t * @param sequences the list of the FastaSequence objects\n\t * @return the Map with key->FastaSequence, value->probability of disorder for each residue\n\t * @see #getDisorder(FastaSequence)\n\t */\n\tpublic static Map<FastaSequence,float[]> getDisorderScores(List<FastaSequence> sequences) {\n\t\tMap<FastaSequence,float[]> results = new TreeMap<FastaSequence, float[]>();\n\t\tresults = sequences.stream().collect(Collectors.toMap(fastaSequence ->  fastaSequence, fastaSequence -> predictSerial(fastaSequence)));\n\t\treturn results;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the sequence for many sequences in the input.\n\t *\n\t * @param sequences sequences the list of the FastaSequence objects\n\t * @return\n\t * @see #getDisorder(FastaSequence)\n\t */\n\tpublic static Map<FastaSequence,Range[]> getDisorder(List<FastaSequence> sequences) {\n\t\tMap<FastaSequence,Range[]> disorderRanges = new TreeMap<FastaSequence,Range[]>();\n\t\tdisorderRanges = sequences.stream().collect(Collectors.toMap(fastaSequence -> fastaSequence, fastaSequence -> getDisorder(fastaSequence) ));\n\t\treturn disorderRanges;\n\t}\n\n\t/**\n\t * Calculates the disordered regions of the protein sequence.\n\t * @param fastaFile input file name containing the sequence in FASTA\n\t * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\n\t * @throws FileNotFoundException if the input file cannot be found\n\t * @throws IOException of the system cannot access or read from the input file\n\t * @see #getDisorder(FastaSequence)\n\t * @see #Jronn.Range\n\t */\n\tpublic static Map<FastaSequence,Range[]> getDisorder(String fastaFile) throws IOException {\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\n\t\treturn getDisorder(sequences);\n\t}\n\n\t/**\n\t * TODO\n\t *\n\t * High performance method for calculating disorder. Use multiple threads to achieve the speedup.\n\t *\n\t * @param fastaFile  fully qualified path to the input FASTA file\n\t * @param outputFile file name of the file for the results\n\t * @param threadNumber the number of threads to use, default\n\t * @param controls the format of the result file\n\t * @throws FileNotFoundException if input file in not found\n\t * @throws IOException if the input or the output files cannot be accessed\n\t * @see ORonn.ResultLayout\n\n\tpublic static void calculateDisorder(String fastaFile, String outputFile, int threadNumber, ResultLayout layout) throws FileNotFoundException, IOException {\n\t\tfinal List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\n\t\tInputParameters in = new InputParameters();\n\t\tin.setFilePrm(fastaFile, InputParameters.inputKey);\n\t\tin.setFilePrm(outputFile, InputParameters.outputKey);\n\t\t//in.setThreadNum(Integer.toString(threadNumber));\n\t\tORonn.predictParallel(sequences, in, loader);\n\t}\n\t*/\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.ronn;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.DNASequence;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.RNASequence;\nimport org.biojava.nbio.data.sequence.FastaSequence;\nimport org.biojava.nbio.ronn.Jronn.Range;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\n\npublic class JronnTest {\n\n\t// Implemented with two platform checks.\n\tpublic void verifyRanges() {\n\n\tRange[]\tranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" +\n\t\t\t\t\"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" +\n\t\t\t\t\"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" +\n\t\t\t\t\"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" +\n\t\t\t\t\"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\n\tassertEquals(4, ranges.length);\n\tassertEquals(53, ranges[0].from);\n\tassertEquals(59, ranges[0].to);\n\n\tassertEquals(190, ranges[1].from);\n\tassertEquals(196, ranges[1].to);\n\n\tassertEquals(210, ranges[2].from);\n\tassertEquals(226, ranges[2].to);\n\n\tassertEquals(305, ranges[3].from);\n\tassertEquals(313, ranges[3].to);\n\t//System.out.println(Arrays.toString(ranges));\n\t}\n\n\t/**\n\t * Jronn was breaking on Windows platform due to the different System.getProperty(\"line.separator\") values\n\t * (CRLF vs LF).  This wraps the existing unit testing to show that it works on windows or unix.\n\t */\n\t@Test\n\tpublic void checkJronn() {\n\t\t// Windows CRLF\n\t\tScopedProperty lineSepProp = new ScopedProperty(\"line.separator\", \"\\r\\n\");\n\t\tverifyRanges();\n\t\tlineSepProp.close();\n\n\t\t// UNIX LF\n\t\tScopedProperty lineSepPropUnix = new ScopedProperty(\"line.separator\", \"\\n\");\n\t\tverifyRanges();\n\t\tlineSepPropUnix.close();\n\t}\n\n\t/**\n\t * A scoped property helper class to check with Windows style CRLF.\n\t * Credit Thomas Klambauer, but here have removed the implement of\n\t * AutoCloseable (Java 7) for BioJava support of Java 6.\n\t */\n\tpublic class ScopedProperty {\n\n\t\tprivate final String key;\n\t\tprivate final String oldValue;\n\n\t\t/**\n\t\t *\n\t\t * @param key The System.setProperty key\n\t\t * @param value The System.setProperty value to switch to.\n\t\t */\n\t\tpublic ScopedProperty(final String key, final String value) {\n\t\t\tthis.key = key;\n\t\t\toldValue = System.setProperty(key, value);\n\t\t}\n\n\t\tpublic void close() {\n\t\t\t// Can't use setProperty(key, null) -> Throws NullPointerException.\n\t\t\tif( oldValue == null ) {\n\t\t\t\t// Previously there was no entry.\n\t\t\t\tSystem.clearProperty(key);\n\t\t\t} else {\n\t\t\t\tSystem.setProperty(key, oldValue);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Test the user scenario when disorder scores are calculated over a sequence containing the selenocysteine (Sec) amino acid.\n\t *  The user has to manually convert the stop codons symbols (\"*\") to the \"U\" symbol and Jronn is expected to handle this sequence.\n\t *\n\t * @throws CompoundNotFoundException\n\t */\n\n\t@Test\n\tpublic void testStopCodons() throws CompoundNotFoundException {\n\n\t\t// gene: DIO2, NM_001007023\n\t\tString dnaString = \"ATGGGCATCCTCAGCGTAGACTTGCTGATCACACTGCAAATTCTGCCAGTTTTTTTCTCCAACTGCCTCT\" +\n\t\t\t\t\"TCCTGGCTCTCTATGACTCGGTCATTCTGCTCAAGCACGTGGTGCTGCTGTTGAGCCGCTCCAAGTCCAC\" +\n\t\t\t\t\"TCGCGGAGAGTGGCGGCGCATGCTGACCTCAGAGGGACTGCGCTGCGTCTGGAAGAGCTTCCTCCTCGAT\" +\n\t\t\t\t\"GCCTACAAACAGCTAAATTGTCCTCCATCAGGTTTTAGCAAAGATGGACACATTTTATGACTAGTATATG\" +\n\t\t\t\t\"AAGCTTATAAAAGCAGACTACTGGTCTACTCACATTTGGATTTATGGATGGTGAAATTGGGTGAGGATGC\" +\n\t\t\t\t\"CCCCAATTCCAGTGTGGTGCATGTCTCCAGTACAGAAGGAGGTGACAACAGTGGCAATGGTACCCAGGAG\" +\n\t\t\t\t\"AAGATAGCTGAGGGAGCCACATGCCACCTTCTTGACTTTGCCAGCCCTGAGCGCCCACTAGTGGTCAACT\" +\n\t\t\t\t\"TTGGCTCAGCCACTTGACCTCCTTTCACGAGCCAGCTGCCAGCCTTCCGCAAACTGGTGGAAGAGTTCTC\" +\n\t\t\t\t\"CTCAGTGGCTGACTTCCTGCTGGTCTACATTGATGAGGCTCATCCATCAGATGGCTGGGCGATACCGGGG\" +\n\t\t\t\t\"GACTCCTCTTTGTCTTTTGAGGTGAAGAAGCACCAGAACCAGGAAGATCGATGTGCAGCAGCCCAGCAGC\" +\n\t\t\t\t\"TTCTGGAGCGTTTCTCCTTGCCGCCCCAGTGCCGAGTTGTGGCTGACCGCATGGACAATAACGCCAACAT\" +\n\t\t\t\t\"AGCTTACGGGGTAGCCTTTGAACGTGTGTGCATTGTGCAGAGACAGAAAATTGCTTATCTGGGAGGAAAG\" +\n\t\t\t\t\"GGCCCCTTCTCCTACAACCTTCAAGAAGTCCGGCATTGGCTGGAGAAGAATTTCAGCAAGAGATGAAAGA\" +\n\t\t\t\t\"AAACTAGATTAGCTGGTTAA\";\n\n\t\tDNASequence dnaSequence = new DNASequence(dnaString);\n\t\tRNASequence mRNA = dnaSequence.getRNASequence();\n\t\tProteinSequence protein = mRNA.getProteinSequence();\n\n\t\tString proteinString = protein.getSequenceAsString();\n\t\t// replace the symbol * (codon TGA) with U at amino acid\n\t\tString proteinStringU = proteinString.replaceAll(\"\\\\*\", \"u\");\n\t\tFastaSequence fsequence = new FastaSequence(\"\", proteinStringU);\n\t\ttry {\n\t\t\tfloat[] rawProbabilityScores = Jronn.getDisorderScores(fsequence);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tfail(\"Disorder scores calculation doesn't work\");\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Fix Sonar S1130 throws declarations should not be superfluous\n","test_commitMessage":"","allZero":false}