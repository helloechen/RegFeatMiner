{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/PDBStatus.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/PDBStatusTest.java","prod_time":"2011-04-27 06:26:39","test_time":"2011-04-27 06:26:39","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":68,"add_classname_line":0,"add_condition_line":29,"add_field_line":0,"add_import_line":3,"add_packageid_line":0,"add_parameter_line":5,"add_return_line":13,"del_annotation_line":0,"del_call_line":21,"del_classname_line":0,"del_condition_line":16,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":8,"label":"POSITIVE","prod_commitID":"37b0c370a62763eaaa20064074815547bb6ed3c1","test_commitID":"37b0c370a62763eaaa20064074815547bb6ed3c1","isfound":"found test change","originPro":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n * \n * All methods query the PDB website.\n * \n * <p><b>TODO</b> Keep a small cache of queries around, to reduce server load\n * \n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatus {\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\t\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tUNKNOWN;\n\t\t\n\t\t\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tif(statusStr.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStr.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse {\n\t\t\t\tstatus = null;\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the status of the PDB in question.\n\t * \n\t * <p>Possible return values are:\n\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {pdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+pdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(pdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn status;\n\t}\n\t\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to calling\n\t * {@link #getReplacement(String,boolean) getReplacement(oldPdbId,true)}\n\t * \n\t * @param oldPdbId\n\t * @return \n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\treturn getReplacement(oldPdbId,true);\n\t}\n\t\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT ids, this will\n\t * be itself.\n\t * \n\t * @param oldPdbId A pdb ID\n\t * @param recurse If true, return the most current version of oldPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB.\n\t */\n\tpublic static String getReplacement(String oldPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+oldPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(oldPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// If we're current, just return\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\treturn oldPdbId;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacement = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\tSystem.err.format(\"Error: %s is OBSOLETE but lacks a replacedBy attribute.\\n\",oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Return the replacement.\n\t\t\t\tif(recurse) {\n\t\t\t\t\treturn PDBStatus.getReplacement(replacement, recurse);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn replacement;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacement = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacement == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, assume at the root.\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\treturn oldPdbId;\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacement.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn replacement;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * Equivalent to {@link #getReplaces(String,boolean) getReplaces(newPdbId, false)}\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @return A (possibly empty) list of ID(s) of the direct ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId) {\n\t\treturn getReplaces(newPdbId, false);\n\t}\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimeted 'replaces'\n\t\t\tSystem.err.println(\"Error getting Status for \"+newPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+newPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\t\t\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = Arrays.asList(directDescendents);\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tallDescendents.addAll(roots);\n\t\t\t}\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t * \n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t * \n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t * \n\t * @param pdbIDs\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) {\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse \n\t\t\tSystem.out.format(\"Got System property %s=%s\\n\",PDB_SERVER_PROPERTY,serverName);\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=%s\",serverName,pdbIDs[0]);\n\t\tfor(int i=1;i<pdbIDs.length;i++) {\n\t\t\turlStr += \",\" + pdbIDs[i];\n\t\t}\n\t\t\n\t\t//System.out.println(\"Fetching \" + urlStr);\n\n\t\ttry {\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\t\t\t\n\t\t\t/* // Print file directly\n\t\t\tBufferedReader r = new BufferedReader(new InputStreamReader(uStream));\n\t\t\tString line = r.readLine();\n\t\t\twhile(line != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t\tline = r.readLine();\n\t\t\t}\n\t\t\tr.close();\n\t\t\t\n\t\t\tuStream = url.openStream();\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\t\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\t\t\t\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\t\t\t\n\t\t\treturn handler.getRecords();\n\t\t} catch (Exception e){\n\t\t\tSystem.err.println(\"Problem getting status for \" + pdbIDs.toString() + \" from PDB server.\" );\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t * \n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Map<String,String>> records;\n\t\t\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Map<String,String>>();\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t\t\tAttributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\t//Convert attributes into a Map, as it should have been.\n\t\t\t\t//Important since SAX reuses Attributes objects for different calls\n\t\t\t\tMap<String,String> attrMap = new HashMap<String,String>(attributes.getLength()*2);\n\t\t\t\tfor(int i=0;i<attributes.getLength();i++) {\n\t\t\t\t\tattrMap.put(attributes.getQName(i), attributes.getValue(i));\n\t\t\t\t}\n\t\t\t\trecords.add(attrMap);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\t\t\n\t\tpublic List<Map<String, String>> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n}","changedPro":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * Methods for getting the status of a PDB file (current, obsolete, etc)\n * and for accessing different versions of the structure.\n * \n * <p>All methods query the \n * <a href=\"http://www.rcsb.org/pdb/rest/idStatus?structureId=1HHB,3HHB,4HHB\">\n * PDB website.</a>\n * \n * <p>PDB supersessions form a directed acyclic graph, where edges point from an\n * obsolete ID to the entry that directly superseded it. For example, here are  \n * edges from one portion of the graph:<br/>\n * \n * 1CAT -> 3CAT<br/>\n * 3CAT -> 7CAT<br/>\n * 3CAT -> 8CAT<br/>\n * \n * <p>The methods {@link #getReplaces(String, boolean) getReplaces(pdbId, false)}/ \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, false, true)}\n * just get the incoming/outgoing edges for a single node. The recursive versions \n * ({@link #getReplaces(String, boolean) getReplaces(pdbId, true)}, \n * {@link #getReplacement(String, boolean, boolean) getReplacement(pdbId, true, false)})\n * will do a depth-first search up/down the tree and return a list of all nodes ]\n * reached.\n * \n * <p>Finally, the getCurrent() method returns a single PDB ID from among the \n * results of \n * {@link #getReplacement(String, boolean) getReplacement(pdbId, true)}. \n * To be consistent with the old REST ordering, this is the PDB ID that occurs \n * last alphabetically.\n * \n * <p><b>TODO</b> Keep a small cache of queries around, to reduce server load\n * \n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatus {\n\tpublic static final String DEFAULT_PDB_SERVER = \"www.rcsb.org\";\n\tpublic static final String PDB_SERVER_PROPERTY = \"PDB.SERVER\";\n\t\n\t/**\n\t * Represents the status of PDB IDs. 'OBSOLETE' and 'CURRENT' are the most\n\t * common.\n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tpublic enum Status {\n\t\tOBSOLETE,\n\t\tCURRENT,\n\t\tAUTH,\n\t\tHOLD,\n\t\tHPUB,\n\t\tPOLC,\n\t\tPROC,\n\t\tREFI,\n\t\tREPL,\n\t\tWAIT,\n\t\tWDRN,\n\t\tUNKNOWN;\n\t\t\n\t\t\n\t\t/**\n\t\t * \n\t\t * @param statusStrUpper\n\t\t * @return\n\t\t * @throws IllegalArgumentException If the string is not recognized\n\t\t */\n\t\tpublic static Status fromString(String statusStr) {\n\t\t\tStatus status;\n\t\t\tString statusStrUpper = statusStr.toUpperCase();\n\t\t\tif(statusStrUpper.equalsIgnoreCase(\"OBSOLETE\"))\n\t\t\t\tstatus = Status.OBSOLETE;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"CURRENT\"))\n\t\t\t\tstatus = Status.CURRENT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"AUTH\"))\n\t\t\t\tstatus = Status.AUTH;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HOLD\"))\n\t\t\t\tstatus = Status.HOLD;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"HPUB\"))\n\t\t\t\tstatus = Status.HPUB;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"POLC\"))\n\t\t\t\tstatus = Status.POLC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"PROC\"))\n\t\t\t\tstatus = Status.PROC;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REFI\"))\n\t\t\t\tstatus = Status.REFI;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"REPL\"))\n\t\t\t\tstatus = Status.REPL;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WAIT\"))\n\t\t\t\tstatus = Status.WAIT;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"WDRN\"))\n\t\t\t\tstatus = Status.WDRN;\n\t\t\telse if(statusStrUpper.equalsIgnoreCase(\"UNKNOWN\"))\n\t\t\t\tstatus = Status.UNKNOWN;\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Unable to parse status '\"+statusStrUpper+\"'.\");\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t}\n\t\n\t/**\n\t * Get the status of the PDB in question.\n\t * \n\t * <p>Possible return values are:\n\n\t * @param pdbId\n\t * @return The status, or null if an error occurred.\n\t */\n\tpublic static Status getStatus(String pdbId) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {pdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+pdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(pdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+pdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\n\t\treturn status;\n\t}\n\t\n\t/**\n\t * Gets the current version of a PDB ID. This is equivalent to selecting\n\t * the first element from\n\t * {@link #getReplacement(String,boolean) getReplacement(oldPdbId,true,false)}\n\t * \n\t * @param oldPdbId\n\t * @return The \n\t */\n\tpublic static String getCurrent(String oldPdbId) {\n\t\tList<String> replacements =  getReplacement(oldPdbId,true, false);\n\t\tif(replacements.size()>0)\n\t\t\treturn replacements.get(0);\n\t\telse\n\t\t\treturn null;\n\t}\n\t\n\t/**\n\t * Gets the PDB which superseded oldPdbId. For CURRENT IDs, this will\n\t * be itself. For obsolete IDs, the behavior depends on the recursion \n\t * parameter. If false, only IDs which directly supersede oldPdbId are\n\t * returned. If true, the replacements for obsolete records are recursively \n\t * fetched, yielding a list of all current replacements of oldPdbId.\n\t * \n\t * \n\t * \n\t * @param oldPdbId A pdb ID\n\t * @param recurse Indicates whether the replacements for obsolete records \n\t * \t\tshould be fetched.\n\t * @param includeObsolete Indicates whether obsolete records should be\n\t * \t\tincluded in the results.\n\t * @return The PDB which replaced oldPdbId. This may be oldPdbId itself, for\n\t * \t\tcurrent records. A return value of null indicates that the ID has\n\t * \t\tbeen removed from the PDB.\n\t */\n\tpublic static List<String> getReplacement(String oldPdbId, boolean recurse, boolean includeObsolete) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {oldPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\tSystem.err.println(\"Error getting Status for \"+oldPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equalsIgnoreCase(oldPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t//Check that the status is given\n\t\tString statusStr = attrs.get(\"status\");\n\t\tif(statusStr == null ) {\n\t\t\tSystem.err.println(\"Error: No status returned for \"+oldPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tStatus status = Status.fromString(statusStr);\n\t\tif(status == null ) {\n\t\t\tSystem.err.println(\"Error: Unknown status '\"+statusStr+\"'\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// If we're current, just return\n\t\tLinkedList<String> results = new LinkedList<String>();\n\t\tswitch(status) {\n\t\t\tcase CURRENT:\n\t\t\t\tresults.add(oldPdbId);\n\t\t\t\treturn results;\n\t\t\tcase OBSOLETE: {\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\tSystem.err.format(\"Error: %s is OBSOLETE but lacks a replacedBy attribute.\\n\",oldPdbId);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t//include this result\n\t\t\t\tif(includeObsolete) {\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t}\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn results; //empty\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif(includeObsolete) {\n\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// check status of replacement\n\t\t\t\t\t\t\tStatus replacementStatus = getStatus(replacement);\n\t\t\t\t\t\t\tswitch(replacementStatus) {\n\t\t\t\t\t\t\tcase OBSOLETE:\n\t\t\t\t\t\t\t\t//ignore obsolete\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CURRENT:\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// include it\n\t\t\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\treturn results;\n\t\t\t}\n\t\t\tcase UNKNOWN:\n\t\t\t\treturn null;\n\t\t\tdefault: { //TODO handle other cases explicitly. They might have other syntax than \"replacedBy\"\n\t\t\t\tString replacementStr = attrs.get(\"replacedBy\");\n\t\t\t\t\n\t\t\t\tif(replacementStr == null) {\n\t\t\t\t\t// If no \"replacedBy\" attribute, treat like we're current\n\t\t\t\t\t// TODO is this correct?\n\t\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\n\t\t\t\treplacementStr = replacementStr.toUpperCase();\n\t\t\t\t// Some PDBs are not replaced.\n\t\t\t\tif(replacementStr.equals(\"NONE\")) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t//include this result, since it's not obsolete\n\t\t\t\tresults.add(oldPdbId);\n\t\t\t\t\n\t\t\t\tString[] replacements = replacementStr.split(\" \");\n\t\t\t\tArrays.sort(replacements, new Comparator<String>() {\n\t\t\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\t\t\treturn o2.compareToIgnoreCase(o1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(String replacement : replacements) {\n\n\t\t\t\t\t// Return the replacement.\n\t\t\t\t\tif(recurse) {\n\t\t\t\t\t\tList<String> others = PDBStatus.getReplacement(replacement, recurse, includeObsolete);\n\t\t\t\t\t\tmergeReversed(results,others);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmergeReversed(results,Arrays.asList(replacement));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Takes two reverse sorted lists of strings and merges the second into the\n\t * first. Duplicates are removed.\n\t * \n\t * @param merged A reverse sorted list. Modified by this method to contain\n\t * \t\tthe contents of other.\n\t * @param other A reverse sorted list. Not modified.\n\t */\n\tprivate static void mergeReversed(List<String> merged,\n\t\t\tfinal List<String> other) {\n\t\t\n\t\tif(other.isEmpty())\n\t\t\treturn;\n\n\t\tif(merged.isEmpty()) {\n\t\t\tmerged.addAll(other);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tListIterator<String> m = merged.listIterator();\n\t\tListIterator<String> o = other.listIterator();\n\t\t\n\t\tString nextM, prevO;\n\t\tprevO = o.next();\n\t\twhile(m.hasNext()) {\n\t\t\t// peek at m\n\t\t\tnextM = m.next();\n\t\t\tm.previous();\n\t\t\t\n\t\t\t//insert from O until exhausted or occurs after nextM\n\t\t\twhile(prevO.compareTo(nextM) > 0) {\n\t\t\t\tm.add(prevO);\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\t\t\t//remove duplicates\n\t\t\tif(prevO.equals(nextM)) {\n\t\t\t\tif(!o.hasNext()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tprevO = o.next();\n\t\t\t}\n\t\t\t\n\t\t\tm.next();\n\t\t}\n\t\tm.add(prevO);\n\t\twhile(o.hasNext()) {\n\t\t\tm.add(o.next());\n\t\t}\n\t\t\n\t}\n\t\n\n\t/**\n\t * Get the ID of the protein which was made obsolete by newPdbId.\n\t * \n\t * @param newPdbId PDB ID of the newer structure\n\t * @param recurse If true, return all ancestors of newPdbId.\n\t * \t\tOtherwise, just go one step newer than oldPdbId.\n\t * @return A (possibly empty) list of ID(s) of the ancestor(s) of\n\t * \t\tnewPdbId, or <tt>null</tt> if an error occurred.\n\t */\n\tpublic static List<String> getReplaces(String newPdbId, boolean recurse) {\n\t\tList<Map<String,String>> attrList = getStatusIdRecords(new String[] {newPdbId});\n\t\t//Expect a single record\n\t\tif(attrList == null || attrList.size() != 1) {\n\t\t\t//TODO Is it possible to have multiple record per ID?\n\t\t\t// They seem to be combined into one record with space-delimited 'replaces'\n\t\t\tSystem.err.println(\"Error getting Status for \"+newPdbId+\" from the PDB website.\");\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tMap<String,String> attrs = attrList.get(0);\n\t\t\n\t\t//Check that the record matches pdbId\n\t\tString id = attrs.get(\"structureId\");\n\t\tif(id == null || !id.equals(newPdbId)) {\n\t\t\tSystem.err.println(\"Error: Results returned from the query don't match \"+newPdbId);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\n\t\tString replacedList = attrs.get(\"replaces\"); //space-delimited list\n\t\tif(replacedList == null) {\n\t\t\t// no replaces value; assume root\n\t\t\treturn new ArrayList<String>();\n\t\t}\n\t\tString[] directDescendents = replacedList.split(\"\\\\s\");\n\t\t\n\t\t// Not the root! Return the replaced PDB.\n\t\tif(recurse) {\n\t\t\t// Note: Assumes a proper directed acyclic graph of revisions\n\t\t\t// Cycles will cause infinite loops.\n\t\t\tList<String> allDescendents = new LinkedList<String>();\n\t\t\tfor(String replaced : directDescendents) {\n\t\t\t\tList<String> roots = PDBStatus.getReplaces(replaced, recurse);\n\t\t\t\tmergeReversed(allDescendents,roots);\n\t\t\t}\n\t\t\tmergeReversed(allDescendents,Arrays.asList(directDescendents));\n\t\t\t\n\t\t\treturn allDescendents;\n\t\t} else {\n\t\t\treturn Arrays.asList(directDescendents);\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * Fetches the status of one or more pdbIDs from the server.\n\t * \n\t * <p>Returns the results as a list of Attributes.\n\t * Each attribute should contain \"structureId\" and \"status\" attributes, and\n\t * possibly more.\n\t * \n\t * <p>Example:</br>\n\t * <tt>http://www.rcsb.org/pdb/rest/idStatus?structureID=1HHB,4HHB</tt></br>\n\t *<pre>&lt;idStatus&gt;\n\t *  &lt;record structureId=\"1HHB\" status=\"OBSOLETE\" replacedBy=\"4HHB\"/&gt;\n\t *  &lt;record structureId=\"4HHB\" status=\"CURRENT\" replaces=\"1HHB\"/&gt;\n\t *&lt;/idStatus&gt;\n\t * </pre>\n\t * \n\t * @param pdbIDs\n\t * @return A map between attributes and values\n\t */\n\tprivate static List<Map<String, String>> getStatusIdRecords(String[] pdbIDs) {\n\t\tString serverName = System.getProperty(PDB_SERVER_PROPERTY);\n\n\t\tif ( serverName == null)\n\t\t\tserverName = DEFAULT_PDB_SERVER;\n\t\telse \n\t\t\tSystem.out.format(\"Got System property %s=%s\\n\",PDB_SERVER_PROPERTY,serverName);\n\n\t\t// Build REST query URL\n\t\tif(pdbIDs.length < 1) {\n\t\t\tthrow new IllegalArgumentException(\"No pdbIDs specified\");\n\t\t}\n\t\tString urlStr = String.format(\"http://%s/pdb/rest/idStatus?structureId=%s\",serverName,pdbIDs[0]);\n\t\tfor(int i=1;i<pdbIDs.length;i++) {\n\t\t\turlStr += \",\" + pdbIDs[i];\n\t\t}\n\t\t\n\t\t//System.out.println(\"Fetching \" + urlStr);\n\n\t\ttry {\n\t\t\tURL url = new URL(urlStr);\n\n\t\t\tInputStream uStream = url.openStream();\n\t\t\t\n\t\t\t/* // Print file directly\n\t\t\tBufferedReader r = new BufferedReader(new InputStreamReader(uStream));\n\t\t\tString line = r.readLine();\n\t\t\twhile(line != null) {\n\t\t\t\tSystem.out.println(line);\n\t\t\t\tline = r.readLine();\n\t\t\t}\n\t\t\tr.close();\n\t\t\t\n\t\t\tuStream = url.openStream();\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\tInputSource source = new InputSource(uStream);\n\t\t\tSAXParserFactory parserFactory = SAXParserFactory.newInstance();\n\t\t\tSAXParser parser = parserFactory.newSAXParser();\n\t\t\tXMLReader reader = parser.getXMLReader();\n\t\t\t\n\t\t\tPDBStatusXMLHandler handler = new PDBStatusXMLHandler();\n\t\t\t\n\t\t\treader.setContentHandler(handler);\n\t\t\treader.parse(source);\n\t\t\t\n\t\t\treturn handler.getRecords();\n\t\t} catch (Exception e){\n\t\t\tSystem.err.println(\"Problem getting status for \" + pdbIDs.toString() + \" from PDB server.\" );\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/**\n\t * Handles idStatus xml by storing attributes for all record elements.\n\t * \n\t * @author Spencer Bliven <sbliven@ucsd.edu>\n\t *\n\t */\n\tprivate static class PDBStatusXMLHandler extends DefaultHandler {\n\t\tprivate List<Map<String,String>> records;\n\t\t\n\t\tpublic PDBStatusXMLHandler() {\n\t\t\trecords = new ArrayList<Map<String,String>>();\n\t\t}\n\t\t\n\t\t/**\n\t\t * @param uri\n\t\t * @param localName\n\t\t * @param qName\n\t\t * @param attributes\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#startElement(java.lang.String, java.lang.String, java.lang.String, org.xml.sax.Attributes)\n\t\t */\n\t\t@Override\n\t\tpublic void startElement(String uri, String localName, String qName,\n\t\t\t\tAttributes attributes) throws SAXException {\n\t\t\t//System.out.format(\"Starting element: uri='%s' localName='%s' qName='%s'\\n\", uri, localName, qName);\n\t\t\tif(qName.equals(\"record\")) {\n\t\t\t\t//Convert attributes into a Map, as it should have been.\n\t\t\t\t//Important since SAX reuses Attributes objects for different calls\n\t\t\t\tMap<String,String> attrMap = new HashMap<String,String>(attributes.getLength()*2);\n\t\t\t\tfor(int i=0;i<attributes.getLength();i++) {\n\t\t\t\t\tattrMap.put(attributes.getQName(i), attributes.getValue(i));\n\t\t\t\t}\n\t\t\t\trecords.add(attrMap);\n\t\t\t}\n\t\t}\n\n\n\t\t/**\n\t\t * @param e\n\t\t * @throws SAXException\n\t\t * @see org.xml.sax.helpers.DefaultHandler#error(org.xml.sax.SAXParseException)\n\t\t */\n\t\t@Override\n\t\tpublic void error(SAXParseException e) throws SAXException {\n\t\t\tSystem.err.println(e.getMessage());\n\t\t\tsuper.error(e);\n\t\t}\n\n\t\t\n\t\tpublic List<Map<String, String>> getRecords() {\n\t\t\treturn records;\n\t\t}\n\t}\n\n}","originTest":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getReplacement(\"1HHB\",false));\n\t\tassertEquals(\"3HHB\",PDBStatus.getReplacement(\"3HHB\",false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tassertEquals(\"3ENI\",PDBStatus.getCurrent(\"1KSA\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\t//TODO should test a case with a longer/more complicated version tree\n\t\tassertEquals(new ArrayList<String>(), Arrays.asList(new String[] {}));\n\t\t\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"4HHB\"));\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"3HHB\"));\n\t\tassertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\"));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",true));\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\t\t\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"4HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replaces\",\"1HHB\",attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\t\n}\n","changedTest":"/**\n * \n */\npackage org.biojava.bio.structure;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.PDBStatus;\nimport org.biojava.bio.structure.PDBStatus.Status;\n\nimport junit.framework.TestCase;\n\n/**\n * @author Spencer Bliven <sbliven@ucsd.edu>\n *\n */\npublic class PDBStatusTest extends TestCase {\n\n\t/**\n\t * Test {@link PDBStatus#getStatus(String)}.\n\t * \n\t * <p>Uses the following PDBs:<br/>\n\t * <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n\t *4HHB    CURRENT\treplaces=1HHB\n\t *3HHB    CURRENT\treplaces=1HHB\n\t *</pre>\n\t */\n\tpublic void testGetStatus() {\n\t\tassertEquals(Status.OBSOLETE, PDBStatus.getStatus(\"1HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n\t\tassertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n\t}\n\t\n\tpublic void testGetReplacement() {\n\t\tassertFalse(Arrays.asList(\"YES\").equals(Arrays.asList(\"NO\"))); //check for deep equals\n\t\t\n\t\t// 1CMW is replacedBy NONE\n\t\tassertEquals(Arrays.asList(),PDBStatus.getReplacement(\"1CMW\", true, false));\n\t\tassertEquals(Arrays.asList(\"1CMW\"),PDBStatus.getReplacement(\"1CMW\", true, true));\n\t\t\n\t\t// 1HHB is replacedBy 2-4HHB\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"3HHB\"),PDBStatus.getReplacement(\"3HHB\",false,true));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\"),PDBStatus.getReplacement(\"1HHB\",false,false));\n\t\tassertEquals(Arrays.asList(\"4HHB\",\"3HHB\",\"2HHB\",\"1HHB\"),PDBStatus.getReplacement(\"1HHB\",false,true));\n\t\t\n\t\t// 1CAT is replacedBy 3CAT is replacedBy 7-8CAT\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\",\"1CAT\"),PDBStatus.getReplacement(\"1CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"1CAT\",true,false));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\",\"3CAT\"),PDBStatus.getReplacement(\"3CAT\",true,true));\n\t\tassertEquals(Arrays.asList(\"8CAT\",\"7CAT\"),PDBStatus.getReplacement(\"3CAT\",true,false));\n\t}\n\t\n\n\tpublic void testGetCurrent() {\n\t\tassertEquals(\"4HHB\",PDBStatus.getCurrent(\"1HHB\"));\n\t\tassertEquals(\"3HHB\",PDBStatus.getCurrent(\"3HHB\"));\n\t\tassertEquals(null, PDBStatus.getCurrent(\"1CMW\"));\n\t\tassertEquals(\"3ENI\",PDBStatus.getCurrent(\"1KSA\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"1CAT\"));\n\t\tassertEquals(\"8CAT\",PDBStatus.getCurrent(\"3CAT\"));\n\t\tassertEquals(\"7CAT\",PDBStatus.getCurrent(\"7CAT\"));\n\t}\n\t\n\tpublic void testGetReplaces() {\n\t\tassertEquals(new ArrayList<String>(), Arrays.asList(new String[] {}));\n\t\t\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"4HHB\",false));\n\t\tassertEquals(Arrays.asList(\"1HHB\"),PDBStatus.getReplaces(\"3HHB\",false));\n\t\tassertEquals(Arrays.asList(), PDBStatus.getReplaces(\"1HHB\", false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",false));\n\t\tassertEquals(Arrays.asList(\"1M50\",\"1KSA\"),PDBStatus.getReplaces(\"3ENI\",true));\n\t\tassertEquals(Arrays.asList(\"3CAT\"),PDBStatus.getReplaces(\"8CAT\",false));\n\t\tassertEquals(Arrays.asList(\"3CAT\",\"1CAT\"),PDBStatus.getReplaces(\"8CAT\",true));\n\t\t\n\t}\n\t\n\t/**\n\t * Tests a helper method for merging that was giving me problems\n\t */\n\tpublic void testMergeReversed() {\n\t\ttry {\n\t\t\tMethod mergeReversed = PDBStatus.class.getDeclaredMethod(\"mergeReversed\",\n\t\t\t\t\tList.class,List.class);\n\t\t\tmergeReversed.setAccessible(true);\n\n\n\t\t\tList<String> a,b;\n\n\t\t\tb = Arrays.asList(\"F\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"B\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"B\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"F\",\"A\", \"1\"),a);\n\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"G\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\t\t\t\n\t\t\tb = Arrays.asList();\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"A\", \"1\"),a);\n\n\t\t\tb = Arrays.asList(\"G\",\"D\",\"C\",\"A\");\n\t\t\ta = new LinkedList<String>();\n\t\t\ta.add(\"F\");\n\t\t\ta.add(\"B\");\n\t\t\ta.add(\"1\");\n\t\t\tmergeReversed.invoke(null, a,b);\n\t\t\tassertEquals(Arrays.asList(\"G\",\"F\",\"D\",\"C\",\"B\",\"A\", \"1\"),a);\n\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\t\n\t/**\n\t * Test low-level connectivity to the PDB\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void testGetStatusIdRecords() {\n\t\ttry {\n\t\tMethod getStatusIdRecords = PDBStatus.class.getDeclaredMethod(\"getStatusIdRecords\",\n\t\t\t\tString[].class);\n\t\tgetStatusIdRecords.setAccessible(true);\n\n\t\t\n\t\t\tList<Map<String,String>> attrsList;\n\t\t\tString[] pdbIds;\n\t\t\tMap<String,String> attrs;\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"1HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test with multiple IDs\n\t\t\tpdbIds = new String[] {\"1HHB\",\"4HHB\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",2, attrsList.size());\n\t\t\tattrs = attrsList.get(1);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"4HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replaces\",\"1HHB\",attrs.get(\"replaces\"));\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"1HHB\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"OBSOLETE\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"4HHB 3HHB 2HHB\",attrs.get(\"replacedBy\"));\n\t\t\t\n\t\t\t// Test invocation with a single ID\n\t\t\tpdbIds = new String[] {\"3ENI\"};\n\t\t\tattrsList = (List<Map<String,String>>) getStatusIdRecords.invoke(null, (Object) pdbIds);\n\t\t\tassertEquals(\"Wrong number of records.\",1, attrsList.size());\n\t\t\tattrs = attrsList.get(0);\n\t\t\tassertEquals(\"Wrong number of attributes\",3,attrs.size());\n\t\t\tassertEquals(\"Wrong structureId\",\"3ENI\",attrs.get(\"structureId\"));\n\t\t\tassertEquals(\"Wrong status\",\"CURRENT\",attrs.get(\"status\"));\n\t\t\tassertEquals(\"Wrong replacedBy\",\"1M50 1KSA\",attrs.get(\"replaces\"));\n\t\t\t\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tfail();\n\t\t}\n\t}\n\t\n}\n","commitMessage":"Modified PDBStatus for more robust support for obsolete files, including multiple current versions of obsolete IDs. Compatible with the 4/26/2011 release of the PDB website.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8897 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"Modified PDBStatus for more robust support for obsolete files, including multiple current versions of obsolete IDs. Compatible with the 4/26/2011 release of the PDB website.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@8897 7c6358e6-4a41-0410-a743-a5b2a554c398\n","allZero":false}