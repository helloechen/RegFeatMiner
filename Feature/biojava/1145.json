{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/search/io/SearchIO.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/search/io/SearchIOTest.java","prod_time":"2024-05-15 23:59:58","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"1ae6b52630282eba2079b5764218f5420c1b12b5","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ServiceLoader;\nimport java.util.NoSuchElementException;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n * @author Paolo Pavan\n */\n\npublic class SearchIO implements Iterable<Result>{\n\tstatic private HashMap<String,ResultFactory> extensionFactoryAssociation;\n\n\tfinal private ResultFactory factory;\n\tfinal private File file;\n\n\t/**\n\t * this threshold applies in retrieving hsp. Those having e-value below this\n\t * will not be loaded.\n\t */\n\tprivate double evalueThreshold = Double.MAX_VALUE;\n\t/**\n\t * contains one object per query sequence describing search results.\n\t * Sometime also referred as Iterations.\n\t */\n\tprivate List<Result> results;\n\n\tprivate final String NOT_SUPPORTED_FILE_EXCEPTION =\n\t\t\t\"This extension is not associated with any parser. You can try to specify a ResultFactory object.\";\n\n\t/**\n\t * Build a SearchIO reader and tries to select the appropriate parser inspecting\n\t * file extension.\n\t *\n\t * @param f\n\t * @throws Exception\n\t */\n\tpublic SearchIO (File f)  throws IOException, ParseException{\n\t\tfactory = guessFactory(f);\n\t\tfile = f;\n\t\tif (file.exists()) readResults();\n\t}\n\n\t/**\n\t * Build a SearchIO reader and specify a ResultFactory object to be used\n\t * for parsing\n\t *\n\t * @param f\n\t * @param factory\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic SearchIO (File f, ResultFactory factory) throws IOException, ParseException{\n\t\tfile = f;\n\t\tthis.factory = factory;\n\t\tif (file.exists()) readResults();\n\t}\n\t/**\n\t * Build a SearchIO reader, specify a ResultFactory object to be used for parsing\n\t * and filter hsp retrieved by a e-value threshold.\n\t * This usually increase parsing speed\n\t * @param f\n\t * @param factory\n\t * @param maxEvalue\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic SearchIO(File f, ResultFactory factory, double maxEvalue) throws IOException, ParseException{\n\t\tfile = f;\n\t\tthis.factory = factory;\n\t\tthis.evalueThreshold = maxEvalue;\n\t\tif (file.exists()) readResults();\n\t}\n\n\t/**\n\t * This method is declared private because it is the default action of constructor\n\t * when file exists\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tprivate void readResults() throws IOException, ParseException {\n\t\tfactory.setFile(file);\n\t\tresults = factory.createObjects(evalueThreshold);\n\t}\n\n\t/**\n\t * used to write a search report using the guessed or specified factory\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic void writeResults() throws IOException, ParseException {\n\t\tfactory.setFile(file);\n\t\tfactory.createObjects(evalueThreshold);\n\t}\n\n\t/**\n\t * Guess factory class to be used using file extension.\n\t * It can be used both for read and for in write.\n\t * To be ResultFactory classes automatically available to this subsystem\n\t * they must be listed in the file org.biojava.nbio.core.search.io.ResultFactory\n\t * located in src/main/resources\n\t *\n\t * @param f: file. Its last extension (text after last dot) will be compared\n\t * to default extensions of known ResultFactory implementing classes\n\t * @return the guessed factory\n\t */\n\tprivate ResultFactory guessFactory(File f){\n\t\tif (extensionFactoryAssociation == null){\n\t\t\textensionFactoryAssociation = new HashMap<>();\n\t\t\tServiceLoader<ResultFactory> impl = ServiceLoader.load(ResultFactory.class);\n\t\t\tfor (ResultFactory loadedImpl : impl) {\n\t\t\t\tList<String> fileExtensions = loadedImpl.getFileExtensions();\n\t\t\t\tfor (String ext: fileExtensions) extensionFactoryAssociation.put(ext, loadedImpl);\n\t\t\t}\n\t\t}\n\n\t\tString filename = f.getAbsolutePath();\n\t\tint extensionPos = filename.lastIndexOf(\".\");\n\t\tString extension = filename.substring(extensionPos + 1);\n\t\tif (extensionFactoryAssociation.get(extension) == null)\n\t\t\tthrow new UnsupportedOperationException(NOT_SUPPORTED_FILE_EXCEPTION\n\t\t\t\t\t+ \"\\nExtension:\"+ extension);\n\n\t\treturn extensionFactoryAssociation.get(extension);\n\t}\n\n\tpublic double getEvalueThreshold() {\n\t\treturn evalueThreshold;\n\t}\n\n\t@Override\n\tpublic Iterator<Result> iterator() {\n\t\treturn new Iterator<Result>() {\n\t\t\tint currentResult = 0;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn currentResult < results.size();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Result next() {\n\t\t\t\tif(!hasNext()){\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t}\n\t\t\t\treturn results.get(currentResult++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"The remove operation is not supported by this iterator\");\n\t\t\t}\n\t\t};\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.text.ParseException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ServiceLoader;\nimport java.util.NoSuchElementException;\nimport java.util.Map;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n * @author Paolo Pavan\n */\n\npublic class SearchIO implements Iterable<Result>{\n\tstatic private Map<String, ResultFactory> extensionFactoryAssociation;\n\n\tfinal private ResultFactory factory;\n\tfinal private File file;\n\n\t/**\n\t * this threshold applies in retrieving hsp. Those having e-value below this\n\t * will not be loaded.\n\t */\n\tprivate double evalueThreshold = Double.MAX_VALUE;\n\t/**\n\t * contains one object per query sequence describing search results.\n\t * Sometime also referred as Iterations.\n\t */\n\tprivate List<Result> results;\n\n\tprivate final String NOT_SUPPORTED_FILE_EXCEPTION =\n\t\t\t\"This extension is not associated with any parser. You can try to specify a ResultFactory object.\";\n\n\t/**\n\t * Build a SearchIO reader and tries to select the appropriate parser inspecting\n\t * file extension.\n\t *\n\t * @param f\n\t * @throws Exception\n\t */\n\tpublic SearchIO (File f)  throws IOException, ParseException{\n\t\tfactory = guessFactory(f);\n\t\tfile = f;\n\t\tif (file.exists()) readResults();\n\t}\n\n\t/**\n\t * Build a SearchIO reader and specify a ResultFactory object to be used\n\t * for parsing\n\t *\n\t * @param f\n\t * @param factory\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic SearchIO (File f, ResultFactory factory) throws IOException, ParseException{\n\t\tfile = f;\n\t\tthis.factory = factory;\n\t\tif (file.exists()) readResults();\n\t}\n\t/**\n\t * Build a SearchIO reader, specify a ResultFactory object to be used for parsing\n\t * and filter hsp retrieved by a e-value threshold.\n\t * This usually increase parsing speed\n\t * @param f\n\t * @param factory\n\t * @param maxEvalue\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic SearchIO(File f, ResultFactory factory, double maxEvalue) throws IOException, ParseException{\n\t\tfile = f;\n\t\tthis.factory = factory;\n\t\tthis.evalueThreshold = maxEvalue;\n\t\tif (file.exists()) readResults();\n\t}\n\n\t/**\n\t * This method is declared private because it is the default action of constructor\n\t * when file exists\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tprivate void readResults() throws IOException, ParseException {\n\t\tfactory.setFile(file);\n\t\tresults = factory.createObjects(evalueThreshold);\n\t}\n\n\t/**\n\t * used to write a search report using the guessed or specified factory\n\t *\n\t * @throws java.io.IOException for file access related issues\n\t * @throws java.text.ParseException for file format related issues\n\t */\n\tpublic void writeResults() throws IOException, ParseException {\n\t\tfactory.setFile(file);\n\t\tfactory.createObjects(evalueThreshold);\n\t}\n\n\t/**\n\t * Guess factory class to be used using file extension.\n\t * It can be used both for read and for in write.\n\t * To be ResultFactory classes automatically available to this subsystem\n\t * they must be listed in the file org.biojava.nbio.core.search.io.ResultFactory\n\t * located in src/main/resources\n\t *\n\t * @param f: file. Its last extension (text after last dot) will be compared\n\t * to default extensions of known ResultFactory implementing classes\n\t * @return the guessed factory\n\t */\n\tprivate ResultFactory guessFactory(File f){\n\t\tif (extensionFactoryAssociation == null){\n\t\t\textensionFactoryAssociation = new HashMap<>();\n\t\t\tServiceLoader<ResultFactory> impl = ServiceLoader.load(ResultFactory.class);\n\t\t\tfor (ResultFactory loadedImpl : impl) {\n\t\t\t\tList<String> fileExtensions = loadedImpl.getFileExtensions();\n\t\t\t\tfor (String ext: fileExtensions) extensionFactoryAssociation.put(ext, loadedImpl);\n\t\t\t}\n\t\t}\n\n\t\tString filename = f.getAbsolutePath();\n\t\tint extensionPos = filename.lastIndexOf(\".\");\n\t\tString extension = filename.substring(extensionPos + 1);\n\t\tif (extensionFactoryAssociation.get(extension) == null)\n\t\t\tthrow new UnsupportedOperationException(NOT_SUPPORTED_FILE_EXCEPTION\n\t\t\t\t\t+ \"\\nExtension:\"+ extension);\n\n\t\treturn extensionFactoryAssociation.get(extension);\n\t}\n\n\tpublic double getEvalueThreshold() {\n\t\treturn evalueThreshold;\n\t}\n\n\t@Override\n\tpublic Iterator<Result> iterator() {\n\t\treturn new Iterator<Result>() {\n\t\t\tint currentResult = 0;\n\t\t\t@Override\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn currentResult < results.size();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Result next() {\n\t\t\t\tif(!hasNext()){\n\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t}\n\t\t\t\treturn results.get(currentResult++);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException(\"The remove operation is not supported by this iterator\");\n\t\t\t}\n\t\t};\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.search.io;\n\nimport java.io.File;\nimport java.net.URL;\nimport org.biojava.nbio.core.search.io.blast.BlastXMLParser;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\n/**\n * Designed by Paolo Pavan.\n * You may want to find my contacts on Github and LinkedIn for code info\n * or discuss major changes.\n * https://github.com/paolopavan\n *\n * @author Paolo Pavan\n */\n\npublic class SearchIOTest {\n\n\tpublic SearchIOTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\t/**\n\t * Constructor test with GuessFactory\n\t */\n\t@Test\n\tpublic void testConstructorWithFactoryGuess() {\n\t\tString resource = \"/org/biojava/nbio/core/search/io/blast/test.two-query.blasttxt\";\n\t\tURL resourceURL = getClass().getResource(resource);\n\t\tFile file = new File(resourceURL.getFile());\n\n\t\tfinal SearchIO instance;\n\t\ttry {\n\t\t\tinstance = new SearchIO(file);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"test failed:\\n\"+e.getMessage());\n\t\t}\n\t}\n\t/**\n\t * Constructor test specifying Factory\n\t */\n\t@Test\n\tpublic void testConstructorWithoutFactoryGuess() {\n\t\tString resource = \"/org/biojava/nbio/core/search/io/blast/testBlastReport.blastxml\";\n\t\tURL resourceURL = getClass().getResource(resource);\n\t\tFile file = new File(resourceURL.getFile());\n\n\t\tResultFactory blastResultFactory = new BlastXMLParser();\n\t\tfinal SearchIO instance;\n\t\ttry {\n\t\t\tinstance = new SearchIO(file, blastResultFactory);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"test failed:\\n\"+e.getMessage());\n\t\t}\n\t}\n\t/**\n\t * Constructor test specifying Factory and using a evalue threshold filter\n\t */\n\t@Test\n\tpublic void testConstructorWithEvalueHspFilter() {\n\t\t//\n\t\tString resource = \"/org/biojava/nbio/core/search/io/blast/testBlastReport.blastxml\";\n\t\tURL resourceURL = getClass().getResource(resource);\n\t\tFile file = new File(resourceURL.getFile());\n\n\t\tResultFactory blastResultFactory = new BlastXMLParser();\n\t\tfinal SearchIO instance;\n\t\ttry {\n\t\t\tinstance = new SearchIO(file, blastResultFactory, 10e-10);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"test failed:\\n\"+e.getMessage());\n\t\t}\n\t}\n}\n","changedTest":"","commitMessage":"Fix issue s1319 Declarations should use Java collection interfaces on biojava-core\n","test_commitMessage":"","allZero":false}