{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/cif/CifFileSupplierImpl.java","test_path":"biojava-integrationtest/src/test/java/org/biojava/nbio/structure/test/io/cif/CifFileSupplierImplTest.java","prod_time":"2019-05-08 00:52:12","test_time":"2019-05-08 00:52:12","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":13,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"0b59a1080b505fbf380a7e49a53792688e1cc80d","test_commitID":"0b59a1080b505fbf380a7e49a53792688e1cc80d","isfound":"found test change","originPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.cif.model.Category;\nimport org.rcsb.cif.model.CifFile;\nimport org.rcsb.cif.model.builder.*;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\n\n/**\n * Convert a BioJava {@link Structure} to a CifFile.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileSupplierImpl implements CifFileSupplier<Structure> {\n    @Override\n    public CifFile get(Structure structure) {\n        // for now BioJava only considered 3 categories for create a Cif representation of a structure\n\n        // cell\n        CrystalCell crystalCell = structure.getPDBHeader().getCrystallographicInfo().getCrystalCell();\n        // symmetry\n        SpaceGroup spaceGroup = structure.getPDBHeader().getCrystallographicInfo().getSpaceGroup();\n        // atom_site\n        List<WrappedAtom> wrappedAtoms = collectWrappedAtoms(structure);\n        Category atomSite = wrappedAtoms.stream().collect(toAtomSite());\n\n        BlockBuilder blockBuilder = new CifBuilder()\n                .enterBlock(structure.getPDBCode());\n\n        if (atomSite.isDefined() && atomSite.getRowCount() > 0) {\n            // set atom site\n            blockBuilder.addCategory(atomSite);\n        }\n\n        if (crystalCell != null) {\n            // set cell category\n            blockBuilder.enterCell()\n                    .enterLengthA()\n                    .add(crystalCell.getA())\n                    .leaveColumn()\n\n                    .enterLengthB()\n                    .add(crystalCell.getB())\n                    .leaveColumn()\n\n                    .enterLengthC()\n                    .add(crystalCell.getC())\n                    .leaveColumn()\n\n                    .enterAngleAlpha()\n                    .add(crystalCell.getAlpha())\n                    .leaveColumn()\n\n                    .enterAngleBeta()\n                    .add(crystalCell.getBeta())\n                    .leaveColumn()\n\n                    .enterAngleGamma()\n                    .add(crystalCell.getGamma())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        if (spaceGroup != null) {\n            // set symmetry category\n            blockBuilder.enterSymmetry()\n                    .enterSpaceGroupNameH_M()\n                    .add(spaceGroup.getShortSymbol())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        return blockBuilder.leaveBlock().leaveFile();\n    }\n\n    private static List<WrappedAtom> collectWrappedAtoms(Structure structure) {\n        List<WrappedAtom> wrappedAtoms = new ArrayList<>();\n\n        for (int modelIndex = 0; modelIndex < structure.nrModels(); modelIndex++) {\n            final int model = modelIndex + 1;\n            for (Chain chain : structure.getChains(modelIndex)) {\n                final String chainName = chain.getName();\n                final String chainId = chain.getId();\n                for (Group group : chain.getAtomGroups()) {\n                    // The alt locs can have duplicates, since at parsing time we make sure that all alt loc groups have\n                    // all atoms (see StructureTools#cleanUpAltLocs)\n                    // Thus we have to remove duplicates here by using the atom id\n                    // See issue https://github.com/biojava/biojava/issues/778 and\n                    // TestAltLocs.testMmcifWritingAllAltlocs/testMmcifWritingPartialAltlocs\n                    Map<Integer, WrappedAtom> uniqueAtoms = new LinkedHashMap<>();\n                    for (int atomIndex = 0; atomIndex < group.size(); atomIndex++) {\n                        Atom atom = group.getAtom(atomIndex);\n                        if (atom == null) {\n                            continue;\n                        }\n\n                        uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                    }\n\n                    if (group.hasAltLoc()) {\n                        for (Group alt : group.getAltLocs()) {\n                            for (int atomIndex = 0; atomIndex < alt.size(); atomIndex++) {\n                                Atom atom = alt.getAtom(atomIndex);\n                                if (atom == null) {\n                                    continue;\n                                }\n\n                                uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                            }\n                        }\n                    }\n\n                    wrappedAtoms.addAll(uniqueAtoms.values());\n                }\n            }\n        }\n\n        return wrappedAtoms;\n    }\n\n    static class WrappedAtom {\n        private final Chain chain;\n        private final int model;\n        private final String chainName;\n        private final String chainId;\n        private final Atom atom;\n        private final int atomId;\n\n        public WrappedAtom(Chain chain, int model, String chainName, String chainId, Atom atom, int atomId) {\n            this.chain = chain;\n            this.model = model;\n            this.chainName = chainName;\n            this.chainId = chainId;\n            this.atom = atom;\n            this.atomId = atomId;\n        }\n\n        public Chain getChain() {\n            return chain;\n        }\n\n        public int getModel() {\n            return model;\n        }\n\n        public String getChainName() {\n            return chainName;\n        }\n\n        public String getChainId() {\n            return chainId;\n        }\n\n        public Atom getAtom() {\n            return atom;\n        }\n\n        public int getAtomId() {\n            return atomId;\n        }\n    }\n\n    private static Collector<WrappedAtom, ?, Category> toAtomSite() {\n        return Collector.of(AtomSiteCollector::new,\n                AtomSiteCollector::accept,\n                AtomSiteCollector::combine,\n                AtomSiteCollector::get);\n    }\n\n    static class AtomSiteCollector implements Consumer<WrappedAtom> {\n        private final StrColumnBuilder<CategoryBuilder> groupPDB;\n        private final IntColumnBuilder<CategoryBuilder> id;\n        private final StrColumnBuilder<CategoryBuilder> typeSymbol;\n        private final StrColumnBuilder<CategoryBuilder> labelAtomId;\n        private final StrColumnBuilder<CategoryBuilder> labelAltId;\n        private final StrColumnBuilder<CategoryBuilder> labelCompId;\n        private final StrColumnBuilder<CategoryBuilder> labelAsymId;\n        private final StrColumnBuilder<CategoryBuilder> labelEntityId;\n        private final IntColumnBuilder<CategoryBuilder> labelSeqId;\n        private final StrColumnBuilder<CategoryBuilder> pdbxPDBInsCode;\n        private final FloatColumnBuilder<CategoryBuilder> cartnX;\n        private final FloatColumnBuilder<CategoryBuilder> cartnY;\n        private final FloatColumnBuilder<CategoryBuilder> cartnZ;\n        private final FloatColumnBuilder<CategoryBuilder> occupancy;\n        private final FloatColumnBuilder<CategoryBuilder> bIsoOrEquiv;\n        private final IntColumnBuilder<CategoryBuilder> authSeqId;\n        private final StrColumnBuilder<CategoryBuilder> authCompId;\n        private final StrColumnBuilder<CategoryBuilder> authAsymId;\n        private final StrColumnBuilder<CategoryBuilder> authAtomId;\n        private final IntColumnBuilder<CategoryBuilder> pdbxPDBModelNum;\n\n        AtomSiteCollector() {\n            // TODO this doesn't really make the case for the builder ;)\n            this.groupPDB = new StrColumnBuilder<>(\"atom_site\", \"group_PDB\", null);\n            this.id = new IntColumnBuilder<>(\"atom_site\", \"id\", null);\n            this.typeSymbol = new StrColumnBuilder<>(\"atom_site\", \"type_symbol\", null);\n            this.labelAtomId = new StrColumnBuilder<>(\"atom_site\", \"label_atom_id\", null);\n            this.labelAltId = new StrColumnBuilder<>(\"atom_site\", \"label_alt_id\", null);\n            this.labelCompId = new StrColumnBuilder<>(\"atom_site\", \"label_comp_id\", null);\n            this.labelAsymId = new StrColumnBuilder<>(\"atom_site\", \"label_asym_id\", null);\n            this.labelEntityId = new StrColumnBuilder<>(\"atom_site\", \"label_entity_id\", null);\n            this.labelSeqId = new IntColumnBuilder<>(\"atom_site\", \"label_seq_id\", null);\n            this.pdbxPDBInsCode = new StrColumnBuilder<>(\"atom_site\", \"pdbx_PDB_ins_code\", null);\n            this.cartnX = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_x\", null);\n            this.cartnY = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_y\", null);\n            this.cartnZ = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_z\", null);\n            this.occupancy = new FloatColumnBuilder<>(\"atom_site\", \"occupancy\", null);\n            this.bIsoOrEquiv = new FloatColumnBuilder<>(\"atom_site\", \"B_iso_or_equiv\", null);\n            this.authSeqId = new IntColumnBuilder<>(\"atom_site\", \"auth_seq_id\", null);\n            this.authCompId = new StrColumnBuilder<>(\"atom_site\", \"auth_comp_id\", null);\n            this.authAsymId = new StrColumnBuilder<>(\"atom_site\", \"auth_asym_id\", null);\n            this.authAtomId = new StrColumnBuilder<>(\"atom_site\", \"auth_atom_id\", null);\n            this.pdbxPDBModelNum = new IntColumnBuilder<>(\"atom_site\", \"pdbx_PDB_model_num\", null);\n        }\n\n        @Override\n        public void accept(WrappedAtom wrappedAtom) {\n            Atom atom = wrappedAtom.getAtom();\n            Group group = atom.getGroup();\n            Chain chain = group.getChain();\n\n            groupPDB.add(group.getType().equals(GroupType.HETATM) ? \"HETATM\" : \"ATOM\");\n            id.add(wrappedAtom.getAtomId());\n            Element element = atom.getElement();\n            typeSymbol.add(element.equals(Element.R) ? \"X\" : element.toString().toUpperCase());\n            labelAtomId.add(atom.getName());\n            Character altLoc = atom.getAltLoc();\n            if (altLoc == null || altLoc == ' ') {\n                labelAltId.markNextNotPresent();\n            } else {\n                labelAltId.add(String.valueOf(altLoc));\n            }\n            labelCompId.add(group.getPDBName());\n            labelAsymId.add(wrappedAtom.getChainId());\n            String entityId = \"0\";\n            int seqId = group.getResidueNumber().getSeqNum();\n            if (chain.getEntityInfo() != null) {\n                entityId = Integer.toString(chain.getEntityInfo().getMolId());\n                if (chain.getEntityInfo().getType() == EntityType.POLYMER) {\n                    // this only makes sense for polymeric chains, non-polymer chains will never have seqres groups and\n                    // there's no point in calling getAlignedResIndex\n                    seqId = chain.getEntityInfo().getAlignedResIndex(group, chain);\n                }\n            }\n            labelEntityId.add(entityId);\n            labelSeqId.add(seqId);\n            String insCode = \"\";\n            if (group.getResidueNumber().getInsCode() != null ) {\n                insCode = Character.toString(group.getResidueNumber().getInsCode());\n            }\n            if (insCode.isEmpty()) {\n                pdbxPDBInsCode.markNextUnknown();\n            } else {\n                pdbxPDBInsCode.add(insCode);\n            }\n            cartnX.add(atom.getX());\n            cartnY.add(atom.getY());\n            cartnZ.add(atom.getZ());\n            occupancy.add(atom.getOccupancy());\n            bIsoOrEquiv.add(atom.getTempFactor());\n            authSeqId.add(group.getResidueNumber().getSeqNum());\n            authCompId.add(group.getPDBName());\n            authAsymId.add(wrappedAtom.getChainName());\n            authAtomId.add(atom.getName());\n            pdbxPDBModelNum.add(wrappedAtom.getModel());\n        }\n\n        AtomSiteCollector combine(AtomSiteCollector other) {\n            throw new UnsupportedOperationException(\"impl by calling addAll for all collection - not feeling like writing that code\");\n        }\n\n        Category get() {\n            return new CategoryBuilder(\"atom_site\", null)\n                    .addColumn(groupPDB.build())\n                    .addColumn(id.build())\n                    .addColumn(typeSymbol.build())\n                    .addColumn(labelAtomId.build())\n                    .addColumn(labelAltId.build())\n                    .addColumn(labelCompId.build())\n                    .addColumn(labelAsymId.build())\n                    .addColumn(labelEntityId.build())\n                    .addColumn(labelSeqId.build())\n                    .addColumn(pdbxPDBInsCode.build())\n                    .addColumn(cartnX.build())\n                    .addColumn(cartnY.build())\n                    .addColumn(cartnZ.build())\n                    .addColumn(occupancy.build())\n                    .addColumn(bIsoOrEquiv.build())\n                    .addColumn(authSeqId.build())\n                    .addColumn(authCompId.build())\n                    .addColumn(authAsymId.build())\n                    .addColumn(authAtomId.build())\n                    .addColumn(pdbxPDBModelNum.build())\n                    .build();\n        }\n    }\n}\n","changedPro":"package org.biojava.nbio.structure.io.cif;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.Element;\nimport org.biojava.nbio.structure.EntityType;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.GroupType;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.xtal.CrystalCell;\nimport org.biojava.nbio.structure.xtal.SpaceGroup;\nimport org.rcsb.cif.model.Category;\nimport org.rcsb.cif.model.CifFile;\nimport org.rcsb.cif.model.builder.BlockBuilder;\nimport org.rcsb.cif.model.builder.CategoryBuilder;\nimport org.rcsb.cif.model.builder.CifBuilder;\nimport org.rcsb.cif.model.builder.FloatColumnBuilder;\nimport org.rcsb.cif.model.builder.IntColumnBuilder;\nimport org.rcsb.cif.model.builder.StrColumnBuilder;\n\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.stream.Collector;\n\n/**\n * Convert a BioJava {@link Structure} to a CifFile.\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\n * @since 5.2.1\n */\nclass CifFileSupplierImpl implements CifFileSupplier<Structure> {\n    @Override\n    public CifFile get(Structure structure) {\n        // for now BioJava only considered 3 categories for create a Cif representation of a structure\n\n        // cell\n        CrystalCell crystalCell = structure.getPDBHeader().getCrystallographicInfo().getCrystalCell();\n        // symmetry\n        SpaceGroup spaceGroup = structure.getPDBHeader().getCrystallographicInfo().getSpaceGroup();\n        // atom_site\n        List<WrappedAtom> wrappedAtoms = collectWrappedAtoms(structure);\n        Category atomSite = wrappedAtoms.stream().collect(toAtomSite());\n\n        BlockBuilder blockBuilder = new CifBuilder()\n                .enterBlock(structure.getPDBCode());\n\n        if (atomSite.isDefined() && atomSite.getRowCount() > 0) {\n            // set atom site\n            blockBuilder.addCategory(atomSite);\n        }\n\n        if (crystalCell != null) {\n            // set cell category\n            blockBuilder.enterCell()\n                    .enterLengthA()\n                    .add(crystalCell.getA())\n                    .leaveColumn()\n\n                    .enterLengthB()\n                    .add(crystalCell.getB())\n                    .leaveColumn()\n\n                    .enterLengthC()\n                    .add(crystalCell.getC())\n                    .leaveColumn()\n\n                    .enterAngleAlpha()\n                    .add(crystalCell.getAlpha())\n                    .leaveColumn()\n\n                    .enterAngleBeta()\n                    .add(crystalCell.getBeta())\n                    .leaveColumn()\n\n                    .enterAngleGamma()\n                    .add(crystalCell.getGamma())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        if (spaceGroup != null) {\n            // set symmetry category\n            blockBuilder.enterSymmetry()\n                    .enterSpaceGroupNameH_M()\n                    .add(spaceGroup.getShortSymbol())\n                    .leaveColumn()\n                    .leaveCategory();\n        }\n\n        return blockBuilder.leaveBlock().leaveFile();\n    }\n\n    private static List<WrappedAtom> collectWrappedAtoms(Structure structure) {\n        List<WrappedAtom> wrappedAtoms = new ArrayList<>();\n\n        for (int modelIndex = 0; modelIndex < structure.nrModels(); modelIndex++) {\n            final int model = modelIndex + 1;\n            for (Chain chain : structure.getChains(modelIndex)) {\n                final String chainName = chain.getName();\n                final String chainId = chain.getId();\n                for (Group group : chain.getAtomGroups()) {\n                    // The alt locs can have duplicates, since at parsing time we make sure that all alt loc groups have\n                    // all atoms (see StructureTools#cleanUpAltLocs)\n                    // Thus we have to remove duplicates here by using the atom id\n                    // See issue https://github.com/biojava/biojava/issues/778 and\n                    // TestAltLocs.testMmcifWritingAllAltlocs/testMmcifWritingPartialAltlocs\n                    Map<Integer, WrappedAtom> uniqueAtoms = new LinkedHashMap<>();\n                    for (int atomIndex = 0; atomIndex < group.size(); atomIndex++) {\n                        Atom atom = group.getAtom(atomIndex);\n                        if (atom == null) {\n                            continue;\n                        }\n\n                        uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                    }\n\n                    if (group.hasAltLoc()) {\n                        for (Group alt : group.getAltLocs()) {\n                            for (int atomIndex = 0; atomIndex < alt.size(); atomIndex++) {\n                                Atom atom = alt.getAtom(atomIndex);\n                                if (atom == null) {\n                                    continue;\n                                }\n\n                                uniqueAtoms.put(atom.getPDBserial(), new WrappedAtom(chain, model, chainName, chainId, atom, atom.getPDBserial()));\n                            }\n                        }\n                    }\n\n                    wrappedAtoms.addAll(uniqueAtoms.values());\n                }\n            }\n        }\n\n        return wrappedAtoms;\n    }\n\n    static class WrappedAtom {\n        private final Chain chain;\n        private final int model;\n        private final String chainName;\n        private final String chainId;\n        private final Atom atom;\n        private final int atomId;\n\n        public WrappedAtom(Chain chain, int model, String chainName, String chainId, Atom atom, int atomId) {\n            this.chain = chain;\n            this.model = model;\n            this.chainName = chainName;\n            this.chainId = chainId;\n            this.atom = atom;\n            this.atomId = atomId;\n        }\n\n        public Chain getChain() {\n            return chain;\n        }\n\n        public int getModel() {\n            return model;\n        }\n\n        public String getChainName() {\n            return chainName;\n        }\n\n        public String getChainId() {\n            return chainId;\n        }\n\n        public Atom getAtom() {\n            return atom;\n        }\n\n        public int getAtomId() {\n            return atomId;\n        }\n    }\n\n    private static Collector<WrappedAtom, ?, Category> toAtomSite() {\n        return Collector.of(AtomSiteCollector::new,\n                AtomSiteCollector::accept,\n                AtomSiteCollector::combine,\n                AtomSiteCollector::get);\n    }\n\n    static class AtomSiteCollector implements Consumer<WrappedAtom> {\n        private final StrColumnBuilder<CategoryBuilder> groupPDB;\n        private final IntColumnBuilder<CategoryBuilder> id;\n        private final StrColumnBuilder<CategoryBuilder> typeSymbol;\n        private final StrColumnBuilder<CategoryBuilder> labelAtomId;\n        private final StrColumnBuilder<CategoryBuilder> labelAltId;\n        private final StrColumnBuilder<CategoryBuilder> labelCompId;\n        private final StrColumnBuilder<CategoryBuilder> labelAsymId;\n        private final StrColumnBuilder<CategoryBuilder> labelEntityId;\n        private final IntColumnBuilder<CategoryBuilder> labelSeqId;\n        private final StrColumnBuilder<CategoryBuilder> pdbxPDBInsCode;\n        private final FloatColumnBuilder<CategoryBuilder> cartnX;\n        private final FloatColumnBuilder<CategoryBuilder> cartnY;\n        private final FloatColumnBuilder<CategoryBuilder> cartnZ;\n        private final FloatColumnBuilder<CategoryBuilder> occupancy;\n        private final FloatColumnBuilder<CategoryBuilder> bIsoOrEquiv;\n        private final IntColumnBuilder<CategoryBuilder> authSeqId;\n        private final StrColumnBuilder<CategoryBuilder> authCompId;\n        private final StrColumnBuilder<CategoryBuilder> authAsymId;\n        private final StrColumnBuilder<CategoryBuilder> authAtomId;\n        private final IntColumnBuilder<CategoryBuilder> pdbxPDBModelNum;\n\n        AtomSiteCollector() {\n            // TODO this doesn't really make the case for the builder ;)\n            this.groupPDB = new StrColumnBuilder<>(\"atom_site\", \"group_PDB\", null);\n            this.id = new IntColumnBuilder<>(\"atom_site\", \"id\", null);\n            this.typeSymbol = new StrColumnBuilder<>(\"atom_site\", \"type_symbol\", null);\n            this.labelAtomId = new StrColumnBuilder<>(\"atom_site\", \"label_atom_id\", null);\n            this.labelAltId = new StrColumnBuilder<>(\"atom_site\", \"label_alt_id\", null);\n            this.labelCompId = new StrColumnBuilder<>(\"atom_site\", \"label_comp_id\", null);\n            this.labelAsymId = new StrColumnBuilder<>(\"atom_site\", \"label_asym_id\", null);\n            this.labelEntityId = new StrColumnBuilder<>(\"atom_site\", \"label_entity_id\", null);\n            this.labelSeqId = new IntColumnBuilder<>(\"atom_site\", \"label_seq_id\", null);\n            this.pdbxPDBInsCode = new StrColumnBuilder<>(\"atom_site\", \"pdbx_PDB_ins_code\", null);\n            this.cartnX = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_x\", null);\n            this.cartnY = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_y\", null);\n            this.cartnZ = new FloatColumnBuilder<>(\"atom_site\", \"Cartn_z\", null);\n            this.occupancy = new FloatColumnBuilder<>(\"atom_site\", \"occupancy\", null);\n            this.bIsoOrEquiv = new FloatColumnBuilder<>(\"atom_site\", \"B_iso_or_equiv\", null);\n            this.authSeqId = new IntColumnBuilder<>(\"atom_site\", \"auth_seq_id\", null);\n            this.authCompId = new StrColumnBuilder<>(\"atom_site\", \"auth_comp_id\", null);\n            this.authAsymId = new StrColumnBuilder<>(\"atom_site\", \"auth_asym_id\", null);\n            this.authAtomId = new StrColumnBuilder<>(\"atom_site\", \"auth_atom_id\", null);\n            this.pdbxPDBModelNum = new IntColumnBuilder<>(\"atom_site\", \"pdbx_PDB_model_num\", null);\n        }\n\n        @Override\n        public void accept(WrappedAtom wrappedAtom) {\n            Atom atom = wrappedAtom.getAtom();\n            Group group = atom.getGroup();\n            Chain chain = group.getChain();\n\n            groupPDB.add(group.getType().equals(GroupType.HETATM) ? \"HETATM\" : \"ATOM\");\n            id.add(wrappedAtom.getAtomId());\n            Element element = atom.getElement();\n            typeSymbol.add(element.equals(Element.R) ? \"X\" : element.toString().toUpperCase());\n            labelAtomId.add(atom.getName());\n            Character altLoc = atom.getAltLoc();\n            if (altLoc == null || altLoc == ' ') {\n                labelAltId.markNextNotPresent();\n            } else {\n                labelAltId.add(String.valueOf(altLoc));\n            }\n            labelCompId.add(group.getPDBName());\n            labelAsymId.add(wrappedAtom.getChainId());\n            String entityId = \"0\";\n            int seqId = group.getResidueNumber().getSeqNum();\n            if (chain.getEntityInfo() != null) {\n                entityId = Integer.toString(chain.getEntityInfo().getMolId());\n                if (chain.getEntityInfo().getType() == EntityType.POLYMER) {\n                    // this only makes sense for polymeric chains, non-polymer chains will never have seqres groups and\n                    // there's no point in calling getAlignedResIndex\n                    seqId = chain.getEntityInfo().getAlignedResIndex(group, chain);\n                }\n            }\n            labelEntityId.add(entityId);\n            labelSeqId.add(seqId);\n            String insCode = \"\";\n            if (group.getResidueNumber().getInsCode() != null ) {\n                insCode = Character.toString(group.getResidueNumber().getInsCode());\n            }\n            if (insCode.isEmpty()) {\n                pdbxPDBInsCode.markNextUnknown();\n            } else {\n                pdbxPDBInsCode.add(insCode);\n            }\n            cartnX.add(atom.getX());\n            cartnY.add(atom.getY());\n            cartnZ.add(atom.getZ());\n            occupancy.add(atom.getOccupancy());\n            bIsoOrEquiv.add(atom.getTempFactor());\n            authSeqId.add(group.getResidueNumber().getSeqNum());\n            authCompId.add(group.getPDBName());\n            authAsymId.add(wrappedAtom.getChainName());\n            authAtomId.add(atom.getName());\n            pdbxPDBModelNum.add(wrappedAtom.getModel());\n        }\n\n        AtomSiteCollector combine(AtomSiteCollector other) {\n            throw new UnsupportedOperationException(\"impl by calling addAll for all collection - not feeling like writing that code\");\n        }\n\n        Category get() {\n            return new CategoryBuilder(\"atom_site\", null)\n                    .addColumn(groupPDB.build())\n                    .addColumn(id.build())\n                    .addColumn(typeSymbol.build())\n                    .addColumn(labelAtomId.build())\n                    .addColumn(labelAltId.build())\n                    .addColumn(labelCompId.build())\n                    .addColumn(labelAsymId.build())\n                    .addColumn(labelEntityId.build())\n                    .addColumn(labelSeqId.build())\n                    .addColumn(pdbxPDBInsCode.build())\n                    .addColumn(cartnX.build())\n                    .addColumn(cartnY.build())\n                    .addColumn(cartnZ.build())\n                    .addColumn(occupancy.build())\n                    .addColumn(bIsoOrEquiv.build())\n                    .addColumn(authSeqId.build())\n                    .addColumn(authCompId.build())\n                    .addColumn(authAsymId.build())\n                    .addColumn(authAtomId.build())\n                    .addColumn(pdbxPDBModelNum.build())\n                    .build();\n        }\n    }\n}\n","originTest":"package org.biojava.nbio.structure.test.io.cif;\n\nimport org.biojava.nbio.structure.*;\nimport org.biojava.nbio.structure.io.cif.CifFileConverter;\nimport org.junit.Test;\nimport org.rcsb.cif.CifReader;\nimport org.rcsb.cif.CifWriter;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\npublic class CifFileSupplierImplTest {\n    @Test\n    public void test1SMT() throws IOException {\n        // an x-ray structure\n        testRoundTrip(\"1SMT\");\n    }\n\n    /**\n     * MMCIF write test for an NMR structure with 2 chains\n     * @throws IOException propagated\n     */\n    @Test\n    public void test2N3J() throws IOException {\n        // an NMR structure (multimodel) with 2 chains\n        testRoundTrip(\"2N3J\");\n    }\n\n    @Test\n    public void test1A2C() throws IOException {\n        // a structure with insertion codes\n        testRoundTrip(\"1A2C\");\n    }\n\n    private static void testRoundTrip(String pdbId) throws IOException {\n        Structure originalStruct = CifFileConverter.convert(CifReader.readText(new URL(\"https://files.rcsb.org/download/\" + pdbId\n                + \".cif\").openStream()));\n\n        File outputFile = File.createTempFile(\"biojava_testing_\", \".cif\");\n        outputFile.deleteOnExit();\n\n        FileWriter fw = new FileWriter(outputFile);\n        String cif = CifWriter.composeText(CifFileConverter.convert(originalStruct));\n        fw.write(cif);\n        fw.close();\n\n        Structure readStruct = CifFileConverter.convert(CifReader.readText(Files.newInputStream(outputFile.toPath())));\n\n        assertNotNull(readStruct);\n        assertEquals(originalStruct.getChains().size(), readStruct.getChains().size());\n        assertEquals(originalStruct.nrModels(), readStruct.nrModels());\n\n        for (int i = 0; i < originalStruct.nrModels(); i++) {\n            assertEquals(originalStruct.getModel(i).size(), readStruct.getModel(i).size());\n        }\n\n        for (int modelIdx = 0; modelIdx < originalStruct.nrModels(); modelIdx++) {\n            for (int i = 0; i < originalStruct.getModel(modelIdx).size(); i++) {\n                assertEquals(originalStruct.getChains().get(i).getAtomGroups().size(),\n                        readStruct.getChains().get(i).getAtomGroups().size());\n\n                Chain origChain = originalStruct.getModel(modelIdx).get(i);\n                Chain readChain = readStruct.getModel(modelIdx).get(i);\n\n                assertEquals(origChain.getAtomGroups().size(), readChain.getAtomGroups().size());\n                assertEquals(origChain.getId(), readChain.getId());\n                assertEquals(origChain.getName(), readChain.getName());\n\n                Atom[] origAtoms = StructureTools.getAllAtomArray(origChain);\n                Atom[] readAtoms = StructureTools.getAllAtomArray(readChain);\n\n                assertEquals(origAtoms.length, readAtoms.length);\n\n                for (int atomIdx = 0; atomIdx < origAtoms.length; atomIdx++) {\n                    assertEquals(\"atom serials don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getPDBserial(), readAtoms[atomIdx].getPDBserial());\n\n                    assertEquals(\"atom names don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getName(), readAtoms[atomIdx].getName());\n\n                    assertEquals(\"atom elements don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getElement(), readAtoms[atomIdx].getElement());\n\n                    assertEquals(\"x values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getX(), readAtoms[atomIdx].getX(),0.0001);\n\n                    assertEquals(\"y values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getY(), readAtoms[atomIdx].getY(),0.0001);\n\n                    assertEquals(\"z values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getZ(), readAtoms[atomIdx].getZ(),0.0001);\n                }\n            }\n        }\n\n        // Test cell and symmetry\n        assertEquals(originalStruct.getCrystallographicInfo().getSpaceGroup(),\n                readStruct.getCrystallographicInfo().getSpaceGroup());\n    }\n\n    /**\n     * Tests that structures containing symmetry mates with modified chain identifiers\n     * can be written out correctly.\n     */\n    @Test\n    public void testBiounitWriting()  {\n        Structure s = createDummyStructure();\n        String mmcif = CifWriter.composeText(CifFileConverter.convert(s));\n        String[] lines = mmcif.split(\"\\n\");\n        long atomLines = Arrays.stream(lines).filter(l -> l.startsWith(\"ATOM\")).count();\n        assertNotNull(mmcif);\n        assertEquals(4, atomLines);\n    }\n\n    private static Structure createDummyStructure() {\n        Group g = new AminoAcidImpl();\n        Atom a = getAtom(\"CA\", Element.C, 1, 1, 1, 1);\n        g.addAtom(a);\n        g.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n        Group altLocG = new AminoAcidImpl();\n        Atom a2 = getAtom(\"CA\", Element.C, 2, 2, 2, 2);\n        altLocG.addAtom(a2);\n        altLocG.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n\n        g.addAltLoc(altLocG);\n\n        Chain c1 = new ChainImpl();\n        c1.addGroup(g);\n        c1.setId(\"A\");\n        EntityInfo entityInfo = new EntityInfo();\n        entityInfo.setMolId(1);\n        entityInfo.addChain(c1);\n        c1.setEntityInfo(entityInfo);\n\n        Group gc2 = new AminoAcidImpl();\n        Atom ac2 = getAtom(\"CA\", Element.C, 3, 3, 3, 3);\n        gc2.addAtom(ac2);\n        gc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        Group altLocGc2 = new AminoAcidImpl();\n        Atom ac22 = getAtom(\"CA\", Element.C, 4, 4, 4, 4);\n        altLocGc2.addAtom(ac22);\n        altLocGc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        gc2.addAltLoc(altLocGc2);\n\n        Chain c2 = new ChainImpl();\n        c2.addGroup(gc2);\n        c2.setId(\"A_1\");\n        c2.setEntityInfo(entityInfo);\n        entityInfo.addChain(c2);\n\n        Structure s = new StructureImpl();\n        s.addChain(c1);\n        s.addChain(c2);\n        return s;\n    }\n\n    private static Atom getAtom(String name, Element e, int id, double x, double y, double z) {\n        Atom a = new AtomImpl();\n        a.setX(x);\n        a.setY(y);\n        a.setZ(z);\n        a.setPDBserial(id);\n        a.setName(name);\n        a.setElement(e);\n        return a;\n    }\n}","changedTest":"package org.biojava.nbio.structure.test.io.cif;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Element;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.io.cif.CifFileConverter;\nimport org.junit.Test;\nimport org.rcsb.cif.CifReader;\nimport org.rcsb.cif.CifWriter;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.util.Arrays;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\npublic class CifFileSupplierImplTest {\n    @Test\n    public void test1SMT() throws IOException {\n        // an x-ray structure\n        testRoundTrip(\"1SMT\");\n    }\n\n    /**\n     * MMCIF write test for an NMR structure with 2 chains\n     * @throws IOException propagated\n     */\n    @Test\n    public void test2N3J() throws IOException {\n        // an NMR structure (multimodel) with 2 chains\n        testRoundTrip(\"2N3J\");\n    }\n\n    @Test\n    public void test1A2C() throws IOException {\n        // a structure with insertion codes\n        testRoundTrip(\"1A2C\");\n    }\n\n    private static void testRoundTrip(String pdbId) throws IOException {\n        Structure originalStruct = CifFileConverter.convert(CifReader.readText(new URL(\"https://files.rcsb.org/download/\" + pdbId\n                + \".cif\").openStream()));\n\n        File outputFile = File.createTempFile(\"biojava_testing_\", \".cif\");\n        outputFile.deleteOnExit();\n\n        FileWriter fw = new FileWriter(outputFile);\n        String cif = CifWriter.composeText(CifFileConverter.convert(originalStruct));\n        fw.write(cif);\n        fw.close();\n\n        Structure readStruct = CifFileConverter.convert(CifReader.readText(Files.newInputStream(outputFile.toPath())));\n\n        assertNotNull(readStruct);\n        assertEquals(originalStruct.getChains().size(), readStruct.getChains().size());\n        assertEquals(originalStruct.nrModels(), readStruct.nrModels());\n\n        for (int i = 0; i < originalStruct.nrModels(); i++) {\n            assertEquals(originalStruct.getModel(i).size(), readStruct.getModel(i).size());\n        }\n\n        for (int modelIdx = 0; modelIdx < originalStruct.nrModels(); modelIdx++) {\n            for (int i = 0; i < originalStruct.getModel(modelIdx).size(); i++) {\n                assertEquals(originalStruct.getChains().get(i).getAtomGroups().size(),\n                        readStruct.getChains().get(i).getAtomGroups().size());\n\n                Chain origChain = originalStruct.getModel(modelIdx).get(i);\n                Chain readChain = readStruct.getModel(modelIdx).get(i);\n\n                assertEquals(origChain.getAtomGroups().size(), readChain.getAtomGroups().size());\n                assertEquals(origChain.getId(), readChain.getId());\n                assertEquals(origChain.getName(), readChain.getName());\n\n                Atom[] origAtoms = StructureTools.getAllAtomArray(origChain);\n                Atom[] readAtoms = StructureTools.getAllAtomArray(readChain);\n\n                assertEquals(origAtoms.length, readAtoms.length);\n\n                for (int atomIdx = 0; atomIdx < origAtoms.length; atomIdx++) {\n                    assertEquals(\"atom serials don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getPDBserial(), readAtoms[atomIdx].getPDBserial());\n\n                    assertEquals(\"atom names don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getName(), readAtoms[atomIdx].getName());\n\n                    assertEquals(\"atom elements don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getElement(), readAtoms[atomIdx].getElement());\n\n                    assertEquals(\"x values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getX(), readAtoms[atomIdx].getX(),0.0001);\n\n                    assertEquals(\"y values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getY(), readAtoms[atomIdx].getY(),0.0001);\n\n                    assertEquals(\"z values don't match for atom \" + origAtoms[atomIdx].toString(),\n                            origAtoms[atomIdx].getZ(), readAtoms[atomIdx].getZ(),0.0001);\n                }\n            }\n        }\n\n        // Test cell and symmetry\n        assertEquals(originalStruct.getCrystallographicInfo().getSpaceGroup(),\n                readStruct.getCrystallographicInfo().getSpaceGroup());\n    }\n\n    /**\n     * Tests that structures containing symmetry mates with modified chain identifiers\n     * can be written out correctly.\n     */\n    @Test\n    public void testBiounitWriting()  {\n        Structure s = createDummyStructure();\n        String mmcif = CifWriter.composeText(CifFileConverter.convert(s));\n        String[] lines = mmcif.split(\"\\n\");\n        long atomLines = Arrays.stream(lines).filter(l -> l.startsWith(\"ATOM\")).count();\n        assertNotNull(mmcif);\n        assertEquals(4, atomLines);\n    }\n\n    private static Structure createDummyStructure() {\n        Group g = new AminoAcidImpl();\n        Atom a = getAtom(\"CA\", Element.C, 1, 1, 1, 1);\n        g.addAtom(a);\n        g.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n        Group altLocG = new AminoAcidImpl();\n        Atom a2 = getAtom(\"CA\", Element.C, 2, 2, 2, 2);\n        altLocG.addAtom(a2);\n        altLocG.setResidueNumber(new ResidueNumber(\"A\", 1, null));\n\n        g.addAltLoc(altLocG);\n\n        Chain c1 = new ChainImpl();\n        c1.addGroup(g);\n        c1.setId(\"A\");\n        EntityInfo entityInfo = new EntityInfo();\n        entityInfo.setMolId(1);\n        entityInfo.addChain(c1);\n        c1.setEntityInfo(entityInfo);\n\n        Group gc2 = new AminoAcidImpl();\n        Atom ac2 = getAtom(\"CA\", Element.C, 3, 3, 3, 3);\n        gc2.addAtom(ac2);\n        gc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        Group altLocGc2 = new AminoAcidImpl();\n        Atom ac22 = getAtom(\"CA\", Element.C, 4, 4, 4, 4);\n        altLocGc2.addAtom(ac22);\n        altLocGc2.setResidueNumber(new ResidueNumber(\"A_1\", 1, null));\n\n        gc2.addAltLoc(altLocGc2);\n\n        Chain c2 = new ChainImpl();\n        c2.addGroup(gc2);\n        c2.setId(\"A_1\");\n        c2.setEntityInfo(entityInfo);\n        entityInfo.addChain(c2);\n\n        Structure s = new StructureImpl();\n        s.addChain(c1);\n        s.addChain(c2);\n        return s;\n    }\n\n    private static Atom getAtom(String name, Element e, int id, double x, double y, double z) {\n        Atom a = new AtomImpl();\n        a.setX(x);\n        a.setY(y);\n        a.setZ(z);\n        a.setPDBserial(id);\n        a.setName(name);\n        a.setElement(e);\n        return a;\n    }\n}","commitMessage":"removes star imports\n","test_commitMessage":"removes star imports\n","allZero":false}