{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/chem/DownloadChemCompProvider.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/chem/TestDownloadChemCompProvider.java","prod_time":"2022-11-19 06:48:05","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"e3ecec524d13bfaa51f1a7089dfb21ffdbf7b24b","test_commitID":"","isfound":"not found test change","originPro":"package org.biojava.nbio.structure.chem;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.align.util.URLConnectionTools;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.biojava.nbio.structure.io.cif.ChemCompConverter;\nimport org.rcsb.cif.ParsingException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPOutputStream;\n\n/**\n * This provider of chemical components can download and cache chemical component definition files from the RCSB PDB web\n * site. It is the default way to access these definitions. If this provider is called he first time, it will download\n * and install all chemical component definitions in a local directory. Once the definition files have been installed,\n * it has quick startup time and low memory requirements.\n *\n * An alternative provider, that keeps all definitions in memory is the {@link AllChemCompProvider}. Another provider,\n * that does not require any network access, but only can support a limited set of chemical component definitions, is\n * the {@link ReducedChemCompProvider}.\n *\n * @author Andreas Prlic\n */\npublic class DownloadChemCompProvider implements ChemCompProvider {\n    private static final Logger logger = LoggerFactory.getLogger(DownloadChemCompProvider.class);\n\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    public static final String CHEM_COMP_CACHE_DIRECTORY = \"chemcomp\";\n    public static final String DEFAULT_SERVER_URL = \"https://files.rcsb.org/ligands/download/\";\n    public static final String DEFAULT_CHEMCOMP_PATHURL_TEMPLATE = \"{ccd_id}.cif\";\n\n    /**\n     * The base URL to which the full path specified via {@link #setChemCompPathUrlTemplate(String)} is appended.\n     * It is assumed that it has a trailing slash.\n     */\n    public static String serverBaseUrl = DEFAULT_SERVER_URL;\n\n    private static File path;\n\n    private static String chemCompPathUrlTemplate = DEFAULT_CHEMCOMP_PATHURL_TEMPLATE;\n\n    static final Pattern CCD_ID_TEMPLATE_REGEX = Pattern.compile(\"\\\\{ccd_id(?::(\\\\d+_\\\\d+|[-+]?\\\\d+))?}\");\n\n\n    // flags to make sure there is only one thread running that is loading the dictionary\n    static AtomicBoolean loading = new AtomicBoolean(false);\n\n    static final List<String> protectedIDs = new ArrayList<>();\n    static {\n        protectedIDs.add(\"CON\");\n        protectedIDs.add(\"PRN\");\n        protectedIDs.add(\"AUX\");\n        protectedIDs.add(\"NUL\");\n    }\n\n    private static ChemCompProvider fallback = null; // Fallback provider if the download fails\n\n    /**\n     * by default we will download only some of the files. User has to request that all files should be downloaded...\n     */\n    boolean downloadAll = false;\n\n    public DownloadChemCompProvider() {\n        this(null);\n    }\n\n    public DownloadChemCompProvider(String cacheFilePath) {\n        logger.debug(\"Initialising DownloadChemCompProvider\");\n\n        // note that path is static, so this is just to make sure that all non-static methods will have path initialised\n        if (cacheFilePath != null) {\n            path = new File(cacheFilePath);\n        }\n    }\n\n    /**\n     * Set the base URL for the location of all chemical component CIF files, to which the chemCompPathUrlTemplate\n     * is appended, settable in {@link #setChemCompPathUrlTemplate(String)}. A trailing slash is appended\n     * if not present.\n     */\n    public static void setServerBaseUrl(String serverBaseUrl) {\n        if (!serverBaseUrl.endsWith(\"/\")) {\n            serverBaseUrl = serverBaseUrl + \"/\";\n        }\n        DownloadChemCompProvider.serverBaseUrl = serverBaseUrl;\n    }\n\n    /**\n     * Set the path to append to the serverBaseUrl (settable in {@link #setServerBaseUrl(String)}).\n     * The string can contain placeholders that will be expanded at runtime:\n     * <li>\"{ccd_id}\" to be replaced by the chemical component identifier, in capitals</li>\n     * <li>\"{ccd_id:beginIndex-endIndex}\" to be replaced by a substring of the chemical component identifier in capitals,\n     * with indices following the same convention as {@link String#substring(int, int)} </li>\n     * <li>\"{ccd_id:index}\" to be replaced by a substring of the chemical component identifier in capitals,\n     * with index either a positive or negative integer to substring from left or right of the string respectively.</li>\n     * If any of the indices are off-bounds, then the full chemical component identifier is replaced\n     */\n    public static void setChemCompPathUrlTemplate(String chemCompPathUrlTemplate) {\n        DownloadChemCompProvider.chemCompPathUrlTemplate = chemCompPathUrlTemplate;\n    }\n\n    /**\n     * Get this provider's cache path\n     * @return\n     */\n    public static File getPath() {\n        if (path == null) {\n            UserConfiguration config = new UserConfiguration();\n            path = new File(config.getCacheFilePath());\n        }\n        return path;\n    }\n\n    /**\n     * Checks if the chemical components already have been installed into the PDB directory.\n     * If not, will download the chemical components definitions file and split it up into small\n     * subfiles.\n     */\n    public void checkDoFirstInstall() {\n        if (!downloadAll) {\n            return;\n        }\n\n        // this makes sure there is a file separator between every component,\n        // if path has a trailing file separator or not, it will work for both cases\n        File dir = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        File f = new File(dir, \"components.cif.gz\");\n\n        if (!f.exists()) {\n            downloadAllDefinitions();\n        } else {\n            // file exists.. did it get extracted?\n            FilenameFilter filter = (dir1, file) -> file.endsWith(\".cif.gz\");\n            String[] files = dir.list(filter);\n            if (files.length < 500) {\n                // not all did get unpacked\n                try {\n                    split();\n                } catch (IOException e) {\n                    logger.error(\"Could not split file {} into individual chemical component files. Error: {}\",\n                            f.toString(), e.getMessage());\n                }\n            }\n        }\n    }\n\n    private void split() throws IOException {\n        logger.info(\"Installing individual chem comp files ...\");\n\n        File dir = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        File f = new File(dir, \"components.cif.gz\");\n\n        int counter = 0;\n        InputStreamProvider prov = new InputStreamProvider();\n\n        try (BufferedReader buf = new BufferedReader (new InputStreamReader(prov.getInputStream(f)))) {\n            String line;\n            line = buf.readLine ();\n            StringWriter writer = new StringWriter();\n\n            String currentID = null;\n            while (line != null) {\n                if (line.startsWith(\"data_\")) {\n                    // a new record found!\n\n                    if (currentID != null) {\n                        writeID(writer.toString(), currentID);\n                        counter++;\n                    }\n\n                    currentID = line.substring(5);\n                    writer = new StringWriter();\n                }\n\n                writer.append(line);\n                writer.append(NEWLINE);\n\n                line = buf.readLine();\n            }\n\n            // write the last record...\n            writeID(writer.toString(), currentID);\n            counter++;\n        }\n\n        logger.info(\"Created {} chemical component files.\", counter);\n    }\n\n    /**\n     * Output chemical contents to a file\n     * @param contents File contents\n     * @param currentID Chemical ID, used to determine the filename\n     * @throws IOException\n     */\n    private void writeID(String contents, String currentID) throws IOException {\n        String localName = getLocalFileName(currentID);\n        try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(localName)))) {\n            pw.print(contents);\n            pw.flush();\n        }\n    }\n\n    /**\n     * Loads the definitions for this {@link ChemComp} from a local file and instantiates a new object.\n     *\n     * @param recordName the ID of the {@link ChemComp}\n     * @return a new {@link ChemComp} definition.\n     */\n    @Override\n    public ChemComp getChemComp(String recordName) {\n        // make sure we work with upper case records\n        recordName = recordName.toUpperCase().trim();\n\n        boolean haveFile = true;\n        if (recordName.equals(\"?\")) {\n            return null;\n        }\n\n        if (fileIsAbsent(recordName)) {\n            // check if we should install all components\n            checkDoFirstInstall();\n        }\n        if (fileIsAbsent(recordName)) {\n            // we previously have installed already the definitions,\n            // just do an incrememntal update\n            haveFile = downloadChemCompRecord(recordName);\n        }\n\n        // Added check that download was successful and chemical component is available.\n        if (haveFile) {\n            String filename = getLocalFileName(recordName);\n            try {\n                ChemComp chemComp;\n                try {\n                    ChemicalComponentDictionary dict = ChemCompConverter.fromPath(Paths.get(filename));\n                    chemComp = dict.getChemComp(recordName);\n                } catch (ParsingException e) {\n                    // happens for corrupt files\n                    chemComp = null;\n                }\n\n                // May be null if the file was corrupt. Fall back on ReducedChemCompProvider in that case\n                if (chemComp != null) {\n                    return chemComp;\n                }\n            } catch (IOException e) {\n                logger.warn(\"Could not download chemical component file {} for {}. Error: {}. Now trying to use the \" +\n                                \"local chemical component definitions.\", filename, recordName, e.getMessage());\n            }\n        }\n\n        // see https://github.com/biojava/biojava/issues/315\n        // probably a network error happened. Try to use the ReducedChemCOmpProvider\n        if (fallback == null) {\n            fallback = new ReducedChemCompProvider();\n        }\n\n        logger.warn(\"Falling back to ReducedChemCompProvider for {}. This could indicate a network error.\", recordName);\n        return fallback.getChemComp(recordName);\n    }\n\n    /**\n     * Returns the file name that contains the definition for this {@link ChemComp}\n     *\n     * @param recordName the ID of the {@link ChemComp}\n     * @return full path to the file\n     */\n    public static String getLocalFileName(String recordName) {\n        if (protectedIDs.contains(recordName)) {\n            recordName = \"_\" + recordName;\n        }\n\n        File f = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        if (!f.exists()) {\n            logger.info(\"Creating directory {}\", f);\n\n            boolean success = f.mkdir();\n            // we've checked in initPath that path is writable, so there's no need to check if it succeeds\n            // in the unlikely case that in the meantime it isn't writable at least we log an error\n            if (!success) {\n                logger.error(\"Directory {} could not be created\", f);\n            }\n        }\n\n        File theFile = new File(f, recordName + \".cif.gz\");\n        return theFile.toString();\n    }\n\n    private static boolean fileIsAbsent(String recordName) {\n        String fileName = getLocalFileName(recordName);\n        File f = new File(fileName);\n\n        // delete files that are too short to have contents\n        if (f.length() < LocalPDBDirectory.MIN_PDB_FILE_SIZE) {\n            // Delete defensively.\n            // Note that if delete is unsuccessful, we re-download the file anyways\n            f.delete();\n            return true;\n        }\n\n        return !f.exists();\n    }\n\n    /**\n     * Expands the given path URL template, replacing the placeholders as specified in {@link #setChemCompPathUrlTemplate(String)}\n     * by the ccdId given (or its substrings, if indices are present in the template)\n     * @param templateStr the template string with placeholders for ccd ids\n     * @param ccdId the ccd id to replace (in full or a substring)\n     * @return the input templateStr with placeholders replaced\n     */\n    static String expandPathUrlTemplate(String templateStr, String ccdId) {\n        Matcher m = CCD_ID_TEMPLATE_REGEX.matcher(templateStr);\n        StringBuilder output = new StringBuilder();\n        int lastIndex = 0;\n        while (m.find()) {\n            String repString = ccdId;\n            String indicesStr = m.group(1);\n            try {\n                if (indicesStr == null) {\n                    // no substringing\n                    repString = ccdId;\n                } else if (!indicesStr.contains(\"_\")) {\n                    // left/right substring\n                    int idx = Integer.parseInt(indicesStr);\n                    if (idx < 0) { // right substring\n                        repString = ccdId.substring(ccdId.length() + idx);\n                    } else { // left substring\n                        repString = ccdId.substring(0, idx);\n                    }\n                } else if (indicesStr.contains(\"_\")) {\n                    // start and end index\n                    String[] tokens = indicesStr.split(\"_\");\n                    int begIdx = Integer.parseInt(tokens[0]);\n                    int endIdx = Integer.parseInt(tokens[1]);\n                    repString = ccdId.substring(begIdx, endIdx);\n                }\n            } catch (IndexOutOfBoundsException e) {\n                // we don't set repString, it keeps original value ccdId\n                logger.debug(\"Indices included in path URL template {} are out of bounds for string {}\", templateStr, ccdId);\n            }\n            output.append(templateStr, lastIndex, m.start()).append(repString);\n\n            lastIndex = m.end();\n            // TODO when we upgrade to java 11, use the new methods introduced in java 9, see https://stackoverflow.com/questions/9605716/java-regular-expression-find-and-replace\n        }\n        if (lastIndex < templateStr.length()) {\n            output.append(templateStr, lastIndex, templateStr.length());\n        }\n        return output.toString();\n    }\n\n    /**\n     * @param recordName : three-letter name\n     * @return true if successful download\n     */\n    private static boolean downloadChemCompRecord(String recordName) {\n        String localName = getLocalFileName(recordName);\n        File newFile;\n        try {\n            newFile = File.createTempFile(\"chemcomp\" + recordName, \"cif\");\n            logger.debug(\"Will write chem comp file to temp file {}\", newFile.toString());\n        } catch(IOException e) {\n            logger.error(\"Could not write to temp directory {} to create the chemical component download temp file\", System.getProperty(\"java.io.tmpdir\"));\n            return false;\n        }\n\n        String u = serverBaseUrl + expandPathUrlTemplate(chemCompPathUrlTemplate, recordName);\n\n        logger.debug(\"Downloading chem comp definition from {}\", u);\n\n        URL url = null;\n        try {\n            url = new URL(u);\n            URLConnection uconn = URLConnectionTools.openURLConnection(url);\n\n            try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));\n                 BufferedReader fileBuffer = new BufferedReader(new InputStreamReader(uconn.getInputStream()))) {\n                String line;\n                boolean success = false;\n                while ((line = fileBuffer.readLine()) != null) {\n                    pw.println(line);\n                    success = true;\n                }\n                if(!success) {\n                \tthrow new IOException(\"Malformed URL or no content found in \"+url.toString());\n                }\n\n                pw.flush();\n            }\n            // Now we move this across to where it actually wants to be\n            Files.move(newFile.toPath(), Paths.get(localName), StandardCopyOption.REPLACE_EXISTING);\n\n            return true;\n        } catch (IOException e) {\n            logger.error(\"Could not download {} OR store locally to {} Error ={}\",\n                    url,\n                    localName,\n                    e.getMessage());\n            newFile.delete();\n        }\n        return false;\n    }\n\n    private void downloadAllDefinitions() {\n        if (loading.get()) {\n            logger.info(\"Waiting for other thread to install chemical components...\");\n        }\n\n        while (loading.get()) {\n            // another thread is already downloading the components definitions\n            // wait for the other thread to finish...\n            try {\n                // wait half a second\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                //e.printStackTrace();\n                logger.error(\"Thread interrupted \"+e.getMessage());\n            }\n\n            logger.info(\"Another thread installed the chemical components.\");\n            return;\n        }\n\n        loading.set(true);\n        long timeS = System.currentTimeMillis();\n\n        logger.info(\"Performing first installation of chemical components.\");\n        logger.info(\"Downloading components.cif.gz ...\");\n\n        try {\n            AllChemCompProvider.downloadFile();\n        } catch (IOException e) {\n            logger.error(\"Could not download the all chemical components file. Error: {}. \"\n                    + \"Chemical components information won't be available\", e.getMessage());\n            // no point in trying to split if the file could not be downloaded\n            loading.set(false);\n            return;\n        }\n        try {\n            split();\n        } catch (IOException e) {\n            logger.error(\"Could not split all chem comp file into individual chemical component files. Error: {}\",\n                    e.getMessage());\n            // no point in reporting time\n            loading.set(false);\n            return;\n        }\n        long timeE = System.currentTimeMillis();\n        logger.info(\"time to install chem comp dictionary: \" + (timeE - timeS) / 1000 + \" sec.\");\n        loading.set(false);\n    }\n\n    /**\n     * By default this provider will download only some of the {@link ChemComp} files.\n     * The user has to request that all files should be downloaded by setting this parameter to true.\n     *\n     *  @return flag if the all components should be downloaded and installed at startup. (default: false)\n     */\n    public boolean isDownloadAll() {\n        return downloadAll;\n    }\n\n    /** By default this provider will download only some of the {@link ChemComp} files.\n     * The user has to request that all files should be downloaded by setting this parameter to true.\n     *\n     * @param downloadAll if the all components should be downloaded and installed at startup. (default: false)\n     */\n    public void setDownloadAll(boolean downloadAll) {\n        this.downloadAll = downloadAll;\n    }\n}\n","changedPro":"package org.biojava.nbio.structure.chem;\n\nimport org.biojava.nbio.core.util.InputStreamProvider;\nimport org.biojava.nbio.structure.align.util.URLConnectionTools;\nimport org.biojava.nbio.structure.align.util.UserConfiguration;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.biojava.nbio.structure.io.cif.ChemCompConverter;\nimport org.rcsb.cif.ParsingException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.zip.GZIPOutputStream;\n\n/**\n * This provider of chemical components can download and cache chemical component definition files from the RCSB PDB web\n * site. It is the default way to access these definitions. If this provider is called he first time, it will download\n * and install all chemical component definitions in a local directory. Once the definition files have been installed,\n * it has quick startup time and low memory requirements.\n *\n * An alternative provider, that keeps all definitions in memory is the {@link AllChemCompProvider}. Another provider,\n * that does not require any network access, but only can support a limited set of chemical component definitions, is\n * the {@link ReducedChemCompProvider}.\n *\n * @author Andreas Prlic\n */\npublic class DownloadChemCompProvider implements ChemCompProvider {\n    private static final Logger logger = LoggerFactory.getLogger(DownloadChemCompProvider.class);\n\n    private static final String NEWLINE = System.getProperty(\"line.separator\");\n\n    public static final String CHEM_COMP_CACHE_DIRECTORY = \"chemcomp\";\n    public static final String DEFAULT_SERVER_URL = \"https://files.rcsb.org/ligands/download/\";\n    public static final String DEFAULT_CHEMCOMP_PATHURL_TEMPLATE = \"{ccd_id}.cif\";\n\n    /**\n     * The base URL to which the full path specified via {@link #setChemCompPathUrlTemplate(String)} is appended.\n     * It is assumed that it has a trailing slash.\n     */\n    public static String serverBaseUrl = DEFAULT_SERVER_URL;\n\n    private static File path;\n\n    private static String chemCompPathUrlTemplate = DEFAULT_CHEMCOMP_PATHURL_TEMPLATE;\n\n    static final Pattern CCD_ID_TEMPLATE_REGEX = Pattern.compile(\"\\\\{ccd_id(?::(\\\\d+_\\\\d+|[-+]?\\\\d+))?}\");\n\n\n    // flags to make sure there is only one thread running that is loading the dictionary\n    static AtomicBoolean loading = new AtomicBoolean(false);\n\n    static final List<String> protectedIDs = new ArrayList<>();\n    static {\n        protectedIDs.add(\"CON\");\n        protectedIDs.add(\"PRN\");\n        protectedIDs.add(\"AUX\");\n        protectedIDs.add(\"NUL\");\n    }\n\n    private static ChemCompProvider fallback = null; // Fallback provider if the download fails\n\n    /**\n     * by default we will download only some of the files. User has to request that all files should be downloaded...\n     */\n    boolean downloadAll = false;\n\n    public DownloadChemCompProvider() {\n        this(null);\n    }\n\n    public DownloadChemCompProvider(String cacheFilePath) {\n        logger.debug(\"Initialising DownloadChemCompProvider\");\n\n        // note that path is static, so this is just to make sure that all non-static methods will have path initialised\n        if (cacheFilePath != null) {\n            path = new File(cacheFilePath);\n        }\n    }\n\n    /**\n     * Set the base URL for the location of all chemical component CIF files, to which the chemCompPathUrlTemplate\n     * is appended, settable in {@link #setChemCompPathUrlTemplate(String)}. A trailing slash is appended\n     * if not present.\n     */\n    public static void setServerBaseUrl(String serverBaseUrl) {\n        if (!serverBaseUrl.endsWith(\"/\")) {\n            serverBaseUrl = serverBaseUrl + \"/\";\n        }\n        DownloadChemCompProvider.serverBaseUrl = serverBaseUrl;\n    }\n\n    /**\n     * Set the path to append to the serverBaseUrl (settable in {@link #setServerBaseUrl(String)}).\n     * The string can contain placeholders that will be expanded at runtime:\n     * <li>\"{ccd_id}\" to be replaced by the chemical component identifier, in capitals</li>\n     * <li>\"{ccd_id:beginIndex-endIndex}\" to be replaced by a substring of the chemical component identifier in capitals,\n     * with indices following the same convention as {@link String#substring(int, int)} </li>\n     * <li>\"{ccd_id:index}\" to be replaced by a substring of the chemical component identifier in capitals,\n     * with index either a positive or negative integer to substring from left or right of the string respectively.</li>\n     * If any of the indices are off-bounds, then the full chemical component identifier is replaced\n     */\n    public static void setChemCompPathUrlTemplate(String chemCompPathUrlTemplate) {\n        DownloadChemCompProvider.chemCompPathUrlTemplate = chemCompPathUrlTemplate;\n    }\n\n    /**\n     * Get this provider's cache path\n     * @return\n     */\n    public static File getPath() {\n        if (path == null) {\n            UserConfiguration config = new UserConfiguration();\n            path = new File(config.getCacheFilePath());\n        }\n        return path;\n    }\n\n    /**\n     * Checks if the chemical components already have been installed into the PDB directory.\n     * If not, will download the chemical components definitions file and split it up into small\n     * subfiles.\n     */\n    public void checkDoFirstInstall() {\n        if (!downloadAll) {\n            return;\n        }\n\n        // this makes sure there is a file separator between every component,\n        // if path has a trailing file separator or not, it will work for both cases\n        File dir = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        File f = new File(dir, \"components.cif.gz\");\n\n        if (!f.exists()) {\n            downloadAllDefinitions();\n        } else {\n            // file exists.. did it get extracted?\n            FilenameFilter filter = (dir1, file) -> file.endsWith(\".cif.gz\");\n            String[] files = dir.list(filter);\n            if (files.length < 500) {\n                // not all did get unpacked\n                try {\n                    split();\n                } catch (IOException e) {\n                    logger.error(\"Could not split file {} into individual chemical component files. Error: {}\",\n                            f.toString(), e.getMessage());\n                }\n            }\n        }\n    }\n\n    private void split() throws IOException {\n        logger.info(\"Installing individual chem comp files ...\");\n\n        File dir = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        File f = new File(dir, \"components.cif.gz\");\n\n        int counter = 0;\n        InputStreamProvider prov = new InputStreamProvider();\n\n        try (BufferedReader buf = new BufferedReader (new InputStreamReader(prov.getInputStream(f)))) {\n            String line;\n            line = buf.readLine ();\n            StringWriter writer = new StringWriter();\n\n            String currentID = null;\n            while (line != null) {\n                if (line.startsWith(\"data_\")) {\n                    // a new record found!\n\n                    if (currentID != null) {\n                        writeID(writer.toString(), currentID);\n                        counter++;\n                    }\n\n                    currentID = line.substring(5);\n                    writer = new StringWriter();\n                }\n\n                writer.append(line);\n                writer.append(NEWLINE);\n\n                line = buf.readLine();\n            }\n\n            // write the last record...\n            writeID(writer.toString(), currentID);\n            counter++;\n        }\n\n        logger.info(\"Created {} chemical component files.\", counter);\n    }\n\n    /**\n     * Output chemical contents to a file\n     * @param contents File contents\n     * @param currentID Chemical ID, used to determine the filename\n     * @throws IOException\n     */\n    private void writeID(String contents, String currentID) throws IOException {\n        String localName = getLocalFileName(currentID);\n        try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(localName)))) {\n            pw.print(contents);\n            pw.flush();\n        }\n    }\n\n    /**\n     * Loads the definitions for this {@link ChemComp} from a local file and instantiates a new object.\n     *\n     * @param recordName the ID of the {@link ChemComp}\n     * @return a new {@link ChemComp} definition.\n     */\n    @Override\n    public ChemComp getChemComp(String recordName) {\n        // make sure we work with upper case records\n        recordName = recordName.toUpperCase().trim();\n\n        boolean haveFile = true;\n        if (recordName.equals(\"?\")) {\n            return null;\n        }\n\n        if (fileIsAbsent(recordName)) {\n            // check if we should install all components\n            checkDoFirstInstall();\n        }\n        if (fileIsAbsent(recordName)) {\n            // we previously have installed already the definitions,\n            // just do an incrememntal update\n            haveFile = downloadChemCompRecord(recordName);\n        }\n\n        // Added check that download was successful and chemical component is available.\n        if (haveFile) {\n            String filename = getLocalFileName(recordName);\n            try {\n                ChemComp chemComp;\n                try {\n                    ChemicalComponentDictionary dict = ChemCompConverter.fromPath(Paths.get(filename));\n                    chemComp = dict.getChemComp(recordName);\n                } catch (ParsingException e) {\n                    // happens for corrupt files\n                    chemComp = null;\n                }\n\n                // May be null if the file was corrupt. Fall back on ReducedChemCompProvider in that case\n                if (chemComp != null) {\n                    return chemComp;\n                }\n            } catch (IOException e) {\n                logger.warn(\"Could not download chemical component file {} for {}. Error: {}. Now trying to use the \" +\n                                \"local chemical component definitions.\", filename, recordName, e.getMessage());\n            }\n        }\n\n        // see https://github.com/biojava/biojava/issues/315\n        // probably a network error happened. Try to use the ReducedChemCOmpProvider\n        if (fallback == null) {\n            fallback = new ReducedChemCompProvider();\n        }\n\n        logger.warn(\"Falling back to ReducedChemCompProvider for {}. This could indicate a network error.\", recordName);\n        return fallback.getChemComp(recordName);\n    }\n\n    /**\n     * Returns the file name that contains the definition for this {@link ChemComp}\n     *\n     * @param recordName the ID of the {@link ChemComp}\n     * @return full path to the file\n     */\n    public static String getLocalFileName(String recordName) {\n        if (protectedIDs.contains(recordName)) {\n            recordName = \"_\" + recordName;\n        }\n\n        File f = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n        if (!f.exists()) {\n            logger.info(\"Creating directory {}\", f);\n\n            boolean success = f.mkdir();\n            // we've checked in initPath that path is writable, so there's no need to check if it succeeds\n            // in the unlikely case that in the meantime it isn't writable at least we log an error\n            if (!success) {\n                logger.error(\"Directory {} could not be created\", f);\n            }\n        }\n\n        File theFile = new File(f, recordName + \".cif.gz\");\n        return theFile.toString();\n    }\n\n    private static boolean fileIsAbsent(String recordName) {\n        String fileName = getLocalFileName(recordName);\n        File f = new File(fileName);\n\n        // delete files that are too short to have contents\n        if (f.length() < LocalPDBDirectory.MIN_PDB_FILE_SIZE) {\n            // Delete defensively.\n            // Note that if delete is unsuccessful, we re-download the file anyways\n            f.delete();\n            return true;\n        }\n\n        return !f.exists();\n    }\n\n    /**\n     * Expands the given path URL template, replacing the placeholders as specified in {@link #setChemCompPathUrlTemplate(String)}\n     * by the ccdId given (or its substrings, if indices are present in the template)\n     * @param templateStr the template string with placeholders for ccd ids\n     * @param ccdId the ccd id to replace (in full or a substring)\n     * @return the input templateStr with placeholders replaced\n     */\n    static String expandPathUrlTemplate(String templateStr, String ccdId) {\n        Matcher m = CCD_ID_TEMPLATE_REGEX.matcher(templateStr);\n        StringBuilder output = new StringBuilder();\n        int lastIndex = 0;\n        while (m.find()) {\n            String repString = ccdId;\n            String indicesStr = m.group(1);\n            try {\n                if (indicesStr == null) {\n                    // no substringing\n                    repString = ccdId;\n                } else if (!indicesStr.contains(\"_\")) {\n                    // left/right substring\n                    int idx = Integer.parseInt(indicesStr);\n                    if (idx < 0) { // right substring\n                        repString = ccdId.substring(ccdId.length() + idx);\n                    } else { // left substring\n                        repString = ccdId.substring(0, idx);\n                    }\n                } else if (indicesStr.contains(\"_\")) {\n                    // start and end index\n                    String[] tokens = indicesStr.split(\"_\");\n                    int begIdx = Integer.parseInt(tokens[0]);\n                    int endIdx = Integer.parseInt(tokens[1]);\n                    repString = ccdId.substring(begIdx, endIdx);\n                }\n            } catch (IndexOutOfBoundsException e) {\n                // we don't set repString, it keeps original value ccdId\n                logger.debug(\"Indices included in path URL template {} are out of bounds for string {}\", templateStr, ccdId);\n            }\n            output.append(templateStr, lastIndex, m.start()).append(repString);\n\n            lastIndex = m.end();\n            // TODO when we upgrade to java 11, use the new methods introduced in java 9, see https://stackoverflow.com/questions/9605716/java-regular-expression-find-and-replace\n        }\n        if (lastIndex < templateStr.length()) {\n            output.append(templateStr, lastIndex, templateStr.length());\n        }\n        return output.toString();\n    }\n\n    /**\n     * @param recordName : three-letter name\n     * @return true if successful download\n     */\n    private static boolean downloadChemCompRecord(String recordName) {\n        String localName = getLocalFileName(recordName);\n        File newFile;\n        try {\n            newFile = Files.createTempFile(\"chemcomp\" + recordName,\"cif\").toFile();\n            logger.debug(\"Will write chem comp file to temp file {}\", newFile.toString());\n        } catch(IOException e) {\n            logger.error(\"Could not write to temp directory {} to create the chemical component download temp file\", System.getProperty(\"java.io.tmpdir\"));\n            return false;\n        }\n\n        String u = serverBaseUrl + expandPathUrlTemplate(chemCompPathUrlTemplate, recordName);\n\n        logger.debug(\"Downloading chem comp definition from {}\", u);\n\n        URL url = null;\n        try {\n            url = new URL(u);\n            URLConnection uconn = URLConnectionTools.openURLConnection(url);\n\n            try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));\n                 BufferedReader fileBuffer = new BufferedReader(new InputStreamReader(uconn.getInputStream()))) {\n                String line;\n                boolean success = false;\n                while ((line = fileBuffer.readLine()) != null) {\n                    pw.println(line);\n                    success = true;\n                }\n                if(!success) {\n                \tthrow new IOException(\"Malformed URL or no content found in \"+url.toString());\n                }\n\n                pw.flush();\n            }\n            // Now we move this across to where it actually wants to be\n            Files.move(newFile.toPath(), Paths.get(localName), StandardCopyOption.REPLACE_EXISTING);\n\n            return true;\n        } catch (IOException e) {\n            logger.error(\"Could not download {} OR store locally to {} Error ={}\",\n                    url,\n                    localName,\n                    e.getMessage());\n            newFile.delete();\n        }\n        return false;\n    }\n\n    private void downloadAllDefinitions() {\n        if (loading.get()) {\n            logger.info(\"Waiting for other thread to install chemical components...\");\n        }\n\n        while (loading.get()) {\n            // another thread is already downloading the components definitions\n            // wait for the other thread to finish...\n            try {\n                // wait half a second\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                //e.printStackTrace();\n                logger.error(\"Thread interrupted \"+e.getMessage());\n            }\n\n            logger.info(\"Another thread installed the chemical components.\");\n            return;\n        }\n\n        loading.set(true);\n        long timeS = System.currentTimeMillis();\n\n        logger.info(\"Performing first installation of chemical components.\");\n        logger.info(\"Downloading components.cif.gz ...\");\n\n        try {\n            AllChemCompProvider.downloadFile();\n        } catch (IOException e) {\n            logger.error(\"Could not download the all chemical components file. Error: {}. \"\n                    + \"Chemical components information won't be available\", e.getMessage());\n            // no point in trying to split if the file could not be downloaded\n            loading.set(false);\n            return;\n        }\n        try {\n            split();\n        } catch (IOException e) {\n            logger.error(\"Could not split all chem comp file into individual chemical component files. Error: {}\",\n                    e.getMessage());\n            // no point in reporting time\n            loading.set(false);\n            return;\n        }\n        long timeE = System.currentTimeMillis();\n        logger.info(\"time to install chem comp dictionary: \" + (timeE - timeS) / 1000 + \" sec.\");\n        loading.set(false);\n    }\n\n    /**\n     * By default this provider will download only some of the {@link ChemComp} files.\n     * The user has to request that all files should be downloaded by setting this parameter to true.\n     *\n     *  @return flag if the all components should be downloaded and installed at startup. (default: false)\n     */\n    public boolean isDownloadAll() {\n        return downloadAll;\n    }\n\n    /** By default this provider will download only some of the {@link ChemComp} files.\n     * The user has to request that all files should be downloaded by setting this parameter to true.\n     *\n     * @param downloadAll if the all components should be downloaded and installed at startup. (default: false)\n     */\n    public void setDownloadAll(boolean downloadAll) {\n        this.downloadAll = downloadAll;\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.chem;\n\nimport org.biojava.nbio.core.util.FlatFileCache;\nimport org.biojava.nbio.structure.chem.ChemComp;\nimport org.biojava.nbio.structure.chem.DownloadChemCompProvider;\nimport org.biojava.nbio.structure.io.LocalPDBDirectory;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.regex.Matcher;\nimport java.util.zip.GZIPOutputStream;\n\npublic class TestDownloadChemCompProvider {\n\n\t@Test\n\tpublic void testProtectedIDs(){\n\n\t\tString id = \"CON\";\n\n\t\tDownloadChemCompProvider prov = new DownloadChemCompProvider();\n\t\tChemComp cc = prov.getChemComp(id);\n\t\tassertNotNull(cc);\n\n\t\tassertEquals(cc.getId(), id);\n\t}\n\n\t@Test\n\tpublic void testWeDontCacheGarbage() {\n\t\t// see #703\n\n\t\tFile file = new File(DownloadChemCompProvider.getLocalFileName(\"HEM\"));\n\n\t\tfile.delete();\n\n\t\tDownloadChemCompProvider prov = new DownloadChemCompProvider();\n\n\t\t// a fake URL that should give a 404\n\t\tDownloadChemCompProvider.serverBaseUrl = \"https://www.rcsb.org/non-existent-ligand-url/\";\n\n\t\tChemComp cc = prov.getChemComp(\"HEM\");\n\n\t\t// we got a 404 back from server so we shouldn't have cached a file\n\t\tassertTrue(!file.exists());\n\n\t\tfile.delete();\n\n\t\t// very important: we have a memory cache of files, we need to reset it not to pollute the cache for later tests\n\t\tFlatFileCache.clear();\n\n\t\t// we couldn't parse, thus there should be no content\n\t\tassertNull(cc.getName());\n\n\t\t// reset to default URL or otherwise we could affect other tests\n\t\tDownloadChemCompProvider.serverBaseUrl = DownloadChemCompProvider.DEFAULT_SERVER_URL;\n\n\n\t}\n\n\t@Test\n\tpublic void testIfWeCachedGarbageWeCanDetectIt() throws IOException {\n\t\t// see #703\n\t\t// TODO this test for the moment only asserts that we get an empty chemcomp, since we can't detect bad cached files yet\n\n\t\t// very important: we have a memory cache of files, we need to reset it\n\t\tFlatFileCache.clear();\n\n\t\tFile file = new File(DownloadChemCompProvider.getLocalFileName(\"HEM\"));\n\n\t\tPrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(file)));\n\t\tpw.println(\"This must produce a compressed file of at least LocalPDBDirectory.MIN_PDB_FILE_SIZE bytes to avoid deletion.\");\n\t\tpw.close();\n\n\t\tDownloadChemCompProvider prov = new DownloadChemCompProvider();\n\n\t\tChemComp cc = prov.getChemComp(\"HEM\");\n\n\t\tassertTrue(file.exists());\n\n\t\tfile.delete();\n\n\t\t// very important: we have a memory cache of files, we need to reset it not to pollute the cache for later tests\n\t\t// we've got to reset here before asserting, in case the assertion fails\n\t\tFlatFileCache.clear();\n\n\t\tassertNull(cc.getName());\n\t}\n\n\t@Test\n\tpublic void testPathUrlTemplateRegex() {\n\t\tString[] shouldMatch = {\"{ccd_id}\", \"{ccd_id:1_2}\", \"{ccd_id:1}\", \"{ccd_id:-1}\", \"abcde{ccd_id}abcde\", \"abcde{ccd_id:1_2}abcde\", \"abcde{ccd_id:-1}abcde\"};\n\t\tString[] expectedCaptures = {null, \"1_2\", \"1\", \"-1\", null, \"1_2\", \"-1\"};\n\t\tfor (int i=0; i<shouldMatch.length; i++) {\n\t\t\tMatcher m = DownloadChemCompProvider.CCD_ID_TEMPLATE_REGEX.matcher(shouldMatch[i]);\n\t\t\tassertTrue(\"String '\"+shouldMatch[i]+\"' should match the regex\",m.find());\n\t\t\tassertEquals(expectedCaptures[i], m.group(1));\n\t\t}\n\t\tString[] shouldntMatch = {\"{ccd_id:}\", \"{ccd_id:-1_2}\", \"{ccd_id:x1}\", \"{ccd_id:1_-2}\"};\n\t\tfor (String testStr : shouldntMatch) {\n\t\t\tMatcher m = DownloadChemCompProvider.CCD_ID_TEMPLATE_REGEX.matcher(testStr);\n\t\t\tassertFalse(\"String '\"+testStr+\"' should not match the regex\",m.find());\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testPathUrlTemplateExpansion() {\n\t\tString templateStr = \"/my/path/{ccd_id:1_2}/hello/{ccd_id:-1}/dir/abcdef/{ccd_id:2}/12345/{ccd_id}.cif\";\n\n\t\tString e1 = \"/my/path/T/hello/P/dir/abcdef/AT/12345/ATP.cif\";\n\t\tString r1 = DownloadChemCompProvider.expandPathUrlTemplate(templateStr,\"ATP\");\n\t\tassertEquals(e1, r1);\n\n\t\tString e2 = \"/my/path/D/hello/D/dir/abcdef/D/12345/D.cif\";\n\t\tString r2 = DownloadChemCompProvider.expandPathUrlTemplate(templateStr,\"D\");\n\t\tassertEquals(e2, r2);\n\n\t\tString e3 = \"/my/path//hello//dir/abcdef//12345/.cif\";\n\t\tString r3 = DownloadChemCompProvider.expandPathUrlTemplate(templateStr,\"\");\n\t\tassertEquals(e3, r3);\n\n\t\ttemplateStr = \"/my/fixed/dir\";\n\t\tassertEquals(templateStr, DownloadChemCompProvider.expandPathUrlTemplate(templateStr, \"\" ));\n\t}\n\n}\n","changedTest":"","commitMessage":"vuln-fix: Temporary File Information Disclosure\n\n\n\nThis fixes temporary file information disclosure vulnerability due to the use\nof the vulnerable `File.createTempFile()` method. The vulnerability is fixed by\nusing the `Files.createTempFile()` method which sets the correct posix permissions.\n\nWeakness: CWE-377: Insecure Temporary File\nSeverity: Medium\nCVSSS: 5.5\nDetection: CodeQL & OpenRewrite (https://public.moderne.io/recipes/org.openrewrite.java.security.SecureTempFileCreation)\n\nReported-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\nSigned-off-by: Jonathan Leitschuh <Jonathan.Leitschuh@gmail.com>\n\nBug-tracker: https://github.com/JLLeitschuh/security-research/issues/18\n\n\nCo-authored-by: Moderne <team@moderne.io>","test_commitMessage":"","allZero":false}