{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/align/multiple/util/MultipleAlignmentTools.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/align/multiple/util/TestMultipleAlignmentTools.java","prod_time":"2015-07-24 00:13:30","test_time":"2015-07-24 00:13:30","type":"RENAME","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"d8c5d2fe6025a432a240a9154b422b13bda64a42","test_commitID":"d8c5d2fe6025a432a240a9154b422b13bda64a42","isfound":"found test change","originPro":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Utility functions for working with {@link MultipleAlignment}. \n * <p>\n * Supported functions:\n * <ul><li>Multiple sequence alignment calculation\n * <li>Map from sequence alignment position to structure Atom\n * <li>Map from sequence alignment position to Block number\n * <li>Transform the aligned Atoms of a MultipleAlignment\n * <li>Get all the core alignment positions of the alignment\n * <li>Calculate the average residue distance of all aligned positions\n * </ul>\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentTools {\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This \n\t * method creates a sequence alignment where aligned residues are in \n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be \n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a \n\t * possible discontinuity.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @param mapSeqToStruct provides a link from the sequence alignment \n\t * \t\t\tposition to the structure alignment position. Specially \n\t * \t\t\tdesigned for the GUI. Has to be initialized previously and will\n\t * \t\t\tbe overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t//Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<String>();\n\t\tfor (int str=0; str<alignment.size(); str++) alnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t//Initialize helper variables in constucting the sequence alignment\n\t\tList<SortedSet<Integer>> freePool = \n\t\t\t\tnew ArrayList<SortedSet<Integer>>();\n\t\tList<SortedSet<Integer>> blockStarts = \n\t\t\t\tnew ArrayList<SortedSet<Integer>>();\n\t\tList<List<Integer>> aligned = \n\t\t\t\tnew ArrayList<List<Integer>>();\n\n\t\t//Generate freePool residues from the ones not aligned\n\t\tfor (int i=0; i<alignment.size(); i++){\n\t\t\tList<Integer> residues = new ArrayList<Integer>();\n\t\t\tfreePool.add(new TreeSet<Integer>());\n\t\t\tblockStarts.add(new TreeSet<Integer>());\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()){\n\t\t\t\tfor (Block b : bs.getBlocks()){\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (int l=0; l<b.length(); l++){\n\t\t\t\t\t\tInteger residue = b.getAlignRes().get(i).get(l);\n\t\t\t\t\t\tif (residue != null){\n\t\t\t\t\t\t\tif (first) blockStarts.get(i).add(residue);\n\t\t\t\t\t\t\tresidues.add(residue);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\taligned.add(residues);\n\t\t}\n\t\t//Add any residue not aligned to the free pool for every structure\n\t\tfor (int i=0; i<alignment.size(); i++){\n\t\t\tfor (int k=0; k<atoms.get(i).length; k++){\n\t\t\t\tif (!aligned.get(i).contains(k)) freePool.get(i).add(k);\n\t\t\t}\n\t\t}\n\n\t\tfor (int b=0; b<alignment.getBlocks().size(); b++){\n\t\t\tif (b!=0){\n\t\t\t\t//Add a gap to all structures to separate visually the Blocks\n\t\t\t\tfor (int str=0; str<alignment.size(); str++) \n\t\t\t\t\talnSequences.set(str,alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); //means unaligned position\n\t\t\t}\n\t\t\t//Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t//Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos=0; pos<alignment.getBlocks().get(b).length(); pos++){\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;  //true if consecutive with the previous\n\t\t\t\twhile (gaps){\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t//Loop through all the structures\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t//If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1){\n\t\t\t\t\t\t\tInteger residue = \n\t\t\t\t\t\t\t\t\talignment.getBlocks().\n\t\t\t\t\t\t\t\t\tget(b).getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\tStructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tInteger residue = \n\t\t\t\t\t\t\t\t\talignment.getBlocks().\n\t\t\t\t\t\t\t\t\tget(b).getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tint nextPos = previousPos[str]+1;\n\t\t\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\t\t\tif (freePool.get(str).contains(nextPos)){\n\t\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\t\tCharacter.toLowerCase(aa);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse provisionalChar[str] = '-';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (nextPos == residue){\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\tStructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//This means non-consecutive\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End all structure analysis\n\n\t\t\t\t\tif (gaps){\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t//It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str]+1];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\t\tconcat(\"\"+Character.toLowerCase(aa)));\n\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\t\t//Insert a gap otherwise\n\t\t\t\t\t\t\t\talnSequences.set(str,\n\t\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\"-\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned position\n\t\t\t\t\t} \n\t\t\t\t\telse {  \n\t\t\t\t\t\t//Add provisional and update the indices\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tif (alignment.getBlocks().get(b).getAlignRes().\n\t\t\t\t\t\t\t\t\t\tget(str).get(pos)==null) {\n\t\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tpreviousPos[str] = \n\t\t\t\t\t\t\t\t\t\t\talignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos); //alignment index\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //All positions in the Block considered so far\n\n\t\t\t//Calculate the index of the next Block for every structure\n\t\t\tint[] blockEnds = new int[alignment.size()];\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tfor (int res:blockStarts.get(str)){\n\t\t\t\t\tif (previousPos[str] > res) blockEnds[str] = res;\n\t\t\t\t\telse {\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add the unaligned residues in between Blocks (lowercase)\n\t\t\tboolean allGaps = false; //true means no more residues to add\n\t\t\twhile (!allGaps){\n\t\t\t\tallGaps = true;\n\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\tif (previousPos[str]+1 < blockEnds[str]){\n\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str]+1];\n\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\tchar letter = StructureTools.get1LetterCode(group);\n\n\t\t\t\t\t\tprovisionalChar[str] = Character.toLowerCase(letter);\n\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\tallGaps = false;\n\t\t\t\t\t} else provisionalChar[str] = '-';\n\t\t\t\t}\n\t\t\t\tif (!allGaps){\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\t\t\t\t\t}\n\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. \n\t * This method creates a sequence alignment where aligned residues are \n\t * in uppercase and unaligned residues are in lowercase, thus\n\t * providing a more compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be \n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(MultipleAlignment msa) {\n\t\treturn getSequenceAlignment(msa, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an \n\t * alignment. This method creates a sequence alignment where all residues \n\t * are in uppercase and a residue alone with gaps in all the other \n\t * structures represents unaligned residues. Because of this latter \n\t * constraint only the residues within the Blocks are represented, for a \n\t * more compact alignment. For a sequence alignment of the full protein \n\t * use {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()},\n\t * so sequences may not be sequential. Gaps between blocks are omitted,\n\t * while gaps within blocks are represented by '-'. Separation between \n\t * different Blocks is indicated by a gap in all positions, meaning that \n\t * there is something unaligned inbetween.\n\t *\n\t * @param alignment input MultipleAlignment\n\t * @param mapSeqToStruct provides a link from the sequence alignment \n\t * \t\t  position to the structure alignment \n\t * \t\t  position. Specially designed for the GUI. Has to be initialized \n\t * \t\t  previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t//Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<String>();\n\t\tfor (int str=0; str<alignment.size(); str++) alnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t//Loop through all the alignment Blocks in the order given\n\t\tfor (int b=0; b<alignment.getBlocks().size(); b++){\n\t\t\tif (b!=0){\n\t\t\t\t//Add a gap to all structures to separate Blocks\n\t\t\t\tfor (int str=0; str<alignment.size(); str++) \n\t\t\t\t\talnSequences.set(str,alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); //means unaligned position\n\t\t\t}\n\n\t\t\t//Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t//Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos=0; pos<alignment.getBlocks().get(b).length(); pos++){\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;\n\t\t\t\twhile (gaps){\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t//Loop through all the structures\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t//If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1){\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse if (previousPos[str]+1 == residue){\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End all structures analysis\n\n\t\t\t\t\tif (gaps){\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {  \n\t\t\t\t\t\t\t\t//It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tfor (int s2=0; s2<alignment.size(); s2++){\n\t\t\t\t\t\t\t\t\tif (str==s2) {\n\t\t\t\t\t\t\t\t\t\tint next = previousPos[str]+1;\n\t\t\t\t\t\t\t\t\t\tAtom a = atoms.get(s2)[next];\n\t\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\t\tchar aa = StructureTools.\n\t\t\t\t\t\t\t\t\t\t\t\tget1LetterCode(g);\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,alnSequences.\n\t\t\t\t\t\t\t\t\t\t\t\tget(s2).concat(\"\"+aa));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,alnSequences.\n\t\t\t\t\t\t\t\t\t\t\t\tget(s2).concat(\"-\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned\n\t\t\t\t\t\t\t\tpreviousPos[str] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {  //Append the provisional and update the indices\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tpreviousPos[str] = \n\t\t\t\t\t\t\t\t\t\talignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an \n\t * alignment. This method creates a sequence alignment where all residues \n\t * are in uppercase and a residue alone with gaps\n\t * in all the other structures represents unaligned residues. Because of \n\t * this latter constraint only\n\t * the residues within the Blocks are represented, for a more compact \n\t * alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()},\n\t * so sequences may not be sequential. Gaps between blocks are omitted,\n\t * while gaps within blocks are represented by '-'. Separation between \n\t * different Blocks is indicated by a gap in all positions, meaning that \n\t * there is something unaligned inbetween.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code \n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(MultipleAlignment ma){\n\t\treturn getBlockSequenceAlignment(ma, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Returns the Atom of the specified structure that is aligned in the \n\t * sequence alignment position specified.\n\t * \n\t * @param multAln the MultipleAlignment object from where the sequence \n\t * alignment has been generated\n\t * @param mapSeqToStruct the mapping between sequence and structure \n\t * generated with the sequence alignment\n\t * @param str the structure index of the alignment (row)\n\t * @param sequencePos the sequence alignment position (column)\n\t * @return Atom the atom in that position or null if there is a gap\n\t */\n\tpublic static Atom getAtomForSequencePosition(MultipleAlignment msa, \n\t\t\tList<Integer> mapSeqToStruct, int str, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\n\t\t//Check if the position selected is an aligned position\n\t\tif (seqPos == -1) return null;\n\t\telse {\n\t\t\tAtom a = null;\n\t\t\t//Calculate the corresponding structure position\n\t\t\tint sum = 0;\n\t\t\tfor (Block b:msa.getBlocks()){\n\t\t\t\tif (sum+b.length()<=seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (Integer p:b.getAlignRes().get(str)){\n\t\t\t\t\t\tif (sum == seqPos) {\n\t\t\t\t\t\t\tif (p!= null){\n\t\t\t\t\t\t\t\ta = msa.getAtomArrays().get(str)[p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the block number of a specified position in the sequence \n\t * alignment, given the mapping from structure to function.\n\t * \n\t * @param multAln the MultipleAlignment object from where the sequence \n\t * alignment has been generated.\n\t * @param mapSeqToStruct the mapping between sequence and structure \n\t * generated with the sequence alignment\n\t * @param sequencePos the position in the sequence alignment (column)\n\t * @return int the block index, or -1 if the position is not aligned\n\t */\n\tpublic static int getBlockForSequencePosition(MultipleAlignment multAln, \n\t\t\tList<Integer> mapSeqToStruct, int sequencePos){\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\t\t//Check if the position selected is an aligned position\n\t\tif (seqPos == -1) return -1;\n\t\telse {\n\t\t\t//Calculate the corresponding block (by iterating all Blocks)\n\t\t\tint sum = 0;\n\t\t\tint block = 0;\n\t\t\tfor (Block b:multAln.getBlocks()){\n\t\t\t\tif (sum+b.length()<=seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tblock++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\treturn block;\n\t\t}\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from \n\t * each residue to all other residues aligned with it. \n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and \n\t * l=alignment length.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return Matrix containing all average residue distances\n\t */\n\tpublic static Matrix getAverageResidueDistances(MultipleAlignment msa){\n\t\tList<Atom[]> transformed = transformAtoms(msa);\n\t\treturn getAverageResidueDistances(transformed);\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from \n\t * each residue to all other residues aligned with it. \n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and \n\t * l=alignment length.\n\t * \n\t * @param transformed List of Atom arrays containing only the aligned \n\t * atoms of each structure, or null if there is a gap.\n\t * @return Matrix containing all average residue distances. Entry -1 means \n\t * there is a gap in the position.\n\t */\n\tpublic static Matrix getAverageResidueDistances(List<Atom[]> transformed){\n\n\t\tint size = transformed.size();\n\t\tint length = transformed.get(0).length;\n\t\tMatrix resDist = new Matrix(size,length,-1);\n\n\t\t//Calculate the average residue distances\n\t\tfor (int r1=0; r1<size; r1++){\n\t\t\tfor(int c=0;c<transformed.get(r1).length;c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif(refAtom == null) continue;\n\n\t\t\t\tfor(int r2=r1+1;r2<size;r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif(atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\n\t\t\t\t\t\tif (resDist.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r1, c, 1+distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r1, c, resDist.get(r1, c)+distance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (resDist.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r2, c, 1+distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r2, c, resDist.get(r2, c)+distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int c=0;c<length;c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor(int r=0;r<size;r++) {\n\t\t\t\tif (resDist.get(r, c) != -1) nonNullRes++;\n\t\t\t}\n\t\t\tfor(int r=0;r<size;r++) {\n\t\t\t\tif (resDist.get(r, c) != -1){\n\t\t\t\t\tresDist.set(r, c, \n\t\t\t\t\t\t\tresDist.get(r, c)/nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resDist;\n\t}\n\n\t/**\n\t * Transforms atoms according to the superposition stored in the alignment.\n\t * <p>\n\t * For each structure in the alignment, returns an atom for each\n\t * representative atom in the aligned columns, omitting unaligned residues\n\t * (i.e. an array of length <tt>alignment.length()</tt> ).\n\t * <p>\n\t * All blocks are concatenated together, so Atoms may not appear in the\n\t * same order as in their parent structure. If the alignment blocks contain\n\t * null residues (gaps), then the returned array will also contain null\n\t * Atoms in the same positions.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return List of Atom arrays of only the aligned atoms of every structure\n\t * (null Atom if a gap position)\n\t */\n\tpublic static List<Atom[]> transformAtoms(MultipleAlignment alignment) {\n\t\tif(alignment.getEnsemble() == null ) {\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"No ensemble set for this alignment\");\n\t\t}\n\n\t\tList<Atom[]> atomArrays = alignment.getAtomArrays();\n\t\tList<Atom[]> transformed = new ArrayList<Atom[]>(atomArrays.size());\n\n\t\t//Loop through structures\n\t\tfor (int i=0; i<atomArrays.size(); i++){\n\n\t\t\tMatrix4d transform = null;\n\t\t\tAtom[] curr = atomArrays.get(i); // all CA atoms from structure\n\n\t\t\t//Concatenated list of all blocks for this structure\n\t\t\tAtom[] transformedAtoms = new Atom[alignment.length()];\n\t\t\tint transformedAtomsLength = 0;\n\n\t\t\t// Each blockset gets transformed independently\n\t\t\tfor( BlockSet bs : alignment.getBlockSets()) {\n\n\t\t\t\tAtom[] blocksetAtoms = new Atom[bs.length()];\n\n\t\t\t\tfor( Block blk : bs.getBlocks() ) {\n\t\t\t\t\tif( blk.size() != atomArrays.size()) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\t\t\"Mismatched block length. Expected %d \"\n\t\t\t\t\t\t\t\t\t\t+ \"structures, found %d.\",\n\t\t\t\t\t\t\t\t\t\tatomArrays.size(),blk.size() ));\n\t\t\t\t\t}\n\t\t\t\t\t//Extract aligned atoms\n\t\t\t\t\tfor (int j=0; j<blk.length(); j++){\n\t\t\t\t\t\tInteger alignedPos = blk.getAlignRes().get(i).get(j);\n\t\t\t\t\t\tif (alignedPos != null) {\n\t\t\t\t\t\t\tblocksetAtoms[j] = (Atom) curr[alignedPos].clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Transform according to the blockset or alignment matrix\n\t\t\t\tMatrix4d blockTrans = null;\n\t\t\t\tif(bs.getTransformations() != null)\n\t\t\t\t\tblockTrans = bs.getTransformations().get(i);\n\t\t\t\tif(blockTrans == null) {\n\t\t\t\t\tblockTrans = transform;\n\t\t\t\t}\n\n\t\t\t\tfor (Atom a : blocksetAtoms) {\n\t\t\t\t\tif (a!=null) Calc.transform(a, blockTrans);\n\t\t\t\t\ttransformedAtoms[transformedAtomsLength] = a;\n\t\t\t\t\ttransformedAtomsLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(transformedAtomsLength == alignment.length());\n\n\t\t\ttransformed.add(transformedAtoms);\n\t\t}\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Calculate a List of alignment indicies that correspond to the core\n\t * of a Block, which means that all structures have a residue in that\n\t * positon.\n\t * \n\t * @param block alignment Block\n\t * @return List of positions in the core of the alignment\n\t */\n\tpublic static List<Integer> getCorePositions(Block block){\n\n\t\tList<Integer> corePositions = new ArrayList<Integer>();\n\t\t\n\t\tfor (int col=0; col<block.length(); col++){\n\t\t\tboolean core = true;\n\t\t\tfor (int str=0; str<block.size(); str++){\n\t\t\t\tif (block.getAlignRes().get(str).get(col) == null){\n\t\t\t\t\tcore = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (core) corePositions.add(col);\n\t\t}\n\t\treturn corePositions;\n\t}\n\n\t/**\n\t * Sort blocks so that the specified row is in sequential order.\n\t * The sort happens in place.\n\t * @param blocks List of blocks\n\t * @param sortedIndex Index of the row to be sorted\n\t */\n\tpublic static void sortBlocks(List<Block> blocks,final int sortedIndex) {\n\t\tCollections.sort(blocks, new Comparator<Block>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Block o1, Block o2) {\n\t\t\t\t// Compare the first non-null residue of each block\n\t\t\t\tList<Integer> alignres1 = o1.getAlignRes().get(sortedIndex);\n\t\t\t\tList<Integer> alignres2 = o2.getAlignRes().get(sortedIndex);\n\t\t\t\tInteger res1 = null;\n\t\t\t\tInteger res2 = null;\n\t\t\t\tfor(Integer r : alignres1) {\n\t\t\t\t\tif( r != null) {\n\t\t\t\t\t\tres1 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(Integer r : alignres2) {\n\t\t\t\t\tif( r != null) {\n\t\t\t\t\t\tres2 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn res1.compareTo(res2);\n\t\t\t}\n\t\t});\n\t}\n}\n","changedPro":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport javax.vecmath.Matrix4d;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Calc;\nimport org.biojava.nbio.structure.StructureTools;\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.jama.Matrix;\n\n/**\n * Utility functions for working with {@link MultipleAlignment}. \n * <p>\n * Supported functions:\n * <ul><li>Multiple sequence alignment calculation\n * <li>Map from sequence alignment position to structure Atom\n * <li>Map from sequence alignment position to Block number\n * <li>Transform the aligned Atoms of a MultipleAlignment\n * <li>Get all the core alignment positions of the alignment\n * <li>Calculate the average residue distance of all aligned positions\n * <li>Sort Blocks in a MultipleAlignment by a specified row\n * </ul>\n * \n * @author Spencer Bliven\n * @author Aleix Lafita\n * @since 4.1.0\n *\n */\npublic class MultipleAlignmentTools {\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. This \n\t * method creates a sequence alignment where aligned residues are in \n\t * uppercase and unaligned residues are in lowercase, thus providing a more\n\t * compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be \n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a \n\t * possible discontinuity.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @param mapSeqToStruct provides a link from the sequence alignment \n\t * \t\t\tposition to the structure alignment position. Specially \n\t * \t\t\tdesigned for the GUI. Has to be initialized previously and will\n\t * \t\t\tbe overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t//Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<String>();\n\t\tfor (int str=0; str<alignment.size(); str++) alnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t//Initialize helper variables in constucting the sequence alignment\n\t\tList<SortedSet<Integer>> freePool = \n\t\t\t\tnew ArrayList<SortedSet<Integer>>();\n\t\tList<SortedSet<Integer>> blockStarts = \n\t\t\t\tnew ArrayList<SortedSet<Integer>>();\n\t\tList<List<Integer>> aligned = \n\t\t\t\tnew ArrayList<List<Integer>>();\n\n\t\t//Generate freePool residues from the ones not aligned\n\t\tfor (int i=0; i<alignment.size(); i++){\n\t\t\tList<Integer> residues = new ArrayList<Integer>();\n\t\t\tfreePool.add(new TreeSet<Integer>());\n\t\t\tblockStarts.add(new TreeSet<Integer>());\n\t\t\tfor (BlockSet bs : alignment.getBlockSets()){\n\t\t\t\tfor (Block b : bs.getBlocks()){\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tfor (int l=0; l<b.length(); l++){\n\t\t\t\t\t\tInteger residue = b.getAlignRes().get(i).get(l);\n\t\t\t\t\t\tif (residue != null){\n\t\t\t\t\t\t\tif (first) blockStarts.get(i).add(residue);\n\t\t\t\t\t\t\tresidues.add(residue);\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\taligned.add(residues);\n\t\t}\n\t\t//Add any residue not aligned to the free pool for every structure\n\t\tfor (int i=0; i<alignment.size(); i++){\n\t\t\tfor (int k=0; k<atoms.get(i).length; k++){\n\t\t\t\tif (!aligned.get(i).contains(k)) freePool.get(i).add(k);\n\t\t\t}\n\t\t}\n\n\t\tfor (int b=0; b<alignment.getBlocks().size(); b++){\n\t\t\tif (b!=0){\n\t\t\t\t//Add a gap to all structures to separate visually the Blocks\n\t\t\t\tfor (int str=0; str<alignment.size(); str++) \n\t\t\t\t\talnSequences.set(str,alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); //means unaligned position\n\t\t\t}\n\t\t\t//Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t//Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos=0; pos<alignment.getBlocks().get(b).length(); pos++){\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;  //true if consecutive with the previous\n\t\t\t\twhile (gaps){\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t//Loop through all the structures\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t//If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1){\n\t\t\t\t\t\t\tInteger residue = \n\t\t\t\t\t\t\t\t\talignment.getBlocks().\n\t\t\t\t\t\t\t\t\tget(b).getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\tStructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tInteger residue = \n\t\t\t\t\t\t\t\t\talignment.getBlocks().\n\t\t\t\t\t\t\t\t\tget(b).getAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tint nextPos = previousPos[str]+1;\n\t\t\t\t\t\t\tif (residue == null) {\n\t\t\t\t\t\t\t\tif (freePool.get(str).contains(nextPos)){\n\t\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\t\tCharacter.toLowerCase(aa);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse provisionalChar[str] = '-';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (nextPos == residue){\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[nextPos];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tprovisionalChar[str] = \n\t\t\t\t\t\t\t\t\t\tStructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//This means non-consecutive\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End all structure analysis\n\n\t\t\t\t\tif (gaps){\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {\n\t\t\t\t\t\t\t\t//It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str]+1];\n\t\t\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(group);\n\t\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\t\tconcat(\"\"+Character.toLowerCase(aa)));\n\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\t\t//Insert a gap otherwise\n\t\t\t\t\t\t\t\talnSequences.set(str,\n\t\t\t\t\t\t\t\t\t\talnSequences.get(str).concat(\"-\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned position\n\t\t\t\t\t} \n\t\t\t\t\telse {  \n\t\t\t\t\t\t//Add provisional and update the indices\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tif (alignment.getBlocks().get(b).getAlignRes().\n\t\t\t\t\t\t\t\t\t\tget(str).get(pos)==null) {\n\t\t\t\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tpreviousPos[str] = \n\t\t\t\t\t\t\t\t\t\t\talignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos); //alignment index\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} //All positions in the Block considered so far\n\n\t\t\t//Calculate the index of the next Block for every structure\n\t\t\tint[] blockEnds = new int[alignment.size()];\n\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\tfor (int res:blockStarts.get(str)){\n\t\t\t\t\tif (previousPos[str] > res) blockEnds[str] = res;\n\t\t\t\t\telse {\n\t\t\t\t\t\tblockEnds[str] = res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Add the unaligned residues in between Blocks (lowercase)\n\t\t\tboolean allGaps = false; //true means no more residues to add\n\t\t\twhile (!allGaps){\n\t\t\t\tallGaps = true;\n\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\tif (previousPos[str]+1 < blockEnds[str]){\n\t\t\t\t\t\tAtom a = atoms.get(str)[previousPos[str]+1];\n\t\t\t\t\t\tString group = a.getGroup().getPDBName();\n\t\t\t\t\t\tchar letter = StructureTools.get1LetterCode(group);\n\n\t\t\t\t\t\tprovisionalChar[str] = Character.toLowerCase(letter);\n\t\t\t\t\t\tpreviousPos[str]++;\n\t\t\t\t\t\tallGaps = false;\n\t\t\t\t\t} else provisionalChar[str] = '-';\n\t\t\t\t}\n\t\t\t\tif (!allGaps){\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++) {\n\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\t\t\t\t\t}\n\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned position\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the whole alignment. \n\t * This method creates a sequence alignment where aligned residues are \n\t * in uppercase and unaligned residues are in lowercase, thus\n\t * providing a more compact way to represent the alignment.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()}, so sequences may not be \n\t * sequential. Gaps are represented by '-'. Separation between different\n\t * Blocks is indicated by a gap in all positions, meaning that there is a\n\t * possible discontinuity.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getSequenceAlignment(MultipleAlignment msa) {\n\t\treturn getSequenceAlignment(msa, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an \n\t * alignment. This method creates a sequence alignment where all residues \n\t * are in uppercase and a residue alone with gaps in all the other \n\t * structures represents unaligned residues. Because of this latter \n\t * constraint only the residues within the Blocks are represented, for a \n\t * more compact alignment. For a sequence alignment of the full protein \n\t * use {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()},\n\t * so sequences may not be sequential. Gaps between blocks are omitted,\n\t * while gaps within blocks are represented by '-'. Separation between \n\t * different Blocks is indicated by a gap in all positions, meaning that \n\t * there is something unaligned inbetween.\n\t *\n\t * @param alignment input MultipleAlignment\n\t * @param mapSeqToStruct provides a link from the sequence alignment \n\t * \t\t  position to the structure alignment \n\t * \t\t  position. Specially designed for the GUI. Has to be initialized \n\t * \t\t  previously and will be overwritten.\n\t * @return a string for each row in the alignment, giving the 1-letter code\n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(\n\t\t\tMultipleAlignment alignment, List<Integer> mapSeqToStruct) {\n\n\t\t//Initialize sequence variables\n\t\tList<String> alnSequences = new ArrayList<String>();\n\t\tfor (int str=0; str<alignment.size(); str++) alnSequences.add(\"\");\n\t\tmapSeqToStruct.clear();\n\t\tList<Atom[]> atoms = alignment.getAtomArrays();\n\t\tint globalPos = -1;\n\n\t\t//Loop through all the alignment Blocks in the order given\n\t\tfor (int b=0; b<alignment.getBlocks().size(); b++){\n\t\t\tif (b!=0){\n\t\t\t\t//Add a gap to all structures to separate Blocks\n\t\t\t\tfor (int str=0; str<alignment.size(); str++) \n\t\t\t\t\talnSequences.set(str,alnSequences.get(str).concat(\"-\"));\n\t\t\t\tmapSeqToStruct.add(-1); //means unaligned position\n\t\t\t}\n\n\t\t\t//Store the previous position added to the sequence alignment\n\t\t\tint[] previousPos = new int[alignment.size()];\n\t\t\tArrays.fill(previousPos, -1);\n\t\t\t//Store provisional characters\n\t\t\tchar[] provisionalChar = new char[alignment.size()];\n\t\t\tArrays.fill(provisionalChar, '-');\n\n\t\t\tfor (int pos=0; pos<alignment.getBlocks().get(b).length(); pos++){\n\t\t\t\tglobalPos++;\n\t\t\t\tboolean gaps = true;\n\t\t\t\twhile (gaps){\n\t\t\t\t\tgaps = false;\n\t\t\t\t\t//Loop through all the structures\n\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t//If it is the first position or before it was null\n\t\t\t\t\t\tif (previousPos[str] == -1){\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tInteger residue = alignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\tif (residue == null) provisionalChar[str] = '-';\n\t\t\t\t\t\t\telse if (previousPos[str]+1 == residue){\n\t\t\t\t\t\t\t\tAtom a = atoms.get(str)[residue];\n\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\tchar aa = StructureTools.get1LetterCode(g);\n\t\t\t\t\t\t\t\tprovisionalChar[str] = aa;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprovisionalChar[str] = ' ';\n\t\t\t\t\t\t\t\tgaps = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}//End all structures analysis\n\n\t\t\t\t\tif (gaps){\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\tif (provisionalChar[str] == ' ') {  \n\t\t\t\t\t\t\t\t//It means this residue was non-consecutive\n\t\t\t\t\t\t\t\tfor (int s2=0; s2<alignment.size(); s2++){\n\t\t\t\t\t\t\t\t\tif (str==s2) {\n\t\t\t\t\t\t\t\t\t\tint next = previousPos[str]+1;\n\t\t\t\t\t\t\t\t\t\tAtom a = atoms.get(s2)[next];\n\t\t\t\t\t\t\t\t\t\tString g = a.getGroup().getPDBName();\n\t\t\t\t\t\t\t\t\t\tchar aa = StructureTools.\n\t\t\t\t\t\t\t\t\t\t\t\tget1LetterCode(g);\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,alnSequences.\n\t\t\t\t\t\t\t\t\t\t\t\tget(s2).concat(\"\"+aa));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\talnSequences.set(s2,alnSequences.\n\t\t\t\t\t\t\t\t\t\t\t\tget(s2).concat(\"-\"));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapSeqToStruct.add(-1); //unaligned\n\t\t\t\t\t\t\t\tpreviousPos[str] += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {  //Append the provisional and update the indices\n\t\t\t\t\t\tfor (int str=0; str<alignment.size(); str++){\n\t\t\t\t\t\t\talnSequences.set(str,alnSequences.get(str).\n\t\t\t\t\t\t\t\t\tconcat(\"\"+provisionalChar[str]));\n\t\t\t\t\t\t\tif (provisionalChar[str] != '-') {\n\t\t\t\t\t\t\t\tpreviousPos[str] = \n\t\t\t\t\t\t\t\t\t\talignment.getBlocks().get(b).\n\t\t\t\t\t\t\t\t\t\tgetAlignRes().get(str).get(pos);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmapSeqToStruct.add(globalPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn alnSequences;\n\t}\n\n\t/**\n\t * Calculate the sequence alignment Strings for the alignment Blocks in an \n\t * alignment. This method creates a sequence alignment where all residues \n\t * are in uppercase and a residue alone with gaps\n\t * in all the other structures represents unaligned residues. Because of \n\t * this latter constraint only\n\t * the residues within the Blocks are represented, for a more compact \n\t * alignment. For a sequence alignment of the full protein use\n\t * {@link #getSequenceAlignment(MultipleAlignment)}.\n\t * <p>\n\t * Blocks are concatenated in the order returned by \n\t * {@link MultipleAlignment#getBlocks()},\n\t * so sequences may not be sequential. Gaps between blocks are omitted,\n\t * while gaps within blocks are represented by '-'. Separation between \n\t * different Blocks is indicated by a gap in all positions, meaning that \n\t * there is something unaligned inbetween.\n\t * \n\t * @param alignment input MultipleAlignment\n\t * @return String for each row in the alignment, giving the 1-letter code \n\t *  \t\tfor each aligned residue.\n\t */\n\tpublic static List<String> getBlockSequenceAlignment(MultipleAlignment ma){\n\t\treturn getBlockSequenceAlignment(ma, new ArrayList<Integer>());\n\t}\n\n\t/**\n\t * Returns the Atom of the specified structure that is aligned in the \n\t * sequence alignment position specified.\n\t * \n\t * @param multAln the MultipleAlignment object from where the sequence \n\t * alignment has been generated\n\t * @param mapSeqToStruct the mapping between sequence and structure \n\t * generated with the sequence alignment\n\t * @param str the structure index of the alignment (row)\n\t * @param sequencePos the sequence alignment position (column)\n\t * @return Atom the atom in that position or null if there is a gap\n\t */\n\tpublic static Atom getAtomForSequencePosition(MultipleAlignment msa, \n\t\t\tList<Integer> mapSeqToStruct, int str, int sequencePos) {\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\n\t\t//Check if the position selected is an aligned position\n\t\tif (seqPos == -1) return null;\n\t\telse {\n\t\t\tAtom a = null;\n\t\t\t//Calculate the corresponding structure position\n\t\t\tint sum = 0;\n\t\t\tfor (Block b:msa.getBlocks()){\n\t\t\t\tif (sum+b.length()<=seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tfor (Integer p:b.getAlignRes().get(str)){\n\t\t\t\t\t\tif (sum == seqPos) {\n\t\t\t\t\t\t\tif (p!= null){\n\t\t\t\t\t\t\t\ta = msa.getAtomArrays().get(str)[p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the block number of a specified position in the sequence \n\t * alignment, given the mapping from structure to function.\n\t * \n\t * @param multAln the MultipleAlignment object from where the sequence \n\t * alignment has been generated.\n\t * @param mapSeqToStruct the mapping between sequence and structure \n\t * generated with the sequence alignment\n\t * @param sequencePos the position in the sequence alignment (column)\n\t * @return int the block index, or -1 if the position is not aligned\n\t */\n\tpublic static int getBlockForSequencePosition(MultipleAlignment multAln, \n\t\t\tList<Integer> mapSeqToStruct, int sequencePos){\n\n\t\tint seqPos = mapSeqToStruct.get(sequencePos);\n\t\t//Check if the position selected is an aligned position\n\t\tif (seqPos == -1) return -1;\n\t\telse {\n\t\t\t//Calculate the corresponding block (by iterating all Blocks)\n\t\t\tint sum = 0;\n\t\t\tint block = 0;\n\t\t\tfor (Block b:multAln.getBlocks()){\n\t\t\t\tif (sum+b.length()<=seqPos) {\n\t\t\t\t\tsum += b.length();\n\t\t\t\t\tblock++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\treturn block;\n\t\t}\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from \n\t * each residue to all other residues aligned with it. \n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and \n\t * l=alignment length.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return Matrix containing all average residue distances\n\t */\n\tpublic static Matrix getAverageResidueDistances(MultipleAlignment msa){\n\t\tList<Atom[]> transformed = transformAtoms(msa);\n\t\treturn getAverageResidueDistances(transformed);\n\t}\n\n\t/**\n\t * The average residue distance Matrix contains the average distance from \n\t * each residue to all other residues aligned with it. \n\t * <p>\n\t * Complexity: T(n,l) = O(l*n^2), if n=number of structures and \n\t * l=alignment length.\n\t * \n\t * @param transformed List of Atom arrays containing only the aligned \n\t * atoms of each structure, or null if there is a gap.\n\t * @return Matrix containing all average residue distances. Entry -1 means \n\t * there is a gap in the position.\n\t */\n\tpublic static Matrix getAverageResidueDistances(List<Atom[]> transformed){\n\n\t\tint size = transformed.size();\n\t\tint length = transformed.get(0).length;\n\t\tMatrix resDist = new Matrix(size,length,-1);\n\n\t\t//Calculate the average residue distances\n\t\tfor (int r1=0; r1<size; r1++){\n\t\t\tfor(int c=0;c<transformed.get(r1).length;c++) {\n\t\t\t\tAtom refAtom = transformed.get(r1)[c];\n\t\t\t\tif(refAtom == null) continue;\n\n\t\t\t\tfor(int r2=r1+1;r2<size;r2++) {\n\t\t\t\t\tAtom atom = transformed.get(r2)[c];\n\t\t\t\t\tif(atom != null) {\n\t\t\t\t\t\tdouble distance = Calc.getDistance(refAtom, atom);\n\n\t\t\t\t\t\tif (resDist.get(r1, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r1, c, 1+distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r1, c, resDist.get(r1, c)+distance);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (resDist.get(r2, c) == -1) {\n\t\t\t\t\t\t\tresDist.set(r2, c, 1+distance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresDist.set(r2, c, resDist.get(r2, c)+distance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int c=0;c<length;c++) {\n\t\t\tint nonNullRes = 0;\n\t\t\tfor(int r=0;r<size;r++) {\n\t\t\t\tif (resDist.get(r, c) != -1) nonNullRes++;\n\t\t\t}\n\t\t\tfor(int r=0;r<size;r++) {\n\t\t\t\tif (resDist.get(r, c) != -1){\n\t\t\t\t\tresDist.set(r, c, \n\t\t\t\t\t\t\tresDist.get(r, c)/nonNullRes);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn resDist;\n\t}\n\n\t/**\n\t * Transforms atoms according to the superposition stored in the alignment.\n\t * <p>\n\t * For each structure in the alignment, returns an atom for each\n\t * representative atom in the aligned columns, omitting unaligned residues\n\t * (i.e. an array of length <tt>alignment.length()</tt> ).\n\t * <p>\n\t * All blocks are concatenated together, so Atoms may not appear in the\n\t * same order as in their parent structure. If the alignment blocks contain\n\t * null residues (gaps), then the returned array will also contain null\n\t * Atoms in the same positions.\n\t * \n\t * @param alignment MultipleAlignment\n\t * @return List of Atom arrays of only the aligned atoms of every structure\n\t * (null Atom if a gap position)\n\t */\n\tpublic static List<Atom[]> transformAtoms(MultipleAlignment alignment) {\n\t\tif(alignment.getEnsemble() == null ) {\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"No ensemble set for this alignment\");\n\t\t}\n\n\t\tList<Atom[]> atomArrays = alignment.getAtomArrays();\n\t\tList<Atom[]> transformed = new ArrayList<Atom[]>(atomArrays.size());\n\n\t\t//Loop through structures\n\t\tfor (int i=0; i<atomArrays.size(); i++){\n\n\t\t\tMatrix4d transform = null;\n\t\t\tAtom[] curr = atomArrays.get(i); // all CA atoms from structure\n\n\t\t\t//Concatenated list of all blocks for this structure\n\t\t\tAtom[] transformedAtoms = new Atom[alignment.length()];\n\t\t\tint transformedAtomsLength = 0;\n\n\t\t\t// Each blockset gets transformed independently\n\t\t\tfor( BlockSet bs : alignment.getBlockSets()) {\n\n\t\t\t\tAtom[] blocksetAtoms = new Atom[bs.length()];\n\n\t\t\t\tfor( Block blk : bs.getBlocks() ) {\n\t\t\t\t\tif( blk.size() != atomArrays.size()) {\n\t\t\t\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\t\t\t\"Mismatched block length. Expected %d \"\n\t\t\t\t\t\t\t\t\t\t+ \"structures, found %d.\",\n\t\t\t\t\t\t\t\t\t\tatomArrays.size(),blk.size() ));\n\t\t\t\t\t}\n\t\t\t\t\t//Extract aligned atoms\n\t\t\t\t\tfor (int j=0; j<blk.length(); j++){\n\t\t\t\t\t\tInteger alignedPos = blk.getAlignRes().get(i).get(j);\n\t\t\t\t\t\tif (alignedPos != null) {\n\t\t\t\t\t\t\tblocksetAtoms[j] = (Atom) curr[alignedPos].clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Transform according to the blockset or alignment matrix\n\t\t\t\tMatrix4d blockTrans = null;\n\t\t\t\tif(bs.getTransformations() != null)\n\t\t\t\t\tblockTrans = bs.getTransformations().get(i);\n\t\t\t\tif(blockTrans == null) {\n\t\t\t\t\tblockTrans = transform;\n\t\t\t\t}\n\n\t\t\t\tfor (Atom a : blocksetAtoms) {\n\t\t\t\t\tif (a!=null) Calc.transform(a, blockTrans);\n\t\t\t\t\ttransformedAtoms[transformedAtomsLength] = a;\n\t\t\t\t\ttransformedAtomsLength++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(transformedAtomsLength == alignment.length());\n\n\t\t\ttransformed.add(transformedAtoms);\n\t\t}\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Calculate a List of alignment indicies that correspond to the core\n\t * of a Block, which means that all structures have a residue in that\n\t * positon.\n\t * \n\t * @param block alignment Block\n\t * @return List of positions in the core of the alignment\n\t */\n\tpublic static List<Integer> getCorePositions(Block block){\n\n\t\tList<Integer> corePositions = new ArrayList<Integer>();\n\t\t\n\t\tfor (int col=0; col<block.length(); col++){\n\t\t\tboolean core = true;\n\t\t\tfor (int str=0; str<block.size(); str++){\n\t\t\t\tif (block.getAlignRes().get(str).get(col) == null){\n\t\t\t\t\tcore = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (core) corePositions.add(col);\n\t\t}\n\t\treturn corePositions;\n\t}\n\n\t/**\n\t * Sort blocks so that the specified row is in sequential order.\n\t * The sort happens in place.\n\t * @param blocks List of blocks\n\t * @param sortedIndex Index of the row to be sorted\n\t */\n\tpublic static void sortBlocks(List<Block> blocks,final int sortedIndex) {\n\t\tCollections.sort(blocks, new Comparator<Block>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Block o1, Block o2) {\n\t\t\t\t// Compare the first non-null residue of each block\n\t\t\t\tList<Integer> alignres1 = o1.getAlignRes().get(sortedIndex);\n\t\t\t\tList<Integer> alignres2 = o2.getAlignRes().get(sortedIndex);\n\t\t\t\tInteger res1 = null;\n\t\t\t\tInteger res2 = null;\n\t\t\t\tfor(Integer r : alignres1) {\n\t\t\t\t\tif( r != null) {\n\t\t\t\t\t\tres1 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(Integer r : alignres2) {\n\t\t\t\t\tif( r != null) {\n\t\t\t\t\t\tres2 = r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn res1.compareTo(res2);\n\t\t\t}\n\t\t});\n\t}\n}\n","originTest":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.junit.Test;\n\n/**\n * \n * @author Spencer Bliven\n *\n */\npublic class MultipleAlignmentToolsTest {\n\n\t/**\n\t * Override the toString method to give shorter output for errors\n\t * @author blivens\n\t *\n\t */\n\tpublic static class NamedBlock extends BlockImpl {\n\t\tprivate static final long serialVersionUID = 5060618718423340848L;\n\t\tprivate String name;\n\t\tpublic NamedBlock(String name, BlockSet bs) {\n\t\t\tsuper(bs);\n\t\t\tthis.name = name;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Block[%s]\", name);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void testSortBlocks() {\n\t\t\n\t\t// Sample alignment with blocks out of order\n\t\t\n\t\t// Row0: Already sorted\n\t\t// Row1: Unsorted\n\t\t// Row2: Test nulls at start\n\t\t// Row3: Test all nulls\n\t\t// Row4: Test overlapping ranges\n\t\t// Row5: Test only fist element used\n\t\tMultipleAlignment align = new MultipleAlignmentImpl();\n\t\tBlockSet bs = new BlockSetImpl(align);\n\t\t\n\t\tBlock one = new NamedBlock(\"1\",bs);\n\t\tone.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( null, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22)\n\t\t\t\t));\n\t\tBlock two = new NamedBlock(\"2\",bs);\n\t\ttwo.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, null, 12),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, 11, 12)\n\t\t\t\t));\n\t\tBlock three = new NamedBlock(\"3\",bs);\n\t\tthree.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, null),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 20, 41, 42)\n\t\t\t\t));\n\t\tBlock four = new NamedBlock(\"4\",bs);\n\t\tfour.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( null, 31, 32),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 30, 51, 52),\n\t\t\t\tArrays.asList( 30, 31, 32)\n\t\t\t\t));\n\t\t\n\t\tList<Block> blocks;\n\t\tint index;\n\t\tList<Block> expected;\n\t\t\n\t\tindex = 0;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(one,two,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 1;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 2;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 3;\n\t\tblocks = align.getBlocks();\n\t\ttry {\n\t\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\t\tfail(\"Row \"+index+\" should throw NPE\");\n\t\t} catch(NullPointerException e) {}\n\n\t\tindex = 4;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 5;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t}\n\n}\n","changedTest":"package org.biojava.nbio.structure.align.multiple.util;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.align.multiple.Block;\nimport org.biojava.nbio.structure.align.multiple.BlockImpl;\nimport org.biojava.nbio.structure.align.multiple.BlockSet;\nimport org.biojava.nbio.structure.align.multiple.BlockSetImpl;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignment;\nimport org.biojava.nbio.structure.align.multiple.MultipleAlignmentImpl;\nimport org.junit.Test;\n\n/**\n * \n * @author Spencer Bliven\n *\n */\npublic class TestMultipleAlignmentTools {\n\n\t/**\n\t * Override the toString method to give shorter output for errors\n\t * @author blivens\n\t *\n\t */\n\tpublic static class NamedBlock extends BlockImpl {\n\t\tprivate static final long serialVersionUID = 5060618718423340848L;\n\t\tprivate String name;\n\t\tpublic NamedBlock(String name, BlockSet bs) {\n\t\t\tsuper(bs);\n\t\t\tthis.name = name;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn String.format(\"Block[%s]\", name);\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\t@Test\n\tpublic void testSortBlocks() {\n\t\t\n\t\t// Sample alignment with blocks out of order\n\t\t\n\t\t// Row0: Already sorted\n\t\t// Row1: Unsorted\n\t\t// Row2: Test nulls at start\n\t\t// Row3: Test all nulls\n\t\t// Row4: Test overlapping ranges\n\t\t// Row5: Test only fist element used\n\t\tMultipleAlignment align = new MultipleAlignmentImpl();\n\t\tBlockSet bs = new BlockSetImpl(align);\n\t\t\n\t\tBlock one = new NamedBlock(\"1\",bs);\n\t\tone.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( null, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 20, 21, 22)\n\t\t\t\t));\n\t\tBlock two = new NamedBlock(\"2\",bs);\n\t\ttwo.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 20, 21, 22),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, null, 12),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 10, 11, 12),\n\t\t\t\tArrays.asList( 10, 11, 12)\n\t\t\t\t));\n\t\tBlock three = new NamedBlock(\"3\",bs);\n\t\tthree.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, null),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 20, 41, 42)\n\t\t\t\t));\n\t\tBlock four = new NamedBlock(\"4\",bs);\n\t\tfour.setAlignRes(Arrays.asList(\n\t\t\t\tArrays.asList( 40, 41, 42),\n\t\t\t\tArrays.asList( 30, 31, 32),\n\t\t\t\tArrays.asList( null, 31, 32),\n\t\t\t\tArrays.asList( (Integer)null,null,null),\n\t\t\t\tArrays.asList( 30, 51, 52),\n\t\t\t\tArrays.asList( 30, 31, 32)\n\t\t\t\t));\n\t\t\n\t\tList<Block> blocks;\n\t\tint index;\n\t\tList<Block> expected;\n\t\t\n\t\tindex = 0;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(one,two,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 1;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 2;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 3;\n\t\tblocks = align.getBlocks();\n\t\ttry {\n\t\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\t\tfail(\"Row \"+index+\" should throw NPE\");\n\t\t} catch(NullPointerException e) {}\n\n\t\tindex = 4;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,four,three);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t\tindex = 5;\n\t\tblocks = align.getBlocks();\n\t\tMultipleAlignmentTools.sortBlocks(blocks, index);\n\t\texpected = Arrays.asList(two,one,three,four);\n\t\tassertEquals(\"Bad comparison of row \"+index, expected,blocks);\n\n\t}\n\n}\n","commitMessage":"Rename and move Tests for consistency","test_commitMessage":"Rename and move Tests for consistency","allZero":true}