{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/io/FastaAFPChainConverter.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/io/FastaAFPChainConverterTest.java","prod_time":"2013-06-21 06:25:03","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":14,"del_classname_line":0,"del_condition_line":5,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b3f09554549f82fa853436bae11cb926906ef1de","test_commitID":"","isfound":"not found test change","originPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.AtomImpl;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.AFPTwister;\nimport org.biojava.bio.structure.align.fatcat.FatCatFlexible;\nimport org.biojava.bio.structure.align.fatcat.FatCatRigid;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPChainScorer;\nimport org.biojava.bio.structure.align.util.AlignmentTools;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.bio.structure.jama.Matrix;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.io.CasePreservingProteinSequenceCreator;\nimport org.biojava3.core.sequence.io.FastaReader;\nimport org.biojava3.core.sequence.io.GenericFastaHeaderParser;\nimport org.biojava3.core.sequence.io.template.FastaHeaderParserInterface;\nimport org.biojava3.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava3.core.sequence.template.Sequence;\nimport org.biojava3.core.util.SequenceTools;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\tpublic static AFPChain cpFastaToAfpChain(String first, String second, Structure structure, int cpSite) throws StructureException {\n\t\tProteinSequence s1 = new ProteinSequence(first);\n\t\ts1.setUserCollection(getAlignedUserCollection(first));\n\t\tProteinSequence s2 = new ProteinSequence(second);\n\t\ts2.setUserCollection(getAlignedUserCollection(second));\n\t\treturn cpFastaToAfpChain(s1, s2, structure, cpSite);\n\t}\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t */\n\tpublic static AFPChain cpFastaToAfpChain(ProteinSequence sequence, ProteinSequence second, Structure structure, int cpSite)\n\t\t\tthrows StructureException {\n\n\t\tif (structure == null) {\n\t\t\tthrow new IllegalArgumentException(\"The structure is null\");\n\t\t}\n\n\t\tif (sequence == null) {\n\t\t\tthrow new IllegalArgumentException(\"The sequence is null\");\n\t\t}\n\n\t\t// we need to find the ungapped CP site\n\t\tint gappedCpShift = 0;\n\t\tint ungappedCpShift = 0;\n\t\twhile (ungappedCpShift < Math.abs(cpSite)) {\n\t\t\tchar c;\n\t\t\ttry {\n\t\t\t\tif (cpSite > 0) {\n\t\t\t\t\tc = sequence.getSequenceAsString().charAt(gappedCpShift);\n\t\t\t\t} else {\n\t\t\t\t\tc = sequence.getSequenceAsString().charAt(sequence.getLength() -1 - gappedCpShift);\n\t\t\t\t}\n\t\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"CP site of \" + cpSite + \" is wrong\");\n\t\t\t}\n\t\t\tif (c != '-') {\n\t\t\t\tungappedCpShift++;\n\t\t\t}\n\t\t\tgappedCpShift++;\n\t\t}\n\t\t\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure);\n\t\tAtom[] ca2 =  StructureTools.getAtomCAArray(structure); // can't use cloneCAArray because it doesn't set parent group.chain.structure\n\n\t\tProteinSequence antipermuted = new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(), gappedCpShift));\n\n\t\tResidueNumber[] residues = StructureSequenceMatcher.matchSequenceToStructure(sequence, structure);\n\t\tResidueNumber[] antipermutedResidues = StructureSequenceMatcher.matchSequenceToStructure(antipermuted, structure);\n\n\t\tResidueNumber[] nonpermutedResidues = new ResidueNumber[antipermutedResidues.length];\n\t\tSequenceTools.permuteCyclic(antipermutedResidues, nonpermutedResidues, -gappedCpShift);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence, residues);\n\t\t}\n\t\tif (second.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(second, nonpermutedResidues);\n\t\t}\n\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (residues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(sequence.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n//\t\tfor (int i = 0; i < residues.length; i++) {\n//\t\t\tif (nonpermutedResidues[i] == null) {\n//\t\t\t\tSystem.out.print(\"=\");\n//\t\t\t} else {\n//\t\t\t\tSystem.out.print(second.getSequenceAsString().charAt(i));\n//\t\t\t}\n//\t\t}\n//\t\tSystem.out.println();\n\n\t\treturn buildAlignment(ca1, ca2, residues, nonpermutedResidues);\n\n\t}\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment. Uses a\n\t * {@link CasePreservingProteinSequenceCreator} and assumes that a residue is aligned if and only if it is given by an uppercase letter.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows Exception {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tFastaHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\tinStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws Exception {\n\t\tProteinSequence seq1 = new ProteinSequence(sequence1);\n\t\tProteinSequence seq2 = new ProteinSequence(sequence2);\n\t\treturn fastaToAfpChain(seq1, seq2, structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * TODO Write comment\n\t * @param sequence1\n\t * @param sequence2\n\t * @param structure1\n\t * @param structure2\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\t\tProteinSequence s1 = new ProteinSequence(sequence1);\n\t\ts1.setUserCollection(getAlignedUserCollection(sequence1));\n\t\tProteinSequence s2 = new ProteinSequence(sequence2);\n\t\ts2.setUserCollection(getAlignedUserCollection(sequence2));\n\t\treturn fastaToAfpChain(s1, s2, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures. Assumes that a residue is aligned if and only if it is given by\n\t * an uppercase letter.\n\t * @param sequence1 <em>Must</em> have {@link ProteinSequence#getUserCollection()} set to document upper- and lower-case as aligned and unaligned; see {@link #getAlignedUserCollection(String)}\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tif (sequence1 == null || sequence2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A sequence is null\");\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tResidueNumber[] residues1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] residues2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence1.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence1, residues1);\n\t\t}\n\t\tif (sequence2.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence2, residues2);\n\t\t}\n\n\t\treturn buildAlignment(ca1, ca2, residues1, residues2);\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Builds an {@link AFPChain} from already-matched arrays of atoms and residues.\n\t * \n\t * @param ca1\n\t *            An array of atoms in the first structure\n\t * @param ca2\n\t *            An array of atoms in the second structure\n\t * @param residues1\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @param residues2\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t */\n\tprivate static AFPChain buildAlignment(Atom[] ca1, Atom[] ca2, ResidueNumber[] residues1, ResidueNumber[] residues2)\n\t\t\tthrows StructureException {\n\n\t\t// remove any gap\n\t\t// this includes the ones introduced by the nullifying above\n\t\tList<ResidueNumber> alignedResiduesList1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> alignedResiduesList2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < residues1.length; i++) {\n\t\t\tif (residues1[i] != null && residues2[i] != null) {\n\t\t\t\talignedResiduesList1.add(residues1[i]);\n\t\t\t\talignedResiduesList2.add(residues2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] alignedResidues1 = alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);\n\t\tResidueNumber[] alignedResidues2 = alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, alignedResidues1, alignedResidues2);\n\n\t\tif (alignedResidues1.length > 0 && alignedResidues2.length > 0) {\n\n\t\t\t/*\n\t\t\t * I have NO idea why this works.\n\t\t\t */\n\t\t\t\n\t\t\tAFPTwister.twistOptimized(afpChain, ca1, ca2);\n\n\t\t\tList<Group> hetatms2 = new ArrayList<Group>();\n\t\t\tList<Group> nucs2    = new ArrayList<Group>();\n\n\t\t\tGroup g2 = ca2[0].getGroup();\n\t\t\tChain c2 = null;\n\t\t\tif (g2 != null) {\n\t\t\t\tc2 = g2.getChain();\n\t\t\t\tif (c2 != null) {\n\t\t\t\t\thetatms2 = c2.getAtomGroups(\"hetatm\");\n\t\t\t\t\tnucs2 = c2.getAtomGroups(\"nucleotide\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (afpChain.getBlockNum() > 0){\n\n\t\t\t\tif (hetatms2.size() > 0 || nucs2.size() >0) {\n\n\t\t\t\t\tif (afpChain.getBlockRotationMatrix().length > 0) {\n\n\t\t\t\t\t\tMatrix m1 = afpChain.getBlockRotationMatrix()[0];\n\t\t\t\t\t\tAtom vector1 = afpChain.getBlockShiftVector()[0];\n\n\t\t\t\t\t\tfor (Group g : hetatms2) {                       \n\t\t\t\t\t\t\tCalc.rotate(g, m1);\n\t\t\t\t\t\t\tCalc.shift(g, vector1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Group g: nucs2){\n\t\t\t\t\t\t\tCalc.rotate(g, m1);\n\t\t\t\t\t\t\tCalc.shift(g, vector1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tdouble tmScore = AFPChainScorer.getTMScore(afpChain, ca1, ca2);\n\t\t\tafpChain.setTMScore(tmScore);\n\n\t\t} else {\n\t\t\tafpChain.setTMScore(0);\n\t\t}\n\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Takes a protein sequence string with capital and lowercase letters and sets its {@link ProteinSequence#getUserCollection() user collection} to record which letters are uppercase (aligned) and which are lowercase (unaligned).\n\t * @param sequence Make sure <em>not</em> to use {@link ProteinSequence#getSequenceAsString()} for this, as it won't preserve upper- and lower-case\n\t */\n\tpublic static List<Object> getAlignedUserCollection(String sequence) {\n\t\tList<Object> aligned = new ArrayList<Object>(sequence.length());\n\t\tfor (char c : sequence.toCharArray()) {\n\t\t\taligned.add(Character.isUpperCase(c));\n\t\t}\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tStructure structure1 = StructureTools.getStructure(args[1]);\n\t\tStructure structure2 = StructureTools.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","changedPro":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.biojava.bio.structure.Atom;\nimport org.biojava.bio.structure.AtomImpl;\nimport org.biojava.bio.structure.Calc;\nimport org.biojava.bio.structure.Chain;\nimport org.biojava.bio.structure.Group;\nimport org.biojava.bio.structure.ResidueNumber;\nimport org.biojava.bio.structure.SVDSuperimposer;\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.AFPTwister;\nimport org.biojava.bio.structure.align.fatcat.FatCatFlexible;\nimport org.biojava.bio.structure.align.fatcat.FatCatRigid;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AFPChainScorer;\nimport org.biojava.bio.structure.align.util.AlignmentTools;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava.bio.structure.jama.Matrix;\nimport org.biojava3.alignment.template.AlignedSequence;\nimport org.biojava3.alignment.template.SequencePair;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava3.core.sequence.io.CasePreservingProteinSequenceCreator;\nimport org.biojava3.core.sequence.io.FastaReader;\nimport org.biojava3.core.sequence.io.GenericFastaHeaderParser;\nimport org.biojava3.core.sequence.io.template.FastaHeaderParserInterface;\nimport org.biojava3.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava3.core.sequence.template.Sequence;\nimport org.biojava3.core.util.SequenceTools;\n\n/**\n * A collection of static utilities to convert between {@link AFPChain AFPChains} and {@link FastaSequence FastaSequences}.\n * \n * @author dmyersturnbull\n * @see StructureSequenceMatcher\n * @see FastaStructureParser\n * @see SeqRes2AtomAligner\n */\npublic class FastaAFPChainConverter {\n\n\tpublic static AFPChain cpFastaToAfpChain(String first, String second, Structure structure, int cpSite) throws StructureException {\n\t\tProteinSequence s1 = new ProteinSequence(first);\n\t\ts1.setUserCollection(getAlignedUserCollection(first));\n\t\tProteinSequence s2 = new ProteinSequence(second);\n\t\ts2.setUserCollection(getAlignedUserCollection(second));\n\t\treturn cpFastaToAfpChain(s1, s2, structure, cpSite);\n\t}\n\t/**\n\t * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n\t * {@link cpSite} residues to the right.\n\t * \n\t * @param cpSite\n\t *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n\t *            are acceptable\n\t */\n\tpublic static AFPChain cpFastaToAfpChain(ProteinSequence sequence, ProteinSequence second, Structure structure, int cpSite)\n\t\t\tthrows StructureException {\n\n\t\tif (structure == null) {\n\t\t\tthrow new IllegalArgumentException(\"The structure is null\");\n\t\t}\n\n\t\tif (sequence == null) {\n\t\t\tthrow new IllegalArgumentException(\"The sequence is null\");\n\t\t}\n\n\t\t// we need to find the ungapped CP site\n\t\tint gappedCpShift = 0;\n\t\tint ungappedCpShift = 0;\n\t\twhile (ungappedCpShift < Math.abs(cpSite)) {\n\t\t\tchar c;\n\t\t\ttry {\n\t\t\t\tif (cpSite > 0) {\n\t\t\t\t\tc = sequence.getSequenceAsString().charAt(gappedCpShift);\n\t\t\t\t} else {\n\t\t\t\t\tc = sequence.getSequenceAsString().charAt(sequence.getLength() -1 - gappedCpShift);\n\t\t\t\t}\n\t\t\t} catch (StringIndexOutOfBoundsException e) {\n\t\t\t\tthrow new IllegalArgumentException(\"CP site of \" + cpSite + \" is wrong\");\n\t\t\t}\n\t\t\tif (c != '-') {\n\t\t\t\tungappedCpShift++;\n\t\t\t}\n\t\t\tgappedCpShift++;\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure);\n\t\tAtom[] ca2 =  StructureTools.getAtomCAArray(structure); // can't use cloneCAArray because it doesn't set parent group.chain.structure\n\n\t\tProteinSequence antipermuted = new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(), gappedCpShift));\n\n\t\tResidueNumber[] residues = StructureSequenceMatcher.matchSequenceToStructure(sequence, structure);\n\t\tResidueNumber[] antipermutedResidues = StructureSequenceMatcher.matchSequenceToStructure(antipermuted, structure);\n\n\t\tResidueNumber[] nonpermutedResidues = new ResidueNumber[antipermutedResidues.length];\n\t\tSequenceTools.permuteCyclic(antipermutedResidues, nonpermutedResidues, -gappedCpShift);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence, residues);\n\t\t}\n\t\tif (second.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(second, nonpermutedResidues);\n\t\t}\n\n\t\t//\t\tfor (int i = 0; i < residues.length; i++) {\n\t\t//\t\t\tif (residues[i] == null) {\n\t\t//\t\t\t\tSystem.out.print(\"=\");\n\t\t//\t\t\t} else {\n\t\t//\t\t\t\tSystem.out.print(sequence.getSequenceAsString().charAt(i));\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t\tSystem.out.println();\n\t\t//\t\tfor (int i = 0; i < residues.length; i++) {\n\t\t//\t\t\tif (nonpermutedResidues[i] == null) {\n\t\t//\t\t\t\tSystem.out.print(\"=\");\n\t\t//\t\t\t} else {\n\t\t//\t\t\t\tSystem.out.print(second.getSequenceAsString().charAt(i));\n\t\t//\t\t\t}\n\t\t//\t\t}\n\t\t//\t\tSystem.out.println();\n\n\t\treturn buildAlignment(ca1, ca2, residues, nonpermutedResidues);\n\n\t}\n\n\t/**\n\t * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment. Uses a\n\t * {@link CasePreservingProteinSequenceCreator} and assumes that a residue is aligned if and only if it is given by an uppercase letter.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaFileToAfpChain(File fastaFile, Structure structure1, Structure structure2)\n\t\t\tthrows Exception {\n\t\tInputStream inStream = new FileInputStream(fastaFile);\n\t\tSequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(\n\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet());\n\t\tFastaHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\tinStream, headerParser, creator);\n\t\tLinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n\t\tinStream.close();\n\t\treturn fastaToAfpChain(sequences, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n\t */\n\tpublic static AFPChain fastaStringToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws Exception {\n\t\tProteinSequence seq1 = new ProteinSequence(sequence1);\n\t\tProteinSequence seq2 = new ProteinSequence(sequence2);\n\t\treturn fastaToAfpChain(seq1, seq2, structure1, structure2);\n\t}\n\n\t/**\n\t * Uses two sequences each with a corresponding structure to create an AFPChain corresponding to the alignment. Provided only for convenience since FastaReaders return such maps.\n\t * \n\t * @param sequences\n\t *            A Map containing exactly two entries from sequence names as Strings to gapped ProteinSequences; the name is ignored\n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(Map<String, ProteinSequence> sequences, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (sequences.size() != 2) {\n\t\t\tthrow new IllegalArgumentException(\"There must be exactly 2 sequences, but there were \" + sequences.size());\n\t\t}\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tList<ProteinSequence> seqs = new ArrayList<ProteinSequence>();\n\t\tList<String> names = new ArrayList<String>(2);\n\t\tfor (Map.Entry<String, ProteinSequence> entry : sequences.entrySet()) {\n\t\t\tseqs.add(entry.getValue());\n\t\t\tnames.add(entry.getKey());\n\t\t}\n\n\t\treturn fastaToAfpChain(seqs.get(0), seqs.get(1), structure1, structure2);\n\t}\n\n\t/**\n\t * TODO Write comment\n\t * @param sequence1\n\t * @param sequence2\n\t * @param structure1\n\t * @param structure2\n\t * @return\n\t * @throws StructureException\n\t */\n\tpublic static AFPChain fastaToAfpChain(String sequence1, String sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\t\tProteinSequence s1 = new ProteinSequence(sequence1);\n\t\ts1.setUserCollection(getAlignedUserCollection(sequence1));\n\t\tProteinSequence s2 = new ProteinSequence(sequence2);\n\t\ts2.setUserCollection(getAlignedUserCollection(sequence2));\n\t\treturn fastaToAfpChain(s1, s2, structure1, structure2);\n\t}\n\n\t/**\n\t * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n\t * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures. Assumes that a residue is aligned if and only if it is given by\n\t * an uppercase letter.\n\t * @param sequence1 <em>Must</em> have {@link ProteinSequence#getUserCollection()} set to document upper- and lower-case as aligned and unaligned; see {@link #getAlignedUserCollection(String)}\n\t */\n\tpublic static AFPChain fastaToAfpChain(ProteinSequence sequence1, ProteinSequence sequence2, Structure structure1,\n\t\t\tStructure structure2) throws StructureException {\n\n\t\tif (structure1 == null || structure2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A structure is null\");\n\t\t}\n\n\t\tif (sequence1 == null || sequence2 == null) {\n\t\t\tthrow new IllegalArgumentException(\"A sequence is null\");\n\t\t}\n\n\t\tAtom[] ca1 = StructureTools.getAtomCAArray(structure1);\n\t\tAtom[] ca2 = StructureTools.getAtomCAArray(structure2);\n\n\t\tResidueNumber[] residues1 = StructureSequenceMatcher.matchSequenceToStructure(sequence1, structure1);\n\t\tResidueNumber[] residues2 = StructureSequenceMatcher.matchSequenceToStructure(sequence2, structure2);\n\n\t\t// nullify ResidueNumbers that have a lowercase sequence character\n\t\tif (sequence1.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence1, residues1);\n\t\t}\n\t\tif (sequence2.getUserCollection() != null) {\n\t\t\tCasePreservingProteinSequenceCreator.setLowercaseToNull(sequence2, residues2);\n\t\t}\n\n\t\treturn buildAlignment(ca1, ca2, residues1, residues2);\n\n\t}\n\n\t/**\n\t * Provided only for convenience.\n\t * \n\t * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n\t */\n\tpublic static AFPChain fastaToAfpChain(SequencePair<Sequence<AminoAcidCompound>, AminoAcidCompound> alignment,\n\t\t\tStructure structure1, Structure structure2) throws StructureException {\n\t\tList<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n\t\tStringBuilder sb1 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(0)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq1 = new ProteinSequence(sb1.toString());\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor (AminoAcidCompound a : seqs.get(1)) {\n\t\t\tsb1.append(a.getBase());\n\t\t}\n\t\tProteinSequence seq2 = new ProteinSequence(sb2.toString());\n\t\tLinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n\t\tmap.put(structure1.getName(), seq1);\n\t\tmap.put(structure2.getName(), seq2);\n\t\treturn fastaToAfpChain(map, structure1, structure2);\n\t}\n\n\t/**\n\t * Builds an {@link AFPChain} from already-matched arrays of atoms and residues.\n\t * \n\t * @param ca1\n\t *            An array of atoms in the first structure\n\t * @param ca2\n\t *            An array of atoms in the second structure\n\t * @param residues1\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t * @param residues2\n\t *            An array of {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n\t */\n\tprivate static AFPChain buildAlignment(Atom[] ca1, Atom[] ca2, ResidueNumber[] residues1, ResidueNumber[] residues2)\n\t\t\tthrows StructureException {\n\n\t\t// remove any gap\n\t\t// this includes the ones introduced by the nullifying above\n\t\tList<ResidueNumber> alignedResiduesList1 = new ArrayList<ResidueNumber>();\n\t\tList<ResidueNumber> alignedResiduesList2 = new ArrayList<ResidueNumber>();\n\t\tfor (int i = 0; i < residues1.length; i++) {\n\t\t\tif (residues1[i] != null && residues2[i] != null) {\n\t\t\t\talignedResiduesList1.add(residues1[i]);\n\t\t\t\talignedResiduesList2.add(residues2[i]);\n\t\t\t}\n\t\t}\n\n\t\tResidueNumber[] alignedResidues1 = alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);\n\t\tResidueNumber[] alignedResidues2 = alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);\n\n\t\tAFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, alignedResidues1, alignedResidues2);\n\t\tafpChain.setAlgorithmName(\"unknown\");\n\n\t\tif (alignedResidues1.length > 0 && alignedResidues2.length > 0) {\n\n\t\t\tAlignmentTools.updateSuperposition(afpChain, ca1, ca2);\n\n\t\t\tdouble tmScore = AFPChainScorer.getTMScore(afpChain, ca1, ca2);\n\t\t\tafpChain.setTMScore(tmScore);\n\n\t\t} else {\n\t\t\tafpChain.setTMScore(0);\n\t\t}\n\n\t\treturn afpChain;\n\n\t}\n\n\t/**\n\t * Takes a protein sequence string with capital and lowercase letters and sets its {@link ProteinSequence#getUserCollection() user collection} to record which letters are uppercase (aligned) and which are lowercase (unaligned).\n\t * @param sequence Make sure <em>not</em> to use {@link ProteinSequence#getSequenceAsString()} for this, as it won't preserve upper- and lower-case\n\t */\n\tpublic static List<Object> getAlignedUserCollection(String sequence) {\n\t\tList<Object> aligned = new ArrayList<Object>(sequence.length());\n\t\tfor (char c : sequence.toCharArray()) {\n\t\t\taligned.add(Character.isUpperCase(c));\n\t\t}\n\t\treturn aligned;\n\t}\n\n\t/**\n\t * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n\t * \n\t * @param args\n\t *            A String array of fasta-file structure-1-name structure-2-name\n\t * @throws Exception\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\t\tif (args.length != 3) {\n\t\t\tSystem.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n\t\t\treturn;\n\t\t}\n\t\tFile fasta = new File(args[0]);\n\t\tStructure structure1 = StructureTools.getStructure(args[1]);\n\t\tStructure structure2 = StructureTools.getStructure(args[2]);\n\t\tAFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t}\n\n}\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2013-05-28\n * Created by Douglas Myers-Turnbull\n *\n * @since 3.0.6\n */\npackage org.biojava.bio.structure.io;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintStream;\n\nimport org.biojava.bio.structure.Structure;\nimport org.biojava.bio.structure.StructureException;\nimport org.biojava.bio.structure.StructureTools;\nimport org.biojava.bio.structure.align.model.AFP;\nimport org.biojava.bio.structure.align.model.AFPChain;\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.align.xml.AFPChainXMLConverter;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.custommonkey.xmlunit.DetailedDiff;\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.Difference;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.custommonkey.xmlunit.examples.RecursiveElementNameAndTextQualifier;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.xml.sax.SAXException;\n\n\n/**\n * A test for {@link FastaAFPChainConverter}.\n * @author dmyersturnbull\n *\n */\npublic class FastaAFPChainConverterTest {\n\n\tstatic {\n\t\tXMLUnit.setIgnoreWhitespace(true);\n\t\tXMLUnit.setIgnoreComments(true);\n\t\tXMLUnit.setIgnoreAttributeOrder(true);\n\t}\n\n\tpublic static void printDetailedDiff(Diff diff, PrintStream ps) {\n\t\tDetailedDiff detDiff = new DetailedDiff(diff);\n\t\tfor (Object object : detDiff.getAllDifferences()) {\n\t\t\tDifference difference = (Difference) object;\n\t\t\tps.println(difference);\n\t\t}\n\t}\n\n\t/**\n\t * Compares two XML files without regard to the order of elements or attributes, and ignoring any element named \\\"releaseDate\\\".\n\t * @return Whether the files are \\\"similar\\\"\n\t */\n\tpublic static boolean compareXml(File expectedFile, File actualFile) {\n\t\ttry {\n\t\t\tFileReader expectedFr = new FileReader(expectedFile);\n\t\t\tFileReader actualFr = new FileReader(actualFile);\n\t\t\tDiff diff = new Diff(expectedFr, actualFr);\n\t\t\t// ignore order\n\t\t\t// look at element, id, and weight (weight is a nested element)\n\t\t\tdiff.overrideElementQualifier(new RecursiveElementNameAndTextQualifier());\n\t\t\tfinal boolean isSimilar = diff.similar();\n\t\t\tif (!isSimilar) printDetailedDiff(diff, System.err);\n\t\t\texpectedFr.close();\n\t\t\tactualFr.close();\n\t\t\treturn isSimilar;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate AtomCache cache;\n\t\n\t@Before\n\tpublic void setUp() {\n\t\tcache = new AtomCache();\n\t}\n\t\n\t@Test\n\tpublic void testCpAsymmetric() throws IOException, StructureException {\n\t\tStructure structure = cache.getStructure(\"1w0p\");\n\t\tString first = (\"alfdynatgdtefdspakqgwmqdntnngsgvltnadgmpawlvqgiggraqwtyslstnqhaqassfgwrmttemkvlsggmitnyyangtqrvlpiisldssgnlvvefegqtgrtvlatgtaateyhkfelvflpgsnpsasfyfdgklirdniqptaskQNMIVWGNGSSntdgvaayrdikfei------------------------------------------------------------------------------------------------------------------QGDVIf------------RGPDRIPSIVASsvTPGVVTAFAEKRVGGgdpgalsntNDIITRTSRDGGITWDTELNLTEQinvsdeFDFSDPRPIYDPs---SNTVLVSYARWPtdaaqngdrikpwmpNGIFYSVYDVASgnWQAPIDVTdqvkersfqiagwggselyrrntslnsqqdwqsnakirivdgaanqiqvadgsrkyvvtlsidesgglvanlngvsapiilqsehakvhsfhdyelqysalnhtttlfvdgqqittwagevsqenniqfgnadaqidgrlhvqkivltqqghnlvefdafylaqqtpevekdleklgwtkiktgntmslygNASVNPGpgHGITLtrqqnisgsqNGRLIYPAIVLdrfFLNVMSIYSDDGgsnwq-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------TGSTLpipfrwksssileTLEPSEADMVELQN--GDLLLTARLDFNQivngvny--SPRQQFLSKDGGITWSLLEANNANvfsnistgTVDASITRFEqsdgSHFLLFTNPQGnpagTNgr------------QNLGLWFSFDEG--VTWKGPIQ--LVNGasaysdiyqldsenaivivetdnsnmrilrmpitllkqklt\");\n\t\tString second =   (\"--------------------------------------------------------------------------------------------kirivdgaanqiqvadgsrkyvvtlsidesgglvanlngvsapiilqsehakvhsfhdyelqysalnhtttLFVDGQQITTWagevsqenniqfgnadaqidgrlhvqkivltqqghnlvefdafylaqqtpevekdleklgwtkiktgntmslygnasvnpgpghgitltrqqnisgsqngrliypaivldrfflnvmsiysddggsnwqTGSTLpipfrwksssileTLEPSEADMVEL--QNGDLLLTARLDFNQivngvny--SPRQQFLSKDGGITWSLLEANNANvfsnisTGTVDASITRFEqsdgSHFLLFTNPQGNpagtngr--------QNLGLWFSFDEG--VTWKGPIQlv---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------NGASAYS--DIYQLd---------SENAIVIVETD---NSNMRILRMPITllkqkltalfdynatgdtefdspakqgwmqdntnngsgvltnadgmpawlvqgiggraqwtyslstnqhaqassfgwrmttemkvlsggmitnyyangtqrvlpiisldssgnlvvefegqtgrtvlatgtaateyhkfelvflpgsnpsasfyfdgklirdniqptaskqnmivwgngssntdgvaayrdikfeiQGDVIf------------RGPDRIPSIVASSVtpGVVTAFAEKRVGGgdpgalsntNDIITRTSRDGGITWDTELNLTEQinvsdefdFSDPRPIYDPs---SNTVLVSYARW----PTdaaqngdrikpwmpNGIFYSVYDVASgnWQAPIDVTdqVKERsfqiagwggselyrrntslnsqqdwqsna------------\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(first, second, structure, -393);\n\t\t// TODO\n\t}\n\n\t@Test\n\tpublic void testCpSymmetric2() throws IOException,StructureException {\n\t\tString a = \"--vRSLNCTLRDSQQ-KSLVMSG---PYELKALHLQgqdmeq-----QVVFSMSFVQGeesndkiPVALGLKEK-NLYLSSVLKdDKPTLQLESVdpknypkkkmekRFVFNKIEInn--KLEFESAQFpnWYISTSqAENmPVFLGGT----KGgqDITDFTMQFV---\";\n\t\tString b = \"esnDKIPVALGLKEKnLYLSSVLkddKPTLQLESVDpknypkkkmekRFVFNKIEINN-------KLEFESAQFpNWYISTSQA-ENMPVFLGGTkggqd-------ITDFTMQFVvrslNCTLRDSQQ--KSLVMS-GPY-ELKALHLqgqdME--QQVVFSMSFVqge\";\n\t\tStructure structure = StructureTools.getStructure(\"31BI\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(a, b, structure, 104);\n\t\tassertEquals(\"Wrong TM-score\", 0.6284, afpChain.getTMScore(), 0.001);\n\t\t// TODO\n\t}\n\t\n\t@Test\n\tpublic void testCpSymmetric1() throws IOException,StructureException {\n\t\t//cat 2GG6-best.fasta |tr -d \\\\n|pbcopy\n\t\tString a = \"-SSRPATAR-KSSGLSGTVRIPGDKSISHRSFMFGGLA-SGETRITGLLEG-EDvINTGKAMQAMGARIRKEGd---------TWIIDGVgngglLAPEAPLD---FGNAATGCRLTMGLVGvydFDSTFIGDASLtkrp---MGRVLNPLREMGVQVKSEDgdrLPVTLRGPK---TPT---PITYRVpMASAQVKSAVLLAGLNTPGITTVIEpi---MTRDHTEKMLQGFGANLTVEtdadGVRTIRLEgRGKLTGQVIDVPGDPSSTAFPLVAALLVpGSDVTILNVLMNpTR-TGLILTLQEMGADIEVINprlaggedvaDLRVRSS-----TLKGVTVPedrAPSMIDEYPILAVAAAFAEGATVMNGLEELrvkesdrLSAVANGLKLNGVDCDEGE---TSLVVRGRPdgkGLGNasgAAVAT-HLDHRIAMSFLVMGLVSENPVTVDDatmIATSFPEFMDLMAGLGAKIELS---\";\n\t\tString b = \"dGVRTIRLEgRGKLTGQVIDVPGDPSSTAFPLVAALLVpGSDVTILNVLMNpTR-TGLILTLQEMGADIEVINprlaggedvaDLRVRSS-----TLKGVTVPedrAPSMIDEYPILAVAAAfaeGATVMNGLEELrvkesdrLSAVANGLKLNGVDCDEGE---TSLVVRGRPdgkGLGnasGAAVAT-HLDHRIAMSFLVMGLVSENPVTVDDatmiaTSFPEFMDLMAGLGAKIELS----SSRPATAR-KSSGLSGTVRIPGDKSISHRSFMFGGLA-SGETRITGLLEG-EDvINTGKAMQAMGARIRKEGd---------TWIIDGVgngglLAPEAPLD---FGNAATGCRLTMGLVGVYDFDSTFIGDASLtkrp---MGRVLNPLREMGVQVKSEDgdrLPVTLRGPK---TPTP---ITYRVpMASAQVKSAVLLAGLNTPGITTVIE---PIMTRDHTEKMLQGFGANLTVEtda\";\n\t\tStructure structure = StructureTools.getStructure(\"2GG6\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.cpFastaToAfpChain(a, b, structure, 215);\n\t\t// TODO\n\t}\n\t\n\t// TODO I probably broke this test\n//\t@Test\n\tpublic void testIncomplete() throws IOException, StructureException {\n\t\tStructure s1 = cache.getStructure(\"1w0p\");\n\t\tStructure s2 = cache.getStructure(\"1qdm\");\n\t\tProteinSequence seq1 = new ProteinSequence(\"GWGG----SEL--YRRNTSLNS--QQDW-------QSNAKIRIVDGAA-----NQIQ\");\n\t\tProteinSequence seq2 = new ProteinSequence(\"WMQNQLAQNKT--QDLILDYVNQLCNRL---PSPMESAV----DCGSLGSMPDIEFT\");\n\t\tAFPChain afpChain = FastaAFPChainConverter.fastaToAfpChain(seq1, seq2, s1, s2);\n\t\tassertEquals(\"Wrong number of EQRs\", 33, afpChain.getNrEQR());\n\t\tString xml = AFPChainXMLConverter.toXML(afpChain);\n\t\tSystem.out.println(xml);\n\t\tFile expected = new File(\"src/test/resources/1w0p_1qdm.xml\");\n\t\tFile x = File.createTempFile(\"1w0p_1qdm_output\", \"xml.tmp\");\n\t\tx.deleteOnExit();\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(x));\n\t\tbw.write(xml);\n\t\tbw.close();\n\t\tassertTrue(\"AFPChain is wrong\", compareXml(expected, x));\n\t}\n\n}\n","changedTest":"","commitMessage":"Simplified FastaAFPChainConverter using new\nAlignmentTools.updateSuperposition.","test_commitMessage":"","allZero":false}