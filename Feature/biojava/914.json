{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/io/mmtf/MmtfStructureWriter.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/io/mmtf/TestMmtfStructureWriter.java","prod_time":"2020-04-13 14:39:43","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":2,"add_classname_line":0,"add_condition_line":0,"add_field_line":2,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":1,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"ab76f927265dfea8a3ffb12073823672ca3dda97","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.rcsb.mmtf.api.StructureAdapterInterface;\nimport org.rcsb.mmtf.dataholders.MmtfStructure;\n\n/**\n * Class to take Biojava structure data and covert to the DataApi for encoding.\n * Must implement all the functions in {@link StructureAdapterInterface}.\n * \n * @author Anthony Bradley\n * @since 5.0\n *\n */\npublic class MmtfStructureWriter {\n\n\tprivate StructureAdapterInterface mmtfDecoderInterface;\n\n\t/**\n\t * Pass data from Biojava structure  to another generic output type. Loops through the data\n\t * structure and calls all the set functions.\n\t * @param structure the input {@link Structure} to write\n\t * @param dataTransferInterface the generic interface that\n\t * implements all the set methods.\n\t */\n\tpublic MmtfStructureWriter(Structure structure, StructureAdapterInterface dataTransferInterface) {\n\t\tthis.mmtfDecoderInterface = dataTransferInterface;\n\t\t// Reset structure to consider altloc groups with the same residue number but different group names as seperate groups\n\t\tMmtfUtils.fixMicroheterogenity(structure);\n\t\t// Get the chain name to index map\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = MmtfUtils.getStructureInfo(structure);\n\t\tMap<String, Integer> chainIdToIndexMap = mmtfSummaryDataBean.getChainIdToIndexMap();\n\t\tList<Atom> allAtoms = mmtfSummaryDataBean.getAllAtoms();\n\t\tint numBonds = mmtfSummaryDataBean.getNumBonds();\n\t\tList<Chain> allChains = mmtfSummaryDataBean.getAllChains();\n\t\tmmtfDecoderInterface.initStructure(numBonds, allAtoms.size(), MmtfUtils.getNumGroups(structure), allChains.size(), structure.nrModels(), structure.getPDBCode());\n\t\t// Generate the secondary structure\n\t\tMmtfUtils.calculateDsspSecondaryStructure(structure);\n\t\t// Get the header and the xtal info.\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\tPDBCrystallographicInfo xtalInfo = pdbHeader.getCrystallographicInfo();\n\t\tmmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(), pdbHeader.getRwork(), pdbHeader.getResolution(), pdbHeader.getTitle(), MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),\n\t\t\t\tMmtfUtils.dateToIsoString(pdbHeader.getRelDate()), MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));\n\t\tmmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()), MmtfUtils.getUnitCellAsArray(xtalInfo), MmtfUtils.getNcsAsArray(xtalInfo.getNcsOperators()));\n\t\t// Store the bioassembly data\n\t\tstoreBioassemblyInformation(chainIdToIndexMap, pdbHeader.getBioAssemblies());\n\t\t// Store the entity data\n\t\tstoreEntityInformation(allChains, structure.getEntityInfos());\n\t\t// Now loop through the data structure\n\t\tfor (int modelIndex=0; modelIndex<structure.nrModels(); modelIndex++) {\n\t\t\tList<Chain> modelChains = structure.getChains(modelIndex);\n\t\t\t// Set this model\n\t\t\tmmtfDecoderInterface.setModelInfo(modelIndex, modelChains.size());\n\t\t\tfor(int chainInModelIndex=0; chainInModelIndex<modelChains.size(); chainInModelIndex++) {\n\t\t\t\tChain chain = modelChains.get(chainInModelIndex);\n\t\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\t\tList<Group> sequenceGroups = chain.getSeqResGroups();\n\t\t\t\tmmtfDecoderInterface.setChainInfo(chain.getId(), chain.getName(), groups.size());\n\t\t\t\tfor(int groupInChainIndex=0; groupInChainIndex<groups.size(); groupInChainIndex++){\n\t\t\t\t\tGroup group = groups.get(groupInChainIndex);\n\t\t\t\t\tList<Atom> atomsInGroup = MmtfUtils.getAtomsForGroup(group);\n\t\t\t\t\tChemComp chemComp = group.getChemComp();\n\t\t\t\t\tCharacter insCode = group.getResidueNumber().getInsCode();\n\t\t\t\t\tif(insCode==null || insCode.equals(' ')){\n\t\t\t\t\t\tinsCode=MmtfStructure.UNAVAILABLE_CHAR_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\tchar singleLetterCode = 'X';\n\t\t\t\t\tif (chemComp.getOne_letter_code().length()==1){\n\t\t\t\t\t\tsingleLetterCode = chemComp.getOne_letter_code().charAt(0);\n\t\t\t\t\t}\n\t\t\t\t\tmmtfDecoderInterface.setGroupInfo(group.getPDBName(), group.getResidueNumber().getSeqNum(), insCode.charValue(),\n\t\t\t\t\t\t\tchemComp.getType().toUpperCase(), atomsInGroup.size(), MmtfUtils.getNumBondsInGroup(atomsInGroup), singleLetterCode,\n\t\t\t\t\t\t\tsequenceGroups.indexOf(group), MmtfUtils.getSecStructType(group));\n\t\t\t\t\tfor (Atom atom : atomsInGroup){\n\t\t\t\t\t\tchar altLoc = MmtfStructure.UNAVAILABLE_CHAR_VALUE;\n\t\t\t\t\t\tif(atom.getAltLoc()!=null){\n\t\t\t\t\t\t\tif(atom.getAltLoc().charValue()!=' '){\n\t\t\t\t\t\t\t\taltLoc=atom.getAltLoc().charValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmmtfDecoderInterface.setAtomInfo(atom.getName(), atom.getPDBserial(), altLoc, (float) atom.getX(),\n\t\t\t\t\t\t\t\t(float) atom.getY(), (float) atom.getZ(), atom.getOccupancy(),\n\t\t\t\t\t\t\t\tatom.getTempFactor(), atom.getElement().toString(), atom.getCharge());\n\t\t\t\t\t\taddBonds(atom, atomsInGroup, allAtoms);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmmtfDecoderInterface.finalizeStructure();\n\n\t}\n\n\t/**\n\t * Add the bonds for a given atom.\n\t * @param atom the atom for which bonds are to be formed\n\t * @param atomsInGroup the list of atoms in the group\n\t * @param allAtoms the list of atoms in the whole structure\n\t */\n\tprivate void addBonds(Atom atom, List<Atom> atomsInGroup, List<Atom> allAtoms) {\n\t\tif(atom.getBonds()==null){\n\t\t\treturn;\n\t\t}\n\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t// Now set the bonding information.\n\t\t\tAtom other = bond.getOther(atom);\n\t\t\t// If both atoms are in the group\n\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t// Don't add the same bond twice\n\t\t\t\tif(firstBondIndex>secondBondIndex){\n\t\t\t\t\tint bondOrder = bond.getBondOrder();\n\t\t\t\t\tmmtfDecoderInterface.setGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise it's an inter group bond - so add it here\n\t\t\telse {\n\t\t\t\tInteger firstBondIndex = allAtoms.indexOf(atom);\n\t\t\t\tInteger secondBondIndex = allAtoms.indexOf(other);\n\t\t\t\tif(firstBondIndex>secondBondIndex){\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tint bondOrder = bond.getBondOrder();\n\t\t\t\t\tmmtfDecoderInterface.setInterGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Store the entity information for a given structure.\n\t * @param allChains a list of all the chains in a structure\n\t * @param entityInfos a list of the entity information\n\t */\n\tprivate void storeEntityInformation(List<Chain> allChains, List<EntityInfo> entityInfos) {\n\t\tfor (EntityInfo entityInfo : entityInfos) {\n\t\t\tString description = entityInfo.getDescription();\n\t\t\tString type;\n\t\t\tif (entityInfo.getType()==null){\n\t\t\t\ttype = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = entityInfo.getType().getEntityType();\n\t\t\t}\n\t\t\tList<Chain> entityChains = entityInfo.getChains();\n\t\t\tif (entityChains.isEmpty()){\n\t\t\t\t// Error mapping chain to entity\n\t\t\t\tSystem.err.println(\"ERROR MAPPING CHAIN TO ENTITY: \"+description);\n\t\t\t\tmmtfDecoderInterface.setEntityInfo(new int[0], \"\", description, type);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint[] chainIndices = new int[entityChains.size()];\n\t\t\t\tfor (int i=0; i<entityChains.size(); i++) {\n\t\t\t\t\tchainIndices[i] = allChains.indexOf(entityChains.get(i));\n\t\t\t\t}\n\t\t\t\tChain chain = entityChains.get(0);\n\t\t\t\tChainImpl chainImpl;\n\t\t\t\tif (chain instanceof ChainImpl){\n\t\t\t\t\tchainImpl = (ChainImpl) entityChains.get(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t\tString sequence = chainImpl.getSeqResOneLetterSeq();\n\t\t\t\tmmtfDecoderInterface.setEntityInfo(chainIndices, sequence, description, type);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate the bioassembly information on in the desired form.\n\t * @param bioJavaStruct the Biojava structure\n\t * @param header the header\n\t */\n\tprivate void storeBioassemblyInformation(Map<String, Integer> chainIdToIndexMap, Map<Integer, BioAssemblyInfo> inputBioAss) {\n\t\tint bioAssemblyIndex = 0;\n\t\tfor (Entry<Integer, BioAssemblyInfo> entry : inputBioAss.entrySet()) {\n\t\t\tMap<double[], int[]> transformMap = MmtfUtils.getTransformMap(entry.getValue(), chainIdToIndexMap);\n\t\t\tfor(Entry<double[], int[]> transformEntry : transformMap.entrySet()) {\n\t\t\t\tmmtfDecoderInterface.setBioAssemblyTrans(bioAssemblyIndex, transformEntry.getValue(), transformEntry.getKey(), entry.getKey().toString());\n\t\t\t}\n\t\t\tbioAssemblyIndex++;\n\t\t}\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.Bond;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBCrystallographicInfo;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.biojava.nbio.structure.quaternary.BioAssemblyInfo;\nimport org.rcsb.mmtf.api.StructureAdapterInterface;\nimport org.rcsb.mmtf.dataholders.MmtfStructure;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Class to take Biojava structure data and covert to the DataApi for encoding.\n * Must implement all the functions in {@link StructureAdapterInterface}.\n * \n * @author Anthony Bradley\n * @since 5.0\n *\n */\npublic class MmtfStructureWriter {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(MmtfStructureWriter.class);\n\n\tprivate final StructureAdapterInterface mmtfDecoderInterface;\n\n\t/**\n\t * Pass data from Biojava structure  to another generic output type. Loops through the data\n\t * structure and calls all the set functions.\n\t * @param structure the input {@link Structure} to write\n\t * @param dataTransferInterface the generic interface that\n\t * implements all the set methods.\n\t */\n\tpublic MmtfStructureWriter(Structure structure, StructureAdapterInterface dataTransferInterface) {\n\t\tthis.mmtfDecoderInterface = dataTransferInterface;\n\t\t// Reset structure to consider altloc groups with the same residue number but different group names as seperate groups\n\t\tMmtfUtils.fixMicroheterogenity(structure);\n\t\t// Get the chain name to index map\n\t\tMmtfSummaryDataBean mmtfSummaryDataBean = MmtfUtils.getStructureInfo(structure);\n\t\tMap<String, Integer> chainIdToIndexMap = mmtfSummaryDataBean.getChainIdToIndexMap();\n\t\tList<Atom> allAtoms = mmtfSummaryDataBean.getAllAtoms();\n\t\tint numBonds = mmtfSummaryDataBean.getNumBonds();\n\t\tList<Chain> allChains = mmtfSummaryDataBean.getAllChains();\n\t\tmmtfDecoderInterface.initStructure(numBonds, allAtoms.size(), MmtfUtils.getNumGroups(structure), allChains.size(), structure.nrModels(), structure.getPDBCode());\n\t\t// Generate the secondary structure\n\t\tMmtfUtils.calculateDsspSecondaryStructure(structure);\n\t\t// Get the header and the xtal info.\n\t\tPDBHeader pdbHeader = structure.getPDBHeader();\n\t\tPDBCrystallographicInfo xtalInfo = pdbHeader.getCrystallographicInfo();\n\t\tmmtfDecoderInterface.setHeaderInfo(pdbHeader.getRfree(), pdbHeader.getRwork(), pdbHeader.getResolution(), pdbHeader.getTitle(), MmtfUtils.dateToIsoString(pdbHeader.getDepDate()),\n\t\t\t\tMmtfUtils.dateToIsoString(pdbHeader.getRelDate()), MmtfUtils.techniquesToStringArray(pdbHeader.getExperimentalTechniques()));\n\t\tmmtfDecoderInterface.setXtalInfo(MmtfUtils.getSpaceGroupAsString(xtalInfo.getSpaceGroup()), MmtfUtils.getUnitCellAsArray(xtalInfo), MmtfUtils.getNcsAsArray(xtalInfo.getNcsOperators()));\n\t\t// Store the bioassembly data\n\t\tstoreBioassemblyInformation(chainIdToIndexMap, pdbHeader.getBioAssemblies());\n\t\t// Store the entity data\n\t\tstoreEntityInformation(allChains, structure.getEntityInfos());\n\t\t// Now loop through the data structure\n\t\tfor (int modelIndex=0; modelIndex<structure.nrModels(); modelIndex++) {\n\t\t\tList<Chain> modelChains = structure.getChains(modelIndex);\n\t\t\t// Set this model\n\t\t\tmmtfDecoderInterface.setModelInfo(modelIndex, modelChains.size());\n\t\t\tfor(int chainInModelIndex=0; chainInModelIndex<modelChains.size(); chainInModelIndex++) {\n\t\t\t\tChain chain = modelChains.get(chainInModelIndex);\n\t\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\t\tList<Group> sequenceGroups = chain.getSeqResGroups();\n\t\t\t\tmmtfDecoderInterface.setChainInfo(chain.getId(), chain.getName(), groups.size());\n\t\t\t\tfor(int groupInChainIndex=0; groupInChainIndex<groups.size(); groupInChainIndex++){\n\t\t\t\t\tGroup group = groups.get(groupInChainIndex);\n\t\t\t\t\tList<Atom> atomsInGroup = MmtfUtils.getAtomsForGroup(group);\n\t\t\t\t\tChemComp chemComp = group.getChemComp();\n\t\t\t\t\tCharacter insCode = group.getResidueNumber().getInsCode();\n\t\t\t\t\tif(insCode==null || insCode.equals(' ')){\n\t\t\t\t\t\tinsCode=MmtfStructure.UNAVAILABLE_CHAR_VALUE;\n\t\t\t\t\t}\n\t\t\t\t\tchar singleLetterCode = 'X';\n\t\t\t\t\tif (chemComp.getOne_letter_code().length()==1){\n\t\t\t\t\t\tsingleLetterCode = chemComp.getOne_letter_code().charAt(0);\n\t\t\t\t\t}\n\t\t\t\t\tmmtfDecoderInterface.setGroupInfo(group.getPDBName(), group.getResidueNumber().getSeqNum(), insCode.charValue(),\n\t\t\t\t\t\t\tchemComp.getType().toUpperCase(), atomsInGroup.size(), MmtfUtils.getNumBondsInGroup(atomsInGroup), singleLetterCode,\n\t\t\t\t\t\t\tsequenceGroups.indexOf(group), MmtfUtils.getSecStructType(group));\n\t\t\t\t\tfor (Atom atom : atomsInGroup){\n\t\t\t\t\t\tchar altLoc = MmtfStructure.UNAVAILABLE_CHAR_VALUE;\n\t\t\t\t\t\tif(atom.getAltLoc()!=null){\n\t\t\t\t\t\t\tif(atom.getAltLoc().charValue()!=' '){\n\t\t\t\t\t\t\t\taltLoc=atom.getAltLoc().charValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmmtfDecoderInterface.setAtomInfo(atom.getName(), atom.getPDBserial(), altLoc, (float) atom.getX(),\n\t\t\t\t\t\t\t\t(float) atom.getY(), (float) atom.getZ(), atom.getOccupancy(),\n\t\t\t\t\t\t\t\tatom.getTempFactor(), atom.getElement().toString(), atom.getCharge());\n\t\t\t\t\t\taddBonds(atom, atomsInGroup, allAtoms);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmmtfDecoderInterface.finalizeStructure();\n\n\t}\n\n\t/**\n\t * Add the bonds for a given atom.\n\t * @param atom the atom for which bonds are to be formed\n\t * @param atomsInGroup the list of atoms in the group\n\t * @param allAtoms the list of atoms in the whole structure\n\t */\n\tprivate void addBonds(Atom atom, List<Atom> atomsInGroup, List<Atom> allAtoms) {\n\t\tif(atom.getBonds()==null){\n\t\t\treturn;\n\t\t}\n\t\tfor(Bond bond : atom.getBonds()) {\n\t\t\t// Now set the bonding information.\n\t\t\tAtom other = bond.getOther(atom);\n\t\t\t// If both atoms are in the group\n\t\t\tif (atomsInGroup.indexOf(other)!=-1){\n\t\t\t\tInteger firstBondIndex = atomsInGroup.indexOf(atom);\n\t\t\t\tInteger secondBondIndex = atomsInGroup.indexOf(other);\n\t\t\t\t// Don't add the same bond twice\n\t\t\t\tif(firstBondIndex>secondBondIndex){\n\t\t\t\t\tint bondOrder = bond.getBondOrder();\n\t\t\t\t\tmmtfDecoderInterface.setGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Otherwise it's an inter group bond - so add it here\n\t\t\telse {\n\t\t\t\tInteger firstBondIndex = allAtoms.indexOf(atom);\n\t\t\t\tInteger secondBondIndex = allAtoms.indexOf(other);\n\t\t\t\tif(firstBondIndex>secondBondIndex){\n\t\t\t\t\t// Don't add the same bond twice\n\t\t\t\t\tint bondOrder = bond.getBondOrder();\n\t\t\t\t\tmmtfDecoderInterface.setInterGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Store the entity information for a given structure.\n\t * @param allChains a list of all the chains in a structure\n\t * @param entityInfos a list of the entity information\n\t */\n\tprivate void storeEntityInformation(List<Chain> allChains, List<EntityInfo> entityInfos) {\n\t\tfor (EntityInfo entityInfo : entityInfos) {\n\t\t\tString description = entityInfo.getDescription();\n\t\t\tString type;\n\t\t\tif (entityInfo.getType()==null){\n\t\t\t\ttype = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = entityInfo.getType().getEntityType();\n\t\t\t}\n\t\t\tList<Chain> entityChains = entityInfo.getChains();\n\t\t\tif (entityChains.isEmpty()){\n\t\t\t\t// Error mapping chain to entity\n\t\t\t\tlogger.error(\"ERROR MAPPING CHAIN TO ENTITY: \"+description);\n\t\t\t\tmmtfDecoderInterface.setEntityInfo(new int[0], \"\", description, type);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint[] chainIndices = new int[entityChains.size()];\n\t\t\t\tfor (int i=0; i<entityChains.size(); i++) {\n\t\t\t\t\tchainIndices[i] = allChains.indexOf(entityChains.get(i));\n\t\t\t\t}\n\t\t\t\tChain chain = entityChains.get(0);\n\t\t\t\tChainImpl chainImpl;\n\t\t\t\tif (chain instanceof ChainImpl){\n\t\t\t\t\tchainImpl = (ChainImpl) entityChains.get(0);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tthrow new RuntimeException(\"Encountered Chain of unexpected type\");\n\t\t\t\t}\n\t\t\t\tString sequence = chainImpl.getSeqResOneLetterSeq();\n\t\t\t\tmmtfDecoderInterface.setEntityInfo(chainIndices, sequence, description, type);\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Generate the bioassembly information on in the desired form.\n\t *\n\t */\n\tprivate void storeBioassemblyInformation(Map<String, Integer> chainIdToIndexMap, Map<Integer, BioAssemblyInfo> inputBioAss) {\n\t\tint bioAssemblyIndex = 0;\n\t\tfor (Entry<Integer, BioAssemblyInfo> entry : inputBioAss.entrySet()) {\n\t\t\tMap<double[], int[]> transformMap = MmtfUtils.getTransformMap(entry.getValue(), chainIdToIndexMap);\n\t\t\tfor(Entry<double[], int[]> transformEntry : transformMap.entrySet()) {\n\t\t\t\tmmtfDecoderInterface.setBioAssemblyTrans(bioAssemblyIndex, transformEntry.getValue(), transformEntry.getKey(), entry.getKey().toString());\n\t\t\t}\n\t\t\tbioAssemblyIndex++;\n\t\t}\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure.io.mmtf;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\n\nimport org.biojava.nbio.structure.AminoAcidImpl;\nimport org.biojava.nbio.structure.Atom;\nimport org.biojava.nbio.structure.AtomImpl;\nimport org.biojava.nbio.structure.Chain;\nimport org.biojava.nbio.structure.ChainImpl;\nimport org.biojava.nbio.structure.Element;\nimport org.biojava.nbio.structure.EntityInfo;\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.PDBHeader;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureImpl;\nimport org.biojava.nbio.structure.io.mmcif.model.ChemComp;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\nimport org.junit.rules.TemporaryFolder;\n\n/**\n * Test the Biojava MMTF writer.\n *\n * @author Anthony Bradley\n * @author Aleix Lafita\n *\n */\npublic class TestMmtfStructureWriter {\n\n\t/**\n\t * A test folder for testing writing files.\n\t */\n\t@Rule\n\tpublic TemporaryFolder testFolder = new TemporaryFolder();\n\n\n\t/**\n\t * Test that Biojava can read a file from the file system.\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testRead() throws IOException {\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\tStructure structure = MmtfActions.readFromFile((Paths.get(classLoader.getResource(\"org/biojava/nbio/structure/io/mmtf/4CUP.mmtf\").getPath())));\n\t\tassertEquals(structure.getPDBCode(),\"4CUP\");\n\t\tassertEquals(structure.getChains().size(),6);\n\t}\n\n\t/**\n\t * Test the writing of Structure objects to a file.\n\t * @throws IOException\n\t */\n\t@Test\n\tpublic void testWrite() throws IOException {\n\n\t\t// Create a structure\n\t\tStructure structure = new StructureImpl();\n\n\t\t// Add some header information\n\t\tPDBHeader pdbHeader = new PDBHeader();\n\t\tpdbHeader.setExperimentalTechnique(\"X-RAY DIFFRACTION\");\n\t\tstructure.setPDBHeader(pdbHeader);\n\n\t\t// Create one chain\n\t\tstructure.setEntityInfos(new ArrayList<EntityInfo>());\n\t\tChain chain = new ChainImpl();\n\t\tchain.setId(\"A\");\n\t\tchain.setName(\"A\");\n\t\tGroup group = new AminoAcidImpl();\n\t\tgroup.setPDBName(\"FKF\");\n\t\tChemComp chemComp = new ChemComp();\n\t\tchemComp.setType(\"TYPfdl\");\n\t\tchemComp.setOne_letter_code(\"A\");\n\t\tgroup.setChemComp(chemComp);\n\n\t\t// Create one Atom\n\t\tAtom atom = new AtomImpl();\n\t\tatom.setName(\"A\");\n\t\tatom.setElement(Element.Ag);\n\t\tatom.setCoords(new double[] { 1.0, 2.0, 3.0 });\n\n\t\t// Link together the objects\n\t\tchain.addGroup(group);\n\t\tgroup.addAtom(atom);\n\n\t\tResidueNumber residueNumber = new ResidueNumber();\n\t\tresidueNumber.setInsCode('A');\n\t\tresidueNumber.setSeqNum(100);\n\t\tgroup.setResidueNumber(residueNumber);\n\n\t\tstructure.addChain(chain);\n\n\t\tFile tempFile = testFolder.newFile(\"tmpfile\");\n\t\tMmtfActions.writeToFile(structure, tempFile.toPath());\n\t}\n}\n","changedTest":"","commitMessage":"Now considering branched entities as non-polymeric. Ends up in a more consistent state. Can be mmtf-encoded.\n","test_commitMessage":"","allZero":false}