{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava3/core/sequence/io/GenericFastaHeaderParser.java","test_path":"biojava-core/src/test/java/org/biojava3/core/sequence/io/GenericFastaHeaderParserTest.java","prod_time":"2015-01-30 06:34:57","test_time":"2015-01-30 06:34:57","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":2,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","test_commitID":"ac224492a348dfb69e069ccff4ae03b0c5d2087c","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava3.core.sequence.io;\n\nimport java.util.ArrayList;\n\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.DataSource;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava3.core.sequence.template.AbstractSequence;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.biojava3.core.sequence.template.AbstractSequence.AnnotationType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The default fasta header parser where some headers are well defined based on the source\n * database which allows us to set the source of the protein sequence and the identifier\n * that can be used in future implementations to load features from external sources\n * \n * If the user has a custom header with local data then they can create their own implementation\n * of a FastaHeaderParserInterface\n *<pre>\n * GenBank                           gi|gi-number|gb|accession|locus\n * ENA Data Library                  gi|gi-number|emb|accession|locus\n * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n * NBRF PIR                          pir||entry\n * Protein Research Foundation       prf||name\n * SWISS-PROT                        sp|accession|name\n * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n * Patents                           pat|country|number\n * GenInfo Backbone Id               bbs|number\n * General database identifier       gnl|database|identifier\n * NCBI Reference Sequence           ref|accession|locus\n * Local Sequence identifier         lcl|identifier\n *</pre>\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParser<S extends AbstractSequence<C>, C extends Compound> implements SequenceHeaderParserInterface<S,C> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParser.class);\n\n    /**\n     * Parse out the components where some have a | and others do not\n     * @param header\n     * @return\n     */\n    private String[] getHeaderValues(String header) {\n        String[] data = new String[0];\n        ArrayList<String> values = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        //commented out 1/11/2012 to resolve an issue where headers do contain a length= at the end that are not recognized\n        //if(header.indexOf(\"length=\") != -1){\n        //    data = new String[1];\n        //    int index = header.indexOf(\"length=\");\n        //    data[0] = header.substring(0, index).trim();\n    //        logger.debug(\"accession=\" + data[0]);\n        //    return data;\n        //} else\n         if (!header.startsWith(\"PDB:\")) {\n            for (int i = 0; i < header.length(); i++) {\n                if (header.charAt(i) == '|') {\n                    values.add(sb.toString());\n                    sb.setLength(0);//faster than  = new StringBuffer();\n                } else if (i == header.length() - 1) {\n                    sb.append(header.charAt(i));\n                    values.add(sb.toString());\n                } else {\n                    sb.append(header.charAt(i));\n                }\n\n                data = new String[values.size()];\n                values.toArray(data);\n            }\n        } else {\n            data = header.split(\" \");\n        }\n        return data;\n    }\n\n    /**\n     * Parse the header and set the values in the sequence\n     * @param header\n     * @param sequence\n     */\n    @Override\n\tpublic void parseHeader(String header, S sequence) {\n        //uniptrot\n        // tr|Q0TET7|Q0TET7_ECOL5 Putative uncharacterized protein OS=Escherichia coli O6:K15:H31 (strain 536 / UPEC) GN=ECP_2553 PE=4 SV=1\n        sequence.setOriginalHeader(header);\n        String[] data = getHeaderValues(header);\n\n        if (data.length == 1) {\n            sequence.setAccession(new AccessionID(data[0]));\n        } else  if (data[0].equalsIgnoreCase(\"sp\") || data[0].equalsIgnoreCase(\"tr\")) {\n            if (data[0].equalsIgnoreCase(\"sp\")) {\n                sequence.setAnnotationType(AnnotationType.CURATED);\n            } else {\n                sequence.setAnnotationType(AnnotationType.PREDICTED);\n            }\n\n            sequence.setAccession(new AccessionID(data[1], DataSource.UNIPROT));\n            if (data.length > 2) {\n                sequence.setDescription(data[2]);\n            }\n\n        } else if (data[0].equalsIgnoreCase(\"gi\")) {\n            DataSource giSource = DataSource.UNKNOWN;\n            if (data.length >= 3) {\n                if (data[2].equalsIgnoreCase(\"gb\")) {\n                    giSource = DataSource.GENBANK;\n                } else if (data[2].equalsIgnoreCase(\"emb\")) {\n                    giSource = DataSource.ENA;\n                } else if (data[2].equalsIgnoreCase(\"dbj\")) {\n                    giSource = DataSource.DDBJ;\n                }\n                sequence.setAccession(new AccessionID(data[3], giSource));\n            } else {\n                sequence.setAccession(new AccessionID(header, giSource));\n            }\n        } else if (data[0].equalsIgnoreCase(\"pir\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.NBRF));\n        } else if (data[0].equalsIgnoreCase(\"prf\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.PRF));\n        } else if (data[0].equalsIgnoreCase(\"pdb\")) {\n            sequence.setAccession(new AccessionID(data[1] + \":\" + data[2], DataSource.PDB1));\n        } else if (data[0].startsWith(\"PDB\")) {\n            String[] pdbe = data[0].split(\" \");\n            String[] pdbaccession = pdbe[0].split(\":\");\n            sequence.setAccession(new AccessionID(pdbaccession[1], DataSource.PDBe));\n        } else if (data[0].indexOf(\":\") != -1 && data.length > 1 && data[1].equals(\"PDBID\")) {\n            sequence.setAccession(new AccessionID(data[0], DataSource.PDB2));\n        } else if (data[0].equalsIgnoreCase(\"pat\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.PATENTS));\n        } else if (data[0].equalsIgnoreCase(\"bbs\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.GENINFO));\n        } else if (data[0].equalsIgnoreCase(\"gnl\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.GENERAL));\n        } else if (data[0].equalsIgnoreCase(\"ref\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.NCBI));\n        } else if (data[0].equalsIgnoreCase(\"lcl\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.LOCAL));\n        } else {\n            sequence.setAccession(new AccessionID(data[0])); // avoid the common problem of picking up all the comments original header in getOriginalHeader\n        }\n\n\n    }\n\n    /**\n     * \n     * @param args\n     */\n    public static void main(String[] args) {\n\n        logger.info(\"parseHeader\");\n        String header = \"\";\n        ProteinSequence sequence = null;\n        try {\n        \tsequence = new ProteinSequence(\"\");\n        } catch (CompoundNotFoundException e) {\n        \t// this should not happen, in case it does we log error\n        \tlogger.error(\"Could not create empty protein sequence. Error: {}. This is most likely a bug.\",e.getMessage());\n        }\n        GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance =\n          new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n        header = \"gi|gi-number|gb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n        header = \"gi|gi-number|emb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.ENA);\n\n        header = \"gi|gi-number|dbj|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n        header = \"pir||entry\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n        header = \"prf||name\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"name = {}\", sequence.getAccession());\n        logger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PRF);\n\n        header = \"sp|accession|name\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = \", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n        header = \"pdb|entry|chain\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry:chain = \", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n        header = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry:chain = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB2);\n        \n        header = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"1ECY_A = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n        header = \"pat|country|number\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"number = {}\", sequence.getAccession());\n        logger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n        header = \"bbs|number\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"number = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n        header = \"gnl|database|identifier\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"identifier = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n        header = \"ref|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n        header = \"lcl|identifier\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"identifier = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.LOCAL);\n    }\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava3.core.sequence.io;\n\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.AccessionID;\nimport org.biojava3.core.sequence.DataSource;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.biojava3.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava3.core.sequence.template.AbstractSequence;\nimport org.biojava3.core.sequence.template.AbstractSequence.AnnotationType;\nimport org.biojava3.core.sequence.template.Compound;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\n\n/**\n * The default fasta header parser where some headers are well defined based on the source\n * database which allows us to set the source of the protein sequence and the identifier\n * that can be used in future implementations to load features from external sources\n * \n * If the user has a custom header with local data then they can create their own implementation\n * of a FastaHeaderParserInterface\n *<pre>\n * GenBank                           gi|gi-number|gb|accession|locus\n * ENA Data Library                  gi|gi-number|emb|accession|locus\n * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n * NBRF PIR                          pir||entry\n * Protein Research Foundation       prf||name\n * SWISS-PROT                        sp|accession|name\n * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n * Patents                           pat|country|number\n * GenInfo Backbone Id               bbs|number\n * General database identifier       gnl|database|identifier\n * NCBI Reference Sequence           ref|accession|locus\n * Local Sequence identifier         lcl|identifier\n *</pre>\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParser<S extends AbstractSequence<C>, C extends Compound> implements SequenceHeaderParserInterface<S,C> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParser.class);\n\n    /**\n     * Parse out the components where some have a | and others do not\n     * @param header\n     * @return\n     */\n    private String[] getHeaderValues(String header) {\n        String[] data = new String[0];\n        ArrayList<String> values = new ArrayList<String>();\n        StringBuffer sb = new StringBuffer();\n        //commented out 1/11/2012 to resolve an issue where headers do contain a length= at the end that are not recognized\n        //if(header.indexOf(\"length=\") != -1){\n        //    data = new String[1];\n        //    int index = header.indexOf(\"length=\");\n        //    data[0] = header.substring(0, index).trim();\n    //        logger.debug(\"accession=\" + data[0]);\n        //    return data;\n        //} else\n         if (!header.startsWith(\"PDB:\")) {\n            for (int i = 0; i < header.length(); i++) {\n                if (header.charAt(i) == '|') {\n                    values.add(sb.toString());\n                    sb.setLength(0);//faster than  = new StringBuffer();\n                } else if (i == header.length() - 1) {\n                    sb.append(header.charAt(i));\n                    values.add(sb.toString());\n                } else {\n                    sb.append(header.charAt(i));\n                }\n\n                data = new String[values.size()];\n                values.toArray(data);\n            }\n        } else {\n            data = header.split(\" \");\n        }\n        return data;\n    }\n\n    /**\n     * Parse the header and set the values in the sequence\n     * @param header\n     * @param sequence\n     */\n    @Override\n\tpublic void parseHeader(String header, S sequence) {\n        //uniptrot\n        // tr|Q0TET7|Q0TET7_ECOL5 Putative uncharacterized protein OS=Escherichia coli O6:K15:H31 (strain 536 / UPEC) GN=ECP_2553 PE=4 SV=1\n        sequence.setOriginalHeader(header);\n        String[] data = getHeaderValues(header);\n\n        if (data.length == 1) {\n            sequence.setAccession(new AccessionID(data[0]));\n        } else  if (data[0].equalsIgnoreCase(\"sp\") || data[0].equalsIgnoreCase(\"tr\")) {\n            if (data[0].equalsIgnoreCase(\"sp\")) {\n                sequence.setAnnotationType(AnnotationType.CURATED);\n            } else {\n                sequence.setAnnotationType(AnnotationType.PREDICTED);\n            }\n\n            sequence.setAccession(new AccessionID(data[1], DataSource.UNIPROT));\n            if (data.length > 2) {\n                sequence.setDescription(data[2]);\n            }\n\n        } else if (data[0].equalsIgnoreCase(\"gi\")) {\n            DataSource giSource = DataSource.UNKNOWN;\n            if (data.length >= 3) {\n                if (data[2].equalsIgnoreCase(\"gb\")) {\n                    giSource = DataSource.GENBANK;\n                } else if (data[2].equalsIgnoreCase(\"emb\")) {\n                    giSource = DataSource.ENA;\n                } else if (data[2].equalsIgnoreCase(\"dbj\")) {\n                    giSource = DataSource.DDBJ;\n                }\n                sequence.setAccession(new AccessionID(data[3], giSource));\n            } else {\n                sequence.setAccession(new AccessionID(header, giSource));\n            }\n        } else if (data[0].equalsIgnoreCase(\"pir\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.NBRF));\n        } else if (data[0].equalsIgnoreCase(\"prf\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.PRF));\n        } else if (data[0].equalsIgnoreCase(\"pdb\")) {\n            sequence.setAccession(new AccessionID(data[1] + \":\" + data[2], DataSource.PDB1));\n        } else if (data[0].startsWith(\"PDB\")) {\n            String[] pdbe = data[0].split(\" \");\n            String[] pdbaccession = pdbe[0].split(\":\");\n            sequence.setAccession(new AccessionID(pdbaccession[1], DataSource.PDBe));\n        } else if (data[0].indexOf(\":\") != -1 && data.length > 1 && data[1].equals(\"PDBID\")) {\n            sequence.setAccession(new AccessionID(data[0], DataSource.PDB2));\n        } else if (data[0].equalsIgnoreCase(\"pat\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.PATENTS));\n        } else if (data[0].equalsIgnoreCase(\"bbs\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.GENINFO));\n        } else if (data[0].equalsIgnoreCase(\"gnl\")) {\n            sequence.setAccession(new AccessionID(data[2], DataSource.GENERAL));\n        } else if (data[0].equalsIgnoreCase(\"ref\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.NCBI));\n        } else if (data[0].equalsIgnoreCase(\"lcl\")) {\n            sequence.setAccession(new AccessionID(data[1], DataSource.LOCAL));\n        } else {\n            sequence.setAccession(new AccessionID(data[0])); // avoid the common problem of picking up all the comments original header in getOriginalHeader\n        }\n\n\n    }\n\n    /**\n     * \n     * @param args\n     */\n    public static void main(String[] args) {\n\n        logger.info(\"parseHeader\");\n        String header = \"\";\n        ProteinSequence sequence = null;\n        try {\n        \tsequence = new ProteinSequence(\"\");\n        } catch (CompoundNotFoundException e) {\n        \t// this should not happen, in case it does we log error\n        \tlogger.error(\"Could not create empty protein sequence. Error: {}. This is most likely a bug.\",e.getMessage());\n        }\n        GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance =\n          new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n        header = \"gi|gi-number|gb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n        header = \"gi|gi-number|emb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.ENA);\n\n        header = \"gi|gi-number|dbj|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n        header = \"pir||entry\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n        header = \"prf||name\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"name = {}\", sequence.getAccession());\n        logger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PRF);\n\n        header = \"sp|accession|name\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = \", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n        header = \"pdb|entry|chain\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry:chain = \", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n        header = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"entry:chain = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDB2);\n        \n        header = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"1ECY_A = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n        header = \"pat|country|number\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"number = {}\", sequence.getAccession());\n        logger.info(\"Data source: {}\", sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n        header = \"bbs|number\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"number = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n        header = \"gnl|database|identifier\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"identifier = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n        header = \"ref|accession|locus\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"accession = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n        header = \"lcl|identifier\";\n        instance.parseHeader(header, sequence);\n        logger.info(\"identifier = {}\", sequence.getAccession());\n        logger.info(\"Data source: {} = {}\", sequence.getAccession().getDataSource(), DataSource.LOCAL);\n    }\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.biojava3.core.sequence.io;\n\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.DataSource;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.Assert.*;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParserTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParserTest.class);\n\n    public GenericFastaHeaderParserTest() {\n    }\n\n    @BeforeClass\n    public static void setUpClass() throws Exception {\n    }\n\n    @AfterClass\n    public static void tearDownClass() throws Exception {\n    }\n\n    @Before\n    public void setUp() {\n    }\n\n    @After\n    public void tearDown() {\n    }\n\n    /**\n     * GenBank                           gi|gi-number|gb|accession|locus\n     * ENA Data Library                 gi|gi-number|emb|accession|locus\n     * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n     * NBRF PIR                          pir||entry\n     * Protein Research Foundation       prf||name\n     * SWISS-PROT                        sp|accession|name\n     * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n     * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n     * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n     * Patents                           pat|country|number\n     * GenInfo Backbone Id               bbs|number\n     * General database identifier       gnl|database|identifier\n     * NCBI Reference Sequence           ref|accession|locus\n     * Local Sequence identifier         lcl|identifier\n     *\n     * @author Scooter Willis <willishf at gmail dot com> \n     */\n    @Test\n    public void testParseHeader() throws CompoundNotFoundException {\n        logger.info(\"parseHeader\");\n        String header = \"\";\n        ProteinSequence sequence = new ProteinSequence(\"\");\n        GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance = new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n        header = \"gi|gi-number|gb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n        header = \"gi|gi-number|emb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.ENA);\n\n        header = \"gi|gi-number|dbj|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n        header = \"pir||entry\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n        header = \"prf||name\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"name\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PRF);\n\n        header = \"sp|accession|name\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n        header = \"pdb|entry|chain\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry:chain\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n        header = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry:chain\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB2);\n        header = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"1ECY_A\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n        header = \"pat|country|number\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"number\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n        header = \"bbs|number\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"number\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n        header = \"gnl|database|identifier\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"identifier\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n        header = \"ref|accession|locus\";\n\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n        header = \"lcl|identifier\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"identifier\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.LOCAL);\n        // TODO review the generated test code and remove the default call to fail.\n        //fail(\"The test case is a prototype.\");\n    }\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.biojava3.core.sequence.io;\n\nimport org.biojava3.core.exceptions.CompoundNotFoundException;\nimport org.biojava3.core.sequence.DataSource;\nimport org.biojava3.core.sequence.ProteinSequence;\nimport org.biojava3.core.sequence.compound.AminoAcidCompound;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class GenericFastaHeaderParserTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(GenericFastaHeaderParserTest.class);\n\n    public GenericFastaHeaderParserTest() {\n    }\n\n    @BeforeClass\n    public static void setUpClass() throws Exception {\n    }\n\n    @AfterClass\n    public static void tearDownClass() throws Exception {\n    }\n\n    @Before\n    public void setUp() {\n    }\n\n    @After\n    public void tearDown() {\n    }\n\n    /**\n     * GenBank                           gi|gi-number|gb|accession|locus\n     * ENA Data Library                 gi|gi-number|emb|accession|locus\n     * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n     * NBRF PIR                          pir||entry\n     * Protein Research Foundation       prf||name\n     * SWISS-PROT                        sp|accession|name\n     * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n     * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n     * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n     * Patents                           pat|country|number\n     * GenInfo Backbone Id               bbs|number\n     * General database identifier       gnl|database|identifier\n     * NCBI Reference Sequence           ref|accession|locus\n     * Local Sequence identifier         lcl|identifier\n     *\n     * @author Scooter Willis <willishf at gmail dot com> \n     */\n    @Test\n    public void testParseHeader() throws CompoundNotFoundException {\n        logger.info(\"parseHeader\");\n        String header = \"\";\n        ProteinSequence sequence = new ProteinSequence(\"\");\n        GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound> instance = new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>();\n\n        header = \"gi|gi-number|gb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENBANK);\n\n        header = \"gi|gi-number|emb|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.ENA);\n\n        header = \"gi|gi-number|dbj|accession|locus\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.DDBJ);\n\n        header = \"pir||entry\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.NBRF);\n\n        header = \"prf||name\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"name\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PRF);\n\n        header = \"sp|accession|name\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n\n        header = \"pdb|entry|chain\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry:chain\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB1);\n\n        header = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"entry:chain\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB2);\n        header = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"1ECY_A\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PDBe);\n\n        header = \"pat|country|number\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"number\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.PATENTS);\n\n        header = \"bbs|number\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"number\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENINFO);\n\n        header = \"gnl|database|identifier\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"identifier\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.GENERAL);\n\n        header = \"ref|accession|locus\";\n\n        instance.parseHeader(header, sequence);\n        assertEquals(\"accession\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.NCBI);\n\n        header = \"lcl|identifier\";\n        instance.parseHeader(header, sequence);\n        assertEquals(\"identifier\", sequence.getAccession().getID());\n        assertEquals(sequence.getAccession().getDataSource(), DataSource.LOCAL);\n        // TODO review the generated test code and remove the default call to fail.\n        //fail(\"The test case is a prototype.\");\n    }\n}\n","commitMessage":"Ran Optimize Imports across the whole project.\n","test_commitMessage":"Ran Optimize Imports across the whole project.\n","allZero":false}