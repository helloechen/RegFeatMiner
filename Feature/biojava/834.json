{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/io/FastaReader.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/io/FastaReaderTest.java","prod_time":"2017-12-12 08:02:24","test_time":"2018-03-16 05:46:14","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"9f6ed0392ebcf6cc8024622fac0ff8cf9aaf8ea7","test_commitID":"1458d85cad306457941b493ec2e9b6d1db20a1ed","isfound":"found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\n\n/**\n * Use FastaReaderHelper as an example of how to use this class where FastaReaderHelper should be the\n * primary class used to read Fasta files\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n */\npublic class FastaReader<S extends Sequence<?>, C extends Compound> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReader.class);\n\n\tSequenceCreatorInterface<C> sequenceCreator;\n\tSequenceHeaderParserInterface<S,C> headerParser;\n\tBufferedReaderBytesRead br;\n\tInputStreamReader isr;\n\tFileInputStream fi = null;\n\tlong fileIndex = 0;\n\tlong sequenceIndex = 0;\n\tString line = \"\";\n\tString header= \"\";\n\n\t/**\n\t * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\n\t * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\n\t * an inputstream is forced to read all the data so you don't gain anything.\n\t * @param is inputStream\n\t * @param headerParser\n\t * @param sequenceCreator\n\t */\n\tpublic FastaReader(InputStream is, SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t   SequenceCreatorInterface<C> sequenceCreator) {\n\t\tthis.headerParser = headerParser;\n\t\tisr = new InputStreamReader(is);\n\t\tthis.br = new BufferedReaderBytesRead(isr);\n\t\tthis.sequenceCreator = sequenceCreator;\n\t}\n\n\t/**\n\t * If you are going to use the FileProxyProteinSequenceCreator then you\n\t * need to use this constructor because we need details about\n\t * the location of the file.\n\t * @param file\n\t * @param headerParser\n\t * @param sequenceCreator\n\t * @throws FileNotFoundException if the file does not exist, is a directory\n\t * \trather than a regular file, or for some other reason cannot be opened\n\t * \tfor reading.\n\t * @throws SecurityException if a security manager exists and its checkRead\n\t * \tmethod denies read access to the file.\n\t */\n\tpublic FastaReader(File file, SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t   SequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\n\t\tthis.headerParser = headerParser;\n\t\tfi = new FileInputStream(file);\n\t\tisr = new InputStreamReader(fi);\n\t\tthis.br = new BufferedReaderBytesRead(isr);\n\t\tthis.sequenceCreator = sequenceCreator;\n\t}\n\n\t/**\n\t * The parsing is done in this method.<br>\n\t * This method tries to process all the available fasta records\n\t * in the File or InputStream, closes the underlying resource,\n\t * and return the results in {@link LinkedHashMap}.<br>\n\t * You don't need to call {@link #close()} after calling this method.\n\t * @see #process(int)\n\t * @return {@link HashMap} containing all the parsed fasta records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException if an error occurs reading the input file\n\t */\n\tpublic LinkedHashMap<String,S> process() throws IOException {\n\t\tLinkedHashMap<String,S> sequences = process(-1);\n\t\tclose();\n\n\t\treturn sequences;\n\t}\n\n\t/**\n\t * This method tries to parse maximum <code>max</code> records from\n\t * the open File or InputStream, and leaves the underlying resource open.<br>\n\t * Subsequent calls to the same method continue parsing the rest of the file.<br>\n\t * This is particularly useful when dealing with very big data files,\n\t * (e.g. NCBI nr database), which can't fit into memory and will take long\n\t * time before the first result is available.<br>\n\t * <b>N.B.</b>\n\t * <ul>\n\t * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n\t * <li>remember to close the underlying resource when you are done.</li>\n\t * <li>This method always return non-null hash map. When end-of-file is reached,\n\t * the number of sequences returned will be smaller than the number requested.</li>\n\t * </ul>\n\t * @see #process()\n\t * @author Amr AL-Hossary\n\t * @since 3.0.6\n\t * @param max maximum number of records to return, <code>-1</code> for infinity.\n\t * @return {@link HashMap} containing maximum <code>max</code> parsed fasta records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException if an error occurs reading the input file\n\t */\n\tpublic LinkedHashMap<String,S> process(int max) throws IOException {\n\n\n\t\tString line = \"\";\n\t\tif(this.line != null && this.line.length() > 0){\n\t\t\tline=this.line;\n\t\t}\n\t\tString header = \"\";\n\t\tif(this.header != null && this.header.length() > 0){\n\t\t\theader=this.header;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint processedSequences=0;\n\t\tboolean keepGoing = true;\n\n\n\t\tLinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\n\n\t\tdo {\n\t\t\tline = line.trim(); // nice to have but probably not needed\n\t\t\tif (line.length() != 0) {\n\t\t\t\tif (line.startsWith(\">\")) {//start of new fasta record\n\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\t//i.e. if there is already a sequence before\n\t\t\t\t\t\t//logger.info(\"Sequence index=\" + sequenceIndex);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tS sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n\t\t\t\t\t\t\theaderParser.parseHeader(header, sequence);\n\t\t\t\t\t\t\tsequences.put(sequence.getAccession().getID(),sequence);\n\t\t\t\t\t\t\tprocessedSequences++;\n\n\t\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n\t\t\t\t\t\t\t\t\theader, e.getMessage());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsb.setLength(0); //this is faster than allocating new buffers, better memory utilization (same buffer)\n\t\t\t\t\t}\n\t\t\t\t\theader = line.substring(1);\n\t\t\t\t} else if (line.startsWith(\";\")) {\n\t\t\t\t} else {\n\t\t\t\t\t//mark the start of the sequence with the fileIndex before the line was read\n\t\t\t\t\tif(sb.length() == 0){\n\t\t\t\t\t\tsequenceIndex = fileIndex;\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfileIndex = br.getBytesRead();\n\n\t\t\tline = br.readLine();\n\n\t\t\tif (line == null) {\n\t\t\t\t//i.e. EOF\n\t\t\t\tif ( sb.length() == 0 && header.length() != 0 ) {\n\t\t\t\t\tlogger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n\t\t\t\t\tlogger.warn(\"header: {}\", header);\n\t\t\t\t\theader = null;\n\t\t\t\t} else if ( sb.length() > 0 ) {\n\t\t\t\t\t//logger.info(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tS sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n\t\t\t\t\t\theaderParser.parseHeader(header, sequence);\n\t\t\t\t\t\tsequences.put(sequence.getAccession().getID(),sequence);\n\t\t\t\t\t\tprocessedSequences++;\n\t\t\t\t\t\theader = null;\n\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n\t\t\t\t\t\t\t\theader, e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeepGoing = false;\n\t\t\t}\n\t\t\tif (max > -1 && processedSequences>=max) {\n\t\t\t\tkeepGoing=false;\n\t\t\t}\n\t\t} while (keepGoing);\n\n\t\tthis.line  = line;\n\t\tthis.header= header;\n\n\t\treturn sequences;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tbr.close();\n\t\tisr.close();\n\t\t//If stream was created from File object then we need to close it\n\t\tif (fi != null) {\n\t\t\tfi.close();\n\t\t}\n\t\tthis.line=this.header = null;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString inputFile = \"/PF00104_small.fasta\";\n\t\t\tInputStream is = FastaReader.class.getResourceAsStream(inputFile);\n\n\n\t\t\tif ( is == null)\n\t\t\t\tSystem.err.println(\"Could not get input file \" + inputFile);\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(is, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\t\tis.close();\n\n\n\t\t\t//logger.info(\"Protein Sequences: {}\", proteinSequences);\n\n\t\t\tFile file = new File(inputFile);\n\t\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaProxyReader =\n\t\t\t\t\tnew FastaReader<ProteinSequence,AminoAcidCompound>(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),\n\t\t\t\t\t\t\tnew FileProxyProteinSequenceCreator(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\t\t\t\t\t\tnew FastaSequenceParser()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\tLinkedHashMap<String,ProteinSequence> proteinProxySequences = fastaProxyReader.process();\n\n\t\t\tfor(String key : proteinProxySequences.keySet()){\n\t\t\t\tProteinSequence proteinSequence = proteinProxySequences.get(key);\n\t\t\t\tlogger.info(\"Protein Proxy Sequence Key: {}\", key);\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\n//                    int dummy = 1;\n//                }\n\t\t\t\tlogger.info(\"Protein Sequence: {}\", proteinSequence.toString());\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tlogger.warn(\"Exception: \", e);\n\t\t}\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 01-21-2010\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.biojava.nbio.core.sequence.io.template.SequenceCreatorInterface;\nimport org.biojava.nbio.core.sequence.io.template.SequenceHeaderParserInterface;\nimport org.biojava.nbio.core.sequence.template.Compound;\nimport org.biojava.nbio.core.sequence.template.Sequence;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\n\n/**\n * Use FastaReaderHelper as an example of how to use this class where FastaReaderHelper should be the\n * primary class used to read Fasta files\n * @author Scooter Willis ;lt;willishf at gmail dot com&gt;\n */\npublic class FastaReader<S extends Sequence<?>, C extends Compound> {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReader.class);\n\n\tSequenceCreatorInterface<C> sequenceCreator;\n\tSequenceHeaderParserInterface<S,C> headerParser;\n\tBufferedReaderBytesRead br;\n\tInputStreamReader isr;\n\tFileInputStream fi = null;\n\tlong fileIndex = 0;\n\tlong sequenceIndex = 0;\n\tString line = \"\";\n\tString header= \"\";\n\n\t/**\n\t * If you are going to use FileProxyProteinSequenceCreator then do not use this constructor because we need details about\n\t * local file offsets for quick reads. InputStreams does not give you the name of the stream to access quickly via file seek. A seek in\n\t * an inputstream is forced to read all the data so you don't gain anything.\n\t * @param is inputStream\n\t * @param headerParser\n\t * @param sequenceCreator\n\t */\n\tpublic FastaReader(InputStream is, SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t   SequenceCreatorInterface<C> sequenceCreator) {\n\t\tthis.headerParser = headerParser;\n\t\tisr = new InputStreamReader(is);\n\t\tthis.br = new BufferedReaderBytesRead(isr);\n\t\tthis.sequenceCreator = sequenceCreator;\n\t}\n\n\t/**\n\t * If you are going to use the FileProxyProteinSequenceCreator then you\n\t * need to use this constructor because we need details about\n\t * the location of the file.\n\t * @param file\n\t * @param headerParser\n\t * @param sequenceCreator\n\t * @throws FileNotFoundException if the file does not exist, is a directory\n\t * \trather than a regular file, or for some other reason cannot be opened\n\t * \tfor reading.\n\t * @throws SecurityException if a security manager exists and its checkRead\n\t * \tmethod denies read access to the file.\n\t */\n\tpublic FastaReader(File file, SequenceHeaderParserInterface<S,C> headerParser,\n\t\t\t\t\t   SequenceCreatorInterface<C> sequenceCreator) throws FileNotFoundException {\n\t\tthis.headerParser = headerParser;\n\t\tfi = new FileInputStream(file);\n\t\tisr = new InputStreamReader(fi);\n\t\tthis.br = new BufferedReaderBytesRead(isr);\n\t\tthis.sequenceCreator = sequenceCreator;\n\t}\n\n\t/**\n\t * The parsing is done in this method.<br>\n\t * This method tries to process all the available fasta records\n\t * in the File or InputStream, closes the underlying resource,\n\t * and return the results in {@link LinkedHashMap}.<br>\n\t * You don't need to call {@link #close()} after calling this method.\n\t * @see #process(int)\n\t * @return {@link HashMap} containing all the parsed fasta records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException if an error occurs reading the input file\n\t */\n\tpublic LinkedHashMap<String,S> process() throws IOException {\n\t\tLinkedHashMap<String,S> sequences = process(-1);\n\t\tclose();\n\n\t\treturn sequences;\n\t}\n\n\t/**\n\t * This method tries to parse maximum <code>max</code> records from\n\t * the open File or InputStream, and leaves the underlying resource open.<br>\n\t * Subsequent calls to the same method continue parsing the rest of the file.<br>\n\t * This is particularly useful when dealing with very big data files,\n\t * (e.g. NCBI nr database), which can't fit into memory and will take long\n\t * time before the first result is available.<br>\n\t * <b>N.B.</b>\n\t * <ul>\n\t * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n\t * <li>remember to close the underlying resource when you are done.</li>\n\t * </ul>\n\t * @see #process()\n\t * @author Amr AL-Hossary\n\t * @since 3.0.6\n\t * @param max maximum number of records to return, <code>-1</code> for infinity.\n\t * @return {@link HashMap} containing maximum <code>max</code> parsed fasta records\n\t * present, starting current fileIndex onwards.\n\t * @throws IOException if an error occurs reading the input file\n\t */\n\tpublic LinkedHashMap<String,S> process(int max) throws IOException {\n\n\n\t\tString line = \"\";\n\t\tif(this.line != null && this.line.length() > 0){\n\t\t\tline=this.line;\n\t\t}\n\t\tString header = \"\";\n\t\tif(this.header != null && this.header.length() > 0){\n\t\t\theader=this.header;\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint processedSequences=0;\n\t\tboolean keepGoing = true;\n\n\n\t\tLinkedHashMap<String,S> sequences = new LinkedHashMap<String,S>();\n\n\t\tdo {\n\t\t\tline = line.trim(); // nice to have but probably not needed\n\t\t\tif (line.length() != 0) {\n\t\t\t\tif (line.startsWith(\">\")) {//start of new fasta record\n\n\t\t\t\t\tif (sb.length() > 0) {\n\t\t\t\t\t\t//i.e. if there is already a sequence before\n\t\t\t\t\t\t//logger.info(\"Sequence index=\" + sequenceIndex);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\t\tS sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n\t\t\t\t\t\t\theaderParser.parseHeader(header, sequence);\n\t\t\t\t\t\t\tsequences.put(sequence.getAccession().getID(),sequence);\n\t\t\t\t\t\t\tprocessedSequences++;\n\n\t\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n\t\t\t\t\t\t\t\t\theader, e.getMessage());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsb.setLength(0); //this is faster than allocating new buffers, better memory utilization (same buffer)\n\t\t\t\t\t}\n\t\t\t\t\theader = line.substring(1);\n\t\t\t\t} else if (line.startsWith(\";\")) {\n\t\t\t\t} else {\n\t\t\t\t\t//mark the start of the sequence with the fileIndex before the line was read\n\t\t\t\t\tif(sb.length() == 0){\n\t\t\t\t\t\tsequenceIndex = fileIndex;\n\t\t\t\t\t}\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfileIndex = br.getBytesRead();\n\n\t\t\tline = br.readLine();\n\n\t\t\tif (line == null) {\n\t\t\t\t//i.e. EOF\n\t\t\t\tif ( sb.length() == 0 && header.length() != 0 ) {\n\t\t\t\t\tlogger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n\t\t\t\t\tlogger.warn(\"header: {}\", header);\n\t\t\t\t\theader = null;\n\t\t\t\t} else if ( sb.length() > 0 ) {\n\t\t\t\t\t//logger.info(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n\t\t\t\t\ttry {\n\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\t\tS sequence = (S)sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n\t\t\t\t\t\theaderParser.parseHeader(header, sequence);\n\t\t\t\t\t\tsequences.put(sequence.getAccession().getID(),sequence);\n\t\t\t\t\t\tprocessedSequences++;\n\t\t\t\t\t\theader = null;\n\t\t\t\t\t} catch (CompoundNotFoundException e) {\n\t\t\t\t\t\tlogger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\",\n\t\t\t\t\t\t\t\theader, e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeepGoing = false;\n\t\t\t}\n\t\t\tif (max > -1 && processedSequences>=max) {\n\t\t\t\tkeepGoing=false;\n\t\t\t}\n\t\t} while (keepGoing);\n\n\t\tthis.line  = line;\n\t\tthis.header= header;\n\n\t\treturn max > -1 && sequences.isEmpty() ? null :  sequences;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tbr.close();\n\t\tisr.close();\n\t\t//If stream was created from File object then we need to close it\n\t\tif (fi != null) {\n\t\t\tfi.close();\n\t\t}\n\t\tthis.line=this.header = null;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString inputFile = \"/PF00104_small.fasta\";\n\t\t\tInputStream is = FastaReader.class.getResourceAsStream(inputFile);\n\n\n\t\t\tif ( is == null)\n\t\t\t\tSystem.err.println(\"Could not get input file \" + inputFile);\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(is, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\t\tis.close();\n\n\n\t\t\t//logger.info(\"Protein Sequences: {}\", proteinSequences);\n\n\t\t\tFile file = new File(inputFile);\n\t\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaProxyReader =\n\t\t\t\t\tnew FastaReader<ProteinSequence,AminoAcidCompound>(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(),\n\t\t\t\t\t\t\tnew FileProxyProteinSequenceCreator(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tAminoAcidCompoundSet.getAminoAcidCompoundSet(),\n\t\t\t\t\t\t\t\t\tnew FastaSequenceParser()\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\tLinkedHashMap<String,ProteinSequence> proteinProxySequences = fastaProxyReader.process();\n\n\t\t\tfor(String key : proteinProxySequences.keySet()){\n\t\t\t\tProteinSequence proteinSequence = proteinProxySequences.get(key);\n\t\t\t\tlogger.info(\"Protein Proxy Sequence Key: {}\", key);\n//                if(key.equals(\"Q98SJ1_CHICK/15-61\")){\n//                    int dummy = 1;\n//                }\n\t\t\t\tlogger.info(\"Protein Sequence: {}\", proteinSequence.toString());\n\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tlogger.warn(\"Exception: \", e);\n\t\t}\n\t}\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport junit.framework.TestCase;\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.util.LinkedHashMap;\nimport java.util.logging.Level;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class FastaReaderTest extends TestCase{\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReaderTest.class);\n\n\tpublic FastaReaderTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws Exception {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() throws Exception {\n\t}\n\n\t@Override\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@Override\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of process method, of class FastaReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\t\tlogger.info(\"process\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\n\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\tinStream.close();\n\n\t\t//Should have 282 sequences\n\t\t//logger.debug(\"Expecting 283 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  283 );\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 281:\n\t\t\t\t\t//logger.debug(\"Get Accession: {}\", proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(\"Get Protein Sequence: {}\", proteinSequence.getSequenceAsString());\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 282:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,283);\n\t}\n\n\t@Test\n\tpublic void processIntTest() throws Exception {\n\t\tlogger.info(\"process(int)\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tassertNotNull(inStream);\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process(200);\n\n\t\t//Should have 200 sequences\n\t\t//logger.debug(\"Expecting 200 got \" + proteinSequences.size());\n\t\tassertEquals(proteinSequences.size() ,  200 );\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"A2D504_ATEGE/1-46\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 199:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q5F0P7_HUMAN/248-428\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"DRELVVIIGWAKHI-PGFS-S----LS-LGD----------------Q----MSL--LQS-----------AWM----------------------EI-LILG------IVYRSLP---YDDKLVYAEDYIMD-------------------------------------------------------------------------------------------------------------------------------------------------------------EEHSRLAGLLELYRAILQLV-RRY-KKL-K-VEKEEF--------------------VTLKA-LALA-NSDSMY-------------------------------------------IEDL--EAVQKLQDLLHEALQD-Y-----ELS---------QR---HE----------------------------EP------W--------RTG-KLLLTLPL-LRQTA-----------------AKA-VQHF--YSVKLQGKV--PMH--KLF-------LEM---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,200);\n\n\t\t//Should have 83 sequences\n\t\tproteinSequences = fastaReader.process(200);\n\t\tassertEquals(proteinSequences.size() , 83 );\n\t\tseqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"RARA_CANFA/233-413\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(), \"TKCIIKTVEFAKQL-PGFT-T----LT-IAD----------------Q----ITL--LKA-----------ACL----------------------DI-LILR------ICTRYTP---EQDTMTFSEGLTLN-------------------------------------------------------------------------------------------------------------------------------------------------------------RTQMHKAGFGPLTDLVFAFA-NQL-LPL-E-MDDAET--------------------GLLSA-ICLI-CGDRQD-------------------------------------------LEQP--DRVDMLQEPLLEALKV-Y-----VRK---------RR---PS----------------------------RP------H--------MFP-KMLMKITD-LRSIS-----------------AKG-AERV--ITLKMEIPG--SMP--PLI-------QEM---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 81:\n\t\t\t\t\t//logger.debug(proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(proteinSequence.getSequenceAsString());\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 82:\n\t\t\t\t\tassertEquals(proteinSequence.getAccession().getID(),\"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tassertEquals(proteinSequence.getSequenceAsString(),\"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tassertEquals(seqNum,83);\n\t\tfastaReader.close();\n\t\tinStream.close();\n\t}\n\n\t@Test\n\tpublic void testSmallFasta(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b;\n\n\t\t\tint nrSeq = 0;\n\n\t\t\twhile ((b = fastaReader.process(10)) != null) {\n\t\t\t\tfor (String key : b.keySet()) {\n\t\t\t\t\tnrSeq++;\n\n\t\t\t\t\t// #282 would result in an endless loop\n\t\t\t\t\t// this makes sure it has been fixed.\n\t\t\t\t\tassertTrue( \"Looks like there is a problem with termination of processing of the FASTA file!\",nrSeq < 15);\n\t\t\t\t}\n\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tfail(ex.getMessage());\n\t\t}\n\t}\n\n\n\t@Test\n\tpublic void testSmallFasta2(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\n\n\t\t\tint nrSeq = 0;\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b = fastaReader.process();\n\n\t\t\tassertNotNull(b);\n\n\t\t\t// #282 make sure that process() still works\n\n\t\t\tassertTrue(b.keySet().size() == 10);\n\n\n\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tfail(ex.getMessage());\n\t\t}\n\t}\n}\n","changedTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.core.sequence.io;\n\nimport org.biojava.nbio.core.sequence.ProteinSequence;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompound;\nimport org.biojava.nbio.core.sequence.compound.AminoAcidCompoundSet;\nimport org.junit.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.InputStream;\nimport java.util.LinkedHashMap;\nimport java.util.logging.Level;\n\n/**\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\npublic class FastaReaderTest {\n\n\tprivate final static Logger logger = LoggerFactory.getLogger(FastaReaderTest.class);\n\n\tpublic FastaReaderTest() {\n\t}\n\n\t@BeforeClass\n\tpublic static void setUpClass() throws Exception {\n\t}\n\n\t@AfterClass\n\tpublic static void tearDownClass() throws Exception {\n\t}\n\n\t@Before\n\tpublic void setUp() {\n\t}\n\n\t@After\n\tpublic void tearDown() {\n\t}\n\n\t/**\n\t * Test of process method, of class FastaReader.\n\t */\n\t@Test\n\tpublic void testProcess() throws Exception {\n\t\tlogger.info(\"process\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tAssert.assertNotNull(inStream);\n\n\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process();\n\t\tinStream.close();\n\n\t\t//Should have 282 sequences\n\t\t//logger.debug(\"Expecting 283 got \" + proteinSequences.size());\n\t\tAssert.assertEquals(proteinSequences.size(), 283);\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"A2D504_ATEGE/1-46\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 281:\n\t\t\t\t\t//logger.debug(\"Get Accession: {}\", proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(\"Get Protein Sequence: {}\", proteinSequence.getSequenceAsString());\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 282:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tAssert.assertEquals(seqNum, 283);\n\t}\n\n\t@Test\n\tpublic void processIntTest() throws Exception {\n\t\tlogger.info(\"process(int)\");\n\t\tInputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n\t\tAssert.assertNotNull(inStream);\n\t\tFastaReader<ProteinSequence,AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence,AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence,AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\t\tLinkedHashMap<String,ProteinSequence> proteinSequences = fastaReader.process(200);\n\n\t\t//Should have 200 sequences\n\t\t//logger.debug(\"Expecting 200 got \" + proteinSequences.size());\n\t\tAssert.assertEquals(proteinSequences.size(), 200);\n\n\t\tint seqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"A2D504_ATEGE/1-46\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 199:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"Q5F0P7_HUMAN/248-428\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"DRELVVIIGWAKHI-PGFS-S----LS-LGD----------------Q----MSL--LQS-----------AWM----------------------EI-LILG------IVYRSLP---YDDKLVYAEDYIMD-------------------------------------------------------------------------------------------------------------------------------------------------------------EEHSRLAGLLELYRAILQLV-RRY-KKL-K-VEKEEF--------------------VTLKA-LALA-NSDSMY-------------------------------------------IEDL--EAVQKLQDLLHEALQD-Y-----ELS---------QR---HE----------------------------EP------W--------RTG-KLLLTLPL-LRQTA-----------------AKA-VQHF--YSVKLQGKV--PMH--KLF-------LEM---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tAssert.assertEquals(seqNum, 200);\n\n\t\t//Should have 83 sequences\n\t\tproteinSequences = fastaReader.process(200);\n\t\tAssert.assertEquals(proteinSequences.size(), 83);\n\t\tseqNum = 0;\n\t\tfor(String id:proteinSequences.keySet()) {\n\t\t\tProteinSequence proteinSequence = proteinSequences.get(id);\n\t\t\tswitch(seqNum) {\n\t\t\t\tcase 0:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"RARA_CANFA/233-413\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"TKCIIKTVEFAKQL-PGFT-T----LT-IAD----------------Q----ITL--LKA-----------ACL----------------------DI-LILR------ICTRYTP---EQDTMTFSEGLTLN-------------------------------------------------------------------------------------------------------------------------------------------------------------RTQMHKAGFGPLTDLVFAFA-NQL-LPL-E-MDDAET--------------------GLLSA-ICLI-CGDRQD-------------------------------------------LEQP--DRVDMLQEPLLEALKV-Y-----VRK---------RR---PS----------------------------RP------H--------MFP-KMLMKITD-LRSIS-----------------AKG-AERV--ITLKMEIPG--SMP--PLI-------QEM---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 81:\n\t\t\t\t\t//logger.debug(proteinSequence.getAccession());\n\t\t\t\t\t//logger.debug(proteinSequence.getSequenceAsString());\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"Q9PU76_CRONI/141-323\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 82:\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getAccession().getID(), \"Q98SJ1_CHICK/15-61\");\n\t\t\t\t\tAssert.assertEquals(proteinSequence.getSequenceAsString(), \"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tseqNum++;\n\t\t}\n\t\tAssert.assertEquals(seqNum, 83);\n\t\tfastaReader.close();\n\t\tinStream.close();\n\t}\n\n\t@Test\n\tpublic void testSmallFasta(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b;\n\n\t\t\tint nrSeq = 0;\n\n\t\t\twhile ((b = fastaReader.process(10)) != null) {\n\t\t\t\tfor (String key : b.keySet()) {\n\t\t\t\t\tnrSeq++;\n\n\t\t\t\t\t// #282 would result in an endless loop\n\t\t\t\t\t// this makes sure it has been fixed.\n\t\t\t\t\tAssert.assertTrue(\"Looks like there is a problem with termination of processing of the FASTA file!\", nrSeq < 15);\n\t\t\t\t}\n\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tAssert.fail(ex.getMessage());\n\t\t}\n\t}\n\n\n\t@Test\n\tpublic void testSmallFasta2(){\n\n\t\ttry {\n\t\t\tInputStream inStream  = this.getClass().getResourceAsStream(\"/test.fasta\");\n\n\t\t\tFastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(\n\t\t\t\t\tinStream,\n\t\t\t\t\tnew GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(),\n\t\t\t\t\tnew ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n\n\n\n\t\t\tint nrSeq = 0;\n\n\t\t\tLinkedHashMap<String, ProteinSequence> b = fastaReader.process();\n\n\t\t\tAssert.assertNotNull(b);\n\n\t\t\t// #282 make sure that process() still works\n\n\t\t\tAssert.assertTrue(b.keySet().size() == 10);\n\n\n\n\n\t\t} catch (Exception ex) {\n\t\t\tex.printStackTrace();\n\t\t\tjava.util.logging.Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n\n\t\t\tAssert.fail(ex.getMessage());\n\t\t}\n\t}\n}\n","commitMessage":"Revert to old behavior where process(int) return null on end-of-file.","test_commitMessage":"Converting junit3 to 4, thanks intellij\n","allZero":false}