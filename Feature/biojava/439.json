{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/secstruc/DSSPParser.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/secstruc/TestDSSPParser.java","prod_time":"2015-11-30 18:20:08","test_time":"2015-11-30 18:20:08","type":"EDIT","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"POSITIVE","prod_commitID":"aeb2344da0e746b31c30d2b1802b8cef8eb8722a","test_commitID":"aeb2344da0e746b31c30d2b1802b8cef8eb8722a","isfound":"found test change","originPro":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Class to parse a DSSP file (output of the DSSP program),\n * that contains the secondary structure assignment of a structure.\n * <p>\n * This class has been ported from the OWL Java library for\n * Structural Bioinformatics (https://github.com/eppic-team/owl).\n * <p>\n * As of September 2015, the DSSP source code and executables can \n * be downloaded from http://swift.cmbi.ru.nl/gv/dssp/.\n * \n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class DSSPParser {\n\t\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(DSSPParser.class);\n\n\t/** \n\t * Parse a DSSP output file and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param dsspPath path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseFile(String dsspPath, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tFile file = new File(dsspPath);\n\t\tReader read = new FileReader(file);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\t/** \n\t * Fetch and parse the DSSP file of the specified pdb code\n\t * from the PDB web server and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param pdb path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> fetch(String pdb,\n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tInputStream in = new URL(\"http://www.rcsb.org/pdb/files/\"+\n\t\t\t\tpdb+\".dssp\").openStream();\n\t\tReader read = new InputStreamReader(in);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\t/** \n\t * Parse a DSSP format String and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param dsspOut String with the DSSP output to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseString(String dsspOut, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tReader read = new StringReader(dsspOut);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\tprivate static List<SecStrucState> generalParse(BufferedReader reader, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tString startLine = \"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC\";\n\t\tString line;\n\t\t\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\t\n\t\t//Find the first line of the DSSP output\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\tif(line.startsWith(startLine)) break;\n\t\t}\n\t\t\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\n\t\t\tString indexStr = line.substring(0,5).trim();\n\t\t\tString resNumStr = line.substring(5,10).trim();\n\t\t\t\n\t\t\t//Only happens if dssp inserts a line indicating a chain break\n\t\t\tif(!resNumStr.equals(\"\")) {\t\n\t\t\t\t\n\t\t\t\tint index = Integer.valueOf(indexStr);\n\t\t\t\t//Get the group of the structure corresponding to the residue\n\t\t\t\tint resNum = Integer.valueOf(resNumStr);\n\t\t\t\tchar insCode = line.charAt(10);\n\t\t\t\tString chainId = line.substring(11,13).trim();\n\t\t\t\tResidueNumber r = new ResidueNumber(chainId, resNum, insCode);\n\t\t\t\tGroup parent = structure.getChainByPDB(chainId)\n\t\t\t\t\t\t.getGroupByPDB(r);\n\t\t\t\tSecStrucType ssType = \n\t\t\t\t\t\tSecStrucType.fromCharacter(line.charAt(16));\n\t\t\t\t\n\t\t\t\tSecStrucState ss = new SecStrucState(parent, \n\t\t\t\t\t\tSecStrucInfo.DSSP_FILE_ASSIGNMENT, ssType);\n\t\t\t\t\n\t\t\t\t//TODO ignore for now\n\t\t\t\t/*int BP1 = Integer.valueOf(line.charAt(28));\n\t\t\t\tint BP2 = Integer.valueOf(line.charAt(32));*/\n\t\t\t\t\n\t\t\t\t//Parse the energy terms of donor and acceptor\n\t\t\t\tfor (int i=0; i<4; i++){\n\t\t\t\t\t\n\t\t\t\t\tint a = 42 + i*11;\n\t\t\t\t\tint b = a + 8;\n\t\t\t\t\t\n\t\t\t\t\tString val = line.substring(a,b).trim();\n\t\t\t\t\tif (val == \"\") {\n\t\t\t\t\t\tlogger.warn(\"Unable to parse energy for resn \"+index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString[] p = val.split(\",\");\n\t\t\t\t\t\n\t\t\t\t\tint partner = Integer.valueOf(p[0]);\n\t\t\t\t\tif (partner != 0) partner += index;\n\t\t\t\t\tdouble energy = Double.valueOf(p[1]) * 1000.0;\n\t\t\t\t\t\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0: \n\t\t\t\t\t\tss.getAccept1().setPartner(partner);\n\t\t\t\t\t\tss.getAccept1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: \n\t\t\t\t\t\tss.getDonor1().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: \n\t\t\t\t\t\tss.getAccept2().setPartner(partner);\n\t\t\t\t\t\tss.getAccept2().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: \n\t\t\t\t\t\tss.getDonor2().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Angle properties\n\t\t\t\tString val = line.substring(91,97).trim();\n\t\t\t\tif (val != \"\") ss.setKappa(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse kappa for resn \"+index);\n\t\t\t\t\n\t\t\t\tval = line.substring(103,109).trim();\n\t\t\t\tif (val != \"\") ss.setPhi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse phi for resn \"+index);\n\t\t\t\t\n\t\t\t\tval = line.substring(109,116).trim();\n\t\t\t\tif (val != \"\") ss.setPsi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse psi for resn \"+index);\n\t\t\t\t\n\t\t\t\tif (assign) parent.setProperty(Group.SEC_STRUC, ss);\n\t\t\t\tsecstruc.add(ss);\n\t\t\t}\n\t\t}\n\t\t\n\t\treader.close();\n\t\treturn secstruc;\n\t}\n\n}","changedPro":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Group;\nimport org.biojava.nbio.structure.ResidueNumber;\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Class to parse a DSSP file (output of the DSSP program),\n * that contains the secondary structure assignment of a structure.\n * <p>\n * This class has been ported from the OWL Java library for\n * Structural Bioinformatics (https://github.com/eppic-team/owl).\n * <p>\n * As of September 2015, the DSSP source code and executables can \n * be downloaded from http://swift.cmbi.ru.nl/gv/dssp/.\n * \n * @author Aleix Lafita\n * @since 4.1.1\n * \n */\npublic class DSSPParser {\n\t\n\tprivate static final Logger logger = \n\t\t\tLoggerFactory.getLogger(DSSPParser.class);\n\n\t/** \n\t * Parse a DSSP output file and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param dsspPath path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseFile(String dsspPath, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\n\t\tFile file = new File(dsspPath);\n\t\tReader read = new FileReader(file);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\t/** \n\t * Fetch and parse the DSSP file of the specified pdb code\n\t * from the PDB web server and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param pdb path to the DSSP file to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> fetch(String pdb,\n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tInputStream in = new URL(\"http://www.rcsb.org/pdb/files/\"+\n\t\t\t\tpdb+\".dssp\").openStream();\n\t\tReader read = new InputStreamReader(in);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\t/** \n\t * Parse a DSSP format String and return the secondary structure \n\t * annotation as a List of {@link SecStrucState} objects.\n\t * \n\t * @param dsspOut String with the DSSP output to parse\n\t * @param structure Structure object associated to the dssp\n\t * @param assign assigns the SS to the structure if true\n\t * @return a List of SS annotation objects\n\t * @throws StructureException \n\t * @throws IOException\n\t */\n\tpublic static List<SecStrucState> parseString(String dsspOut, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tReader read = new StringReader(dsspOut);\n\t\tBufferedReader reader = new BufferedReader(read);\n\t\treturn generalParse(reader, structure, assign);\n\t}\n\t\n\tprivate static List<SecStrucState> generalParse(BufferedReader reader, \n\t\t\tStructure structure, boolean assign) \n\t\t\t\t\tthrows IOException, StructureException {\n\t\t\n\t\tString startLine = \"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC\";\n\t\tString line;\n\t\t\n\t\tList<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n\t\t\n\t\t//Find the first line of the DSSP output\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\tif(line.startsWith(startLine)) break;\n\t\t}\n\t\t\n\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\n\t\t\tString indexStr = line.substring(0,5).trim();\n\t\t\tString resNumStr = line.substring(5,10).trim();\n\t\t\t\n\t\t\t//Only happens if dssp inserts a line indicating a chain break\n\t\t\tif(!resNumStr.equals(\"\")) {\t\n\t\t\t\t\n\t\t\t\tint index = Integer.valueOf(indexStr);\n\t\t\t\t//Get the group of the structure corresponding to the residue\n\t\t\t\tint resNum = Integer.valueOf(resNumStr);\n\t\t\t\tchar insCode = line.charAt(10);\n\t\t\t\tString chainId = line.substring(11,13).trim();\n\t\t\t\tResidueNumber r = new ResidueNumber(chainId, resNum, insCode);\n\t\t\t\tGroup parent = structure.getChainByPDB(chainId)\n\t\t\t\t\t\t.getGroupByPDB(r);\n\t\t\t\tSecStrucType ssType = \n\t\t\t\t\t\tSecStrucType.fromCharacter(line.charAt(16));\n\t\t\t\t\n\t\t\t\tSecStrucState ss = new SecStrucState(parent, \n\t\t\t\t\t\tSecStrucInfo.DSSP_ASSIGNMENT, ssType);\n\t\t\t\t\n\t\t\t\t//TODO ignore for now\n\t\t\t\t/*int BP1 = Integer.valueOf(line.charAt(28));\n\t\t\t\tint BP2 = Integer.valueOf(line.charAt(32));*/\n\t\t\t\t\n\t\t\t\t//Parse the energy terms of donor and acceptor\n\t\t\t\tfor (int i=0; i<4; i++){\n\t\t\t\t\t\n\t\t\t\t\tint a = 42 + i*11;\n\t\t\t\t\tint b = a + 8;\n\t\t\t\t\t\n\t\t\t\t\tString val = line.substring(a,b).trim();\n\t\t\t\t\tif (val == \"\") {\n\t\t\t\t\t\tlogger.warn(\"Unable to parse energy for resn \"+index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tString[] p = val.split(\",\");\n\t\t\t\t\t\n\t\t\t\t\tint partner = Integer.valueOf(p[0]);\n\t\t\t\t\tif (partner != 0) partner += index;\n\t\t\t\t\tdouble energy = Double.valueOf(p[1]) * 1000.0;\n\t\t\t\t\t\n\t\t\t\t\tswitch(i){\n\t\t\t\t\tcase 0: \n\t\t\t\t\t\tss.getAccept1().setPartner(partner);\n\t\t\t\t\t\tss.getAccept1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: \n\t\t\t\t\t\tss.getDonor1().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: \n\t\t\t\t\t\tss.getAccept2().setPartner(partner);\n\t\t\t\t\t\tss.getAccept2().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: \n\t\t\t\t\t\tss.getDonor2().setPartner(partner);\n\t\t\t\t\t\tss.getDonor1().setEnergy(energy);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//Angle properties\n\t\t\t\tString val = line.substring(91,97).trim();\n\t\t\t\tif (val != \"\") ss.setKappa(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse kappa for resn \"+index);\n\t\t\t\t\n\t\t\t\tval = line.substring(103,109).trim();\n\t\t\t\tif (val != \"\") ss.setPhi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse phi for resn \"+index);\n\t\t\t\t\n\t\t\t\tval = line.substring(109,116).trim();\n\t\t\t\tif (val != \"\") ss.setPsi(Float.valueOf(val));\n\t\t\t\telse logger.warn(\"Unable to parse psi for resn \"+index);\n\t\t\t\t\n\t\t\t\tif (assign) parent.setProperty(Group.SEC_STRUC, ss);\n\t\t\t\tsecstruc.add(ss);\n\t\t\t}\n\t\t}\n\t\t\n\t\treader.close();\n\t\treturn secstruc;\n\t}\n\n}","originTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test all the options for writting and fetching DSSP file\n * formats. Also compare that files match the prediction (assumed\n * to be correct).\n * \n * @author Aleix Lafita\n *\n */\npublic class TestDSSPParser {\n\t\n\t@Test\n\tpublic void testDSSPParser() throws IOException, StructureException {\n\t\t\n\t\t//List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"5pti\");\n\t\t\n\t\tfor (String name : names) {\n\t\t\t\n\t\t\tAtomCache cache = new AtomCache();\t\t\n\t\t\tStructure s = cache.getStructure(name);\n\t\t\t\n\t\t\t//Test loading from file\n\t\t\tList<SecStrucState> file = DSSPParser.parseFile(\n\t\t\t\t\t\"src/test/resources/\"+name+\".dssp\", s, false);\n\t\t\t\n\t\t\t//Test fetching from PDB\n\t\t\tList<SecStrucState> pdb = DSSPParser.fetch(name, s, false);\n\t\t\t\n\t\t\t//Test predicting, writting and parsing back\n\t\t\tSecStrucPred sec = new SecStrucPred();\n\t\t\tList<SecStrucState> pred = sec.predict(s, false);\n\t\t\t\n\t\t\tList<SecStrucState> parseBack = DSSPParser.parseString(\n\t\t\t\t\tsec.toString(), s, false);\n\t\t\t\n\t\t\tassertTrue(\"SS assignment lengths do not match\",\n\t\t\t\t\tfile.size() == pdb.size() && \n\t\t\t\t\tpred.size() == parseBack.size() &&\n\t\t\t\t\tpred.size() == file.size());\n\t\t\t\n\t\t\tfor (int i=0; i<file.size(); i++){\n\t\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\",\n\t\t\t\t\t\tfile.get(i), pdb.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\",\n\t\t\t\t\t\tpred.get(i), parseBack.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \"+(i+1)+\" does not match\",\n\t\t\t\t\t\tfile.get(i), pred.get(i));\n\t\t\t}\n\t\t}\n\t}\n}\n","changedTest":"package org.biojava.nbio.structure.secstruc;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.biojava.nbio.structure.Structure;\nimport org.biojava.nbio.structure.StructureException;\nimport org.biojava.nbio.structure.align.util.AtomCache;\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n\n/**\n * Test all the options for writting and fetching DSSP file formats. Also\n * compare that files match the prediction (assumed to be correct).\n * \n * @author Aleix Lafita\n *\n */\npublic class TestDSSPParser {\n\n\t@Test\n\tpublic void testDSSPParser() throws IOException, StructureException {\n\n\t\t// List of names to test the DSSP prediction\n\t\tList<String> names = Arrays.asList(\"5pti\");\n\n\t\tfor (String name : names) {\n\n\t\t\tAtomCache cache = new AtomCache();\n\t\t\tStructure s = cache.getStructure(name);\n\n\t\t\t// Test loading from file\n\t\t\tList<SecStrucState> file = DSSPParser.parseFile(\n\t\t\t\t\t\"src/test/resources/\" + name + \".dssp\", s, false);\n\n\t\t\t// Test fetching from PDB\n\t\t\tList<SecStrucState> pdb = DSSPParser.fetch(name, s, false);\n\n\t\t\t// Test predicting, writting and parsing back\n\t\t\tSecStrucPred sec = new SecStrucPred();\n\t\t\tList<SecStrucState> pred = sec.predict(s, false);\n\n\t\t\tList<SecStrucState> parseBack = DSSPParser.parseString(\n\t\t\t\t\tsec.toString(), s, false);\n\n\t\t\tassertTrue(\n\t\t\t\t\t\"SS assignment lengths do not match\",\n\t\t\t\t\tfile.size() == pdb.size()\n\t\t\t\t\t\t\t&& pred.size() == parseBack.size()\n\t\t\t\t\t\t\t&& pred.size() == file.size());\n\n\t\t\tfor (int i = 0; i < file.size(); i++) {\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", file.get(i), pdb.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", pred.get(i), parseBack.get(i));\n\t\t\t\tassertEquals(\"SS assignment position \" + (i + 1)\n\t\t\t\t\t\t+ \" does not match\", file.get(i), pred.get(i));\n\t\t\t}\n\t\t}\n\t}\n}\n","commitMessage":"Format and improve SS support","test_commitMessage":"Format and improve SS support","allZero":true}