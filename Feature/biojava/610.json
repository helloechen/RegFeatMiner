{"repository":"biojava","prod_path":"biojava-structure/src/main/java/org/biojava/nbio/structure/StructureImpl.java","test_path":"biojava-structure/src/test/java/org/biojava/nbio/structure/TestStructureImpl.java","prod_time":"2016-05-11 05:03:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":9,"add_classname_line":0,"add_condition_line":2,"add_field_line":0,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":2,"add_return_line":1,"del_annotation_line":0,"del_call_line":4,"del_classname_line":0,"del_condition_line":1,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":2,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"bf9132493ce0a950b3ac5c826a5bcce83c2854bb","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.nbio.structure;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.biojava.nbio.structure.io.FileConvert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of a PDB Structure. This class\n * provides the data contained in a PDB file.\n * to get structure objects from different sources\n * see io package.\n *\n * @author Andreas Prlic\n * @author Jules Jacobsen\n * @since 1.4\n * @version %I% %G%\n */\npublic class StructureImpl implements Structure, Serializable {\n\n\tprivate static final long serialVersionUID = -8344837138032851348L;\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureImpl.class);\n\n\tprivate String pdb_id ;\n\n\tprivate List<Model> models;\n\n\tprivate List<EntityInfo> entityInfos;\n\tprivate List<DBRef> dbrefs;\n\tprivate List<Bond> ssbonds;\n\tprivate List<Site> sites;\n\tprivate String name ;\n\tprivate StructureIdentifier structureIdentifier;\n\n\tprivate PDBHeader pdbHeader;\n\n\tprivate Long id;\n\tprivate boolean biologicalAssembly;\n\n\t/**\n\t *  Constructs a StructureImpl object.\n\t */\n\tpublic StructureImpl() {\n\t\tsuper();\n\n\t\tmodels         = new ArrayList<>();\n\t\tname           = \"\";\n\t\tentityInfos      = new ArrayList<>();\n\t\tdbrefs         = new ArrayList<>();\n\t\tpdbHeader      = new PDBHeader();\n\t\tssbonds        = new ArrayList<>();\n\t\tsites          = new ArrayList<>();\n\t}\n\n\n\t/** get the ID used by Hibernate\n\t *\n\t * @return the ID used by Hibernate\n\t */\n\t@Override\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\n\t/** set the ID used by Hibernate\n\t *\n\t * @param id the hibernate ID\n\t */\n\t@Override\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\n\n\n\t/** Construct a Structure object that only contains a single group\n\t *\n\t * @param g group object\n\t */\n\tpublic StructureImpl(Group g){\n\t\tthis();\n\n\t\tChain c = new ChainImpl();\n\t\tc.addGroup(g);\n\n\t\taddChain(c);\n\t}\n\n\t/** construct a Structure object that contains a particular chain\n\t *\n\t * @param c chain\n\t */\n\tpublic StructureImpl(Chain c){\n\t\tthis();\n\t\taddChain(c);\n\t}\n\n\t/** returns an identical copy of this structure .\n\t * @return an identical Structure object\n\t */\n\t@Override\n\tpublic Structure clone() {\n\t\t// Note: structures are also cloned in SubstructureIdentifier.reduce().\n\t\t// Changes might need to be made there as well\n\n\t\tStructure n = new StructureImpl();\n\t\t// go through whole substructure and clone ...\n\n\t\t// copy structure data\n\n\t\tn.setPDBCode(getPDBCode());\n\t\tn.setName(getName());\n\t\t//TODO the header data is not being deep-copied, that's a minor issue since it is just some static metadata, but we should recheck this if needed - JD 2014-12-11\n\t\tn.setPDBHeader(pdbHeader);\n\t\tn.setDBRefs(this.getDBRefs());\n\t\tn.setSites(getSites());\n\n\n\t\t// go through each chain and clone chain\n\t\tfor (int i=0;i<nrModels();i++){\n\t\t\tList<Chain> cloned_model = new ArrayList<Chain>();\n\n\t\t\tfor (int j=0;j<size(i);j++){\n\n\t\t\t\tChain cloned_chain  = (Chain) getChain(i,j).clone();\n\n\t\t\t\t// setting the parent: can only be done from the parent\n\t\t\t\tcloned_chain.setStructure(n);\n\n\t\t\t\tcloned_model.add(cloned_chain);\n\n\t\t\t}\n\t\t\tn.addModel(cloned_model);\n\n\t\t}\n\n\t\t// deep-copying of entityInfofos is tricky: there's cross references also in the Chains\n\t\t// beware: if we copy the entityInfos we would also need to reset the references to entityInfos in the individual chains\n\t\tList<EntityInfo> newEntityInfoList = new ArrayList<EntityInfo>();\n\t\tfor (EntityInfo entityInfo : this.entityInfos) {\n\t\t\tEntityInfo newEntityInfo = new EntityInfo(entityInfo); // this sets everything but the chains\n\t\t\tfor (String asymId:entityInfo.getChainIds()) {\n\n\t\t\t\tfor (int modelNr=0;modelNr<n.nrModels();modelNr++) {\n\t\t\t\t\tChain newChain = n.getChain(asymId,modelNr);\n\t\t\t\t\tif (newChain==null) {\n\t\t\t\t\t\t// this actually happens for structure 1msh, which has no chain B for model 29 (clearly a deposition error)\n\t\t\t\t\t\tlogger.warn(\"Could not find chain asymId \"+asymId+\" of model \"+modelNr+\" while cloning entityInfo \"+entityInfo.getMolId()+\". Something is wrong!\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnewChain.setEntityInfo(newEntityInfo);\n\t\t\t\t\tnewEntityInfo.addChain(newChain);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewEntityInfoList.add(newEntityInfo);\n\t\t}\n\t\tn.setEntityInfos(newEntityInfoList);\n\t\t// TODO ssbonds are complicated to clone: there are deep references inside Atom objects, how would we do it? - JD 2016-03-03\n\n\t\treturn n ;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Group findGroup(String chainId, String pdbResnum, int modelnr)\n\t\t\tthrows StructureException {\n\n\n\t\t// if structure is xray there will be only one \"model\".\n\t\tif ( modelnr > models.size())\n\t\t\tthrow new StructureException(\" no model nr \" + modelnr +\n\t\t\t\t\t\" in this structure. (contains \"+models.size()+\")\");\n\n\n\t\tChain c = findChain(chainId,modelnr);\n\n\t\tList<Group> groups = c.getAtomGroups();\n\n\t\t// now iterate over all groups in this chain.\n\t\t// in order to find the amino acid that has this pdbRenum.\n\n\t\tfor (Group g : groups) {\n\t\t\tString rnum = g.getResidueNumber().toString();\n\t\t\t//System.out.println(g + \" >\" + rnum + \"< >\" + pdbResnum + \"<\");\n\t\t\t// we only mutate amino acids\n\t\t\t// and ignore hetatoms and nucleotides in this case\n\t\t\tif (rnum.equals(pdbResnum)) {\n\t\t\t\treturn g;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StructureException(\"could not find group \" + pdbResnum +\n\t\t\t\t\" in chain \" + chainId);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Group findGroup(String chainName, String pdbResnum) throws StructureException\n\t{\n\t\treturn findGroup(chainName, pdbResnum, 0);\n\n\t}\n\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain findChain(String asymId, int modelnr) throws StructureException {\n\n\t\tList<Chain> chains = getChains(modelnr);\n\n\t\t// iterate over all chains.\n\t\tfor (Chain c : chains) {\n\t\t\tif (c.getName().equals(asymId)) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\tthrow new StructureException(\"Could not find chain by asymId \\\"\" + asymId + \"\\\" for PDB id \" + pdb_id);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain findChain(String chainId) throws StructureException {\n\n\t\treturn findChain(chainId,0);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setPDBCode (String pdb_id_) {\n\t\tpdb_id = pdb_id_ ;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String  getPDBCode () {\n\t\treturn pdb_id ;\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void   setName(String nam) { name = nam; }\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String getName()           { return name;  }\n\n\n\n\t/**\n\t * @return The StructureIdentifier used to create this structure\n\t */\n\t@Override\n\tpublic StructureIdentifier getStructureIdentifier() {\n\t\treturn structureIdentifier;\n\t}\n\n\t/**\n\t * @param structureIdentifier the structureIdentifier corresponding to this structure\n\t */\n\t@Override\n\tpublic void setStructureIdentifier(StructureIdentifier structureIdentifier) {\n\t\tthis.structureIdentifier = structureIdentifier;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addChain(Chain chain) {\n\t\tint modelnr = 0 ;\n\t\taddChain(chain,modelnr);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addChain(Chain chain, int modelnr) {\n\t\t// if model has not been initialized, init it!\n\t\tchain.setStructure(this);\n\t\tif (models.isEmpty()) {\n\t\t\tModel model = new Model();\n\t\t\tList<Chain> modelChains = new ArrayList<Chain>() ;\n\t\t\tmodelChains.add(chain);\n\t\t\tmodel.setChains(modelChains);\n\t\t\tmodels.add(model);\n\n\t\t} else {\n\t\t\tModel model = models.get(modelnr);\n\t\t\tmodel.addChain(chain);\n\t\t}\n\n\n\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(int number) {\n\n\t\tint modelnr = 0 ;\n\n\t\treturn getChain(modelnr,number);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(int modelnr,int number) {\n\n\t\tModel model = models.get(modelnr);\n\n\t\treturn model.getChains().get(number);\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addModel(List<Chain> modelChains){\n\t\tfor (Chain c: modelChains){\n\t\t\tc.setStructure(this);\n\t\t}\n\t\tModel model = new Model();\n\t\tmodel.setChains(modelChains);\n\t\tmodels.add(model);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setChains(List<Chain> chains){\n\n\t\tsetModel(0,chains);\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setModel(int position, List<Chain> modelChains){\n\t\tif (modelChains == null)\n\t\t\tthrow new IllegalArgumentException(\"trying to set model to null!\");\n\n\t\tfor (Chain c: modelChains)\n\t\t\tc.setStructure(this);\n\n\t\t//System.out.println(\"model size:\" + models.size());\n\n\n\t\tModel model = new Model();\n\t\tmodel.setChains(modelChains);\n\n\t\tif (models.isEmpty()){\n\t\t\tmodels.add(model);\n\t\t} else {\n\t\t\tmodels.set(position, model);\n\t\t}\n\t}\n\n\t/** String representation.\n\t *\n\t */\n\t@Override\n\tpublic String toString(){\n\t\tString newline = System.getProperty(\"line.separator\");\n\t\tStringBuilder str = new StringBuilder();\n\t\tstr.append(\"structure \");\n\t\tstr.append(name);\n\t\tstr.append(\" \");\n\t\tstr.append(pdb_id);\n\t\tstr.append(\" \");\n\n\t\tif ( nrModels()>1 ){\n\t\t\tstr.append( \" models: \");\n\t\t\tstr.append(nrModels());\n\t\t\tstr.append(newline) ;\n\t\t}\n\n\t\tstr.append(pdbHeader);\n\t\tstr.append(newline) ;\n\n\t\tfor (int i=0;i<nrModels();i++){\n\t\t\tif ( nrModels()>1 ) {\n\t\t\t\tstr.append(\" model[\");\n\t\t\t\tstr.append(i);\n\t\t\t\tstr.append(\"]:\");\n\t\t\t\tstr.append(newline);\n\t\t\t}\n\t\t\tstr.append(\" chains:\");\n\t\t\tstr.append(newline);\n\n\t\t\tfor (int j=0;j<size(i);j++){\n\n\t\t\t\tChain cha = getChain(i,j);\n\t\t\t\tList<Group> agr = cha.getAtomGroups(GroupType.AMINOACID);\n\t\t\t\tList<Group> hgr = cha.getAtomGroups(GroupType.HETATM);\n\t\t\t\tList<Group> ngr = cha.getAtomGroups(GroupType.NUCLEOTIDE);\n\n\n\n\n\t\t\t\tstr.append(\"chain \")\n\t\t\t\t\t\t.append(j).append(\": asymId:\")\n\t\t\t\t\t\t.append(cha.getId())\n\t\t\t\t\t\t.append(\" authId:\")\n\t\t\t\t\t\t.append(cha.getName()).append(\" \");\n\n\n\t\t\t\tif ( cha.getEntityInfo() != null){\n\t\t\t\t\tEntityInfo comp = cha.getEntityInfo();\n\t\t\t\t\tString molName = comp.getDescription();\n\t\t\t\t\tif ( molName != null){\n\t\t\t\t\t\tstr.append(molName);\n\t\t\t\t\t}\n\t\t\t\t\tString type =  comp.getType().toString();\n\t\t\t\t\tstr.append(\" (\")\n\t\t\t\t\t\t\t.append(type)\n\t\t\t\t\t\t\t.append(\")\");\n\t\t\t\t}\n\n\n\t\t\t\tstr.append(newline);\n\t\t\t\tstr.append(\" length SEQRES: \").append(cha.getSeqResLength());\n\t\t\t\tstr.append(\" length ATOM: \").append(cha.getAtomLength());\n\t\t\t\tstr.append(\" aminos: \").append(agr.size());\n\t\t\t\tstr.append(\" hetatms: \").append(hgr.size());\n\t\t\t\tstr.append(\" nucleotides: \").append(ngr.size()).append(newline);\n\t\t\t}\n\n\t\t}\n\t\tstr.append(\"DBRefs: \").append(dbrefs.size()).append(newline);\n\t\tfor (DBRef dbref: dbrefs){\n\t\t\tstr.append(dbref.toPDB()).append(newline);\n\t\t}\n\t\tstr.append(\"Molecules: \").append(newline);\n\t\tfor (EntityInfo mol : entityInfos) {\n\t\t\tstr.append(mol).append(newline);\n\t\t}\n\n\n\t\treturn str.toString() ;\n\t}\n\n\t/** return number of chains , if NMR return number of chains of first model .\n\t *\n\t */\n\t@Override\n\tpublic int size() {\n\t\tint modelnr = 0 ;\n\n\t\tif (!models.isEmpty()) {\n\t\t\treturn models.get(modelnr).getPolyChains().size();\n\t\t}\n\t\telse {\n\t\t\treturn 0 ;\n\t\t}\n\n\t}\n\n\t/** return number of chains  of model.\n\t *\n\t */\n\t@Override\n\tpublic int size(int modelnr) { return models.get(modelnr).size(); }\n\n\t// some NMR stuff :\n\n\t/** return number of models. */\n\t@Override\n\tpublic int nrModels() {\n\t\treturn models.size() ;\n\t}\n\n\t/**\n\t * Whether this Structure is a crystallographic structure or not.\n\t * It will first check the experimental technique and if not present it will try\n\t * to guess from the presence of a space group and sensible cell parameters\n\t *\n\t * @return true if crystallographic, false otherwise\n\t */\n\t@Override\n\tpublic boolean isCrystallographic() {\n\t\tif (pdbHeader.getExperimentalTechniques()!=null) {\n\t\t\treturn ExperimentalTechnique.isCrystallographic(pdbHeader.getExperimentalTechniques());\n\t\t} else {\n\t\t\t// no experimental technique known, we try to guess...\n\t\t\tif (pdbHeader.getCrystallographicInfo().getSpaceGroup()!=null) {\n\t\t\t\t// space group defined but no crystal cell: incomplete info, return false\n\t\t\t\treturn  pdbHeader.getCrystallographicInfo().getCrystalCell() != null &&\n\t\t\t\t\t\tpdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Whether this Structure is a NMR structure or not.\n\t * It will first check the experimental technique and if not present it will try\n\t * to guess from the presence of more than 1 model and from b-factors being 0 in first chain of first model\n\t * @return true if NMR, false otherwise\n\t */\n\t@Override\n\tpublic boolean isNmr() {\n\n\t\t// old implementation was:\n\t\t//return nmrflag;\n\n\t\tif (pdbHeader.getExperimentalTechniques()!=null) {\n\t\t\treturn ExperimentalTechnique.isNmr(pdbHeader.getExperimentalTechniques());\n\t\t} else {\n\t\t\t// no experimental technique known, we try to guess...\n\t\t\tif (nrModels()>1) {\n\t\t\t\tif (pdbHeader.getCrystallographicInfo().getSpaceGroup()!=null) {\n\t\t\t\t\t// multimodel, sg defined, but missing cell: must be NMR\n\t\t\t\t\tif (pdbHeader.getCrystallographicInfo().getCrystalCell()==null)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t// multi-model, sg defined and cell unreasonable: must be NMR\n\t\t\t\t\tif (!pdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable())\n\t\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// multi-model and missing space group: must be NMR\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Chain> getChains(int modelIdx){\n\t\treturn getModel(modelIdx);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Chain> getChains(){\n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getChains(0);\n\n\t}\n\n\t@Override\n\tpublic List<Chain> getPolyChains() { \n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getPolyChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getPolyChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getPolyChains();\n\t}\n\n\t@Override\n\tpublic List<Chain> getNonPolyChains() { \n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn  getNonPolyChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getNonPolyChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getNonPolyChains();\n\t}\n\t\n\t@Override\n\tpublic List<Chain> getWaterChains() {\n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getWaterChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getWaterChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getWaterChains();\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setChains(int modelnr, List<Chain> chains){\n\t\tfor (Chain c: chains){\n\t\t\tc.setStructure(this);\n\t\t}\n\t\tif (models.size()>modelnr) {\n\t\t\tmodels.remove(modelnr);\n\t\t}\n\n\t\tModel model = new Model();\n\t\tmodel.setChains(chains);\n\t\tmodels.add(modelnr, model);\n\n\t}\n\n\t/** Retrieve all Chains belonging to a model .\n\t *\n\t * @param modelnr  an int\n\t * @return a List object\n\t */\n\t@Override\n\tpublic List<Chain> getModel(int modelnr) {\n\n\t\treturn models.get(modelnr).getChains();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChainByPDB(String authId, int modelnr)\n\t\t\tthrows StructureException{\n\n\t\tChain c = getPolyChainByPDB(authId, modelnr);\n\t\t\n\t\tif (c==null) {\n\t\t\tthrow new StructureException(\"Could not find chain with authId \\\"\" + authId + \"\\\"\" + \" for PDB id \" + pdb_id + \", model \"+modelnr);\t\t\t\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(String asymId, int modelnr) {\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\tif (c.getId().equals(asymId)) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(String asymId) {\n\n\t\treturn getChain(asymId,0);\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChainByPDB(String chainId)\n\t\t\tthrows StructureException{\n\t\treturn getChainByPDB(chainId,0);\n\t}\n\n\t@Override\n\tpublic Chain getPolyChain(String asymId) {\n\t\treturn getPolyChain(asymId, 0);\n\n\t}\n\t\n\t@Override\n\tpublic Chain getPolyChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> polyChains = model.getPolyChains();\n\t\tfor (Chain c : polyChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic Chain getNonPolyChain(String asymId) {\n\t\treturn getNonPolyChain(asymId, 0);\n\t}\n\t\n\t@Override\n\tpublic Chain getNonPolyChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tList<Chain> nonpolyChains = model.getNonPolyChains();\n\t\tfor (Chain c : nonpolyChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getPolyChainByPDB(String authId) {\n\t\treturn getPolyChainByPDB(authId, 0);\n\t}\n\n\t@Override\n\tpublic Chain getPolyChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> polyChains = model.getPolyChains();\n\t\tfor (Chain c : polyChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getNonPolyChainByPDB(String authId) {\n\t\treturn getNonPolyChainByPDB(authId, 0);\n\t}\n\t\n\t@Override\n\tpublic Chain getNonPolyChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> nonpolyChains = model.getNonPolyChains();\n\t\tfor (Chain c : nonpolyChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getWaterChain(String asymId) {\n\t\treturn getWaterChain(asymId, 0);\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> waterChains = model.getWaterChains();\n\t\tfor (Chain c : waterChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChainByPDB(String authId) {\n\t\treturn getWaterChainByPDB(authId, 0);\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> waterChains = model.getWaterChains();\n\t\tfor (Chain c : waterChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String toPDB() {\n\t\tFileConvert f = new FileConvert(this) ;\n\t\treturn f.toPDB();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String toMMCIF() {\n\t\tFileConvert f = new FileConvert(this);\n\t\treturn f.toMMCIF();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasChain(String authId) {\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getId().equals(authId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasNonPolyChain(String asymId){\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = models.get(modelnr).getNonPolyChains();\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getId().equals(asymId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasPdbChain(String authId) {\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getName().equals(authId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setEntityInfos(List<EntityInfo> molList){\n\t\tthis.entityInfos = molList;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addEntityInfo(EntityInfo entityInfo) {\n\t\tthis.entityInfos.add(entityInfo);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<EntityInfo> getEntityInfos() {\n\t\treturn entityInfos;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic EntityInfo getCompoundById(int molId) {\n\t\treturn getEntityById(molId);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic EntityInfo getEntityById(int entityId) {\n\t\tfor (EntityInfo mol : this.entityInfos){\n\t\t\tif (mol.getMolId()==entityId){\n\t\t\t\treturn mol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<DBRef> getDBRefs() {\n\t\treturn dbrefs;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setDBRefs(List<DBRef> dbrefs) {\n\t\tif ( dbrefs == null)\n\t\t\tthrow new IllegalArgumentException(\"trying to set dbrefs to null!\");\n\n\t\tfor( DBRef ref : dbrefs){\n\t\t\tref.setParent(this);\n\t\t}\n\t\tthis.dbrefs = dbrefs;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic PDBHeader getPDBHeader() {\n\t\treturn pdbHeader;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setPDBHeader(PDBHeader pdbHeader){\n\t\tthis.pdbHeader = pdbHeader;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Bond> getSSBonds(){\n\t\treturn ssbonds;\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setSSBonds(List<Bond> ssbonds){\n\t\tthis.ssbonds = ssbonds;\n\t}\n\n\t/**\n\t * Adds a single disulfide Bond to this structure\n\t *\n\t * @param ssbond the SSBond.\n\t */\n\t@Override\n\tpublic void addSSBond(Bond ssbond){\n\t\tssbonds.add(ssbond);\n\t}\n\n\t/**\n\t * Return whether or not the entry has an associated journal article\n\t * or publication. The JRNL section is not mandatory and thus may not be\n\t * present.\n\t * @return flag if a JournalArticle could be found.\n\t */\n\t@Override\n\tpublic boolean hasJournalArticle() {\n\t\treturn this.pdbHeader.hasJournalArticle();\n\t}\n\n\t/**\n\t * get the associated publication as defined by the JRNL records in a PDB\n\t * file.\n\t * @return a JournalArticle\n\t */\n\t@Override\n\tpublic JournalArticle getJournalArticle() {\n\t\treturn this.pdbHeader.getJournalArticle();\n\t}\n\n\t/**\n\t * set the associated publication as defined by the JRNL records in a PDB\n\t * file.\n\t * @param journalArticle the article\n\t */\n\t@Override\n\tpublic void setJournalArticle(JournalArticle journalArticle) {\n\t\tthis.pdbHeader.setJournalArticle(journalArticle);\n\t}\n\n\t/**\n\t * @return the sites contained in this structure\n\t */\n\n\t@Override\n\tpublic List<Site> getSites() {\n\t\treturn sites;\n\t}\n\n\t/**\n\t * @param sites the sites to set in the structure\n\t */\n\n\t@Override\n\tpublic void setSites(List<Site> sites) {\n\t\tthis.sites = sites;\n\t}\n\n\t/** Caution: we should probably remove this to avoid confusion. Currently this is always an empty list!\n\t *\n\t * @return a list of Groups listed in the HET records - this will not\n\t * include any waters.\n\t */\n\n\t/**\n\t * Sets a flag to indicate if this structure is a biological assembly\n\t * @param biologicalAssembly true if biological assembly, otherwise false\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic void setBiologicalAssembly(boolean biologicalAssembly) {\n\t\tthis.biologicalAssembly = biologicalAssembly;\n\t}\n\n\t/**\n\t * Gets flag that indicates if this structure is a biological assembly\n\t * @return the sites contained in this structure\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic boolean isBiologicalAssembly() {\n\t\treturn biologicalAssembly;\n\t}\n\n\t/**\n\t * Sets crystallographic information for this structure\n\t * @param crystallographicInfo crystallographic information\n\t * @since 3.2\n\t */\n\n\t@Override\n\tpublic void setCrystallographicInfo(PDBCrystallographicInfo crystallographicInfo) {\n\t\tthis.pdbHeader.setCrystallographicInfo(crystallographicInfo);\n\t}\n\n\t/**\n\t * Gets crystallographic information for this structure\n\t * @return PDBCrystallographicInfo crystallographic information\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic PDBCrystallographicInfo getCrystallographicInfo() {\n\t\treturn pdbHeader.getCrystallographicInfo();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String getIdentifier() {\n\t\t//1. StructureIdentifier\n\t\tif(getStructureIdentifier() != null) {\n\t\t\treturn getStructureIdentifier().getIdentifier();\n\t\t}\n\t\t//2. Name\n\t\tif(getName() != null) {\n\t\t\treturn getName();\n\t\t}\n\t\t//3. PDBCode + ranges\n\t\treturn toCanonical().getIdentifier();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic String getPdbId() {\n\t\treturn pdb_id;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void resetModels() {\n\t\tmodels = new ArrayList<Model>();\n\t}\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic List<ResidueRange> getResidueRanges() {\n\t\treturn toCanonical().getResidueRanges();\n\t}\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic List<String> getRanges() {\n\t\treturn ResidueRange.toStrings(getResidueRanges());\n\t}\n\n\t/**\n\t * Creates a SubstructureIdentifier based on the residues in this Structure.\n\t *\n\t * Only the first and last residues of each chain are considered, so chains\n\t * with gaps\n\t * @return A {@link SubstructureIdentifier} with residue ranges constructed from each chain\n\t */\n\tprivate SubstructureIdentifier toCanonical() {\n\t\tStructureIdentifier real = getStructureIdentifier();\n\t\tif(real != null) {\n\t\t\ttry {\n\t\t\t\treturn real.toCanonical();\n\t\t\t} catch (StructureException e) {\n\t\t\t\t// generate fake one if needed\n\t\t\t}\n\t\t}\n\n\t\t// No identifier set, so generate based on residues present in the structure\n\t\tList<ResidueRange> range = new ArrayList<ResidueRange>();\n\t\tfor (Chain chain : getChains()) {\n\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\tListIterator<Group> groupsIt = groups.listIterator();\n\t\t\tif(!groupsIt.hasNext()) {\n\t\t\t\tcontinue; // no groups in chain\n\t\t\t}\n\t\t\tGroup g = groupsIt.next();\n\t\t\tResidueNumber first = g.getResidueNumber();\n\n\t\t\t//TODO Detect missing intermediate residues -sbliven, 2015-01-28\n\t\t\t//Already better than previous whole-chain representation\n\n\t\t\t// get last residue\n\t\t\twhile(groupsIt.hasNext()) {\n\t\t\t\tg = groupsIt.next();\n\t\t\t}\n\t\t\tResidueNumber last = g.getResidueNumber();\n\n\t\t\trange.add(new ResidueRange(chain.getName(),first,last));\n\t\t}\n\t\treturn new SubstructureIdentifier(getPDBCode(),range);\n\t}\n\n\n\n\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 26.04.2004\n * @author Andreas Prlic\n *\n */\npackage org.biojava.nbio.structure;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.biojava.nbio.structure.io.FileConvert;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Implementation of a PDB Structure. This class\n * provides the data contained in a PDB file.\n * to get structure objects from different sources\n * see io package.\n *\n * @author Andreas Prlic\n * @author Jules Jacobsen\n * @since 1.4\n * @version %I% %G%\n */\npublic class StructureImpl implements Structure, Serializable {\n\n\tprivate static final long serialVersionUID = -8344837138032851348L;\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(StructureImpl.class);\n\n\tprivate String pdb_id ;\n\n\tprivate List<Model> models;\n\n\tprivate List<EntityInfo> entityInfos;\n\tprivate List<DBRef> dbrefs;\n\tprivate List<Bond> ssbonds;\n\tprivate List<Site> sites;\n\tprivate String name ;\n\tprivate StructureIdentifier structureIdentifier;\n\n\tprivate PDBHeader pdbHeader;\n\n\tprivate Long id;\n\tprivate boolean biologicalAssembly;\n\n\t/**\n\t *  Constructs a StructureImpl object.\n\t */\n\tpublic StructureImpl() {\n\t\tsuper();\n\n\t\tmodels         = new ArrayList<>();\n\t\tname           = \"\";\n\t\tentityInfos      = new ArrayList<>();\n\t\tdbrefs         = new ArrayList<>();\n\t\tpdbHeader      = new PDBHeader();\n\t\tssbonds        = new ArrayList<>();\n\t\tsites          = new ArrayList<>();\n\t}\n\n\n\t/** get the ID used by Hibernate\n\t *\n\t * @return the ID used by Hibernate\n\t */\n\t@Override\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\n\t/** set the ID used by Hibernate\n\t *\n\t * @param id the hibernate ID\n\t */\n\t@Override\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\n\n\n\t/** Construct a Structure object that only contains a single group\n\t *\n\t * @param g group object\n\t */\n\tpublic StructureImpl(Group g){\n\t\tthis();\n\n\t\tChain c = new ChainImpl();\n\t\tc.addGroup(g);\n\n\t\taddChain(c);\n\t}\n\n\t/** construct a Structure object that contains a particular chain\n\t *\n\t * @param c chain\n\t */\n\tpublic StructureImpl(Chain c){\n\t\tthis();\n\t\taddChain(c);\n\t}\n\n\t/** returns an identical copy of this structure .\n\t * @return an identical Structure object\n\t */\n\t@Override\n\tpublic Structure clone() {\n\t\t// Note: structures are also cloned in SubstructureIdentifier.reduce().\n\t\t// Changes might need to be made there as well\n\n\t\tStructure n = new StructureImpl();\n\t\t// go through whole substructure and clone ...\n\n\t\t// copy structure data\n\n\t\tn.setPDBCode(getPDBCode());\n\t\tn.setName(getName());\n\t\t//TODO the header data is not being deep-copied, that's a minor issue since it is just some static metadata, but we should recheck this if needed - JD 2014-12-11\n\t\tn.setPDBHeader(pdbHeader);\n\t\tn.setDBRefs(this.getDBRefs());\n\t\tn.setSites(getSites());\n\n\n\t\t// go through each chain and clone chain\n\t\tfor (int i=0;i<nrModels();i++){\n\t\t\tList<Chain> cloned_model = new ArrayList<Chain>();\n\n\t\t\tfor (int j=0;j<size(i);j++){\n\n\t\t\t\tChain cloned_chain  = (Chain) getChain(i,j).clone();\n\n\t\t\t\t// setting the parent: can only be done from the parent\n\t\t\t\tcloned_chain.setStructure(n);\n\n\t\t\t\tcloned_model.add(cloned_chain);\n\n\t\t\t}\n\t\t\tn.addModel(cloned_model);\n\n\t\t}\n\n\t\t// deep-copying of entityInfofos is tricky: there's cross references also in the Chains\n\t\t// beware: if we copy the entityInfos we would also need to reset the references to entityInfos in the individual chains\n\t\tList<EntityInfo> newEntityInfoList = new ArrayList<EntityInfo>();\n\t\tfor (EntityInfo entityInfo : this.entityInfos) {\n\t\t\tEntityInfo newEntityInfo = new EntityInfo(entityInfo); // this sets everything but the chains\n\t\t\tfor (String asymId:entityInfo.getChainIds()) {\n\n\t\t\t\tfor (int modelNr=0;modelNr<n.nrModels();modelNr++) {\n\t\t\t\t\tChain newChain = n.getChain(asymId,modelNr);\n\t\t\t\t\tif (newChain==null) {\n\t\t\t\t\t\t// this actually happens for structure 1msh, which has no chain B for model 29 (clearly a deposition error)\n\t\t\t\t\t\tlogger.warn(\"Could not find chain asymId \"+asymId+\" of model \"+modelNr+\" while cloning entityInfo \"+entityInfo.getMolId()+\". Something is wrong!\");\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnewChain.setEntityInfo(newEntityInfo);\n\t\t\t\t\tnewEntityInfo.addChain(newChain);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewEntityInfoList.add(newEntityInfo);\n\t\t}\n\t\tn.setEntityInfos(newEntityInfoList);\n\t\t// TODO ssbonds are complicated to clone: there are deep references inside Atom objects, how would we do it? - JD 2016-03-03\n\n\t\treturn n ;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Group findGroup(String chainName, String pdbResnum, int modelnr)\n\t\t\tthrows StructureException {\n\n\n\t\t// if structure is xray there will be only one \"model\".\n\t\tif ( modelnr > models.size())\n\t\t\tthrow new StructureException(\" no model nr \" + modelnr +\n\t\t\t\t\t\" in this structure. (contains \"+models.size()+\")\");\n\n\n\t\t// first we need to gather all groups with the author id chainName: polymers, non-polymers and waters\n\t\tChain polyChain = getPolyChainByPDB(chainName, modelnr);\n\t\tList<Group> groups = new ArrayList<>();\n\t\tgroups.addAll(polyChain.getAtomGroups());\n\n\t\t// there can be more thatn one non-poly chain for a given author id\n\t\tfor (Chain chain: getNonPolyChains(modelnr)) {\n\t\t\tif (chain.getName().equals(chainName))\n\t\t\t\tgroups.addAll(chain.getAtomGroups());\n\t\t}\n\t\tfor (Chain chain: getWaterChains(modelnr)) {\n\t\t\tif (chain.getName().equals(chainName))\n\t\t\t\tgroups.addAll(chain.getAtomGroups());\n\t\t}\n\n\n\t\t// now iterate over all groups \n\t\t// in order to find the amino acid that has this pdbRenum.\n\n\t\tfor (Group g : groups) {\n\t\t\tString rnum = g.getResidueNumber().toString();\n\t\t\t//System.out.println(g + \" >\" + rnum + \"< >\" + pdbResnum + \"<\");\n\t\t\t// we only mutate amino acids\n\t\t\t// and ignore hetatoms and nucleotides in this case\n\t\t\tif (rnum.equals(pdbResnum)) {\n\t\t\t\treturn g;\n\t\t\t}\n\t\t}\n\n\t\tthrow new StructureException(\"could not find group \" + pdbResnum +\n\t\t\t\t\" in chain \" + chainName);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Group findGroup(String chainName, String pdbResnum) throws StructureException\n\t{\n\t\treturn findGroup(chainName, pdbResnum, 0);\n\n\t}\n\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain findChain(String chainName, int modelnr) throws StructureException {\n\n\t\treturn getChainByPDB(chainName, modelnr);\n\t\t\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain findChain(String chainId) throws StructureException {\n\n\t\treturn findChain(chainId,0);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setPDBCode (String pdb_id_) {\n\t\tpdb_id = pdb_id_ ;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String  getPDBCode () {\n\t\treturn pdb_id ;\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void   setName(String nam) { name = nam; }\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String getName()           { return name;  }\n\n\n\n\t/**\n\t * @return The StructureIdentifier used to create this structure\n\t */\n\t@Override\n\tpublic StructureIdentifier getStructureIdentifier() {\n\t\treturn structureIdentifier;\n\t}\n\n\t/**\n\t * @param structureIdentifier the structureIdentifier corresponding to this structure\n\t */\n\t@Override\n\tpublic void setStructureIdentifier(StructureIdentifier structureIdentifier) {\n\t\tthis.structureIdentifier = structureIdentifier;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addChain(Chain chain) {\n\t\tint modelnr = 0 ;\n\t\taddChain(chain,modelnr);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addChain(Chain chain, int modelnr) {\n\t\t// if model has not been initialized, init it!\n\t\tchain.setStructure(this);\n\t\tif (models.isEmpty()) {\n\t\t\tModel model = new Model();\n\t\t\tList<Chain> modelChains = new ArrayList<Chain>() ;\n\t\t\tmodelChains.add(chain);\n\t\t\tmodel.setChains(modelChains);\n\t\t\tmodels.add(model);\n\n\t\t} else {\n\t\t\tModel model = models.get(modelnr);\n\t\t\tmodel.addChain(chain);\n\t\t}\n\n\n\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(int number) {\n\n\t\tint modelnr = 0 ;\n\n\t\treturn getChain(modelnr,number);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(int modelnr,int number) {\n\n\t\tModel model = models.get(modelnr);\n\n\t\treturn model.getChains().get(number);\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addModel(List<Chain> modelChains){\n\t\tfor (Chain c: modelChains){\n\t\t\tc.setStructure(this);\n\t\t}\n\t\tModel model = new Model();\n\t\tmodel.setChains(modelChains);\n\t\tmodels.add(model);\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setChains(List<Chain> chains){\n\n\t\tsetModel(0,chains);\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setModel(int position, List<Chain> modelChains){\n\t\tif (modelChains == null)\n\t\t\tthrow new IllegalArgumentException(\"trying to set model to null!\");\n\n\t\tfor (Chain c: modelChains)\n\t\t\tc.setStructure(this);\n\n\t\t//System.out.println(\"model size:\" + models.size());\n\n\n\t\tModel model = new Model();\n\t\tmodel.setChains(modelChains);\n\n\t\tif (models.isEmpty()){\n\t\t\tmodels.add(model);\n\t\t} else {\n\t\t\tmodels.set(position, model);\n\t\t}\n\t}\n\n\t/** String representation.\n\t *\n\t */\n\t@Override\n\tpublic String toString(){\n\t\tString newline = System.getProperty(\"line.separator\");\n\t\tStringBuilder str = new StringBuilder();\n\t\tstr.append(\"structure \");\n\t\tstr.append(name);\n\t\tstr.append(\" \");\n\t\tstr.append(pdb_id);\n\t\tstr.append(\" \");\n\n\t\tif ( nrModels()>1 ){\n\t\t\tstr.append( \" models: \");\n\t\t\tstr.append(nrModels());\n\t\t\tstr.append(newline) ;\n\t\t}\n\n\t\tstr.append(pdbHeader);\n\t\tstr.append(newline) ;\n\n\t\tfor (int i=0;i<nrModels();i++){\n\t\t\tif ( nrModels()>1 ) {\n\t\t\t\tstr.append(\" model[\");\n\t\t\t\tstr.append(i);\n\t\t\t\tstr.append(\"]:\");\n\t\t\t\tstr.append(newline);\n\t\t\t}\n\t\t\tstr.append(\" chains:\");\n\t\t\tstr.append(newline);\n\n\t\t\tfor (int j=0;j<size(i);j++){\n\n\t\t\t\tChain cha = getChain(i,j);\n\t\t\t\tList<Group> agr = cha.getAtomGroups(GroupType.AMINOACID);\n\t\t\t\tList<Group> hgr = cha.getAtomGroups(GroupType.HETATM);\n\t\t\t\tList<Group> ngr = cha.getAtomGroups(GroupType.NUCLEOTIDE);\n\n\n\n\n\t\t\t\tstr.append(\"chain \")\n\t\t\t\t\t\t.append(j).append(\": asymId:\")\n\t\t\t\t\t\t.append(cha.getId())\n\t\t\t\t\t\t.append(\" authId:\")\n\t\t\t\t\t\t.append(cha.getName()).append(\" \");\n\n\n\t\t\t\tif ( cha.getEntityInfo() != null){\n\t\t\t\t\tEntityInfo comp = cha.getEntityInfo();\n\t\t\t\t\tString molName = comp.getDescription();\n\t\t\t\t\tif ( molName != null){\n\t\t\t\t\t\tstr.append(molName);\n\t\t\t\t\t}\n\t\t\t\t\tString type =  comp.getType().toString();\n\t\t\t\t\tstr.append(\" (\")\n\t\t\t\t\t\t\t.append(type)\n\t\t\t\t\t\t\t.append(\")\");\n\t\t\t\t}\n\n\n\t\t\t\tstr.append(newline);\n\t\t\t\tstr.append(\" length SEQRES: \").append(cha.getSeqResLength());\n\t\t\t\tstr.append(\" length ATOM: \").append(cha.getAtomLength());\n\t\t\t\tstr.append(\" aminos: \").append(agr.size());\n\t\t\t\tstr.append(\" hetatms: \").append(hgr.size());\n\t\t\t\tstr.append(\" nucleotides: \").append(ngr.size()).append(newline);\n\t\t\t}\n\n\t\t}\n\t\tstr.append(\"DBRefs: \").append(dbrefs.size()).append(newline);\n\t\tfor (DBRef dbref: dbrefs){\n\t\t\tstr.append(dbref.toPDB()).append(newline);\n\t\t}\n\t\tstr.append(\"Molecules: \").append(newline);\n\t\tfor (EntityInfo mol : entityInfos) {\n\t\t\tstr.append(mol).append(newline);\n\t\t}\n\n\n\t\treturn str.toString() ;\n\t}\n\n\t/** return number of chains , if NMR return number of chains of first model .\n\t *\n\t */\n\t@Override\n\tpublic int size() {\n\t\tint modelnr = 0 ;\n\n\t\tif (!models.isEmpty()) {\n\t\t\treturn models.get(modelnr).getPolyChains().size();\n\t\t}\n\t\telse {\n\t\t\treturn 0 ;\n\t\t}\n\n\t}\n\n\t/** return number of chains  of model.\n\t *\n\t */\n\t@Override\n\tpublic int size(int modelnr) { return models.get(modelnr).size(); }\n\n\t// some NMR stuff :\n\n\t/** return number of models. */\n\t@Override\n\tpublic int nrModels() {\n\t\treturn models.size() ;\n\t}\n\n\t/**\n\t * Whether this Structure is a crystallographic structure or not.\n\t * It will first check the experimental technique and if not present it will try\n\t * to guess from the presence of a space group and sensible cell parameters\n\t *\n\t * @return true if crystallographic, false otherwise\n\t */\n\t@Override\n\tpublic boolean isCrystallographic() {\n\t\tif (pdbHeader.getExperimentalTechniques()!=null) {\n\t\t\treturn ExperimentalTechnique.isCrystallographic(pdbHeader.getExperimentalTechniques());\n\t\t} else {\n\t\t\t// no experimental technique known, we try to guess...\n\t\t\tif (pdbHeader.getCrystallographicInfo().getSpaceGroup()!=null) {\n\t\t\t\t// space group defined but no crystal cell: incomplete info, return false\n\t\t\t\treturn  pdbHeader.getCrystallographicInfo().getCrystalCell() != null &&\n\t\t\t\t\t\tpdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable();\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Whether this Structure is a NMR structure or not.\n\t * It will first check the experimental technique and if not present it will try\n\t * to guess from the presence of more than 1 model and from b-factors being 0 in first chain of first model\n\t * @return true if NMR, false otherwise\n\t */\n\t@Override\n\tpublic boolean isNmr() {\n\n\t\t// old implementation was:\n\t\t//return nmrflag;\n\n\t\tif (pdbHeader.getExperimentalTechniques()!=null) {\n\t\t\treturn ExperimentalTechnique.isNmr(pdbHeader.getExperimentalTechniques());\n\t\t} else {\n\t\t\t// no experimental technique known, we try to guess...\n\t\t\tif (nrModels()>1) {\n\t\t\t\tif (pdbHeader.getCrystallographicInfo().getSpaceGroup()!=null) {\n\t\t\t\t\t// multimodel, sg defined, but missing cell: must be NMR\n\t\t\t\t\tif (pdbHeader.getCrystallographicInfo().getCrystalCell()==null)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t// multi-model, sg defined and cell unreasonable: must be NMR\n\t\t\t\t\tif (!pdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable())\n\t\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\t// multi-model and missing space group: must be NMR\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Chain> getChains(int modelIdx){\n\t\treturn getModel(modelIdx);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Chain> getChains(){\n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getChains(0);\n\n\t}\n\n\t@Override\n\tpublic List<Chain> getPolyChains() { \n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getPolyChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getPolyChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getPolyChains();\n\t}\n\n\t@Override\n\tpublic List<Chain> getNonPolyChains() { \n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn  getNonPolyChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getNonPolyChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getNonPolyChains();\n\t}\n\t\n\t@Override\n\tpublic List<Chain> getWaterChains() {\n\t\tif (models.size()==0) {\n\t\t\treturn new ArrayList<>(0);\n\t\t}\n\t\treturn getWaterChains(0);\n\t}\n\n\t@Override\n\tpublic List<Chain> getWaterChains(int modelIdx) {\n\t\treturn models.get(modelIdx).getWaterChains();\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setChains(int modelnr, List<Chain> chains){\n\t\tfor (Chain c: chains){\n\t\t\tc.setStructure(this);\n\t\t}\n\t\tif (models.size()>modelnr) {\n\t\t\tmodels.remove(modelnr);\n\t\t}\n\n\t\tModel model = new Model();\n\t\tmodel.setChains(chains);\n\t\tmodels.add(modelnr, model);\n\n\t}\n\n\t/** Retrieve all Chains belonging to a model .\n\t *\n\t * @param modelnr  an int\n\t * @return a List object\n\t */\n\t@Override\n\tpublic List<Chain> getModel(int modelnr) {\n\n\t\treturn models.get(modelnr).getChains();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChainByPDB(String authId, int modelnr)\n\t\t\tthrows StructureException{\n\n\t\tChain c = getPolyChainByPDB(authId, modelnr);\n\t\t\n\t\tif (c==null) {\n\t\t\tthrow new StructureException(\"Could not find chain with authId \\\"\" + authId + \"\\\"\" + \" for PDB id \" + pdb_id + \", model \"+modelnr);\t\t\t\n\t\t}\n\t\t\n\t\treturn c;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(String asymId, int modelnr) {\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\tif (c.getId().equals(asymId)) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChain(String asymId) {\n\n\t\treturn getChain(asymId,0);\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic Chain getChainByPDB(String chainId)\n\t\t\tthrows StructureException{\n\t\treturn getChainByPDB(chainId,0);\n\t}\n\n\t@Override\n\tpublic Chain getPolyChain(String asymId) {\n\t\treturn getPolyChain(asymId, 0);\n\n\t}\n\t\n\t@Override\n\tpublic Chain getPolyChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> polyChains = model.getPolyChains();\n\t\tfor (Chain c : polyChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic Chain getNonPolyChain(String asymId) {\n\t\treturn getNonPolyChain(asymId, 0);\n\t}\n\t\n\t@Override\n\tpublic Chain getNonPolyChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tList<Chain> nonpolyChains = model.getNonPolyChains();\n\t\tfor (Chain c : nonpolyChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getPolyChainByPDB(String authId) {\n\t\treturn getPolyChainByPDB(authId, 0);\n\t}\n\n\t@Override\n\tpublic Chain getPolyChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> polyChains = model.getPolyChains();\n\t\tfor (Chain c : polyChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getNonPolyChainByPDB(String authId) {\n\t\treturn getNonPolyChainByPDB(authId, 0);\n\t}\n\t\n\t@Override\n\tpublic Chain getNonPolyChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> nonpolyChains = model.getNonPolyChains();\n\t\tfor (Chain c : nonpolyChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Chain getWaterChain(String asymId) {\n\t\treturn getWaterChain(asymId, 0);\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChain(String asymId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> waterChains = model.getWaterChains();\n\t\tfor (Chain c : waterChains){\n\t\t\tif (c.getId().equals(asymId))\n\t\t\t\treturn c;\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChainByPDB(String authId) {\n\t\treturn getWaterChainByPDB(authId, 0);\n\t}\n\n\n\t@Override\n\tpublic Chain getWaterChainByPDB(String authId, int modelIdx) {\n\t\tModel model = models.get(modelIdx);\n\t\tif (model==null) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Chain> waterChains = model.getWaterChains();\n\t\tfor (Chain c : waterChains){\n\t\t\tif (c.getName().equals(authId))\n\t\t\t\treturn c;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String toPDB() {\n\t\tFileConvert f = new FileConvert(this) ;\n\t\treturn f.toPDB();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String toMMCIF() {\n\t\tFileConvert f = new FileConvert(this);\n\t\treturn f.toMMCIF();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasChain(String authId) {\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getId().equals(authId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasNonPolyChain(String asymId){\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = models.get(modelnr).getNonPolyChains();\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getId().equals(asymId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic boolean hasPdbChain(String authId) {\n\t\tint modelnr = 0;\n\n\t\tList<Chain> chains = getChains(modelnr);\n\t\tfor (Chain c : chains) {\n\t\t\t// we check here with equals because we might want to distinguish between upper and lower case chains!\n\t\t\tif (c.getName().equals(authId)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setEntityInfos(List<EntityInfo> molList){\n\t\tthis.entityInfos = molList;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void addEntityInfo(EntityInfo entityInfo) {\n\t\tthis.entityInfos.add(entityInfo);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<EntityInfo> getEntityInfos() {\n\t\treturn entityInfos;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic EntityInfo getCompoundById(int molId) {\n\t\treturn getEntityById(molId);\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic EntityInfo getEntityById(int entityId) {\n\t\tfor (EntityInfo mol : this.entityInfos){\n\t\t\tif (mol.getMolId()==entityId){\n\t\t\t\treturn mol;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<DBRef> getDBRefs() {\n\t\treturn dbrefs;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setDBRefs(List<DBRef> dbrefs) {\n\t\tif ( dbrefs == null)\n\t\t\tthrow new IllegalArgumentException(\"trying to set dbrefs to null!\");\n\n\t\tfor( DBRef ref : dbrefs){\n\t\t\tref.setParent(this);\n\t\t}\n\t\tthis.dbrefs = dbrefs;\n\t}\n\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic PDBHeader getPDBHeader() {\n\t\treturn pdbHeader;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setPDBHeader(PDBHeader pdbHeader){\n\t\tthis.pdbHeader = pdbHeader;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic List<Bond> getSSBonds(){\n\t\treturn ssbonds;\n\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void setSSBonds(List<Bond> ssbonds){\n\t\tthis.ssbonds = ssbonds;\n\t}\n\n\t/**\n\t * Adds a single disulfide Bond to this structure\n\t *\n\t * @param ssbond the SSBond.\n\t */\n\t@Override\n\tpublic void addSSBond(Bond ssbond){\n\t\tssbonds.add(ssbond);\n\t}\n\n\t/**\n\t * Return whether or not the entry has an associated journal article\n\t * or publication. The JRNL section is not mandatory and thus may not be\n\t * present.\n\t * @return flag if a JournalArticle could be found.\n\t */\n\t@Override\n\tpublic boolean hasJournalArticle() {\n\t\treturn this.pdbHeader.hasJournalArticle();\n\t}\n\n\t/**\n\t * get the associated publication as defined by the JRNL records in a PDB\n\t * file.\n\t * @return a JournalArticle\n\t */\n\t@Override\n\tpublic JournalArticle getJournalArticle() {\n\t\treturn this.pdbHeader.getJournalArticle();\n\t}\n\n\t/**\n\t * set the associated publication as defined by the JRNL records in a PDB\n\t * file.\n\t * @param journalArticle the article\n\t */\n\t@Override\n\tpublic void setJournalArticle(JournalArticle journalArticle) {\n\t\tthis.pdbHeader.setJournalArticle(journalArticle);\n\t}\n\n\t/**\n\t * @return the sites contained in this structure\n\t */\n\n\t@Override\n\tpublic List<Site> getSites() {\n\t\treturn sites;\n\t}\n\n\t/**\n\t * @param sites the sites to set in the structure\n\t */\n\n\t@Override\n\tpublic void setSites(List<Site> sites) {\n\t\tthis.sites = sites;\n\t}\n\n\t/** Caution: we should probably remove this to avoid confusion. Currently this is always an empty list!\n\t *\n\t * @return a list of Groups listed in the HET records - this will not\n\t * include any waters.\n\t */\n\n\t/**\n\t * Sets a flag to indicate if this structure is a biological assembly\n\t * @param biologicalAssembly true if biological assembly, otherwise false\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic void setBiologicalAssembly(boolean biologicalAssembly) {\n\t\tthis.biologicalAssembly = biologicalAssembly;\n\t}\n\n\t/**\n\t * Gets flag that indicates if this structure is a biological assembly\n\t * @return the sites contained in this structure\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic boolean isBiologicalAssembly() {\n\t\treturn biologicalAssembly;\n\t}\n\n\t/**\n\t * Sets crystallographic information for this structure\n\t * @param crystallographicInfo crystallographic information\n\t * @since 3.2\n\t */\n\n\t@Override\n\tpublic void setCrystallographicInfo(PDBCrystallographicInfo crystallographicInfo) {\n\t\tthis.pdbHeader.setCrystallographicInfo(crystallographicInfo);\n\t}\n\n\t/**\n\t * Gets crystallographic information for this structure\n\t * @return PDBCrystallographicInfo crystallographic information\n\t * @since 3.2\n\t */\n\t@Override\n\tpublic PDBCrystallographicInfo getCrystallographicInfo() {\n\t\treturn pdbHeader.getCrystallographicInfo();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic String getIdentifier() {\n\t\t//1. StructureIdentifier\n\t\tif(getStructureIdentifier() != null) {\n\t\t\treturn getStructureIdentifier().getIdentifier();\n\t\t}\n\t\t//2. Name\n\t\tif(getName() != null) {\n\t\t\treturn getName();\n\t\t}\n\t\t//3. PDBCode + ranges\n\t\treturn toCanonical().getIdentifier();\n\t}\n\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic String getPdbId() {\n\t\treturn pdb_id;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic void resetModels() {\n\t\tmodels = new ArrayList<Model>();\n\t}\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic List<ResidueRange> getResidueRanges() {\n\t\treturn toCanonical().getResidueRanges();\n\t}\n\t/** {@inheritDoc} */\n\t@Deprecated\n\t@Override\n\tpublic List<String> getRanges() {\n\t\treturn ResidueRange.toStrings(getResidueRanges());\n\t}\n\n\t/**\n\t * Creates a SubstructureIdentifier based on the residues in this Structure.\n\t *\n\t * Only the first and last residues of each chain are considered, so chains\n\t * with gaps\n\t * @return A {@link SubstructureIdentifier} with residue ranges constructed from each chain\n\t */\n\tprivate SubstructureIdentifier toCanonical() {\n\t\tStructureIdentifier real = getStructureIdentifier();\n\t\tif(real != null) {\n\t\t\ttry {\n\t\t\t\treturn real.toCanonical();\n\t\t\t} catch (StructureException e) {\n\t\t\t\t// generate fake one if needed\n\t\t\t}\n\t\t}\n\n\t\t// No identifier set, so generate based on residues present in the structure\n\t\tList<ResidueRange> range = new ArrayList<ResidueRange>();\n\t\tfor (Chain chain : getChains()) {\n\t\t\tList<Group> groups = chain.getAtomGroups();\n\t\t\tListIterator<Group> groupsIt = groups.listIterator();\n\t\t\tif(!groupsIt.hasNext()) {\n\t\t\t\tcontinue; // no groups in chain\n\t\t\t}\n\t\t\tGroup g = groupsIt.next();\n\t\t\tResidueNumber first = g.getResidueNumber();\n\n\t\t\t//TODO Detect missing intermediate residues -sbliven, 2015-01-28\n\t\t\t//Already better than previous whole-chain representation\n\n\t\t\t// get last residue\n\t\t\twhile(groupsIt.hasNext()) {\n\t\t\t\tg = groupsIt.next();\n\t\t\t}\n\t\t\tResidueNumber last = g.getResidueNumber();\n\n\t\t\trange.add(new ResidueRange(chain.getName(),first,last));\n\t\t}\n\t\treturn new SubstructureIdentifier(getPDBCode(),range);\n\t}\n\n\n\n\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.nbio.structure;\n\nimport static org.junit.Assert.*;\n\nimport java.util.ArrayList;\n\nimport org.junit.Test;\n\n/**\n * This tests the correctness of the {@link Structure} data structure, in terms\n * of correct implementation, given the expected behavior, of the methods.\n *\n * @author Aleix Lafita\n * @since 4.2.0\n *\n */\npublic class TestStructureImpl {\n\n\t/**\n\t * This tests the correctness of the Links between the different objects\n\t * that create a Structure (Chains, Groups, Atoms). The correct behavior is\n\t * that objects higher in the hierarchy should set the links of lower level\n\t * objects.\n\t */\n\t@Test\n\tpublic void testLinks() {\n\n\t\t// Create new Structure and assign one Chain to it\n\t\tStructure s1 = new StructureImpl();\n\t\ts1.addModel(new ArrayList<Chain>(1));\n\n\t\tChain c1 = new ChainImpl();\n\t\ts1.addChain(c1);\n\n\t\t// Test that chains parent is s1\n\t\tassertEquals(s1, c1.getStructure());\n\n\t\t// Populate the Chain with one Group\n\t\tGroup g1 = new HetatomImpl();\n\t\tc1.addGroup(g1);\n\n\t\t// Test that the group parent is c1\n\t\tassertEquals(c1, g1.getChain());\n\n\t\t// Add a single Atom to the Group\n\t\tAtom a1 = new AtomImpl();\n\t\tg1.addAtom(a1);\n\n\t\t// Test that the atom parent is g1\n\t\tassertEquals(c1, g1.getChain());\n\n\t\t// Now clone the Atom and assign it to a second structure\n\t\tAtom a2 = (Atom) a1.clone();\n\n\t\tStructure s2 = new StructureImpl();\n\t\ts2.addModel(new ArrayList<Chain>(1));\n\t\tChain c2 = new ChainImpl();\n\t\ts2.addChain(c2);\n\t\tGroup g2 = new HetatomImpl();\n\t\tc2.addGroup(g2);\n\t\tg2.addAtom(a2);\n\n\t\t// Test correct parent links in Atoms\n\t\tassertEquals(g1, a1.getGroup());\n\t\tassertEquals(g2, a2.getGroup());\n\n\t\t// Now clone the Group and assign it to new third structure\n\t\tGroup g3 = (Group) g1.clone();\n\t\tAtom a3 = g3.getAtom(0);\n\t\tStructure s3 = new StructureImpl();\n\t\ts3.addModel(new ArrayList<Chain>(1));\n\t\tChain c3 = new ChainImpl();\n\t\ts3.addChain(c3);\n\t\tc3.addGroup(g3);\n\n\t\t// Test correct parent links in Groups and Atoms\n\t\tassertEquals(c1, g1.getChain());\n\t\tassertEquals(g1, a1.getGroup());\n\t\tassertEquals(c3, g3.getChain());\n\t\tassertEquals(g3, a3.getGroup());\n\n\t}\n}\n","changedTest":"","commitMessage":"Important bug fixes and docs in Structure/StructureImpl. \n\nFixed also pdb writing. Fixed some tests in integration tests, removed\nsome warnings.","test_commitMessage":"","allZero":false}