{"repository":"biojava","prod_path":"core/src/main/java/org/biojava/bio/seq/io/MSFAlignmentFormat.java","test_path":"core/src/test/java/org/biojava/bio/seq/io/MSFAlignmentFormatTest.java","prod_time":"2010-03-25 14:10:57","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":35,"add_classname_line":1,"add_condition_line":18,"add_field_line":0,"add_import_line":1,"add_packageid_line":0,"add_parameter_line":3,"add_return_line":0,"del_annotation_line":0,"del_call_line":21,"del_classname_line":2,"del_condition_line":19,"del_field_line":0,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":3,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"fcfff41a3d56d284b2531db7a9b1251ca88b53f8","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\n\npackage  org.biojava.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.alignment.SimpleAlignment;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\n\n/**\n * @author raemig\n * @author Thomas Down\n * @author Keith James\n * @author Nimesh Singh\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @author Bradford Powell\n */\n\npublic class MSFAlignmentFormat\n       implements AlignmentFormat {\n    private static final boolean DEBUGPRINT = false;\n    private static final int DNA = 1;\n    private static final int PROTEIN = 2;\n\n\n    public MSFAlignmentFormat () {\n    }\n\n    /**\n     * used to quick test the code\n     * @param args\n     */\n    public static void main (String[] args) {\n        String filename;\n        if (args.length < 1) {\n            filename = \"SimpleMSF.msf\";         //change to your favorite\n        }\n        else {\n            filename = args[0];\n        }\n        try {\n            BufferedReader reader = new BufferedReader(new FileReader(filename));\n            MSFAlignmentFormat MSFAlignmentFormat1 = new MSFAlignmentFormat();\n            MSFAlignmentFormat1.read(reader);\n        } catch (Exception E) {}\n    }\n\n    /**\n     * Reads an MSF Alignment File\n     * @param reader The file reader\n     * @return Alignment A SimpleAlignment consisting of the sequences in the file.\n     */\n    public Alignment read (BufferedReader reader) {\n        Vector sequenceNames = new Vector();\n        String sequenceName = null;\n        StringBuffer sequenceData[] = null;\n        int startOfData = 0;                    //the start of the sequence data in the line\n        int currSeqCount = 0;                   //which sequence data you are currently trying to get\n        try {\n            Pattern mtc = Pattern.compile(\"(Name:|NAME:)\\\\s+(.*?)\\\\s+(oo|OO|Len:|LEN:)\");\n            Pattern removewhitespace = Pattern.compile(\"\\\\s\");\n            // REMatch rem = null;\n            String line = reader.readLine();\n            //parse past header\n            while (line.toUpperCase().indexOf(\"NAME:\") == -1) {\n                line = reader.readLine();\n            }\n            //read each name (between Name:   and Len:\n            while ((line.indexOf(\"//\") == -1) && ((line.trim()).length() !=\n                    0))\n            {\n                Matcher matcher = mtc.matcher(line);\n                if (!matcher.find()) {\n                    break;\n                }               //end of sequence names\n                //sequenceName = line.substring(rem.getSubStartIndex(1),\n                //                              rem.getSubEndIndex(1));\n                if ((line.trim()).length() == 0) {\n                    break;\n                }\n                sequenceName = matcher.group(2).trim();\n                sequenceNames.add(sequenceName);\n\n                line = reader.readLine();\n            }\n            sequenceData = new StringBuffer[sequenceNames.size()];\n            for (int it = 0; it < sequenceNames.size(); it++) {\n                sequenceData[it] = new StringBuffer();\n            }\n            //until you get a line that matches the first sequence\n            while (line.indexOf((String)sequenceNames.get(0)) == -1)\n            {\n                line = reader.readLine();\n            }\n            //now you on the first line of the sequence data\n            while (line != null) {\n                for (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {//you could also check for order of names\n                    if (line.indexOf((String)sequenceNames.get(currSeqCount))\n                            == -1) {\n                        break;\n                    }           //error\n\n                    startOfData = line.indexOf((String)sequenceNames.get(currSeqCount))\n                            + ((String)sequenceNames.get(currSeqCount)).length();\n                    line = (line.substring(startOfData));\n                    line = removewhitespace.matcher(line).replaceAll(\"\");\n                    sequenceData[currSeqCount].append(line); //make into string buffer\n                    line = reader.readLine();\n                    if ((currSeqCount < sequenceNames.size() - 1) && (line.trim().length() == 0)) {\n                        break;\n                    }           //could be an error\n                }\n                //until you get a line that matches the first sequence\n                while ((line != null) && (line.indexOf((String)sequenceNames.get(0))\n                        == -1))                 // || (   (line.trim()) .length()>0  )    )\n                {\n                    line = reader.readLine();\n                }\n            }\n            //print them out for testing\n            if (DEBUGPRINT) {\n                for (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n                    System.out.println((String)sequenceNames.get(currSeqCount)\n                            + \":\" + sequenceData[currSeqCount]);\n                }\n            }\n            //check DNA, RNA or Prot\n            StringBuffer testString = new StringBuffer();\n            for (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n                testString.append(sequenceData[currSeqCount]);\n            }\n            String testStringUpper=testString.toString().toUpperCase();\n\n\n            //now parse through them and create gapped symbol lists\n            LinkedHashMap sequenceDataMap = new LinkedHashMap();\n            FiniteAlphabet alph = null;\n\n            for (int i = 0; i < testStringUpper.length(); i++) {\n              char c=testStringUpper.charAt(i);\n                if (c == 'F' ||\n                    c == 'L' ||\n                    c == 'I' ||\n                    c == 'P' ||\n                    c == 'Q' ||\n                    c == 'E') {\n                        alph = ProteinTools.getTAlphabet();\n                       break;\n                }\n            }\n            if (alph == null) {\n                alph = DNATools.getDNA();\n            }\n            for (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n                String sd = sequenceData[currSeqCount].toString();\n                //change stop codons to specified symbols\n                sd = sd.replace('~', '-');              //sometimes this is a term signal not a gap\n                sd = sd.replace('.', '-');              //sometimes this is a term signal not a gap\n                sequenceDataMap.put((String)sequenceNames.get(currSeqCount),\n                        alph==ProteinTools.getTAlphabet()?\n                        \t\tProteinTools.createGappedProteinSequence(sd, (String)sequenceNames.get(currSeqCount))\n                        \t\t:DNATools.createGappedDNASequence(sd, (String)sequenceNames.get(currSeqCount)));\n            }\n            SimpleAlignment sa=new SimpleAlignment(sequenceDataMap);\n            return  (sa);\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"MSFFormatReader \" + e.getMessage());\n            // throw (e);\n        }\n        return  (null);\n    }           //end read it\n\n    //This is where I am writing an alignment writer\n    public void write(OutputStream os, Alignment align, int fileType) throws BioException, IllegalSymbolException {\n        PrintStream out = new PrintStream(os);\n        Object labels[] = align.getLabels().toArray();\n        int numSeqs = labels.length;\n        Iterator seqIts[] = new Iterator[numSeqs];\n        int maxLabelLength = 0;\n        for (int i = 0; i < numSeqs; i++) {\n            seqIts[i] = align.symbolListForLabel(labels[i]).iterator();\n            if (((String) labels[i]).length() > maxLabelLength) {\n                maxLabelLength = ((String) labels[i]).length();\n            }\n        }\n        String nl = System.getProperty(\"line.separator\");\n        SymbolTokenization toke = null;\n\n//really should determine the filetype based on one of the seqeunces alphabet\n\nif (align.symbolListForLabel(labels[0]).getAlphabet()==DNATools.getDNA()) {\n  fileType = DNA;\n\n} else if (align.symbolListForLabel(labels[0]).getAlphabet()==ProteinTools.getAlphabet() ||align.symbolListForLabel(labels[0]).getAlphabet()==ProteinTools.getTAlphabet() ) {\n  fileType = PROTEIN;\n}\n\n        if (fileType == DNA) {\n          out.print(\"PileUp\"+nl);\n          out.print(nl);\n          out.print(\" MSF: \" + align.length() + \"  Type: \");\n          out.print(\"N\");\n            out.print(\"   Check: \"+0+\"   ..\"+nl);\n            toke = DNATools.getDNA().getTokenization(\"token\");\n        }\n        else if (fileType == PROTEIN) {\n          out.print(\"PileUp\"+nl);\n          out.print(nl);\n          out.print(\" MSF: \" + align.length() + \"  Type: \");\n          out.print(\"P\");\n            out.print(\"   Check: \"+0+\"   ..\"+nl);\n            toke = ProteinTools.getTAlphabet().getTokenization(\"token\");\n        }\n        else {\n            System.out.println(\"MSFAlignment.write -- File type not recognized.\");\n            return;\n        }\n        out.print(nl);\n\n        for (int i = 0; i < numSeqs; i++) {\n            out.print(\" Name: \" + labels[i]);\n            for (int j = 0; j < (maxLabelLength - ((String) labels[i]).length()); j++) {//padding\n                out.print(\" \");\n            }\n            out.print(\"  Len: \" + align.length() +\" \tCheck: \"+0+\"\tWeight: \"+0+nl); //this really should be seq length?\n        }\n\n        out.println(nl+\"//\"+nl+nl);\n        //now should print the numbering line\n\n        while (seqIts[0].hasNext()) {\n            for (int i = 0; i < numSeqs; i++) {\n                while (((String) labels[i]).length() < maxLabelLength + 1) {\n                    labels[i] = \" \" + labels[i];\n                }\n                out.print(labels[i] + \" \");\n                theLabel:\n                for (int j = 0; j < 5; j++) {\n                    out.print(\" \");\n                    for (int k = 0; k < 10; k++) {\n                        if (seqIts[i].hasNext()) {\n                            out.print(toke.tokenizeSymbol((Symbol) seqIts[i].next()));\n                        }\n                        else {\n                            break theLabel;\n                        }\n                    }\n                }\n                out.print(nl);\n            }\n            out.print(nl);\n        }\n\n    } //end write\n\n    public void writeDna(OutputStream os, Alignment align) throws BioException, IllegalSymbolException {\n        write(os, align, DNA);\n    }\n\n    public void writeProtein(OutputStream os, Alignment align) throws BioException, IllegalSymbolException {\n        write(os, align, PROTEIN);\n    }\n\n}               //end class\n\n\n\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\n\npackage org.biojava.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.biojava.bio.BioException;\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.alignment.SimpleAlignment;\nimport org.biojava.bio.seq.DNATools;\nimport org.biojava.bio.seq.ProteinTools;\nimport org.biojava.bio.symbol.FiniteAlphabet;\nimport org.biojava.bio.symbol.IllegalSymbolException;\nimport org.biojava.bio.symbol.Symbol;\nimport org.biojava.bio.symbol.SymbolList;\n\n/**\n * @author raemig\n * @author Thomas Down\n * @author Keith James\n * @author Nimesh Singh\n * @author Mark Schreiber\n * @author Matthew Pocock\n * @author Bradford Powell\n */\n\npublic class MSFAlignmentFormat implements AlignmentFormat {\n\tprivate static final boolean DEBUGPRINT = false;\n\tprivate static final int DNA = 1;\n\tprivate static final int PROTEIN = 2;\n\n\tpublic MSFAlignmentFormat() {\n\t}\n\n\t/**\n\t * used to quick test the code\n\t * \n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tString filename;\n\t\tif (args.length < 1) {\n\t\t\tfilename = \"SimpleMSF.msf\"; // change to your favorite\n\t\t} else {\n\t\t\tfilename = args[0];\n\t\t}\n\t\ttry {\n\t\t\tBufferedReader reader = new BufferedReader(new FileReader(filename));\n\t\t\tMSFAlignmentFormat MSFAlignmentFormat1 = new MSFAlignmentFormat();\n\t\t\tMSFAlignmentFormat1.read(reader);\n\t\t} catch (Exception E) {\n\t\t}\n\t}\n\n\t/**\n\t * Reads an MSF Alignment File\n\t * \n\t * @param reader\n\t *            The file reader\n\t * @return Alignment A SimpleAlignment consisting of the sequences in the\n\t *         file.\n\t */\n\tpublic Alignment read(BufferedReader reader) {\n\t\tVector sequenceNames = new Vector();\n\t\tString sequenceName = null;\n\t\tStringBuffer sequenceData[] = null;\n\t\tint startOfData = 0; // the start of the sequence data in the line\n\t\tint currSeqCount = 0; // which sequence data you are currently trying to\n\t\t// get\n\t\ttry {\n\t\t\tPattern mtc = Pattern\n\t\t\t\t\t.compile(\"(Name:|NAME:)\\\\s+(.*?)\\\\s+(oo|OO|Len:|LEN:)\");\n\t\t\tPattern removewhitespace = Pattern.compile(\"\\\\s\");\n\t\t\t// REMatch rem = null;\n\t\t\tString line = reader.readLine();\n\t\t\t// parse past header\n\t\t\twhile (line.toUpperCase().indexOf(\"NAME:\") == -1) {\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\t// read each name (between Name: and Len:\n\t\t\twhile ((line.indexOf(\"//\") == -1) && ((line.trim()).length() != 0)) {\n\t\t\t\tMatcher matcher = mtc.matcher(line);\n\t\t\t\tif (!matcher.find()) {\n\t\t\t\t\tbreak;\n\t\t\t\t} // end of sequence names\n\t\t\t\t// sequenceName = line.substring(rem.getSubStartIndex(1),\n\t\t\t\t// rem.getSubEndIndex(1));\n\t\t\t\tif ((line.trim()).length() == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsequenceName = matcher.group(2).trim();\n\t\t\t\tsequenceNames.add(sequenceName);\n\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\tsequenceData = new StringBuffer[sequenceNames.size()];\n\t\t\tfor (int it = 0; it < sequenceNames.size(); it++) {\n\t\t\t\tsequenceData[it] = new StringBuffer();\n\t\t\t}\n\t\t\t// until you get a line that matches the first sequence\n\t\t\twhile (line.indexOf((String) sequenceNames.get(0)) == -1) {\n\t\t\t\tline = reader.readLine();\n\t\t\t}\n\t\t\t// now you on the first line of the sequence data\n\t\t\twhile (line != null) {\n\t\t\t\tfor (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {// you\n\t\t\t\t\t// could\n\t\t\t\t\t// also\n\t\t\t\t\t// check\n\t\t\t\t\t// for\n\t\t\t\t\t// order\n\t\t\t\t\t// of\n\t\t\t\t\t// names\n\t\t\t\t\tif (line.indexOf((String) sequenceNames.get(currSeqCount)) == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // error\n\n\t\t\t\t\tstartOfData = line.indexOf((String) sequenceNames\n\t\t\t\t\t\t\t.get(currSeqCount))\n\t\t\t\t\t\t\t+ ((String) sequenceNames.get(currSeqCount))\n\t\t\t\t\t\t\t\t\t.length();\n\t\t\t\t\tline = (line.substring(startOfData));\n\t\t\t\t\tline = removewhitespace.matcher(line).replaceAll(\"\");\n\t\t\t\t\tsequenceData[currSeqCount].append(line); // make into string\n\t\t\t\t\t// buffer\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif ((currSeqCount < sequenceNames.size() - 1)\n\t\t\t\t\t\t\t&& (line.trim().length() == 0)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // could be an error\n\t\t\t\t}\n\t\t\t\t// until you get a line that matches the first sequence\n\t\t\t\twhile ((line != null)\n\t\t\t\t\t\t&& (line.indexOf((String) sequenceNames.get(0)) == -1)) // ||\n\t\t\t\t// (\n\t\t\t\t// (line.trim())\n\t\t\t\t// .length()>0\n\t\t\t\t// )\n\t\t\t\t// )\n\t\t\t\t{\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t}\n\t\t\t}\n\t\t\t// print them out for testing\n\t\t\tif (DEBUGPRINT) {\n\t\t\t\tfor (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n\t\t\t\t\tSystem.out.println((String) sequenceNames.get(currSeqCount)\n\t\t\t\t\t\t\t+ \":\" + sequenceData[currSeqCount]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check DNA, RNA or Prot\n\t\t\tStringBuffer testString = new StringBuffer();\n\t\t\tfor (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n\t\t\t\ttestString.append(sequenceData[currSeqCount]);\n\t\t\t}\n\t\t\tString testStringUpper = testString.toString().toUpperCase();\n\n\t\t\t// now parse through them and create gapped symbol lists\n\t\t\tLinkedHashMap sequenceDataMap = new LinkedHashMap();\n\t\t\tFiniteAlphabet alph = null;\n\n\t\t\tfor (int i = 0; i < testStringUpper.length(); i++) {\n\t\t\t\tchar c = testStringUpper.charAt(i);\n\t\t\t\tif (c == 'F' || c == 'L' || c == 'I' || c == 'P' || c == 'Q'\n\t\t\t\t\t\t|| c == 'E') {\n\t\t\t\t\talph = ProteinTools.getTAlphabet();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (alph == null) {\n\t\t\t\talph = DNATools.getDNA();\n\t\t\t}\n\t\t\tfor (currSeqCount = 0; currSeqCount < sequenceNames.size(); currSeqCount++) {\n\t\t\t\tString sd = sequenceData[currSeqCount].toString();\n\t\t\t\t// change stop codons to specified symbols\n\t\t\t\tsd = sd.replace('~', '-'); // sometimes this is a term signal\n\t\t\t\t// not a gap\n\t\t\t\tsd = sd.replace('.', '-'); // sometimes this is a term signal\n\t\t\t\t// not a gap\n\t\t\t\tsequenceDataMap.put((String) sequenceNames.get(currSeqCount),\n\t\t\t\t\t\talph == ProteinTools.getTAlphabet() ? ProteinTools\n\t\t\t\t\t\t\t\t.createGappedProteinSequence(sd,\n\t\t\t\t\t\t\t\t\t\t(String) sequenceNames\n\t\t\t\t\t\t\t\t\t\t\t\t.get(currSeqCount)) : DNATools\n\t\t\t\t\t\t\t\t.createGappedDNASequence(sd,\n\t\t\t\t\t\t\t\t\t\t(String) sequenceNames\n\t\t\t\t\t\t\t\t\t\t\t\t.get(currSeqCount)));\n\t\t\t}\n\t\t\tSimpleAlignment sa = new SimpleAlignment(sequenceDataMap);\n\t\t\treturn (sa);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.err.println(\"MSFFormatReader \" + e.getMessage());\n\t\t\t// throw (e);\n\t\t}\n\t\treturn (null);\n\t} // end read it\n\n\t// This is where I am writing an alignment writer\n\tpublic void write(OutputStream os, Alignment align, int fileType)\n\t\t\tthrows BioException, IllegalSymbolException {\n\t\tPrintStream out = new PrintStream(os);\n\t\tObject labels[] = align.getLabels().toArray();\n\t\tint numSeqs = labels.length;\n\t\tIterator<?> seqIts[] = new Iterator<?>[numSeqs];\n\t\tint maxLabelLength = 0;\n\t\tfor (int i = 0; i < numSeqs; i++) {\n\t\t\tseqIts[i] = align.symbolListForLabel(labels[i].toString())\n\t\t\t\t\t.iterator();\n\t\t\tif (((String) labels[i]).length() > maxLabelLength) {\n\t\t\t\tmaxLabelLength = ((String) labels[i]).length();\n\t\t\t}\n\t\t}\n\t\tString nl = System.getProperty(\"line.separator\");\n\t\tSymbolTokenization toke = null;\n\n\t\t// really should determine the filetype based on one of the seqeunces\n\t\t// alphabet\n\n\t\tif (align.symbolListForLabel(labels[0].toString()).getAlphabet() == DNATools\n\t\t\t\t.getDNA()) {\n\t\t\tfileType = DNA;\n\n\t\t} else if (align.symbolListForLabel(labels[0].toString()).getAlphabet() == ProteinTools\n\t\t\t\t.getAlphabet()\n\t\t\t\t|| align.symbolListForLabel(labels[0].toString()).getAlphabet() == ProteinTools\n\t\t\t\t\t\t.getTAlphabet()) {\n\t\t\tfileType = PROTEIN;\n\t\t}\n\n\t\tif (fileType == DNA) {\n\t\t\tout.print(\"PileUp\" + nl);\n\t\t\tout.print(nl);\n\t\t\tout.print(\" MSF: \" + align.length() + \"  Type: \");\n\t\t\tout.print(\"N\");\n\t\t\tout.print(\"   Check: \" + 0 + \"   ..\" + nl);\n\t\t\ttoke = DNATools.getDNA().getTokenization(\"token\");\n\t\t} else if (fileType == PROTEIN) {\n\t\t\tout.print(\"PileUp\" + nl);\n\t\t\tout.print(nl);\n\t\t\tout.print(\" MSF: \" + align.length() + \"  Type: \");\n\t\t\tout.print(\"P\");\n\t\t\tout.print(\"   Check: \" + 0 + \"   ..\" + nl);\n\t\t\ttoke = ProteinTools.getTAlphabet().getTokenization(\"token\");\n\t\t} else {\n\t\t\tSystem.out\n\t\t\t\t\t.println(\"MSFAlignment.write -- File type not recognized.\");\n\t\t\treturn;\n\t\t}\n\t\tout.print(nl);\n\n\t\tfor (int i = 0; i < numSeqs; i++) {\n\t\t\tout.print(\" Name: \" + labels[i]);\n\t\t\tfor (int j = 0; j < (maxLabelLength - ((String) labels[i]).length()); j++) {// padding\n\t\t\t\tout.print(\" \");\n\t\t\t}\n\t\t\tout.print(\"  Len: \" + align.length() + \" \tCheck: \" + 0\n\t\t\t\t\t+ \"\tWeight: \" + 0 + nl); // this really should be seq\n\t\t\t// length?\n\t\t}\n\n\t\tout.println(nl + \"//\" + nl + nl);\n\t\t// now should print the numbering line\n\n\t\twhile (seqIts[0].hasNext()) {\n\t\t\tfor (int i = 0; i < numSeqs; i++) {\n\t\t\t\twhile (((String) labels[i]).length() < maxLabelLength + 1) {\n\t\t\t\t\tlabels[i] = \" \" + labels[i];\n\t\t\t\t}\n\t\t\t\tout.print(labels[i] + \" \");\n\t\t\t\ttheLabel: for (int j = 0; j < 5; j++) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tif (seqIts[i].hasNext()) {\n\t\t\t\t\t\t\tout.print(toke.tokenizeSymbol((Symbol) seqIts[i]\n\t\t\t\t\t\t\t\t\t.next()));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak theLabel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.print(nl);\n\t\t\t}\n\t\t\tout.print(nl);\n\t\t}\n\n\t} // end write\n\n\tpublic void writeDna(OutputStream os, Alignment align) throws BioException,\n\t\t\tIllegalSymbolException {\n\t\twrite(os, align, DNA);\n\t}\n\n\tpublic void writeProtein(OutputStream os, Alignment align)\n\t\t\tthrows BioException, IllegalSymbolException {\n\t\twrite(os, align, PROTEIN);\n\t}\n\n} // end class\n\n","originTest":"/**\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n */\npackage org.biojava.bio.seq.io;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\nimport junit.framework.TestCase;\n\nimport org.biojava.bio.alignment.Alignment;\nimport org.biojava.bio.seq.DNATools;\n\n/**\n * JUnit test for MSFAlignmentFormat\n * @author Thomas Down\n * @since 1.4\n */\n \npublic class MSFAlignmentFormatTest extends TestCase\n{\n\n    public MSFAlignmentFormatTest(String name)\n    {\n        super(name);\n    }\n\n    public void testReadDNAAlignment()\n    {\n        // get access to the test file\n        InputStream inputS = this.getClass().getResourceAsStream(\"/dna.msf\");\n        assertNotNull(inputS);\n\n        Alignment alignment = new MSFAlignmentFormat().read(new BufferedReader(new InputStreamReader(inputS)));\n        assertNotNull(alignment);\n        \n        assertEquals(alignment.length(), 120);\n        assertEquals(alignment.getAlphabet().getAlphabets().get(0), DNATools.getDNA());\n    }\n}\n","changedTest":"","commitMessage":"The alignment algorithms NeedlemanWunsch and SmithWaterman have been revised and are now based on a Alignment data structure that strongly eases using the result.\n\ngit-svn-id: http://code.open-bio.org/repos/biojava/biojava-live/trunk@7598 7c6358e6-4a41-0410-a743-a5b2a554c398\n","test_commitMessage":"","allZero":false}