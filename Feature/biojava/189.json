{"repository":"biojava","prod_path":"biojava3-structure/src/main/java/org/biojava/bio/structure/AtomPositionMap.java","test_path":"biojava3-structure/src/test/java/org/biojava/bio/structure/AtomPositionMapTest.java","prod_time":"2015-01-26 23:32:03","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":1,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":2,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":1,"del_annotation_line":0,"del_call_line":3,"del_classname_line":0,"del_condition_line":0,"del_field_line":2,"del_import_line":4,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":1,"label":"NEGATIVE","prod_commitID":"be164adbf95f232f45581146b1694ca298588de1","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.io.mmcif.chem.ResidueType;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * A map from {@link ResidueNumber ResidueNumbers} to ATOM record positions in a PDB file.\n * To use:\n * <code>\n * AtomPositionMap map = new AtomPositionMap(new AtomCache().getAtoms(\"1w0p\"));\n * ResidueNumber start = new ResidueNumber(\"A\", 100, null);\n * ResidueNumber end = map.getEnd(\"A\");\n * int pos = map.getPosition(start);\n * int length = map.calcLength(start, end);\n * </code>\n * @author dmyerstu\n */\npublic class AtomPositionMap {\n\n\tprivate HashMap<ResidueNumber, Integer> hashMap;\n\tprivate TreeMap<ResidueNumber, Integer> treeMap;\n\n\tpublic static final Set<String> AMINO_ACID_NAMES = new TreeSet<String>();\n\tstatic {\n\t\tAMINO_ACID_NAMES.addAll(Arrays.asList(\"ALA\", \"ARG\", \"ASN\", \"ASP\", \"CYS\", \"GLU\", \"GLN\", \"GLY\", \"HIS\", \"ILE\", \"LEU\", \"LYS\", \"MET\", \"PHE\", \"PRO\", \"SER\", \"THR\", \"TRP\", \"TYR\", \"VAL\"));\n\t\tAMINO_ACID_NAMES.addAll(Arrays.asList(\"ASX\", \"GLX\", \"XLE\", \"XAA\"));\n\t}\n\n\tpublic static interface GroupMatcher {\n\t\tboolean matches(Group group);\n\t}\n\n\tpublic static final GroupMatcher AMINO_ACID_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\tResidueType type = group.getChemComp().getResidueType();\n\t\t\treturn group.hasAtom(StructureTools.CA_ATOM_NAME) || AMINO_ACID_NAMES.contains(group.getPDBName()) || type == ResidueType.lPeptideLinking || type == ResidueType.glycine || type == ResidueType.lPeptideAminoTerminus || type == ResidueType.lPeptideCarboxyTerminus || type == ResidueType.dPeptideLinking || type == ResidueType.dPeptideAminoTerminus || type == ResidueType.dPeptideCarboxyTerminus;\n\t\t}\n\t};\n\n\tpublic static final GroupMatcher ANYTHING_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * A map that is sorted by its values.\n\t * \n\t * @author dmyerstu\n\t * \n\t * @param <T>\n\t *            The key type\n\t * @param <V>\n\t *            The value type\n\t */\n\tprivate static class ValueComparator<T, V extends Comparable<V>> implements Comparator<T> {\n\n\t\tprivate Map<T, V> map;\n\n\t\tpublic ValueComparator(Map<T, V> map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(T o1, T o2) {\n\t\t\treturn map.get(o1).compareTo(map.get(o2));\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only amino acids C-alpha atoms. C-alpha atoms are identified somewhat liberally.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms) {\n\t\tthis(atoms, AMINO_ACID_MATCHER);\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only atoms matched by {@code matcher}.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms, GroupMatcher matcher) {\n\t\thashMap = new HashMap<ResidueNumber, Integer>();\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tGroup group = atoms[i].getGroup();\n\t\t\tResidueNumber rn = group.getResidueNumber();\n\t\t\tif (matcher.matches(group)) {\n\t\t\t\tif (!hashMap.containsKey(rn)) {\n\t\t\t\t\thashMap.put(rn, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tComparator<ResidueNumber> vc = new ValueComparator<ResidueNumber, Integer>(hashMap);\n\t\ttreeMap = new TreeMap<ResidueNumber, Integer>(vc);\n\t\ttreeMap.putAll(hashMap);\n\t}\n\n\t/**\n\t * This is <strong>not</em> the same as subtracting {@link #getPosition(ResidueNumber)} for {@code positionB} from {@link #getPosition(ResidueNumber)} for {@code positionA}.\n\t * The latter considers only positions of ATOM entries in the PDB file and ignores chains. This method only includes ATOMs from the same chain.\n\t * @param positionA\n\t * @param positionB\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLength(int positionA, int positionB, char startingChain) {\n\t\treturn calcLength(positionA, positionB, String.valueOf(startingChain));\n\t}\n\n\t/**\n\t * This is <strong>not</em> the same as subtracting {@link #getPosition(ResidueNumber)} for {@code positionB} from {@link #getPosition(ResidueNumber)} for {@code positionA}.\n\t * The latter considers only positions of ATOM entries in the PDB file and ignores chains. This method only includes ATOMs from the same chain.\n\t * @param positionA\n\t * @param positionB\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLength(int positionA, int positionB, String startingChain) {\n\t\tint positionStart, positionEnd;\n\t\tif (positionA <= positionB) {\n\t\t\tpositionStart = positionA;\n\t\t\tpositionEnd = positionB;\n\t\t} else {\n\t\t\tpositionStart = positionB;\n\t\t\tpositionEnd = positionA;\n\t\t}\n\t\treturn calcLengthDirectional(positionStart, positionEnd, startingChain);\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(ResidueNumber start, ResidueNumber end) {\n\t\treturn calcLengthDirectional(getPosition(start), getPosition(end), start.getChainId());\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param positionStart\n\t * @param positionEnd\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(int positionStart, int positionEnd, char startingChain) {\n\t\treturn calcLengthDirectional(positionStart, positionEnd, String.valueOf(startingChain));\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param positionStart\n\t * @param positionEnd\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(int positionStart, int positionEnd, String startingChain) {\n\t\tint count = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : treeMap.entrySet()) {\n\t\t\tif (entry.getKey().getChainId().equals(startingChain)) {\n\t\t\t\tif (entry.getValue() == positionStart) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t\tif (entry.getValue() == positionEnd) return count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Convenience method for {@link #calcLength(int, int, String)}.\n\t * @param positionA\n\t * @param positionB\n\t * @return\n\t * @see #calcLength(int, int, char)\n\t */\n\tpublic int calcLength(ResidueNumber positionA, ResidueNumber positionB) {\n\t\tint pA = hashMap.get(positionA);\n\t\tint pB = hashMap.get(positionB);\n\t\tString chain = positionA.getChainId();\n\t\tif (pA > pB) chain = positionB.getChainId();\n\t\treturn calcLength(pA, pB, chain);\n\t}\n\n\tpublic NavigableMap<ResidueNumber, Integer> getNavMap() {\n\t\treturn treeMap;\n\t}\n\n\t/**\n\t * @param residueNumber\n\t * @return The position of the ATOM record in the PDB file corresponding to the {@code residueNumber}\n\t */\n\tpublic Integer getPosition(ResidueNumber residueNumber) {\n\t\treturn hashMap.get(residueNumber);\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The first {@link ResidueNumber} of the specified chain (the one highest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.firstEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.higherEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The last {@link ResidueNumber} of the specified chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.lastEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.lowerEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @return The first {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst() {\n\t\treturn treeMap.firstKey();\n\t}\n\n\t/**\n\t * @return The last {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast() {\n\t\treturn treeMap.lastKey();\n\t}\n\n\t/**\n\t * Returns a list of {@link ResidueRange ResidueRanges} corresponding to this entire AtomPositionMap.\n\t */\n\tpublic List<ResidueRangeAndLength> getRanges() {\n\t\tString currentChain = \"\";\n\t\tResidueNumber first = null;\n\t\tResidueNumber prev = null;\n\t\tList<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>();\n\t\tfor (ResidueNumber rn : treeMap.keySet()) {\n\t\t\tif (!rn.getChainId().equals(currentChain)) {\n\t\t\t\tif (first != null) {\n\t\t\t\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.calcLength(first, prev));\n\t\t\t\t\tranges.add(newRange);\n\t\t\t\t}\n\t\t\t\tfirst = rn;\n\t\t\t}\n\t\t\tprev = rn;\n\t\t\tcurrentChain = rn.getChainId();\n\t\t}\n\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.calcLength(first, prev));\n\t\tranges.add(newRange);\n\t\treturn ranges;\n\t}\n\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport org.biojava.bio.structure.io.mmcif.chem.PolymerType;\nimport org.biojava.bio.structure.io.mmcif.chem.ResidueType;\n\n/**\n * A map from {@link ResidueNumber ResidueNumbers} to ATOM record positions in a PDB file.\n * To use:\n * <code>\n * AtomPositionMap map = new AtomPositionMap(new AtomCache().getAtoms(\"1w0p\"));\n * ResidueNumber start = new ResidueNumber(\"A\", 100, null);\n * ResidueNumber end = map.getEnd(\"A\");\n * int pos = map.getPosition(start);\n * int length = map.calcLength(start, end);\n * </code>\n * @author dmyerstu\n */\npublic class AtomPositionMap {\n\n\tprivate HashMap<ResidueNumber, Integer> hashMap;\n\tprivate TreeMap<ResidueNumber, Integer> treeMap;\n\n\n\tpublic static interface GroupMatcher {\n\t\tboolean matches(Group group);\n\t}\n\n\tpublic static final GroupMatcher AMINO_ACID_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\tResidueType type = group.getChemComp().getResidueType();\n\t\t\treturn PolymerType.PROTEIN_ONLY.contains(type.getPolymerType());\n\t\t}\n\t};\n\n\tpublic static final GroupMatcher ANYTHING_MATCHER = new GroupMatcher() {\n\t\t@Override\n\t\tpublic boolean matches(Group group) {\n\t\t\treturn true;\n\t\t}\n\t};\n\n\t/**\n\t * A map that is sorted by its values.\n\t * \n\t * @author dmyerstu\n\t * \n\t * @param <T>\n\t *            The key type\n\t * @param <V>\n\t *            The value type\n\t */\n\tprivate static class ValueComparator<T, V extends Comparable<V>> implements Comparator<T> {\n\n\t\tprivate Map<T, V> map;\n\n\t\tpublic ValueComparator(Map<T, V> map) {\n\t\t\tthis.map = map;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compare(T o1, T o2) {\n\t\t\treturn map.get(o1).compareTo(map.get(o2));\n\t\t}\n\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only amino acids C-alpha atoms. C-alpha atoms are identified somewhat liberally.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms) {\n\t\tthis(atoms, AMINO_ACID_MATCHER);\n\t}\n\n\t/**\n\t * Creates a new AtomPositionMap containing only atoms matched by {@code matcher}.\n\t * @param atoms\n\t */\n\tpublic AtomPositionMap(Atom[] atoms, GroupMatcher matcher) {\n\t\thashMap = new HashMap<ResidueNumber, Integer>();\n\t\tfor (int i = 0; i < atoms.length; i++) {\n\t\t\tGroup group = atoms[i].getGroup();\n\t\t\tResidueNumber rn = group.getResidueNumber();\n\t\t\tif (matcher.matches(group)) {\n\t\t\t\tif (!hashMap.containsKey(rn)) {\n\t\t\t\t\thashMap.put(rn, i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tComparator<ResidueNumber> vc = new ValueComparator<ResidueNumber, Integer>(hashMap);\n\t\ttreeMap = new TreeMap<ResidueNumber, Integer>(vc);\n\t\ttreeMap.putAll(hashMap);\n\t}\n\n\t/**\n\t * This is <strong>not</em> the same as subtracting {@link #getPosition(ResidueNumber)} for {@code positionB} from {@link #getPosition(ResidueNumber)} for {@code positionA}.\n\t * The latter considers only positions of ATOM entries in the PDB file and ignores chains. This method only includes ATOMs from the same chain.\n\t * @param positionA\n\t * @param positionB\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLength(int positionA, int positionB, char startingChain) {\n\t\treturn calcLength(positionA, positionB, String.valueOf(startingChain));\n\t}\n\n\t/**\n\t * This is <strong>not</em> the same as subtracting {@link #getPosition(ResidueNumber)} for {@code positionB} from {@link #getPosition(ResidueNumber)} for {@code positionA}.\n\t * The latter considers only positions of ATOM entries in the PDB file and ignores chains. This method only includes ATOMs from the same chain.\n\t * @param positionA\n\t * @param positionB\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLength(int positionA, int positionB, String startingChain) {\n\t\tint positionStart, positionEnd;\n\t\tif (positionA <= positionB) {\n\t\t\tpositionStart = positionA;\n\t\t\tpositionEnd = positionB;\n\t\t} else {\n\t\t\tpositionStart = positionB;\n\t\t\tpositionEnd = positionA;\n\t\t}\n\t\treturn calcLengthDirectional(positionStart, positionEnd, startingChain);\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param start\n\t * @param end\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(ResidueNumber start, ResidueNumber end) {\n\t\treturn calcLengthDirectional(getPosition(start), getPosition(end), start.getChainId());\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param positionStart\n\t * @param positionEnd\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(int positionStart, int positionEnd, char startingChain) {\n\t\treturn calcLengthDirectional(positionStart, positionEnd, String.valueOf(startingChain));\n\t}\n\n\t/**\n\t * Calculates the distance between {@code positionStart} and {@code positionEnd}. Will return a negative value if the start is past the end.\n\t * @param positionStart\n\t * @param positionEnd\n\t * @param startingChain\n\t * @return\n\t */\n\tpublic int calcLengthDirectional(int positionStart, int positionEnd, String startingChain) {\n\t\tint count = 0;\n\t\tfor (Map.Entry<ResidueNumber, Integer> entry : treeMap.entrySet()) {\n\t\t\tif (entry.getKey().getChainId().equals(startingChain)) {\n\t\t\t\tif (entry.getValue() == positionStart) {\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t\tif (entry.getValue() == positionEnd) return count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Convenience method for {@link #calcLength(int, int, String)}.\n\t * @param positionA\n\t * @param positionB\n\t * @return\n\t * @see #calcLength(int, int, char)\n\t */\n\tpublic int calcLength(ResidueNumber positionA, ResidueNumber positionB) {\n\t\tint pA = hashMap.get(positionA);\n\t\tint pB = hashMap.get(positionB);\n\t\tString chain = positionA.getChainId();\n\t\tif (pA > pB) chain = positionB.getChainId();\n\t\treturn calcLength(pA, pB, chain);\n\t}\n\n\tpublic NavigableMap<ResidueNumber, Integer> getNavMap() {\n\t\treturn treeMap;\n\t}\n\n\t/**\n\t * @param residueNumber\n\t * @return The position of the ATOM record in the PDB file corresponding to the {@code residueNumber}\n\t */\n\tpublic Integer getPosition(ResidueNumber residueNumber) {\n\t\treturn hashMap.get(residueNumber);\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The first {@link ResidueNumber} of the specified chain (the one highest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.firstEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.higherEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @param chainId\n\t * @return The last {@link ResidueNumber} of the specified chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast(String chainId) {\n\t\tMap.Entry<ResidueNumber,Integer> entry = treeMap.lastEntry();\n\t\twhile (true) {\n\t\t\tif (entry.getKey().getChainId().equals(chainId)) return entry.getKey();\n\t\t\tentry = treeMap.lowerEntry(entry.getKey());\n\t\t\tif (entry == null) return null;\n\t\t}\n\t}\n\n\t/**\n\t * @return The first {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getFirst() {\n\t\treturn treeMap.firstKey();\n\t}\n\n\t/**\n\t * @return The last {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n\t */\n\tpublic ResidueNumber getLast() {\n\t\treturn treeMap.lastKey();\n\t}\n\n\t/**\n\t * Returns a list of {@link ResidueRange ResidueRanges} corresponding to this entire AtomPositionMap.\n\t */\n\tpublic List<ResidueRangeAndLength> getRanges() {\n\t\tString currentChain = \"\";\n\t\tResidueNumber first = null;\n\t\tResidueNumber prev = null;\n\t\tList<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>();\n\t\tfor (ResidueNumber rn : treeMap.keySet()) {\n\t\t\tif (!rn.getChainId().equals(currentChain)) {\n\t\t\t\tif (first != null) {\n\t\t\t\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.calcLength(first, prev));\n\t\t\t\t\tranges.add(newRange);\n\t\t\t\t}\n\t\t\t\tfirst = rn;\n\t\t\t}\n\t\t\tprev = rn;\n\t\t\tcurrentChain = rn.getChainId();\n\t\t}\n\t\tResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.calcLength(first, prev));\n\t\tranges.add(newRange);\n\t\treturn ranges;\n\t}\n\n}\n","originTest":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on 2012-12-01\n *\n */\n\npackage org.biojava.bio.structure;\n\nimport org.biojava.bio.structure.align.util.AtomCache;\nimport org.biojava.bio.structure.io.LocalPDBDirectory;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.NavigableMap;\n\nimport static org.junit.Assert.assertEquals;\n\n/**\n * A unit test for {@link org.biojava.bio.structure.AtomPositionMap}.\n * @author dmyerstu\n */\npublic class AtomPositionMapTest {\n\n\t@Before\n\tpublic void setUp() throws Exception {\n\t\tcache = new AtomCache(); // TODO Should mock instead of depending on real data from AtomCache\n\t\tcache.setObsoleteBehavior(LocalPDBDirectory.ObsoleteBehavior.FETCH_OBSOLETE);\n\t}\n\t\n\tprivate AtomCache cache;\n\t\n\t/**\n\t * Tests with no insertion codes.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testEasy() throws IOException, StructureException { // no insertion codes\n\t\tString pdbId = \"1w0p\";\n\t\tint length = 92;\n\t\tResidueNumber start = new ResidueNumber(\"A\", 25, null);\n\t\tResidueNumber end = new ResidueNumber(\"A\", 117, null);\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tNavigableMap<ResidueNumber,Integer> navMap = map.getNavMap();\n\t\tfor (ResidueNumber n : navMap.keySet()) {\n\t\t\tassertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n\t\t}\n\t\tint realLength = map.calcLength(start, end);\n\t\tassertEquals(\"Real atom length is wrong\", length, realLength);\n\t}\n\n\t/**\n\t * Tests with insertion codes.\n\t * @throws StructureException \n\t * @throws IOException \n\t */\n\t@Test\n\tpublic void testHard() throws IOException, StructureException {\n\n\t\tString pdbId = \"1qdm\";\n\t\t// has 2 insertion code regions:\n\t\t// P at the beginning starting at 6P and ending at 27P, where 2 starts\n\t\t// S between 247 (before:1S) and 248 (after:104S)\n\n\t\tAtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n\t\tNavigableMap<ResidueNumber,Integer> navMap = map.getNavMap();\n\n\t\tfor (ResidueNumber n : navMap.keySet()) {\n\t\t\tassertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n\t\t}\n\t\t\n\t\tint length1 = 59;\n\t\tint length2 = 131;\n\t\tResidueNumber start = new ResidueNumber(\"A\", 246, null);\n\t\tResidueNumber mid = new ResidueNumber(\"A\", 85, 'S');\n\t\tResidueNumber end = new ResidueNumber(\"A\", 300, null);\n\t\tint realLength1 = map.calcLength(start, mid);\n\t\tassertEquals(\"Real atom length is wrong\", length1, realLength1);\n\t\tint realLength2 = map.calcLength(start, end);\n\t\tassertEquals(\"Real atom length is wrong\", length2, realLength2);\n\t}\n\n}\n","changedTest":"","commitMessage":"Switching AtomPositionMap to use more standard AminoAcid type detection\n","test_commitMessage":"","allZero":false}