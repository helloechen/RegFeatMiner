{"repository":"biojava","prod_path":"biojava-core/src/main/java/org/biojava/nbio/core/sequence/ChromosomeSequence.java","test_path":"biojava-core/src/test/java/org/biojava/nbio/core/sequence/ChromosomeSequenceTest.java","prod_time":"2024-04-18 15:26:14","test_time":"","type":"","proType":"EDIT","add_annotation_line":0,"add_call_line":0,"add_classname_line":0,"add_condition_line":0,"add_field_line":1,"add_import_line":0,"add_packageid_line":0,"add_parameter_line":0,"add_return_line":0,"del_annotation_line":0,"del_call_line":0,"del_classname_line":0,"del_condition_line":0,"del_field_line":1,"del_import_line":0,"del_packageid_line":0,"del_parameter_line":0,"del_return_line":0,"label":"NEGATIVE","prod_commitID":"b18212163e0fd9ff56da13ef258005b7d0decced","test_commitID":"","isfound":"not found test change","originPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.SequenceReader;\n\nimport java.util.LinkedHashMap;\n\n/**\n * A ChromosomeSequence is a DNASequence but keeps track of geneSequences\n * @author Scooter Willis\n */\npublic class ChromosomeSequence extends DNASequence {\n\n\tprivate int chromosomeNumber;\n\tprivate LinkedHashMap<String, GeneSequence> geneSequenceHashMap = new LinkedHashMap<String, GeneSequence>();\n\n\t/**\n\t * Empty constructor used by tools that need a proper Bean that allows the actual\n\t * sequence data to be set after construction. Not recommended\n\t */\n\tpublic ChromosomeSequence() {\n//        throw new UnsupportedOperationException(\"Null constructor not supported\");\n\t}\n\n\t/**\n\t * String is king and assume DNA\n\t * @param seqString\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ChromosomeSequence(String seqString) throws CompoundNotFoundException {\n\t\tsuper(seqString, DNACompoundSet.getDNACompoundSet());\n\t}\n\n\t/**\n\t * Fairly important constructor given the size of a ChromsomeSequence where the\n\t * ProxySequenceReader could load from disk via RandomAccessFile so that the sequence\n\t * doesn't need to be kept in memory. Could also be a NCBI proxy to load sequence\n\t * data as needed from remote web server.\n\t * @param proxyLoader\n\t */\n\tpublic ChromosomeSequence(SequenceReader<NucleotideCompound> proxyLoader) {\n\t\tsuper(proxyLoader, DNACompoundSet.getDNACompoundSet());\n\t}\n\n\t/**\n\t * Allows the creation of a ChromosomeSequence using String for the sequence with a custom CompoundSet\n\t * @param seqString\n\t * @param compoundSet\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ChromosomeSequence(String seqString, CompoundSet<NucleotideCompound> compoundSet) throws CompoundNotFoundException {\n\t\tsuper(seqString, compoundSet);\n\t}\n\n\t/**\n\t * Allows the creation of a ChromosomeSequence using a ProxyResequenceReader for the sequence with a custom CompoundSet\n\t * @param proxyLoader\n\t * @param compoundSet\n\t */\n\tpublic ChromosomeSequence(SequenceReader<NucleotideCompound> proxyLoader, CompoundSet<NucleotideCompound> compoundSet) {\n\t\tsuper(proxyLoader, compoundSet);\n\t}\n\n\t/**\n\t * @return the chromosomeNumber\n\t */\n\tpublic int getChromosomeNumber() {\n\t\treturn chromosomeNumber;\n\t}\n\n\t/**\n\t * @param chromosomeNumber the chromosomeNumber to set\n\t */\n\tpublic void setChromosomeNumber(int chromosomeNumber) {\n\t\tthis.chromosomeNumber = chromosomeNumber;\n\t}\n\n\t/**\n\t * Get the list of genes that have been added to the ChromosomeSequence where accession.toString is the key.\n\t * The list retains the order the genes are added\n\t * @return\n\t */\n\n\tpublic LinkedHashMap<String, GeneSequence> getGeneSequences() {\n\t\treturn geneSequenceHashMap;\n\t}\n\n\t/**\n\t *\n\t * @param accession\n\t * @return\n\t */\n\tpublic GeneSequence removeGeneSequence(String accession) {\n\t\treturn geneSequenceHashMap.remove(accession);\n\t}\n\n\t/**\n\t * Add a gene to the chromosome sequence using bioIndexing starts at 1 instead of 0. The\n\t * GeneSequence that is returned will have a reference to parent chromosome sequence\n\t * which actually contains the sequence data. Strand is important for positive and negative\n\t * direction where negative strand means we need reverse complement. If negative strand then\n\t * bioBegin will be greater than bioEnd\n\t * @param accession\n\t * @param bioBegin\n\t * @param bioEnd\n\t * @param strand\n\t * @return A GeneSequence\n\t */\n\tpublic GeneSequence addGene(AccessionID accession, int bioBegin, int bioEnd, Strand strand) {\n\t\tGeneSequence geneSequence = new GeneSequence(this, bioBegin, bioEnd, strand);\n\t\tgeneSequence.setAccession(accession);\n\t\tgeneSequenceHashMap.put(accession.toString(), geneSequence);\n\t\treturn geneSequence;\n\t}\n\n\t/**\n\t * Get the gene based on accession. Will return null if not found\n\t * @param accession\n\t * @return\n\t */\n\tpublic GeneSequence getGene(String accession) {\n\t\treturn geneSequenceHashMap.get(accession);\n\t}\n}\n","changedPro":"/*\n *                    BioJava development code\n *\n * This code may be freely distributed and modified under the\n * terms of the GNU Lesser General Public Licence.  This should\n * be distributed with the code.  If you do not have a copy,\n * see:\n *\n *      http://www.gnu.org/copyleft/lesser.html\n *\n * Copyright for this code is held jointly by the individual\n * authors.  These should be listed in @author doc comments.\n *\n * For more information on the BioJava project and its aims,\n * or to join the biojava-l mailing list, visit the home page\n * at:\n *\n *      http://www.biojava.org/\n *\n * Created on DATE\n *\n */\npackage org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.biojava.nbio.core.sequence.compound.DNACompoundSet;\nimport org.biojava.nbio.core.sequence.compound.NucleotideCompound;\nimport org.biojava.nbio.core.sequence.template.CompoundSet;\nimport org.biojava.nbio.core.sequence.template.SequenceReader;\n\nimport java.util.LinkedHashMap;\n\n/**\n * A ChromosomeSequence is a DNASequence but keeps track of geneSequences\n * @author Scooter Willis\n */\npublic class ChromosomeSequence extends DNASequence {\n\n\tprivate int chromosomeNumber;\n\tprivate LinkedHashMap<String, GeneSequence> geneSequenceHashMap = new LinkedHashMap<>();\n\n\t/**\n\t * Empty constructor used by tools that need a proper Bean that allows the actual\n\t * sequence data to be set after construction. Not recommended\n\t */\n\tpublic ChromosomeSequence() {\n//        throw new UnsupportedOperationException(\"Null constructor not supported\");\n\t}\n\n\t/**\n\t * String is king and assume DNA\n\t * @param seqString\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ChromosomeSequence(String seqString) throws CompoundNotFoundException {\n\t\tsuper(seqString, DNACompoundSet.getDNACompoundSet());\n\t}\n\n\t/**\n\t * Fairly important constructor given the size of a ChromsomeSequence where the\n\t * ProxySequenceReader could load from disk via RandomAccessFile so that the sequence\n\t * doesn't need to be kept in memory. Could also be a NCBI proxy to load sequence\n\t * data as needed from remote web server.\n\t * @param proxyLoader\n\t */\n\tpublic ChromosomeSequence(SequenceReader<NucleotideCompound> proxyLoader) {\n\t\tsuper(proxyLoader, DNACompoundSet.getDNACompoundSet());\n\t}\n\n\t/**\n\t * Allows the creation of a ChromosomeSequence using String for the sequence with a custom CompoundSet\n\t * @param seqString\n\t * @param compoundSet\n\t * @throws CompoundNotFoundException\n\t */\n\tpublic ChromosomeSequence(String seqString, CompoundSet<NucleotideCompound> compoundSet) throws CompoundNotFoundException {\n\t\tsuper(seqString, compoundSet);\n\t}\n\n\t/**\n\t * Allows the creation of a ChromosomeSequence using a ProxyResequenceReader for the sequence with a custom CompoundSet\n\t * @param proxyLoader\n\t * @param compoundSet\n\t */\n\tpublic ChromosomeSequence(SequenceReader<NucleotideCompound> proxyLoader, CompoundSet<NucleotideCompound> compoundSet) {\n\t\tsuper(proxyLoader, compoundSet);\n\t}\n\n\t/**\n\t * @return the chromosomeNumber\n\t */\n\tpublic int getChromosomeNumber() {\n\t\treturn chromosomeNumber;\n\t}\n\n\t/**\n\t * @param chromosomeNumber the chromosomeNumber to set\n\t */\n\tpublic void setChromosomeNumber(int chromosomeNumber) {\n\t\tthis.chromosomeNumber = chromosomeNumber;\n\t}\n\n\t/**\n\t * Get the list of genes that have been added to the ChromosomeSequence where accession.toString is the key.\n\t * The list retains the order the genes are added\n\t * @return\n\t */\n\n\tpublic LinkedHashMap<String, GeneSequence> getGeneSequences() {\n\t\treturn geneSequenceHashMap;\n\t}\n\n\t/**\n\t *\n\t * @param accession\n\t * @return\n\t */\n\tpublic GeneSequence removeGeneSequence(String accession) {\n\t\treturn geneSequenceHashMap.remove(accession);\n\t}\n\n\t/**\n\t * Add a gene to the chromosome sequence using bioIndexing starts at 1 instead of 0. The\n\t * GeneSequence that is returned will have a reference to parent chromosome sequence\n\t * which actually contains the sequence data. Strand is important for positive and negative\n\t * direction where negative strand means we need reverse complement. If negative strand then\n\t * bioBegin will be greater than bioEnd\n\t * @param accession\n\t * @param bioBegin\n\t * @param bioEnd\n\t * @param strand\n\t * @return A GeneSequence\n\t */\n\tpublic GeneSequence addGene(AccessionID accession, int bioBegin, int bioEnd, Strand strand) {\n\t\tGeneSequence geneSequence = new GeneSequence(this, bioBegin, bioEnd, strand);\n\t\tgeneSequence.setAccession(accession);\n\t\tgeneSequenceHashMap.put(accession.toString(), geneSequence);\n\t\treturn geneSequence;\n\t}\n\n\t/**\n\t * Get the gene based on accession. Will return null if not found\n\t * @param accession\n\t * @return\n\t */\n\tpublic GeneSequence getGene(String accession) {\n\t\treturn geneSequenceHashMap.get(accession);\n\t}\n}\n","originTest":"package org.biojava.nbio.core.sequence;\n\nimport org.biojava.nbio.core.exceptions.CompoundNotFoundException;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.EnumSource;\nimport org.junit.jupiter.params.provider.ValueSource;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\nclass ChromosomeSequenceTest {\n\n    static final String CHROMOSOME_SEQ = \"ATATCGACTTATATATATATATATATATATATATACGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCATATATATATATATATATATATACGCGCGCGCGCGCGCGCATATATATATATATATATATATATATATATATACGCGCGCGCGCGCGCGCGCGCGCGCGCGCGCATATATATATATATATATATATACGCGCGCGCGCGCGCGC\";\n\n    @Nested\n    class AfterValidConstruction {\n        ChromosomeSequence seq = null;\n\n        @BeforeEach\n        void before() throws CompoundNotFoundException {\n            seq = new ChromosomeSequence(CHROMOSOME_SEQ);\n        }\n\n        @Test\n        void beginAndEndAreLengthOfSequence() {\n            assertEquals(1, seq.getBioBegin());\n            assertEquals(210, seq.getBioEnd());\n            assertEquals(210, seq.getLength());\n        }\n\n        @Test\n        void noGenesAreDefined() {\n            assertEquals(0, seq.getGeneSequences().size());\n        }\n\n        @Test\n        void chromosomeNumberIsZero() {\n            assertEquals(0, seq.getChromosomeNumber());\n        }\n\n        @Test\n        void sequenceTypeIsUnknown() {\n            assertEquals(DNASequence.DNAType.UNKNOWN, seq.getDNAType());\n        }\n    }\n\n    @Nested\n    class AfterConstructionWithEmptyString {\n        ChromosomeSequence seq = null;\n\n        @BeforeEach\n        void before() throws CompoundNotFoundException {\n            seq = new ChromosomeSequence(\"\");\n        }\n\n        @Test\n        void lengthIsZero() {\n            assertEquals(0, seq.getLength());\n        }\n\n        @Test\n        void endIsBeforeBeginning() {\n            assertEquals(0, seq.getBioEnd());\n            assertEquals(1, seq.getBioBegin());\n        }\n\n    }\n\n    @Test\n    void nullSequenceNotAllowed() throws CompoundNotFoundException {\n        assertThrows(NullPointerException.class, () -> new ChromosomeSequence((String) null));\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {Integer.MAX_VALUE, Integer.MIN_VALUE, 100, 0, -1, -100})\n    void anyIntegerIsValidChromosomeNumber(int value) throws CompoundNotFoundException {\n        ChromosomeSequence seq = new ChromosomeSequence(CHROMOSOME_SEQ);\n        seq.setChromosomeNumber(value);\n        assertEquals(value, seq.getChromosomeNumber());\n    }\n\n    @ParameterizedTest\n    @EnumSource(DNASequence.DNAType.class)\n    void anyDNATypeIsValid(DNASequence.DNAType dnaType) throws CompoundNotFoundException {\n        ChromosomeSequence seq = new ChromosomeSequence(CHROMOSOME_SEQ);\n        seq.setDNAType(dnaType);\n        assertEquals(dnaType, seq.getDNAType());\n    }\n\n    @Nested\n    class AddingAndRemovingGeneSequences {\n        ChromosomeSequence seq = null;\n        @BeforeEach\n        void before() throws CompoundNotFoundException {\n            seq = new ChromosomeSequence(CHROMOSOME_SEQ);\n        }\n        @Test\n        void canAddSameGeneTwice(){\n            seq.addGene(new AccessionID(\"ABCDE1\"), 1, 20, Strand.POSITIVE);\n            assertEquals(1, seq.getGeneSequences().size());\n            seq.addGene(new AccessionID(\"ABCDE1\"), 1, 20, Strand.POSITIVE);\n            assertEquals(1, seq.getGeneSequences().size());\n        }\n\n        @Test\n        void isOKToRemoveNonExistentSequence(){\n            seq.removeGeneSequence(\"XXX\");\n        }\n\n        @Test\n        void addAndRemove(){\n            final String accessionId = \"ABCDE1\";\n            GeneSequence geneSequence = seq.addGene(new AccessionID(accessionId), 1, 20, Strand.POSITIVE);\n            assertEquals(geneSequence.getAccession(), seq.getGene(accessionId).getAccession());\n            assertEquals(1, seq.getGeneSequences().size());\n            seq.removeGeneSequence(accessionId);\n            assertEquals(0, seq.getGeneSequences().size());\n        }\n\n        @Test\n        void geneSequenceHasCorrectLength(){\n            final String accessionId = \"ABCDE1\";\n            GeneSequence geneSequence = seq.addGene(new AccessionID(accessionId), 1, 20, Strand.POSITIVE);\n            assertEquals(20, geneSequence.getLength());\n        }\n\n        @Test\n        void geneSequenceCanHaveBeginAndEndOutsideOfChromosomeSeq(){\n            final String accessionId = \"ABCDE1\";\n            GeneSequence geneSequence = seq.addGene(new AccessionID(accessionId), Integer.MAX_VALUE-10, Integer.MAX_VALUE, Strand.POSITIVE);\n            assertEquals(11, geneSequence.getLength());\n\n        }\n    }\n\n    @Test\n    void addAndRemoveGeneSequence() throws CompoundNotFoundException {\n        ChromosomeSequence seq = new ChromosomeSequence(CHROMOSOME_SEQ);\n        seq.addGene(new AccessionID(\"ABCDE1\"), 1, 20, Strand.POSITIVE);\n        assertEquals(1, seq.getGeneSequences().size());\n\n\n        // still present\n        assertEquals(1, seq.getGeneSequences().size());\n        // can be added again with sam\n        seq.addGene(new AccessionID(\"ABCDE1\"), 1, 20, Strand.POSITIVE);\n        assertEquals(1, seq.getGeneSequences().size());\n\n    }\n\n\n\n    @Test\n    void addGene() {\n    }\n\n    @Test\n    void getGene() {\n    }\n}","changedTest":"","commitMessage":"Fix sonar issue S2293 Replace the type specification in this constructor call with the diamond operator ('<>')\n","test_commitMessage":"","allZero":false}